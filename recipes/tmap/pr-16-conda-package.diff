From fc29e3c7ca5fb2fdde0d311691b5c953e1695b4b Mon Sep 17 00:00:00 2001
From: Hadrien Mary <hadrien.mary@gmail.com>
Date: Mon, 31 Aug 2020 17:53:15 -0400
Subject: [PATCH 1/4] Use bind instead of bind2nd

---
 tmap/tmap/analyse.cc | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/tmap/tmap/analyse.cc b/tmap/tmap/analyse.cc
index b282b74..7cfe52e 100644
--- a/tmap/tmap/analyse.cc
+++ b/tmap/tmap/analyse.cc
@@ -30,7 +30,7 @@ namespace {
 
     std::vector<float> diff(weights.size());
     std::transform(weights.begin(), weights.end(), diff.begin(),
-                  std::bind2nd(std::minus<float>(), mean));
+                  std::bind(std::minus<float>(), std::placeholders::_1, mean));
     float sq_sum = std::inner_product(diff.begin(), diff.end(), diff.begin(), 0.0);
     float stdev = std::sqrt(sq_sum / weights.size());
 
@@ -64,7 +64,7 @@ namespace {
 
       std::vector<float> diff(weights.size());
       std::transform(weights.begin(), weights.end(), diff.begin(),
-                    std::bind2nd(std::minus<float>(), mean));
+                    std::bind(std::minus<float>(), std::placeholders::_1, mean));
       float sq_sum = std::inner_product(diff.begin(), diff.end(), diff.begin(), 0.0);
       float stdev = std::sqrt(sq_sum / weights.size());
 

From ec7a69b9939c62d147b479c2bc1d7f8dc506909e Mon Sep 17 00:00:00 2001
From: Hadrien Mary <hadrien.mary@gmail.com>
Date: Mon, 31 Aug 2020 17:53:52 -0400
Subject: [PATCH 2/4] Fix x64 flag in setup.py

---
 tmap/setup.py | 2 --
 1 file changed, 2 deletions(-)

diff --git a/tmap/setup.py b/tmap/setup.py
index 28c0d06..4d7e240 100644
--- a/tmap/setup.py
+++ b/tmap/setup.py
@@ -54,8 +54,6 @@ def build_extension(self, ext):
             cmake_args += [
                 "-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_{}={}".format(cfg.upper(), extdir)
             ]
-            if sys.maxsize > 2 ** 32:
-                cmake_args += ["-A", "x64"]
             build_args += ["--", "/m"]
         elif platform.system() == 'Darwin':
             cmake_args += ['-DOpenMP_C_FLAG=-fopenmp']

From b566512d3cb0d45202d334a33a5b4e79b5d342e6 Mon Sep 17 00:00:00 2001
From: Hadrien Mary <hadrien.mary@gmail.com>
Date: Mon, 31 Aug 2020 18:09:32 -0400
Subject: [PATCH 3/4] remove conda logic in cmake

---
 tmap/CMakeLists.txt | 9 ---------
 1 file changed, 9 deletions(-)

diff --git a/tmap/CMakeLists.txt b/tmap/CMakeLists.txt
index 723a7ae..4621a7f 100644
--- a/tmap/CMakeLists.txt
+++ b/tmap/CMakeLists.txt
@@ -11,15 +11,6 @@ else()
     set(CMAKE_CXX_FLAGS_RELEASE "-O3 -funroll-loops -fopenmp")
 endif(MSVC)
 
-
-if (DEFINED ENV{CONDA_PREFIX})
-    SET(OGDF_INCLUDE "$ENV{CONDA_PREFIX}/include")
-    SET(OGDF_LIB "$ENV{CONDA_PREFIX}/lib")
-
-    include_directories(${OGDF_INCLUDE})
-    link_directories(${OGDF_LIB})
-endif()
-
 # find_package(OpenMP)
 # if (OPENMP_FOUND)
 #    set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}")

From 6fc94c3abf8c55e2745b7e77c8eb771c5b7cf93b Mon Sep 17 00:00:00 2001
From: Hadrien Mary <hadrien.mary@gmail.com>
Date: Mon, 31 Aug 2020 18:10:42 -0400
Subject: [PATCH 4/4] remove pybind11 hard coded dep

---
 tmap/CMakeLists.txt                           |    3 -
 .../CMakeDirectoryInformation.cmake           |   16 -
 tmap/lib/pybind11/CMakeFiles/progress.marks   |    1 -
 tmap/lib/pybind11/CMakeLists.txt              |  154 --
 tmap/lib/pybind11/CONTRIBUTING.md             |   37 -
 tmap/lib/pybind11/ISSUE_TEMPLATE.md           |   17 -
 tmap/lib/pybind11/LICENSE                     |   36 -
 tmap/lib/pybind11/MANIFEST.in                 |    2 -
 tmap/lib/pybind11/Makefile                    |  134 --
 tmap/lib/pybind11/README.md                   |  129 --
 tmap/lib/pybind11/cmake_install.cmake         |   39 -
 tmap/lib/pybind11/docs/Doxyfile               |   20 -
 tmap/lib/pybind11/docs/Makefile               |  192 --
 .../pybind11/docs/_static/theme_overrides.css |   11 -
 .../pybind11/docs/advanced/cast/chrono.rst    |   81 -
 .../pybind11/docs/advanced/cast/custom.rst    |   91 -
 .../lib/pybind11/docs/advanced/cast/eigen.rst |  310 ---
 .../docs/advanced/cast/functional.rst         |  109 -
 .../lib/pybind11/docs/advanced/cast/index.rst |   42 -
 .../pybind11/docs/advanced/cast/overview.rst  |  163 --
 tmap/lib/pybind11/docs/advanced/cast/stl.rst  |  243 --
 .../pybind11/docs/advanced/cast/strings.rst   |  303 ---
 tmap/lib/pybind11/docs/advanced/classes.rst   | 1033 ---------
 tmap/lib/pybind11/docs/advanced/embedding.rst |  256 --
 .../lib/pybind11/docs/advanced/exceptions.rst |  142 --
 tmap/lib/pybind11/docs/advanced/functions.rst |  486 ----
 tmap/lib/pybind11/docs/advanced/misc.rst      |  272 ---
 .../pybind11/docs/advanced/pycpp/index.rst    |   13 -
 .../pybind11/docs/advanced/pycpp/numpy.rst    |  366 ---
 .../pybind11/docs/advanced/pycpp/object.rst   |   98 -
 .../docs/advanced/pycpp/utilities.rst         |  144 --
 .../lib/pybind11/docs/advanced/smart_ptrs.rst |  173 --
 tmap/lib/pybind11/docs/basics.rst             |  293 ---
 tmap/lib/pybind11/docs/benchmark.py           |   88 -
 tmap/lib/pybind11/docs/benchmark.rst          |   97 -
 tmap/lib/pybind11/docs/changelog.rst          |  885 -------
 tmap/lib/pybind11/docs/classes.rst            |  500 ----
 tmap/lib/pybind11/docs/compiling.rst          |  273 ---
 tmap/lib/pybind11/docs/conf.py                |  332 ---
 tmap/lib/pybind11/docs/faq.rst                |  273 ---
 tmap/lib/pybind11/docs/index.rst              |   47 -
 tmap/lib/pybind11/docs/intro.rst              |   95 -
 tmap/lib/pybind11/docs/limitations.rst        |   20 -
 .../docs/pybind11_vs_boost_python1.svg        |  427 ----
 .../docs/pybind11_vs_boost_python2.svg        |  427 ----
 tmap/lib/pybind11/docs/reference.rst          |  102 -
 tmap/lib/pybind11/docs/release.rst            |   24 -
 tmap/lib/pybind11/docs/requirements.txt       |    1 -
 tmap/lib/pybind11/docs/upgrade.rst            |  377 ---
 tmap/lib/pybind11/include/pybind11/attr.h     |  489 ----
 .../pybind11/include/pybind11/buffer_info.h   |  108 -
 tmap/lib/pybind11/include/pybind11/cast.h     | 2049 -----------------
 tmap/lib/pybind11/include/pybind11/chrono.h   |  162 --
 tmap/lib/pybind11/include/pybind11/complex.h  |   61 -
 .../pybind11/include/pybind11/detail/class.h  |  606 -----
 .../pybind11/include/pybind11/detail/common.h |  799 -------
 .../pybind11/include/pybind11/detail/descr.h  |  185 --
 .../pybind11/include/pybind11/detail/init.h   |  325 ---
 .../include/pybind11/detail/internals.h       |  247 --
 .../pybind11/include/pybind11/detail/typeid.h |   53 -
 tmap/lib/pybind11/include/pybind11/eigen.h    |  610 -----
 tmap/lib/pybind11/include/pybind11/embed.h    |  193 --
 tmap/lib/pybind11/include/pybind11/eval.h     |  117 -
 .../pybind11/include/pybind11/functional.h    |   85 -
 tmap/lib/pybind11/include/pybind11/iostream.h |  200 --
 tmap/lib/pybind11/include/pybind11/numpy.h    | 1598 -------------
 .../lib/pybind11/include/pybind11/operators.h |  168 --
 tmap/lib/pybind11/include/pybind11/options.h  |   65 -
 tmap/lib/pybind11/include/pybind11/pybind11.h | 1937 ----------------
 tmap/lib/pybind11/include/pybind11/pytypes.h  | 1330 -----------
 tmap/lib/pybind11/include/pybind11/stl.h      |  369 ---
 tmap/lib/pybind11/include/pybind11/stl_bind.h |  599 -----
 tmap/lib/pybind11/pybind11/__init__.py        |   11 -
 tmap/lib/pybind11/pybind11/__main__.py        |   37 -
 tmap/lib/pybind11/pybind11/_version.py        |    2 -
 tmap/lib/pybind11/setup.cfg                   |   10 -
 tmap/lib/pybind11/setup.py                    |  107 -
 tmap/lib/pybind11/tests/CMakeLists.txt        |  234 --
 tmap/lib/pybind11/tests/conftest.py           |  241 --
 tmap/lib/pybind11/tests/constructor_stats.h   |  276 ---
 tmap/lib/pybind11/tests/local_bindings.h      |   60 -
 tmap/lib/pybind11/tests/object.h              |  175 --
 .../tests/pybind11_cross_module_tests.cpp     |  107 -
 tmap/lib/pybind11/tests/pybind11_tests.cpp    |   93 -
 tmap/lib/pybind11/tests/pybind11_tests.h      |   65 -
 tmap/lib/pybind11/tests/pytest.ini            |   15 -
 tmap/lib/pybind11/tests/test_buffers.cpp      |  169 --
 tmap/lib/pybind11/tests/test_buffers.py       |   83 -
 .../pybind11/tests/test_builtin_casters.cpp   |  156 --
 .../pybind11/tests/test_builtin_casters.py    |  322 ---
 .../lib/pybind11/tests/test_call_policies.cpp |   97 -
 tmap/lib/pybind11/tests/test_call_policies.py |  168 --
 tmap/lib/pybind11/tests/test_callbacks.cpp    |  149 --
 tmap/lib/pybind11/tests/test_callbacks.py     |  107 -
 tmap/lib/pybind11/tests/test_chrono.cpp       |   47 -
 tmap/lib/pybind11/tests/test_chrono.py        |  101 -
 tmap/lib/pybind11/tests/test_class.cpp        |  357 ---
 tmap/lib/pybind11/tests/test_class.py         |  235 --
 .../tests/test_cmake_build/CMakeLists.txt     |   58 -
 .../pybind11/tests/test_cmake_build/embed.cpp |   21 -
 .../installed_embed/CMakeLists.txt            |   15 -
 .../installed_function/CMakeLists.txt         |   12 -
 .../installed_target/CMakeLists.txt           |   22 -
 .../pybind11/tests/test_cmake_build/main.cpp  |    6 -
 .../subdirectory_embed/CMakeLists.txt         |   25 -
 .../subdirectory_function/CMakeLists.txt      |    8 -
 .../subdirectory_target/CMakeLists.txt        |   15 -
 .../pybind11/tests/test_cmake_build/test.py   |    5 -
 .../tests/test_constants_and_functions.cpp    |  113 -
 .../tests/test_constants_and_functions.py     |   39 -
 tmap/lib/pybind11/tests/test_copy_move.cpp    |  213 --
 tmap/lib/pybind11/tests/test_copy_move.py     |  112 -
 .../pybind11/tests/test_docstring_options.cpp |   61 -
 .../pybind11/tests/test_docstring_options.py  |   38 -
 tmap/lib/pybind11/tests/test_eigen.cpp        |  317 ---
 tmap/lib/pybind11/tests/test_eigen.py         |  681 ------
 .../pybind11/tests/test_embed/CMakeLists.txt  |   34 -
 tmap/lib/pybind11/tests/test_embed/catch.cpp  |   16 -
 .../tests/test_embed/test_interpreter.cpp     |  218 --
 .../tests/test_embed/test_interpreter.py      |    9 -
 tmap/lib/pybind11/tests/test_enum.cpp         |   71 -
 tmap/lib/pybind11/tests/test_enum.py          |  121 -
 tmap/lib/pybind11/tests/test_eval.cpp         |   91 -
 tmap/lib/pybind11/tests/test_eval.py          |   17 -
 tmap/lib/pybind11/tests/test_eval_call.py     |    4 -
 tmap/lib/pybind11/tests/test_exceptions.cpp   |  168 --
 tmap/lib/pybind11/tests/test_exceptions.py    |  144 --
 .../tests/test_factory_constructors.cpp       |  337 ---
 .../tests/test_factory_constructors.py        |  459 ----
 tmap/lib/pybind11/tests/test_iostream.cpp     |   73 -
 tmap/lib/pybind11/tests/test_iostream.py      |  203 --
 .../tests/test_kwargs_and_defaults.cpp        |   71 -
 .../tests/test_kwargs_and_defaults.py         |  107 -
 .../pybind11/tests/test_local_bindings.cpp    |   97 -
 .../lib/pybind11/tests/test_local_bindings.py |  210 --
 .../tests/test_methods_and_attributes.cpp     |  446 ----
 .../tests/test_methods_and_attributes.py      |  476 ----
 tmap/lib/pybind11/tests/test_modules.cpp      |   98 -
 tmap/lib/pybind11/tests/test_modules.py       |   72 -
 .../tests/test_multiple_inheritance.cpp       |  220 --
 .../tests/test_multiple_inheritance.py        |  349 ---
 tmap/lib/pybind11/tests/test_numpy_array.cpp  |  295 ---
 tmap/lib/pybind11/tests/test_numpy_array.py   |  402 ----
 tmap/lib/pybind11/tests/test_numpy_dtypes.cpp |  451 ----
 tmap/lib/pybind11/tests/test_numpy_dtypes.py  |  298 ---
 .../pybind11/tests/test_numpy_vectorize.cpp   |   89 -
 .../pybind11/tests/test_numpy_vectorize.py    |  196 --
 tmap/lib/pybind11/tests/test_opaque_types.cpp |   63 -
 tmap/lib/pybind11/tests/test_opaque_types.py  |   46 -
 .../tests/test_operator_overloading.cpp       |  146 --
 .../tests/test_operator_overloading.py        |  106 -
 tmap/lib/pybind11/tests/test_pickling.cpp     |  130 --
 tmap/lib/pybind11/tests/test_pickling.py      |   36 -
 tmap/lib/pybind11/tests/test_pytypes.cpp      |  266 ---
 tmap/lib/pybind11/tests/test_pytypes.py       |  238 --
 .../tests/test_sequences_and_iterators.cpp    |  334 ---
 .../tests/test_sequences_and_iterators.py     |  158 --
 tmap/lib/pybind11/tests/test_smart_ptr.cpp    |  270 ---
 tmap/lib/pybind11/tests/test_smart_ptr.py     |  220 --
 tmap/lib/pybind11/tests/test_stl.cpp          |  233 --
 tmap/lib/pybind11/tests/test_stl.py           |  178 --
 tmap/lib/pybind11/tests/test_stl_binders.cpp  |  111 -
 tmap/lib/pybind11/tests/test_stl_binders.py   |  181 --
 .../pybind11/tests/test_virtual_functions.cpp |  450 ----
 .../pybind11/tests/test_virtual_functions.py  |  371 ---
 tmap/lib/pybind11/tools/FindCatch.cmake       |   57 -
 tmap/lib/pybind11/tools/FindEigen3.cmake      |   81 -
 .../pybind11/tools/FindPythonLibsNew.cmake    |  195 --
 tmap/lib/pybind11/tools/check-style.sh        |   82 -
 tmap/lib/pybind11/tools/libsize.py            |   38 -
 tmap/lib/pybind11/tools/mkdoc.py              |  302 ---
 .../pybind11/tools/pybind11Config.cmake.in    |  100 -
 tmap/lib/pybind11/tools/pybind11Tools.cmake   |  202 --
 173 files changed, 37353 deletions(-)
 delete mode 100644 tmap/lib/pybind11/CMakeFiles/CMakeDirectoryInformation.cmake
 delete mode 100644 tmap/lib/pybind11/CMakeFiles/progress.marks
 delete mode 100644 tmap/lib/pybind11/CMakeLists.txt
 delete mode 100644 tmap/lib/pybind11/CONTRIBUTING.md
 delete mode 100644 tmap/lib/pybind11/ISSUE_TEMPLATE.md
 delete mode 100644 tmap/lib/pybind11/LICENSE
 delete mode 100644 tmap/lib/pybind11/MANIFEST.in
 delete mode 100644 tmap/lib/pybind11/Makefile
 delete mode 100644 tmap/lib/pybind11/README.md
 delete mode 100644 tmap/lib/pybind11/cmake_install.cmake
 delete mode 100644 tmap/lib/pybind11/docs/Doxyfile
 delete mode 100644 tmap/lib/pybind11/docs/Makefile
 delete mode 100644 tmap/lib/pybind11/docs/_static/theme_overrides.css
 delete mode 100644 tmap/lib/pybind11/docs/advanced/cast/chrono.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/cast/custom.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/cast/eigen.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/cast/functional.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/cast/index.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/cast/overview.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/cast/stl.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/cast/strings.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/classes.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/embedding.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/exceptions.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/functions.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/misc.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/pycpp/index.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/pycpp/numpy.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/pycpp/object.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/pycpp/utilities.rst
 delete mode 100644 tmap/lib/pybind11/docs/advanced/smart_ptrs.rst
 delete mode 100644 tmap/lib/pybind11/docs/basics.rst
 delete mode 100644 tmap/lib/pybind11/docs/benchmark.py
 delete mode 100644 tmap/lib/pybind11/docs/benchmark.rst
 delete mode 100644 tmap/lib/pybind11/docs/changelog.rst
 delete mode 100644 tmap/lib/pybind11/docs/classes.rst
 delete mode 100644 tmap/lib/pybind11/docs/compiling.rst
 delete mode 100644 tmap/lib/pybind11/docs/conf.py
 delete mode 100644 tmap/lib/pybind11/docs/faq.rst
 delete mode 100644 tmap/lib/pybind11/docs/index.rst
 delete mode 100644 tmap/lib/pybind11/docs/intro.rst
 delete mode 100644 tmap/lib/pybind11/docs/limitations.rst
 delete mode 100644 tmap/lib/pybind11/docs/pybind11_vs_boost_python1.svg
 delete mode 100644 tmap/lib/pybind11/docs/pybind11_vs_boost_python2.svg
 delete mode 100644 tmap/lib/pybind11/docs/reference.rst
 delete mode 100644 tmap/lib/pybind11/docs/release.rst
 delete mode 100644 tmap/lib/pybind11/docs/requirements.txt
 delete mode 100644 tmap/lib/pybind11/docs/upgrade.rst
 delete mode 100644 tmap/lib/pybind11/include/pybind11/attr.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/buffer_info.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/cast.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/chrono.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/complex.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/detail/class.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/detail/common.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/detail/descr.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/detail/init.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/detail/internals.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/detail/typeid.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/eigen.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/embed.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/eval.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/functional.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/iostream.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/numpy.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/operators.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/options.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/pybind11.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/pytypes.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/stl.h
 delete mode 100644 tmap/lib/pybind11/include/pybind11/stl_bind.h
 delete mode 100644 tmap/lib/pybind11/pybind11/__init__.py
 delete mode 100644 tmap/lib/pybind11/pybind11/__main__.py
 delete mode 100644 tmap/lib/pybind11/pybind11/_version.py
 delete mode 100644 tmap/lib/pybind11/setup.cfg
 delete mode 100644 tmap/lib/pybind11/setup.py
 delete mode 100644 tmap/lib/pybind11/tests/CMakeLists.txt
 delete mode 100644 tmap/lib/pybind11/tests/conftest.py
 delete mode 100644 tmap/lib/pybind11/tests/constructor_stats.h
 delete mode 100644 tmap/lib/pybind11/tests/local_bindings.h
 delete mode 100644 tmap/lib/pybind11/tests/object.h
 delete mode 100644 tmap/lib/pybind11/tests/pybind11_cross_module_tests.cpp
 delete mode 100644 tmap/lib/pybind11/tests/pybind11_tests.cpp
 delete mode 100644 tmap/lib/pybind11/tests/pybind11_tests.h
 delete mode 100644 tmap/lib/pybind11/tests/pytest.ini
 delete mode 100644 tmap/lib/pybind11/tests/test_buffers.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_buffers.py
 delete mode 100644 tmap/lib/pybind11/tests/test_builtin_casters.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_builtin_casters.py
 delete mode 100644 tmap/lib/pybind11/tests/test_call_policies.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_call_policies.py
 delete mode 100644 tmap/lib/pybind11/tests/test_callbacks.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_callbacks.py
 delete mode 100644 tmap/lib/pybind11/tests/test_chrono.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_chrono.py
 delete mode 100644 tmap/lib/pybind11/tests/test_class.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_class.py
 delete mode 100644 tmap/lib/pybind11/tests/test_cmake_build/CMakeLists.txt
 delete mode 100644 tmap/lib/pybind11/tests/test_cmake_build/embed.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_cmake_build/installed_embed/CMakeLists.txt
 delete mode 100644 tmap/lib/pybind11/tests/test_cmake_build/installed_function/CMakeLists.txt
 delete mode 100644 tmap/lib/pybind11/tests/test_cmake_build/installed_target/CMakeLists.txt
 delete mode 100644 tmap/lib/pybind11/tests/test_cmake_build/main.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt
 delete mode 100644 tmap/lib/pybind11/tests/test_cmake_build/subdirectory_function/CMakeLists.txt
 delete mode 100644 tmap/lib/pybind11/tests/test_cmake_build/subdirectory_target/CMakeLists.txt
 delete mode 100644 tmap/lib/pybind11/tests/test_cmake_build/test.py
 delete mode 100644 tmap/lib/pybind11/tests/test_constants_and_functions.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_constants_and_functions.py
 delete mode 100644 tmap/lib/pybind11/tests/test_copy_move.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_copy_move.py
 delete mode 100644 tmap/lib/pybind11/tests/test_docstring_options.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_docstring_options.py
 delete mode 100644 tmap/lib/pybind11/tests/test_eigen.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_eigen.py
 delete mode 100644 tmap/lib/pybind11/tests/test_embed/CMakeLists.txt
 delete mode 100644 tmap/lib/pybind11/tests/test_embed/catch.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_embed/test_interpreter.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_embed/test_interpreter.py
 delete mode 100644 tmap/lib/pybind11/tests/test_enum.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_enum.py
 delete mode 100644 tmap/lib/pybind11/tests/test_eval.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_eval.py
 delete mode 100644 tmap/lib/pybind11/tests/test_eval_call.py
 delete mode 100644 tmap/lib/pybind11/tests/test_exceptions.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_exceptions.py
 delete mode 100644 tmap/lib/pybind11/tests/test_factory_constructors.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_factory_constructors.py
 delete mode 100644 tmap/lib/pybind11/tests/test_iostream.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_iostream.py
 delete mode 100644 tmap/lib/pybind11/tests/test_kwargs_and_defaults.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_kwargs_and_defaults.py
 delete mode 100644 tmap/lib/pybind11/tests/test_local_bindings.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_local_bindings.py
 delete mode 100644 tmap/lib/pybind11/tests/test_methods_and_attributes.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_methods_and_attributes.py
 delete mode 100644 tmap/lib/pybind11/tests/test_modules.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_modules.py
 delete mode 100644 tmap/lib/pybind11/tests/test_multiple_inheritance.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_multiple_inheritance.py
 delete mode 100644 tmap/lib/pybind11/tests/test_numpy_array.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_numpy_array.py
 delete mode 100644 tmap/lib/pybind11/tests/test_numpy_dtypes.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_numpy_dtypes.py
 delete mode 100644 tmap/lib/pybind11/tests/test_numpy_vectorize.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_numpy_vectorize.py
 delete mode 100644 tmap/lib/pybind11/tests/test_opaque_types.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_opaque_types.py
 delete mode 100644 tmap/lib/pybind11/tests/test_operator_overloading.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_operator_overloading.py
 delete mode 100644 tmap/lib/pybind11/tests/test_pickling.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_pickling.py
 delete mode 100644 tmap/lib/pybind11/tests/test_pytypes.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_pytypes.py
 delete mode 100644 tmap/lib/pybind11/tests/test_sequences_and_iterators.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_sequences_and_iterators.py
 delete mode 100644 tmap/lib/pybind11/tests/test_smart_ptr.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_smart_ptr.py
 delete mode 100644 tmap/lib/pybind11/tests/test_stl.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_stl.py
 delete mode 100644 tmap/lib/pybind11/tests/test_stl_binders.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_stl_binders.py
 delete mode 100644 tmap/lib/pybind11/tests/test_virtual_functions.cpp
 delete mode 100644 tmap/lib/pybind11/tests/test_virtual_functions.py
 delete mode 100644 tmap/lib/pybind11/tools/FindCatch.cmake
 delete mode 100644 tmap/lib/pybind11/tools/FindEigen3.cmake
 delete mode 100644 tmap/lib/pybind11/tools/FindPythonLibsNew.cmake
 delete mode 100755 tmap/lib/pybind11/tools/check-style.sh
 delete mode 100644 tmap/lib/pybind11/tools/libsize.py
 delete mode 100644 tmap/lib/pybind11/tools/mkdoc.py
 delete mode 100644 tmap/lib/pybind11/tools/pybind11Config.cmake.in
 delete mode 100644 tmap/lib/pybind11/tools/pybind11Tools.cmake

diff --git a/tmap/CMakeLists.txt b/tmap/CMakeLists.txt
index 4621a7f..c6f448b 100644
--- a/tmap/CMakeLists.txt
+++ b/tmap/CMakeLists.txt
@@ -28,9 +28,6 @@ SET(SOURCE_DIR "tmap")
 include_directories(${SOURCE_DIR})
 SET(SOURCES "${SOURCE_DIR}/layout.cc" "${SOURCE_DIR}/lshforest.cc" "${SOURCE_DIR}/minhash.cc" "${SOURCE_DIR}/analyse.cc")
 
-# Generate python module
-add_subdirectory(lib/pybind11)
-
 pybind11_add_module(tmap ${SOURCES} "${SOURCE_DIR}/bindings.cc")
 if(MSVC)
 target_link_libraries(tmap PRIVATE OGDF.lib COIN.lib)
diff --git a/tmap/lib/pybind11/CMakeFiles/CMakeDirectoryInformation.cmake b/tmap/lib/pybind11/CMakeFiles/CMakeDirectoryInformation.cmake
deleted file mode 100644
index 394d1d3..0000000
--- a/tmap/lib/pybind11/CMakeFiles/CMakeDirectoryInformation.cmake
+++ /dev/null
@@ -1,16 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.10
-
-# Relative path conversion top directories.
-set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/daenu/Code/conda-mstmap/mstmap")
-set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/daenu/Code/conda-mstmap/mstmap")
-
-# Force unix paths in dependencies.
-set(CMAKE_FORCE_UNIX_PATHS 1)
-
-
-# The C and CXX include file regular expressions for this directory.
-set(CMAKE_C_INCLUDE_REGEX_SCAN "^.*$")
-set(CMAKE_C_INCLUDE_REGEX_COMPLAIN "^$")
-set(CMAKE_CXX_INCLUDE_REGEX_SCAN ${CMAKE_C_INCLUDE_REGEX_SCAN})
-set(CMAKE_CXX_INCLUDE_REGEX_COMPLAIN ${CMAKE_C_INCLUDE_REGEX_COMPLAIN})
diff --git a/tmap/lib/pybind11/CMakeFiles/progress.marks b/tmap/lib/pybind11/CMakeFiles/progress.marks
deleted file mode 100644
index 573541a..0000000
--- a/tmap/lib/pybind11/CMakeFiles/progress.marks
+++ /dev/null
@@ -1 +0,0 @@
-0
diff --git a/tmap/lib/pybind11/CMakeLists.txt b/tmap/lib/pybind11/CMakeLists.txt
deleted file mode 100644
index 2a3e1ed..0000000
--- a/tmap/lib/pybind11/CMakeLists.txt
+++ /dev/null
@@ -1,154 +0,0 @@
-# CMakeLists.txt -- Build system for the pybind11 modules
-#
-# Copyright (c) 2015 Wenzel Jakob <wenzel@inf.ethz.ch>
-#
-# All rights reserved. Use of this source code is governed by a
-# BSD-style license that can be found in the LICENSE file.
-
-cmake_minimum_required(VERSION 2.8.12)
-
-if (POLICY CMP0048)
-  # cmake warns if loaded from a min-3.0-required parent dir, so silence the warning:
-  cmake_policy(SET CMP0048 NEW)
-endif()
-
-# CMake versions < 3.4.0 do not support try_compile/pthread checks without C as active language.
-if(CMAKE_VERSION VERSION_LESS 3.4.0)
-  project(pybind11)
-else()
-  project(pybind11 CXX)
-endif()
-
-# Check if pybind11 is being used directly or via add_subdirectory
-set(PYBIND11_MASTER_PROJECT OFF)
-if (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
-  set(PYBIND11_MASTER_PROJECT ON)
-endif()
-
-option(PYBIND11_INSTALL "Install pybind11 header files?" ${PYBIND11_MASTER_PROJECT})
-option(PYBIND11_TEST    "Build pybind11 test suite?"     ${PYBIND11_MASTER_PROJECT})
-
-list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/tools")
-
-include(pybind11Tools)
-
-# Cache variables so pybind11_add_module can be used in parent projects
-set(PYBIND11_INCLUDE_DIR "${CMAKE_CURRENT_LIST_DIR}/include" CACHE INTERNAL "")
-set(PYTHON_INCLUDE_DIRS ${PYTHON_INCLUDE_DIRS} CACHE INTERNAL "")
-set(PYTHON_LIBRARIES ${PYTHON_LIBRARIES} CACHE INTERNAL "")
-set(PYTHON_MODULE_PREFIX ${PYTHON_MODULE_PREFIX} CACHE INTERNAL "")
-set(PYTHON_MODULE_EXTENSION ${PYTHON_MODULE_EXTENSION} CACHE INTERNAL "")
-
-# NB: when adding a header don't forget to also add it to setup.py
-set(PYBIND11_HEADERS
-  include/pybind11/detail/class.h
-  include/pybind11/detail/common.h
-  include/pybind11/detail/descr.h
-  include/pybind11/detail/init.h
-  include/pybind11/detail/internals.h
-  include/pybind11/detail/typeid.h
-  include/pybind11/attr.h
-  include/pybind11/buffer_info.h
-  include/pybind11/cast.h
-  include/pybind11/chrono.h
-  include/pybind11/complex.h
-  include/pybind11/options.h
-  include/pybind11/eigen.h
-  include/pybind11/embed.h
-  include/pybind11/eval.h
-  include/pybind11/functional.h
-  include/pybind11/numpy.h
-  include/pybind11/operators.h
-  include/pybind11/pybind11.h
-  include/pybind11/pytypes.h
-  include/pybind11/stl.h
-  include/pybind11/stl_bind.h
-)
-string(REPLACE "include/" "${CMAKE_CURRENT_SOURCE_DIR}/include/"
-       PYBIND11_HEADERS "${PYBIND11_HEADERS}")
-
-if (PYBIND11_TEST)
-  add_subdirectory(tests)
-endif()
-
-include(GNUInstallDirs)
-include(CMakePackageConfigHelpers)
-
-# extract project version from source
-file(STRINGS "${PYBIND11_INCLUDE_DIR}/pybind11/detail/common.h" pybind11_version_defines
-     REGEX "#define PYBIND11_VERSION_(MAJOR|MINOR|PATCH) ")
-foreach(ver ${pybind11_version_defines})
-  if (ver MATCHES "#define PYBIND11_VERSION_(MAJOR|MINOR|PATCH) +([^ ]+)$")
-    set(PYBIND11_VERSION_${CMAKE_MATCH_1} "${CMAKE_MATCH_2}" CACHE INTERNAL "")
-  endif()
-endforeach()
-set(${PROJECT_NAME}_VERSION ${PYBIND11_VERSION_MAJOR}.${PYBIND11_VERSION_MINOR}.${PYBIND11_VERSION_PATCH})
-message(STATUS "pybind11 v${${PROJECT_NAME}_VERSION}")
-
-option (USE_PYTHON_INCLUDE_DIR "Install pybind11 headers in Python include directory instead of default installation prefix" OFF)
-if (USE_PYTHON_INCLUDE_DIR)
-    file(RELATIVE_PATH CMAKE_INSTALL_INCLUDEDIR ${CMAKE_INSTALL_PREFIX} ${PYTHON_INCLUDE_DIRS})
-endif()
-
-if(NOT (CMAKE_VERSION VERSION_LESS 3.0))  # CMake >= 3.0
-  # Build an interface library target:
-  add_library(pybind11 INTERFACE)
-  add_library(pybind11::pybind11 ALIAS pybind11)  # to match exported target
-  target_include_directories(pybind11 INTERFACE $<BUILD_INTERFACE:${PYBIND11_INCLUDE_DIR}>
-                                                $<BUILD_INTERFACE:${PYTHON_INCLUDE_DIRS}>
-                                                $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>)
-  target_compile_options(pybind11 INTERFACE $<BUILD_INTERFACE:${PYBIND11_CPP_STANDARD}>)
-
-  add_library(module INTERFACE)
-  add_library(pybind11::module ALIAS module)
-  if(NOT MSVC)
-    target_compile_options(module INTERFACE -fvisibility=hidden)
-  endif()
-  target_link_libraries(module INTERFACE pybind11::pybind11)
-  if(WIN32 OR CYGWIN)
-    target_link_libraries(module INTERFACE $<BUILD_INTERFACE:${PYTHON_LIBRARIES}>)
-  elseif(APPLE)
-    target_link_libraries(module INTERFACE "-undefined dynamic_lookup")
-  endif()
-
-  add_library(embed INTERFACE)
-  add_library(pybind11::embed ALIAS embed)
-  target_link_libraries(embed INTERFACE pybind11::pybind11 $<BUILD_INTERFACE:${PYTHON_LIBRARIES}>)
-endif()
-
-if (PYBIND11_INSTALL)
-  install(DIRECTORY ${PYBIND11_INCLUDE_DIR}/pybind11 DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
-  # GNUInstallDirs "DATADIR" wrong here; CMake search path wants "share".
-  set(PYBIND11_CMAKECONFIG_INSTALL_DIR "share/cmake/${PROJECT_NAME}" CACHE STRING "install path for pybind11Config.cmake")
-
-  configure_package_config_file(tools/${PROJECT_NAME}Config.cmake.in
-                                "${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake"
-                                INSTALL_DESTINATION ${PYBIND11_CMAKECONFIG_INSTALL_DIR})
-  # Remove CMAKE_SIZEOF_VOID_P from ConfigVersion.cmake since the library does
-  # not depend on architecture specific settings or libraries.
-  set(_PYBIND11_CMAKE_SIZEOF_VOID_P ${CMAKE_SIZEOF_VOID_P})
-  unset(CMAKE_SIZEOF_VOID_P)
-  write_basic_package_version_file(${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ConfigVersion.cmake
-                                   VERSION ${${PROJECT_NAME}_VERSION}
-                                   COMPATIBILITY AnyNewerVersion)
-  set(CMAKE_SIZEOF_VOID_P ${_PYBIND11_CMAKE_SIZEOF_VOID_P})
-  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake
-                ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ConfigVersion.cmake
-                tools/FindPythonLibsNew.cmake
-                tools/pybind11Tools.cmake
-          DESTINATION ${PYBIND11_CMAKECONFIG_INSTALL_DIR})
-
-  if(NOT (CMAKE_VERSION VERSION_LESS 3.0))
-    if(NOT PYBIND11_EXPORT_NAME)
-      set(PYBIND11_EXPORT_NAME "${PROJECT_NAME}Targets")
-    endif()
-
-    install(TARGETS pybind11 module embed
-            EXPORT "${PYBIND11_EXPORT_NAME}")
-    if(PYBIND11_MASTER_PROJECT)
-      install(EXPORT "${PYBIND11_EXPORT_NAME}"
-              NAMESPACE "${PROJECT_NAME}::"
-              DESTINATION ${PYBIND11_CMAKECONFIG_INSTALL_DIR})
-    endif()
-  endif()
-endif()
diff --git a/tmap/lib/pybind11/CONTRIBUTING.md b/tmap/lib/pybind11/CONTRIBUTING.md
deleted file mode 100644
index 2beaf8d..0000000
--- a/tmap/lib/pybind11/CONTRIBUTING.md
+++ /dev/null
@@ -1,37 +0,0 @@
-Thank you for your interest in this project! Please refer to the following
-sections on how to contribute code and bug reports.
-
-### Reporting bugs
-
-At the moment, this project is run in the spare time of a single person
-([Wenzel Jakob](http://rgl.epfl.ch/people/wjakob)) with very limited resources
-for issue tracker tickets. Thus, before submitting a question or bug report,
-please take a moment of your time and ensure that your issue isn't already
-discussed in the project documentation provided at
-[http://pybind11.readthedocs.org/en/latest](http://pybind11.readthedocs.org/en/latest).
-
-Assuming that you have identified a previously unknown problem or an important
-question, it's essential that you submit a self-contained and minimal piece of
-code that reproduces the problem. In other words: no external dependencies,
-isolate the function(s) that cause breakage, submit matched and complete C++
-and Python snippets that can be easily compiled and run on my end.
-
-## Pull requests
-Contributions are submitted, reviewed, and accepted using Github pull requests.
-Please refer to [this
-article](https://help.github.com/articles/using-pull-requests) for details and
-adhere to the following rules to make the process as smooth as possible:
-
-* Make a new branch for every feature you're working on.
-* Make small and clean pull requests that are easy to review but make sure they
-  do add value by themselves.
-* Add tests for any new functionality and run the test suite (``make pytest``)
-  to ensure that no existing features break.
-* This project has a strong focus on providing general solutions using a
-  minimal amount of code, thus small pull requests are greatly preferred.
-
-### License
-
-pybind11 is provided under a BSD-style license that can be found in the
-``LICENSE`` file. By using, distributing, or contributing to this project, you
-agree to the terms and conditions of this license.
diff --git a/tmap/lib/pybind11/ISSUE_TEMPLATE.md b/tmap/lib/pybind11/ISSUE_TEMPLATE.md
deleted file mode 100644
index 75df399..0000000
--- a/tmap/lib/pybind11/ISSUE_TEMPLATE.md
+++ /dev/null
@@ -1,17 +0,0 @@
-Make sure you've completed the following steps before submitting your issue -- thank you!
-
-1. Check if your question has already been answered in the [FAQ](http://pybind11.readthedocs.io/en/latest/faq.html) section.
-2. Make sure you've read the [documentation](http://pybind11.readthedocs.io/en/latest/). Your issue may be addressed there.
-3. If those resources didn't help and you only have a short question (not a bug report), consider asking in the [Gitter chat room](https://gitter.im/pybind/Lobby).
-4. If you have a genuine bug report or a more complex question which is not answered in the previous items (or not suitable for chat), please fill in the details below.
-5. Include a self-contained and minimal piece of code that reproduces the problem. If that's not possible, try to make the description as clear as possible.
-
-*After reading, remove this checklist and the template text in parentheses below.*
-
-## Issue description
-
-(Provide a short description, state the expected behavior and what actually happens.)
-
-## Reproducible example code
-
-(The code should be minimal, have no external dependencies, isolate the function(s) that cause breakage. Submit matched and complete C++ and Python snippets that can be easily compiled and run to diagnose the issue.)
diff --git a/tmap/lib/pybind11/LICENSE b/tmap/lib/pybind11/LICENSE
deleted file mode 100644
index ccf4e97..0000000
--- a/tmap/lib/pybind11/LICENSE
+++ /dev/null
@@ -1,36 +0,0 @@
-Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>, All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice, this
-   list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice,
-   this list of conditions and the following disclaimer in the documentation
-   and/or other materials provided with the distribution.
-
-3. Neither the name of the copyright holder nor the names of its contributors
-   may be used to endorse or promote products derived from this software
-   without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-You are under no obligation whatsoever to provide any bug fixes, patches, or
-upgrades to the features, functionality or performance of the source code
-("Enhancements") to anyone; however, if you choose to make your Enhancements
-available either publicly, or directly to the author of this software, without
-imposing a separate written license agreement for such Enhancements, then you
-hereby grant the following license: a non-exclusive, royalty-free perpetual
-license to install, use, modify, prepare derivative works, incorporate into
-other computer software, distribute, and sublicense such enhancements or
-derivative works thereof, in binary and source code form.
diff --git a/tmap/lib/pybind11/MANIFEST.in b/tmap/lib/pybind11/MANIFEST.in
deleted file mode 100644
index 6e57bae..0000000
--- a/tmap/lib/pybind11/MANIFEST.in
+++ /dev/null
@@ -1,2 +0,0 @@
-recursive-include include/pybind11 *.h
-include LICENSE README.md CONTRIBUTING.md
diff --git a/tmap/lib/pybind11/Makefile b/tmap/lib/pybind11/Makefile
deleted file mode 100644
index 5b37bfb..0000000
--- a/tmap/lib/pybind11/Makefile
+++ /dev/null
@@ -1,134 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.10
-
-# Default target executed when no arguments are given to make.
-default_target: all
-
-.PHONY : default_target
-
-# Allow only one "make -f Makefile2" at a time, but pass parallelism.
-.NOTPARALLEL:
-
-
-#=============================================================================
-# Special targets provided by cmake.
-
-# Disable implicit rules so canonical targets will work.
-.SUFFIXES:
-
-
-# Remove some rules from gmake that .SUFFIXES does not remove.
-SUFFIXES =
-
-.SUFFIXES: .hpux_make_needs_suffix_list
-
-
-# Suppress display of executed commands.
-$(VERBOSE).SILENT:
-
-
-# A target that is always out of date.
-cmake_force:
-
-.PHONY : cmake_force
-
-#=============================================================================
-# Set environment variables for the build.
-
-# The shell in which to execute make rules.
-SHELL = /bin/sh
-
-# The CMake executable.
-CMAKE_COMMAND = /usr/bin/cmake
-
-# The command to remove a file.
-RM = /usr/bin/cmake -E remove -f
-
-# Escaping for special characters.
-EQUALS = =
-
-# The top-level source directory on which CMake was run.
-CMAKE_SOURCE_DIR = /home/daenu/Code/conda-mstmap/mstmap
-
-# The top-level build directory on which CMake was run.
-CMAKE_BINARY_DIR = /home/daenu/Code/conda-mstmap/mstmap
-
-#=============================================================================
-# Targets provided globally by CMake.
-
-# Special rule for the target rebuild_cache
-rebuild_cache:
- @$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running CMake to regenerate build system..."
- /usr/bin/cmake -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR)
-.PHONY : rebuild_cache
-
-# Special rule for the target rebuild_cache
-rebuild_cache/fast: rebuild_cache
-
-.PHONY : rebuild_cache/fast
-
-# Special rule for the target edit_cache
-edit_cache:
- @$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "No interactive CMake dialog available..."
- /usr/bin/cmake -E echo No\ interactive\ CMake\ dialog\ available.
-.PHONY : edit_cache
-
-# Special rule for the target edit_cache
-edit_cache/fast: edit_cache
-
-.PHONY : edit_cache/fast
-
-# The main all target
-all: cmake_check_build_system
- cd /home/daenu/Code/conda-mstmap/mstmap && $(CMAKE_COMMAND) -E cmake_progress_start /home/daenu/Code/conda-mstmap/mstmap/CMakeFiles /home/daenu/Code/conda-mstmap/mstmap/lib/pybind11/CMakeFiles/progress.marks
- cd /home/daenu/Code/conda-mstmap/mstmap && $(MAKE) -f CMakeFiles/Makefile2 lib/pybind11/all
- $(CMAKE_COMMAND) -E cmake_progress_start /home/daenu/Code/conda-mstmap/mstmap/CMakeFiles 0
-.PHONY : all
-
-# The main clean target
-clean:
- cd /home/daenu/Code/conda-mstmap/mstmap && $(MAKE) -f CMakeFiles/Makefile2 lib/pybind11/clean
-.PHONY : clean
-
-# The main clean target
-clean/fast: clean
-
-.PHONY : clean/fast
-
-# Prepare targets for installation.
-preinstall: all
- cd /home/daenu/Code/conda-mstmap/mstmap && $(MAKE) -f CMakeFiles/Makefile2 lib/pybind11/preinstall
-.PHONY : preinstall
-
-# Prepare targets for installation.
-preinstall/fast:
- cd /home/daenu/Code/conda-mstmap/mstmap && $(MAKE) -f CMakeFiles/Makefile2 lib/pybind11/preinstall
-.PHONY : preinstall/fast
-
-# clear depends
-depend:
- cd /home/daenu/Code/conda-mstmap/mstmap && $(CMAKE_COMMAND) -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 1
-.PHONY : depend
-
-# Help Target
-help:
- @echo "The following are some of the valid targets for this Makefile:"
- @echo "... all (the default if no target is provided)"
- @echo "... clean"
- @echo "... depend"
- @echo "... rebuild_cache"
- @echo "... edit_cache"
-.PHONY : help
-
-
-
-#=============================================================================
-# Special targets to cleanup operation of make.
-
-# Special rule to run CMake to check the build system integrity.
-# No rule that depends on this can have commands that come from listfiles
-# because they might be regenerated.
-cmake_check_build_system:
- cd /home/daenu/Code/conda-mstmap/mstmap && $(CMAKE_COMMAND) -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 0
-.PHONY : cmake_check_build_system
-
diff --git a/tmap/lib/pybind11/README.md b/tmap/lib/pybind11/README.md
deleted file mode 100644
index 4477882..0000000
--- a/tmap/lib/pybind11/README.md
+++ /dev/null
@@ -1,129 +0,0 @@
-![pybind11 logo](https://github.com/pybind/pybind11/raw/master/docs/pybind11-logo.png)
-
-# pybind11 — Seamless operability between C++11 and Python
-
-[![Documentation Status](https://readthedocs.org/projects/pybind11/badge/?version=master)](http://pybind11.readthedocs.org/en/master/?badge=master)
-[![Documentation Status](https://readthedocs.org/projects/pybind11/badge/?version=stable)](http://pybind11.readthedocs.org/en/stable/?badge=stable)
-[![Gitter chat](https://img.shields.io/gitter/room/gitterHQ/gitter.svg)](https://gitter.im/pybind/Lobby)
-[![Build Status](https://travis-ci.org/pybind/pybind11.svg?branch=master)](https://travis-ci.org/pybind/pybind11)
-[![Build status](https://ci.appveyor.com/api/projects/status/riaj54pn4h08xy40?svg=true)](https://ci.appveyor.com/project/wjakob/pybind11)
-
-**pybind11** is a lightweight header-only library that exposes C++ types in Python
-and vice versa, mainly to create Python bindings of existing C++ code. Its
-goals and syntax are similar to the excellent
-[Boost.Python](http://www.boost.org/doc/libs/1_58_0/libs/python/doc/) library
-by David Abrahams: to minimize boilerplate code in traditional extension
-modules by inferring type information using compile-time introspection.
-
-The main issue with Boost.Python—and the reason for creating such a similar
-project—is Boost. Boost is an enormously large and complex suite of utility
-libraries that works with almost every C++ compiler in existence. This
-compatibility has its cost: arcane template tricks and workarounds are
-necessary to support the oldest and buggiest of compiler specimens. Now that
-C++11-compatible compilers are widely available, this heavy machinery has
-become an excessively large and unnecessary dependency.
-
-Think of this library as a tiny self-contained version of Boost.Python with
-everything stripped away that isn't relevant for binding generation. Without
-comments, the core header files only require ~4K lines of code and depend on
-Python (2.7 or 3.x, or PyPy2.7 >= 5.7) and the C++ standard library. This
-compact implementation was possible thanks to some of the new C++11 language
-features (specifically: tuples, lambda functions and variadic templates). Since
-its creation, this library has grown beyond Boost.Python in many ways, leading
-to dramatically simpler binding code in many common situations.
-
-Tutorial and reference documentation is provided at
-[http://pybind11.readthedocs.org/en/master](http://pybind11.readthedocs.org/en/master).
-A PDF version of the manual is available
-[here](https://media.readthedocs.org/pdf/pybind11/master/pybind11.pdf).
-
-## Core features
-pybind11 can map the following core C++ features to Python
-
-- Functions accepting and returning custom data structures per value, reference, or pointer
-- Instance methods and static methods
-- Overloaded functions
-- Instance attributes and static attributes
-- Arbitrary exception types
-- Enumerations
-- Callbacks
-- Iterators and ranges
-- Custom operators
-- Single and multiple inheritance
-- STL data structures
-- Iterators and ranges
-- Smart pointers with reference counting like ``std::shared_ptr``
-- Internal references with correct reference counting
-- C++ classes with virtual (and pure virtual) methods can be extended in Python
-
-## Goodies
-In addition to the core functionality, pybind11 provides some extra goodies:
-
-- Python 2.7, 3.x, and PyPy (PyPy2.7 >= 5.7) are supported with an
-  implementation-agnostic interface.
-
-- It is possible to bind C++11 lambda functions with captured variables. The
-  lambda capture data is stored inside the resulting Python function object.
-
-- pybind11 uses C++11 move constructors and move assignment operators whenever
-  possible to efficiently transfer custom data types.
-
-- It's easy to expose the internal storage of custom data types through
-  Pythons' buffer protocols. This is handy e.g. for fast conversion between
-  C++ matrix classes like Eigen and NumPy without expensive copy operations.
-
-- pybind11 can automatically vectorize functions so that they are transparently
-  applied to all entries of one or more NumPy array arguments.
-
-- Python's slice-based access and assignment operations can be supported with
-  just a few lines of code.
-
-- Everything is contained in just a few header files; there is no need to link
-  against any additional libraries.
-
-- Binaries are generally smaller by a factor of at least 2 compared to
-  equivalent bindings generated by Boost.Python. A recent pybind11 conversion
-  of PyRosetta, an enormous Boost.Python binding project,
-  [reported](http://graylab.jhu.edu/RosettaCon2016/PyRosetta-4.pdf) a binary
-  size reduction of **5.4x** and compile time reduction by **5.8x**.
-
-- When supported by the compiler, two new C++14 features (relaxed constexpr and
-  return value deduction) are used to precompute function signatures at compile
-  time, leading to smaller binaries.
-
-- With little extra effort, C++ types can be pickled and unpickled similar to
-  regular Python objects.
-
-## Supported compilers
-
-1. Clang/LLVM 3.3 or newer (for Apple Xcode's clang, this is 5.0.0 or newer)
-2. GCC 4.8 or newer
-3. Microsoft Visual Studio 2015 Update 3 or newer
-4. Intel C++ compiler 16 or newer (15 with a [workaround](https://github.com/pybind/pybind11/issues/276))
-5. Cygwin/GCC (tested on 2.5.1)
-
-## About
-
-This project was created by [Wenzel Jakob](http://rgl.epfl.ch/people/wjakob).
-Significant features and/or improvements to the code were contributed by
-Jonas Adler,
-Sylvain Corlay,
-Trent Houliston,
-Axel Huebl,
-@hulucc,
-Sergey Lyskov
-Johan Mabille,
-Tomasz Miąsko,
-Dean Moldovan,
-Ben Pritchard,
-Jason Rhinelander,
-Boris Schäling,
-Pim Schellart,
-Ivan Smirnov, and
-Patrick Stewart.
-
-### License
-
-pybind11 is provided under a BSD-style license that can be found in the
-``LICENSE`` file. By using, distributing, or contributing to this project,
-you agree to the terms and conditions of this license.
diff --git a/tmap/lib/pybind11/cmake_install.cmake b/tmap/lib/pybind11/cmake_install.cmake
deleted file mode 100644
index a9b8c56..0000000
--- a/tmap/lib/pybind11/cmake_install.cmake
+++ /dev/null
@@ -1,39 +0,0 @@
-# Install script for directory: /home/daenu/Code/conda-mstmap/mstmap/lib/pybind11
-
-# Set the install prefix
-if(NOT DEFINED CMAKE_INSTALL_PREFIX)
-  set(CMAKE_INSTALL_PREFIX "/usr/local")
-endif()
-string(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")
-
-# Set the install configuration name.
-if(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
-  if(BUILD_TYPE)
-    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
-           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
-  else()
-    set(CMAKE_INSTALL_CONFIG_NAME "")
-  endif()
-  message(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
-endif()
-
-# Set the component getting installed.
-if(NOT CMAKE_INSTALL_COMPONENT)
-  if(COMPONENT)
-    message(STATUS "Install component: \"${COMPONENT}\"")
-    set(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
-  else()
-    set(CMAKE_INSTALL_COMPONENT)
-  endif()
-endif()
-
-# Install shared libraries without execute permission?
-if(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)
-  set(CMAKE_INSTALL_SO_NO_EXE "1")
-endif()
-
-# Is this installation the result of a crosscompile?
-if(NOT DEFINED CMAKE_CROSSCOMPILING)
-  set(CMAKE_CROSSCOMPILING "FALSE")
-endif()
-
diff --git a/tmap/lib/pybind11/docs/Doxyfile b/tmap/lib/pybind11/docs/Doxyfile
deleted file mode 100644
index 1b9d129..0000000
--- a/tmap/lib/pybind11/docs/Doxyfile
+++ /dev/null
@@ -1,20 +0,0 @@
-PROJECT_NAME           = pybind11
-INPUT                  = ../include/pybind11/
-RECURSIVE              = YES
-
-GENERATE_HTML          = NO
-GENERATE_LATEX         = NO
-GENERATE_XML           = YES
-XML_OUTPUT             = .build/doxygenxml
-XML_PROGRAMLISTING     = YES
-
-MACRO_EXPANSION        = YES
-EXPAND_ONLY_PREDEF     = YES
-EXPAND_AS_DEFINED      = PYBIND11_RUNTIME_EXCEPTION
-
-ALIASES                = "rst=\verbatim embed:rst"
-ALIASES               += "endrst=\endverbatim"
-
-QUIET                  = YES
-WARNINGS               = YES
-WARN_IF_UNDOCUMENTED   = NO
diff --git a/tmap/lib/pybind11/docs/Makefile b/tmap/lib/pybind11/docs/Makefile
deleted file mode 100644
index 511b47c..0000000
--- a/tmap/lib/pybind11/docs/Makefile
+++ /dev/null
@@ -1,192 +0,0 @@
-# Makefile for Sphinx documentation
-#
-
-# You can set these variables from the command line.
-SPHINXOPTS    =
-SPHINXBUILD   = sphinx-build
-PAPER         =
-BUILDDIR      = .build
-
-# User-friendly check for sphinx-build
-ifeq ($(shell which $(SPHINXBUILD) >/dev/null 2>&1; echo $$?), 1)
-$(error The '$(SPHINXBUILD)' command was not found. Make sure you have Sphinx installed, then set the SPHINXBUILD environment variable to point to the full path of the '$(SPHINXBUILD)' executable. Alternatively you can add the directory with the executable to your PATH. If you don't have Sphinx installed, grab it from http://sphinx-doc.org/)
-endif
-
-# Internal variables.
-PAPEROPT_a4     = -D latex_paper_size=a4
-PAPEROPT_letter = -D latex_paper_size=letter
-ALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
-# the i18n builder cannot share the environment and doctrees with the others
-I18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
-
-.PHONY: help clean html dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest coverage gettext
-
-help:
- @echo "Please use \`make <target>' where <target> is one of"
- @echo "  html       to make standalone HTML files"
- @echo "  dirhtml    to make HTML files named index.html in directories"
- @echo "  singlehtml to make a single large HTML file"
- @echo "  pickle     to make pickle files"
- @echo "  json       to make JSON files"
- @echo "  htmlhelp   to make HTML files and a HTML help project"
- @echo "  qthelp     to make HTML files and a qthelp project"
- @echo "  applehelp  to make an Apple Help Book"
- @echo "  devhelp    to make HTML files and a Devhelp project"
- @echo "  epub       to make an epub"
- @echo "  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter"
- @echo "  latexpdf   to make LaTeX files and run them through pdflatex"
- @echo "  latexpdfja to make LaTeX files and run them through platex/dvipdfmx"
- @echo "  text       to make text files"
- @echo "  man        to make manual pages"
- @echo "  texinfo    to make Texinfo files"
- @echo "  info       to make Texinfo files and run them through makeinfo"
- @echo "  gettext    to make PO message catalogs"
- @echo "  changes    to make an overview of all changed/added/deprecated items"
- @echo "  xml        to make Docutils-native XML files"
- @echo "  pseudoxml  to make pseudoxml-XML files for display purposes"
- @echo "  linkcheck  to check all external links for integrity"
- @echo "  doctest    to run all doctests embedded in the documentation (if enabled)"
- @echo "  coverage   to run coverage check of the documentation (if enabled)"
-
-clean:
- rm -rf $(BUILDDIR)/*
-
-html:
- $(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
- @echo
- @echo "Build finished. The HTML pages are in $(BUILDDIR)/html."
-
-dirhtml:
- $(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
- @echo
- @echo "Build finished. The HTML pages are in $(BUILDDIR)/dirhtml."
-
-singlehtml:
- $(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml
- @echo
- @echo "Build finished. The HTML page is in $(BUILDDIR)/singlehtml."
-
-pickle:
- $(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle
- @echo
- @echo "Build finished; now you can process the pickle files."
-
-json:
- $(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json
- @echo
- @echo "Build finished; now you can process the JSON files."
-
-htmlhelp:
- $(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp
- @echo
- @echo "Build finished; now you can run HTML Help Workshop with the" \
-       ".hhp project file in $(BUILDDIR)/htmlhelp."
-
-qthelp:
- $(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp
- @echo
- @echo "Build finished; now you can run "qcollectiongenerator" with the" \
-       ".qhcp project file in $(BUILDDIR)/qthelp, like this:"
- @echo "# qcollectiongenerator $(BUILDDIR)/qthelp/pybind11.qhcp"
- @echo "To view the help file:"
- @echo "# assistant -collectionFile $(BUILDDIR)/qthelp/pybind11.qhc"
-
-applehelp:
- $(SPHINXBUILD) -b applehelp $(ALLSPHINXOPTS) $(BUILDDIR)/applehelp
- @echo
- @echo "Build finished. The help book is in $(BUILDDIR)/applehelp."
- @echo "N.B. You won't be able to view it unless you put it in" \
-       "~/Library/Documentation/Help or install it in your application" \
-       "bundle."
-
-devhelp:
- $(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp
- @echo
- @echo "Build finished."
- @echo "To view the help file:"
- @echo "# mkdir -p $$HOME/.local/share/devhelp/pybind11"
- @echo "# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/pybind11"
- @echo "# devhelp"
-
-epub:
- $(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub
- @echo
- @echo "Build finished. The epub file is in $(BUILDDIR)/epub."
-
-latex:
- $(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
- @echo
- @echo "Build finished; the LaTeX files are in $(BUILDDIR)/latex."
- @echo "Run \`make' in that directory to run these through (pdf)latex" \
-       "(use \`make latexpdf' here to do that automatically)."
-
-latexpdf:
- $(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
- @echo "Running LaTeX files through pdflatex..."
- $(MAKE) -C $(BUILDDIR)/latex all-pdf
- @echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."
-
-latexpdfja:
- $(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
- @echo "Running LaTeX files through platex and dvipdfmx..."
- $(MAKE) -C $(BUILDDIR)/latex all-pdf-ja
- @echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."
-
-text:
- $(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text
- @echo
- @echo "Build finished. The text files are in $(BUILDDIR)/text."
-
-man:
- $(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man
- @echo
- @echo "Build finished. The manual pages are in $(BUILDDIR)/man."
-
-texinfo:
- $(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
- @echo
- @echo "Build finished. The Texinfo files are in $(BUILDDIR)/texinfo."
- @echo "Run \`make' in that directory to run these through makeinfo" \
-       "(use \`make info' here to do that automatically)."
-
-info:
- $(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
- @echo "Running Texinfo files through makeinfo..."
- make -C $(BUILDDIR)/texinfo info
- @echo "makeinfo finished; the Info files are in $(BUILDDIR)/texinfo."
-
-gettext:
- $(SPHINXBUILD) -b gettext $(I18NSPHINXOPTS) $(BUILDDIR)/locale
- @echo
- @echo "Build finished. The message catalogs are in $(BUILDDIR)/locale."
-
-changes:
- $(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes
- @echo
- @echo "The overview file is in $(BUILDDIR)/changes."
-
-linkcheck:
- $(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck
- @echo
- @echo "Link check complete; look for any errors in the above output " \
-       "or in $(BUILDDIR)/linkcheck/output.txt."
-
-doctest:
- $(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest
- @echo "Testing of doctests in the sources finished, look at the " \
-       "results in $(BUILDDIR)/doctest/output.txt."
-
-coverage:
- $(SPHINXBUILD) -b coverage $(ALLSPHINXOPTS) $(BUILDDIR)/coverage
- @echo "Testing of coverage in the sources finished, look at the " \
-       "results in $(BUILDDIR)/coverage/python.txt."
-
-xml:
- $(SPHINXBUILD) -b xml $(ALLSPHINXOPTS) $(BUILDDIR)/xml
- @echo
- @echo "Build finished. The XML files are in $(BUILDDIR)/xml."
-
-pseudoxml:
- $(SPHINXBUILD) -b pseudoxml $(ALLSPHINXOPTS) $(BUILDDIR)/pseudoxml
- @echo
- @echo "Build finished. The pseudo-XML files are in $(BUILDDIR)/pseudoxml."
diff --git a/tmap/lib/pybind11/docs/_static/theme_overrides.css b/tmap/lib/pybind11/docs/_static/theme_overrides.css
deleted file mode 100644
index 1071809..0000000
--- a/tmap/lib/pybind11/docs/_static/theme_overrides.css
+++ /dev/null
@@ -1,11 +0,0 @@
-.wy-table-responsive table td,
-.wy-table-responsive table th {
-    white-space: initial !important;
-}
-.rst-content table.docutils td {
-    vertical-align: top !important;
-}
-div[class^='highlight'] pre {
-    white-space: pre;
-    white-space: pre-wrap;
-}
diff --git a/tmap/lib/pybind11/docs/advanced/cast/chrono.rst b/tmap/lib/pybind11/docs/advanced/cast/chrono.rst
deleted file mode 100644
index 8c6b3d7..0000000
--- a/tmap/lib/pybind11/docs/advanced/cast/chrono.rst
+++ /dev/null
@@ -1,81 +0,0 @@
-Chrono
-======
-
-When including the additional header file :file:`pybind11/chrono.h` conversions
-from C++11 chrono datatypes to python datetime objects are automatically enabled.
-This header also enables conversions of python floats (often from sources such
-as ``time.monotonic()``, ``time.perf_counter()`` and ``time.process_time()``)
-into durations.
-
-An overview of clocks in C++11
-------------------------------
-
-A point of confusion when using these conversions is the differences between
-clocks provided in C++11. There are three clock types defined by the C++11
-standard and users can define their own if needed. Each of these clocks have
-different properties and when converting to and from python will give different
-results.
-
-The first clock defined by the standard is ``std::chrono::system_clock``. This
-clock measures the current date and time. However, this clock changes with to
-updates to the operating system time. For example, if your time is synchronised
-with a time server this clock will change. This makes this clock a poor choice
-for timing purposes but good for measuring the wall time.
-
-The second clock defined in the standard is ``std::chrono::steady_clock``.
-This clock ticks at a steady rate and is never adjusted. This makes it excellent
-for timing purposes, however the value in this clock does not correspond to the
-current date and time. Often this clock will be the amount of time your system
-has been on, although it does not have to be. This clock will never be the same
-clock as the system clock as the system clock can change but steady clocks
-cannot.
-
-The third clock defined in the standard is ``std::chrono::high_resolution_clock``.
-This clock is the clock that has the highest resolution out of the clocks in the
-system. It is normally a typedef to either the system clock or the steady clock
-but can be its own independent clock. This is important as when using these
-conversions as the types you get in python for this clock might be different
-depending on the system.
-If it is a typedef of the system clock, python will get datetime objects, but if
-it is a different clock they will be timedelta objects.
-
-Provided conversions
---------------------
-
-.. rubric:: C++ to Python
-
-- ``std::chrono::system_clock::time_point`` → ``datetime.datetime``
-    System clock times are converted to python datetime instances. They are
-    in the local timezone, but do not have any timezone information attached
-    to them (they are naive datetime objects).
-
-- ``std::chrono::duration`` → ``datetime.timedelta``
-    Durations are converted to timedeltas, any precision in the duration
-    greater than microseconds is lost by rounding towards zero.
-
-- ``std::chrono::[other_clocks]::time_point`` → ``datetime.timedelta``
-    Any clock time that is not the system clock is converted to a time delta.
-    This timedelta measures the time from the clocks epoch to now.
-
-.. rubric:: Python to C++
-
-- ``datetime.datetime`` → ``std::chrono::system_clock::time_point``
-    Date/time objects are converted into system clock timepoints. Any
-    timezone information is ignored and the type is treated as a naive
-    object.
-
-- ``datetime.timedelta`` → ``std::chrono::duration``
-    Time delta are converted into durations with microsecond precision.
-
-- ``datetime.timedelta`` → ``std::chrono::[other_clocks]::time_point``
-    Time deltas that are converted into clock timepoints are treated as
-    the amount of time from the start of the clocks epoch.
-
-- ``float`` → ``std::chrono::duration``
-    Floats that are passed to C++ as durations be interpreted as a number of
-    seconds. These will be converted to the duration using ``duration_cast``
-    from the float.
-
-- ``float`` → ``std::chrono::[other_clocks]::time_point``
-    Floats that are passed to C++ as time points will be interpreted as the
-    number of seconds from the start of the clocks epoch.
diff --git a/tmap/lib/pybind11/docs/advanced/cast/custom.rst b/tmap/lib/pybind11/docs/advanced/cast/custom.rst
deleted file mode 100644
index e4f99ac..0000000
--- a/tmap/lib/pybind11/docs/advanced/cast/custom.rst
+++ /dev/null
@@ -1,91 +0,0 @@
-Custom type casters
-===================
-
-In very rare cases, applications may require custom type casters that cannot be
-expressed using the abstractions provided by pybind11, thus requiring raw
-Python C API calls. This is fairly advanced usage and should only be pursued by
-experts who are familiar with the intricacies of Python reference counting.
-
-The following snippets demonstrate how this works for a very simple ``inty``
-type that that should be convertible from Python types that provide a
-``__int__(self)`` method.
-
-.. code-block:: cpp
-
-    struct inty { long long_value; };
-
-    void print(inty s) {
-        std::cout << s.long_value << std::endl;
-    }
-
-The following Python snippet demonstrates the intended usage from the Python side:
-
-.. code-block:: python
-
-    class A:
-        def __int__(self):
-            return 123
-
-    from example import print
-    print(A())
-
-To register the necessary conversion routines, it is necessary to add
-a partial overload to the ``pybind11::detail::type_caster<T>`` template.
-Although this is an implementation detail, adding partial overloads to this
-type is explicitly allowed.
-
-.. code-block:: cpp
-
-    namespace pybind11 { namespace detail {
-        template <> struct type_caster<inty> {
-        public:
-            /**
-             * This macro establishes the name 'inty' in
-             * function signatures and declares a local variable
-             * 'value' of type inty
-             */
-            PYBIND11_TYPE_CASTER(inty, _("inty"));
-
-            /**
-             * Conversion part 1 (Python->C++): convert a PyObject into a inty
-             * instance or return false upon failure. The second argument
-             * indicates whether implicit conversions should be applied.
-             */
-            bool load(handle src, bool) {
-                /* Extract PyObject from handle */
-                PyObject *source = src.ptr();
-                /* Try converting into a Python integer value */
-                PyObject *tmp = PyNumber_Long(source);
-                if (!tmp)
-                    return false;
-                /* Now try to convert into a C++ int */
-                value.long_value = PyLong_AsLong(tmp);
-                Py_DECREF(tmp);
-                /* Ensure return code was OK (to avoid out-of-range errors etc) */
-                return !(value.long_value == -1 && !PyErr_Occurred());
-            }
-
-            /**
-             * Conversion part 2 (C++ -> Python): convert an inty instance into
-             * a Python object. The second and third arguments are used to
-             * indicate the return value policy and parent object (for
-             * ``return_value_policy::reference_internal``) and are generally
-             * ignored by implicit casters.
-             */
-            static handle cast(inty src, return_value_policy /* policy */, handle /* parent */) {
-                return PyLong_FromLong(src.long_value);
-            }
-        };
-    }} // namespace pybind11::detail
-
-.. note::
-
-    A ``type_caster<T>`` defined with ``PYBIND11_TYPE_CASTER(T, ...)`` requires
-    that ``T`` is default-constructible (``value`` is first default constructed
-    and then ``load()`` assigns to it).
-
-.. warning::
-
-    When using custom type casters, it's important to declare them consistently
-    in every compilation unit of the Python extension module. Otherwise,
-    undefined behavior can ensue.
diff --git a/tmap/lib/pybind11/docs/advanced/cast/eigen.rst b/tmap/lib/pybind11/docs/advanced/cast/eigen.rst
deleted file mode 100644
index acdb51d..0000000
--- a/tmap/lib/pybind11/docs/advanced/cast/eigen.rst
+++ /dev/null
@@ -1,310 +0,0 @@
-Eigen
-#####
-
-`Eigen <http://eigen.tuxfamily.org>`_ is C++ header-based library for dense and
-sparse linear algebra. Due to its popularity and widespread adoption, pybind11
-provides transparent conversion and limited mapping support between Eigen and
-Scientific Python linear algebra data types.
-
-To enable the built-in Eigen support you must include the optional header file
-:file:`pybind11/eigen.h`.
-
-Pass-by-value
-=============
-
-When binding a function with ordinary Eigen dense object arguments (for
-example, ``Eigen::MatrixXd``), pybind11 will accept any input value that is
-already (or convertible to) a ``numpy.ndarray`` with dimensions compatible with
-the Eigen type, copy its values into a temporary Eigen variable of the
-appropriate type, then call the function with this temporary variable.
-
-Sparse matrices are similarly copied to or from
-``scipy.sparse.csr_matrix``/``scipy.sparse.csc_matrix`` objects.
-
-Pass-by-reference
-=================
-
-One major limitation of the above is that every data conversion implicitly
-involves a copy, which can be both expensive (for large matrices) and disallows
-binding functions that change their (Matrix) arguments.  Pybind11 allows you to
-work around this by using Eigen's ``Eigen::Ref<MatrixType>`` class much as you
-would when writing a function taking a generic type in Eigen itself (subject to
-some limitations discussed below).
-
-When calling a bound function accepting a ``Eigen::Ref<const MatrixType>``
-type, pybind11 will attempt to avoid copying by using an ``Eigen::Map`` object
-that maps into the source ``numpy.ndarray`` data: this requires both that the
-data types are the same (e.g. ``dtype='float64'`` and ``MatrixType::Scalar`` is
-``double``); and that the storage is layout compatible.  The latter limitation
-is discussed in detail in the section below, and requires careful
-consideration: by default, numpy matrices and eigen matrices are *not* storage
-compatible.
-
-If the numpy matrix cannot be used as is (either because its types differ, e.g.
-passing an array of integers to an Eigen paramater requiring doubles, or
-because the storage is incompatible), pybind11 makes a temporary copy and
-passes the copy instead.
-
-When a bound function parameter is instead ``Eigen::Ref<MatrixType>`` (note the
-lack of ``const``), pybind11 will only allow the function to be called if it
-can be mapped *and* if the numpy array is writeable (that is
-``a.flags.writeable`` is true).  Any access (including modification) made to
-the passed variable will be transparently carried out directly on the
-``numpy.ndarray``.
-
-This means you can can write code such as the following and have it work as
-expected:
-
-.. code-block:: cpp
-
-    void scale_by_2(Eigen::Ref<Eigen::VectorXd> v) {
-        v *= 2;
-    }
-
-Note, however, that you will likely run into limitations due to numpy and
-Eigen's difference default storage order for data; see the below section on
-:ref:`storage_orders` for details on how to bind code that won't run into such
-limitations.
-
-.. note::
-
-    Passing by reference is not supported for sparse types.
-
-Returning values to Python
-==========================
-
-When returning an ordinary dense Eigen matrix type to numpy (e.g.
-``Eigen::MatrixXd`` or ``Eigen::RowVectorXf``) pybind11 keeps the matrix and
-returns a numpy array that directly references the Eigen matrix: no copy of the
-data is performed.  The numpy array will have ``array.flags.owndata`` set to
-``False`` to indicate that it does not own the data, and the lifetime of the
-stored Eigen matrix will be tied to the returned ``array``.
-
-If you bind a function with a non-reference, ``const`` return type (e.g.
-``const Eigen::MatrixXd``), the same thing happens except that pybind11 also
-sets the numpy array's ``writeable`` flag to false.
-
-If you return an lvalue reference or pointer, the usual pybind11 rules apply,
-as dictated by the binding function's return value policy (see the
-documentation on :ref:`return_value_policies` for full details).  That means,
-without an explicit return value policy, lvalue references will be copied and
-pointers will be managed by pybind11.  In order to avoid copying, you should
-explictly specify an appropriate return value policy, as in the following
-example:
-
-.. code-block:: cpp
-
-    class MyClass {
-        Eigen::MatrixXd big_mat = Eigen::MatrixXd::Zero(10000, 10000);
-    public:
-        Eigen::MatrixXd &getMatrix() { return big_mat; }
-        const Eigen::MatrixXd &viewMatrix() { return big_mat; }
-    };
-
-    // Later, in binding code:
-    py::class_<MyClass>(m, "MyClass")
-        .def(py::init<>())
-        .def("copy_matrix", &MyClass::getMatrix) // Makes a copy!
-        .def("get_matrix", &MyClass::getMatrix, py::return_value_policy::reference_internal)
-        .def("view_matrix", &MyClass::viewMatrix, py::return_value_policy::reference_internal)
-        ;
-
-.. code-block:: python
-
-    a = MyClass()
-    m = a.get_matrix()   # flags.writeable = True,  flags.owndata = False
-    v = a.view_matrix()  # flags.writeable = False, flags.owndata = False
-    c = a.copy_matrix()  # flags.writeable = True,  flags.owndata = True
-    # m[5,6] and v[5,6] refer to the same element, c[5,6] does not.
-
-Note in this example that ``py::return_value_policy::reference_internal`` is
-used to tie the life of the MyClass object to the life of the returned arrays.
-
-You may also return an ``Eigen::Ref``, ``Eigen::Map`` or other map-like Eigen
-object (for example, the return value of ``matrix.block()`` and related
-methods) that map into a dense Eigen type.  When doing so, the default
-behaviour of pybind11 is to simply reference the returned data: you must take
-care to ensure that this data remains valid!  You may ask pybind11 to
-explicitly *copy* such a return value by using the
-``py::return_value_policy::copy`` policy when binding the function.  You may
-also use ``py::return_value_policy::reference_internal`` or a
-``py::keep_alive`` to ensure the data stays valid as long as the returned numpy
-array does.
-
-When returning such a reference of map, pybind11 additionally respects the
-readonly-status of the returned value, marking the numpy array as non-writeable
-if the reference or map was itself read-only.
-
-.. note::
-
-    Sparse types are always copied when returned.
-
-.. _storage_orders:
-
-Storage orders
-==============
-
-Passing arguments via ``Eigen::Ref`` has some limitations that you must be
-aware of in order to effectively pass matrices by reference.  First and
-foremost is that the default ``Eigen::Ref<MatrixType>`` class requires
-contiguous storage along columns (for column-major types, the default in Eigen)
-or rows if ``MatrixType`` is specifically an ``Eigen::RowMajor`` storage type.
-The former, Eigen's default, is incompatible with ``numpy``'s default row-major
-storage, and so you will not be able to pass numpy arrays to Eigen by reference
-without making one of two changes.
-
-(Note that this does not apply to vectors (or column or row matrices): for such
-types the "row-major" and "column-major" distinction is meaningless).
-
-The first approach is to change the use of ``Eigen::Ref<MatrixType>`` to the
-more general ``Eigen::Ref<MatrixType, 0, Eigen::Stride<Eigen::Dynamic,
-Eigen::Dynamic>>`` (or similar type with a fully dynamic stride type in the
-third template argument).  Since this is a rather cumbersome type, pybind11
-provides a ``py::EigenDRef<MatrixType>`` type alias for your convenience (along
-with EigenDMap for the equivalent Map, and EigenDStride for just the stride
-type).
-
-This type allows Eigen to map into any arbitrary storage order.  This is not
-the default in Eigen for performance reasons: contiguous storage allows
-vectorization that cannot be done when storage is not known to be contiguous at
-compile time.  The default ``Eigen::Ref`` stride type allows non-contiguous
-storage along the outer dimension (that is, the rows of a column-major matrix
-or columns of a row-major matrix), but not along the inner dimension.
-
-This type, however, has the added benefit of also being able to map numpy array
-slices.  For example, the following (contrived) example uses Eigen with a numpy
-slice to multiply by 2 all coefficients that are both on even rows (0, 2, 4,
-...) and in columns 2, 5, or 8:
-
-.. code-block:: cpp
-
-    m.def("scale", [](py::EigenDRef<Eigen::MatrixXd> m, double c) { m *= c; });
-
-.. code-block:: python
-
-    # a = np.array(...)
-    scale_by_2(myarray[0::2, 2:9:3])
-
-The second approach to avoid copying is more intrusive: rearranging the
-underlying data types to not run into the non-contiguous storage problem in the
-first place.  In particular, that means using matrices with ``Eigen::RowMajor``
-storage, where appropriate, such as:
-
-.. code-block:: cpp
-
-    using RowMatrixXd = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;
-    // Use RowMatrixXd instead of MatrixXd
-
-Now bound functions accepting ``Eigen::Ref<RowMatrixXd>`` arguments will be
-callable with numpy's (default) arrays without involving a copying.
-
-You can, alternatively, change the storage order that numpy arrays use by
-adding the ``order='F'`` option when creating an array:
-
-.. code-block:: python
-
-    myarray = np.array(source, order='F')
-
-Such an object will be passable to a bound function accepting an
-``Eigen::Ref<MatrixXd>`` (or similar column-major Eigen type).
-
-One major caveat with this approach, however, is that it is not entirely as
-easy as simply flipping all Eigen or numpy usage from one to the other: some
-operations may alter the storage order of a numpy array.  For example, ``a2 =
-array.transpose()`` results in ``a2`` being a view of ``array`` that references
-the same data, but in the opposite storage order!
-
-While this approach allows fully optimized vectorized calculations in Eigen, it
-cannot be used with array slices, unlike the first approach.
-
-When *returning* a matrix to Python (either a regular matrix, a reference via
-``Eigen::Ref<>``, or a map/block into a matrix), no special storage
-consideration is required: the created numpy array will have the required
-stride that allows numpy to properly interpret the array, whatever its storage
-order.
-
-Failing rather than copying
-===========================
-
-The default behaviour when binding ``Eigen::Ref<const MatrixType>`` eigen
-references is to copy matrix values when passed a numpy array that does not
-conform to the element type of ``MatrixType`` or does not have a compatible
-stride layout.  If you want to explicitly avoid copying in such a case, you
-should bind arguments using the ``py::arg().noconvert()`` annotation (as
-described in the :ref:`nonconverting_arguments` documentation).
-
-The following example shows an example of arguments that don't allow data
-copying to take place:
-
-.. code-block:: cpp
-
-    // The method and function to be bound:
-    class MyClass {
-        // ...
-        double some_method(const Eigen::Ref<const MatrixXd> &matrix) { /* ... */ }
-    };
-    float some_function(const Eigen::Ref<const MatrixXf> &big,
-                        const Eigen::Ref<const MatrixXf> &small) {
-        // ...
-    }
-
-    // The associated binding code:
-    using namespace pybind11::literals; // for "arg"_a
-    py::class_<MyClass>(m, "MyClass")
-        // ... other class definitions
-        .def("some_method", &MyClass::some_method, py::arg().noconvert());
-
-    m.def("some_function", &some_function,
-        "big"_a.noconvert(), // <- Don't allow copying for this arg
-        "small"_a            // <- This one can be copied if needed
-    );
-
-With the above binding code, attempting to call the the ``some_method(m)``
-method on a ``MyClass`` object, or attempting to call ``some_function(m, m2)``
-will raise a ``RuntimeError`` rather than making a temporary copy of the array.
-It will, however, allow the ``m2`` argument to be copied into a temporary if
-necessary.
-
-Note that explicitly specifying ``.noconvert()`` is not required for *mutable*
-Eigen references (e.g. ``Eigen::Ref<MatrixXd>`` without ``const`` on the
-``MatrixXd``): mutable references will never be called with a temporary copy.
-
-Vectors versus column/row matrices
-==================================
-
-Eigen and numpy have fundamentally different notions of a vector.  In Eigen, a
-vector is simply a matrix with the number of columns or rows set to 1 at
-compile time (for a column vector or row vector, respectively).  Numpy, in
-contast, has comparable 2-dimensional 1xN and Nx1 arrays, but *also* has
-1-dimensional arrays of size N.
-
-When passing a 2-dimensional 1xN or Nx1 array to Eigen, the Eigen type must
-have matching dimensions: That is, you cannot pass a 2-dimensional Nx1 numpy
-array to an Eigen value expecting a row vector, or a 1xN numpy array as a
-column vector argument.
-
-On the other hand, pybind11 allows you to pass 1-dimensional arrays of length N
-as Eigen parameters.  If the Eigen type can hold a column vector of length N it
-will be passed as such a column vector.  If not, but the Eigen type constraints
-will accept a row vector, it will be passed as a row vector.  (The column
-vector takes precendence when both are supported, for example, when passing a
-1D numpy array to a MatrixXd argument).  Note that the type need not be
-expicitly a vector: it is permitted to pass a 1D numpy array of size 5 to an
-Eigen ``Matrix<double, Dynamic, 5>``: you would end up with a 1x5 Eigen matrix.
-Passing the same to an ``Eigen::MatrixXd`` would result in a 5x1 Eigen matrix.
-
-When returning an eigen vector to numpy, the conversion is ambiguous: a row
-vector of length 4 could be returned as either a 1D array of length 4, or as a
-2D array of size 1x4.  When encoutering such a situation, pybind11 compromises
-by considering the returned Eigen type: if it is a compile-time vector--that
-is, the type has either the number of rows or columns set to 1 at compile
-time--pybind11 converts to a 1D numpy array when returning the value.  For
-instances that are a vector only at run-time (e.g. ``MatrixXd``,
-``Matrix<float, Dynamic, 4>``), pybind11 returns the vector as a 2D array to
-numpy.  If this isn't want you want, you can use ``array.reshape(...)`` to get
-a view of the same data in the desired dimensions.
-
-.. seealso::
-
-    The file :file:`tests/test_eigen.cpp` contains a complete example that
-    shows how to pass Eigen sparse and dense data types in more detail.
diff --git a/tmap/lib/pybind11/docs/advanced/cast/functional.rst b/tmap/lib/pybind11/docs/advanced/cast/functional.rst
deleted file mode 100644
index d9b4605..0000000
--- a/tmap/lib/pybind11/docs/advanced/cast/functional.rst
+++ /dev/null
@@ -1,109 +0,0 @@
-Functional
-##########
-
-The following features must be enabled by including :file:`pybind11/functional.h`.
-
-
-Callbacks and passing anonymous functions
-=========================================
-
-The C++11 standard brought lambda functions and the generic polymorphic
-function wrapper ``std::function<>`` to the C++ programming language, which
-enable powerful new ways of working with functions. Lambda functions come in
-two flavors: stateless lambda function resemble classic function pointers that
-link to an anonymous piece of code, while stateful lambda functions
-additionally depend on captured variables that are stored in an anonymous
-*lambda closure object*.
-
-Here is a simple example of a C++ function that takes an arbitrary function
-(stateful or stateless) with signature ``int -> int`` as an argument and runs
-it with the value 10.
-
-.. code-block:: cpp
-
-    int func_arg(const std::function<int(int)> &f) {
-        return f(10);
-    }
-
-The example below is more involved: it takes a function of signature ``int -> int``
-and returns another function of the same kind. The return value is a stateful
-lambda function, which stores the value ``f`` in the capture object and adds 1 to
-its return value upon execution.
-
-.. code-block:: cpp
-
-    std::function<int(int)> func_ret(const std::function<int(int)> &f) {
-        return [f](int i) {
-            return f(i) + 1;
-        };
-    }
-
-This example demonstrates using python named parameters in C++ callbacks which
-requires using ``py::cpp_function`` as a wrapper. Usage is similar to defining
-methods of classes:
-
-.. code-block:: cpp
-
-    py::cpp_function func_cpp() {
-        return py::cpp_function([](int i) { return i+1; },
-           py::arg("number"));
-    }
-
-After including the extra header file :file:`pybind11/functional.h`, it is almost
-trivial to generate binding code for all of these functions.
-
-.. code-block:: cpp
-
-    #include <pybind11/functional.h>
-
-    PYBIND11_MODULE(example, m) {
-        m.def("func_arg", &func_arg);
-        m.def("func_ret", &func_ret);
-        m.def("func_cpp", &func_cpp);
-    }
-
-The following interactive session shows how to call them from Python.
-
-.. code-block:: pycon
-
-    $ python
-    >>> import example
-    >>> def square(i):
-    ...     return i * i
-    ...
-    >>> example.func_arg(square)
-    100L
-    >>> square_plus_1 = example.func_ret(square)
-    >>> square_plus_1(4)
-    17L
-    >>> plus_1 = func_cpp()
-    >>> plus_1(number=43)
-    44L
-
-.. warning::
-
-    Keep in mind that passing a function from C++ to Python (or vice versa)
-    will instantiate a piece of wrapper code that translates function
-    invocations between the two languages. Naturally, this translation
-    increases the computational cost of each function call somewhat. A
-    problematic situation can arise when a function is copied back and forth
-    between Python and C++ many times in a row, in which case the underlying
-    wrappers will accumulate correspondingly. The resulting long sequence of
-    C++ -> Python -> C++ -> ... roundtrips can significantly decrease
-    performance.
-
-    There is one exception: pybind11 detects case where a stateless function
-    (i.e. a function pointer or a lambda function without captured variables)
-    is passed as an argument to another C++ function exposed in Python. In this
-    case, there is no overhead. Pybind11 will extract the underlying C++
-    function pointer from the wrapped function to sidestep a potential C++ ->
-    Python -> C++ roundtrip. This is demonstrated in :file:`tests/test_callbacks.cpp`.
-
-.. note::
-
-    This functionality is very useful when generating bindings for callbacks in
-    C++ libraries (e.g. GUI libraries, asynchronous networking libraries, etc.).
-
-    The file :file:`tests/test_callbacks.cpp` contains a complete example
-    that demonstrates how to work with callbacks and anonymous functions in
-    more detail.
diff --git a/tmap/lib/pybind11/docs/advanced/cast/index.rst b/tmap/lib/pybind11/docs/advanced/cast/index.rst
deleted file mode 100644
index 54c1057..0000000
--- a/tmap/lib/pybind11/docs/advanced/cast/index.rst
+++ /dev/null
@@ -1,42 +0,0 @@
-Type conversions
-################
-
-Apart from enabling cross-language function calls, a fundamental problem
-that a binding tool like pybind11 must address is to provide access to
-native Python types in C++ and vice versa. There are three fundamentally
-different ways to do this—which approach is preferable for a particular type
-depends on the situation at hand.
-
-1. Use a native C++ type everywhere. In this case, the type must be wrapped
-   using pybind11-generated bindings so that Python can interact with it.
-
-2. Use a native Python type everywhere. It will need to be wrapped so that
-   C++ functions can interact with it.
-
-3. Use a native C++ type on the C++ side and a native Python type on the
-   Python side. pybind11 refers to this as a *type conversion*.
-
-   Type conversions are the most "natural" option in the sense that native
-   (non-wrapped) types are used everywhere. The main downside is that a copy
-   of the data must be made on every Python ↔ C++ transition: this is
-   needed since the C++ and Python versions of the same type generally won't
-   have the same memory layout.
-
-   pybind11 can perform many kinds of conversions automatically. An overview
-   is provided in the table ":ref:`conversion_table`".
-
-The following subsections discuss the differences between these options in more
-detail. The main focus in this section is on type conversions, which represent
-the last case of the above list.
-
-.. toctree::
-   :maxdepth: 1
-
-   overview
-   strings
-   stl
-   functional
-   chrono
-   eigen
-   custom
-
diff --git a/tmap/lib/pybind11/docs/advanced/cast/overview.rst b/tmap/lib/pybind11/docs/advanced/cast/overview.rst
deleted file mode 100644
index 2ac7d30..0000000
--- a/tmap/lib/pybind11/docs/advanced/cast/overview.rst
+++ /dev/null
@@ -1,163 +0,0 @@
-Overview
-########
-
-.. rubric:: 1. Native type in C++, wrapper in Python
-
-Exposing a custom C++ type using :class:`py::class_` was covered in detail
-in the :doc:`/classes` section. There, the underlying data structure is
-always the original C++ class while the :class:`py::class_` wrapper provides
-a Python interface. Internally, when an object like this is sent from C++ to
-Python, pybind11 will just add the outer wrapper layer over the native C++
-object. Getting it back from Python is just a matter of peeling off the
-wrapper.
-
-.. rubric:: 2. Wrapper in C++, native type in Python
-
-This is the exact opposite situation. Now, we have a type which is native to
-Python, like a ``tuple`` or a ``list``. One way to get this data into C++ is
-with the :class:`py::object` family of wrappers. These are explained in more
-detail in the :doc:`/advanced/pycpp/object` section. We'll just give a quick
-example here:
-
-.. code-block:: cpp
-
-    void print_list(py::list my_list) {
-        for (auto item : my_list)
-            std::cout << item << " ";
-    }
-
-.. code-block:: pycon
-
-    >>> print_list([1, 2, 3])
-    1 2 3
-
-The Python ``list`` is not converted in any way -- it's just wrapped in a C++
-:class:`py::list` class. At its core it's still a Python object. Copying a
-:class:`py::list` will do the usual reference-counting like in Python.
-Returning the object to Python will just remove the thin wrapper.
-
-.. rubric:: 3. Converting between native C++ and Python types
-
-In the previous two cases we had a native type in one language and a wrapper in
-the other. Now, we have native types on both sides and we convert between them.
-
-.. code-block:: cpp
-
-    void print_vector(const std::vector<int> &v) {
-        for (auto item : v)
-            std::cout << item << "\n";
-    }
-
-.. code-block:: pycon
-
-    >>> print_vector([1, 2, 3])
-    1 2 3
-
-In this case, pybind11 will construct a new ``std::vector<int>`` and copy each
-element from the Python ``list``. The newly constructed object will be passed
-to ``print_vector``. The same thing happens in the other direction: a new
-``list`` is made to match the value returned from C++.
-
-Lots of these conversions are supported out of the box, as shown in the table
-below. They are very convenient, but keep in mind that these conversions are
-fundamentally based on copying data. This is perfectly fine for small immutable
-types but it may become quite expensive for large data structures. This can be
-avoided by overriding the automatic conversion with a custom wrapper (i.e. the
-above-mentioned approach 1). This requires some manual effort and more details
-are available in the :ref:`opaque` section.
-
-.. _conversion_table:
-
-List of all builtin conversions
--------------------------------
-
-The following basic data types are supported out of the box (some may require
-an additional extension header to be included). To pass other data structures
-as arguments and return values, refer to the section on binding :ref:`classes`.
-
-+------------------------------------+---------------------------+-------------------------------+
-|  Data type                         |  Description              | Header file                   |
-+====================================+===========================+===============================+
-| ``int8_t``, ``uint8_t``            | 8-bit integers            | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``int16_t``, ``uint16_t``          | 16-bit integers           | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``int32_t``, ``uint32_t``          | 32-bit integers           | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``int64_t``, ``uint64_t``          | 64-bit integers           | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``ssize_t``, ``size_t``            | Platform-dependent size   | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``float``, ``double``              | Floating point types      | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``bool``                           | Two-state Boolean type    | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``char``                           | Character literal         | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``char16_t``                       | UTF-16 character literal  | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``char32_t``                       | UTF-32 character literal  | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``wchar_t``                        | Wide character literal    | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``const char *``                   | UTF-8 string literal      | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``const char16_t *``               | UTF-16 string literal     | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``const char32_t *``               | UTF-32 string literal     | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``const wchar_t *``                | Wide string literal       | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::string``                    | STL dynamic UTF-8 string  | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::u16string``                 | STL dynamic UTF-16 string | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::u32string``                 | STL dynamic UTF-32 string | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::wstring``                   | STL dynamic wide string   | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::string_view``,              | STL C++17 string views    | :file:`pybind11/pybind11.h`   |
-| ``std::u16string_view``, etc.      |                           |                               |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::pair<T1, T2>``              | Pair of two custom types  | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::tuple<...>``                | Arbitrary tuple of types  | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::reference_wrapper<...>``    | Reference type wrapper    | :file:`pybind11/pybind11.h`   |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::complex<T>``                | Complex numbers           | :file:`pybind11/complex.h`    |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::array<T, Size>``            | STL static array          | :file:`pybind11/stl.h`        |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::vector<T>``                 | STL dynamic array         | :file:`pybind11/stl.h`        |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::valarray<T>``               | STL value array           | :file:`pybind11/stl.h`        |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::list<T>``                   | STL linked list           | :file:`pybind11/stl.h`        |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::map<T1, T2>``               | STL ordered map           | :file:`pybind11/stl.h`        |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::unordered_map<T1, T2>``     | STL unordered map         | :file:`pybind11/stl.h`        |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::set<T>``                    | STL ordered set           | :file:`pybind11/stl.h`        |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::unordered_set<T>``          | STL unordered set         | :file:`pybind11/stl.h`        |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::optional<T>``               | STL optional type (C++17) | :file:`pybind11/stl.h`        |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::experimental::optional<T>`` | STL optional type (exp.)  | :file:`pybind11/stl.h`        |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::variant<...>``              | Type-safe union (C++17)   | :file:`pybind11/stl.h`        |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::function<...>``             | STL polymorphic function  | :file:`pybind11/functional.h` |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::chrono::duration<...>``     | STL time duration         | :file:`pybind11/chrono.h`     |
-+------------------------------------+---------------------------+-------------------------------+
-| ``std::chrono::time_point<...>``   | STL date/time             | :file:`pybind11/chrono.h`     |
-+------------------------------------+---------------------------+-------------------------------+
-| ``Eigen::Matrix<...>``             | Eigen: dense matrix       | :file:`pybind11/eigen.h`      |
-+------------------------------------+---------------------------+-------------------------------+
-| ``Eigen::Map<...>``                | Eigen: mapped memory      | :file:`pybind11/eigen.h`      |
-+------------------------------------+---------------------------+-------------------------------+
-| ``Eigen::SparseMatrix<...>``       | Eigen: sparse matrix      | :file:`pybind11/eigen.h`      |
-+------------------------------------+---------------------------+-------------------------------+
diff --git a/tmap/lib/pybind11/docs/advanced/cast/stl.rst b/tmap/lib/pybind11/docs/advanced/cast/stl.rst
deleted file mode 100644
index 3f30c02..0000000
--- a/tmap/lib/pybind11/docs/advanced/cast/stl.rst
+++ /dev/null
@@ -1,243 +0,0 @@
-STL containers
-##############
-
-Automatic conversion
-====================
-
-When including the additional header file :file:`pybind11/stl.h`, conversions
-between ``std::vector<>``/``std::list<>``/``std::array<>``,
-``std::set<>``/``std::unordered_set<>``, and
-``std::map<>``/``std::unordered_map<>`` and the Python ``list``, ``set`` and
-``dict`` data structures are automatically enabled. The types ``std::pair<>``
-and ``std::tuple<>`` are already supported out of the box with just the core
-:file:`pybind11/pybind11.h` header.
-
-The major downside of these implicit conversions is that containers must be
-converted (i.e. copied) on every Python->C++ and C++->Python transition, which
-can have implications on the program semantics and performance. Please read the
-next sections for more details and alternative approaches that avoid this.
-
-.. note::
-
-    Arbitrary nesting of any of these types is possible.
-
-.. seealso::
-
-    The file :file:`tests/test_stl.cpp` contains a complete
-    example that demonstrates how to pass STL data types in more detail.
-
-.. _cpp17_container_casters:
-
-C++17 library containers
-========================
-
-The :file:`pybind11/stl.h` header also includes support for ``std::optional<>``
-and ``std::variant<>``. These require a C++17 compiler and standard library.
-In C++14 mode, ``std::experimental::optional<>`` is supported if available.
-
-Various versions of these containers also exist for C++11 (e.g. in Boost).
-pybind11 provides an easy way to specialize the ``type_caster`` for such
-types:
-
-.. code-block:: cpp
-
-    // `boost::optional` as an example -- can be any `std::optional`-like container
-    namespace pybind11 { namespace detail {
-        template <typename T>
-        struct type_caster<boost::optional<T>> : optional_caster<boost::optional<T>> {};
-    }}
-
-The above should be placed in a header file and included in all translation units
-where automatic conversion is needed. Similarly, a specialization can be provided
-for custom variant types:
-
-.. code-block:: cpp
-
-    // `boost::variant` as an example -- can be any `std::variant`-like container
-    namespace pybind11 { namespace detail {
-        template <typename... Ts>
-        struct type_caster<boost::variant<Ts...>> : variant_caster<boost::variant<Ts...>> {};
-
-        // Specifies the function used to visit the variant -- `apply_visitor` instead of `visit`
-        template <>
-        struct visit_helper<boost::variant> {
-            template <typename... Args>
-            static auto call(Args &&...args) -> decltype(boost::apply_visitor(args...)) {
-                return boost::apply_visitor(args...);
-            }
-        };
-    }} // namespace pybind11::detail
-
-The ``visit_helper`` specialization is not required if your ``name::variant`` provides
-a ``name::visit()`` function. For any other function name, the specialization must be
-included to tell pybind11 how to visit the variant.
-
-.. note::
-
-    pybind11 only supports the modern implementation of ``boost::variant``
-    which makes use of variadic templates. This requires Boost 1.56 or newer.
-    Additionally, on Windows, MSVC 2017 is required because ``boost::variant``
-    falls back to the old non-variadic implementation on MSVC 2015.
-
-.. _opaque:
-
-Making opaque types
-===================
-
-pybind11 heavily relies on a template matching mechanism to convert parameters
-and return values that are constructed from STL data types such as vectors,
-linked lists, hash tables, etc. This even works in a recursive manner, for
-instance to deal with lists of hash maps of pairs of elementary and custom
-types, etc.
-
-However, a fundamental limitation of this approach is that internal conversions
-between Python and C++ types involve a copy operation that prevents
-pass-by-reference semantics. What does this mean?
-
-Suppose we bind the following function
-
-.. code-block:: cpp
-
-    void append_1(std::vector<int> &v) {
-       v.push_back(1);
-    }
-
-and call it from Python, the following happens:
-
-.. code-block:: pycon
-
-   >>> v = [5, 6]
-   >>> append_1(v)
-   >>> print(v)
-   [5, 6]
-
-As you can see, when passing STL data structures by reference, modifications
-are not propagated back the Python side. A similar situation arises when
-exposing STL data structures using the ``def_readwrite`` or ``def_readonly``
-functions:
-
-.. code-block:: cpp
-
-    /* ... definition ... */
-
-    class MyClass {
-        std::vector<int> contents;
-    };
-
-    /* ... binding code ... */
-
-    py::class_<MyClass>(m, "MyClass")
-        .def(py::init<>())
-        .def_readwrite("contents", &MyClass::contents);
-
-In this case, properties can be read and written in their entirety. However, an
-``append`` operation involving such a list type has no effect:
-
-.. code-block:: pycon
-
-   >>> m = MyClass()
-   >>> m.contents = [5, 6]
-   >>> print(m.contents)
-   [5, 6]
-   >>> m.contents.append(7)
-   >>> print(m.contents)
-   [5, 6]
-
-Finally, the involved copy operations can be costly when dealing with very
-large lists. To deal with all of the above situations, pybind11 provides a
-macro named ``PYBIND11_MAKE_OPAQUE(T)`` that disables the template-based
-conversion machinery of types, thus rendering them *opaque*. The contents of
-opaque objects are never inspected or extracted, hence they *can* be passed by
-reference. For instance, to turn ``std::vector<int>`` into an opaque type, add
-the declaration
-
-.. code-block:: cpp
-
-    PYBIND11_MAKE_OPAQUE(std::vector<int>);
-
-before any binding code (e.g. invocations to ``class_::def()``, etc.). This
-macro must be specified at the top level (and outside of any namespaces), since
-it instantiates a partial template overload. If your binding code consists of
-multiple compilation units, it must be present in every file (typically via a
-common header) preceding any usage of ``std::vector<int>``. Opaque types must
-also have a corresponding ``class_`` declaration to associate them with a name
-in Python, and to define a set of available operations, e.g.:
-
-.. code-block:: cpp
-
-    py::class_<std::vector<int>>(m, "IntVector")
-        .def(py::init<>())
-        .def("clear", &std::vector<int>::clear)
-        .def("pop_back", &std::vector<int>::pop_back)
-        .def("__len__", [](const std::vector<int> &v) { return v.size(); })
-        .def("__iter__", [](std::vector<int> &v) {
-           return py::make_iterator(v.begin(), v.end());
-        }, py::keep_alive<0, 1>()) /* Keep vector alive while iterator is used */
-        // ....
-
-Please take a look at the :ref:`macro_notes` before using the
-``PYBIND11_MAKE_OPAQUE`` macro.
-
-.. seealso::
-
-    The file :file:`tests/test_opaque_types.cpp` contains a complete
-    example that demonstrates how to create and expose opaque types using
-    pybind11 in more detail.
-
-.. _stl_bind:
-
-Binding STL containers
-======================
-
-The ability to expose STL containers as native Python objects is a fairly
-common request, hence pybind11 also provides an optional header file named
-:file:`pybind11/stl_bind.h` that does exactly this. The mapped containers try
-to match the behavior of their native Python counterparts as much as possible.
-
-The following example showcases usage of :file:`pybind11/stl_bind.h`:
-
-.. code-block:: cpp
-
-    // Don't forget this
-    #include <pybind11/stl_bind.h>
-
-    PYBIND11_MAKE_OPAQUE(std::vector<int>);
-    PYBIND11_MAKE_OPAQUE(std::map<std::string, double>);
-
-    // ...
-
-    // later in binding code:
-    py::bind_vector<std::vector<int>>(m, "VectorInt");
-    py::bind_map<std::map<std::string, double>>(m, "MapStringDouble");
-
-When binding STL containers pybind11 considers the types of the container's
-elements to decide whether the container should be confined to the local module
-(via the :ref:`module_local` feature).  If the container element types are
-anything other than already-bound custom types bound without
-``py::module_local()`` the container binding will have ``py::module_local()``
-applied.  This includes converting types such as numeric types, strings, Eigen
-types; and types that have not yet been bound at the time of the stl container
-binding.  This module-local binding is designed to avoid potential conflicts
-between module bindings (for example, from two separate modules each attempting
-to bind ``std::vector<int>`` as a python type).
-
-It is possible to override this behavior to force a definition to be either
-module-local or global.  To do so, you can pass the attributes
-``py::module_local()`` (to make the binding module-local) or
-``py::module_local(false)`` (to make the binding global) into the
-``py::bind_vector`` or ``py::bind_map`` arguments:
-
-.. code-block:: cpp
-
-    py::bind_vector<std::vector<int>>(m, "VectorInt", py::module_local(false));
-
-Note, however, that such a global binding would make it impossible to load this
-module at the same time as any other pybind module that also attempts to bind
-the same container type (``std::vector<int>`` in the above example).
-
-See :ref:`module_local` for more details on module-local bindings.
-
-.. seealso::
-
-    The file :file:`tests/test_stl_binders.cpp` shows how to use the
-    convenience STL container wrappers.
diff --git a/tmap/lib/pybind11/docs/advanced/cast/strings.rst b/tmap/lib/pybind11/docs/advanced/cast/strings.rst
deleted file mode 100644
index 2cdbade..0000000
--- a/tmap/lib/pybind11/docs/advanced/cast/strings.rst
+++ /dev/null
@@ -1,303 +0,0 @@
-Strings, bytes and Unicode conversions
-######################################
-
-.. note::
-
-    This section discusses string handling in terms of Python 3 strings. For
-    Python 2.7, replace all occurrences of ``str`` with ``unicode`` and
-    ``bytes`` with ``str``.  Python 2.7 users may find it best to use ``from
-    __future__ import unicode_literals`` to avoid unintentionally using ``str``
-    instead of ``unicode``.
-
-Passing Python strings to C++
-=============================
-
-When a Python ``str`` is passed from Python to a C++ function that accepts
-``std::string`` or ``char *`` as arguments, pybind11 will encode the Python
-string to UTF-8. All Python ``str`` can be encoded in UTF-8, so this operation
-does not fail.
-
-The C++ language is encoding agnostic. It is the responsibility of the
-programmer to track encodings. It's often easiest to simply `use UTF-8
-everywhere <http://utf8everywhere.org/>`_.
-
-.. code-block:: c++
-
-    m.def("utf8_test",
-        [](const std::string &s) {
-            cout << "utf-8 is icing on the cake.\n";
-            cout << s;
-        }
-    );
-    m.def("utf8_charptr",
-        [](const char *s) {
-            cout << "My favorite food is\n";
-            cout << s;
-        }
-    );
-
-.. code-block:: python
-
-    >>> utf8_test('🎂')
-    utf-8 is icing on the cake.
-    🎂
-
-    >>> utf8_charptr('🍕')
-    My favorite food is
-    🍕
-
-.. note::
-
-    Some terminal emulators do not support UTF-8 or emoji fonts and may not
-    display the example above correctly.
-
-The results are the same whether the C++ function accepts arguments by value or
-reference, and whether or not ``const`` is used.
-
-Passing bytes to C++
---------------------
-
-A Python ``bytes`` object will be passed to C++ functions that accept
-``std::string`` or ``char*`` *without* conversion.
-
-
-Returning C++ strings to Python
-===============================
-
-When a C++ function returns a ``std::string`` or ``char*`` to a Python caller,
-**pybind11 will assume that the string is valid UTF-8** and will decode it to a
-native Python ``str``, using the same API as Python uses to perform
-``bytes.decode('utf-8')``. If this implicit conversion fails, pybind11 will
-raise a ``UnicodeDecodeError``.
-
-.. code-block:: c++
-
-    m.def("std_string_return",
-        []() {
-            return std::string("This string needs to be UTF-8 encoded");
-        }
-    );
-
-.. code-block:: python
-
-    >>> isinstance(example.std_string_return(), str)
-    True
-
-
-Because UTF-8 is inclusive of pure ASCII, there is never any issue with
-returning a pure ASCII string to Python. If there is any possibility that the
-string is not pure ASCII, it is necessary to ensure the encoding is valid
-UTF-8.
-
-.. warning::
-
-    Implicit conversion assumes that a returned ``char *`` is null-terminated.
-    If there is no null terminator a buffer overrun will occur.
-
-Explicit conversions
---------------------
-
-If some C++ code constructs a ``std::string`` that is not a UTF-8 string, one
-can perform a explicit conversion and return a ``py::str`` object. Explicit
-conversion has the same overhead as implicit conversion.
-
-.. code-block:: c++
-
-    // This uses the Python C API to convert Latin-1 to Unicode
-    m.def("str_output",
-        []() {
-            std::string s = "Send your r\xe9sum\xe9 to Alice in HR"; // Latin-1
-            py::str py_s = PyUnicode_DecodeLatin1(s.data(), s.length());
-            return py_s;
-        }
-    );
-
-.. code-block:: python
-
-    >>> str_output()
-    'Send your résumé to Alice in HR'
-
-The `Python C API
-<https://docs.python.org/3/c-api/unicode.html#built-in-codecs>`_ provides
-several built-in codecs.
-
-
-One could also use a third party encoding library such as libiconv to transcode
-to UTF-8.
-
-Return C++ strings without conversion
--------------------------------------
-
-If the data in a C++ ``std::string`` does not represent text and should be
-returned to Python as ``bytes``, then one can return the data as a
-``py::bytes`` object.
-
-.. code-block:: c++
-
-    m.def("return_bytes",
-        []() {
-            std::string s("\xba\xd0\xba\xd0");  // Not valid UTF-8
-            return py::bytes(s);  // Return the data without transcoding
-        }
-    );
-
-.. code-block:: python
-
-    >>> example.return_bytes()
-    b'\xba\xd0\xba\xd0'
-
-
-Note the asymmetry: pybind11 will convert ``bytes`` to ``std::string`` without
-encoding, but cannot convert ``std::string`` back to ``bytes`` implicitly.
-
-.. code-block:: c++
-
-    m.def("asymmetry",
-        [](std::string s) {  // Accepts str or bytes from Python
-            return s;  // Looks harmless, but implicitly converts to str
-        }
-    );
-
-.. code-block:: python
-
-    >>> isinstance(example.asymmetry(b"have some bytes"), str)
-    True
-
-    >>> example.asymmetry(b"\xba\xd0\xba\xd0")  # invalid utf-8 as bytes
-    UnicodeDecodeError: 'utf-8' codec can't decode byte 0xba in position 0: invalid start byte
-
-
-Wide character strings
-======================
-
-When a Python ``str`` is passed to a C++ function expecting ``std::wstring``,
-``wchar_t*``, ``std::u16string`` or ``std::u32string``, the ``str`` will be
-encoded to UTF-16 or UTF-32 depending on how the C++ compiler implements each
-type, in the platform's native endianness. When strings of these types are
-returned, they are assumed to contain valid UTF-16 or UTF-32, and will be
-decoded to Python ``str``.
-
-.. code-block:: c++
-
-    #define UNICODE
-    #include <windows.h>
-
-    m.def("set_window_text",
-        [](HWND hwnd, std::wstring s) {
-            // Call SetWindowText with null-terminated UTF-16 string
-            ::SetWindowText(hwnd, s.c_str());
-        }
-    );
-    m.def("get_window_text",
-        [](HWND hwnd) {
-            const int buffer_size = ::GetWindowTextLength(hwnd) + 1;
-            auto buffer = std::make_unique< wchar_t[] >(buffer_size);
-
-            ::GetWindowText(hwnd, buffer.data(), buffer_size);
-
-            std::wstring text(buffer.get());
-
-            // wstring will be converted to Python str
-            return text;
-        }
-    );
-
-.. warning::
-
-    Wide character strings may not work as described on Python 2.7 or Python
-    3.3 compiled with ``--enable-unicode=ucs2``.
-
-Strings in multibyte encodings such as Shift-JIS must transcoded to a
-UTF-8/16/32 before being returned to Python.
-
-
-Character literals
-==================
-
-C++ functions that accept character literals as input will receive the first
-character of a Python ``str`` as their input. If the string is longer than one
-Unicode character, trailing characters will be ignored.
-
-When a character literal is returned from C++ (such as a ``char`` or a
-``wchar_t``), it will be converted to a ``str`` that represents the single
-character.
-
-.. code-block:: c++
-
-    m.def("pass_char", [](char c) { return c; });
-    m.def("pass_wchar", [](wchar_t w) { return w; });
-
-.. code-block:: python
-
-    >>> example.pass_char('A')
-    'A'
-
-While C++ will cast integers to character types (``char c = 0x65;``), pybind11
-does not convert Python integers to characters implicitly. The Python function
-``chr()`` can be used to convert integers to characters.
-
-.. code-block:: python
-
-    >>> example.pass_char(0x65)
-    TypeError
-
-    >>> example.pass_char(chr(0x65))
-    'A'
-
-If the desire is to work with an 8-bit integer, use ``int8_t`` or ``uint8_t``
-as the argument type.
-
-Grapheme clusters
------------------
-
-A single grapheme may be represented by two or more Unicode characters. For
-example 'é' is usually represented as U+00E9 but can also be expressed as the
-combining character sequence U+0065 U+0301 (that is, the letter 'e' followed by
-a combining acute accent). The combining character will be lost if the
-two-character sequence is passed as an argument, even though it renders as a
-single grapheme.
-
-.. code-block:: python
-
-    >>> example.pass_wchar('é')
-    'é'
-
-    >>> combining_e_acute = 'e' + '\u0301'
-
-    >>> combining_e_acute
-    'é'
-
-    >>> combining_e_acute == 'é'
-    False
-
-    >>> example.pass_wchar(combining_e_acute)
-    'e'
-
-Normalizing combining characters before passing the character literal to C++
-may resolve *some* of these issues:
-
-.. code-block:: python
-
-    >>> example.pass_wchar(unicodedata.normalize('NFC', combining_e_acute))
-    'é'
-
-In some languages (Thai for example), there are `graphemes that cannot be
-expressed as a single Unicode code point
-<http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries>`_, so there is
-no way to capture them in a C++ character type.
-
-
-C++17 string views
-==================
-
-C++17 string views are automatically supported when compiling in C++17 mode.
-They follow the same rules for encoding and decoding as the corresponding STL
-string type (for example, a ``std::u16string_view`` argument will be passed
-UTF-16-encoded data, and a returned ``std::string_view`` will be decoded as
-UTF-8).
-
-References
-==========
-
-* `The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!) <https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/>`_
-* `C++ - Using STL Strings at Win32 API Boundaries <https://msdn.microsoft.com/en-ca/magazine/mt238407.aspx>`_
diff --git a/tmap/lib/pybind11/docs/advanced/classes.rst b/tmap/lib/pybind11/docs/advanced/classes.rst
deleted file mode 100644
index be4bc2e..0000000
--- a/tmap/lib/pybind11/docs/advanced/classes.rst
+++ /dev/null
@@ -1,1033 +0,0 @@
-Classes
-#######
-
-This section presents advanced binding code for classes and it is assumed
-that you are already familiar with the basics from :doc:`/classes`.
-
-.. _overriding_virtuals:
-
-Overriding virtual functions in Python
-======================================
-
-Suppose that a C++ class or interface has a virtual function that we'd like to
-to override from within Python (we'll focus on the class ``Animal``; ``Dog`` is
-given as a specific example of how one would do this with traditional C++
-code).
-
-.. code-block:: cpp
-
-    class Animal {
-    public:
-        virtual ~Animal() { }
-        virtual std::string go(int n_times) = 0;
-    };
-
-    class Dog : public Animal {
-    public:
-        std::string go(int n_times) override {
-            std::string result;
-            for (int i=0; i<n_times; ++i)
-                result += "woof! ";
-            return result;
-        }
-    };
-
-Let's also suppose that we are given a plain function which calls the
-function ``go()`` on an arbitrary ``Animal`` instance.
-
-.. code-block:: cpp
-
-    std::string call_go(Animal *animal) {
-        return animal->go(3);
-    }
-
-Normally, the binding code for these classes would look as follows:
-
-.. code-block:: cpp
-
-    PYBIND11_MODULE(example, m) {
-        py::class_<Animal> animal(m, "Animal");
-        animal
-            .def("go", &Animal::go);
-
-        py::class_<Dog>(m, "Dog", animal)
-            .def(py::init<>());
-
-        m.def("call_go", &call_go);
-    }
-
-However, these bindings are impossible to extend: ``Animal`` is not
-constructible, and we clearly require some kind of "trampoline" that
-redirects virtual calls back to Python.
-
-Defining a new type of ``Animal`` from within Python is possible but requires a
-helper class that is defined as follows:
-
-.. code-block:: cpp
-
-    class PyAnimal : public Animal {
-    public:
-        /* Inherit the constructors */
-        using Animal::Animal;
-
-        /* Trampoline (need one for each virtual function) */
-        std::string go(int n_times) override {
-            PYBIND11_OVERLOAD_PURE(
-                std::string, /* Return type */
-                Animal,      /* Parent class */
-                go,          /* Name of function in C++ (must match Python name) */
-                n_times      /* Argument(s) */
-            );
-        }
-    };
-
-The macro :func:`PYBIND11_OVERLOAD_PURE` should be used for pure virtual
-functions, and :func:`PYBIND11_OVERLOAD` should be used for functions which have
-a default implementation.  There are also two alternate macros
-:func:`PYBIND11_OVERLOAD_PURE_NAME` and :func:`PYBIND11_OVERLOAD_NAME` which
-take a string-valued name argument between the *Parent class* and *Name of the
-function* slots, which defines the name of function in Python. This is required
-when the C++ and Python versions of the
-function have different names, e.g.  ``operator()`` vs ``__call__``.
-
-The binding code also needs a few minor adaptations (highlighted):
-
-.. code-block:: cpp
-    :emphasize-lines: 2,4,5
-
-    PYBIND11_MODULE(example, m) {
-        py::class_<Animal, PyAnimal /* <--- trampoline*/> animal(m, "Animal");
-        animal
-            .def(py::init<>())
-            .def("go", &Animal::go);
-
-        py::class_<Dog>(m, "Dog", animal)
-            .def(py::init<>());
-
-        m.def("call_go", &call_go);
-    }
-
-Importantly, pybind11 is made aware of the trampoline helper class by
-specifying it as an extra template argument to :class:`class_`. (This can also
-be combined with other template arguments such as a custom holder type; the
-order of template types does not matter).  Following this, we are able to
-define a constructor as usual.
-
-Bindings should be made against the actual class, not the trampoline helper class.
-
-.. code-block:: cpp
-
-    py::class_<Animal, PyAnimal /* <--- trampoline*/> animal(m, "Animal");
-        animal
-            .def(py::init<>())
-            .def("go", &PyAnimal::go); /* <--- THIS IS WRONG, use &Animal::go */
-
-Note, however, that the above is sufficient for allowing python classes to
-extend ``Animal``, but not ``Dog``: see :ref:`virtual_and_inheritance` for the
-necessary steps required to providing proper overload support for inherited
-classes.
-
-The Python session below shows how to override ``Animal::go`` and invoke it via
-a virtual method call.
-
-.. code-block:: pycon
-
-    >>> from example import *
-    >>> d = Dog()
-    >>> call_go(d)
-    u'woof! woof! woof! '
-    >>> class Cat(Animal):
-    ...     def go(self, n_times):
-    ...             return "meow! " * n_times
-    ...
-    >>> c = Cat()
-    >>> call_go(c)
-    u'meow! meow! meow! '
-
-If you are defining a custom constructor in a derived Python class, you *must*
-ensure that you explicitly call the bound C++ constructor using ``__init__``,
-*regardless* of whether it is a default constructor or not. Otherwise, the
-memory for the C++ portion of the instance will be left uninitialized, which
-will generally leave the C++ instance in an invalid state and cause undefined
-behavior if the C++ instance is subsequently used.
-
-Here is an example:
-
-.. code-block:: python
-
-    class Dachschund(Dog):
-        def __init__(self, name):
-            Dog.__init__(self) # Without this, undefind behavior may occur if the C++ portions are referenced.
-            self.name = name
-        def bark(self):
-            return "yap!"
-
-Note that a direct ``__init__`` constructor *should be called*, and ``super()``
-should not be used. For simple cases of linear inheritance, ``super()``
-may work, but once you begin mixing Python and C++ multiple inheritance,
-things will fall apart due to differences between Python's MRO and C++'s
-mechanisms.
-
-Please take a look at the :ref:`macro_notes` before using this feature.
-
-.. note::
-
-    When the overridden type returns a reference or pointer to a type that
-    pybind11 converts from Python (for example, numeric values, std::string,
-    and other built-in value-converting types), there are some limitations to
-    be aware of:
-
-    - because in these cases there is no C++ variable to reference (the value
-      is stored in the referenced Python variable), pybind11 provides one in
-      the PYBIND11_OVERLOAD macros (when needed) with static storage duration.
-      Note that this means that invoking the overloaded method on *any*
-      instance will change the referenced value stored in *all* instances of
-      that type.
-
-    - Attempts to modify a non-const reference will not have the desired
-      effect: it will change only the static cache variable, but this change
-      will not propagate to underlying Python instance, and the change will be
-      replaced the next time the overload is invoked.
-
-.. seealso::
-
-    The file :file:`tests/test_virtual_functions.cpp` contains a complete
-    example that demonstrates how to override virtual functions using pybind11
-    in more detail.
-
-.. _virtual_and_inheritance:
-
-Combining virtual functions and inheritance
-===========================================
-
-When combining virtual methods with inheritance, you need to be sure to provide
-an override for each method for which you want to allow overrides from derived
-python classes.  For example, suppose we extend the above ``Animal``/``Dog``
-example as follows:
-
-.. code-block:: cpp
-
-    class Animal {
-    public:
-        virtual std::string go(int n_times) = 0;
-        virtual std::string name() { return "unknown"; }
-    };
-    class Dog : public Animal {
-    public:
-        std::string go(int n_times) override {
-            std::string result;
-            for (int i=0; i<n_times; ++i)
-                result += bark() + " ";
-            return result;
-        }
-        virtual std::string bark() { return "woof!"; }
-    };
-
-then the trampoline class for ``Animal`` must, as described in the previous
-section, override ``go()`` and ``name()``, but in order to allow python code to
-inherit properly from ``Dog``, we also need a trampoline class for ``Dog`` that
-overrides both the added ``bark()`` method *and* the ``go()`` and ``name()``
-methods inherited from ``Animal`` (even though ``Dog`` doesn't directly
-override the ``name()`` method):
-
-.. code-block:: cpp
-
-    class PyAnimal : public Animal {
-    public:
-        using Animal::Animal; // Inherit constructors
-        std::string go(int n_times) override { PYBIND11_OVERLOAD_PURE(std::string, Animal, go, n_times); }
-        std::string name() override { PYBIND11_OVERLOAD(std::string, Animal, name, ); }
-    };
-    class PyDog : public Dog {
-    public:
-        using Dog::Dog; // Inherit constructors
-        std::string go(int n_times) override { PYBIND11_OVERLOAD_PURE(std::string, Dog, go, n_times); }
-        std::string name() override { PYBIND11_OVERLOAD(std::string, Dog, name, ); }
-        std::string bark() override { PYBIND11_OVERLOAD(std::string, Dog, bark, ); }
-    };
-
-.. note::
-
-    Note the trailing commas in the ``PYBIND11_OVERLOAD`` calls to ``name()``
-    and ``bark()``. These are needed to portably implement a trampoline for a
-    function that does not take any arguments. For functions that take
-    a nonzero number of arguments, the trailing comma must be omitted.
-
-A registered class derived from a pybind11-registered class with virtual
-methods requires a similar trampoline class, *even if* it doesn't explicitly
-declare or override any virtual methods itself:
-
-.. code-block:: cpp
-
-    class Husky : public Dog {};
-    class PyHusky : public Husky {
-    public:
-        using Husky::Husky; // Inherit constructors
-        std::string go(int n_times) override { PYBIND11_OVERLOAD_PURE(std::string, Husky, go, n_times); }
-        std::string name() override { PYBIND11_OVERLOAD(std::string, Husky, name, ); }
-        std::string bark() override { PYBIND11_OVERLOAD(std::string, Husky, bark, ); }
-    };
-
-There is, however, a technique that can be used to avoid this duplication
-(which can be especially helpful for a base class with several virtual
-methods).  The technique involves using template trampoline classes, as
-follows:
-
-.. code-block:: cpp
-
-    template <class AnimalBase = Animal> class PyAnimal : public AnimalBase {
-    public:
-        using AnimalBase::AnimalBase; // Inherit constructors
-        std::string go(int n_times) override { PYBIND11_OVERLOAD_PURE(std::string, AnimalBase, go, n_times); }
-        std::string name() override { PYBIND11_OVERLOAD(std::string, AnimalBase, name, ); }
-    };
-    template <class DogBase = Dog> class PyDog : public PyAnimal<DogBase> {
-    public:
-        using PyAnimal<DogBase>::PyAnimal; // Inherit constructors
-        // Override PyAnimal's pure virtual go() with a non-pure one:
-        std::string go(int n_times) override { PYBIND11_OVERLOAD(std::string, DogBase, go, n_times); }
-        std::string bark() override { PYBIND11_OVERLOAD(std::string, DogBase, bark, ); }
-    };
-
-This technique has the advantage of requiring just one trampoline method to be
-declared per virtual method and pure virtual method override.  It does,
-however, require the compiler to generate at least as many methods (and
-possibly more, if both pure virtual and overridden pure virtual methods are
-exposed, as above).
-
-The classes are then registered with pybind11 using:
-
-.. code-block:: cpp
-
-    py::class_<Animal, PyAnimal<>> animal(m, "Animal");
-    py::class_<Dog, PyDog<>> dog(m, "Dog");
-    py::class_<Husky, PyDog<Husky>> husky(m, "Husky");
-    // ... add animal, dog, husky definitions
-
-Note that ``Husky`` did not require a dedicated trampoline template class at
-all, since it neither declares any new virtual methods nor provides any pure
-virtual method implementations.
-
-With either the repeated-virtuals or templated trampoline methods in place, you
-can now create a python class that inherits from ``Dog``:
-
-.. code-block:: python
-
-    class ShihTzu(Dog):
-        def bark(self):
-            return "yip!"
-
-.. seealso::
-
-    See the file :file:`tests/test_virtual_functions.cpp` for complete examples
-    using both the duplication and templated trampoline approaches.
-
-.. _extended_aliases:
-
-Extended trampoline class functionality
-=======================================
-
-The trampoline classes described in the previous sections are, by default, only
-initialized when needed.  More specifically, they are initialized when a python
-class actually inherits from a registered type (instead of merely creating an
-instance of the registered type), or when a registered constructor is only
-valid for the trampoline class but not the registered class.  This is primarily
-for performance reasons: when the trampoline class is not needed for anything
-except virtual method dispatching, not initializing the trampoline class
-improves performance by avoiding needing to do a run-time check to see if the
-inheriting python instance has an overloaded method.
-
-Sometimes, however, it is useful to always initialize a trampoline class as an
-intermediate class that does more than just handle virtual method dispatching.
-For example, such a class might perform extra class initialization, extra
-destruction operations, and might define new members and methods to enable a
-more python-like interface to a class.
-
-In order to tell pybind11 that it should *always* initialize the trampoline
-class when creating new instances of a type, the class constructors should be
-declared using ``py::init_alias<Args, ...>()`` instead of the usual
-``py::init<Args, ...>()``.  This forces construction via the trampoline class,
-ensuring member initialization and (eventual) destruction.
-
-.. seealso::
-
-    See the file :file:`tests/test_virtual_functions.cpp` for complete examples
-    showing both normal and forced trampoline instantiation.
-
-.. _custom_constructors:
-
-Custom constructors
-===================
-
-The syntax for binding constructors was previously introduced, but it only
-works when a constructor of the appropriate arguments actually exists on the
-C++ side.  To extend this to more general cases, pybind11 offers two different
-approaches: binding factory functions, and placement-new creation.
-
-Factory function constructors
------------------------------
-
-It is possible to expose a Python-side constructor from a C++ function that
-returns a new object by value or pointer.  For example, suppose you have a
-class like this:
-
-.. code-block:: cpp
-
-    class Example {
-    private:
-        Example(int); // private constructor
-    public:
-        // Factory function:
-        static Example create(int a) { return Example(a); }
-    };
-
-While it is possible to create a straightforward binding of the static
-``create`` method, it may sometimes be preferable to expose it as a constructor
-on the Python side. This can be accomplished by calling ``.def(py::init(...))``
-with the function reference returning the new instance passed as an argument.
-It is also possible to use this approach to bind a function returning a new
-instance by raw pointer or by the holder (e.g. ``std::unique_ptr``).
-
-The following example shows the different approaches:
-
-.. code-block:: cpp
-
-    class Example {
-    private:
-        Example(int); // private constructor
-    public:
-        // Factory function - returned by value:
-        static Example create(int a) { return Example(a); }
-
-        // These constructors are publicly callable:
-        Example(double);
-        Example(int, int);
-        Example(std::string);
-    };
-
-    py::class_<Example>(m, "Example")
-        // Bind the factory function as a constructor:
-        .def(py::init(&Example::create))
-        // Bind a lambda function returning a pointer wrapped in a holder:
-        .def(py::init([](std::string arg) {
-            return std::unique_ptr<Example>(new Example(arg));
-        }))
-        // Return a raw pointer:
-        .def(py::init([](int a, int b) { return new Example(a, b); }))
-        // You can mix the above with regular C++ constructor bindings as well:
-        .def(py::init<double>())
-        ;
-
-When the constructor is invoked from Python, pybind11 will call the factory
-function and store the resulting C++ instance in the Python instance.
-
-When combining factory functions constructors with :ref:`virtual function
-trampolines <overriding_virtuals>` there are two approaches.  The first is to
-add a constructor to the alias class that takes a base value by
-rvalue-reference.  If such a constructor is available, it will be used to
-construct an alias instance from the value returned by the factory function.
-The second option is to provide two factory functions to ``py::init()``: the
-first will be invoked when no alias class is required (i.e. when the class is
-being used but not inherited from in Python), and the second will be invoked
-when an alias is required.
-
-You can also specify a single factory function that always returns an alias
-instance: this will result in behaviour similar to ``py::init_alias<...>()``,
-as described in the :ref:`extended trampoline class documentation
-<extended_aliases>`.
-
-The following example shows the different factory approaches for a class with
-an alias:
-
-.. code-block:: cpp
-
-    #include <pybind11/factory.h>
-    class Example {
-    public:
-        // ...
-        virtual ~Example() = default;
-    };
-    class PyExample : public Example {
-    public:
-        using Example::Example;
-        PyExample(Example &&base) : Example(std::move(base)) {}
-    };
-    py::class_<Example, PyExample>(m, "Example")
-        // Returns an Example pointer.  If a PyExample is needed, the Example
-        // instance will be moved via the extra constructor in PyExample, above.
-        .def(py::init([]() { return new Example(); }))
-        // Two callbacks:
-        .def(py::init([]() { return new Example(); } /* no alias needed */,
-                      []() { return new PyExample(); } /* alias needed */))
-        // *Always* returns an alias instance (like py::init_alias<>())
-        .def(py::init([]() { return new PyExample(); }))
-        ;
-
-Low-level placement-new construction
-------------------------------------
-
-A second approach for creating new instances use C++ placement new to construct
-an object in-place in preallocated memory.  To do this, you simply bind a
-method name ``__init__`` that takes the class instance as the first argument by
-pointer or reference, then uses a placement-new constructor to construct the
-object in the pre-allocated (but uninitialized) memory.
-
-For example, instead of:
-
-.. code-block:: cpp
-
-    py::class_<Example>(m, "Example")
-        .def(py::init<int>());
-
-you could equivalently write:
-
-.. code-block:: cpp
-
-    py::class_<Example>(m, "Example")
-        .def("__init__",
-            [](Example &instance, int arg) {
-                new (&instance) Example(arg);
-            }
-        );
-
-which will invoke the constructor in-place at the pre-allocated memory.
-
-Brace initialization
---------------------
-
-``pybind11::init<>`` internally uses C++11 brace initialization to call the
-constructor of the target class. This means that it can be used to bind
-*implicit* constructors as well:
-
-.. code-block:: cpp
-
-    struct Aggregate {
-        int a;
-        std::string b;
-    };
-
-    py::class_<Aggregate>(m, "Aggregate")
-        .def(py::init<int, const std::string &>());
-
-.. note::
-
-    Note that brace initialization preferentially invokes constructor overloads
-    taking a ``std::initializer_list``. In the rare event that this causes an
-    issue, you can work around it by using ``py::init(...)`` with a lambda
-    function that constructs the new object as desired.
-
-.. _classes_with_non_public_destructors:
-
-Non-public destructors
-======================
-
-If a class has a private or protected destructor (as might e.g. be the case in
-a singleton pattern), a compile error will occur when creating bindings via
-pybind11. The underlying issue is that the ``std::unique_ptr`` holder type that
-is responsible for managing the lifetime of instances will reference the
-destructor even if no deallocations ever take place. In order to expose classes
-with private or protected destructors, it is possible to override the holder
-type via a holder type argument to ``class_``. Pybind11 provides a helper class
-``py::nodelete`` that disables any destructor invocations. In this case, it is
-crucial that instances are deallocated on the C++ side to avoid memory leaks.
-
-.. code-block:: cpp
-
-    /* ... definition ... */
-
-    class MyClass {
-    private:
-        ~MyClass() { }
-    };
-
-    /* ... binding code ... */
-
-    py::class_<MyClass, std::unique_ptr<MyClass, py::nodelete>>(m, "MyClass")
-        .def(py::init<>())
-
-.. _implicit_conversions:
-
-Implicit conversions
-====================
-
-Suppose that instances of two types ``A`` and ``B`` are used in a project, and
-that an ``A`` can easily be converted into an instance of type ``B`` (examples of this
-could be a fixed and an arbitrary precision number type).
-
-.. code-block:: cpp
-
-    py::class_<A>(m, "A")
-        /// ... members ...
-
-    py::class_<B>(m, "B")
-        .def(py::init<A>())
-        /// ... members ...
-
-    m.def("func",
-        [](const B &) { /* .... */ }
-    );
-
-To invoke the function ``func`` using a variable ``a`` containing an ``A``
-instance, we'd have to write ``func(B(a))`` in Python. On the other hand, C++
-will automatically apply an implicit type conversion, which makes it possible
-to directly write ``func(a)``.
-
-In this situation (i.e. where ``B`` has a constructor that converts from
-``A``), the following statement enables similar implicit conversions on the
-Python side:
-
-.. code-block:: cpp
-
-    py::implicitly_convertible<A, B>();
-
-.. note::
-
-    Implicit conversions from ``A`` to ``B`` only work when ``B`` is a custom
-    data type that is exposed to Python via pybind11.
-
-    To prevent runaway recursion, implicit conversions are non-reentrant: an
-    implicit conversion invoked as part of another implicit conversion of the
-    same type (i.e. from ``A`` to ``B``) will fail.
-
-.. _static_properties:
-
-Static properties
-=================
-
-The section on :ref:`properties` discussed the creation of instance properties
-that are implemented in terms of C++ getters and setters.
-
-Static properties can also be created in a similar way to expose getters and
-setters of static class attributes. Note that the implicit ``self`` argument
-also exists in this case and is used to pass the Python ``type`` subclass
-instance. This parameter will often not be needed by the C++ side, and the
-following example illustrates how to instantiate a lambda getter function
-that ignores it:
-
-.. code-block:: cpp
-
-    py::class_<Foo>(m, "Foo")
-        .def_property_readonly_static("foo", [](py::object /* self */) { return Foo(); });
-
-Operator overloading
-====================
-
-Suppose that we're given the following ``Vector2`` class with a vector addition
-and scalar multiplication operation, all implemented using overloaded operators
-in C++.
-
-.. code-block:: cpp
-
-    class Vector2 {
-    public:
-        Vector2(float x, float y) : x(x), y(y) { }
-
-        Vector2 operator+(const Vector2 &v) const { return Vector2(x + v.x, y + v.y); }
-        Vector2 operator*(float value) const { return Vector2(x * value, y * value); }
-        Vector2& operator+=(const Vector2 &v) { x += v.x; y += v.y; return *this; }
-        Vector2& operator*=(float v) { x *= v; y *= v; return *this; }
-
-        friend Vector2 operator*(float f, const Vector2 &v) {
-            return Vector2(f * v.x, f * v.y);
-        }
-
-        std::string toString() const {
-            return "[" + std::to_string(x) + ", " + std::to_string(y) + "]";
-        }
-    private:
-        float x, y;
-    };
-
-The following snippet shows how the above operators can be conveniently exposed
-to Python.
-
-.. code-block:: cpp
-
-    #include <pybind11/operators.h>
-
-    PYBIND11_MODULE(example, m) {
-        py::class_<Vector2>(m, "Vector2")
-            .def(py::init<float, float>())
-            .def(py::self + py::self)
-            .def(py::self += py::self)
-            .def(py::self *= float())
-            .def(float() * py::self)
-            .def(py::self * float())
-            .def("__repr__", &Vector2::toString);
-    }
-
-Note that a line like
-
-.. code-block:: cpp
-
-            .def(py::self * float())
-
-is really just short hand notation for
-
-.. code-block:: cpp
-
-    .def("__mul__", [](const Vector2 &a, float b) {
-        return a * b;
-    }, py::is_operator())
-
-This can be useful for exposing additional operators that don't exist on the
-C++ side, or to perform other types of customization. The ``py::is_operator``
-flag marker is needed to inform pybind11 that this is an operator, which
-returns ``NotImplemented`` when invoked with incompatible arguments rather than
-throwing a type error.
-
-.. note::
-
-    To use the more convenient ``py::self`` notation, the additional
-    header file :file:`pybind11/operators.h` must be included.
-
-.. seealso::
-
-    The file :file:`tests/test_operator_overloading.cpp` contains a
-    complete example that demonstrates how to work with overloaded operators in
-    more detail.
-
-.. _pickling:
-
-Pickling support
-================
-
-Python's ``pickle`` module provides a powerful facility to serialize and
-de-serialize a Python object graph into a binary data stream. To pickle and
-unpickle C++ classes using pybind11, a ``py::pickle()`` definition must be
-provided. Suppose the class in question has the following signature:
-
-.. code-block:: cpp
-
-    class Pickleable {
-    public:
-        Pickleable(const std::string &value) : m_value(value) { }
-        const std::string &value() const { return m_value; }
-
-        void setExtra(int extra) { m_extra = extra; }
-        int extra() const { return m_extra; }
-    private:
-        std::string m_value;
-        int m_extra = 0;
-    };
-
-Pickling support in Python is enable by defining the ``__setstate__`` and
-``__getstate__`` methods [#f3]_. For pybind11 classes, use ``py::pickle()``
-to bind these two functions:
-
-.. code-block:: cpp
-
-    py::class_<Pickleable>(m, "Pickleable")
-        .def(py::init<std::string>())
-        .def("value", &Pickleable::value)
-        .def("extra", &Pickleable::extra)
-        .def("setExtra", &Pickleable::setExtra)
-        .def(py::pickle(
-            [](const Pickleable &p) { // __getstate__
-                /* Return a tuple that fully encodes the state of the object */
-                return py::make_tuple(p.value(), p.extra());
-            },
-            [](py::tuple t) { // __setstate__
-                if (t.size() != 2)
-                    throw std::runtime_error("Invalid state!");
-
-                /* Create a new C++ instance */
-                Pickleable p(t[0].cast<std::string>());
-
-                /* Assign any additional state */
-                p.setExtra(t[1].cast<int>());
-
-                return p;
-            }
-        ));
-
-The ``__setstate__`` part of the ``py::picke()`` definition follows the same
-rules as the single-argument version of ``py::init()``. The return type can be
-a value, pointer or holder type. See :ref:`custom_constructors` for details.
-
-An instance can now be pickled as follows:
-
-.. code-block:: python
-
-    try:
-        import cPickle as pickle  # Use cPickle on Python 2.7
-    except ImportError:
-        import pickle
-
-    p = Pickleable("test_value")
-    p.setExtra(15)
-    data = pickle.dumps(p, 2)
-
-Note that only the cPickle module is supported on Python 2.7. The second
-argument to ``dumps`` is also crucial: it selects the pickle protocol version
-2, since the older version 1 is not supported. Newer versions are also fine—for
-instance, specify ``-1`` to always use the latest available version. Beware:
-failure to follow these instructions will cause important pybind11 memory
-allocation routines to be skipped during unpickling, which will likely lead to
-memory corruption and/or segmentation faults.
-
-.. seealso::
-
-    The file :file:`tests/test_pickling.cpp` contains a complete example
-    that demonstrates how to pickle and unpickle types using pybind11 in more
-    detail.
-
-.. [#f3] http://docs.python.org/3/library/pickle.html#pickling-class-instances
-
-Multiple Inheritance
-====================
-
-pybind11 can create bindings for types that derive from multiple base types
-(aka. *multiple inheritance*). To do so, specify all bases in the template
-arguments of the ``class_`` declaration:
-
-.. code-block:: cpp
-
-    py::class_<MyType, BaseType1, BaseType2, BaseType3>(m, "MyType")
-       ...
-
-The base types can be specified in arbitrary order, and they can even be
-interspersed with alias types and holder types (discussed earlier in this
-document)---pybind11 will automatically find out which is which. The only
-requirement is that the first template argument is the type to be declared.
-
-It is also permitted to inherit multiply from exported C++ classes in Python,
-as well as inheriting from multiple Python and/or pybind-exported classes.
-
-There is one caveat regarding the implementation of this feature:
-
-When only one base type is specified for a C++ type that actually has multiple
-bases, pybind11 will assume that it does not participate in multiple
-inheritance, which can lead to undefined behavior. In such cases, add the tag
-``multiple_inheritance`` to the class constructor:
-
-.. code-block:: cpp
-
-    py::class_<MyType, BaseType2>(m, "MyType", py::multiple_inheritance());
-
-The tag is redundant and does not need to be specified when multiple base types
-are listed.
-
-.. _module_local:
-
-Module-local class bindings
-===========================
-
-When creating a binding for a class, pybind by default makes that binding
-"global" across modules.  What this means is that a type defined in one module
-can be returned from any module resulting in the same Python type.  For
-example, this allows the following:
-
-.. code-block:: cpp
-
-    // In the module1.cpp binding code for module1:
-    py::class_<Pet>(m, "Pet")
-        .def(py::init<std::string>())
-        .def_readonly("name", &Pet::name);
-
-.. code-block:: cpp
-
-    // In the module2.cpp binding code for module2:
-    m.def("create_pet", [](std::string name) { return new Pet(name); });
-
-.. code-block:: pycon
-
-    >>> from module1 import Pet
-    >>> from module2 import create_pet
-    >>> pet1 = Pet("Kitty")
-    >>> pet2 = create_pet("Doggy")
-    >>> pet2.name()
-    'Doggy'
-
-When writing binding code for a library, this is usually desirable: this
-allows, for example, splitting up a complex library into multiple Python
-modules.
-
-In some cases, however, this can cause conflicts.  For example, suppose two
-unrelated modules make use of an external C++ library and each provide custom
-bindings for one of that library's classes.  This will result in an error when
-a Python program attempts to import both modules (directly or indirectly)
-because of conflicting definitions on the external type:
-
-.. code-block:: cpp
-
-    // dogs.cpp
-
-    // Binding for external library class:
-    py::class<pets::Pet>(m, "Pet")
-        .def("name", &pets::Pet::name);
-
-    // Binding for local extension class:
-    py::class<Dog, pets::Pet>(m, "Dog")
-        .def(py::init<std::string>());
-
-.. code-block:: cpp
-
-    // cats.cpp, in a completely separate project from the above dogs.cpp.
-
-    // Binding for external library class:
-    py::class<pets::Pet>(m, "Pet")
-        .def("get_name", &pets::Pet::name);
-
-    // Binding for local extending class:
-    py::class<Cat, pets::Pet>(m, "Cat")
-        .def(py::init<std::string>());
-
-.. code-block:: pycon
-
-    >>> import cats
-    >>> import dogs
-    Traceback (most recent call last):
-      File "<stdin>", line 1, in <module>
-    ImportError: generic_type: type "Pet" is already registered!
-
-To get around this, you can tell pybind11 to keep the external class binding
-localized to the module by passing the ``py::module_local()`` attribute into
-the ``py::class_`` constructor:
-
-.. code-block:: cpp
-
-    // Pet binding in dogs.cpp:
-    py::class<pets::Pet>(m, "Pet", py::module_local())
-        .def("name", &pets::Pet::name);
-
-.. code-block:: cpp
-
-    // Pet binding in cats.cpp:
-    py::class<pets::Pet>(m, "Pet", py::module_local())
-        .def("get_name", &pets::Pet::name);
-
-This makes the Python-side ``dogs.Pet`` and ``cats.Pet`` into distinct classes,
-avoiding the conflict and allowing both modules to be loaded.  C++ code in the
-``dogs`` module that casts or returns a ``Pet`` instance will result in a
-``dogs.Pet`` Python instance, while C++ code in the ``cats`` module will result
-in a ``cats.Pet`` Python instance.
-
-This does come with two caveats, however: First, external modules cannot return
-or cast a ``Pet`` instance to Python (unless they also provide their own local
-bindings).  Second, from the Python point of view they are two distinct classes.
-
-Note that the locality only applies in the C++ -> Python direction.  When
-passing such a ``py::module_local`` type into a C++ function, the module-local
-classes are still considered.  This means that if the following function is
-added to any module (including but not limited to the ``cats`` and ``dogs``
-modules above) it will be callable with either a ``dogs.Pet`` or ``cats.Pet``
-argument:
-
-.. code-block:: cpp
-
-    m.def("pet_name", [](const pets::Pet &pet) { return pet.name(); });
-
-For example, suppose the above function is added to each of ``cats.cpp``,
-``dogs.cpp`` and ``frogs.cpp`` (where ``frogs.cpp`` is some other module that
-does *not* bind ``Pets`` at all).
-
-.. code-block:: pycon
-
-    >>> import cats, dogs, frogs  # No error because of the added py::module_local()
-    >>> mycat, mydog = cats.Cat("Fluffy"), dogs.Dog("Rover")
-    >>> (cats.pet_name(mycat), dogs.pet_name(mydog))
-    ('Fluffy', 'Rover')
-    >>> (cats.pet_name(mydog), dogs.pet_name(mycat), frogs.pet_name(mycat))
-    ('Rover', 'Fluffy', 'Fluffy')
-
-It is possible to use ``py::module_local()`` registrations in one module even
-if another module registers the same type globally: within the module with the
-module-local definition, all C++ instances will be cast to the associated bound
-Python type.  In other modules any such values are converted to the global
-Python type created elsewhere.
-
-.. note::
-
-    STL bindings (as provided via the optional :file:`pybind11/stl_bind.h`
-    header) apply ``py::module_local`` by default when the bound type might
-    conflict with other modules; see :ref:`stl_bind` for details.
-
-.. note::
-
-    The localization of the bound types is actually tied to the shared object
-    or binary generated by the compiler/linker.  For typical modules created
-    with ``PYBIND11_MODULE()``, this distinction is not significant.  It is
-    possible, however, when :ref:`embedding` to embed multiple modules in the
-    same binary (see :ref:`embedding_modules`).  In such a case, the
-    localization will apply across all embedded modules within the same binary.
-
-.. seealso::
-
-    The file :file:`tests/test_local_bindings.cpp` contains additional examples
-    that demonstrate how ``py::module_local()`` works.
-
-Binding protected member functions
-==================================
-
-It's normally not possible to expose ``protected`` member functions to Python:
-
-.. code-block:: cpp
-
-    class A {
-    protected:
-        int foo() const { return 42; }
-    };
-
-    py::class_<A>(m, "A")
-        .def("foo", &A::foo); // error: 'foo' is a protected member of 'A'
-
-On one hand, this is good because non-``public`` members aren't meant to be
-accessed from the outside. But we may want to make use of ``protected``
-functions in derived Python classes.
-
-The following pattern makes this possible:
-
-.. code-block:: cpp
-
-    class A {
-    protected:
-        int foo() const { return 42; }
-    };
-
-    class Publicist : public A { // helper type for exposing protected functions
-    public:
-        using A::foo; // inherited with different access modifier
-    };
-
-    py::class_<A>(m, "A") // bind the primary class
-        .def("foo", &Publicist::foo); // expose protected methods via the publicist
-
-This works because ``&Publicist::foo`` is exactly the same function as
-``&A::foo`` (same signature and address), just with a different access
-modifier. The only purpose of the ``Publicist`` helper class is to make
-the function name ``public``.
-
-If the intent is to expose ``protected`` ``virtual`` functions which can be
-overridden in Python, the publicist pattern can be combined with the previously
-described trampoline:
-
-.. code-block:: cpp
-
-    class A {
-    public:
-        virtual ~A() = default;
-
-    protected:
-        virtual int foo() const { return 42; }
-    };
-
-    class Trampoline : public A {
-    public:
-        int foo() const override { PYBIND11_OVERLOAD(int, A, foo, ); }
-    };
-
-    class Publicist : public A {
-    public:
-        using A::foo;
-    };
-
-    py::class_<A, Trampoline>(m, "A") // <-- `Trampoline` here
-        .def("foo", &Publicist::foo); // <-- `Publicist` here, not `Trampoline`!
-
-.. note::
-
-    MSVC 2015 has a compiler bug (fixed in version 2017) which
-    requires a more explicit function binding in the form of
-    ``.def("foo", static_cast<int (A::*)() const>(&Publicist::foo));``
-    where ``int (A::*)() const`` is the type of ``A::foo``.
diff --git a/tmap/lib/pybind11/docs/advanced/embedding.rst b/tmap/lib/pybind11/docs/advanced/embedding.rst
deleted file mode 100644
index bdfc75e..0000000
--- a/tmap/lib/pybind11/docs/advanced/embedding.rst
+++ /dev/null
@@ -1,256 +0,0 @@
-.. _embedding:
-
-Embedding the interpreter
-#########################
-
-While pybind11 is mainly focused on extending Python using C++, it's also
-possible to do the reverse: embed the Python interpreter into a C++ program.
-All of the other documentation pages still apply here, so refer to them for
-general pybind11 usage. This section will cover a few extra things required
-for embedding.
-
-Getting started
-===============
-
-A basic executable with an embedded interpreter can be created with just a few
-lines of CMake and the ``pybind11::embed`` target, as shown below. For more
-information, see :doc:`/compiling`.
-
-.. code-block:: cmake
-
-    cmake_minimum_required(VERSION 3.0)
-    project(example)
-
-    find_package(pybind11 REQUIRED)  # or `add_subdirectory(pybind11)`
-
-    add_executable(example main.cpp)
-    target_link_libraries(example PRIVATE pybind11::embed)
-
-The essential structure of the ``main.cpp`` file looks like this:
-
-.. code-block:: cpp
-
-    #include <pybind11/embed.h> // everything needed for embedding
-    namespace py = pybind11;
-
-    int main() {
-        py::scoped_interpreter guard{}; // start the interpreter and keep it alive
-
-        py::print("Hello, World!"); // use the Python API
-    }
-
-The interpreter must be initialized before using any Python API, which includes
-all the functions and classes in pybind11. The RAII guard class `scoped_interpreter`
-takes care of the interpreter lifetime. After the guard is destroyed, the interpreter
-shuts down and clears its memory. No Python functions can be called after this.
-
-Executing Python code
-=====================
-
-There are a few different ways to run Python code. One option is to use `eval`,
-`exec` or `eval_file`, as explained in :ref:`eval`. Here is a quick example in
-the context of an executable with an embedded interpreter:
-
-.. code-block:: cpp
-
-    #include <pybind11/embed.h>
-    namespace py = pybind11;
-
-    int main() {
-        py::scoped_interpreter guard{};
-
-        py::exec(R"(
-            kwargs = dict(name="World", number=42)
-            message = "Hello, {name}! The answer is {number}".format(**kwargs)
-            print(message)
-        )");
-    }
-
-Alternatively, similar results can be achieved using pybind11's API (see
-:doc:`/advanced/pycpp/index` for more details).
-
-.. code-block:: cpp
-
-    #include <pybind11/embed.h>
-    namespace py = pybind11;
-    using namespace py::literals;
-
-    int main() {
-        py::scoped_interpreter guard{};
-
-        auto kwargs = py::dict("name"_a="World", "number"_a=42);
-        auto message = "Hello, {name}! The answer is {number}"_s.format(**kwargs);
-        py::print(message);
-    }
-
-The two approaches can also be combined:
-
-.. code-block:: cpp
-
-    #include <pybind11/embed.h>
-    #include <iostream>
-
-    namespace py = pybind11;
-    using namespace py::literals;
-
-    int main() {
-        py::scoped_interpreter guard{};
-
-        auto locals = py::dict("name"_a="World", "number"_a=42);
-        py::exec(R"(
-            message = "Hello, {name}! The answer is {number}".format(**locals())
-        )", py::globals(), locals);
-
-        auto message = locals["message"].cast<std::string>();
-        std::cout << message;
-    }
-
-Importing modules
-=================
-
-Python modules can be imported using `module::import()`:
-
-.. code-block:: cpp
-
-    py::module sys = py::module::import("sys");
-    py::print(sys.attr("path"));
-
-For convenience, the current working directory is included in ``sys.path`` when
-embedding the interpreter. This makes it easy to import local Python files:
-
-.. code-block:: python
-
-    """calc.py located in the working directory"""
-
-    def add(i, j):
-        return i + j
-
-
-.. code-block:: cpp
-
-    py::module calc = py::module::import("calc");
-    py::object result = calc.attr("add")(1, 2);
-    int n = result.cast<int>();
-    assert(n == 3);
-
-.. _embedding_modules:
-
-Adding embedded modules
-=======================
-
-Embedded binary modules can be added using the `PYBIND11_EMBEDDED_MODULE` macro.
-Note that the definition must be placed at global scope. They can be imported
-like any other module.
-
-.. code-block:: cpp
-
-    #include <pybind11/embed.h>
-    namespace py = pybind11;
-
-    PYBIND11_EMBEDDED_MODULE(fast_calc, m) {
-        // `m` is a `py::module` which is used to bind functions and classes
-        m.def("add", [](int i, int j) {
-            return i + j;
-        });
-    }
-
-    int main() {
-        py::scoped_interpreter guard{};
-
-        auto fast_calc = py::module::import("fast_calc");
-        auto result = fast_calc.attr("add")(1, 2).cast<int>();
-        assert(result == 3);
-    }
-
-Unlike extension modules where only a single binary module can be created, on
-the embedded side an unlimited number of modules can be added using multiple
-`PYBIND11_EMBEDDED_MODULE` definitions (as long as they have unique names).
-
-These modules are added to Python's list of builtins, so they can also be
-imported in pure Python files loaded by the interpreter. Everything interacts
-naturally:
-
-.. code-block:: python
-
-    """py_module.py located in the working directory"""
-    import cpp_module
-
-    a = cpp_module.a
-    b = a + 1
-
-
-.. code-block:: cpp
-
-    #include <pybind11/embed.h>
-    namespace py = pybind11;
-
-    PYBIND11_EMBEDDED_MODULE(cpp_module, m) {
-        m.attr("a") = 1
-    }
-
-    int main() {
-        py::scoped_interpreter guard{};
-
-        auto py_module = py::module::import("py_module");
-
-        auto locals = py::dict("fmt"_a="{} + {} = {}", **py_module.attr("__dict__"));
-        assert(locals["a"].cast<int>() == 1);
-        assert(locals["b"].cast<int>() == 2);
-
-        py::exec(R"(
-            c = a + b
-            message = fmt.format(a, b, c)
-        )", py::globals(), locals);
-
-        assert(locals["c"].cast<int>() == 3);
-        assert(locals["message"].cast<std::string>() == "1 + 2 = 3");
-    }
-
-
-Interpreter lifetime
-====================
-
-The Python interpreter shuts down when `scoped_interpreter` is destroyed. After
-this, creating a new instance will restart the interpreter. Alternatively, the
-`initialize_interpreter` / `finalize_interpreter` pair of functions can be used
-to directly set the state at any time.
-
-Modules created with pybind11 can be safely re-initialized after the interpreter
-has been restarted. However, this may not apply to third-party extension modules.
-The issue is that Python itself cannot completely unload extension modules and
-there are several caveats with regard to interpreter restarting. In short, not
-all memory may be freed, either due to Python reference cycles or user-created
-global data. All the details can be found in the CPython documentation.
-
-.. warning::
-
-    Creating two concurrent `scoped_interpreter` guards is a fatal error. So is
-    calling `initialize_interpreter` for a second time after the interpreter
-    has already been initialized.
-
-    Do not use the raw CPython API functions ``Py_Initialize`` and
-    ``Py_Finalize`` as these do not properly handle the lifetime of
-    pybind11's internal data.
-
-
-Sub-interpreter support
-=======================
-
-Creating multiple copies of `scoped_interpreter` is not possible because it
-represents the main Python interpreter. Sub-interpreters are something different
-and they do permit the existence of multiple interpreters. This is an advanced
-feature of the CPython API and should be handled with care. pybind11 does not
-currently offer a C++ interface for sub-interpreters, so refer to the CPython
-documentation for all the details regarding this feature.
-
-We'll just mention a couple of caveats the sub-interpreters support in pybind11:
-
- 1. Sub-interpreters will not receive independent copies of embedded modules.
-    Instead, these are shared and modifications in one interpreter may be
-    reflected in another.
-
- 2. Managing multiple threads, multiple interpreters and the GIL can be
-    challenging and there are several caveats here, even within the pure
-    CPython API (please refer to the Python docs for details). As for
-    pybind11, keep in mind that `gil_scoped_release` and `gil_scoped_acquire`
-    do not take sub-interpreters into account.
diff --git a/tmap/lib/pybind11/docs/advanced/exceptions.rst b/tmap/lib/pybind11/docs/advanced/exceptions.rst
deleted file mode 100644
index 3483379..0000000
--- a/tmap/lib/pybind11/docs/advanced/exceptions.rst
+++ /dev/null
@@ -1,142 +0,0 @@
-Exceptions
-##########
-
-Built-in exception translation
-==============================
-
-When C++ code invoked from Python throws an ``std::exception``, it is
-automatically converted into a Python ``Exception``. pybind11 defines multiple
-special exception classes that will map to different types of Python
-exceptions:
-
-.. tabularcolumns:: |p{0.5\textwidth}|p{0.45\textwidth}|
-
-+--------------------------------------+------------------------------+
-|  C++ exception type                  |  Python exception type       |
-+======================================+==============================+
-| :class:`std::exception`              | ``RuntimeError``             |
-+--------------------------------------+------------------------------+
-| :class:`std::bad_alloc`              | ``MemoryError``              |
-+--------------------------------------+------------------------------+
-| :class:`std::domain_error`           | ``ValueError``               |
-+--------------------------------------+------------------------------+
-| :class:`std::invalid_argument`       | ``ValueError``               |
-+--------------------------------------+------------------------------+
-| :class:`std::length_error`           | ``ValueError``               |
-+--------------------------------------+------------------------------+
-| :class:`std::out_of_range`           | ``ValueError``               |
-+--------------------------------------+------------------------------+
-| :class:`std::range_error`            | ``ValueError``               |
-+--------------------------------------+------------------------------+
-| :class:`pybind11::stop_iteration`    | ``StopIteration`` (used to   |
-|                                      | implement custom iterators)  |
-+--------------------------------------+------------------------------+
-| :class:`pybind11::index_error`       | ``IndexError`` (used to      |
-|                                      | indicate out of bounds       |
-|                                      | accesses in ``__getitem__``, |
-|                                      | ``__setitem__``, etc.)       |
-+--------------------------------------+------------------------------+
-| :class:`pybind11::value_error`       | ``ValueError`` (used to      |
-|                                      | indicate wrong value passed  |
-|                                      | in ``container.remove(...)`` |
-+--------------------------------------+------------------------------+
-| :class:`pybind11::key_error`         | ``KeyError`` (used to        |
-|                                      | indicate out of bounds       |
-|                                      | accesses in ``__getitem__``, |
-|                                      | ``__setitem__`` in dict-like |
-|                                      | objects, etc.)               |
-+--------------------------------------+------------------------------+
-| :class:`pybind11::error_already_set` | Indicates that the Python    |
-|                                      | exception flag has already   |
-|                                      | been initialized             |
-+--------------------------------------+------------------------------+
-
-When a Python function invoked from C++ throws an exception, it is converted
-into a C++ exception of type :class:`error_already_set` whose string payload
-contains a textual summary.
-
-There is also a special exception :class:`cast_error` that is thrown by
-:func:`handle::call` when the input arguments cannot be converted to Python
-objects.
-
-Registering custom translators
-==============================
-
-If the default exception conversion policy described above is insufficient,
-pybind11 also provides support for registering custom exception translators.
-To register a simple exception conversion that translates a C++ exception into
-a new Python exception using the C++ exception's ``what()`` method, a helper
-function is available:
-
-.. code-block:: cpp
-
-    py::register_exception<CppExp>(module, "PyExp");
-
-This call creates a Python exception class with the name ``PyExp`` in the given
-module and automatically converts any encountered exceptions of type ``CppExp``
-into Python exceptions of type ``PyExp``.
-
-When more advanced exception translation is needed, the function
-``py::register_exception_translator(translator)`` can be used to register
-functions that can translate arbitrary exception types (and which may include
-additional logic to do so).  The function takes a stateless callable (e.g.  a
-function pointer or a lambda function without captured variables) with the call
-signature ``void(std::exception_ptr)``.
-
-When a C++ exception is thrown, the registered exception translators are tried
-in reverse order of registration (i.e. the last registered translator gets the
-first shot at handling the exception).
-
-Inside the translator, ``std::rethrow_exception`` should be used within
-a try block to re-throw the exception.  One or more catch clauses to catch
-the appropriate exceptions should then be used with each clause using
-``PyErr_SetString`` to set a Python exception or ``ex(string)`` to set
-the python exception to a custom exception type (see below).
-
-To declare a custom Python exception type, declare a ``py::exception`` variable
-and use this in the associated exception translator (note: it is often useful
-to make this a static declaration when using it inside a lambda expression
-without requiring capturing).
-
-
-The following example demonstrates this for a hypothetical exception classes
-``MyCustomException`` and ``OtherException``: the first is translated to a
-custom python exception ``MyCustomError``, while the second is translated to a
-standard python RuntimeError:
-
-.. code-block:: cpp
-
-    static py::exception<MyCustomException> exc(m, "MyCustomError");
-    py::register_exception_translator([](std::exception_ptr p) {
-        try {
-            if (p) std::rethrow_exception(p);
-        } catch (const MyCustomException &e) {
-            exc(e.what());
-        } catch (const OtherException &e) {
-            PyErr_SetString(PyExc_RuntimeError, e.what());
-        }
-    });
-
-Multiple exceptions can be handled by a single translator, as shown in the
-example above. If the exception is not caught by the current translator, the
-previously registered one gets a chance.
-
-If none of the registered exception translators is able to handle the
-exception, it is handled by the default converter as described in the previous
-section.
-
-.. seealso::
-
-    The file :file:`tests/test_exceptions.cpp` contains examples
-    of various custom exception translators and custom exception types.
-
-.. note::
-
-    You must call either ``PyErr_SetString`` or a custom exception's call
-    operator (``exc(string)``) for every exception caught in a custom exception
-    translator.  Failure to do so will cause Python to crash with ``SystemError:
-    error return without exception set``.
-
-    Exceptions that you do not plan to handle should simply not be caught, or
-    may be explicity (re-)thrown to delegate it to the other,
-    previously-declared existing exception translators.
diff --git a/tmap/lib/pybind11/docs/advanced/functions.rst b/tmap/lib/pybind11/docs/advanced/functions.rst
deleted file mode 100644
index 0e2b16c..0000000
--- a/tmap/lib/pybind11/docs/advanced/functions.rst
+++ /dev/null
@@ -1,486 +0,0 @@
-Functions
-#########
-
-Before proceeding with this section, make sure that you are already familiar
-with the basics of binding functions and classes, as explained in :doc:`/basics`
-and :doc:`/classes`. The following guide is applicable to both free and member
-functions, i.e. *methods* in Python.
-
-.. _return_value_policies:
-
-Return value policies
-=====================
-
-Python and C++ use fundamentally different ways of managing the memory and
-lifetime of objects managed by them. This can lead to issues when creating
-bindings for functions that return a non-trivial type. Just by looking at the
-type information, it is not clear whether Python should take charge of the
-returned value and eventually free its resources, or if this is handled on the
-C++ side. For this reason, pybind11 provides a several *return value policy*
-annotations that can be passed to the :func:`module::def` and
-:func:`class_::def` functions. The default policy is
-:enum:`return_value_policy::automatic`.
-
-Return value policies are tricky, and it's very important to get them right.
-Just to illustrate what can go wrong, consider the following simple example:
-
-.. code-block:: cpp
-
-    /* Function declaration */
-    Data *get_data() { return _data; /* (pointer to a static data structure) */ }
-    ...
-
-    /* Binding code */
-    m.def("get_data", &get_data); // <-- KABOOM, will cause crash when called from Python
-
-What's going on here? When ``get_data()`` is called from Python, the return
-value (a native C++ type) must be wrapped to turn it into a usable Python type.
-In this case, the default return value policy (:enum:`return_value_policy::automatic`)
-causes pybind11 to assume ownership of the static ``_data`` instance.
-
-When Python's garbage collector eventually deletes the Python
-wrapper, pybind11 will also attempt to delete the C++ instance (via ``operator
-delete()``) due to the implied ownership. At this point, the entire application
-will come crashing down, though errors could also be more subtle and involve
-silent data corruption.
-
-In the above example, the policy :enum:`return_value_policy::reference` should have
-been specified so that the global data instance is only *referenced* without any
-implied transfer of ownership, i.e.:
-
-.. code-block:: cpp
-
-    m.def("get_data", &get_data, return_value_policy::reference);
-
-On the other hand, this is not the right policy for many other situations,
-where ignoring ownership could lead to resource leaks.
-As a developer using pybind11, it's important to be familiar with the different
-return value policies, including which situation calls for which one of them.
-The following table provides an overview of available policies:
-
-.. tabularcolumns:: |p{0.5\textwidth}|p{0.45\textwidth}|
-
-+--------------------------------------------------+----------------------------------------------------------------------------+
-| Return value policy                              | Description                                                                |
-+==================================================+============================================================================+
-| :enum:`return_value_policy::take_ownership`      | Reference an existing object (i.e. do not create a new copy) and take      |
-|                                                  | ownership. Python will call the destructor and delete operator when the    |
-|                                                  | object's reference count reaches zero. Undefined behavior ensues when the  |
-|                                                  | C++ side does the same, or when the data was not dynamically allocated.    |
-+--------------------------------------------------+----------------------------------------------------------------------------+
-| :enum:`return_value_policy::copy`                | Create a new copy of the returned object, which will be owned by Python.   |
-|                                                  | This policy is comparably safe because the lifetimes of the two instances  |
-|                                                  | are decoupled.                                                             |
-+--------------------------------------------------+----------------------------------------------------------------------------+
-| :enum:`return_value_policy::move`                | Use ``std::move`` to move the return value contents into a new instance    |
-|                                                  | that will be owned by Python. This policy is comparably safe because the   |
-|                                                  | lifetimes of the two instances (move source and destination) are decoupled.|
-+--------------------------------------------------+----------------------------------------------------------------------------+
-| :enum:`return_value_policy::reference`           | Reference an existing object, but do not take ownership. The C++ side is   |
-|                                                  | responsible for managing the object's lifetime and deallocating it when    |
-|                                                  | it is no longer used. Warning: undefined behavior will ensue when the C++  |
-|                                                  | side deletes an object that is still referenced and used by Python.        |
-+--------------------------------------------------+----------------------------------------------------------------------------+
-| :enum:`return_value_policy::reference_internal`  | Indicates that the lifetime of the return value is tied to the lifetime    |
-|                                                  | of a parent object, namely the implicit ``this``, or ``self`` argument of  |
-|                                                  | the called method or property. Internally, this policy works just like     |
-|                                                  | :enum:`return_value_policy::reference` but additionally applies a          |
-|                                                  | ``keep_alive<0, 1>`` *call policy* (described in the next section) that    |
-|                                                  | prevents the parent object from being garbage collected as long as the     |
-|                                                  | return value is referenced by Python. This is the default policy for       |
-|                                                  | property getters created via ``def_property``, ``def_readwrite``, etc.     |
-+--------------------------------------------------+----------------------------------------------------------------------------+
-| :enum:`return_value_policy::automatic`           | **Default policy.** This policy falls back to the policy                   |
-|                                                  | :enum:`return_value_policy::take_ownership` when the return value is a     |
-|                                                  | pointer. Otherwise, it uses :enum:`return_value_policy::move` or           |
-|                                                  | :enum:`return_value_policy::copy` for rvalue and lvalue references,        |
-|                                                  | respectively. See above for a description of what all of these different   |
-|                                                  | policies do.                                                               |
-+--------------------------------------------------+----------------------------------------------------------------------------+
-| :enum:`return_value_policy::automatic_reference` | As above, but use policy :enum:`return_value_policy::reference` when the   |
-|                                                  | return value is a pointer. This is the default conversion policy for       |
-|                                                  | function arguments when calling Python functions manually from C++ code    |
-|                                                  | (i.e. via handle::operator()). You probably won't need to use this.        |
-+--------------------------------------------------+----------------------------------------------------------------------------+
-
-Return value policies can also be applied to properties:
-
-.. code-block:: cpp
-
-    class_<MyClass>(m, "MyClass")
-        .def_property("data", &MyClass::getData, &MyClass::setData,
-                      py::return_value_policy::copy);
-
-Technically, the code above applies the policy to both the getter and the
-setter function, however, the setter doesn't really care about *return*
-value policies which makes this a convenient terse syntax. Alternatively,
-targeted arguments can be passed through the :class:`cpp_function` constructor:
-
-.. code-block:: cpp
-
-    class_<MyClass>(m, "MyClass")
-        .def_property("data"
-            py::cpp_function(&MyClass::getData, py::return_value_policy::copy),
-            py::cpp_function(&MyClass::setData)
-        );
-
-.. warning::
-
-    Code with invalid return value policies might access unitialized memory or
-    free data structures multiple times, which can lead to hard-to-debug
-    non-determinism and segmentation faults, hence it is worth spending the
-    time to understand all the different options in the table above.
-
-.. note::
-
-    One important aspect of the above policies is that they only apply to
-    instances which pybind11 has *not* seen before, in which case the policy
-    clarifies essential questions about the return value's lifetime and
-    ownership.  When pybind11 knows the instance already (as identified by its
-    type and address in memory), it will return the existing Python object
-    wrapper rather than creating a new copy.
-
-.. note::
-
-    The next section on :ref:`call_policies` discusses *call policies* that can be
-    specified *in addition* to a return value policy from the list above. Call
-    policies indicate reference relationships that can involve both return values
-    and parameters of functions.
-
-.. note::
-
-   As an alternative to elaborate call policies and lifetime management logic,
-   consider using smart pointers (see the section on :ref:`smart_pointers` for
-   details). Smart pointers can tell whether an object is still referenced from
-   C++ or Python, which generally eliminates the kinds of inconsistencies that
-   can lead to crashes or undefined behavior. For functions returning smart
-   pointers, it is not necessary to specify a return value policy.
-
-.. _call_policies:
-
-Additional call policies
-========================
-
-In addition to the above return value policies, further *call policies* can be
-specified to indicate dependencies between parameters or ensure a certain state
-for the function call.
-
-Keep alive
-----------
-
-In general, this policy is required when the C++ object is any kind of container
-and another object is being added to the container. ``keep_alive<Nurse, Patient>``
-indicates that the argument with index ``Patient`` should be kept alive at least
-until the argument with index ``Nurse`` is freed by the garbage collector. Argument
-indices start at one, while zero refers to the return value. For methods, index
-``1`` refers to the implicit ``this`` pointer, while regular arguments begin at
-index ``2``. Arbitrarily many call policies can be specified. When a ``Nurse``
-with value ``None`` is detected at runtime, the call policy does nothing.
-
-This feature internally relies on the ability to create a *weak reference* to
-the nurse object, which is permitted by all classes exposed via pybind11. When
-the nurse object does not support weak references, an exception will be thrown.
-
-Consider the following example: here, the binding code for a list append
-operation ties the lifetime of the newly added element to the underlying
-container:
-
-.. code-block:: cpp
-
-    py::class_<List>(m, "List")
-        .def("append", &List::append, py::keep_alive<1, 2>());
-
-.. note::
-
-    ``keep_alive`` is analogous to the ``with_custodian_and_ward`` (if Nurse,
-    Patient != 0) and ``with_custodian_and_ward_postcall`` (if Nurse/Patient ==
-    0) policies from Boost.Python.
-
-Call guard
-----------
-
-The ``call_guard<T>`` policy allows any scope guard type ``T`` to be placed
-around the function call. For example, this definition:
-
-.. code-block:: cpp
-
-    m.def("foo", foo, py::call_guard<T>());
-
-is equivalent to the following pseudocode:
-
-.. code-block:: cpp
-
-    m.def("foo", [](args...) {
-        T scope_guard;
-        return foo(args...); // forwarded arguments
-    });
-
-The only requirement is that ``T`` is default-constructible, but otherwise any
-scope guard will work. This is very useful in combination with `gil_scoped_release`.
-See :ref:`gil`.
-
-Multiple guards can also be specified as ``py::call_guard<T1, T2, T3...>``. The
-constructor order is left to right and destruction happens in reverse.
-
-.. seealso::
-
-    The file :file:`tests/test_call_policies.cpp` contains a complete example
-    that demonstrates using `keep_alive` and `call_guard` in more detail.
-
-.. _python_objects_as_args:
-
-Python objects as arguments
-===========================
-
-pybind11 exposes all major Python types using thin C++ wrapper classes. These
-wrapper classes can also be used as parameters of functions in bindings, which
-makes it possible to directly work with native Python types on the C++ side.
-For instance, the following statement iterates over a Python ``dict``:
-
-.. code-block:: cpp
-
-    void print_dict(py::dict dict) {
-        /* Easily interact with Python types */
-        for (auto item : dict)
-            std::cout << "key=" << std::string(py::str(item.first)) << ", "
-                      << "value=" << std::string(py::str(item.second)) << std::endl;
-    }
-
-It can be exported:
-
-.. code-block:: cpp
-
-    m.def("print_dict", &print_dict);
-
-And used in Python as usual:
-
-.. code-block:: pycon
-
-    >>> print_dict({'foo': 123, 'bar': 'hello'})
-    key=foo, value=123
-    key=bar, value=hello
-
-For more information on using Python objects in C++, see :doc:`/advanced/pycpp/index`.
-
-Accepting \*args and \*\*kwargs
-===============================
-
-Python provides a useful mechanism to define functions that accept arbitrary
-numbers of arguments and keyword arguments:
-
-.. code-block:: python
-
-   def generic(*args, **kwargs):
-       ...  # do something with args and kwargs
-
-Such functions can also be created using pybind11:
-
-.. code-block:: cpp
-
-   void generic(py::args args, py::kwargs kwargs) {
-       /// .. do something with args
-       if (kwargs)
-           /// .. do something with kwargs
-   }
-
-   /// Binding code
-   m.def("generic", &generic);
-
-The class ``py::args`` derives from ``py::tuple`` and ``py::kwargs`` derives
-from ``py::dict``.
-
-You may also use just one or the other, and may combine these with other
-arguments as long as the ``py::args`` and ``py::kwargs`` arguments are the last
-arguments accepted by the function.
-
-Please refer to the other examples for details on how to iterate over these,
-and on how to cast their entries into C++ objects. A demonstration is also
-available in ``tests/test_kwargs_and_defaults.cpp``.
-
-.. note::
-
-    When combining \*args or \*\*kwargs with :ref:`keyword_args` you should
-    *not* include ``py::arg`` tags for the ``py::args`` and ``py::kwargs``
-    arguments.
-
-Default arguments revisited
-===========================
-
-The section on :ref:`default_args` previously discussed basic usage of default
-arguments using pybind11. One noteworthy aspect of their implementation is that
-default arguments are converted to Python objects right at declaration time.
-Consider the following example:
-
-.. code-block:: cpp
-
-    py::class_<MyClass>("MyClass")
-        .def("myFunction", py::arg("arg") = SomeType(123));
-
-In this case, pybind11 must already be set up to deal with values of the type
-``SomeType`` (via a prior instantiation of ``py::class_<SomeType>``), or an
-exception will be thrown.
-
-Another aspect worth highlighting is that the "preview" of the default argument
-in the function signature is generated using the object's ``__repr__`` method.
-If not available, the signature may not be very helpful, e.g.:
-
-.. code-block:: pycon
-
-    FUNCTIONS
-    ...
-    |  myFunction(...)
-    |      Signature : (MyClass, arg : SomeType = <SomeType object at 0x101b7b080>) -> NoneType
-    ...
-
-The first way of addressing this is by defining ``SomeType.__repr__``.
-Alternatively, it is possible to specify the human-readable preview of the
-default argument manually using the ``arg_v`` notation:
-
-.. code-block:: cpp
-
-    py::class_<MyClass>("MyClass")
-        .def("myFunction", py::arg_v("arg", SomeType(123), "SomeType(123)"));
-
-Sometimes it may be necessary to pass a null pointer value as a default
-argument. In this case, remember to cast it to the underlying type in question,
-like so:
-
-.. code-block:: cpp
-
-    py::class_<MyClass>("MyClass")
-        .def("myFunction", py::arg("arg") = (SomeType *) nullptr);
-
-.. _nonconverting_arguments:
-
-Non-converting arguments
-========================
-
-Certain argument types may support conversion from one type to another.  Some
-examples of conversions are:
-
-* :ref:`implicit_conversions` declared using ``py::implicitly_convertible<A,B>()``
-* Calling a method accepting a double with an integer argument
-* Calling a ``std::complex<float>`` argument with a non-complex python type
-  (for example, with a float).  (Requires the optional ``pybind11/complex.h``
-  header).
-* Calling a function taking an Eigen matrix reference with a numpy array of the
-  wrong type or of an incompatible data layout.  (Requires the optional
-  ``pybind11/eigen.h`` header).
-
-This behaviour is sometimes undesirable: the binding code may prefer to raise
-an error rather than convert the argument.  This behaviour can be obtained
-through ``py::arg`` by calling the ``.noconvert()`` method of the ``py::arg``
-object, such as:
-
-.. code-block:: cpp
-
-    m.def("floats_only", [](double f) { return 0.5 * f; }, py::arg("f").noconvert());
-    m.def("floats_preferred", [](double f) { return 0.5 * f; }, py::arg("f"));
-
-Attempting the call the second function (the one without ``.noconvert()``) with
-an integer will succeed, but attempting to call the ``.noconvert()`` version
-will fail with a ``TypeError``:
-
-.. code-block:: pycon
-
-    >>> floats_preferred(4)
-    2.0
-    >>> floats_only(4)
-    Traceback (most recent call last):
-      File "<stdin>", line 1, in <module>
-    TypeError: floats_only(): incompatible function arguments. The following argument types are supported:
-        1. (f: float) -> float
-
-    Invoked with: 4
-
-You may, of course, combine this with the :var:`_a` shorthand notation (see
-:ref:`keyword_args`) and/or :ref:`default_args`.  It is also permitted to omit
-the argument name by using the ``py::arg()`` constructor without an argument
-name, i.e. by specifying ``py::arg().noconvert()``.
-
-.. note::
-
-    When specifying ``py::arg`` options it is necessary to provide the same
-    number of options as the bound function has arguments.  Thus if you want to
-    enable no-convert behaviour for just one of several arguments, you will
-    need to specify a ``py::arg()`` annotation for each argument with the
-    no-convert argument modified to ``py::arg().noconvert()``.
-
-.. _none_arguments:
-
-Allow/Prohibiting None arguments
-================================
-
-When a C++ type registered with :class:`py::class_` is passed as an argument to
-a function taking the instance as pointer or shared holder (e.g. ``shared_ptr``
-or a custom, copyable holder as described in :ref:`smart_pointers`), pybind
-allows ``None`` to be passed from Python which results in calling the C++
-function with ``nullptr`` (or an empty holder) for the argument.
-
-To explicitly enable or disable this behaviour, using the
-``.none`` method of the :class:`py::arg` object:
-
-.. code-block:: cpp
-
-    py::class_<Dog>(m, "Dog").def(py::init<>());
-    py::class_<Cat>(m, "Cat").def(py::init<>());
-    m.def("bark", [](Dog *dog) -> std::string {
-        if (dog) return "woof!"; /* Called with a Dog instance */
-        else return "(no dog)"; /* Called with None, d == nullptr */
-    }, py::arg("dog").none(true));
-    m.def("meow", [](Cat *cat) -> std::string {
-        // Can't be called with None argument
-        return "meow";
-    }, py::arg("cat").none(false));
-
-With the above, the Python call ``bark(None)`` will return the string ``"(no
-dog)"``, while attempting to call ``meow(None)`` will raise a ``TypeError``:
-
-.. code-block:: pycon
-
-    >>> from animals import Dog, Cat, bark, meow
-    >>> bark(Dog())
-    'woof!'
-    >>> meow(Cat())
-    'meow'
-    >>> bark(None)
-    '(no dog)'
-    >>> meow(None)
-    Traceback (most recent call last):
-      File "<stdin>", line 1, in <module>
-    TypeError: meow(): incompatible function arguments. The following argument types are supported:
-        1. (cat: animals.Cat) -> str
-
-    Invoked with: None
-
-The default behaviour when the tag is unspecified is to allow ``None``.
-
-Overload resolution order
-=========================
-
-When a function or method with multiple overloads is called from Python,
-pybind11 determines which overload to call in two passes.  The first pass
-attempts to call each overload without allowing argument conversion (as if
-every argument had been specified as ``py::arg().noconvert()`` as decribed
-above).
-
-If no overload succeeds in the no-conversion first pass, a second pass is
-attempted in which argument conversion is allowed (except where prohibited via
-an explicit ``py::arg().noconvert()`` attribute in the function definition).
-
-If the second pass also fails a ``TypeError`` is raised.
-
-Within each pass, overloads are tried in the order they were registered with
-pybind11.
-
-What this means in practice is that pybind11 will prefer any overload that does
-not require conversion of arguments to an overload that does, but otherwise prefers
-earlier-defined overloads to later-defined ones.
-
-.. note::
-
-    pybind11 does *not* further prioritize based on the number/pattern of
-    overloaded arguments.  That is, pybind11 does not prioritize a function
-    requiring one conversion over one requiring three, but only prioritizes
-    overloads requiring no conversion at all to overloads that require
-    conversion of at least one argument.
diff --git a/tmap/lib/pybind11/docs/advanced/misc.rst b/tmap/lib/pybind11/docs/advanced/misc.rst
deleted file mode 100644
index 87481ba..0000000
--- a/tmap/lib/pybind11/docs/advanced/misc.rst
+++ /dev/null
@@ -1,272 +0,0 @@
-Miscellaneous
-#############
-
-.. _macro_notes:
-
-General notes regarding convenience macros
-==========================================
-
-pybind11 provides a few convenience macros such as
-:func:`PYBIND11_MAKE_OPAQUE` and :func:`PYBIND11_DECLARE_HOLDER_TYPE`, and
-``PYBIND11_OVERLOAD_*``. Since these are "just" macros that are evaluated
-in the preprocessor (which has no concept of types), they *will* get confused
-by commas in a template argument such as ``PYBIND11_OVERLOAD(MyReturnValue<T1,
-T2>, myFunc)``. In this case, the preprocessor assumes that the comma indicates
-the beginning of the next parameter. Use a ``typedef`` to bind the template to
-another name and use it in the macro to avoid this problem.
-
-.. _gil:
-
-Global Interpreter Lock (GIL)
-=============================
-
-When calling a C++ function from Python, the GIL is always held.
-The classes :class:`gil_scoped_release` and :class:`gil_scoped_acquire` can be
-used to acquire and release the global interpreter lock in the body of a C++
-function call. In this way, long-running C++ code can be parallelized using
-multiple Python threads. Taking :ref:`overriding_virtuals` as an example, this
-could be realized as follows (important changes highlighted):
-
-.. code-block:: cpp
-    :emphasize-lines: 8,9,31,32
-
-    class PyAnimal : public Animal {
-    public:
-        /* Inherit the constructors */
-        using Animal::Animal;
-
-        /* Trampoline (need one for each virtual function) */
-        std::string go(int n_times) {
-            /* Acquire GIL before calling Python code */
-            py::gil_scoped_acquire acquire;
-
-            PYBIND11_OVERLOAD_PURE(
-                std::string, /* Return type */
-                Animal,      /* Parent class */
-                go,          /* Name of function */
-                n_times      /* Argument(s) */
-            );
-        }
-    };
-
-    PYBIND11_MODULE(example, m) {
-        py::class_<Animal, PyAnimal> animal(m, "Animal");
-        animal
-            .def(py::init<>())
-            .def("go", &Animal::go);
-
-        py::class_<Dog>(m, "Dog", animal)
-            .def(py::init<>());
-
-        m.def("call_go", [](Animal *animal) -> std::string {
-            /* Release GIL before calling into (potentially long-running) C++ code */
-            py::gil_scoped_release release;
-            return call_go(animal);
-        });
-    }
-
-The ``call_go`` wrapper can also be simplified using the `call_guard` policy
-(see :ref:`call_policies`) which yields the same result:
-
-.. code-block:: cpp
-
-    m.def("call_go", &call_go, py::call_guard<py::gil_scoped_release>());
-
-
-Binding sequence data types, iterators, the slicing protocol, etc.
-==================================================================
-
-Please refer to the supplemental example for details.
-
-.. seealso::
-
-    The file :file:`tests/test_sequences_and_iterators.cpp` contains a
-    complete example that shows how to bind a sequence data type, including
-    length queries (``__len__``), iterators (``__iter__``), the slicing
-    protocol and other kinds of useful operations.
-
-
-Partitioning code over multiple extension modules
-=================================================
-
-It's straightforward to split binding code over multiple extension modules,
-while referencing types that are declared elsewhere. Everything "just" works
-without any special precautions. One exception to this rule occurs when
-extending a type declared in another extension module. Recall the basic example
-from Section :ref:`inheritance`.
-
-.. code-block:: cpp
-
-    py::class_<Pet> pet(m, "Pet");
-    pet.def(py::init<const std::string &>())
-       .def_readwrite("name", &Pet::name);
-
-    py::class_<Dog>(m, "Dog", pet /* <- specify parent */)
-        .def(py::init<const std::string &>())
-        .def("bark", &Dog::bark);
-
-Suppose now that ``Pet`` bindings are defined in a module named ``basic``,
-whereas the ``Dog`` bindings are defined somewhere else. The challenge is of
-course that the variable ``pet`` is not available anymore though it is needed
-to indicate the inheritance relationship to the constructor of ``class_<Dog>``.
-However, it can be acquired as follows:
-
-.. code-block:: cpp
-
-    py::object pet = (py::object) py::module::import("basic").attr("Pet");
-
-    py::class_<Dog>(m, "Dog", pet)
-        .def(py::init<const std::string &>())
-        .def("bark", &Dog::bark);
-
-Alternatively, you can specify the base class as a template parameter option to
-``class_``, which performs an automated lookup of the corresponding Python
-type. Like the above code, however, this also requires invoking the ``import``
-function once to ensure that the pybind11 binding code of the module ``basic``
-has been executed:
-
-.. code-block:: cpp
-
-    py::module::import("basic");
-
-    py::class_<Dog, Pet>(m, "Dog")
-        .def(py::init<const std::string &>())
-        .def("bark", &Dog::bark);
-
-Naturally, both methods will fail when there are cyclic dependencies.
-
-Note that pybind11 code compiled with hidden-by-default symbol visibility (e.g.
-via the command line flag ``-fvisibility=hidden`` on GCC/Clang), which is
-required proper pybind11 functionality, can interfere with the ability to
-access types defined in another extension module.  Working around this requires
-manually exporting types that are accessed by multiple extension modules;
-pybind11 provides a macro to do just this:
-
-.. code-block:: cpp
-
-    class PYBIND11_EXPORT Dog : public Animal {
-        ...
-    };
-
-Note also that it is possible (although would rarely be required) to share arbitrary
-C++ objects between extension modules at runtime. Internal library data is shared
-between modules using capsule machinery [#f6]_ which can be also utilized for
-storing, modifying and accessing user-defined data. Note that an extension module
-will "see" other extensions' data if and only if they were built with the same
-pybind11 version. Consider the following example:
-
-.. code-block:: cpp
-
-    auto data = (MyData *) py::get_shared_data("mydata");
-    if (!data)
-        data = (MyData *) py::set_shared_data("mydata", new MyData(42));
-
-If the above snippet was used in several separately compiled extension modules,
-the first one to be imported would create a ``MyData`` instance and associate
-a ``"mydata"`` key with a pointer to it. Extensions that are imported later
-would be then able to access the data behind the same pointer.
-
-.. [#f6] https://docs.python.org/3/extending/extending.html#using-capsules
-
-Module Destructors
-==================
-
-pybind11 does not provide an explicit mechanism to invoke cleanup code at
-module destruction time. In rare cases where such functionality is required, it
-is possible to emulate it using Python capsules or weak references with a
-destruction callback.
-
-.. code-block:: cpp
-
-    auto cleanup_callback = []() {
-        // perform cleanup here -- this function is called with the GIL held
-    };
-
-    m.add_object("_cleanup", py::capsule(cleanup_callback));
-
-This approach has the potential downside that instances of classes exposed
-within the module may still be alive when the cleanup callback is invoked
-(whether this is acceptable will generally depend on the application).
-
-Alternatively, the capsule may also be stashed within a type object, which
-ensures that it not called before all instances of that type have been
-collected:
-
-.. code-block:: cpp
-
-    auto cleanup_callback = []() { /* ... */ };
-    m.attr("BaseClass").attr("_cleanup") = py::capsule(cleanup_callback);
-
-Both approaches also expose a potentially dangerous ``_cleanup`` attribute in
-Python, which may be undesirable from an API standpoint (a premature explicit
-call from Python might lead to undefined behavior). Yet another approach that 
-avoids this issue involves weak reference with a cleanup callback:
-
-.. code-block:: cpp
-
-    // Register a callback function that is invoked when the BaseClass object is colelcted
-    py::cpp_function cleanup_callback(
-        [](py::handle weakref) {
-            // perform cleanup here -- this function is called with the GIL held
-
-            weakref.dec_ref(); // release weak reference
-        }
-    );
-
-    // Create a weak reference with a cleanup callback and initially leak it
-    (void) py::weakref(m.attr("BaseClass"), cleanup_callback).release();
-
-
-Generating documentation using Sphinx
-=====================================
-
-Sphinx [#f4]_ has the ability to inspect the signatures and documentation
-strings in pybind11-based extension modules to automatically generate beautiful
-documentation in a variety formats. The python_example repository [#f5]_ contains a
-simple example repository which uses this approach.
-
-There are two potential gotchas when using this approach: first, make sure that
-the resulting strings do not contain any :kbd:`TAB` characters, which break the
-docstring parsing routines. You may want to use C++11 raw string literals,
-which are convenient for multi-line comments. Conveniently, any excess
-indentation will be automatically be removed by Sphinx. However, for this to
-work, it is important that all lines are indented consistently, i.e.:
-
-.. code-block:: cpp
-
-    // ok
-    m.def("foo", &foo, R"mydelimiter(
-        The foo function
-
-        Parameters
-        ----------
-    )mydelimiter");
-
-    // *not ok*
-    m.def("foo", &foo, R"mydelimiter(The foo function
-
-        Parameters
-        ----------
-    )mydelimiter");
-
-By default, pybind11 automatically generates and prepends a signature to the docstring of a function 
-registered with ``module::def()`` and ``class_::def()``. Sometimes this
-behavior is not desirable, because you want to provide your own signature or remove 
-the docstring completely to exclude the function from the Sphinx documentation.
-The class ``options`` allows you to selectively suppress auto-generated signatures:
-
-.. code-block:: cpp
-
-    PYBIND11_MODULE(example, m) {
-        py::options options;
-        options.disable_function_signatures();
-
-        m.def("add", [](int a, int b) { return a + b; }, "A function which adds two numbers");
-    }
-
-Note that changes to the settings affect only function bindings created during the 
-lifetime of the ``options`` instance. When it goes out of scope at the end of the module's init function, 
-the default settings are restored to prevent unwanted side effects.
-
-.. [#f4] http://www.sphinx-doc.org
-.. [#f5] http://github.com/pybind/python_example
diff --git a/tmap/lib/pybind11/docs/advanced/pycpp/index.rst b/tmap/lib/pybind11/docs/advanced/pycpp/index.rst
deleted file mode 100644
index 6885bdc..0000000
--- a/tmap/lib/pybind11/docs/advanced/pycpp/index.rst
+++ /dev/null
@@ -1,13 +0,0 @@
-Python C++ interface
-####################
-
-pybind11 exposes Python types and functions using thin C++ wrappers, which
-makes it possible to conveniently call Python code from C++ without resorting
-to Python's C API.
-
-.. toctree::
-   :maxdepth: 2
-
-   object
-   numpy
-   utilities
diff --git a/tmap/lib/pybind11/docs/advanced/pycpp/numpy.rst b/tmap/lib/pybind11/docs/advanced/pycpp/numpy.rst
deleted file mode 100644
index 98b0c25..0000000
--- a/tmap/lib/pybind11/docs/advanced/pycpp/numpy.rst
+++ /dev/null
@@ -1,366 +0,0 @@
-.. _numpy:
-
-NumPy
-#####
-
-Buffer protocol
-===============
-
-Python supports an extremely general and convenient approach for exchanging
-data between plugin libraries. Types can expose a buffer view [#f2]_, which
-provides fast direct access to the raw internal data representation. Suppose we
-want to bind the following simplistic Matrix class:
-
-.. code-block:: cpp
-
-    class Matrix {
-    public:
-        Matrix(size_t rows, size_t cols) : m_rows(rows), m_cols(cols) {
-            m_data = new float[rows*cols];
-        }
-        float *data() { return m_data; }
-        size_t rows() const { return m_rows; }
-        size_t cols() const { return m_cols; }
-    private:
-        size_t m_rows, m_cols;
-        float *m_data;
-    };
-
-The following binding code exposes the ``Matrix`` contents as a buffer object,
-making it possible to cast Matrices into NumPy arrays. It is even possible to
-completely avoid copy operations with Python expressions like
-``np.array(matrix_instance, copy = False)``.
-
-.. code-block:: cpp
-
-    py::class_<Matrix>(m, "Matrix", py::buffer_protocol())
-       .def_buffer([](Matrix &m) -> py::buffer_info {
-            return py::buffer_info(
-                m.data(),                               /* Pointer to buffer */
-                sizeof(float),                          /* Size of one scalar */
-                py::format_descriptor<float>::format(), /* Python struct-style format descriptor */
-                2,                                      /* Number of dimensions */
-                { m.rows(), m.cols() },                 /* Buffer dimensions */
-                { sizeof(float) * m.rows(),             /* Strides (in bytes) for each index */
-                  sizeof(float) }
-            );
-        });
-
-Supporting the buffer protocol in a new type involves specifying the special
-``py::buffer_protocol()`` tag in the ``py::class_`` constructor and calling the
-``def_buffer()`` method with a lambda function that creates a
-``py::buffer_info`` description record on demand describing a given matrix
-instance. The contents of ``py::buffer_info`` mirror the Python buffer protocol
-specification.
-
-.. code-block:: cpp
-
-    struct buffer_info {
-        void *ptr;
-        ssize_t itemsize;
-        std::string format;
-        ssize_t ndim;
-        std::vector<ssize_t> shape;
-        std::vector<ssize_t> strides;
-    };
-
-To create a C++ function that can take a Python buffer object as an argument,
-simply use the type ``py::buffer`` as one of its arguments. Buffers can exist
-in a great variety of configurations, hence some safety checks are usually
-necessary in the function body. Below, you can see an basic example on how to
-define a custom constructor for the Eigen double precision matrix
-(``Eigen::MatrixXd``) type, which supports initialization from compatible
-buffer objects (e.g. a NumPy matrix).
-
-.. code-block:: cpp
-
-    /* Bind MatrixXd (or some other Eigen type) to Python */
-    typedef Eigen::MatrixXd Matrix;
-
-    typedef Matrix::Scalar Scalar;
-    constexpr bool rowMajor = Matrix::Flags & Eigen::RowMajorBit;
-
-    py::class_<Matrix>(m, "Matrix", py::buffer_protocol())
-        .def("__init__", [](Matrix &m, py::buffer b) {
-            typedef Eigen::Stride<Eigen::Dynamic, Eigen::Dynamic> Strides;
-
-            /* Request a buffer descriptor from Python */
-            py::buffer_info info = b.request();
-
-            /* Some sanity checks ... */
-            if (info.format != py::format_descriptor<Scalar>::format())
-                throw std::runtime_error("Incompatible format: expected a double array!");
-
-            if (info.ndim != 2)
-                throw std::runtime_error("Incompatible buffer dimension!");
-
-            auto strides = Strides(
-                info.strides[rowMajor ? 0 : 1] / (py::ssize_t)sizeof(Scalar),
-                info.strides[rowMajor ? 1 : 0] / (py::ssize_t)sizeof(Scalar));
-
-            auto map = Eigen::Map<Matrix, 0, Strides>(
-                static_cast<Scalar *>(info.ptr), info.shape[0], info.shape[1], strides);
-
-            new (&m) Matrix(map);
-        });
-
-For reference, the ``def_buffer()`` call for this Eigen data type should look
-as follows:
-
-.. code-block:: cpp
-
-    .def_buffer([](Matrix &m) -> py::buffer_info {
-        return py::buffer_info(
-            m.data(),                                /* Pointer to buffer */
-            sizeof(Scalar),                          /* Size of one scalar */
-            py::format_descriptor<Scalar>::format(), /* Python struct-style format descriptor */
-            2,                                       /* Number of dimensions */
-            { m.rows(), m.cols() },                  /* Buffer dimensions */
-            { sizeof(Scalar) * (rowMajor ? m.cols() : 1),
-              sizeof(Scalar) * (rowMajor ? 1 : m.rows()) }
-                                                     /* Strides (in bytes) for each index */
-        );
-     })
-
-For a much easier approach of binding Eigen types (although with some
-limitations), refer to the section on :doc:`/advanced/cast/eigen`.
-
-.. seealso::
-
-    The file :file:`tests/test_buffers.cpp` contains a complete example
-    that demonstrates using the buffer protocol with pybind11 in more detail.
-
-.. [#f2] http://docs.python.org/3/c-api/buffer.html
-
-Arrays
-======
-
-By exchanging ``py::buffer`` with ``py::array`` in the above snippet, we can
-restrict the function so that it only accepts NumPy arrays (rather than any
-type of Python object satisfying the buffer protocol).
-
-In many situations, we want to define a function which only accepts a NumPy
-array of a certain data type. This is possible via the ``py::array_t<T>``
-template. For instance, the following function requires the argument to be a
-NumPy array containing double precision values.
-
-.. code-block:: cpp
-
-    void f(py::array_t<double> array);
-
-When it is invoked with a different type (e.g. an integer or a list of
-integers), the binding code will attempt to cast the input into a NumPy array
-of the requested type. Note that this feature requires the
-:file:`pybind11/numpy.h` header to be included.
-
-Data in NumPy arrays is not guaranteed to packed in a dense manner;
-furthermore, entries can be separated by arbitrary column and row strides.
-Sometimes, it can be useful to require a function to only accept dense arrays
-using either the C (row-major) or Fortran (column-major) ordering. This can be
-accomplished via a second template argument with values ``py::array::c_style``
-or ``py::array::f_style``.
-
-.. code-block:: cpp
-
-    void f(py::array_t<double, py::array::c_style | py::array::forcecast> array);
-
-The ``py::array::forcecast`` argument is the default value of the second
-template parameter, and it ensures that non-conforming arguments are converted
-into an array satisfying the specified requirements instead of trying the next
-function overload.
-
-Structured types
-================
-
-In order for ``py::array_t`` to work with structured (record) types, we first
-need to register the memory layout of the type. This can be done via
-``PYBIND11_NUMPY_DTYPE`` macro, called in the plugin definition code, which
-expects the type followed by field names:
-
-.. code-block:: cpp
-
-    struct A {
-        int x;
-        double y;
-    };
-
-    struct B {
-        int z;
-        A a;
-    };
-
-    // ...
-    PYBIND11_MODULE(test, m) {
-        // ...
-
-        PYBIND11_NUMPY_DTYPE(A, x, y);
-        PYBIND11_NUMPY_DTYPE(B, z, a);
-        /* now both A and B can be used as template arguments to py::array_t */
-    }
-
-The structure should consist of fundamental arithmetic types, ``std::complex``,
-previously registered substructures, and arrays of any of the above. Both C++
-arrays and ``std::array`` are supported. While there is a static assertion to
-prevent many types of unsupported structures, it is still the user's
-responsibility to use only "plain" structures that can be safely manipulated as
-raw memory without violating invariants.
-
-Vectorizing functions
-=====================
-
-Suppose we want to bind a function with the following signature to Python so
-that it can process arbitrary NumPy array arguments (vectors, matrices, general
-N-D arrays) in addition to its normal arguments:
-
-.. code-block:: cpp
-
-    double my_func(int x, float y, double z);
-
-After including the ``pybind11/numpy.h`` header, this is extremely simple:
-
-.. code-block:: cpp
-
-    m.def("vectorized_func", py::vectorize(my_func));
-
-Invoking the function like below causes 4 calls to be made to ``my_func`` with
-each of the array elements. The significant advantage of this compared to
-solutions like ``numpy.vectorize()`` is that the loop over the elements runs
-entirely on the C++ side and can be crunched down into a tight, optimized loop
-by the compiler. The result is returned as a NumPy array of type
-``numpy.dtype.float64``.
-
-.. code-block:: pycon
-
-    >>> x = np.array([[1, 3],[5, 7]])
-    >>> y = np.array([[2, 4],[6, 8]])
-    >>> z = 3
-    >>> result = vectorized_func(x, y, z)
-
-The scalar argument ``z`` is transparently replicated 4 times.  The input
-arrays ``x`` and ``y`` are automatically converted into the right types (they
-are of type  ``numpy.dtype.int64`` but need to be ``numpy.dtype.int32`` and
-``numpy.dtype.float32``, respectively).
-
-.. note::
-
-    Only arithmetic, complex, and POD types passed by value or by ``const &``
-    reference are vectorized; all other arguments are passed through as-is.
-    Functions taking rvalue reference arguments cannot be vectorized.
-
-In cases where the computation is too complicated to be reduced to
-``vectorize``, it will be necessary to create and access the buffer contents
-manually. The following snippet contains a complete example that shows how this
-works (the code is somewhat contrived, since it could have been done more
-simply using ``vectorize``).
-
-.. code-block:: cpp
-
-    #include <pybind11/pybind11.h>
-    #include <pybind11/numpy.h>
-
-    namespace py = pybind11;
-
-    py::array_t<double> add_arrays(py::array_t<double> input1, py::array_t<double> input2) {
-        auto buf1 = input1.request(), buf2 = input2.request();
-
-        if (buf1.ndim != 1 || buf2.ndim != 1)
-            throw std::runtime_error("Number of dimensions must be one");
-
-        if (buf1.size != buf2.size)
-            throw std::runtime_error("Input shapes must match");
-
-        /* No pointer is passed, so NumPy will allocate the buffer */
-        auto result = py::array_t<double>(buf1.size);
-
-        auto buf3 = result.request();
-
-        double *ptr1 = (double *) buf1.ptr,
-               *ptr2 = (double *) buf2.ptr,
-               *ptr3 = (double *) buf3.ptr;
-
-        for (size_t idx = 0; idx < buf1.shape[0]; idx++)
-            ptr3[idx] = ptr1[idx] + ptr2[idx];
-
-        return result;
-    }
-
-    PYBIND11_MODULE(test, m) {
-        m.def("add_arrays", &add_arrays, "Add two NumPy arrays");
-    }
-
-.. seealso::
-
-    The file :file:`tests/test_numpy_vectorize.cpp` contains a complete
-    example that demonstrates using :func:`vectorize` in more detail.
-
-Direct access
-=============
-
-For performance reasons, particularly when dealing with very large arrays, it
-is often desirable to directly access array elements without internal checking
-of dimensions and bounds on every access when indices are known to be already
-valid.  To avoid such checks, the ``array`` class and ``array_t<T>`` template
-class offer an unchecked proxy object that can be used for this unchecked
-access through the ``unchecked<N>`` and ``mutable_unchecked<N>`` methods,
-where ``N`` gives the required dimensionality of the array:
-
-.. code-block:: cpp
-
-    m.def("sum_3d", [](py::array_t<double> x) {
-        auto r = x.unchecked<3>(); // x must have ndim = 3; can be non-writeable
-        double sum = 0;
-        for (ssize_t i = 0; i < r.shape(0); i++)
-            for (ssize_t j = 0; j < r.shape(1); j++)
-                for (ssize_t k = 0; k < r.shape(2); k++)
-                    sum += r(i, j, k);
-        return sum;
-    });
-    m.def("increment_3d", [](py::array_t<double> x) {
-        auto r = x.mutable_unchecked<3>(); // Will throw if ndim != 3 or flags.writeable is false
-        for (ssize_t i = 0; i < r.shape(0); i++)
-            for (ssize_t j = 0; j < r.shape(1); j++)
-                for (ssize_t k = 0; k < r.shape(2); k++)
-                    r(i, j, k) += 1.0;
-    }, py::arg().noconvert());
-
-To obtain the proxy from an ``array`` object, you must specify both the data
-type and number of dimensions as template arguments, such as ``auto r =
-myarray.mutable_unchecked<float, 2>()``.
-
-If the number of dimensions is not known at compile time, you can omit the
-dimensions template parameter (i.e. calling ``arr_t.unchecked()`` or
-``arr.unchecked<T>()``.  This will give you a proxy object that works in the
-same way, but results in less optimizable code and thus a small efficiency
-loss in tight loops.
-
-Note that the returned proxy object directly references the array's data, and
-only reads its shape, strides, and writeable flag when constructed.  You must
-take care to ensure that the referenced array is not destroyed or reshaped for
-the duration of the returned object, typically by limiting the scope of the
-returned instance.
-
-The returned proxy object supports some of the same methods as ``py::array`` so
-that it can be used as a drop-in replacement for some existing, index-checked
-uses of ``py::array``:
-
-- ``r.ndim()`` returns the number of dimensions
-
-- ``r.data(1, 2, ...)`` and ``r.mutable_data(1, 2, ...)``` returns a pointer to
-  the ``const T`` or ``T`` data, respectively, at the given indices.  The
-  latter is only available to proxies obtained via ``a.mutable_unchecked()``.
-
-- ``itemsize()`` returns the size of an item in bytes, i.e. ``sizeof(T)``.
-
-- ``ndim()`` returns the number of dimensions.
-
-- ``shape(n)`` returns the size of dimension ``n``
-
-- ``size()`` returns the total number of elements (i.e. the product of the shapes).
-
-- ``nbytes()`` returns the number of bytes used by the referenced elements
-  (i.e. ``itemsize()`` times ``size()``).
-
-.. seealso::
-
-    The file :file:`tests/test_numpy_array.cpp` contains additional examples
-    demonstrating the use of this feature.
diff --git a/tmap/lib/pybind11/docs/advanced/pycpp/object.rst b/tmap/lib/pybind11/docs/advanced/pycpp/object.rst
deleted file mode 100644
index c9728e9..0000000
--- a/tmap/lib/pybind11/docs/advanced/pycpp/object.rst
+++ /dev/null
@@ -1,98 +0,0 @@
-Python types
-############
-
-Available wrappers
-==================
-
-All major Python types are available as thin C++ wrapper classes. These
-can also be used as function parameters -- see :ref:`python_objects_as_args`.
-
-Available types include :class:`handle`, :class:`object`, :class:`bool_`,
-:class:`int_`, :class:`float_`, :class:`str`, :class:`bytes`, :class:`tuple`,
-:class:`list`, :class:`dict`, :class:`slice`, :class:`none`, :class:`capsule`,
-:class:`iterable`, :class:`iterator`, :class:`function`, :class:`buffer`,
-:class:`array`, and :class:`array_t`.
-
-Casting back and forth
-======================
-
-In this kind of mixed code, it is often necessary to convert arbitrary C++
-types to Python, which can be done using :func:`py::cast`:
-
-.. code-block:: cpp
-
-    MyClass *cls = ..;
-    py::object obj = py::cast(cls);
-
-The reverse direction uses the following syntax:
-
-.. code-block:: cpp
-
-    py::object obj = ...;
-    MyClass *cls = obj.cast<MyClass *>();
-
-When conversion fails, both directions throw the exception :class:`cast_error`.
-
-.. _calling_python_functions:
-
-Calling Python functions
-========================
-
-It is also possible to call python functions via ``operator()``.
-
-.. code-block:: cpp
-
-    py::function f = <...>;
-    py::object result_py = f(1234, "hello", some_instance);
-    MyClass &result = result_py.cast<MyClass>();
-
-Keyword arguments are also supported. In Python, there is the usual call syntax:
-
-.. code-block:: python
-
-    def f(number, say, to):
-        ...  # function code
-
-    f(1234, say="hello", to=some_instance)  # keyword call in Python
-
-In C++, the same call can be made using:
-
-.. code-block:: cpp
-
-    using namespace pybind11::literals; // to bring in the `_a` literal
-    f(1234, "say"_a="hello", "to"_a=some_instance); // keyword call in C++
-
-Unpacking of ``*args`` and ``**kwargs`` is also possible and can be mixed with
-other arguments:
-
-.. code-block:: cpp
-
-    // * unpacking
-    py::tuple args = py::make_tuple(1234, "hello", some_instance);
-    f(*args);
-
-    // ** unpacking
-    py::dict kwargs = py::dict("number"_a=1234, "say"_a="hello", "to"_a=some_instance);
-    f(**kwargs);
-
-    // mixed keywords, * and ** unpacking
-    py::tuple args = py::make_tuple(1234);
-    py::dict kwargs = py::dict("to"_a=some_instance);
-    f(*args, "say"_a="hello", **kwargs);
-
-Generalized unpacking according to PEP448_ is also supported:
-
-.. code-block:: cpp
-
-    py::dict kwargs1 = py::dict("number"_a=1234);
-    py::dict kwargs2 = py::dict("to"_a=some_instance);
-    f(**kwargs1, "say"_a="hello", **kwargs2);
-
-.. seealso::
-
-    The file :file:`tests/test_pytypes.cpp` contains a complete
-    example that demonstrates passing native Python types in more detail. The
-    file :file:`tests/test_callbacks.cpp` presents a few examples of calling
-    Python functions from C++, including keywords arguments and unpacking.
-
-.. _PEP448: https://www.python.org/dev/peps/pep-0448/
diff --git a/tmap/lib/pybind11/docs/advanced/pycpp/utilities.rst b/tmap/lib/pybind11/docs/advanced/pycpp/utilities.rst
deleted file mode 100644
index 369e7c9..0000000
--- a/tmap/lib/pybind11/docs/advanced/pycpp/utilities.rst
+++ /dev/null
@@ -1,144 +0,0 @@
-Utilities
-#########
-
-Using Python's print function in C++
-====================================
-
-The usual way to write output in C++ is using ``std::cout`` while in Python one
-would use ``print``. Since these methods use different buffers, mixing them can
-lead to output order issues. To resolve this, pybind11 modules can use the
-:func:`py::print` function which writes to Python's ``sys.stdout`` for consistency.
-
-Python's ``print`` function is replicated in the C++ API including optional
-keyword arguments ``sep``, ``end``, ``file``, ``flush``. Everything works as
-expected in Python:
-
-.. code-block:: cpp
-
-    py::print(1, 2.0, "three"); // 1 2.0 three
-    py::print(1, 2.0, "three", "sep"_a="-"); // 1-2.0-three
-
-    auto args = py::make_tuple("unpacked", true);
-    py::print("->", *args, "end"_a="<-"); // -> unpacked True <-
-
-.. _ostream_redirect:
-
-Capturing standard output from ostream
-======================================
-
-Often, a library will use the streams ``std::cout`` and ``std::cerr`` to print,
-but this does not play well with Python's standard ``sys.stdout`` and ``sys.stderr``
-redirection. Replacing a library's printing with `py::print <print>` may not
-be feasible. This can be fixed using a guard around the library function that
-redirects output to the corresponding Python streams:
-
-.. code-block:: cpp
-
-    #include <pybind11/iostream.h>
-
-    ...
-
-    // Add a scoped redirect for your noisy code
-    m.def("noisy_func", []() {
-        py::scoped_ostream_redirect stream(
-            std::cout,                               // std::ostream&
-            py::module::import("sys").attr("stdout") // Python output
-        );
-        call_noisy_func();
-    });
-
-This method respects flushes on the output streams and will flush if needed
-when the scoped guard is destroyed. This allows the output to be redirected in
-real time, such as to a Jupyter notebook. The two arguments, the C++ stream and
-the Python output, are optional, and default to standard output if not given. An
-extra type, `py::scoped_estream_redirect <scoped_estream_redirect>`, is identical
-except for defaulting to ``std::cerr`` and ``sys.stderr``; this can be useful with
-`py::call_guard`, which allows multiple items, but uses the default constructor:
-
-.. code-block:: py
-
-    // Alternative: Call single function using call guard
-    m.def("noisy_func", &call_noisy_function,
-          py::call_guard<py::scoped_ostream_redirect,
-                         py::scoped_estream_redirect>());
-
-The redirection can also be done in Python with the addition of a context
-manager, using the `py::add_ostream_redirect() <add_ostream_redirect>` function:
-
-.. code-block:: cpp
-
-    py::add_ostream_redirect(m, "ostream_redirect");
-
-The name in Python defaults to ``ostream_redirect`` if no name is passed.  This
-creates the following context manager in Python:
-
-.. code-block:: python
-
-    with ostream_redirect(stdout=True, stderr=True):
-        noisy_function()
-
-It defaults to redirecting both streams, though you can use the keyword
-arguments to disable one of the streams if needed.
-
-.. note::
-
-    The above methods will not redirect C-level output to file descriptors, such
-    as ``fprintf``. For those cases, you'll need to redirect the file
-    descriptors either directly in C or with Python's ``os.dup2`` function
-    in an operating-system dependent way.
-
-.. _eval:
-
-Evaluating Python expressions from strings and files
-====================================================
-
-pybind11 provides the `eval`, `exec` and `eval_file` functions to evaluate
-Python expressions and statements. The following example illustrates how they
-can be used.
-
-.. code-block:: cpp
-
-    // At beginning of file
-    #include <pybind11/eval.h>
-
-    ...
-
-    // Evaluate in scope of main module
-    py::object scope = py::module::import("__main__").attr("__dict__");
-
-    // Evaluate an isolated expression
-    int result = py::eval("my_variable + 10", scope).cast<int>();
-
-    // Evaluate a sequence of statements
-    py::exec(
-        "print('Hello')\n"
-        "print('world!');",
-        scope);
-
-    // Evaluate the statements in an separate Python file on disk
-    py::eval_file("script.py", scope);
-
-C++11 raw string literals are also supported and quite handy for this purpose.
-The only requirement is that the first statement must be on a new line following
-the raw string delimiter ``R"(``, ensuring all lines have common leading indent:
-
-.. code-block:: cpp
-
-    py::exec(R"(
-        x = get_answer()
-        if x == 42:
-            print('Hello World!')
-        else:
-            print('Bye!')
-        )", scope
-    );
-
-.. note::
-
-    `eval` and `eval_file` accept a template parameter that describes how the
-    string/file should be interpreted. Possible choices include ``eval_expr``
-    (isolated expression), ``eval_single_statement`` (a single statement, return
-    value is always ``none``), and ``eval_statements`` (sequence of statements,
-    return value is always ``none``). `eval` defaults to  ``eval_expr``,
-    `eval_file` defaults to ``eval_statements`` and `exec` is just a shortcut
-    for ``eval<eval_statements>``.
diff --git a/tmap/lib/pybind11/docs/advanced/smart_ptrs.rst b/tmap/lib/pybind11/docs/advanced/smart_ptrs.rst
deleted file mode 100644
index da57748..0000000
--- a/tmap/lib/pybind11/docs/advanced/smart_ptrs.rst
+++ /dev/null
@@ -1,173 +0,0 @@
-Smart pointers
-##############
-
-std::unique_ptr
-===============
-
-Given a class ``Example`` with Python bindings, it's possible to return
-instances wrapped in C++11 unique pointers, like so
-
-.. code-block:: cpp
-
-    std::unique_ptr<Example> create_example() { return std::unique_ptr<Example>(new Example()); }
-
-.. code-block:: cpp
-
-    m.def("create_example", &create_example);
-
-In other words, there is nothing special that needs to be done. While returning
-unique pointers in this way is allowed, it is *illegal* to use them as function
-arguments. For instance, the following function signature cannot be processed
-by pybind11.
-
-.. code-block:: cpp
-
-    void do_something_with_example(std::unique_ptr<Example> ex) { ... }
-
-The above signature would imply that Python needs to give up ownership of an
-object that is passed to this function, which is generally not possible (for
-instance, the object might be referenced elsewhere).
-
-std::shared_ptr
-===============
-
-The binding generator for classes, :class:`class_`, can be passed a template
-type that denotes a special *holder* type that is used to manage references to
-the object.  If no such holder type template argument is given, the default for
-a type named ``Type`` is ``std::unique_ptr<Type>``, which means that the object
-is deallocated when Python's reference count goes to zero.
-
-It is possible to switch to other types of reference counting wrappers or smart
-pointers, which is useful in codebases that rely on them. For instance, the
-following snippet causes ``std::shared_ptr`` to be used instead.
-
-.. code-block:: cpp
-
-    py::class_<Example, std::shared_ptr<Example> /* <- holder type */> obj(m, "Example");
-
-Note that any particular class can only be associated with a single holder type.
-
-One potential stumbling block when using holder types is that they need to be
-applied consistently. Can you guess what's broken about the following binding
-code?
-
-.. code-block:: cpp
-
-    class Child { };
-
-    class Parent {
-    public:
-       Parent() : child(std::make_shared<Child>()) { }
-       Child *get_child() { return child.get(); }  /* Hint: ** DON'T DO THIS ** */
-    private:
-        std::shared_ptr<Child> child;
-    };
-
-    PYBIND11_MODULE(example, m) {
-        py::class_<Child, std::shared_ptr<Child>>(m, "Child");
-
-        py::class_<Parent, std::shared_ptr<Parent>>(m, "Parent")
-           .def(py::init<>())
-           .def("get_child", &Parent::get_child);
-    }
-
-The following Python code will cause undefined behavior (and likely a
-segmentation fault).
-
-.. code-block:: python
-
-   from example import Parent
-   print(Parent().get_child())
-
-The problem is that ``Parent::get_child()`` returns a pointer to an instance of
-``Child``, but the fact that this instance is already managed by
-``std::shared_ptr<...>`` is lost when passing raw pointers. In this case,
-pybind11 will create a second independent ``std::shared_ptr<...>`` that also
-claims ownership of the pointer. In the end, the object will be freed **twice**
-since these shared pointers have no way of knowing about each other.
-
-There are two ways to resolve this issue:
-
-1. For types that are managed by a smart pointer class, never use raw pointers
-   in function arguments or return values. In other words: always consistently
-   wrap pointers into their designated holder types (such as
-   ``std::shared_ptr<...>``). In this case, the signature of ``get_child()``
-   should be modified as follows:
-
-.. code-block:: cpp
-
-    std::shared_ptr<Child> get_child() { return child; }
-
-2. Adjust the definition of ``Child`` by specifying
-   ``std::enable_shared_from_this<T>`` (see cppreference_ for details) as a
-   base class. This adds a small bit of information to ``Child`` that allows
-   pybind11 to realize that there is already an existing
-   ``std::shared_ptr<...>`` and communicate with it. In this case, the
-   declaration of ``Child`` should look as follows:
-
-.. _cppreference: http://en.cppreference.com/w/cpp/memory/enable_shared_from_this
-
-.. code-block:: cpp
-
-    class Child : public std::enable_shared_from_this<Child> { };
-
-.. _smart_pointers:
-
-Custom smart pointers
-=====================
-
-pybind11 supports ``std::unique_ptr`` and ``std::shared_ptr`` right out of the
-box. For any other custom smart pointer, transparent conversions can be enabled
-using a macro invocation similar to the following. It must be declared at the
-top namespace level before any binding code:
-
-.. code-block:: cpp
-
-    PYBIND11_DECLARE_HOLDER_TYPE(T, SmartPtr<T>);
-
-The first argument of :func:`PYBIND11_DECLARE_HOLDER_TYPE` should be a
-placeholder name that is used as a template parameter of the second argument.
-Thus, feel free to use any identifier, but use it consistently on both sides;
-also, don't use the name of a type that already exists in your codebase.
-
-The macro also accepts a third optional boolean parameter that is set to false
-by default. Specify
-
-.. code-block:: cpp
-
-    PYBIND11_DECLARE_HOLDER_TYPE(T, SmartPtr<T>, true);
-
-if ``SmartPtr<T>`` can always be initialized from a ``T*`` pointer without the
-risk of inconsistencies (such as multiple independent ``SmartPtr`` instances
-believing that they are the sole owner of the ``T*`` pointer). A common
-situation where ``true`` should be passed is when the ``T`` instances use
-*intrusive* reference counting.
-
-Please take a look at the :ref:`macro_notes` before using this feature.
-
-By default, pybind11 assumes that your custom smart pointer has a standard
-interface, i.e. provides a ``.get()`` member function to access the underlying
-raw pointer. If this is not the case, pybind11's ``holder_helper`` must be
-specialized:
-
-.. code-block:: cpp
-
-    // Always needed for custom holder types
-    PYBIND11_DECLARE_HOLDER_TYPE(T, SmartPtr<T>);
-
-    // Only needed if the type's `.get()` goes by another name
-    namespace pybind11 { namespace detail {
-        template <typename T>
-        struct holder_helper<SmartPtr<T>> { // <-- specialization
-            static const T *get(const SmartPtr<T> &p) { return p.getPointer(); }
-        };
-    }}
-
-The above specialization informs pybind11 that the custom ``SmartPtr`` class
-provides ``.get()`` functionality via ``.getPointer()``.
-
-.. seealso::
-
-    The file :file:`tests/test_smart_ptr.cpp` contains a complete example
-    that demonstrates how to work with custom reference-counting holder types
-    in more detail.
diff --git a/tmap/lib/pybind11/docs/basics.rst b/tmap/lib/pybind11/docs/basics.rst
deleted file mode 100644
index 447250e..0000000
--- a/tmap/lib/pybind11/docs/basics.rst
+++ /dev/null
@@ -1,293 +0,0 @@
-.. _basics:
-
-First steps
-###########
-
-This sections demonstrates the basic features of pybind11. Before getting
-started, make sure that development environment is set up to compile the
-included set of test cases.
-
-
-Compiling the test cases
-========================
-
-Linux/MacOS
------------
-
-On Linux  you'll need to install the **python-dev** or **python3-dev** packages as
-well as **cmake**. On Mac OS, the included python version works out of the box,
-but **cmake** must still be installed.
-
-After installing the prerequisites, run
-
-.. code-block:: bash
-
-   mkdir build
-   cd build
-   cmake ..
-   make check -j 4
-
-The last line will both compile and run the tests.
-
-Windows
--------
-
-On Windows, only **Visual Studio 2015** and newer are supported since pybind11 relies
-on various C++11 language features that break older versions of Visual Studio.
-
-To compile and run the tests:
-
-.. code-block:: batch
-
-   mkdir build
-   cd build
-   cmake ..
-   cmake --build . --config Release --target check
-
-This will create a Visual Studio project, compile and run the target, all from the
-command line.
-
-.. Note::
-
-    If all tests fail, make sure that the Python binary and the testcases are compiled
-    for the same processor type and bitness (i.e. either **i386** or **x86_64**). You
-    can specify **x86_64** as the target architecture for the generated Visual Studio
-    project using ``cmake -A x64 ..``.
-
-.. seealso::
-
-    Advanced users who are already familiar with Boost.Python may want to skip
-    the tutorial and look at the test cases in the :file:`tests` directory,
-    which exercise all features of pybind11.
-
-Header and namespace conventions
-================================
-
-For brevity, all code examples assume that the following two lines are present:
-
-.. code-block:: cpp
-
-    #include <pybind11/pybind11.h>
-
-    namespace py = pybind11;
-
-Some features may require additional headers, but those will be specified as needed.
-
-.. _simple_example:
-
-Creating bindings for a simple function
-=======================================
-
-Let's start by creating Python bindings for an extremely simple function, which
-adds two numbers and returns their result:
-
-.. code-block:: cpp
-
-    int add(int i, int j) {
-        return i + j;
-    }
-
-For simplicity [#f1]_, we'll put both this function and the binding code into
-a file named :file:`example.cpp` with the following contents:
-
-.. code-block:: cpp
-
-    #include <pybind11/pybind11.h>
-
-    int add(int i, int j) {
-        return i + j;
-    }
-
-    PYBIND11_MODULE(example, m) {
-        m.doc() = "pybind11 example plugin"; // optional module docstring
-
-        m.def("add", &add, "A function which adds two numbers");
-    }
-
-.. [#f1] In practice, implementation and binding code will generally be located
-         in separate files.
-
-The :func:`PYBIND11_MODULE` macro creates a function that will be called when an
-``import`` statement is issued from within Python. The module name (``example``)
-is given as the first macro argument (it should not be in quotes). The second
-argument (``m``) defines a variable of type :class:`py::module <module>` which
-is the main interface for creating bindings. The method :func:`module::def`
-generates binding code that exposes the ``add()`` function to Python.
-
-.. note::
-
-    Notice how little code was needed to expose our function to Python: all
-    details regarding the function's parameters and return value were
-    automatically inferred using template metaprogramming. This overall
-    approach and the used syntax are borrowed from Boost.Python, though the
-    underlying implementation is very different.
-
-pybind11 is a header-only library, hence it is not necessary to link against
-any special libraries and there are no intermediate (magic) translation steps.
-On Linux, the above example can be compiled using the following command:
-
-.. code-block:: bash
-
-    $ c++ -O3 -Wall -shared -std=c++11 -fPIC `python3 -m pybind11 --includes` example.cpp -o example`python3-config --extension-suffix`
-
-For more details on the required compiler flags on Linux and MacOS, see
-:ref:`building_manually`. For complete cross-platform compilation instructions,
-refer to the :ref:`compiling` page.
-
-The `python_example`_ and `cmake_example`_ repositories are also a good place
-to start. They are both complete project examples with cross-platform build
-systems. The only difference between the two is that `python_example`_ uses
-Python's ``setuptools`` to build the module, while `cmake_example`_ uses CMake
-(which may be preferable for existing C++ projects).
-
-.. _python_example: https://github.com/pybind/python_example
-.. _cmake_example: https://github.com/pybind/cmake_example
-
-Building the above C++ code will produce a binary module file that can be
-imported to Python. Assuming that the compiled module is located in the
-current directory, the following interactive Python session shows how to
-load and execute the example:
-
-.. code-block:: pycon
-
-    $ python
-    Python 2.7.10 (default, Aug 22 2015, 20:33:39)
-    [GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.0.59.1)] on darwin
-    Type "help", "copyright", "credits" or "license" for more information.
-    >>> import example
-    >>> example.add(1, 2)
-    3L
-    >>>
-
-.. _keyword_args:
-
-Keyword arguments
-=================
-
-With a simple modification code, it is possible to inform Python about the
-names of the arguments ("i" and "j" in this case).
-
-.. code-block:: cpp
-
-    m.def("add", &add, "A function which adds two numbers",
-          py::arg("i"), py::arg("j"));
-
-:class:`arg` is one of several special tag classes which can be used to pass
-metadata into :func:`module::def`. With this modified binding code, we can now
-call the function using keyword arguments, which is a more readable alternative
-particularly for functions taking many parameters:
-
-.. code-block:: pycon
-
-    >>> import example
-    >>> example.add(i=1, j=2)
-    3L
-
-The keyword names also appear in the function signatures within the documentation.
-
-.. code-block:: pycon
-
-    >>> help(example)
-
-    ....
-
-    FUNCTIONS
-        add(...)
-            Signature : (i: int, j: int) -> int
-
-            A function which adds two numbers
-
-A shorter notation for named arguments is also available:
-
-.. code-block:: cpp
-
-    // regular notation
-    m.def("add1", &add, py::arg("i"), py::arg("j"));
-    // shorthand
-    using namespace pybind11::literals;
-    m.def("add2", &add, "i"_a, "j"_a);
-
-The :var:`_a` suffix forms a C++11 literal which is equivalent to :class:`arg`.
-Note that the literal operator must first be made visible with the directive
-``using namespace pybind11::literals``. This does not bring in anything else
-from the ``pybind11`` namespace except for literals.
-
-.. _default_args:
-
-Default arguments
-=================
-
-Suppose now that the function to be bound has default arguments, e.g.:
-
-.. code-block:: cpp
-
-    int add(int i = 1, int j = 2) {
-        return i + j;
-    }
-
-Unfortunately, pybind11 cannot automatically extract these parameters, since they
-are not part of the function's type information. However, they are simple to specify
-using an extension of :class:`arg`:
-
-.. code-block:: cpp
-
-    m.def("add", &add, "A function which adds two numbers",
-          py::arg("i") = 1, py::arg("j") = 2);
-
-The default values also appear within the documentation.
-
-.. code-block:: pycon
-
-    >>> help(example)
-
-    ....
-
-    FUNCTIONS
-        add(...)
-            Signature : (i: int = 1, j: int = 2) -> int
-
-            A function which adds two numbers
-
-The shorthand notation is also available for default arguments:
-
-.. code-block:: cpp
-
-    // regular notation
-    m.def("add1", &add, py::arg("i") = 1, py::arg("j") = 2);
-    // shorthand
-    m.def("add2", &add, "i"_a=1, "j"_a=2);
-
-Exporting variables
-===================
-
-To expose a value from C++, use the ``attr`` function to register it in a
-module as shown below. Built-in types and general objects (more on that later)
-are automatically converted when assigned as attributes, and can be explicitly
-converted using the function ``py::cast``.
-
-.. code-block:: cpp
-
-    PYBIND11_MODULE(example, m) {
-        m.attr("the_answer") = 42;
-        py::object world = py::cast("World");
-        m.attr("what") = world;
-    }
-
-These are then accessible from Python:
-
-.. code-block:: pycon
-
-    >>> import example
-    >>> example.the_answer
-    42
-    >>> example.what
-    'World'
-
-.. _supported_types:
-
-Supported data types
-====================
-
-A large number of data types are supported out of the box and can be used
-seamlessly as functions arguments, return values or with ``py::cast`` in general.
-For a full overview, see the :doc:`advanced/cast/index` section.
diff --git a/tmap/lib/pybind11/docs/benchmark.py b/tmap/lib/pybind11/docs/benchmark.py
deleted file mode 100644
index 6dc0604..0000000
--- a/tmap/lib/pybind11/docs/benchmark.py
+++ /dev/null
@@ -1,88 +0,0 @@
-import random
-import os
-import time
-import datetime as dt
-
-nfns = 4  # Functions per class
-nargs = 4  # Arguments per function
-
-
-def generate_dummy_code_pybind11(nclasses=10):
-    decl = ""
-    bindings = ""
-
-    for cl in range(nclasses):
-        decl += "class cl%03i;\n" % cl
-    decl += '\n'
-
-    for cl in range(nclasses):
-        decl += "class cl%03i {\n" % cl
-        decl += "public:\n"
-        bindings += '    py::class_<cl%03i>(m, "cl%03i")\n' % (cl, cl)
-        for fn in range(nfns):
-            ret = random.randint(0, nclasses - 1)
-            params  = [random.randint(0, nclasses - 1) for i in range(nargs)]
-            decl += "    cl%03i *fn_%03i(" % (ret, fn)
-            decl += ", ".join("cl%03i *" % p for p in params)
-            decl += ");\n"
-            bindings += '        .def("fn_%03i", &cl%03i::fn_%03i)\n' % \
-                (fn, cl, fn)
-        decl += "};\n\n"
-        bindings += '        ;\n'
-
-    result = "#include <pybind11/pybind11.h>\n\n"
-    result += "namespace py = pybind11;\n\n"
-    result += decl + '\n'
-    result += "PYBIND11_MODULE(example, m) {\n"
-    result += bindings
-    result += "}"
-    return result
-
-
-def generate_dummy_code_boost(nclasses=10):
-    decl = ""
-    bindings = ""
-
-    for cl in range(nclasses):
-        decl += "class cl%03i;\n" % cl
-    decl += '\n'
-
-    for cl in range(nclasses):
-        decl += "class cl%03i {\n" % cl
-        decl += "public:\n"
-        bindings += '    py::class_<cl%03i>("cl%03i")\n' % (cl, cl)
-        for fn in range(nfns):
-            ret = random.randint(0, nclasses - 1)
-            params  = [random.randint(0, nclasses - 1) for i in range(nargs)]
-            decl += "    cl%03i *fn_%03i(" % (ret, fn)
-            decl += ", ".join("cl%03i *" % p for p in params)
-            decl += ");\n"
-            bindings += '        .def("fn_%03i", &cl%03i::fn_%03i, py::return_value_policy<py::manage_new_object>())\n' % \
-                (fn, cl, fn)
-        decl += "};\n\n"
-        bindings += '        ;\n'
-
-    result = "#include <boost/python.hpp>\n\n"
-    result += "namespace py = boost::python;\n\n"
-    result += decl + '\n'
-    result += "BOOST_PYTHON_MODULE(example) {\n"
-    result += bindings
-    result += "}"
-    return result
-
-
-for codegen in [generate_dummy_code_pybind11, generate_dummy_code_boost]:
-    print ("{")
-    for i in range(0, 10):
-        nclasses = 2 ** i
-        with open("test.cpp", "w") as f:
-            f.write(codegen(nclasses))
-        n1 = dt.datetime.now()
-        os.system("g++ -Os -shared -rdynamic -undefined dynamic_lookup "
-            "-fvisibility=hidden -std=c++14 test.cpp -I include "
-            "-I /System/Library/Frameworks/Python.framework/Headers -o test.so")
-        n2 = dt.datetime.now()
-        elapsed = (n2 - n1).total_seconds()
-        size = os.stat('test.so').st_size
-        print("   {%i, %f, %i}," % (nclasses * nfns, elapsed, size))
-    print ("}")
diff --git a/tmap/lib/pybind11/docs/benchmark.rst b/tmap/lib/pybind11/docs/benchmark.rst
deleted file mode 100644
index 59d533d..0000000
--- a/tmap/lib/pybind11/docs/benchmark.rst
+++ /dev/null
@@ -1,97 +0,0 @@
-Benchmark
-=========
-
-The following is the result of a synthetic benchmark comparing both compilation
-time and module size of pybind11 against Boost.Python. A detailed report about a
-Boost.Python to pybind11 conversion of a real project is available here: [#f1]_.
-
-.. [#f1] http://graylab.jhu.edu/RosettaCon2016/PyRosetta-4.pdf
-
-Setup
------
-
-A python script (see the ``docs/benchmark.py`` file) was used to generate a set
-of files with dummy classes whose count increases for each successive benchmark
-(between 1 and 2048 classes in powers of two). Each class has four methods with
-a randomly generated signature with a return value and four arguments. (There
-was no particular reason for this setup other than the desire to generate many
-unique function signatures whose count could be controlled in a simple way.)
-
-Here is an example of the binding code for one class:
-
-.. code-block:: cpp
-
-    ...
-    class cl034 {
-    public:
-        cl279 *fn_000(cl084 *, cl057 *, cl065 *, cl042 *);
-        cl025 *fn_001(cl098 *, cl262 *, cl414 *, cl121 *);
-        cl085 *fn_002(cl445 *, cl297 *, cl145 *, cl421 *);
-        cl470 *fn_003(cl200 *, cl323 *, cl332 *, cl492 *);
-    };
-    ...
-
-    PYBIND11_MODULE(example, m) {
-        ...
-        py::class_<cl034>(m, "cl034")
-            .def("fn_000", &cl034::fn_000)
-            .def("fn_001", &cl034::fn_001)
-            .def("fn_002", &cl034::fn_002)
-            .def("fn_003", &cl034::fn_003)
-        ...
-    }
-
-The Boost.Python version looks almost identical except that a return value
-policy had to be specified as an argument to ``def()``. For both libraries,
-compilation was done with
-
-.. code-block:: bash
-
-    Apple LLVM version 7.0.2 (clang-700.1.81)
-
-and the following compilation flags
-
-.. code-block:: bash
-
-    g++ -Os -shared -rdynamic -undefined dynamic_lookup -fvisibility=hidden -std=c++14
-
-Compilation time
-----------------
-
-The following log-log plot shows how the compilation time grows for an
-increasing number of class and function declarations. pybind11 includes many
-fewer headers, which initially leads to shorter compilation times, but the
-performance is ultimately fairly similar (pybind11 is 19.8 seconds faster for
-the largest largest file with 2048 classes and a total of 8192 methods -- a
-modest **1.2x** speedup relative to Boost.Python, which required 116.35
-seconds).
-
-.. only:: not latex
-
-    .. image:: pybind11_vs_boost_python1.svg
-
-.. only:: latex
-
-    .. image:: pybind11_vs_boost_python1.png
-
-Module size
------------
-
-Differences between the two libraries become much more pronounced when
-considering the file size of the generated Python plugin: for the largest file,
-the binary generated by Boost.Python required 16.8 MiB, which was **2.17
-times** / **9.1 megabytes** larger than the output generated by pybind11. For
-very small inputs, Boost.Python has an edge in the plot below -- however, note
-that it stores many definitions in an external library, whose size was not
-included here, hence the comparison is slightly shifted in Boost.Python's
-favor.
-
-.. only:: not latex
-
-    .. image:: pybind11_vs_boost_python2.svg
-
-.. only:: latex
-
-    .. image:: pybind11_vs_boost_python2.png
-
-
diff --git a/tmap/lib/pybind11/docs/changelog.rst b/tmap/lib/pybind11/docs/changelog.rst
deleted file mode 100644
index fa56fdd..0000000
--- a/tmap/lib/pybind11/docs/changelog.rst
+++ /dev/null
@@ -1,885 +0,0 @@
-.. _changelog:
-
-Changelog
-#########
-
-Starting with version 1.8.0, pybind11 releases use a `semantic versioning
-<http://semver.org>`_ policy.
-
-v2.2.0 (August 31, 2017)
------------------------------------------------------
-
-* Support for embedding the Python interpreter. See the
-  :doc:`documentation page </advanced/embedding>` for a
-  full overview of the new features.
-  `#774 <https://github.com/pybind/pybind11/pull/774>`_,
-  `#889 <https://github.com/pybind/pybind11/pull/889>`_,
-  `#892 <https://github.com/pybind/pybind11/pull/892>`_,
-  `#920 <https://github.com/pybind/pybind11/pull/920>`_.
-
-  .. code-block:: cpp
-
-      #include <pybind11/embed.h>
-      namespace py = pybind11;
-
-      int main() {
-          py::scoped_interpreter guard{}; // start the interpreter and keep it alive
-
-          py::print("Hello, World!"); // use the Python API
-      }
-
-* Support for inheriting from multiple C++ bases in Python.
-  `#693 <https://github.com/pybind/pybind11/pull/693>`_.
-
-  .. code-block:: python
-
-      from cpp_module import CppBase1, CppBase2
-
-      class PyDerived(CppBase1, CppBase2):
-          def __init__(self):
-              CppBase1.__init__(self)  # C++ bases must be initialized explicitly
-              CppBase2.__init__(self)
-
-* ``PYBIND11_MODULE`` is now the preferred way to create module entry points.
-  ``PYBIND11_PLUGIN`` is deprecated. See :ref:`macros` for details.
-  `#879 <https://github.com/pybind/pybind11/pull/879>`_.
-
-  .. code-block:: cpp
-
-      // new
-      PYBIND11_MODULE(example, m) {
-          m.def("add", [](int a, int b) { return a + b; });
-      }
-
-      // old
-      PYBIND11_PLUGIN(example) {
-          py::module m("example");
-          m.def("add", [](int a, int b) { return a + b; });
-          return m.ptr();
-      }
-
-* pybind11's headers and build system now more strictly enforce hidden symbol
-  visibility for extension modules. This should be seamless for most users,
-  but see the :doc:`upgrade` if you use a custom build system.
-  `#995 <https://github.com/pybind/pybind11/pull/995>`_.
-
-* Support for ``py::module_local`` types which allow multiple modules to
-  export the same C++ types without conflicts. This is useful for opaque
-  types like ``std::vector<int>``. ``py::bind_vector`` and ``py::bind_map``
-  now default to ``py::module_local`` if their elements are builtins or
-  local types. See :ref:`module_local` for details.
-  `#949 <https://github.com/pybind/pybind11/pull/949>`_,
-  `#981 <https://github.com/pybind/pybind11/pull/981>`_,
-  `#995 <https://github.com/pybind/pybind11/pull/995>`_,
-  `#997 <https://github.com/pybind/pybind11/pull/997>`_.
-
-* Custom constructors can now be added very easily using lambdas or factory
-  functions which return a class instance by value, pointer or holder. This
-  supersedes the old placement-new ``__init__`` technique.
-  See :ref:`custom_constructors` for details.
-  `#805 <https://github.com/pybind/pybind11/pull/805>`_,
-  `#1014 <https://github.com/pybind/pybind11/pull/1014>`_.
-
-  .. code-block:: cpp
-
-      struct Example {
-          Example(std::string);
-      };
-
-      py::class_<Example>(m, "Example")
-          .def(py::init<std::string>()) // existing constructor
-          .def(py::init([](int n) { // custom constructor
-              return std::make_unique<Example>(std::to_string(n));
-          }));
-
-* Similarly to custom constructors, pickling support functions are now bound
-  using the ``py::pickle()`` adaptor which improves type safety. See the
-  :doc:`upgrade` and :ref:`pickling` for details.
-  `#1038 <https://github.com/pybind/pybind11/pull/1038>`_.
-
-* Builtin support for converting C++17 standard library types and general
-  conversion improvements:
-
-  1. C++17 ``std::variant`` is supported right out of the box. C++11/14
-     equivalents (e.g. ``boost::variant``) can also be added with a simple
-     user-defined specialization. See :ref:`cpp17_container_casters` for details.
-     `#811 <https://github.com/pybind/pybind11/pull/811>`_,
-     `#845 <https://github.com/pybind/pybind11/pull/845>`_,
-     `#989 <https://github.com/pybind/pybind11/pull/989>`_.
-
-  2. Out-of-the-box support for C++17 ``std::string_view``.
-     `#906 <https://github.com/pybind/pybind11/pull/906>`_.
-
-  3. Improved compatibility of the builtin ``optional`` converter.
-     `#874 <https://github.com/pybind/pybind11/pull/874>`_.
-
-  4. The ``bool`` converter now accepts ``numpy.bool_`` and types which
-     define ``__bool__`` (Python 3.x) or ``__nonzero__`` (Python 2.7).
-     `#925 <https://github.com/pybind/pybind11/pull/925>`_.
-
-  5. C++-to-Python casters are now more efficient and move elements out
-     of rvalue containers whenever possible.
-     `#851 <https://github.com/pybind/pybind11/pull/851>`_,
-     `#936 <https://github.com/pybind/pybind11/pull/936>`_,
-     `#938 <https://github.com/pybind/pybind11/pull/938>`_.
-
-  6. Fixed ``bytes`` to ``std::string/char*`` conversion on Python 3.
-     `#817 <https://github.com/pybind/pybind11/pull/817>`_.
-
-  7. Fixed lifetime of temporary C++ objects created in Python-to-C++ conversions.
-     `#924 <https://github.com/pybind/pybind11/pull/924>`_.
-
-* Scope guard call policy for RAII types, e.g. ``py::call_guard<py::gil_scoped_release>()``,
-  ``py::call_guard<py::scoped_ostream_redirect>()``. See :ref:`call_policies` for details.
-  `#740 <https://github.com/pybind/pybind11/pull/740>`_.
-
-* Utility for redirecting C++ streams to Python (e.g. ``std::cout`` ->
-  ``sys.stdout``). Scope guard ``py::scoped_ostream_redirect`` in C++ and
-  a context manager in Python. See :ref:`ostream_redirect`.
-  `#1009 <https://github.com/pybind/pybind11/pull/1009>`_.
-
-* Improved handling of types and exceptions across module boundaries.
-  `#915 <https://github.com/pybind/pybind11/pull/915>`_,
-  `#951 <https://github.com/pybind/pybind11/pull/951>`_,
-  `#995 <https://github.com/pybind/pybind11/pull/995>`_.
-
-* Fixed destruction order of ``py::keep_alive`` nurse/patient objects
-  in reference cycles.
-  `#856 <https://github.com/pybind/pybind11/pull/856>`_.
-
-* Numpy and buffer protocol related improvements:
-
-  1. Support for negative strides in Python buffer objects/numpy arrays. This
-     required changing integers from unsigned to signed for the related C++ APIs.
-     Note: If you have compiler warnings enabled, you may notice some new conversion
-     warnings after upgrading. These can be resolved with ``static_cast``.
-     `#782 <https://github.com/pybind/pybind11/pull/782>`_.
-
-  2. Support ``std::complex`` and arrays inside ``PYBIND11_NUMPY_DTYPE``.
-     `#831 <https://github.com/pybind/pybind11/pull/831>`_,
-     `#832 <https://github.com/pybind/pybind11/pull/832>`_.
-
-  3. Support for constructing ``py::buffer_info`` and ``py::arrays`` using
-     arbitrary containers or iterators instead of requiring a ``std::vector``.
-     `#788 <https://github.com/pybind/pybind11/pull/788>`_,
-     `#822 <https://github.com/pybind/pybind11/pull/822>`_,
-     `#860 <https://github.com/pybind/pybind11/pull/860>`_.
-
-  4. Explicitly check numpy version and require >= 1.7.0.
-     `#819 <https://github.com/pybind/pybind11/pull/819>`_.
-
-* Support for allowing/prohibiting ``None`` for specific arguments and improved
-  ``None`` overload resolution order. See :ref:`none_arguments` for details.
-  `#843 <https://github.com/pybind/pybind11/pull/843>`_.
-  `#859 <https://github.com/pybind/pybind11/pull/859>`_.
-
-* Added ``py::exec()`` as a shortcut for ``py::eval<py::eval_statements>()``
-  and support for C++11 raw string literals as input. See :ref:`eval`.
-  `#766 <https://github.com/pybind/pybind11/pull/766>`_,
-  `#827 <https://github.com/pybind/pybind11/pull/827>`_.
-
-* ``py::vectorize()`` ignores non-vectorizable arguments and supports
-  member functions.
-  `#762 <https://github.com/pybind/pybind11/pull/762>`_.
-
-* Support for bound methods as callbacks (``pybind11/functional.h``).
-  `#815 <https://github.com/pybind/pybind11/pull/815>`_.
-
-* Allow aliasing pybind11 methods: ``cls.attr("foo") = cls.attr("bar")``.
-  `#802 <https://github.com/pybind/pybind11/pull/802>`_.
-
-* Don't allow mixed static/non-static overloads.
-  `#804 <https://github.com/pybind/pybind11/pull/804>`_.
-
-* Fixed overriding static properties in derived classes.
-  `#784 <https://github.com/pybind/pybind11/pull/784>`_.
-
-* Improved deduction of member functions of a derived class when its bases
-  aren't registered with pybind11.
-  `#855 <https://github.com/pybind/pybind11/pull/855>`_.
-
-  .. code-block:: cpp
-
-      struct Base {
-          int foo() { return 42; }
-      }
-
-      struct Derived : Base {}
-
-      // Now works, but previously required also binding `Base`
-      py::class_<Derived>(m, "Derived")
-          .def("foo", &Derived::foo); // function is actually from `Base`
-
-* The implementation of ``py::init<>`` now uses C++11 brace initialization
-  syntax to construct instances, which permits binding implicit constructors of
-  aggregate types. `#1015 <https://github.com/pybind/pybind11/pull/1015>`_.
-
-    .. code-block:: cpp
-
-        struct Aggregate {
-            int a;
-            std::string b;
-        };
-
-        py::class_<Aggregate>(m, "Aggregate")
-            .def(py::init<int, const std::string &>());
-
-* Fixed issues with multiple inheritance with offset base/derived pointers.
-  `#812 <https://github.com/pybind/pybind11/pull/812>`_,
-  `#866 <https://github.com/pybind/pybind11/pull/866>`_,
-  `#960 <https://github.com/pybind/pybind11/pull/960>`_.
-
-* Fixed reference leak of type objects.
-  `#1030 <https://github.com/pybind/pybind11/pull/1030>`_.
-
-* Improved support for the ``/std:c++14`` and ``/std:c++latest`` modes
-  on MSVC 2017.
-  `#841 <https://github.com/pybind/pybind11/pull/841>`_,
-  `#999 <https://github.com/pybind/pybind11/pull/999>`_.
-
-* Fixed detection of private operator new on MSVC.
-  `#893 <https://github.com/pybind/pybind11/pull/893>`_,
-  `#918 <https://github.com/pybind/pybind11/pull/918>`_.
-
-* Intel C++ compiler compatibility fixes.
-  `#937 <https://github.com/pybind/pybind11/pull/937>`_.
-
-* Fixed implicit conversion of `py::enum_` to integer types on Python 2.7.
-  `#821 <https://github.com/pybind/pybind11/pull/821>`_.
-
-* Added ``py::hash`` to fetch the hash value of Python objects, and
-  ``.def(hash(py::self))`` to provide the C++ ``std::hash`` as the Python
-  ``__hash__`` method.
-  `#1034 <https://github.com/pybind/pybind11/pull/1034>`_.
-
-* Fixed ``__truediv__`` on Python 2 and ``__itruediv__`` on Python 3.
-  `#867 <https://github.com/pybind/pybind11/pull/867>`_.
-
-* ``py::capsule`` objects now support the ``name`` attribute. This is useful
-  for interfacing with ``scipy.LowLevelCallable``.
-  `#902 <https://github.com/pybind/pybind11/pull/902>`_.
-
-* Fixed ``py::make_iterator``'s ``__next__()`` for past-the-end calls.
-  `#897 <https://github.com/pybind/pybind11/pull/897>`_.
-
-* Added ``error_already_set::matches()`` for checking Python exceptions.
-  `#772 <https://github.com/pybind/pybind11/pull/772>`_.
-
-* Deprecated ``py::error_already_set::clear()``. It's no longer needed
-  following a simplification of the ``py::error_already_set`` class.
-  `#954 <https://github.com/pybind/pybind11/pull/954>`_.
-
-* Deprecated ``py::handle::operator==()`` in favor of ``py::handle::is()``
-  `#825 <https://github.com/pybind/pybind11/pull/825>`_.
-
-* Deprecated ``py::object::borrowed``/``py::object::stolen``.
-  Use ``py::object::borrowed_t{}``/``py::object::stolen_t{}`` instead.
-  `#771 <https://github.com/pybind/pybind11/pull/771>`_.
-
-* Changed internal data structure versioning to avoid conflicts between
-  modules compiled with different revisions of pybind11.
-  `#1012 <https://github.com/pybind/pybind11/pull/1012>`_.
-
-* Additional compile-time and run-time error checking and more informative messages.
-  `#786 <https://github.com/pybind/pybind11/pull/786>`_,
-  `#794 <https://github.com/pybind/pybind11/pull/794>`_,
-  `#803 <https://github.com/pybind/pybind11/pull/803>`_.
-
-* Various minor improvements and fixes.
-  `#764 <https://github.com/pybind/pybind11/pull/764>`_,
-  `#791 <https://github.com/pybind/pybind11/pull/791>`_,
-  `#795 <https://github.com/pybind/pybind11/pull/795>`_,
-  `#840 <https://github.com/pybind/pybind11/pull/840>`_,
-  `#844 <https://github.com/pybind/pybind11/pull/844>`_,
-  `#846 <https://github.com/pybind/pybind11/pull/846>`_,
-  `#849 <https://github.com/pybind/pybind11/pull/849>`_,
-  `#858 <https://github.com/pybind/pybind11/pull/858>`_,
-  `#862 <https://github.com/pybind/pybind11/pull/862>`_,
-  `#871 <https://github.com/pybind/pybind11/pull/871>`_,
-  `#872 <https://github.com/pybind/pybind11/pull/872>`_,
-  `#881 <https://github.com/pybind/pybind11/pull/881>`_,
-  `#888 <https://github.com/pybind/pybind11/pull/888>`_,
-  `#899 <https://github.com/pybind/pybind11/pull/899>`_,
-  `#928 <https://github.com/pybind/pybind11/pull/928>`_,
-  `#931 <https://github.com/pybind/pybind11/pull/931>`_,
-  `#944 <https://github.com/pybind/pybind11/pull/944>`_,
-  `#950 <https://github.com/pybind/pybind11/pull/950>`_,
-  `#952 <https://github.com/pybind/pybind11/pull/952>`_,
-  `#962 <https://github.com/pybind/pybind11/pull/962>`_,
-  `#965 <https://github.com/pybind/pybind11/pull/965>`_,
-  `#970 <https://github.com/pybind/pybind11/pull/970>`_,
-  `#978 <https://github.com/pybind/pybind11/pull/978>`_,
-  `#979 <https://github.com/pybind/pybind11/pull/979>`_,
-  `#986 <https://github.com/pybind/pybind11/pull/986>`_,
-  `#1020 <https://github.com/pybind/pybind11/pull/1020>`_,
-  `#1027 <https://github.com/pybind/pybind11/pull/1027>`_,
-  `#1037 <https://github.com/pybind/pybind11/pull/1037>`_.
-
-* Testing improvements.
-  `#798 <https://github.com/pybind/pybind11/pull/798>`_,
-  `#882 <https://github.com/pybind/pybind11/pull/882>`_,
-  `#898 <https://github.com/pybind/pybind11/pull/898>`_,
-  `#900 <https://github.com/pybind/pybind11/pull/900>`_,
-  `#921 <https://github.com/pybind/pybind11/pull/921>`_,
-  `#923 <https://github.com/pybind/pybind11/pull/923>`_,
-  `#963 <https://github.com/pybind/pybind11/pull/963>`_.
-
-v2.1.1 (April 7, 2017)
------------------------------------------------------
-
-* Fixed minimum version requirement for MSVC 2015u3
-  `#773 <https://github.com/pybind/pybind11/pull/773>`_.
-
-v2.1.0 (March 22, 2017)
------------------------------------------------------
-
-* pybind11 now performs function overload resolution in two phases. The first
-  phase only considers exact type matches, while the second allows for implicit
-  conversions to take place. A special ``noconvert()`` syntax can be used to
-  completely disable implicit conversions for specific arguments.
-  `#643 <https://github.com/pybind/pybind11/pull/643>`_,
-  `#634 <https://github.com/pybind/pybind11/pull/634>`_,
-  `#650 <https://github.com/pybind/pybind11/pull/650>`_.
-
-* Fixed a regression where static properties no longer worked with classes
-  using multiple inheritance. The ``py::metaclass`` attribute is no longer
-  necessary (and deprecated as of this release) when binding classes with
-  static properties.
-  `#679 <https://github.com/pybind/pybind11/pull/679>`_,
-
-* Classes bound using ``pybind11`` can now use custom metaclasses.
-  `#679 <https://github.com/pybind/pybind11/pull/679>`_,
-
-* ``py::args`` and ``py::kwargs`` can now be mixed with other positional
-  arguments when binding functions using pybind11.
-  `#611 <https://github.com/pybind/pybind11/pull/611>`_.
-
-* Improved support for C++11 unicode string and character types; added
-  extensive documentation regarding pybind11's string conversion behavior.
-  `#624 <https://github.com/pybind/pybind11/pull/624>`_,
-  `#636 <https://github.com/pybind/pybind11/pull/636>`_,
-  `#715 <https://github.com/pybind/pybind11/pull/715>`_.
-
-* pybind11 can now avoid expensive copies when converting Eigen arrays to NumPy
-  arrays (and vice versa). `#610 <https://github.com/pybind/pybind11/pull/610>`_.
-
-* The "fast path" in ``py::vectorize`` now works for any full-size group of C or
-  F-contiguous arrays. The non-fast path is also faster since it no longer performs
-  copies of the input arguments (except when type conversions are necessary).
-  `#610 <https://github.com/pybind/pybind11/pull/610>`_.
-
-* Added fast, unchecked access to NumPy arrays via a proxy object.
-  `#746 <https://github.com/pybind/pybind11/pull/746>`_.
-
-* Transparent support for class-specific ``operator new`` and
-  ``operator delete`` implementations.
-  `#755 <https://github.com/pybind/pybind11/pull/755>`_.
-
-* Slimmer and more efficient STL-compatible iterator interface for sequence types.
-  `#662 <https://github.com/pybind/pybind11/pull/662>`_.
-
-* Improved custom holder type support.
-  `#607 <https://github.com/pybind/pybind11/pull/607>`_.
-
-* ``nullptr`` to ``None`` conversion fixed in various builtin type casters.
-  `#732 <https://github.com/pybind/pybind11/pull/732>`_.
-
-* ``enum_`` now exposes its members via a special ``__members__`` attribute.
-  `#666 <https://github.com/pybind/pybind11/pull/666>`_.
-
-* ``std::vector`` bindings created using ``stl_bind.h`` can now optionally
-  implement the buffer protocol. `#488 <https://github.com/pybind/pybind11/pull/488>`_.
-
-* Automated C++ reference documentation using doxygen and breathe.
-  `#598 <https://github.com/pybind/pybind11/pull/598>`_.
-
-* Added minimum compiler version assertions.
-  `#727 <https://github.com/pybind/pybind11/pull/727>`_.
-
-* Improved compatibility with C++1z.
-  `#677 <https://github.com/pybind/pybind11/pull/677>`_.
-
-* Improved ``py::capsule`` API. Can be used to implement cleanup
-  callbacks that are involved at module destruction time.
-  `#752 <https://github.com/pybind/pybind11/pull/752>`_.
-
-* Various minor improvements and fixes.
-  `#595 <https://github.com/pybind/pybind11/pull/595>`_,
-  `#588 <https://github.com/pybind/pybind11/pull/588>`_,
-  `#589 <https://github.com/pybind/pybind11/pull/589>`_,
-  `#603 <https://github.com/pybind/pybind11/pull/603>`_,
-  `#619 <https://github.com/pybind/pybind11/pull/619>`_,
-  `#648 <https://github.com/pybind/pybind11/pull/648>`_,
-  `#695 <https://github.com/pybind/pybind11/pull/695>`_,
-  `#720 <https://github.com/pybind/pybind11/pull/720>`_,
-  `#723 <https://github.com/pybind/pybind11/pull/723>`_,
-  `#729 <https://github.com/pybind/pybind11/pull/729>`_,
-  `#724 <https://github.com/pybind/pybind11/pull/724>`_,
-  `#742 <https://github.com/pybind/pybind11/pull/742>`_,
-  `#753 <https://github.com/pybind/pybind11/pull/753>`_.
-
-v2.0.1 (Jan 4, 2017)
------------------------------------------------------
-
-* Fix pointer to reference error in type_caster on MSVC
-  `#583 <https://github.com/pybind/pybind11/pull/583>`_.
-
-* Fixed a segmentation in the test suite due to a typo
-  `cd7eac <https://github.com/pybind/pybind11/commit/cd7eac>`_.
-
-v2.0.0 (Jan 1, 2017)
------------------------------------------------------
-
-* Fixed a reference counting regression affecting types with custom metaclasses
-  (introduced in v2.0.0-rc1).
-  `#571 <https://github.com/pybind/pybind11/pull/571>`_.
-
-* Quenched a CMake policy warning.
-  `#570 <https://github.com/pybind/pybind11/pull/570>`_.
-
-v2.0.0-rc1 (Dec 23, 2016)
------------------------------------------------------
-
-The pybind11 developers are excited to issue a release candidate of pybind11
-with a subsequent v2.0.0 release planned in early January next year.
-
-An incredible amount of effort by went into pybind11 over the last ~5 months,
-leading to a release that is jam-packed with exciting new features and numerous
-usability improvements. The following list links PRs or individual commits
-whenever applicable.
-
-Happy Christmas!
-
-* Support for binding C++ class hierarchies that make use of multiple
-  inheritance. `#410 <https://github.com/pybind/pybind11/pull/410>`_.
-
-* PyPy support: pybind11 now supports nightly builds of PyPy and will
-  interoperate with the future 5.7 release. No code changes are necessary,
-  everything "just" works as usual. Note that we only target the Python 2.7
-  branch for now; support for 3.x will be added once its ``cpyext`` extension
-  support catches up. A few minor features remain unsupported for the time
-  being (notably dynamic attributes in custom types).
-  `#527 <https://github.com/pybind/pybind11/pull/527>`_.
-
-* Significant work on the documentation -- in particular, the monolitic
-  ``advanced.rst`` file was restructured into a easier to read hierarchical
-  organization. `#448 <https://github.com/pybind/pybind11/pull/448>`_.
-
-* Many NumPy-related improvements:
-
-  1. Object-oriented API to access and modify NumPy ``ndarray`` instances,
-     replicating much of the corresponding NumPy C API functionality.
-     `#402 <https://github.com/pybind/pybind11/pull/402>`_.
-
-  2. NumPy array ``dtype`` array descriptors are now first-class citizens and
-     are exposed via a new class ``py::dtype``.
-
-  3. Structured dtypes can be registered using the ``PYBIND11_NUMPY_DTYPE()``
-     macro. Special ``array`` constructors accepting dtype objects were also
-     added.
-
-     One potential caveat involving this change: format descriptor strings
-     should now be accessed via ``format_descriptor::format()`` (however, for
-     compatibility purposes, the old syntax ``format_descriptor::value`` will
-     still work for non-structured data types). `#308
-     <https://github.com/pybind/pybind11/pull/308>`_.
-
-  4. Further improvements to support structured dtypes throughout the system.
-     `#472 <https://github.com/pybind/pybind11/pull/472>`_,
-     `#474 <https://github.com/pybind/pybind11/pull/474>`_,
-     `#459 <https://github.com/pybind/pybind11/pull/459>`_,
-     `#453 <https://github.com/pybind/pybind11/pull/453>`_,
-     `#452 <https://github.com/pybind/pybind11/pull/452>`_, and
-     `#505 <https://github.com/pybind/pybind11/pull/505>`_.
-
-  5. Fast access operators. `#497 <https://github.com/pybind/pybind11/pull/497>`_.
-
-  6. Constructors for arrays whose storage is owned by another object.
-     `#440 <https://github.com/pybind/pybind11/pull/440>`_.
-
-  7. Added constructors for ``array`` and ``array_t`` explicitly accepting shape
-     and strides; if strides are not provided, they are deduced assuming
-     C-contiguity. Also added simplified constructors for 1-dimensional case.
-
-  8. Added buffer/NumPy support for ``char[N]`` and ``std::array<char, N>`` types.
-
-  9. Added ``memoryview`` wrapper type which is constructible from ``buffer_info``.
-
-* Eigen: many additional conversions and support for non-contiguous
-  arrays/slices.
-  `#427 <https://github.com/pybind/pybind11/pull/427>`_,
-  `#315 <https://github.com/pybind/pybind11/pull/315>`_,
-  `#316 <https://github.com/pybind/pybind11/pull/316>`_,
-  `#312 <https://github.com/pybind/pybind11/pull/312>`_, and
-  `#267 <https://github.com/pybind/pybind11/pull/267>`_
-
-* Incompatible changes in ``class_<...>::class_()``:
-
-    1. Declarations of types that provide access via the buffer protocol must
-       now include the ``py::buffer_protocol()`` annotation as an argument to
-       the ``class_`` constructor.
-
-    2. Declarations of types that require a custom metaclass (i.e. all classes
-       which include static properties via commands such as
-       ``def_readwrite_static()``) must now include the ``py::metaclass()``
-       annotation as an argument to the ``class_`` constructor.
-
-       These two changes were necessary to make type definitions in pybind11
-       future-proof, and to support PyPy via its cpyext mechanism. `#527
-       <https://github.com/pybind/pybind11/pull/527>`_.
-
-
-    3. This version of pybind11 uses a redesigned mechnism for instantiating
-       trempoline classes that are used to override virtual methods from within
-       Python. This led to the following user-visible syntax change: instead of
-
-       .. code-block:: cpp
-
-           py::class_<TrampolineClass>("MyClass")
-             .alias<MyClass>()
-             ....
-
-       write
-
-       .. code-block:: cpp
-
-           py::class_<MyClass, TrampolineClass>("MyClass")
-             ....
-
-       Importantly, both the original and the trampoline class are now
-       specified as an arguments (in arbitrary order) to the ``py::class_``
-       template, and the ``alias<..>()`` call is gone. The new scheme has zero
-       overhead in cases when Python doesn't override any functions of the
-       underlying C++ class. `rev. 86d825
-       <https://github.com/pybind/pybind11/commit/86d825>`_.
-
-* Added ``eval`` and ``eval_file`` functions for evaluating expressions and
-  statements from a string or file. `rev. 0d3fc3
-  <https://github.com/pybind/pybind11/commit/0d3fc3>`_.
-
-* pybind11 can now create types with a modifiable dictionary.
-  `#437 <https://github.com/pybind/pybind11/pull/437>`_ and
-  `#444 <https://github.com/pybind/pybind11/pull/444>`_.
-
-* Support for translation of arbitrary C++ exceptions to Python counterparts.
-  `#296 <https://github.com/pybind/pybind11/pull/296>`_ and
-  `#273 <https://github.com/pybind/pybind11/pull/273>`_.
-
-* Report full backtraces through mixed C++/Python code, better reporting for
-  import errors, fixed GIL management in exception processing.
-  `#537 <https://github.com/pybind/pybind11/pull/537>`_,
-  `#494 <https://github.com/pybind/pybind11/pull/494>`_,
-  `rev. e72d95 <https://github.com/pybind/pybind11/commit/e72d95>`_, and
-  `rev. 099d6e <https://github.com/pybind/pybind11/commit/099d6e>`_.
-
-* Support for bit-level operations, comparisons, and serialization of C++
-  enumerations. `#503 <https://github.com/pybind/pybind11/pull/503>`_,
-  `#508 <https://github.com/pybind/pybind11/pull/508>`_,
-  `#380 <https://github.com/pybind/pybind11/pull/380>`_,
-  `#309 <https://github.com/pybind/pybind11/pull/309>`_.
-  `#311 <https://github.com/pybind/pybind11/pull/311>`_.
-
-* The ``class_`` constructor now accepts its template arguments in any order.
-  `#385 <https://github.com/pybind/pybind11/pull/385>`_.
-
-* Attribute and item accessors now have a more complete interface which makes
-  it possible to chain attributes as in
-  ``obj.attr("a")[key].attr("b").attr("method")(1, 2, 3)``. `#425
-  <https://github.com/pybind/pybind11/pull/425>`_.
-
-* Major redesign of the default and conversion constructors in ``pytypes.h``.
-  `#464 <https://github.com/pybind/pybind11/pull/464>`_.
-
-* Added built-in support for ``std::shared_ptr`` holder type. It is no longer
-  necessary to to include a declaration of the form
-  ``PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)`` (though continuing to
-  do so won't cause an error).
-  `#454 <https://github.com/pybind/pybind11/pull/454>`_.
-
-* New ``py::overload_cast`` casting operator to select among multiple possible
-  overloads of a function. An example:
-
-    .. code-block:: cpp
-
-        py::class_<Pet>(m, "Pet")
-            .def("set", py::overload_cast<int>(&Pet::set), "Set the pet's age")
-            .def("set", py::overload_cast<const std::string &>(&Pet::set), "Set the pet's name");
-
-  This feature only works on C++14-capable compilers.
-  `#541 <https://github.com/pybind/pybind11/pull/541>`_.
-
-* C++ types are automatically cast to Python types, e.g. when assigning
-  them as an attribute. For instance, the following is now legal:
-
-    .. code-block:: cpp
-
-        py::module m = /* ... */
-        m.attr("constant") = 123;
-
-  (Previously, a ``py::cast`` call was necessary to avoid a compilation error.)
-  `#551 <https://github.com/pybind/pybind11/pull/551>`_.
-
-* Redesigned ``pytest``-based test suite. `#321 <https://github.com/pybind/pybind11/pull/321>`_.
-
-* Instance tracking to detect reference leaks in test suite. `#324 <https://github.com/pybind/pybind11/pull/324>`_
-
-* pybind11 can now distinguish between multiple different instances that are
-  located at the same memory address, but which have different types.
-  `#329 <https://github.com/pybind/pybind11/pull/329>`_.
-
-* Improved logic in ``move`` return value policy.
-  `#510 <https://github.com/pybind/pybind11/pull/510>`_,
-  `#297 <https://github.com/pybind/pybind11/pull/297>`_.
-
-* Generalized unpacking API to permit calling Python functions from C++ using
-  notation such as ``foo(a1, a2, *args, "ka"_a=1, "kb"_a=2, **kwargs)``. `#372 <https://github.com/pybind/pybind11/pull/372>`_.
-
-* ``py::print()`` function whose behavior matches that of the native Python
-  ``print()`` function. `#372 <https://github.com/pybind/pybind11/pull/372>`_.
-
-* Added ``py::dict`` keyword constructor:``auto d = dict("number"_a=42,
-  "name"_a="World");``. `#372 <https://github.com/pybind/pybind11/pull/372>`_.
-
-* Added ``py::str::format()`` method and ``_s`` literal: ``py::str s = "1 + 2
-  = {}"_s.format(3);``. `#372 <https://github.com/pybind/pybind11/pull/372>`_.
-
-* Added ``py::repr()`` function which is equivalent to Python's builtin
-  ``repr()``. `#333 <https://github.com/pybind/pybind11/pull/333>`_.
-
-* Improved construction and destruction logic for holder types. It is now
-  possible to reference instances with smart pointer holder types without
-  constructing the holder if desired. The ``PYBIND11_DECLARE_HOLDER_TYPE``
-  macro now accepts an optional second parameter to indicate whether the holder
-  type uses intrusive reference counting.
-  `#533 <https://github.com/pybind/pybind11/pull/533>`_ and
-  `#561 <https://github.com/pybind/pybind11/pull/561>`_.
-
-* Mapping a stateless C++ function to Python and back is now "for free" (i.e.
-  no extra indirections or argument conversion overheads). `rev. 954b79
-  <https://github.com/pybind/pybind11/commit/954b79>`_.
-
-* Bindings for ``std::valarray<T>``.
-  `#545 <https://github.com/pybind/pybind11/pull/545>`_.
-
-* Improved support for C++17 capable compilers.
-  `#562 <https://github.com/pybind/pybind11/pull/562>`_.
-
-* Bindings for ``std::optional<t>``.
-  `#475 <https://github.com/pybind/pybind11/pull/475>`_,
-  `#476 <https://github.com/pybind/pybind11/pull/476>`_,
-  `#479 <https://github.com/pybind/pybind11/pull/479>`_,
-  `#499 <https://github.com/pybind/pybind11/pull/499>`_, and
-  `#501 <https://github.com/pybind/pybind11/pull/501>`_.
-
-* ``stl_bind.h``: general improvements and support for ``std::map`` and
-  ``std::unordered_map``.
-  `#490 <https://github.com/pybind/pybind11/pull/490>`_,
-  `#282 <https://github.com/pybind/pybind11/pull/282>`_,
-  `#235 <https://github.com/pybind/pybind11/pull/235>`_.
-
-* The ``std::tuple``, ``std::pair``, ``std::list``, and ``std::vector`` type
-  casters now accept any Python sequence type as input. `rev. 107285
-  <https://github.com/pybind/pybind11/commit/107285>`_.
-
-* Improved CMake Python detection on multi-architecture Linux.
-  `#532 <https://github.com/pybind/pybind11/pull/532>`_.
-
-* Infrastructure to selectively disable or enable parts of the automatically
-  generated docstrings. `#486 <https://github.com/pybind/pybind11/pull/486>`_.
-
-* ``reference`` and ``reference_internal`` are now the default return value
-  properties for static and non-static properties, respectively. `#473
-  <https://github.com/pybind/pybind11/pull/473>`_. (the previous defaults
-  were ``automatic``). `#473 <https://github.com/pybind/pybind11/pull/473>`_.
-
-* Support for ``std::unique_ptr`` with non-default deleters or no deleter at
-  all (``py::nodelete``). `#384 <https://github.com/pybind/pybind11/pull/384>`_.
-
-* Deprecated ``handle::call()`` method. The new syntax to call Python
-  functions is simply ``handle()``. It can also be invoked explicitly via
-  ``handle::operator<X>()``, where ``X`` is an optional return value policy.
-
-* Print more informative error messages when ``make_tuple()`` or ``cast()``
-  fail. `#262 <https://github.com/pybind/pybind11/pull/262>`_.
-
-* Creation of holder types for classes deriving from
-  ``std::enable_shared_from_this<>`` now also works for ``const`` values.
-  `#260 <https://github.com/pybind/pybind11/pull/260>`_.
-
-* ``make_iterator()`` improvements for better compatibility with various
-  types (now uses prefix increment operator); it now also accepts iterators
-  with different begin/end types as long as they are equality comparable.
-  `#247 <https://github.com/pybind/pybind11/pull/247>`_.
-
-* ``arg()`` now accepts a wider range of argument types for default values.
-  `#244 <https://github.com/pybind/pybind11/pull/244>`_.
-
-* Support ``keep_alive`` where the nurse object may be ``None``. `#341
-  <https://github.com/pybind/pybind11/pull/341>`_.
-
-* Added constructors for ``str`` and ``bytes`` from zero-terminated char
-  pointers, and from char pointers and length. Added constructors for ``str``
-  from ``bytes`` and for ``bytes`` from ``str``, which will perform UTF-8
-  decoding/encoding as required.
-
-* Many other improvements of library internals without user-visible changes
-
-
-1.8.1 (July 12, 2016)
-----------------------
-* Fixed a rare but potentially very severe issue when the garbage collector ran
-  during pybind11 type creation.
-
-1.8.0 (June 14, 2016)
-----------------------
-* Redesigned CMake build system which exports a convenient
-  ``pybind11_add_module`` function to parent projects.
-* ``std::vector<>`` type bindings analogous to Boost.Python's ``indexing_suite``
-* Transparent conversion of sparse and dense Eigen matrices and vectors (``eigen.h``)
-* Added an ``ExtraFlags`` template argument to the NumPy ``array_t<>`` wrapper
-  to disable an enforced cast that may lose precision, e.g. to create overloads
-  for different precisions and complex vs real-valued matrices.
-* Prevent implicit conversion of floating point values to integral types in
-  function arguments
-* Fixed incorrect default return value policy for functions returning a shared
-  pointer
-* Don't allow registering a type via ``class_`` twice
-* Don't allow casting a ``None`` value into a C++ lvalue reference
-* Fixed a crash in ``enum_::operator==`` that was triggered by the ``help()`` command
-* Improved detection of whether or not custom C++ types can be copy/move-constructed
-* Extended ``str`` type to also work with ``bytes`` instances
-* Added a ``"name"_a`` user defined string literal that is equivalent to ``py::arg("name")``.
-* When specifying function arguments via ``py::arg``, the test that verifies
-  the number of arguments now runs at compile time.
-* Added ``[[noreturn]]`` attribute to ``pybind11_fail()`` to quench some
-  compiler warnings
-* List function arguments in exception text when the dispatch code cannot find
-  a matching overload
-* Added ``PYBIND11_OVERLOAD_NAME`` and ``PYBIND11_OVERLOAD_PURE_NAME`` macros which
-  can be used to override virtual methods whose name differs in C++ and Python
-  (e.g. ``__call__`` and ``operator()``)
-* Various minor ``iterator`` and ``make_iterator()`` improvements
-* Transparently support ``__bool__`` on Python 2.x and Python 3.x
-* Fixed issue with destructor of unpickled object not being called
-* Minor CMake build system improvements on Windows
-* New ``pybind11::args`` and ``pybind11::kwargs`` types to create functions which
-  take an arbitrary number of arguments and keyword arguments
-* New syntax to call a Python function from C++ using ``*args`` and ``*kwargs``
-* The functions ``def_property_*`` now correctly process docstring arguments (these
-  formerly caused a segmentation fault)
-* Many ``mkdoc.py`` improvements (enumerations, template arguments, ``DOC()``
-  macro accepts more arguments)
-* Cygwin support
-* Documentation improvements (pickling support, ``keep_alive``, macro usage)
-
-1.7 (April 30, 2016)
-----------------------
-* Added a new ``move`` return value policy that triggers C++11 move semantics.
-  The automatic return value policy falls back to this case whenever a rvalue
-  reference is encountered
-* Significantly more general GIL state routines that are used instead of
-  Python's troublesome ``PyGILState_Ensure`` and ``PyGILState_Release`` API
-* Redesign of opaque types that drastically simplifies their usage
-* Extended ability to pass values of type ``[const] void *``
-* ``keep_alive`` fix: don't fail when there is no patient
-* ``functional.h``: acquire the GIL before calling a Python function
-* Added Python RAII type wrappers ``none`` and ``iterable``
-* Added ``*args`` and ``*kwargs`` pass-through parameters to
-  ``pybind11.get_include()`` function
-* Iterator improvements and fixes
-* Documentation on return value policies and opaque types improved
-
-1.6 (April 30, 2016)
-----------------------
-* Skipped due to upload to PyPI gone wrong and inability to recover
-  (https://github.com/pypa/packaging-problems/issues/74)
-
-1.5 (April 21, 2016)
-----------------------
-* For polymorphic types, use RTTI to try to return the closest type registered with pybind11
-* Pickling support for serializing and unserializing C++ instances to a byte stream in Python
-* Added a convenience routine ``make_iterator()`` which turns a range indicated
-  by a pair of C++ iterators into a iterable Python object
-* Added ``len()`` and a variadic ``make_tuple()`` function
-* Addressed a rare issue that could confuse the current virtual function
-  dispatcher and another that could lead to crashes in multi-threaded
-  applications
-* Added a ``get_include()`` function to the Python module that returns the path
-  of the directory containing the installed pybind11 header files
-* Documentation improvements: import issues, symbol visibility, pickling, limitations
-* Added casting support for ``std::reference_wrapper<>``
-
-1.4 (April 7, 2016)
---------------------------
-* Transparent type conversion for ``std::wstring`` and ``wchar_t``
-* Allow passing ``nullptr``-valued strings
-* Transparent passing of ``void *`` pointers using capsules
-* Transparent support for returning values wrapped in ``std::unique_ptr<>``
-* Improved docstring generation for compatibility with Sphinx
-* Nicer debug error message when default parameter construction fails
-* Support for "opaque" types that bypass the transparent conversion layer for STL containers
-* Redesigned type casting interface to avoid ambiguities that could occasionally cause compiler errors
-* Redesigned property implementation; fixes crashes due to an unfortunate default return value policy
-* Anaconda package generation support
-
-1.3 (March 8, 2016)
---------------------------
-
-* Added support for the Intel C++ compiler (v15+)
-* Added support for the STL unordered set/map data structures
-* Added support for the STL linked list data structure
-* NumPy-style broadcasting support in ``pybind11::vectorize``
-* pybind11 now displays more verbose error messages when ``arg::operator=()`` fails
-* pybind11 internal data structures now live in a version-dependent namespace to avoid ABI issues
-* Many, many bugfixes involving corner cases and advanced usage
-
-1.2 (February 7, 2016)
---------------------------
-
-* Optional: efficient generation of function signatures at compile time using C++14
-* Switched to a simpler and more general way of dealing with function default
-  arguments. Unused keyword arguments in function calls are now detected and
-  cause errors as expected
-* New ``keep_alive`` call policy analogous to Boost.Python's ``with_custodian_and_ward``
-* New ``pybind11::base<>`` attribute to indicate a subclass relationship
-* Improved interface for RAII type wrappers in ``pytypes.h``
-* Use RAII type wrappers consistently within pybind11 itself. This
-  fixes various potential refcount leaks when exceptions occur
-* Added new ``bytes`` RAII type wrapper (maps to ``string`` in Python 2.7)
-* Made handle and related RAII classes const correct, using them more
-  consistently everywhere now
-* Got rid of the ugly ``__pybind11__`` attributes on the Python side---they are
-  now stored in a C++ hash table that is not visible in Python
-* Fixed refcount leaks involving NumPy arrays and bound functions
-* Vastly improved handling of shared/smart pointers
-* Removed an unnecessary copy operation in ``pybind11::vectorize``
-* Fixed naming clashes when both pybind11 and NumPy headers are included
-* Added conversions for additional exception types
-* Documentation improvements (using multiple extension modules, smart pointers,
-  other minor clarifications)
-* unified infrastructure for parsing variadic arguments in ``class_`` and cpp_function
-* Fixed license text (was: ZLIB, should have been: 3-clause BSD)
-* Python 3.2 compatibility
-* Fixed remaining issues when accessing types in another plugin module
-* Added enum comparison and casting methods
-* Improved SFINAE-based detection of whether types are copy-constructible
-* Eliminated many warnings about unused variables and the use of ``offsetof()``
-* Support for ``std::array<>`` conversions
-
-1.1 (December 7, 2015)
---------------------------
-
-* Documentation improvements (GIL, wrapping functions, casting, fixed many typos)
-* Generalized conversion of integer types
-* Improved support for casting function objects
-* Improved support for ``std::shared_ptr<>`` conversions
-* Initial support for ``std::set<>`` conversions
-* Fixed type resolution issue for types defined in a separate plugin module
-* Cmake build system improvements
-* Factored out generic functionality to non-templated code (smaller code size)
-* Added a code size / compile time benchmark vs Boost.Python
-* Added an appveyor CI script
-
-1.0 (October 15, 2015)
-------------------------
-* Initial release
diff --git a/tmap/lib/pybind11/docs/classes.rst b/tmap/lib/pybind11/docs/classes.rst
deleted file mode 100644
index ca2477e..0000000
--- a/tmap/lib/pybind11/docs/classes.rst
+++ /dev/null
@@ -1,500 +0,0 @@
-.. _classes:
-
-Object-oriented code
-####################
-
-Creating bindings for a custom type
-===================================
-
-Let's now look at a more complex example where we'll create bindings for a
-custom C++ data structure named ``Pet``. Its definition is given below:
-
-.. code-block:: cpp
-
-    struct Pet {
-        Pet(const std::string &name) : name(name) { }
-        void setName(const std::string &name_) { name = name_; }
-        const std::string &getName() const { return name; }
-
-        std::string name;
-    };
-
-The binding code for ``Pet`` looks as follows:
-
-.. code-block:: cpp
-
-    #include <pybind11/pybind11.h>
-
-    namespace py = pybind11;
-
-    PYBIND11_MODULE(example, m) {
-        py::class_<Pet>(m, "Pet")
-            .def(py::init<const std::string &>())
-            .def("setName", &Pet::setName)
-            .def("getName", &Pet::getName);
-    }
-
-:class:`class_` creates bindings for a C++ *class* or *struct*-style data
-structure. :func:`init` is a convenience function that takes the types of a
-constructor's parameters as template arguments and wraps the corresponding
-constructor (see the :ref:`custom_constructors` section for details). An
-interactive Python session demonstrating this example is shown below:
-
-.. code-block:: pycon
-
-    % python
-    >>> import example
-    >>> p = example.Pet('Molly')
-    >>> print(p)
-    <example.Pet object at 0x10cd98060>
-    >>> p.getName()
-    u'Molly'
-    >>> p.setName('Charly')
-    >>> p.getName()
-    u'Charly'
-
-.. seealso::
-
-    Static member functions can be bound in the same way using
-    :func:`class_::def_static`.
-
-Keyword and default arguments
-=============================
-It is possible to specify keyword and default arguments using the syntax
-discussed in the previous chapter. Refer to the sections :ref:`keyword_args`
-and :ref:`default_args` for details.
-
-Binding lambda functions
-========================
-
-Note how ``print(p)`` produced a rather useless summary of our data structure in the example above:
-
-.. code-block:: pycon
-
-    >>> print(p)
-    <example.Pet object at 0x10cd98060>
-
-To address this, we could bind an utility function that returns a human-readable
-summary to the special method slot named ``__repr__``. Unfortunately, there is no
-suitable functionality in the ``Pet`` data structure, and it would be nice if
-we did not have to change it. This can easily be accomplished by binding a
-Lambda function instead:
-
-.. code-block:: cpp
-
-        py::class_<Pet>(m, "Pet")
-            .def(py::init<const std::string &>())
-            .def("setName", &Pet::setName)
-            .def("getName", &Pet::getName)
-            .def("__repr__",
-                [](const Pet &a) {
-                    return "<example.Pet named '" + a.name + "'>";
-                }
-            );
-
-Both stateless [#f1]_ and stateful lambda closures are supported by pybind11.
-With the above change, the same Python code now produces the following output:
-
-.. code-block:: pycon
-
-    >>> print(p)
-    <example.Pet named 'Molly'>
-
-.. [#f1] Stateless closures are those with an empty pair of brackets ``[]`` as the capture object.
-
-.. _properties:
-
-Instance and static fields
-==========================
-
-We can also directly expose the ``name`` field using the
-:func:`class_::def_readwrite` method. A similar :func:`class_::def_readonly`
-method also exists for ``const`` fields.
-
-.. code-block:: cpp
-
-        py::class_<Pet>(m, "Pet")
-            .def(py::init<const std::string &>())
-            .def_readwrite("name", &Pet::name)
-            // ... remainder ...
-
-This makes it possible to write
-
-.. code-block:: pycon
-
-    >>> p = example.Pet('Molly')
-    >>> p.name
-    u'Molly'
-    >>> p.name = 'Charly'
-    >>> p.name
-    u'Charly'
-
-Now suppose that ``Pet::name`` was a private internal variable
-that can only be accessed via setters and getters.
-
-.. code-block:: cpp
-
-    class Pet {
-    public:
-        Pet(const std::string &name) : name(name) { }
-        void setName(const std::string &name_) { name = name_; }
-        const std::string &getName() const { return name; }
-    private:
-        std::string name;
-    };
-
-In this case, the method :func:`class_::def_property`
-(:func:`class_::def_property_readonly` for read-only data) can be used to
-provide a field-like interface within Python that will transparently call
-the setter and getter functions:
-
-.. code-block:: cpp
-
-        py::class_<Pet>(m, "Pet")
-            .def(py::init<const std::string &>())
-            .def_property("name", &Pet::getName, &Pet::setName)
-            // ... remainder ...
-
-.. seealso::
-
-    Similar functions :func:`class_::def_readwrite_static`,
-    :func:`class_::def_readonly_static` :func:`class_::def_property_static`,
-    and :func:`class_::def_property_readonly_static` are provided for binding
-    static variables and properties. Please also see the section on
-    :ref:`static_properties` in the advanced part of the documentation.
-
-Dynamic attributes
-==================
-
-Native Python classes can pick up new attributes dynamically:
-
-.. code-block:: pycon
-
-    >>> class Pet:
-    ...     name = 'Molly'
-    ...
-    >>> p = Pet()
-    >>> p.name = 'Charly'  # overwrite existing
-    >>> p.age = 2  # dynamically add a new attribute
-
-By default, classes exported from C++ do not support this and the only writable
-attributes are the ones explicitly defined using :func:`class_::def_readwrite`
-or :func:`class_::def_property`.
-
-.. code-block:: cpp
-
-    py::class_<Pet>(m, "Pet")
-        .def(py::init<>())
-        .def_readwrite("name", &Pet::name);
-
-Trying to set any other attribute results in an error:
-
-.. code-block:: pycon
-
-    >>> p = example.Pet()
-    >>> p.name = 'Charly'  # OK, attribute defined in C++
-    >>> p.age = 2  # fail
-    AttributeError: 'Pet' object has no attribute 'age'
-
-To enable dynamic attributes for C++ classes, the :class:`py::dynamic_attr` tag
-must be added to the :class:`py::class_` constructor:
-
-.. code-block:: cpp
-
-    py::class_<Pet>(m, "Pet", py::dynamic_attr())
-        .def(py::init<>())
-        .def_readwrite("name", &Pet::name);
-
-Now everything works as expected:
-
-.. code-block:: pycon
-
-    >>> p = example.Pet()
-    >>> p.name = 'Charly'  # OK, overwrite value in C++
-    >>> p.age = 2  # OK, dynamically add a new attribute
-    >>> p.__dict__  # just like a native Python class
-    {'age': 2}
-
-Note that there is a small runtime cost for a class with dynamic attributes.
-Not only because of the addition of a ``__dict__``, but also because of more
-expensive garbage collection tracking which must be activated to resolve
-possible circular references. Native Python classes incur this same cost by
-default, so this is not anything to worry about. By default, pybind11 classes
-are more efficient than native Python classes. Enabling dynamic attributes
-just brings them on par.
-
-.. _inheritance:
-
-Inheritance and automatic upcasting
-===================================
-
-Suppose now that the example consists of two data structures with an
-inheritance relationship:
-
-.. code-block:: cpp
-
-    struct Pet {
-        Pet(const std::string &name) : name(name) { }
-        std::string name;
-    };
-
-    struct Dog : Pet {
-        Dog(const std::string &name) : Pet(name) { }
-        std::string bark() const { return "woof!"; }
-    };
-
-There are two different ways of indicating a hierarchical relationship to
-pybind11: the first specifies the C++ base class as an extra template
-parameter of the :class:`class_`:
-
-.. code-block:: cpp
-
-    py::class_<Pet>(m, "Pet")
-       .def(py::init<const std::string &>())
-       .def_readwrite("name", &Pet::name);
-
-    // Method 1: template parameter:
-    py::class_<Dog, Pet /* <- specify C++ parent type */>(m, "Dog")
-        .def(py::init<const std::string &>())
-        .def("bark", &Dog::bark);
-
-Alternatively, we can also assign a name to the previously bound ``Pet``
-:class:`class_` object and reference it when binding the ``Dog`` class:
-
-.. code-block:: cpp
-
-    py::class_<Pet> pet(m, "Pet");
-    pet.def(py::init<const std::string &>())
-       .def_readwrite("name", &Pet::name);
-
-    // Method 2: pass parent class_ object:
-    py::class_<Dog>(m, "Dog", pet /* <- specify Python parent type */)
-        .def(py::init<const std::string &>())
-        .def("bark", &Dog::bark);
-
-Functionality-wise, both approaches are equivalent. Afterwards, instances will
-expose fields and methods of both types:
-
-.. code-block:: pycon
-
-    >>> p = example.Dog('Molly')
-    >>> p.name
-    u'Molly'
-    >>> p.bark()
-    u'woof!'
-
-The C++ classes defined above are regular non-polymorphic types with an
-inheritance relationship. This is reflected in Python:
-
-.. code-block:: cpp
-
-    // Return a base pointer to a derived instance
-    m.def("pet_store", []() { return std::unique_ptr<Pet>(new Dog("Molly")); });
-
-.. code-block:: pycon
-
-    >>> p = example.pet_store()
-    >>> type(p)  # `Dog` instance behind `Pet` pointer
-    Pet          # no pointer upcasting for regular non-polymorphic types
-    >>> p.bark()
-    AttributeError: 'Pet' object has no attribute 'bark'
-
-The function returned a ``Dog`` instance, but because it's a non-polymorphic
-type behind a base pointer, Python only sees a ``Pet``. In C++, a type is only
-considered polymorphic if it has at least one virtual function and pybind11
-will automatically recognize this:
-
-.. code-block:: cpp
-
-    struct PolymorphicPet {
-        virtual ~PolymorphicPet() = default;
-    };
-
-    struct PolymorphicDog : PolymorphicPet {
-        std::string bark() const { return "woof!"; }
-    };
-
-    // Same binding code
-    py::class_<PolymorphicPet>(m, "PolymorphicPet");
-    py::class_<PolymorphicDog, PolymorphicPet>(m, "PolymorphicDog")
-        .def(py::init<>())
-        .def("bark", &PolymorphicDog::bark);
-
-    // Again, return a base pointer to a derived instance
-    m.def("pet_store2", []() { return std::unique_ptr<PolymorphicPet>(new PolymorphicDog); });
-
-.. code-block:: pycon
-
-    >>> p = example.pet_store2()
-    >>> type(p)
-    PolymorphicDog  # automatically upcast
-    >>> p.bark()
-    u'woof!'
-
-Given a pointer to a polymorphic base, pybind11 performs automatic upcasting
-to the actual derived type. Note that this goes beyond the usual situation in
-C++: we don't just get access to the virtual functions of the base, we get the
-concrete derived type including functions and attributes that the base type may
-not even be aware of.
-
-.. seealso::
-
-    For more information about polymorphic behavior see :ref:`overriding_virtuals`.
-
-
-Overloaded methods
-==================
-
-Sometimes there are several overloaded C++ methods with the same name taking
-different kinds of input arguments:
-
-.. code-block:: cpp
-
-    struct Pet {
-        Pet(const std::string &name, int age) : name(name), age(age) { }
-
-        void set(int age_) { age = age_; }
-        void set(const std::string &name_) { name = name_; }
-
-        std::string name;
-        int age;
-    };
-
-Attempting to bind ``Pet::set`` will cause an error since the compiler does not
-know which method the user intended to select. We can disambiguate by casting
-them to function pointers. Binding multiple functions to the same Python name
-automatically creates a chain of function overloads that will be tried in
-sequence.
-
-.. code-block:: cpp
-
-    py::class_<Pet>(m, "Pet")
-       .def(py::init<const std::string &, int>())
-       .def("set", (void (Pet::*)(int)) &Pet::set, "Set the pet's age")
-       .def("set", (void (Pet::*)(const std::string &)) &Pet::set, "Set the pet's name");
-
-The overload signatures are also visible in the method's docstring:
-
-.. code-block:: pycon
-
-    >>> help(example.Pet)
-
-    class Pet(__builtin__.object)
-     |  Methods defined here:
-     |
-     |  __init__(...)
-     |      Signature : (Pet, str, int) -> NoneType
-     |
-     |  set(...)
-     |      1. Signature : (Pet, int) -> NoneType
-     |
-     |      Set the pet's age
-     |
-     |      2. Signature : (Pet, str) -> NoneType
-     |
-     |      Set the pet's name
-
-If you have a C++14 compatible compiler [#cpp14]_, you can use an alternative
-syntax to cast the overloaded function:
-
-.. code-block:: cpp
-
-    py::class_<Pet>(m, "Pet")
-        .def("set", py::overload_cast<int>(&Pet::set), "Set the pet's age")
-        .def("set", py::overload_cast<const std::string &>(&Pet::set), "Set the pet's name");
-
-Here, ``py::overload_cast`` only requires the parameter types to be specified.
-The return type and class are deduced. This avoids the additional noise of
-``void (Pet::*)()`` as seen in the raw cast. If a function is overloaded based
-on constness, the ``py::const_`` tag should be used:
-
-.. code-block:: cpp
-
-    struct Widget {
-        int foo(int x, float y);
-        int foo(int x, float y) const;
-    };
-
-    py::class_<Widget>(m, "Widget")
-       .def("foo_mutable", py::overload_cast<int, float>(&Widget::foo))
-       .def("foo_const",   py::overload_cast<int, float>(&Widget::foo, py::const_));
-
-
-.. [#cpp14] A compiler which supports the ``-std=c++14`` flag
-            or Visual Studio 2015 Update 2 and newer.
-
-.. note::
-
-    To define multiple overloaded constructors, simply declare one after the
-    other using the ``.def(py::init<...>())`` syntax. The existing machinery
-    for specifying keyword and default arguments also works.
-
-Enumerations and internal types
-===============================
-
-Let's now suppose that the example class contains an internal enumeration type,
-e.g.:
-
-.. code-block:: cpp
-
-    struct Pet {
-        enum Kind {
-            Dog = 0,
-            Cat
-        };
-
-        Pet(const std::string &name, Kind type) : name(name), type(type) { }
-
-        std::string name;
-        Kind type;
-    };
-
-The binding code for this example looks as follows:
-
-.. code-block:: cpp
-
-    py::class_<Pet> pet(m, "Pet");
-
-    pet.def(py::init<const std::string &, Pet::Kind>())
-        .def_readwrite("name", &Pet::name)
-        .def_readwrite("type", &Pet::type);
-
-    py::enum_<Pet::Kind>(pet, "Kind")
-        .value("Dog", Pet::Kind::Dog)
-        .value("Cat", Pet::Kind::Cat)
-        .export_values();
-
-To ensure that the ``Kind`` type is created within the scope of ``Pet``, the
-``pet`` :class:`class_` instance must be supplied to the :class:`enum_`.
-constructor. The :func:`enum_::export_values` function exports the enum entries
-into the parent scope, which should be skipped for newer C++11-style strongly
-typed enums.
-
-.. code-block:: pycon
-
-    >>> p = Pet('Lucy', Pet.Cat)
-    >>> p.type
-    Kind.Cat
-    >>> int(p.type)
-    1L
-
-The entries defined by the enumeration type are exposed in the ``__members__`` property:
-
-.. code-block:: pycon
-
-    >>> Pet.Kind.__members__
-    {'Dog': Kind.Dog, 'Cat': Kind.Cat}
-
-.. note::
-
-    When the special tag ``py::arithmetic()`` is specified to the ``enum_``
-    constructor, pybind11 creates an enumeration that also supports rudimentary
-    arithmetic and bit-level operations like comparisons, and, or, xor, negation,
-    etc.
-
-    .. code-block:: cpp
-
-        py::enum_<Pet::Kind>(pet, "Kind", py::arithmetic())
-           ...
-
-    By default, these are omitted to conserve space.
diff --git a/tmap/lib/pybind11/docs/compiling.rst b/tmap/lib/pybind11/docs/compiling.rst
deleted file mode 100644
index b5d6ce9..0000000
--- a/tmap/lib/pybind11/docs/compiling.rst
+++ /dev/null
@@ -1,273 +0,0 @@
-.. _compiling:
-
-Build systems
-#############
-
-Building with setuptools
-========================
-
-For projects on PyPI, building with setuptools is the way to go. Sylvain Corlay
-has kindly provided an example project which shows how to set up everything,
-including automatic generation of documentation using Sphinx. Please refer to
-the [python_example]_ repository.
-
-.. [python_example] https://github.com/pybind/python_example
-
-Building with cppimport
-========================
-
-[cppimport]_ is a small Python import hook that determines whether there is a C++
-source file whose name matches the requested module. If there is, the file is
-compiled as a Python extension using pybind11 and placed in the same folder as
-the C++ source file. Python is then able to find the module and load it.
-
-.. [cppimport] https://github.com/tbenthompson/cppimport
-
-.. _cmake:
-
-Building with CMake
-===================
-
-For C++ codebases that have an existing CMake-based build system, a Python
-extension module can be created with just a few lines of code:
-
-.. code-block:: cmake
-
-    cmake_minimum_required(VERSION 2.8.12)
-    project(example)
-
-    add_subdirectory(pybind11)
-    pybind11_add_module(example example.cpp)
-
-This assumes that the pybind11 repository is located in a subdirectory named
-:file:`pybind11` and that the code is located in a file named :file:`example.cpp`.
-The CMake command ``add_subdirectory`` will import the pybind11 project which
-provides the ``pybind11_add_module`` function. It will take care of all the
-details needed to build a Python extension module on any platform.
-
-A working sample project, including a way to invoke CMake from :file:`setup.py` for
-PyPI integration, can be found in the [cmake_example]_  repository.
-
-.. [cmake_example] https://github.com/pybind/cmake_example
-
-pybind11_add_module
--------------------
-
-To ease the creation of Python extension modules, pybind11 provides a CMake
-function with the following signature:
-
-.. code-block:: cmake
-
-    pybind11_add_module(<name> [MODULE | SHARED] [EXCLUDE_FROM_ALL]
-                        [NO_EXTRAS] [THIN_LTO] source1 [source2 ...])
-
-This function behaves very much like CMake's builtin ``add_library`` (in fact,
-it's a wrapper function around that command). It will add a library target
-called ``<name>`` to be built from the listed source files. In addition, it
-will take care of all the Python-specific compiler and linker flags as well
-as the OS- and Python-version-specific file extension. The produced target
-``<name>`` can be further manipulated with regular CMake commands.
-
-``MODULE`` or ``SHARED`` may be given to specify the type of library. If no
-type is given, ``MODULE`` is used by default which ensures the creation of a
-Python-exclusive module. Specifying ``SHARED`` will create a more traditional
-dynamic library which can also be linked from elsewhere. ``EXCLUDE_FROM_ALL``
-removes this target from the default build (see CMake docs for details).
-
-Since pybind11 is a template library, ``pybind11_add_module`` adds compiler
-flags to ensure high quality code generation without bloat arising from long
-symbol names and duplication of code in different translation units. It
-sets default visibility to *hidden*, which is required for some pybind11
-features and functionality when attempting to load multiple pybind11 modules
-compiled under different pybind11 versions.  It also adds additional flags
-enabling LTO (Link Time Optimization) and strip unneeded symbols. See the
-:ref:`FAQ entry <faq:symhidden>` for a more detailed explanation. These
-latter optimizations are never applied in ``Debug`` mode.  If ``NO_EXTRAS`` is
-given, they will always be disabled, even in ``Release`` mode. However, this
-will result in code bloat and is generally not recommended.
-
-As stated above, LTO is enabled by default. Some newer compilers also support
-different flavors of LTO such as `ThinLTO`_. Setting ``THIN_LTO`` will cause
-the function to prefer this flavor if available. The function falls back to
-regular LTO if ``-flto=thin`` is not available.
-
-.. _ThinLTO: http://clang.llvm.org/docs/ThinLTO.html
-
-Configuration variables
------------------------
-
-By default, pybind11 will compile modules with the C++14 standard, if available
-on the target compiler, falling back to C++11 if C++14 support is not
-available.  Note, however, that this default is subject to change: future
-pybind11 releases are expected to migrate to newer C++ standards as they become
-available.  To override this, the standard flag can be given explicitly in
-``PYBIND11_CPP_STANDARD``:
-
-.. code-block:: cmake
-
-    # Use just one of these:
-    # GCC/clang:
-    set(PYBIND11_CPP_STANDARD -std=c++11)
-    set(PYBIND11_CPP_STANDARD -std=c++14)
-    set(PYBIND11_CPP_STANDARD -std=c++1z) # Experimental C++17 support
-    # MSVC:
-    set(PYBIND11_CPP_STANDARD /std:c++14)
-    set(PYBIND11_CPP_STANDARD /std:c++latest) # Enables some MSVC C++17 features
-
-    add_subdirectory(pybind11)  # or find_package(pybind11)
-
-Note that this and all other configuration variables must be set **before** the
-call to ``add_subdirectory`` or ``find_package``. The variables can also be set
-when calling CMake from the command line using the ``-D<variable>=<value>`` flag.
-
-The target Python version can be selected by setting ``PYBIND11_PYTHON_VERSION``
-or an exact Python installation can be specified with ``PYTHON_EXECUTABLE``.
-For example:
-
-.. code-block:: bash
-
-    cmake -DPYBIND11_PYTHON_VERSION=3.6 ..
-    # or
-    cmake -DPYTHON_EXECUTABLE=path/to/python ..
-
-find_package vs. add_subdirectory
----------------------------------
-
-For CMake-based projects that don't include the pybind11 repository internally,
-an external installation can be detected through ``find_package(pybind11)``.
-See the `Config file`_ docstring for details of relevant CMake variables.
-
-.. code-block:: cmake
-
-    cmake_minimum_required(VERSION 2.8.12)
-    project(example)
-
-    find_package(pybind11 REQUIRED)
-    pybind11_add_module(example example.cpp)
-
-Once detected, the aforementioned ``pybind11_add_module`` can be employed as
-before. The function usage and configuration variables are identical no matter
-if pybind11 is added as a subdirectory or found as an installed package. You
-can refer to the same [cmake_example]_ repository for a full sample project
--- just swap out ``add_subdirectory`` for ``find_package``.
-
-.. _Config file: https://github.com/pybind/pybind11/blob/master/tools/pybind11Config.cmake.in
-
-Advanced: interface library target
-----------------------------------
-
-When using a version of CMake greater than 3.0, pybind11 can additionally
-be used as a special *interface library* . The target ``pybind11::module``
-is available with pybind11 headers, Python headers and libraries as needed,
-and C++ compile definitions attached. This target is suitable for linking
-to an independently constructed (through ``add_library``, not
-``pybind11_add_module``) target in the consuming project.
-
-.. code-block:: cmake
-
-    cmake_minimum_required(VERSION 3.0)
-    project(example)
-
-    find_package(pybind11 REQUIRED)  # or add_subdirectory(pybind11)
-
-    add_library(example MODULE main.cpp)
-    target_link_libraries(example PRIVATE pybind11::module)
-    set_target_properties(example PROPERTIES PREFIX "${PYTHON_MODULE_PREFIX}"
-                                             SUFFIX "${PYTHON_MODULE_EXTENSION}")
-
-.. warning::
-
-    Since pybind11 is a metatemplate library, it is crucial that certain
-    compiler flags are provided to ensure high quality code generation. In
-    contrast to the ``pybind11_add_module()`` command, the CMake interface
-    library only provides the *minimal* set of parameters to ensure that the
-    code using pybind11 compiles, but it does **not** pass these extra compiler
-    flags (i.e. this is up to you).
-
-    These include Link Time Optimization (``-flto`` on GCC/Clang/ICPC, ``/GL``
-    and ``/LTCG`` on Visual Studio) and .OBJ files with many sections on Visual
-    Studio (``/bigobj``).  The :ref:`FAQ <faq:symhidden>` contains an
-    explanation on why these are needed.
-
-Embedding the Python interpreter
---------------------------------
-
-In addition to extension modules, pybind11 also supports embedding Python into
-a C++ executable or library. In CMake, simply link with the ``pybind11::embed``
-target. It provides everything needed to get the interpreter running. The Python
-headers and libraries are attached to the target. Unlike ``pybind11::module``,
-there is no need to manually set any additional properties here. For more
-information about usage in C++, see :doc:`/advanced/embedding`.
-
-.. code-block:: cmake
-
-    cmake_minimum_required(VERSION 3.0)
-    project(example)
-
-    find_package(pybind11 REQUIRED)  # or add_subdirectory(pybind11)
-
-    add_executable(example main.cpp)
-    target_link_libraries(example PRIVATE pybind11::embed)
-
-.. _building_manually:
-
-Building manually
-=================
-
-pybind11 is a header-only library, hence it is not necessary to link against
-any special libraries and there are no intermediate (magic) translation steps.
-
-On Linux, you can compile an example such as the one given in
-:ref:`simple_example` using the following command:
-
-.. code-block:: bash
-
-    $ c++ -O3 -Wall -shared -std=c++11 -fPIC `python3 -m pybind11 --includes` example.cpp -o example`python3-config --extension-suffix`
-
-The flags given here assume that you're using Python 3. For Python 2, just
-change the executable appropriately (to ``python`` or ``python2``).
-
-The ``python3 -m pybind11 --includes`` command fetches the include paths for
-both pybind11 and Python headers. This assumes that pybind11 has been installed
-using ``pip`` or ``conda``. If it hasn't, you can also manually specify
-``-I <path-to-pybind11>/include`` together with the Python includes path
-``python3-config --includes``.
-
-Note that Python 2.7 modules don't use a special suffix, so you should simply
-use ``example.so`` instead of ``example`python3-config --extension-suffix```.
-Besides, the ``--extension-suffix`` option may or may not be available, depending
-on the distribution; in the latter case, the module extension can be manually
-set to ``.so``.
-
-On Mac OS: the build command is almost the same but it also requires passing
-the ``-undefined dynamic_lookup`` flag so as to ignore missing symbols when
-building the module:
-
-.. code-block:: bash
-
-    $ c++ -O3 -Wall -shared -std=c++11 -undefined dynamic_lookup `python3 -m pybind11 --includes` example.cpp -o example`python3-config --extension-suffix`
-
-In general, it is advisable to include several additional build parameters
-that can considerably reduce the size of the created binary. Refer to section
-:ref:`cmake` for a detailed example of a suitable cross-platform CMake-based
-build system that works on all platforms including Windows.
-
-.. note::
-
-    On Linux and macOS, it's better to (intentionally) not link against
-    ``libpython``. The symbols will be resolved when the extension library
-    is loaded into a Python binary. This is preferable because you might
-    have several different installations of a given Python version (e.g. the
-    system-provided Python, and one that ships with a piece of commercial
-    software). In this way, the plugin will work with both versions, instead
-    of possibly importing a second Python library into a process that already
-    contains one (which will lead to a segfault).
-
-Generating binding code automatically
-=====================================
-
-The ``Binder`` project is a tool for automatic generation of pybind11 binding
-code by introspecting existing C++ codebases using LLVM/Clang. See the
-[binder]_ documentation for details.
-
-.. [binder] http://cppbinder.readthedocs.io/en/latest/about.html
diff --git a/tmap/lib/pybind11/docs/conf.py b/tmap/lib/pybind11/docs/conf.py
deleted file mode 100644
index 930d4ec..0000000
--- a/tmap/lib/pybind11/docs/conf.py
+++ /dev/null
@@ -1,332 +0,0 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-#
-# pybind11 documentation build configuration file, created by
-# sphinx-quickstart on Sun Oct 11 19:23:48 2015.
-#
-# This file is execfile()d with the current directory set to its
-# containing dir.
-#
-# Note that not all possible configuration values are present in this
-# autogenerated file.
-#
-# All configuration values have a default; values that are commented out
-# serve to show the default.
-
-import sys
-import os
-import shlex
-import subprocess
-
-# If extensions (or modules to document with autodoc) are in another directory,
-# add these directories to sys.path here. If the directory is relative to the
-# documentation root, use os.path.abspath to make it absolute, like shown here.
-#sys.path.insert(0, os.path.abspath('.'))
-
-# -- General configuration ------------------------------------------------
-
-# If your documentation needs a minimal Sphinx version, state it here.
-#needs_sphinx = '1.0'
-
-# Add any Sphinx extension module names here, as strings. They can be
-# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
-# ones.
-extensions = ['breathe']
-
-breathe_projects = {'pybind11': '.build/doxygenxml/'}
-breathe_default_project = 'pybind11'
-breathe_domain_by_extension = {'h': 'cpp'}
-
-# Add any paths that contain templates here, relative to this directory.
-templates_path = ['.templates']
-
-# The suffix(es) of source filenames.
-# You can specify multiple suffix as a list of string:
-# source_suffix = ['.rst', '.md']
-source_suffix = '.rst'
-
-# The encoding of source files.
-#source_encoding = 'utf-8-sig'
-
-# The master toctree document.
-master_doc = 'index'
-
-# General information about the project.
-project = 'pybind11'
-copyright = '2017, Wenzel Jakob'
-author = 'Wenzel Jakob'
-
-# The version info for the project you're documenting, acts as replacement for
-# |version| and |release|, also used in various other places throughout the
-# built documents.
-#
-# The short X.Y version.
-version = '2.2'
-# The full version, including alpha/beta/rc tags.
-release = '2.2.0'
-
-# The language for content autogenerated by Sphinx. Refer to documentation
-# for a list of supported languages.
-#
-# This is also used if you do content translation via gettext catalogs.
-# Usually you set "language" from the command line for these cases.
-language = None
-
-# There are two options for replacing |today|: either, you set today to some
-# non-false value, then it is used:
-#today = ''
-# Else, today_fmt is used as the format for a strftime call.
-#today_fmt = '%B %d, %Y'
-
-# List of patterns, relative to source directory, that match files and
-# directories to ignore when looking for source files.
-exclude_patterns = ['.build', 'release.rst']
-
-# The reST default role (used for this markup: `text`) to use for all
-# documents.
-default_role = 'any'
-
-# If true, '()' will be appended to :func: etc. cross-reference text.
-#add_function_parentheses = True
-
-# If true, the current module name will be prepended to all description
-# unit titles (such as .. function::).
-#add_module_names = True
-
-# If true, sectionauthor and moduleauthor directives will be shown in the
-# output. They are ignored by default.
-#show_authors = False
-
-# The name of the Pygments (syntax highlighting) style to use.
-#pygments_style = 'monokai'
-
-# A list of ignored prefixes for module index sorting.
-#modindex_common_prefix = []
-
-# If true, keep warnings as "system message" paragraphs in the built documents.
-#keep_warnings = False
-
-# If true, `todo` and `todoList` produce output, else they produce nothing.
-todo_include_todos = False
-
-
-# -- Options for HTML output ----------------------------------------------
-
-# The theme to use for HTML and HTML Help pages.  See the documentation for
-# a list of builtin themes.
-
-on_rtd = os.environ.get('READTHEDOCS', None) == 'True'
-
-if not on_rtd:  # only import and set the theme if we're building docs locally
-    import sphinx_rtd_theme
-    html_theme = 'sphinx_rtd_theme'
-    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]
-
-    html_context = {
-        'css_files': [
-            '_static/theme_overrides.css'
-        ]
-    }
-else:
-    html_context = {
-        'css_files': [
-            '//media.readthedocs.org/css/sphinx_rtd_theme.css',            
-            '//media.readthedocs.org/css/readthedocs-doc-embed.css',    
-            '_static/theme_overrides.css'
-        ]
-    }
-
-# Theme options are theme-specific and customize the look and feel of a theme
-# further.  For a list of options available for each theme, see the
-# documentation.
-#html_theme_options = {}
-
-# Add any paths that contain custom themes here, relative to this directory.
-#html_theme_path = []
-
-# The name for this set of Sphinx documents.  If None, it defaults to
-# "<project> v<release> documentation".
-#html_title = None
-
-# A shorter title for the navigation bar.  Default is the same as html_title.
-#html_short_title = None
-
-# The name of an image file (relative to this directory) to place at the top
-# of the sidebar.
-#html_logo = None
-
-# The name of an image file (within the static path) to use as favicon of the
-# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
-# pixels large.
-#html_favicon = None
-
-# Add any paths that contain custom static files (such as style sheets) here,
-# relative to this directory. They are copied after the builtin static files,
-# so a file named "default.css" will overwrite the builtin "default.css".
-html_static_path = ['_static']
-
-# Add any extra paths that contain custom files (such as robots.txt or
-# .htaccess) here, relative to this directory. These files are copied
-# directly to the root of the documentation.
-#html_extra_path = []
-
-# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
-# using the given strftime format.
-#html_last_updated_fmt = '%b %d, %Y'
-
-# If true, SmartyPants will be used to convert quotes and dashes to
-# typographically correct entities.
-#html_use_smartypants = True
-
-# Custom sidebar templates, maps document names to template names.
-#html_sidebars = {}
-
-# Additional templates that should be rendered to pages, maps page names to
-# template names.
-#html_additional_pages = {}
-
-# If false, no module index is generated.
-#html_domain_indices = True
-
-# If false, no index is generated.
-#html_use_index = True
-
-# If true, the index is split into individual pages for each letter.
-#html_split_index = False
-
-# If true, links to the reST sources are added to the pages.
-#html_show_sourcelink = True
-
-# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
-#html_show_sphinx = True
-
-# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
-#html_show_copyright = True
-
-# If true, an OpenSearch description file will be output, and all pages will
-# contain a <link> tag referring to it.  The value of this option must be the
-# base URL from which the finished HTML is served.
-#html_use_opensearch = ''
-
-# This is the file name suffix for HTML files (e.g. ".xhtml").
-#html_file_suffix = None
-
-# Language to be used for generating the HTML full-text search index.
-# Sphinx supports the following languages:
-#   'da', 'de', 'en', 'es', 'fi', 'fr', 'h', 'it', 'ja'
-#   'nl', 'no', 'pt', 'ro', 'r', 'sv', 'tr'
-#html_search_language = 'en'
-
-# A dictionary with options for the search language support, empty by default.
-# Now only 'ja' uses this config value
-#html_search_options = {'type': 'default'}
-
-# The name of a javascript file (relative to the configuration directory) that
-# implements a search results scorer. If empty, the default will be used.
-#html_search_scorer = 'scorer.js'
-
-# Output file base name for HTML help builder.
-htmlhelp_basename = 'pybind11doc'
-
-# -- Options for LaTeX output ---------------------------------------------
-
-latex_elements = {
-# The paper size ('letterpaper' or 'a4paper').
-#'papersize': 'letterpaper',
-
-# The font size ('10pt', '11pt' or '12pt').
-#'pointsize': '10pt',
-
-# Additional stuff for the LaTeX preamble.
-'preamble': '\DeclareUnicodeCharacter{00A0}{}',
-
-# Latex figure (float) alignment
-#'figure_align': 'htbp',
-}
-
-# Grouping the document tree into LaTeX files. List of tuples
-# (source start file, target name, title,
-#  author, documentclass [howto, manual, or own class]).
-latex_documents = [
-  (master_doc, 'pybind11.tex', 'pybind11 Documentation',
-   'Wenzel Jakob', 'manual'),
-]
-
-# The name of an image file (relative to this directory) to place at the top of
-# the title page.
-# latex_logo = 'pybind11-logo.png'
-
-# For "manual" documents, if this is true, then toplevel headings are parts,
-# not chapters.
-#latex_use_parts = False
-
-# If true, show page references after internal links.
-#latex_show_pagerefs = False
-
-# If true, show URL addresses after external links.
-#latex_show_urls = False
-
-# Documents to append as an appendix to all manuals.
-#latex_appendices = []
-
-# If false, no module index is generated.
-#latex_domain_indices = True
-
-
-# -- Options for manual page output ---------------------------------------
-
-# One entry per manual page. List of tuples
-# (source start file, name, description, authors, manual section).
-man_pages = [
-    (master_doc, 'pybind11', 'pybind11 Documentation',
-     [author], 1)
-]
-
-# If true, show URL addresses after external links.
-#man_show_urls = False
-
-
-# -- Options for Texinfo output -------------------------------------------
-
-# Grouping the document tree into Texinfo files. List of tuples
-# (source start file, target name, title, author,
-#  dir menu entry, description, category)
-texinfo_documents = [
-  (master_doc, 'pybind11', 'pybind11 Documentation',
-   author, 'pybind11', 'One line description of project.',
-   'Miscellaneous'),
-]
-
-# Documents to append as an appendix to all manuals.
-#texinfo_appendices = []
-
-# If false, no module index is generated.
-#texinfo_domain_indices = True
-
-# How to display URL addresses: 'footnote', 'no', or 'inline'.
-#texinfo_show_urls = 'footnote'
-
-# If true, do not generate a @detailmenu in the "Top" node's menu.
-#texinfo_no_detailmenu = False
-
-primary_domain = 'cpp'
-highlight_language = 'cpp'
-
-
-def generate_doxygen_xml(app):
-    build_dir = os.path.join(app.confdir, '.build')
-    if not os.path.exists(build_dir):
-        os.mkdir(build_dir)
-
-    try:
-        subprocess.call(['doxygen', '--version'])
-        retcode = subprocess.call(['doxygen'], cwd=app.confdir)
-        if retcode < 0:
-            sys.stderr.write("doxygen error code: {}\n".format(-retcode))
-    except OSError as e:
-        sys.stderr.write("doxygen execution failed: {}\n".format(e))
-
-
-def setup(app):
-    """Add hook for building doxygen xml when needed"""
-    app.connect("builder-inited", generate_doxygen_xml)
diff --git a/tmap/lib/pybind11/docs/faq.rst b/tmap/lib/pybind11/docs/faq.rst
deleted file mode 100644
index 8f33eb0..0000000
--- a/tmap/lib/pybind11/docs/faq.rst
+++ /dev/null
@@ -1,273 +0,0 @@
-Frequently asked questions
-##########################
-
-"ImportError: dynamic module does not define init function"
-===========================================================
-
-You are likely using an incompatible version of Python (for instance, the
-extension library was compiled against Python 2, while the interpreter is
-running on top of some version of Python 3, or vice versa).
-
-"Symbol not found: ``__Py_ZeroStruct`` / ``_PyInstanceMethod_Type``"
-========================================================================
-
-See the first answer.
-
-"SystemError: dynamic module not initialized properly"
-======================================================
-
-See the first answer.
-
-The Python interpreter immediately crashes when importing my module
-===================================================================
-
-See the first answer.
-
-CMake doesn't detect the right Python version
-=============================================
-
-The CMake-based build system will try to automatically detect the installed
-version of Python and link against that. When this fails, or when there are
-multiple versions of Python and it finds the wrong one, delete
-``CMakeCache.txt`` and then invoke CMake as follows:
-
-.. code-block:: bash
-
-    cmake -DPYTHON_EXECUTABLE:FILEPATH=<path-to-python-executable> .
-
-Limitations involving reference arguments
-=========================================
-
-In C++, it's fairly common to pass arguments using mutable references or
-mutable pointers, which allows both read and write access to the value
-supplied by the caller. This is sometimes done for efficiency reasons, or to
-realize functions that have multiple return values. Here are two very basic
-examples:
-
-.. code-block:: cpp
-
-    void increment(int &i) { i++; }
-    void increment_ptr(int *i) { (*i)++; }
-
-In Python, all arguments are passed by reference, so there is no general
-issue in binding such code from Python.
-
-However, certain basic Python types (like ``str``, ``int``, ``bool``,
-``float``, etc.) are **immutable**. This means that the following attempt
-to port the function to Python doesn't have the same effect on the value
-provided by the caller -- in fact, it does nothing at all.
-
-.. code-block:: python
-
-    def increment(i):
-        i += 1 # nope..
-
-pybind11 is also affected by such language-level conventions, which means that
-binding ``increment`` or ``increment_ptr`` will also create Python functions
-that don't modify their arguments.
-
-Although inconvenient, one workaround is to encapsulate the immutable types in
-a custom type that does allow modifications.
-
-An other alternative involves binding a small wrapper lambda function that
-returns a tuple with all output arguments (see the remainder of the
-documentation for examples on binding lambda functions). An example:
-
-.. code-block:: cpp
-
-    int foo(int &i) { i++; return 123; }
-
-and the binding code
-
-.. code-block:: cpp
-
-   m.def("foo", [](int i) { int rv = foo(i); return std::make_tuple(rv, i); });
-
-
-How can I reduce the build time?
-================================
-
-It's good practice to split binding code over multiple files, as in the
-following example:
-
-:file:`example.cpp`:
-
-.. code-block:: cpp
-
-    void init_ex1(py::module &);
-    void init_ex2(py::module &);
-    /* ... */
-
-    PYBIND11_MODULE(example, m) {
-        init_ex1(m);
-        init_ex2(m);
-        /* ... */
-    }
-
-:file:`ex1.cpp`:
-
-.. code-block:: cpp
-
-    void init_ex1(py::module &m) {
-        m.def("add", [](int a, int b) { return a + b; });
-    }
-
-:file:`ex2.cpp`:
-
-.. code-block:: cpp
-
-    void init_ex1(py::module &m) {
-        m.def("sub", [](int a, int b) { return a - b; });
-    }
-
-:command:`python`:
-
-.. code-block:: pycon
-
-    >>> import example
-    >>> example.add(1, 2)
-    3
-    >>> example.sub(1, 1)
-    0
-
-As shown above, the various ``init_ex`` functions should be contained in
-separate files that can be compiled independently from one another, and then
-linked together into the same final shared object.  Following this approach
-will:
-
-1. reduce memory requirements per compilation unit.
-
-2. enable parallel builds (if desired).
-
-3. allow for faster incremental builds. For instance, when a single class
-   definition is changed, only a subset of the binding code will generally need
-   to be recompiled.
-
-"recursive template instantiation exceeded maximum depth of 256"
-================================================================
-
-If you receive an error about excessive recursive template evaluation, try
-specifying a larger value, e.g. ``-ftemplate-depth=1024`` on GCC/Clang. The
-culprit is generally the generation of function signatures at compile time
-using C++14 template metaprogramming.
-
-.. _`faq:hidden_visibility`:
-
-"‘SomeClass’ declared with greater visibility than the type of its field ‘SomeClass::member’ [-Wattributes]"
-============================================================================================================
-
-This error typically indicates that you are compiling without the required
-``-fvisibility`` flag.  pybind11 code internally forces hidden visibility on
-all internal code, but if non-hidden (and thus *exported*) code attempts to
-include a pybind type (for example, ``py::object`` or ``py::list``) you can run
-into this warning.
-
-To avoid it, make sure you are specifying ``-fvisibility=hidden`` when
-compiling pybind code.
-
-As to why ``-fvisibility=hidden`` is necessary, because pybind modules could
-have been compiled under different versions of pybind itself, it is also
-important that the symbols defined in one module do not clash with the
-potentially-incompatible symbols defined in another.  While Python extension
-modules are usually loaded with localized symbols (under POSIX systems
-typically using ``dlopen`` with the ``RTLD_LOCAL`` flag), this Python default
-can be changed, but even if it isn't it is not always enough to guarantee
-complete independence of the symbols involved when not using
-``-fvisibility=hidden``.
-
-Additionally, ``-fvisiblity=hidden`` can deliver considerably binary size
-savings.  (See the following section for more details).
-
-
-.. _`faq:symhidden`:
-
-How can I create smaller binaries?
-==================================
-
-To do its job, pybind11 extensively relies on a programming technique known as
-*template metaprogramming*, which is a way of performing computation at compile
-time using type information. Template metaprogamming usually instantiates code
-involving significant numbers of deeply nested types that are either completely
-removed or reduced to just a few instructions during the compiler's optimization
-phase. However, due to the nested nature of these types, the resulting symbol
-names in the compiled extension library can be extremely long. For instance,
-the included test suite contains the following symbol:
-
-.. only:: html
-
-    .. code-block:: none
-
-        _​_​Z​N​8​p​y​b​i​n​d​1​1​1​2​c​p​p​_​f​u​n​c​t​i​o​n​C​1​I​v​8​E​x​a​m​p​l​e​2​J​R​N​S​t​3​_​_​1​6​v​e​c​t​o​r​I​N​S​3​_​1​2​b​a​s​i​c​_​s​t​r​i​n​g​I​w​N​S​3​_​1​1​c​h​a​r​_​t​r​a​i​t​s​I​w​E​E​N​S​3​_​9​a​l​l​o​c​a​t​o​r​I​w​E​E​E​E​N​S​8​_​I​S​A​_​E​E​E​E​E​J​N​S​_​4​n​a​m​e​E​N​S​_​7​s​i​b​l​i​n​g​E​N​S​_​9​i​s​_​m​e​t​h​o​d​E​A​2​8​_​c​E​E​E​M​T​0​_​F​T​_​D​p​T​1​_​E​D​p​R​K​T​2​_
-
-.. only:: not html
-
-    .. code-block:: cpp
-
-        __ZN8pybind1112cpp_functionC1Iv8Example2JRNSt3__16vectorINS3_12basic_stringIwNS3_11char_traitsIwEENS3_9allocatorIwEEEENS8_ISA_EEEEEJNS_4nameENS_7siblingENS_9is_methodEA28_cEEEMT0_FT_DpT1_EDpRKT2_
-
-which is the mangled form of the following function type:
-
-.. code-block:: cpp
-
-    pybind11::cpp_function::cpp_function<void, Example2, std::__1::vector<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >, std::__1::allocator<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> > > >&, pybind11::name, pybind11::sibling, pybind11::is_method, char [28]>(void (Example2::*)(std::__1::vector<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >, std::__1::allocator<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> > > >&), pybind11::name const&, pybind11::sibling const&, pybind11::is_method const&, char const (&) [28])
-
-The memory needed to store just the mangled name of this function (196 bytes)
-is larger than the actual piece of code (111 bytes) it represents! On the other
-hand, it's silly to even give this function a name -- after all, it's just a
-tiny cog in a bigger piece of machinery that is not exposed to the outside
-world. So we'll generally only want to export symbols for those functions which
-are actually called from the outside.
-
-This can be achieved by specifying the parameter ``-fvisibility=hidden`` to GCC
-and Clang, which sets the default symbol visibility to *hidden*, which has a
-tremendous impact on the final binary size of the resulting extension library.
-(On Visual Studio, symbols are already hidden by default, so nothing needs to
-be done there.)
-
-In addition to decreasing binary size, ``-fvisibility=hidden`` also avoids
-potential serious issues when loading multiple modules and is required for
-proper pybind operation.  See the previous FAQ entry for more details.
-
-Another aspect that can require a fair bit of code are function signature
-descriptions. pybind11 automatically generates human-readable function
-signatures for docstrings, e.g.:
-
-.. code-block:: none
-
-     |  __init__(...)
-     |      __init__(*args, **kwargs)
-     |      Overloaded function.
-     |
-     |      1. __init__(example.Example1) -> NoneType
-     |
-     |      Docstring for overload #1 goes here
-     |
-     |      2. __init__(example.Example1, int) -> NoneType
-     |
-     |      Docstring for overload #2 goes here
-     |
-     |      3. __init__(example.Example1, example.Example1) -> NoneType
-     |
-     |      Docstring for overload #3 goes here
-
-
-In C++11 mode, these are generated at run time using string concatenation,
-which can amount to 10-20% of the size of the resulting binary. If you can,
-enable C++14 language features (using ``-std=c++14`` for GCC/Clang), in which
-case signatures are efficiently pre-generated at compile time. Unfortunately,
-Visual Studio's C++14 support (``constexpr``) is not good enough as of April
-2016, so it always uses the more expensive run-time approach.
-
-Working with ancient Visual Studio 2009 builds on Windows
-=========================================================
-
-The official Windows distributions of Python are compiled using truly
-ancient versions of Visual Studio that lack good C++11 support. Some users
-implicitly assume that it would be impossible to load a plugin built with
-Visual Studio 2015 into a Python distribution that was compiled using Visual
-Studio 2009. However, no such issue exists: it's perfectly legitimate to
-interface DLLs that are built with different compilers and/or C libraries.
-Common gotchas to watch out for involve not ``free()``-ing memory region
-that that were ``malloc()``-ed in another shared library, using data
-structures with incompatible ABIs, and so on. pybind11 is very careful not
-to make these types of mistakes.
diff --git a/tmap/lib/pybind11/docs/index.rst b/tmap/lib/pybind11/docs/index.rst
deleted file mode 100644
index d236611..0000000
--- a/tmap/lib/pybind11/docs/index.rst
+++ /dev/null
@@ -1,47 +0,0 @@
-.. only: not latex
-
-    .. image:: pybind11-logo.png
-
-pybind11 --- Seamless operability between C++11 and Python
-==========================================================
-
-.. only: not latex
-
-    Contents:
-
-.. toctree::
-   :maxdepth: 1
-
-   intro
-   changelog
-   upgrade
-
-.. toctree::
-   :caption: The Basics
-   :maxdepth: 2
-
-   basics
-   classes
-   compiling
-
-.. toctree::
-   :caption: Advanced Topics
-   :maxdepth: 2
-
-   advanced/functions
-   advanced/classes
-   advanced/exceptions
-   advanced/smart_ptrs
-   advanced/cast/index
-   advanced/pycpp/index
-   advanced/embedding
-   advanced/misc
-
-.. toctree::
-   :caption: Extra Information
-   :maxdepth: 1
-
-   faq
-   benchmark
-   limitations
-   reference
diff --git a/tmap/lib/pybind11/docs/intro.rst b/tmap/lib/pybind11/docs/intro.rst
deleted file mode 100644
index 2149c18..0000000
--- a/tmap/lib/pybind11/docs/intro.rst
+++ /dev/null
@@ -1,95 +0,0 @@
-.. image:: pybind11-logo.png
-
-About this project
-==================
-**pybind11** is a lightweight header-only library that exposes C++ types in Python
-and vice versa, mainly to create Python bindings of existing C++ code. Its
-goals and syntax are similar to the excellent `Boost.Python`_ library by David
-Abrahams: to minimize boilerplate code in traditional extension modules by
-inferring type information using compile-time introspection.
-
-.. _Boost.Python: http://www.boost.org/doc/libs/release/libs/python/doc/index.html
-
-The main issue with Boost.Python—and the reason for creating such a similar
-project—is Boost. Boost is an enormously large and complex suite of utility
-libraries that works with almost every C++ compiler in existence. This
-compatibility has its cost: arcane template tricks and workarounds are
-necessary to support the oldest and buggiest of compiler specimens. Now that
-C++11-compatible compilers are widely available, this heavy machinery has
-become an excessively large and unnecessary dependency.
-Think of this library as a tiny self-contained version of Boost.Python with
-everything stripped away that isn't relevant for binding generation. Without
-comments, the core header files only require ~4K lines of code and depend on
-Python (2.7 or 3.x, or PyPy2.7 >= 5.7) and the C++ standard library. This
-compact implementation was possible thanks to some of the new C++11 language
-features (specifically: tuples, lambda functions and variadic templates). Since
-its creation, this library has grown beyond Boost.Python in many ways, leading
-to dramatically simpler binding code in many common situations.
-
-Core features
-*************
-The following core C++ features can be mapped to Python
-
-- Functions accepting and returning custom data structures per value, reference, or pointer
-- Instance methods and static methods
-- Overloaded functions
-- Instance attributes and static attributes
-- Arbitrary exception types
-- Enumerations
-- Callbacks
-- Iterators and ranges
-- Custom operators
-- Single and multiple inheritance
-- STL data structures
-- Iterators and ranges
-- Smart pointers with reference counting like ``std::shared_ptr``
-- Internal references with correct reference counting
-- C++ classes with virtual (and pure virtual) methods can be extended in Python
-
-Goodies
-*******
-In addition to the core functionality, pybind11 provides some extra goodies:
-
-- Python 2.7, 3.x, and PyPy (PyPy2.7 >= 5.7) are supported with an
-  implementation-agnostic interface.
-
-- It is possible to bind C++11 lambda functions with captured variables. The
-  lambda capture data is stored inside the resulting Python function object.
-
-- pybind11 uses C++11 move constructors and move assignment operators whenever
-  possible to efficiently transfer custom data types.
-
-- It's easy to expose the internal storage of custom data types through
-  Pythons' buffer protocols. This is handy e.g. for fast conversion between
-  C++ matrix classes like Eigen and NumPy without expensive copy operations.
-
-- pybind11 can automatically vectorize functions so that they are transparently
-  applied to all entries of one or more NumPy array arguments.
-
-- Python's slice-based access and assignment operations can be supported with
-  just a few lines of code.
-
-- Everything is contained in just a few header files; there is no need to link
-  against any additional libraries.
-
-- Binaries are generally smaller by a factor of at least 2 compared to
-  equivalent bindings generated by Boost.Python. A recent pybind11 conversion
-  of `PyRosetta`_, an enormous Boost.Python binding project, reported a binary
-  size reduction of **5.4x** and compile time reduction by **5.8x**.
-
-- When supported by the compiler, two new C++14 features (relaxed constexpr and
-  return value deduction) are used to precompute function signatures at compile
-  time, leading to smaller binaries.
-
-- With little extra effort, C++ types can be pickled and unpickled similar to
-  regular Python objects.
-
-.. _PyRosetta: http://graylab.jhu.edu/RosettaCon2016/PyRosetta-4.pdf
-
-Supported compilers
-*******************
-
-1. Clang/LLVM (any non-ancient version with C++11 support)
-2. GCC 4.8 or newer
-3. Microsoft Visual Studio 2015 or newer
-4. Intel C++ compiler v15 or newer
diff --git a/tmap/lib/pybind11/docs/limitations.rst b/tmap/lib/pybind11/docs/limitations.rst
deleted file mode 100644
index a1a4f1a..0000000
--- a/tmap/lib/pybind11/docs/limitations.rst
+++ /dev/null
@@ -1,20 +0,0 @@
-Limitations
-###########
-
-pybind11 strives to be a general solution to binding generation, but it also has
-certain limitations:
-
-- pybind11 casts away ``const``-ness in function arguments and return values.
-  This is in line with the Python language, which has no concept of ``const``
-  values. This means that some additional care is needed to avoid bugs that
-  would be caught by the type checker in a traditional C++ program.
-
-- The NumPy interface ``pybind11::array`` greatly simplifies accessing
-  numerical data from C++ (and vice versa), but it's not a full-blown array
-  class like ``Eigen::Array`` or ``boost.multi_array``.
-
-These features could be implemented but would lead to a significant increase in
-complexity. I've decided to draw the line here to keep this project simple and
-compact. Users who absolutely require these features are encouraged to fork
-pybind11.
-
diff --git a/tmap/lib/pybind11/docs/pybind11_vs_boost_python1.svg b/tmap/lib/pybind11/docs/pybind11_vs_boost_python1.svg
deleted file mode 100644
index 5bf950e..0000000
--- a/tmap/lib/pybind11/docs/pybind11_vs_boost_python1.svg
+++ /dev/null
@@ -1,427 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="468pt" height="252pt" viewBox="0 0 468 252" version="1.1">
-<defs>
-<g>
-<symbol overflow="visible" id="glyph0-0">
-<path style="stroke:none;" d=""/>
-</symbol>
-<symbol overflow="visible" id="glyph0-1">
-<path style="stroke:none;" d="M 3.726562 0 L 2.847656 0 L 2.847656 -5.601562 C 2.636719 -5.398438 2.359375 -5.195312 2.015625 -4.996094 C 1.671875 -4.792969 1.363281 -4.640625 1.089844 -4.539062 L 1.089844 -5.390625 C 1.582031 -5.621094 2.011719 -5.902344 2.378906 -6.230469 C 2.746094 -6.558594 3.007812 -6.878906 3.160156 -7.1875 L 3.726562 -7.1875 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-2">
-<path style="stroke:none;" d="M 0.414062 -3.53125 C 0.414062 -4.375 0.503906 -5.058594 0.675781 -5.574219 C 0.851562 -6.089844 1.109375 -6.488281 1.453125 -6.765625 C 1.796875 -7.046875 2.226562 -7.1875 2.75 -7.1875 C 3.132812 -7.1875 3.46875 -7.109375 3.757812 -6.957031 C 4.046875 -6.800781 4.289062 -6.578125 4.476562 -6.285156 C 4.664062 -5.996094 4.8125 -5.640625 4.921875 -5.222656 C 5.03125 -4.804688 5.082031 -4.238281 5.082031 -3.53125 C 5.082031 -2.691406 4.996094 -2.011719 4.824219 -1.496094 C 4.652344 -0.980469 4.394531 -0.582031 4.050781 -0.300781 C 3.707031 -0.0195312 3.273438 0.121094 2.75 0.121094 C 2.058594 0.121094 1.515625 -0.125 1.125 -0.621094 C 0.652344 -1.214844 0.414062 -2.1875 0.414062 -3.53125 Z M 1.320312 -3.53125 C 1.320312 -2.355469 1.457031 -1.574219 1.730469 -1.183594 C 2.007812 -0.796875 2.34375 -0.601562 2.75 -0.601562 C 3.152344 -0.601562 3.492188 -0.796875 3.765625 -1.1875 C 4.042969 -1.578125 4.179688 -2.359375 4.179688 -3.53125 C 4.179688 -4.710938 4.042969 -5.492188 3.765625 -5.878906 C 3.492188 -6.265625 3.148438 -6.460938 2.738281 -6.460938 C 2.335938 -6.460938 2.011719 -6.289062 1.773438 -5.945312 C 1.46875 -5.511719 1.320312 -4.707031 1.320312 -3.53125 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-3">
-<path style="stroke:none;" d="M 5.035156 -0.84375 L 5.035156 0 L 0.304688 0 C 0.296875 -0.210938 0.332031 -0.414062 0.40625 -0.609375 C 0.527344 -0.933594 0.71875 -1.25 0.984375 -1.5625 C 1.25 -1.875 1.632812 -2.234375 2.132812 -2.648438 C 2.910156 -3.285156 3.4375 -3.789062 3.710938 -4.164062 C 3.984375 -4.535156 4.121094 -4.886719 4.121094 -5.21875 C 4.121094 -5.566406 3.996094 -5.863281 3.746094 -6.101562 C 3.5 -6.339844 3.171875 -6.460938 2.773438 -6.460938 C 2.351562 -6.460938 2.011719 -6.332031 1.757812 -6.078125 C 1.503906 -5.824219 1.375 -5.472656 1.371094 -5.023438 L 0.46875 -5.117188 C 0.53125 -5.789062 0.761719 -6.304688 1.167969 -6.65625 C 1.570312 -7.011719 2.113281 -7.1875 2.792969 -7.1875 C 3.480469 -7.1875 4.023438 -6.996094 4.421875 -6.617188 C 4.824219 -6.234375 5.023438 -5.761719 5.023438 -5.199219 C 5.023438 -4.914062 4.964844 -4.632812 4.847656 -4.355469 C 4.730469 -4.078125 4.535156 -3.789062 4.265625 -3.480469 C 3.992188 -3.175781 3.542969 -2.753906 2.910156 -2.222656 C 2.382812 -1.78125 2.042969 -1.480469 1.894531 -1.320312 C 1.746094 -1.164062 1.621094 -1.003906 1.523438 -0.84375 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-4">
-<path style="stroke:none;" d="M 0.414062 -1.875 L 1.335938 -1.953125 C 1.40625 -1.503906 1.566406 -1.167969 1.8125 -0.941406 C 2.0625 -0.714844 2.363281 -0.601562 2.714844 -0.601562 C 3.136719 -0.601562 3.496094 -0.761719 3.789062 -1.078125 C 4.082031 -1.398438 4.226562 -1.820312 4.226562 -2.347656 C 4.226562 -2.851562 4.085938 -3.246094 3.804688 -3.535156 C 3.523438 -3.824219 3.15625 -3.96875 2.699219 -3.96875 C 2.417969 -3.96875 2.160156 -3.90625 1.933594 -3.777344 C 1.707031 -3.648438 1.527344 -3.480469 1.398438 -3.277344 L 0.570312 -3.382812 L 1.265625 -7.0625 L 4.824219 -7.0625 L 4.824219 -6.21875 L 1.96875 -6.21875 L 1.582031 -4.296875 C 2.011719 -4.597656 2.460938 -4.746094 2.933594 -4.746094 C 3.558594 -4.746094 4.085938 -4.53125 4.515625 -4.097656 C 4.945312 -3.664062 5.160156 -3.105469 5.160156 -2.425781 C 5.160156 -1.777344 4.972656 -1.21875 4.59375 -0.746094 C 4.136719 -0.167969 3.507812 0.121094 2.714844 0.121094 C 2.0625 0.121094 1.53125 -0.0585938 1.121094 -0.425781 C 0.710938 -0.789062 0.472656 -1.273438 0.414062 -1.875 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-5">
-<path style="stroke:none;" d="M 0.820312 0 L 0.820312 -7.15625 L 5.648438 -7.15625 L 5.648438 -6.3125 L 1.765625 -6.3125 L 1.765625 -4.097656 L 5.125 -4.097656 L 5.125 -3.25 L 1.765625 -3.25 L 1.765625 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-6">
-<path style="stroke:none;" d="M 4.058594 0 L 4.058594 -0.761719 C 3.65625 -0.175781 3.105469 0.117188 2.414062 0.117188 C 2.105469 0.117188 1.820312 0.0585938 1.554688 -0.0585938 C 1.289062 -0.175781 1.09375 -0.324219 0.964844 -0.5 C 0.835938 -0.679688 0.746094 -0.894531 0.695312 -1.152344 C 0.65625 -1.324219 0.640625 -1.597656 0.640625 -1.972656 L 0.640625 -5.1875 L 1.519531 -5.1875 L 1.519531 -2.308594 C 1.519531 -1.851562 1.535156 -1.542969 1.570312 -1.382812 C 1.625 -1.152344 1.746094 -0.96875 1.921875 -0.835938 C 2.101562 -0.703125 2.324219 -0.640625 2.585938 -0.640625 C 2.851562 -0.640625 3.097656 -0.707031 3.328125 -0.84375 C 3.5625 -0.976562 3.726562 -1.160156 3.820312 -1.394531 C 3.917969 -1.625 3.964844 -1.964844 3.964844 -2.40625 L 3.964844 -5.1875 L 4.84375 -5.1875 L 4.84375 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-7">
-<path style="stroke:none;" d="M 0.660156 0 L 0.660156 -5.1875 L 1.449219 -5.1875 L 1.449219 -4.449219 C 1.832031 -5.019531 2.382812 -5.304688 3.101562 -5.304688 C 3.414062 -5.304688 3.699219 -5.246094 3.960938 -5.132812 C 4.222656 -5.023438 4.421875 -4.875 4.550781 -4.691406 C 4.679688 -4.507812 4.773438 -4.292969 4.824219 -4.042969 C 4.855469 -3.878906 4.875 -3.59375 4.875 -3.1875 L 4.875 0 L 3.992188 0 L 3.992188 -3.15625 C 3.992188 -3.511719 3.960938 -3.78125 3.890625 -3.957031 C 3.824219 -4.132812 3.703125 -4.277344 3.527344 -4.382812 C 3.351562 -4.488281 3.148438 -4.539062 2.914062 -4.539062 C 2.539062 -4.539062 2.21875 -4.421875 1.945312 -4.183594 C 1.671875 -3.945312 1.539062 -3.496094 1.539062 -2.832031 L 1.539062 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-8">
-<path style="stroke:none;" d="M 4.042969 -1.898438 L 4.90625 -1.789062 C 4.8125 -1.191406 4.570312 -0.726562 4.183594 -0.386719 C 3.792969 -0.0507812 3.316406 0.117188 2.75 0.117188 C 2.039062 0.117188 1.46875 -0.113281 1.039062 -0.578125 C 0.605469 -1.042969 0.390625 -1.707031 0.390625 -2.574219 C 0.390625 -3.132812 0.484375 -3.625 0.667969 -4.042969 C 0.855469 -4.460938 1.136719 -4.777344 1.515625 -4.988281 C 1.894531 -5.199219 2.308594 -5.304688 2.753906 -5.304688 C 3.316406 -5.304688 3.777344 -5.160156 4.136719 -4.875 C 4.492188 -4.589844 4.722656 -4.1875 4.824219 -3.664062 L 3.96875 -3.53125 C 3.886719 -3.878906 3.746094 -4.140625 3.539062 -4.316406 C 3.332031 -4.492188 3.082031 -4.578125 2.789062 -4.578125 C 2.34375 -4.578125 1.984375 -4.421875 1.710938 -4.105469 C 1.433594 -3.789062 1.292969 -3.285156 1.292969 -2.597656 C 1.292969 -1.902344 1.425781 -1.394531 1.695312 -1.078125 C 1.960938 -0.761719 2.308594 -0.605469 2.738281 -0.605469 C 3.085938 -0.605469 3.371094 -0.710938 3.601562 -0.921875 C 3.835938 -1.132812 3.980469 -1.460938 4.042969 -1.898438 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-9">
-<path style="stroke:none;" d="M 2.578125 -0.785156 L 2.703125 -0.0078125 C 2.457031 0.0429688 2.234375 0.0703125 2.039062 0.0703125 C 1.722656 0.0703125 1.476562 0.0195312 1.296875 -0.0820312 C 1.121094 -0.183594 1 -0.316406 0.929688 -0.480469 C 0.855469 -0.644531 0.820312 -0.992188 0.820312 -1.519531 L 0.820312 -4.5 L 0.175781 -4.5 L 0.175781 -5.1875 L 0.820312 -5.1875 L 0.820312 -6.46875 L 1.695312 -6.996094 L 1.695312 -5.1875 L 2.578125 -5.1875 L 2.578125 -4.5 L 1.695312 -4.5 L 1.695312 -1.46875 C 1.695312 -1.21875 1.710938 -1.058594 1.742188 -0.984375 C 1.773438 -0.914062 1.820312 -0.859375 1.890625 -0.816406 C 1.960938 -0.773438 2.0625 -0.75 2.191406 -0.75 C 2.289062 -0.75 2.417969 -0.761719 2.578125 -0.785156 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-10">
-<path style="stroke:none;" d="M 0.664062 -6.148438 L 0.664062 -7.15625 L 1.542969 -7.15625 L 1.542969 -6.148438 Z M 0.664062 0 L 0.664062 -5.1875 L 1.542969 -5.1875 L 1.542969 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-11">
-<path style="stroke:none;" d="M 0.332031 -2.59375 C 0.332031 -3.554688 0.597656 -4.265625 1.132812 -4.726562 C 1.578125 -5.109375 2.121094 -5.304688 2.765625 -5.304688 C 3.476562 -5.304688 4.058594 -5.070312 4.511719 -4.601562 C 4.964844 -4.132812 5.191406 -3.488281 5.191406 -2.664062 C 5.191406 -2 5.089844 -1.472656 4.890625 -1.089844 C 4.691406 -0.707031 4.398438 -0.410156 4.015625 -0.199219 C 3.632812 0.0117188 3.214844 0.117188 2.765625 0.117188 C 2.039062 0.117188 1.449219 -0.117188 1.003906 -0.582031 C 0.554688 -1.046875 0.332031 -1.71875 0.332031 -2.59375 Z M 1.234375 -2.59375 C 1.234375 -1.929688 1.378906 -1.429688 1.671875 -1.101562 C 1.960938 -0.769531 2.324219 -0.605469 2.765625 -0.605469 C 3.199219 -0.605469 3.5625 -0.773438 3.851562 -1.101562 C 4.140625 -1.433594 4.289062 -1.941406 4.289062 -2.621094 C 4.289062 -3.261719 4.140625 -3.75 3.851562 -4.078125 C 3.558594 -4.410156 3.195312 -4.574219 2.765625 -4.574219 C 2.324219 -4.574219 1.960938 -4.410156 1.671875 -4.082031 C 1.382812 -3.753906 1.234375 -3.257812 1.234375 -2.59375 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-12">
-<path style="stroke:none;" d="M 0.308594 -1.546875 L 1.175781 -1.683594 C 1.226562 -1.335938 1.363281 -1.070312 1.585938 -0.882812 C 1.808594 -0.699219 2.117188 -0.605469 2.519531 -0.605469 C 2.921875 -0.605469 3.222656 -0.6875 3.417969 -0.851562 C 3.613281 -1.015625 3.710938 -1.210938 3.710938 -1.429688 C 3.710938 -1.628906 3.625 -1.785156 3.453125 -1.898438 C 3.332031 -1.976562 3.03125 -2.078125 2.554688 -2.195312 C 1.910156 -2.359375 1.460938 -2.5 1.214844 -2.621094 C 0.964844 -2.738281 0.777344 -2.902344 0.648438 -3.113281 C 0.519531 -3.324219 0.453125 -3.554688 0.453125 -3.808594 C 0.453125 -4.039062 0.507812 -4.253906 0.613281 -4.449219 C 0.71875 -4.648438 0.863281 -4.8125 1.046875 -4.941406 C 1.183594 -5.042969 1.367188 -5.128906 1.605469 -5.199219 C 1.839844 -5.269531 2.09375 -5.304688 2.363281 -5.304688 C 2.769531 -5.304688 3.128906 -5.242188 3.433594 -5.125 C 3.742188 -5.007812 3.96875 -4.851562 4.117188 -4.652344 C 4.261719 -4.453125 4.363281 -4.183594 4.417969 -3.847656 L 3.558594 -3.730469 C 3.519531 -3.996094 3.40625 -4.207031 3.21875 -4.355469 C 3.03125 -4.503906 2.769531 -4.578125 2.425781 -4.578125 C 2.023438 -4.578125 1.734375 -4.511719 1.5625 -4.378906 C 1.390625 -4.246094 1.304688 -4.089844 1.304688 -3.910156 C 1.304688 -3.796875 1.339844 -3.695312 1.410156 -3.601562 C 1.484375 -3.507812 1.59375 -3.429688 1.75 -3.367188 C 1.835938 -3.335938 2.09375 -3.261719 2.523438 -3.144531 C 3.144531 -2.976562 3.578125 -2.84375 3.824219 -2.738281 C 4.070312 -2.632812 4.265625 -2.476562 4.40625 -2.273438 C 4.546875 -2.074219 4.613281 -1.824219 4.613281 -1.523438 C 4.613281 -1.230469 4.527344 -0.953125 4.359375 -0.695312 C 4.1875 -0.4375 3.941406 -0.238281 3.617188 -0.09375 C 3.296875 0.046875 2.929688 0.117188 2.523438 0.117188 C 1.851562 0.117188 1.335938 -0.0234375 0.984375 -0.304688 C 0.632812 -0.582031 0.40625 -0.996094 0.308594 -1.546875 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph1-0">
-<path style="stroke:none;" d=""/>
-</symbol>
-<symbol overflow="visible" id="glyph1-1">
-<path style="stroke:none;" d="M -2.300781 -0.449219 L -2.378906 -1.34375 C -2.019531 -1.386719 -1.726562 -1.484375 -1.496094 -1.636719 C -1.265625 -1.792969 -1.082031 -2.03125 -0.941406 -2.359375 C -0.796875 -2.683594 -0.726562 -3.050781 -0.726562 -3.457031 C -0.726562 -3.820312 -0.78125 -4.136719 -0.890625 -4.414062 C -0.996094 -4.691406 -1.144531 -4.898438 -1.332031 -5.03125 C -1.519531 -5.167969 -1.722656 -5.234375 -1.945312 -5.234375 C -2.167969 -5.234375 -2.363281 -5.167969 -2.53125 -5.039062 C -2.699219 -4.910156 -2.839844 -4.695312 -2.953125 -4.394531 C -3.027344 -4.203125 -3.144531 -3.777344 -3.304688 -3.121094 C -3.460938 -2.460938 -3.609375 -2 -3.75 -1.738281 C -3.929688 -1.398438 -4.152344 -1.140625 -4.417969 -0.972656 C -4.683594 -0.804688 -4.980469 -0.722656 -5.308594 -0.722656 C -5.667969 -0.722656 -6.007812 -0.824219 -6.320312 -1.03125 C -6.632812 -1.234375 -6.875 -1.535156 -7.035156 -1.929688 C -7.199219 -2.324219 -7.28125 -2.761719 -7.28125 -3.242188 C -7.28125 -3.773438 -7.195312 -4.242188 -7.023438 -4.644531 C -6.851562 -5.050781 -6.601562 -5.363281 -6.269531 -5.582031 C -5.9375 -5.800781 -5.5625 -5.917969 -5.140625 -5.933594 L -5.074219 -5.023438 C -5.527344 -4.976562 -5.867188 -4.808594 -6.097656 -4.527344 C -6.328125 -4.246094 -6.445312 -3.832031 -6.445312 -3.28125 C -6.445312 -2.707031 -6.339844 -2.289062 -6.128906 -2.027344 C -5.921875 -1.765625 -5.667969 -1.636719 -5.371094 -1.636719 C -5.113281 -1.636719 -4.902344 -1.726562 -4.734375 -1.914062 C -4.570312 -2.097656 -4.398438 -2.574219 -4.226562 -3.34375 C -4.050781 -4.113281 -3.898438 -4.640625 -3.769531 -4.925781 C -3.578125 -5.34375 -3.335938 -5.652344 -3.039062 -5.851562 C -2.746094 -6.046875 -2.40625 -6.148438 -2.023438 -6.148438 C -1.640625 -6.148438 -1.28125 -6.039062 -0.945312 -5.820312 C -0.609375 -5.601562 -0.347656 -5.289062 -0.160156 -4.878906 C 0.0273438 -4.472656 0.121094 -4.011719 0.121094 -3.5 C 0.121094 -2.851562 0.0273438 -2.308594 -0.160156 -1.871094 C -0.351562 -1.433594 -0.632812 -1.089844 -1.011719 -0.84375 C -1.390625 -0.59375 -1.820312 -0.460938 -2.300781 -0.449219 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph1-2">
-<path style="stroke:none;" d="M -1.671875 -4.210938 L -1.558594 -5.117188 C -1.027344 -4.972656 -0.617188 -4.707031 -0.320312 -4.320312 C -0.0273438 -3.933594 0.117188 -3.4375 0.117188 -2.835938 C 0.117188 -2.078125 -0.117188 -1.476562 -0.582031 -1.03125 C -1.050781 -0.585938 -1.707031 -0.367188 -2.546875 -0.367188 C -3.421875 -0.367188 -4.097656 -0.589844 -4.578125 -1.039062 C -5.0625 -1.488281 -5.304688 -2.070312 -5.304688 -2.789062 C -5.304688 -3.480469 -5.066406 -4.046875 -4.59375 -4.488281 C -4.121094 -4.925781 -3.457031 -5.148438 -2.601562 -5.148438 C -2.550781 -5.148438 -2.472656 -5.144531 -2.367188 -5.140625 L -2.367188 -1.273438 C -1.796875 -1.304688 -1.363281 -1.46875 -1.058594 -1.757812 C -0.757812 -2.046875 -0.605469 -2.410156 -0.605469 -2.84375 C -0.605469 -3.164062 -0.691406 -3.4375 -0.859375 -3.667969 C -1.027344 -3.894531 -1.296875 -4.074219 -1.671875 -4.210938 Z M -3.089844 -1.324219 L -3.089844 -4.21875 C -3.527344 -4.179688 -3.855469 -4.070312 -4.070312 -3.886719 C -4.410156 -3.605469 -4.578125 -3.242188 -4.578125 -2.796875 C -4.578125 -2.394531 -4.445312 -2.054688 -4.175781 -1.78125 C -3.90625 -1.503906 -3.542969 -1.351562 -3.089844 -1.324219 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph1-3">
-<path style="stroke:none;" d="M -1.898438 -4.042969 L -1.789062 -4.90625 C -1.191406 -4.8125 -0.726562 -4.570312 -0.386719 -4.183594 C -0.0507812 -3.792969 0.117188 -3.316406 0.117188 -2.75 C 0.117188 -2.039062 -0.113281 -1.46875 -0.578125 -1.039062 C -1.042969 -0.605469 -1.707031 -0.390625 -2.574219 -0.390625 C -3.132812 -0.390625 -3.625 -0.484375 -4.042969 -0.667969 C -4.460938 -0.855469 -4.777344 -1.136719 -4.988281 -1.515625 C -5.199219 -1.894531 -5.304688 -2.308594 -5.304688 -2.753906 C -5.304688 -3.316406 -5.160156 -3.777344 -4.875 -4.136719 C -4.589844 -4.492188 -4.1875 -4.722656 -3.664062 -4.824219 L -3.53125 -3.96875 C -3.878906 -3.886719 -4.140625 -3.746094 -4.316406 -3.539062 C -4.492188 -3.332031 -4.578125 -3.082031 -4.578125 -2.789062 C -4.578125 -2.34375 -4.421875 -1.984375 -4.105469 -1.710938 C -3.789062 -1.433594 -3.285156 -1.292969 -2.597656 -1.292969 C -1.902344 -1.292969 -1.394531 -1.425781 -1.078125 -1.695312 C -0.761719 -1.960938 -0.605469 -2.308594 -0.605469 -2.738281 C -0.605469 -3.085938 -0.710938 -3.371094 -0.921875 -3.601562 C -1.132812 -3.835938 -1.460938 -3.980469 -1.898438 -4.042969 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph1-4">
-<path style="stroke:none;" d="M -2.59375 -0.332031 C -3.554688 -0.332031 -4.265625 -0.597656 -4.726562 -1.132812 C -5.109375 -1.578125 -5.304688 -2.121094 -5.304688 -2.765625 C -5.304688 -3.476562 -5.070312 -4.058594 -4.601562 -4.511719 C -4.132812 -4.964844 -3.488281 -5.191406 -2.664062 -5.191406 C -2 -5.191406 -1.472656 -5.089844 -1.089844 -4.890625 C -0.707031 -4.691406 -0.410156 -4.398438 -0.199219 -4.015625 C 0.0117188 -3.632812 0.117188 -3.214844 0.117188 -2.765625 C 0.117188 -2.039062 -0.117188 -1.449219 -0.582031 -1.003906 C -1.046875 -0.554688 -1.71875 -0.332031 -2.59375 -0.332031 Z M -2.59375 -1.234375 C -1.929688 -1.234375 -1.429688 -1.378906 -1.101562 -1.671875 C -0.769531 -1.960938 -0.605469 -2.324219 -0.605469 -2.765625 C -0.605469 -3.199219 -0.773438 -3.5625 -1.101562 -3.851562 C -1.433594 -4.140625 -1.941406 -4.289062 -2.621094 -4.289062 C -3.261719 -4.289062 -3.75 -4.140625 -4.078125 -3.851562 C -4.410156 -3.558594 -4.574219 -3.195312 -4.574219 -2.765625 C -4.574219 -2.324219 -4.410156 -1.960938 -4.082031 -1.671875 C -3.753906 -1.382812 -3.257812 -1.234375 -2.59375 -1.234375 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph1-5">
-<path style="stroke:none;" d="M 0 -0.660156 L -5.1875 -0.660156 L -5.1875 -1.449219 L -4.449219 -1.449219 C -5.019531 -1.832031 -5.304688 -2.382812 -5.304688 -3.101562 C -5.304688 -3.414062 -5.246094 -3.699219 -5.132812 -3.960938 C -5.023438 -4.222656 -4.875 -4.421875 -4.691406 -4.550781 C -4.507812 -4.679688 -4.292969 -4.773438 -4.042969 -4.824219 C -3.878906 -4.855469 -3.59375 -4.875 -3.1875 -4.875 L 0 -4.875 L 0 -3.992188 L -3.15625 -3.992188 C -3.511719 -3.992188 -3.78125 -3.960938 -3.957031 -3.890625 C -4.132812 -3.824219 -4.277344 -3.703125 -4.382812 -3.527344 C -4.488281 -3.351562 -4.539062 -3.148438 -4.539062 -2.914062 C -4.539062 -2.539062 -4.421875 -2.21875 -4.183594 -1.945312 C -3.945312 -1.671875 -3.496094 -1.539062 -2.832031 -1.539062 L 0 -1.539062 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph1-6">
-<path style="stroke:none;" d="M 0 -4.023438 L -0.65625 -4.023438 C -0.140625 -3.695312 0.117188 -3.210938 0.117188 -2.574219 C 0.117188 -2.160156 0.00390625 -1.78125 -0.226562 -1.433594 C -0.453125 -1.085938 -0.769531 -0.816406 -1.179688 -0.628906 C -1.585938 -0.4375 -2.058594 -0.34375 -2.585938 -0.34375 C -3.105469 -0.34375 -3.574219 -0.429688 -3.996094 -0.601562 C -4.417969 -0.773438 -4.742188 -1.03125 -4.964844 -1.375 C -5.191406 -1.722656 -5.304688 -2.109375 -5.304688 -2.535156 C -5.304688 -2.847656 -5.238281 -3.125 -5.105469 -3.367188 C -4.972656 -3.613281 -4.800781 -3.8125 -4.589844 -3.964844 L -7.15625 -3.964844 L -7.15625 -4.839844 L 0 -4.839844 Z M -2.585938 -1.246094 C -1.921875 -1.246094 -1.425781 -1.386719 -1.097656 -1.664062 C -0.769531 -1.945312 -0.605469 -2.273438 -0.605469 -2.65625 C -0.605469 -3.039062 -0.761719 -3.367188 -1.078125 -3.636719 C -1.390625 -3.90625 -1.871094 -4.039062 -2.515625 -4.039062 C -3.226562 -4.039062 -3.746094 -3.902344 -4.078125 -3.628906 C -4.410156 -3.355469 -4.574219 -3.015625 -4.574219 -2.617188 C -4.574219 -2.226562 -4.414062 -1.898438 -4.097656 -1.636719 C -3.777344 -1.375 -3.273438 -1.246094 -2.585938 -1.246094 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph1-7">
-<path style="stroke:none;" d="M -1.546875 -0.308594 L -1.683594 -1.175781 C -1.335938 -1.226562 -1.070312 -1.363281 -0.882812 -1.585938 C -0.699219 -1.808594 -0.605469 -2.117188 -0.605469 -2.519531 C -0.605469 -2.921875 -0.6875 -3.222656 -0.851562 -3.417969 C -1.015625 -3.613281 -1.210938 -3.710938 -1.429688 -3.710938 C -1.628906 -3.710938 -1.785156 -3.625 -1.898438 -3.453125 C -1.976562 -3.332031 -2.078125 -3.03125 -2.195312 -2.554688 C -2.359375 -1.910156 -2.5 -1.460938 -2.621094 -1.214844 C -2.738281 -0.964844 -2.902344 -0.777344 -3.113281 -0.648438 C -3.324219 -0.519531 -3.554688 -0.453125 -3.808594 -0.453125 C -4.039062 -0.453125 -4.253906 -0.507812 -4.449219 -0.613281 C -4.648438 -0.71875 -4.8125 -0.863281 -4.941406 -1.046875 C -5.042969 -1.183594 -5.128906 -1.367188 -5.199219 -1.605469 C -5.269531 -1.839844 -5.304688 -2.09375 -5.304688 -2.363281 C -5.304688 -2.769531 -5.242188 -3.128906 -5.125 -3.433594 C -5.007812 -3.742188 -4.851562 -3.96875 -4.652344 -4.117188 C -4.453125 -4.261719 -4.183594 -4.363281 -3.847656 -4.417969 L -3.730469 -3.558594 C -3.996094 -3.519531 -4.207031 -3.40625 -4.355469 -3.21875 C -4.503906 -3.03125 -4.578125 -2.769531 -4.578125 -2.425781 C -4.578125 -2.023438 -4.511719 -1.734375 -4.378906 -1.5625 C -4.246094 -1.390625 -4.089844 -1.304688 -3.910156 -1.304688 C -3.796875 -1.304688 -3.695312 -1.339844 -3.601562 -1.410156 C -3.507812 -1.484375 -3.429688 -1.59375 -3.367188 -1.75 C -3.335938 -1.835938 -3.261719 -2.09375 -3.144531 -2.523438 C -2.976562 -3.144531 -2.84375 -3.578125 -2.738281 -3.824219 C -2.632812 -4.070312 -2.476562 -4.265625 -2.273438 -4.40625 C -2.074219 -4.546875 -1.824219 -4.613281 -1.523438 -4.613281 C -1.230469 -4.613281 -0.953125 -4.527344 -0.695312 -4.359375 C -0.4375 -4.1875 -0.238281 -3.941406 -0.09375 -3.617188 C 0.046875 -3.296875 0.117188 -2.929688 0.117188 -2.523438 C 0.117188 -1.851562 -0.0234375 -1.335938 -0.304688 -0.984375 C -0.582031 -0.632812 -0.996094 -0.40625 -1.546875 -0.308594 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-0">
-<path style="stroke:none;" d=""/>
-</symbol>
-<symbol overflow="visible" id="glyph2-1">
-<path style="stroke:none;" d="M 7.054688 -3.011719 L 8.191406 -2.726562 C 7.953125 -1.792969 7.523438 -1.078125 6.90625 -0.589844 C 6.285156 -0.0976562 5.53125 0.148438 4.632812 0.148438 C 3.707031 0.148438 2.957031 -0.0429688 2.375 -0.417969 C 1.796875 -0.796875 1.355469 -1.34375 1.050781 -2.054688 C 0.75 -2.769531 0.597656 -3.539062 0.597656 -4.359375 C 0.597656 -5.253906 0.769531 -6.035156 1.109375 -6.699219 C 1.453125 -7.367188 1.9375 -7.871094 2.570312 -8.21875 C 3.199219 -8.5625 3.894531 -8.734375 4.652344 -8.734375 C 5.511719 -8.734375 6.234375 -8.515625 6.820312 -8.078125 C 7.40625 -7.640625 7.8125 -7.027344 8.046875 -6.234375 L 6.925781 -5.96875 C 6.726562 -6.59375 6.4375 -7.050781 6.058594 -7.335938 C 5.679688 -7.621094 5.203125 -7.765625 4.628906 -7.765625 C 3.96875 -7.765625 3.417969 -7.605469 2.972656 -7.289062 C 2.53125 -6.972656 2.21875 -6.546875 2.039062 -6.015625 C 1.859375 -5.480469 1.769531 -4.929688 1.769531 -4.367188 C 1.769531 -3.636719 1.875 -2.996094 2.089844 -2.453125 C 2.300781 -1.90625 2.632812 -1.5 3.082031 -1.230469 C 3.53125 -0.960938 4.015625 -0.828125 4.539062 -0.828125 C 5.175781 -0.828125 5.71875 -1.007812 6.15625 -1.375 C 6.597656 -1.742188 6.898438 -2.289062 7.054688 -3.011719 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-2">
-<path style="stroke:none;" d="M 0.398438 -3.109375 C 0.398438 -4.261719 0.71875 -5.117188 1.359375 -5.671875 C 1.894531 -6.132812 2.546875 -6.363281 3.316406 -6.363281 C 4.171875 -6.363281 4.871094 -6.082031 5.414062 -5.523438 C 5.957031 -4.960938 6.226562 -4.1875 6.226562 -3.199219 C 6.226562 -2.398438 6.109375 -1.769531 5.867188 -1.308594 C 5.628906 -0.851562 5.277344 -0.492188 4.820312 -0.242188 C 4.359375 0.0117188 3.859375 0.140625 3.316406 0.140625 C 2.445312 0.140625 1.742188 -0.140625 1.203125 -0.695312 C 0.667969 -1.253906 0.398438 -2.0625 0.398438 -3.109375 Z M 1.484375 -3.109375 C 1.484375 -2.3125 1.65625 -1.71875 2.003906 -1.320312 C 2.351562 -0.925781 2.789062 -0.726562 3.316406 -0.726562 C 3.839844 -0.726562 4.273438 -0.925781 4.625 -1.324219 C 4.972656 -1.722656 5.144531 -2.328125 5.144531 -3.148438 C 5.144531 -3.917969 4.96875 -4.5 4.621094 -4.894531 C 4.269531 -5.292969 3.835938 -5.492188 3.316406 -5.492188 C 2.789062 -5.492188 2.351562 -5.292969 2.003906 -4.898438 C 1.65625 -4.503906 1.484375 -3.90625 1.484375 -3.109375 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-3">
-<path style="stroke:none;" d="M 0.789062 0 L 0.789062 -6.222656 L 1.734375 -6.222656 L 1.734375 -5.351562 C 1.929688 -5.65625 2.1875 -5.898438 2.515625 -6.085938 C 2.839844 -6.269531 3.207031 -6.363281 3.621094 -6.363281 C 4.082031 -6.363281 4.460938 -6.265625 4.753906 -6.078125 C 5.050781 -5.886719 5.257812 -5.617188 5.378906 -5.273438 C 5.871094 -6 6.511719 -6.363281 7.300781 -6.363281 C 7.917969 -6.363281 8.390625 -6.191406 8.726562 -5.851562 C 9.058594 -5.507812 9.222656 -4.984375 9.222656 -4.273438 L 9.222656 0 L 8.171875 0 L 8.171875 -3.921875 C 8.171875 -4.34375 8.140625 -4.644531 8.070312 -4.832031 C 8.003906 -5.015625 7.878906 -5.164062 7.699219 -5.28125 C 7.519531 -5.394531 7.308594 -5.449219 7.066406 -5.449219 C 6.628906 -5.449219 6.265625 -5.304688 5.976562 -5.011719 C 5.6875 -4.722656 5.542969 -4.257812 5.542969 -3.617188 L 5.542969 0 L 4.488281 0 L 4.488281 -4.042969 C 4.488281 -4.511719 4.402344 -4.863281 4.230469 -5.097656 C 4.058594 -5.332031 3.777344 -5.449219 3.386719 -5.449219 C 3.089844 -5.449219 2.816406 -5.371094 2.5625 -5.214844 C 2.3125 -5.058594 2.128906 -4.828125 2.015625 -4.53125 C 1.902344 -4.230469 1.84375 -3.796875 1.84375 -3.226562 L 1.84375 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-4">
-<path style="stroke:none;" d="M 0.789062 2.382812 L 0.789062 -6.222656 L 1.75 -6.222656 L 1.75 -5.414062 C 1.976562 -5.730469 2.234375 -5.96875 2.519531 -6.125 C 2.804688 -6.285156 3.148438 -6.363281 3.554688 -6.363281 C 4.085938 -6.363281 4.554688 -6.226562 4.960938 -5.953125 C 5.367188 -5.679688 5.675781 -5.292969 5.882812 -4.796875 C 6.089844 -4.296875 6.195312 -3.75 6.195312 -3.15625 C 6.195312 -2.519531 6.078125 -1.949219 5.851562 -1.4375 C 5.621094 -0.929688 5.289062 -0.539062 4.855469 -0.265625 C 4.417969 0.00390625 3.960938 0.140625 3.480469 0.140625 C 3.128906 0.140625 2.8125 0.0664062 2.535156 -0.0820312 C 2.253906 -0.230469 2.023438 -0.417969 1.84375 -0.644531 L 1.84375 2.382812 Z M 1.746094 -3.078125 C 1.746094 -2.277344 1.90625 -1.683594 2.234375 -1.300781 C 2.558594 -0.917969 2.949219 -0.726562 3.410156 -0.726562 C 3.878906 -0.726562 4.28125 -0.925781 4.613281 -1.320312 C 4.949219 -1.71875 5.117188 -2.332031 5.117188 -3.164062 C 5.117188 -3.957031 4.953125 -4.550781 4.625 -4.945312 C 4.300781 -5.339844 3.910156 -5.539062 3.457031 -5.539062 C 3.007812 -5.539062 2.609375 -5.328125 2.265625 -4.90625 C 1.917969 -4.488281 1.746094 -3.875 1.746094 -3.078125 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-5">
-<path style="stroke:none;" d="M 0.796875 -7.375 L 0.796875 -8.589844 L 1.851562 -8.589844 L 1.851562 -7.375 Z M 0.796875 0 L 0.796875 -6.222656 L 1.851562 -6.222656 L 1.851562 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-6">
-<path style="stroke:none;" d="M 0.765625 0 L 0.765625 -8.589844 L 1.820312 -8.589844 L 1.820312 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-7">
-<path style="stroke:none;" d="M 4.851562 -0.765625 C 4.460938 -0.433594 4.085938 -0.203125 3.722656 -0.0625 C 3.363281 0.0742188 2.976562 0.140625 2.5625 0.140625 C 1.878906 0.140625 1.351562 -0.0273438 0.984375 -0.359375 C 0.617188 -0.695312 0.433594 -1.121094 0.433594 -1.640625 C 0.433594 -1.945312 0.503906 -2.222656 0.640625 -2.476562 C 0.78125 -2.726562 0.960938 -2.929688 1.1875 -3.082031 C 1.410156 -3.234375 1.664062 -3.351562 1.945312 -3.429688 C 2.152344 -3.484375 2.464844 -3.535156 2.882812 -3.585938 C 3.734375 -3.6875 4.359375 -3.808594 4.765625 -3.949219 C 4.769531 -4.09375 4.769531 -4.1875 4.769531 -4.226562 C 4.769531 -4.65625 4.671875 -4.957031 4.46875 -5.132812 C 4.199219 -5.371094 3.800781 -5.492188 3.269531 -5.492188 C 2.773438 -5.492188 2.40625 -5.402344 2.171875 -5.230469 C 1.933594 -5.054688 1.757812 -4.75 1.648438 -4.304688 L 0.617188 -4.445312 C 0.710938 -4.886719 0.863281 -5.246094 1.078125 -5.515625 C 1.292969 -5.789062 1.601562 -5.996094 2.007812 -6.144531 C 2.414062 -6.289062 2.886719 -6.363281 3.421875 -6.363281 C 3.953125 -6.363281 4.382812 -6.300781 4.71875 -6.175781 C 5.050781 -6.050781 5.292969 -5.894531 5.449219 -5.703125 C 5.605469 -5.515625 5.714844 -5.273438 5.777344 -4.984375 C 5.8125 -4.804688 5.828125 -4.484375 5.828125 -4.015625 L 5.828125 -2.609375 C 5.828125 -1.628906 5.851562 -1.007812 5.898438 -0.746094 C 5.941406 -0.488281 6.03125 -0.238281 6.164062 0 L 5.0625 0 C 4.953125 -0.21875 4.882812 -0.476562 4.851562 -0.765625 Z M 4.765625 -3.125 C 4.382812 -2.96875 3.804688 -2.835938 3.039062 -2.726562 C 2.605469 -2.664062 2.300781 -2.59375 2.121094 -2.515625 C 1.941406 -2.4375 1.804688 -2.320312 1.703125 -2.171875 C 1.605469 -2.019531 1.558594 -1.851562 1.558594 -1.671875 C 1.558594 -1.390625 1.664062 -1.15625 1.878906 -0.96875 C 2.089844 -0.78125 2.402344 -0.6875 2.8125 -0.6875 C 3.21875 -0.6875 3.578125 -0.773438 3.898438 -0.953125 C 4.214844 -1.128906 4.445312 -1.375 4.59375 -1.679688 C 4.707031 -1.917969 4.765625 -2.273438 4.765625 -2.734375 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-8">
-<path style="stroke:none;" d="M 3.09375 -0.945312 L 3.246094 -0.0117188 C 2.949219 0.0507812 2.683594 0.0820312 2.449219 0.0820312 C 2.066406 0.0820312 1.769531 0.0234375 1.558594 -0.101562 C 1.347656 -0.222656 1.199219 -0.378906 1.113281 -0.578125 C 1.027344 -0.773438 0.984375 -1.1875 0.984375 -1.820312 L 0.984375 -5.402344 L 0.210938 -5.402344 L 0.210938 -6.222656 L 0.984375 -6.222656 L 0.984375 -7.765625 L 2.03125 -8.398438 L 2.03125 -6.222656 L 3.09375 -6.222656 L 3.09375 -5.402344 L 2.03125 -5.402344 L 2.03125 -1.765625 C 2.03125 -1.464844 2.050781 -1.269531 2.089844 -1.183594 C 2.125 -1.097656 2.1875 -1.03125 2.269531 -0.976562 C 2.355469 -0.925781 2.476562 -0.902344 2.632812 -0.902344 C 2.75 -0.902344 2.902344 -0.914062 3.09375 -0.945312 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-9">
-<path style="stroke:none;" d="M 0.789062 0 L 0.789062 -6.222656 L 1.742188 -6.222656 L 1.742188 -5.335938 C 2.199219 -6.019531 2.859375 -6.363281 3.71875 -6.363281 C 4.09375 -6.363281 4.441406 -6.296875 4.753906 -6.160156 C 5.070312 -6.027344 5.304688 -5.851562 5.460938 -5.632812 C 5.617188 -5.414062 5.726562 -5.152344 5.789062 -4.851562 C 5.828125 -4.65625 5.847656 -4.3125 5.847656 -3.828125 L 5.847656 0 L 4.792969 0 L 4.792969 -3.785156 C 4.792969 -4.214844 4.75 -4.535156 4.671875 -4.75 C 4.589844 -4.960938 4.441406 -5.132812 4.234375 -5.257812 C 4.023438 -5.386719 3.78125 -5.449219 3.5 -5.449219 C 3.050781 -5.449219 2.660156 -5.304688 2.335938 -5.023438 C 2.007812 -4.738281 1.84375 -4.195312 1.84375 -3.398438 L 1.84375 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-10">
-<path style="stroke:none;" d="M 5.050781 -2.003906 L 6.140625 -1.867188 C 5.96875 -1.230469 5.648438 -0.738281 5.1875 -0.386719 C 4.722656 -0.0351562 4.125 0.140625 3.40625 0.140625 C 2.496094 0.140625 1.773438 -0.140625 1.238281 -0.699219 C 0.707031 -1.261719 0.4375 -2.046875 0.4375 -3.058594 C 0.4375 -4.105469 0.710938 -4.917969 1.25 -5.496094 C 1.789062 -6.074219 2.484375 -6.363281 3.34375 -6.363281 C 4.175781 -6.363281 4.859375 -6.078125 5.382812 -5.515625 C 5.910156 -4.949219 6.175781 -4.148438 6.175781 -3.125 C 6.175781 -3.0625 6.171875 -2.96875 6.171875 -2.84375 L 1.53125 -2.84375 C 1.570312 -2.160156 1.761719 -1.632812 2.109375 -1.273438 C 2.457031 -0.910156 2.890625 -0.726562 3.410156 -0.726562 C 3.796875 -0.726562 4.125 -0.828125 4.398438 -1.03125 C 4.671875 -1.234375 4.890625 -1.558594 5.050781 -2.003906 Z M 1.585938 -3.710938 L 5.0625 -3.710938 C 5.015625 -4.234375 4.882812 -4.625 4.664062 -4.886719 C 4.328125 -5.292969 3.890625 -5.496094 3.359375 -5.496094 C 2.875 -5.496094 2.464844 -5.335938 2.136719 -5.007812 C 1.804688 -4.683594 1.625 -4.25 1.585938 -3.710938 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-11">
-<path style="stroke:none;" d="M 1.042969 0 L 1.042969 -5.402344 L 0.109375 -5.402344 L 0.109375 -6.222656 L 1.042969 -6.222656 L 1.042969 -6.882812 C 1.042969 -7.300781 1.078125 -7.613281 1.15625 -7.816406 C 1.257812 -8.089844 1.433594 -8.3125 1.691406 -8.480469 C 1.945312 -8.652344 2.304688 -8.734375 2.765625 -8.734375 C 3.0625 -8.734375 3.390625 -8.703125 3.75 -8.632812 L 3.59375 -7.710938 C 3.375 -7.75 3.164062 -7.769531 2.96875 -7.769531 C 2.648438 -7.769531 2.421875 -7.703125 2.289062 -7.5625 C 2.15625 -7.425781 2.09375 -7.171875 2.09375 -6.796875 L 2.09375 -6.222656 L 3.304688 -6.222656 L 3.304688 -5.402344 L 2.09375 -5.402344 L 2.09375 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-12">
-<path style="stroke:none;" d="M 4.828125 0 L 4.828125 -0.785156 C 4.433594 -0.167969 3.851562 0.140625 3.085938 0.140625 C 2.589844 0.140625 2.136719 0.00390625 1.71875 -0.269531 C 1.304688 -0.542969 0.980469 -0.925781 0.753906 -1.414062 C 0.523438 -1.90625 0.410156 -2.46875 0.410156 -3.105469 C 0.410156 -3.726562 0.515625 -4.289062 0.71875 -4.796875 C 0.925781 -5.300781 1.238281 -5.6875 1.652344 -5.960938 C 2.066406 -6.230469 2.53125 -6.363281 3.039062 -6.363281 C 3.414062 -6.363281 3.75 -6.285156 4.042969 -6.125 C 4.335938 -5.96875 4.574219 -5.761719 4.757812 -5.507812 L 4.757812 -8.589844 L 5.804688 -8.589844 L 5.804688 0 Z M 1.492188 -3.105469 C 1.492188 -2.308594 1.664062 -1.710938 2 -1.320312 C 2.335938 -0.925781 2.730469 -0.726562 3.1875 -0.726562 C 3.648438 -0.726562 4.039062 -0.914062 4.363281 -1.292969 C 4.683594 -1.667969 4.84375 -2.242188 4.84375 -3.015625 C 4.84375 -3.867188 4.679688 -4.492188 4.351562 -4.890625 C 4.023438 -5.289062 3.621094 -5.492188 3.140625 -5.492188 C 2.671875 -5.492188 2.28125 -5.296875 1.964844 -4.914062 C 1.652344 -4.53125 1.492188 -3.929688 1.492188 -3.105469 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-13">
-<path style="stroke:none;" d="M 4.867188 0 L 4.867188 -0.914062 C 4.382812 -0.210938 3.726562 0.140625 2.894531 0.140625 C 2.527344 0.140625 2.183594 0.0703125 1.867188 -0.0703125 C 1.546875 -0.210938 1.3125 -0.386719 1.15625 -0.601562 C 1.003906 -0.8125 0.894531 -1.074219 0.832031 -1.382812 C 0.789062 -1.589844 0.765625 -1.917969 0.765625 -2.367188 L 0.765625 -6.222656 L 1.820312 -6.222656 L 1.820312 -2.773438 C 1.820312 -2.222656 1.84375 -1.851562 1.886719 -1.65625 C 1.953125 -1.378906 2.09375 -1.164062 2.308594 -1.003906 C 2.523438 -0.847656 2.789062 -0.765625 3.105469 -0.765625 C 3.421875 -0.765625 3.71875 -0.847656 3.996094 -1.011719 C 4.273438 -1.171875 4.46875 -1.394531 4.585938 -1.671875 C 4.699219 -1.953125 4.757812 -2.359375 4.757812 -2.890625 L 4.757812 -6.222656 L 5.8125 -6.222656 L 5.8125 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-0">
-<path style="stroke:none;" d=""/>
-</symbol>
-<symbol overflow="visible" id="glyph3-1">
-<path style="stroke:none;" d="M 0.953125 0 L 0.953125 -9.304688 L 4.445312 -9.304688 C 5.15625 -9.304688 5.722656 -9.210938 6.152344 -9.023438 C 6.582031 -8.835938 6.921875 -8.546875 7.164062 -8.152344 C 7.40625 -7.761719 7.527344 -7.351562 7.527344 -6.925781 C 7.527344 -6.527344 7.421875 -6.152344 7.203125 -5.800781 C 6.988281 -5.449219 6.664062 -5.167969 6.226562 -4.953125 C 6.789062 -4.785156 7.222656 -4.503906 7.523438 -4.105469 C 7.828125 -3.707031 7.980469 -3.238281 7.980469 -2.699219 C 7.980469 -2.261719 7.886719 -1.855469 7.703125 -1.480469 C 7.519531 -1.105469 7.292969 -0.820312 7.019531 -0.617188 C 6.75 -0.414062 6.410156 -0.257812 6 -0.15625 C 5.59375 -0.0507812 5.09375 0 4.5 0 Z M 2.183594 -5.394531 L 4.195312 -5.394531 C 4.742188 -5.394531 5.132812 -5.429688 5.371094 -5.503906 C 5.683594 -5.597656 5.917969 -5.75 6.078125 -5.96875 C 6.238281 -6.183594 6.316406 -6.453125 6.316406 -6.78125 C 6.316406 -7.089844 6.242188 -7.359375 6.09375 -7.59375 C 5.945312 -7.828125 5.734375 -7.992188 5.460938 -8.078125 C 5.183594 -8.164062 4.710938 -8.207031 4.042969 -8.207031 L 2.183594 -8.207031 Z M 2.183594 -1.097656 L 4.5 -1.097656 C 4.898438 -1.097656 5.175781 -1.113281 5.339844 -1.140625 C 5.621094 -1.191406 5.859375 -1.277344 6.050781 -1.398438 C 6.242188 -1.515625 6.394531 -1.6875 6.519531 -1.914062 C 6.640625 -2.140625 6.703125 -2.402344 6.703125 -2.699219 C 6.703125 -3.046875 6.613281 -3.347656 6.4375 -3.601562 C 6.257812 -3.859375 6.011719 -4.039062 5.695312 -4.140625 C 5.382812 -4.246094 4.929688 -4.296875 4.335938 -4.296875 L 2.183594 -4.296875 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-2">
-<path style="stroke:none;" d="M 0.429688 -3.371094 C 0.429688 -4.617188 0.777344 -5.542969 1.472656 -6.144531 C 2.050781 -6.644531 2.757812 -6.894531 3.59375 -6.894531 C 4.519531 -6.894531 5.277344 -6.589844 5.867188 -5.984375 C 6.453125 -5.375 6.746094 -4.535156 6.746094 -3.464844 C 6.746094 -2.597656 6.617188 -1.914062 6.355469 -1.417969 C 6.097656 -0.921875 5.71875 -0.535156 5.222656 -0.261719 C 4.722656 0.015625 4.179688 0.152344 3.59375 0.152344 C 2.648438 0.152344 1.886719 -0.148438 1.304688 -0.753906 C 0.722656 -1.359375 0.429688 -2.230469 0.429688 -3.371094 Z M 1.605469 -3.371094 C 1.605469 -2.507812 1.792969 -1.859375 2.171875 -1.429688 C 2.546875 -1 3.023438 -0.789062 3.59375 -0.789062 C 4.160156 -0.789062 4.632812 -1.003906 5.007812 -1.433594 C 5.382812 -1.867188 5.574219 -2.523438 5.574219 -3.410156 C 5.574219 -4.242188 5.382812 -4.875 5.003906 -5.304688 C 4.625 -5.734375 4.15625 -5.949219 3.59375 -5.949219 C 3.023438 -5.949219 2.546875 -5.734375 2.171875 -5.304688 C 1.792969 -4.878906 1.605469 -4.234375 1.605469 -3.371094 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-3">
-<path style="stroke:none;" d="M 0.398438 -2.011719 L 1.53125 -2.191406 C 1.59375 -1.738281 1.769531 -1.390625 2.058594 -1.148438 C 2.347656 -0.90625 2.753906 -0.789062 3.273438 -0.789062 C 3.800781 -0.789062 4.1875 -0.894531 4.445312 -1.109375 C 4.699219 -1.320312 4.824219 -1.570312 4.824219 -1.859375 C 4.824219 -2.117188 4.710938 -2.320312 4.488281 -2.46875 C 4.332031 -2.570312 3.941406 -2.699219 3.320312 -2.855469 C 2.480469 -3.066406 1.902344 -3.25 1.578125 -3.40625 C 1.253906 -3.558594 1.007812 -3.773438 0.839844 -4.046875 C 0.671875 -4.320312 0.589844 -4.621094 0.589844 -4.953125 C 0.589844 -5.253906 0.660156 -5.53125 0.796875 -5.785156 C 0.933594 -6.042969 1.121094 -6.253906 1.359375 -6.421875 C 1.535156 -6.554688 1.777344 -6.667969 2.085938 -6.757812 C 2.390625 -6.847656 2.722656 -6.894531 3.070312 -6.894531 C 3.601562 -6.894531 4.066406 -6.816406 4.464844 -6.664062 C 4.867188 -6.511719 5.160156 -6.304688 5.351562 -6.046875 C 5.542969 -5.785156 5.671875 -5.4375 5.746094 -5 L 4.628906 -4.851562 C 4.578125 -5.195312 4.429688 -5.46875 4.1875 -5.664062 C 3.945312 -5.859375 3.597656 -5.953125 3.15625 -5.953125 C 2.628906 -5.953125 2.253906 -5.867188 2.03125 -5.695312 C 1.808594 -5.519531 1.695312 -5.316406 1.695312 -5.085938 C 1.695312 -4.9375 1.742188 -4.804688 1.835938 -4.683594 C 1.929688 -4.5625 2.074219 -4.460938 2.273438 -4.378906 C 2.386719 -4.335938 2.722656 -4.242188 3.28125 -4.085938 C 4.089844 -3.871094 4.652344 -3.695312 4.972656 -3.558594 C 5.292969 -3.421875 5.542969 -3.21875 5.726562 -2.957031 C 5.90625 -2.695312 6 -2.371094 6 -1.980469 C 6 -1.601562 5.886719 -1.242188 5.664062 -0.90625 C 5.441406 -0.570312 5.121094 -0.308594 4.703125 -0.125 C 4.285156 0.0585938 3.8125 0.152344 3.28125 0.152344 C 2.40625 0.152344 1.738281 -0.03125 1.277344 -0.394531 C 0.820312 -0.757812 0.527344 -1.296875 0.398438 -2.011719 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-4">
-<path style="stroke:none;" d="M 3.351562 -1.023438 L 3.515625 -0.0117188 C 3.195312 0.0546875 2.90625 0.0898438 2.652344 0.0898438 C 2.238281 0.0898438 1.917969 0.0234375 1.6875 -0.109375 C 1.460938 -0.238281 1.300781 -0.410156 1.207031 -0.625 C 1.113281 -0.839844 1.066406 -1.289062 1.066406 -1.972656 L 1.066406 -5.851562 L 0.226562 -5.851562 L 0.226562 -6.742188 L 1.066406 -6.742188 L 1.066406 -8.410156 L 2.203125 -9.097656 L 2.203125 -6.742188 L 3.351562 -6.742188 L 3.351562 -5.851562 L 2.203125 -5.851562 L 2.203125 -1.910156 C 2.203125 -1.585938 2.222656 -1.375 2.261719 -1.28125 C 2.304688 -1.1875 2.367188 -1.113281 2.460938 -1.058594 C 2.550781 -1.003906 2.679688 -0.976562 2.851562 -0.976562 C 2.976562 -0.976562 3.144531 -0.992188 3.351562 -1.023438 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-5">
-<path style="stroke:none;" d="M 1.179688 0 L 1.179688 -1.300781 L 2.480469 -1.300781 L 2.480469 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-6">
-<path style="stroke:none;" d="M 1.003906 0 L 1.003906 -9.304688 L 4.511719 -9.304688 C 5.128906 -9.304688 5.601562 -9.277344 5.929688 -9.21875 C 6.386719 -9.140625 6.769531 -8.996094 7.078125 -8.78125 C 7.386719 -8.566406 7.636719 -8.269531 7.824219 -7.882812 C 8.011719 -7.5 8.105469 -7.074219 8.105469 -6.613281 C 8.105469 -5.824219 7.855469 -5.152344 7.351562 -4.605469 C 6.847656 -4.058594 5.9375 -3.78125 4.621094 -3.78125 L 2.234375 -3.78125 L 2.234375 0 Z M 2.234375 -4.882812 L 4.640625 -4.882812 C 5.4375 -4.882812 6 -5.03125 6.335938 -5.324219 C 6.667969 -5.621094 6.835938 -6.039062 6.835938 -6.578125 C 6.835938 -6.964844 6.738281 -7.296875 6.542969 -7.574219 C 6.34375 -7.851562 6.085938 -8.035156 5.765625 -8.125 C 5.558594 -8.179688 5.171875 -8.207031 4.613281 -8.207031 L 2.234375 -8.207031 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-7">
-<path style="stroke:none;" d="M 0.804688 2.597656 L 0.679688 1.523438 C 0.929688 1.589844 1.148438 1.625 1.332031 1.625 C 1.585938 1.625 1.789062 1.582031 1.941406 1.5 C 2.09375 1.414062 2.21875 1.296875 2.316406 1.140625 C 2.390625 1.027344 2.503906 0.746094 2.664062 0.292969 C 2.6875 0.230469 2.722656 0.136719 2.765625 0.0117188 L 0.210938 -6.742188 L 1.441406 -6.742188 L 2.84375 -2.835938 C 3.027344 -2.34375 3.1875 -1.820312 3.332031 -1.277344 C 3.464844 -1.800781 3.621094 -2.3125 3.800781 -2.8125 L 5.242188 -6.742188 L 6.386719 -6.742188 L 3.820312 0.113281 C 3.546875 0.855469 3.332031 1.363281 3.179688 1.644531 C 2.976562 2.019531 2.746094 2.296875 2.480469 2.472656 C 2.21875 2.648438 1.90625 2.734375 1.542969 2.734375 C 1.324219 2.734375 1.078125 2.6875 0.804688 2.597656 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-8">
-<path style="stroke:none;" d="M 0.855469 0 L 0.855469 -9.304688 L 2 -9.304688 L 2 -5.96875 C 2.53125 -6.585938 3.207031 -6.894531 4.019531 -6.894531 C 4.519531 -6.894531 4.953125 -6.796875 5.320312 -6.597656 C 5.6875 -6.402344 5.949219 -6.128906 6.109375 -5.78125 C 6.269531 -5.433594 6.347656 -4.933594 6.347656 -4.273438 L 6.347656 0 L 5.203125 0 L 5.203125 -4.273438 C 5.203125 -4.84375 5.082031 -5.257812 4.832031 -5.519531 C 4.585938 -5.78125 4.234375 -5.910156 3.78125 -5.910156 C 3.445312 -5.910156 3.125 -5.820312 2.828125 -5.644531 C 2.53125 -5.46875 2.316406 -5.234375 2.191406 -4.933594 C 2.0625 -4.632812 2 -4.21875 2 -3.6875 L 2 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-9">
-<path style="stroke:none;" d="M 0.855469 0 L 0.855469 -6.742188 L 1.886719 -6.742188 L 1.886719 -5.78125 C 2.382812 -6.523438 3.09375 -6.894531 4.03125 -6.894531 C 4.4375 -6.894531 4.808594 -6.820312 5.152344 -6.675781 C 5.492188 -6.527344 5.746094 -6.335938 5.914062 -6.101562 C 6.085938 -5.863281 6.203125 -5.582031 6.273438 -5.257812 C 6.3125 -5.046875 6.335938 -4.675781 6.335938 -4.144531 L 6.335938 0 L 5.191406 0 L 5.191406 -4.101562 C 5.191406 -4.566406 5.148438 -4.914062 5.058594 -5.144531 C 4.96875 -5.375 4.8125 -5.558594 4.585938 -5.695312 C 4.359375 -5.835938 4.09375 -5.902344 3.789062 -5.902344 C 3.304688 -5.902344 2.882812 -5.75 2.53125 -5.441406 C 2.175781 -5.132812 2 -4.546875 2 -3.679688 L 2 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-10">
-<path style="stroke:none;" d="M 0.855469 2.582031 L 0.855469 -6.742188 L 1.898438 -6.742188 L 1.898438 -5.867188 C 2.144531 -6.207031 2.421875 -6.464844 2.730469 -6.636719 C 3.039062 -6.808594 3.414062 -6.894531 3.851562 -6.894531 C 4.429688 -6.894531 4.9375 -6.746094 5.375 -6.449219 C 5.816406 -6.152344 6.148438 -5.734375 6.375 -5.195312 C 6.597656 -4.65625 6.710938 -4.066406 6.710938 -3.421875 C 6.710938 -2.730469 6.585938 -2.109375 6.339844 -1.558594 C 6.089844 -1.007812 5.730469 -0.582031 5.257812 -0.289062 C 4.785156 0.00390625 4.289062 0.152344 3.769531 0.152344 C 3.390625 0.152344 3.046875 0.0703125 2.746094 -0.0898438 C 2.441406 -0.25 2.195312 -0.453125 2 -0.699219 L 2 2.582031 Z M 1.890625 -3.332031 C 1.890625 -2.464844 2.066406 -1.824219 2.417969 -1.410156 C 2.769531 -0.996094 3.195312 -0.789062 3.695312 -0.789062 C 4.203125 -0.789062 4.636719 -1 5 -1.429688 C 5.359375 -1.859375 5.542969 -2.527344 5.542969 -3.429688 C 5.542969 -4.289062 5.363281 -4.929688 5.011719 -5.359375 C 4.65625 -5.785156 4.234375 -6 3.746094 -6 C 3.257812 -6 2.828125 -5.769531 2.453125 -5.316406 C 2.078125 -4.859375 1.890625 -4.199219 1.890625 -3.332031 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-11">
-<path style="stroke:none;" d="M 1.910156 0 L 0.851562 0 L 0.851562 -9.304688 L 1.992188 -9.304688 L 1.992188 -5.984375 C 2.476562 -6.589844 3.089844 -6.894531 3.839844 -6.894531 C 4.253906 -6.894531 4.648438 -6.808594 5.019531 -6.644531 C 5.390625 -6.476562 5.691406 -6.242188 5.933594 -5.9375 C 6.171875 -5.636719 6.359375 -5.269531 6.492188 -4.84375 C 6.628906 -4.414062 6.695312 -3.957031 6.695312 -3.472656 C 6.695312 -2.316406 6.410156 -1.425781 5.839844 -0.792969 C 5.269531 -0.164062 4.582031 0.152344 3.78125 0.152344 C 2.988281 0.152344 2.363281 -0.179688 1.910156 -0.84375 Z M 1.898438 -3.421875 C 1.898438 -2.613281 2.007812 -2.027344 2.226562 -1.667969 C 2.585938 -1.082031 3.074219 -0.789062 3.6875 -0.789062 C 4.1875 -0.789062 4.617188 -1.003906 4.984375 -1.4375 C 5.347656 -1.871094 5.527344 -2.519531 5.527344 -3.375 C 5.527344 -4.257812 5.355469 -4.90625 5.003906 -5.324219 C 4.65625 -5.742188 4.234375 -5.953125 3.738281 -5.953125 C 3.238281 -5.953125 2.808594 -5.738281 2.445312 -5.304688 C 2.082031 -4.871094 1.898438 -4.242188 1.898438 -3.421875 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-12">
-<path style="stroke:none;" d="M 0.863281 -7.992188 L 0.863281 -9.304688 L 2.007812 -9.304688 L 2.007812 -7.992188 Z M 0.863281 0 L 0.863281 -6.742188 L 2.007812 -6.742188 L 2.007812 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-13">
-<path style="stroke:none;" d="M 5.230469 0 L 5.230469 -0.851562 C 4.804688 -0.183594 4.175781 0.152344 3.34375 0.152344 C 2.808594 0.152344 2.3125 0.00390625 1.863281 -0.292969 C 1.414062 -0.589844 1.0625 -1 0.816406 -1.53125 C 0.570312 -2.0625 0.445312 -2.675781 0.445312 -3.363281 C 0.445312 -4.035156 0.554688 -4.648438 0.78125 -5.195312 C 1.003906 -5.742188 1.339844 -6.164062 1.789062 -6.457031 C 2.238281 -6.75 2.738281 -6.894531 3.292969 -6.894531 C 3.699219 -6.894531 4.0625 -6.808594 4.378906 -6.636719 C 4.695312 -6.464844 4.957031 -6.242188 5.15625 -5.96875 L 5.15625 -9.304688 L 6.289062 -9.304688 L 6.289062 0 Z M 1.617188 -3.363281 C 1.617188 -2.5 1.800781 -1.855469 2.164062 -1.429688 C 2.527344 -1 2.957031 -0.789062 3.453125 -0.789062 C 3.953125 -0.789062 4.375 -0.992188 4.726562 -1.398438 C 5.074219 -1.808594 5.25 -2.429688 5.25 -3.269531 C 5.25 -4.191406 5.070312 -4.867188 4.714844 -5.300781 C 4.359375 -5.730469 3.921875 -5.949219 3.402344 -5.949219 C 2.894531 -5.949219 2.46875 -5.742188 2.128906 -5.324219 C 1.789062 -4.910156 1.617188 -4.257812 1.617188 -3.363281 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-14">
-<path style="stroke:none;" d="M 4.84375 0 L 3.699219 0 L 3.699219 -7.28125 C 3.425781 -7.019531 3.066406 -6.757812 2.617188 -6.492188 C 2.171875 -6.230469 1.769531 -6.035156 1.414062 -5.902344 L 1.414062 -7.007812 C 2.054688 -7.308594 2.613281 -7.671875 3.089844 -8.101562 C 3.570312 -8.527344 3.90625 -8.941406 4.105469 -9.34375 L 4.84375 -9.34375 Z "/>
-</symbol>
-</g>
-<clipPath id="clip1">
-  <path d="M 89 21 L 91 21 L 91 221 L 89 221 Z "/>
-</clipPath>
-<clipPath id="clip2">
-  <path d="M 201 21 L 203 21 L 203 221 L 201 221 Z "/>
-</clipPath>
-<clipPath id="clip3">
-  <path d="M 313 21 L 315 21 L 315 221 L 313 221 Z "/>
-</clipPath>
-<clipPath id="clip4">
-  <path d="M 33 180 L 355 180 L 355 182 L 33 182 Z "/>
-</clipPath>
-<clipPath id="clip5">
-  <path d="M 33 146 L 355 146 L 355 148 L 33 148 Z "/>
-</clipPath>
-<clipPath id="clip6">
-  <path d="M 33 120 L 355 120 L 355 122 L 33 122 Z "/>
-</clipPath>
-<clipPath id="clip7">
-  <path d="M 33 95 L 355 95 L 355 97 L 33 97 Z "/>
-</clipPath>
-<clipPath id="clip8">
-  <path d="M 33 61 L 355 61 L 355 63 L 33 63 Z "/>
-</clipPath>
-</defs>
-<g id="surface11">
-<g clip-path="url(#clip1)" clip-rule="nonzero">
-<path style="fill:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:0.5;stroke-dasharray:1,2;stroke-miterlimit:3.25;" d="M 90.226562 220.007812 L 90.226562 21 "/>
-</g>
-<g clip-path="url(#clip2)" clip-rule="nonzero">
-<path style="fill:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:0.5;stroke-dasharray:1,2;stroke-miterlimit:3.25;" d="M 201.996094 220.007812 L 201.996094 21 "/>
-</g>
-<g clip-path="url(#clip3)" clip-rule="nonzero">
-<path style="fill:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:0.5;stroke-dasharray:1,2;stroke-miterlimit:3.25;" d="M 313.761719 220.007812 L 313.761719 21 "/>
-</g>
-<g clip-path="url(#clip4)" clip-rule="nonzero">
-<path style="fill:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:0.5;stroke-dasharray:1,2;stroke-miterlimit:3.25;" d="M 33 180.734375 L 355 180.734375 "/>
-</g>
-<g clip-path="url(#clip5)" clip-rule="nonzero">
-<path style="fill:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:0.5;stroke-dasharray:1,2;stroke-miterlimit:3.25;" d="M 33 146.960938 L 355 146.960938 "/>
-</g>
-<g clip-path="url(#clip6)" clip-rule="nonzero">
-<path style="fill:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:0.5;stroke-dasharray:1,2;stroke-miterlimit:3.25;" d="M 33 121.410156 L 355 121.410156 "/>
-</g>
-<g clip-path="url(#clip7)" clip-rule="nonzero">
-<path style="fill:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:0.5;stroke-dasharray:1,2;stroke-miterlimit:3.25;" d="M 33 95.859375 L 355 95.859375 "/>
-</g>
-<g clip-path="url(#clip8)" clip-rule="nonzero">
-<path style="fill:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:0.5;stroke-dasharray:1,2;stroke-miterlimit:3.25;" d="M 33 62.082031 L 355 62.082031 "/>
-</g>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 49.128906 169 C 49.128906 168.167969 48.800781 167.375 48.214844 166.785156 C 47.625 166.199219 46.832031 165.871094 46 165.871094 C 45.167969 165.871094 44.375 166.199219 43.785156 166.785156 C 43.199219 167.375 42.871094 168.167969 42.871094 169 C 42.871094 169.832031 43.199219 170.625 43.785156 171.214844 C 44.375 171.800781 45.167969 172.128906 46 172.128906 C 46.832031 172.128906 47.625 171.800781 48.214844 171.214844 C 48.800781 170.625 49.128906 169.832031 49.128906 169 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 82.128906 169 C 82.128906 168.167969 81.800781 167.375 81.214844 166.785156 C 80.625 166.199219 79.832031 165.871094 79 165.871094 C 78.167969 165.871094 77.375 166.199219 76.785156 166.785156 C 76.199219 167.375 75.871094 168.167969 75.871094 169 C 75.871094 169.832031 76.199219 170.625 76.785156 171.214844 C 77.375 171.800781 78.167969 172.128906 79 172.128906 C 79.832031 172.128906 80.625 171.800781 81.214844 171.214844 C 81.800781 170.625 82.128906 169.832031 82.128906 169 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 116.128906 167 C 116.128906 166.167969 115.800781 165.375 115.214844 164.785156 C 114.625 164.199219 113.832031 163.871094 113 163.871094 C 112.167969 163.871094 111.375 164.199219 110.785156 164.785156 C 110.199219 165.375 109.871094 166.167969 109.871094 167 C 109.871094 167.832031 110.199219 168.625 110.785156 169.214844 C 111.375 169.800781 112.167969 170.128906 113 170.128906 C 113.832031 170.128906 114.625 169.800781 115.214844 169.214844 C 115.800781 168.625 116.128906 167.832031 116.128906 167 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 150.128906 159 C 150.128906 158.167969 149.800781 157.375 149.214844 156.785156 C 148.625 156.199219 147.832031 155.871094 147 155.871094 C 146.167969 155.871094 145.375 156.199219 144.785156 156.785156 C 144.199219 157.375 143.871094 158.167969 143.871094 159 C 143.871094 159.832031 144.199219 160.625 144.785156 161.214844 C 145.375 161.800781 146.167969 162.128906 147 162.128906 C 147.832031 162.128906 148.625 161.800781 149.214844 161.214844 C 149.800781 160.625 150.128906 159.832031 150.128906 159 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 183.128906 146 C 183.128906 145.167969 182.800781 144.375 182.214844 143.785156 C 181.625 143.199219 180.832031 142.871094 180 142.871094 C 179.167969 142.871094 178.375 143.199219 177.785156 143.785156 C 177.199219 144.375 176.871094 145.167969 176.871094 146 C 176.871094 146.832031 177.199219 147.625 177.785156 148.214844 C 178.375 148.800781 179.167969 149.128906 180 149.128906 C 180.832031 149.128906 181.625 148.800781 182.214844 148.214844 C 182.800781 147.625 183.128906 146.832031 183.128906 146 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 217.128906 128 C 217.128906 127.167969 216.800781 126.375 216.214844 125.785156 C 215.625 125.199219 214.832031 124.871094 214 124.871094 C 213.167969 124.871094 212.375 125.199219 211.785156 125.785156 C 211.199219 126.375 210.871094 127.167969 210.871094 128 C 210.871094 128.832031 211.199219 129.625 211.785156 130.214844 C 212.375 130.800781 213.167969 131.128906 214 131.128906 C 214.832031 131.128906 215.625 130.800781 216.214844 130.214844 C 216.800781 129.625 217.128906 128.832031 217.128906 128 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 251.128906 108 C 251.128906 107.167969 250.800781 106.375 250.214844 105.785156 C 249.625 105.199219 248.832031 104.871094 248 104.871094 C 247.167969 104.871094 246.375 105.199219 245.785156 105.785156 C 245.199219 106.375 244.871094 107.167969 244.871094 108 C 244.871094 108.832031 245.199219 109.625 245.785156 110.214844 C 246.375 110.800781 247.167969 111.128906 248 111.128906 C 248.832031 111.128906 249.625 110.800781 250.214844 110.214844 C 250.800781 109.625 251.128906 108.832031 251.128906 108 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 284.128906 85 C 284.128906 84.167969 283.800781 83.375 283.214844 82.785156 C 282.625 82.199219 281.832031 81.871094 281 81.871094 C 280.167969 81.871094 279.375 82.199219 278.785156 82.785156 C 278.199219 83.375 277.871094 84.167969 277.871094 85 C 277.871094 85.832031 278.199219 86.625 278.785156 87.214844 C 279.375 87.800781 280.167969 88.128906 281 88.128906 C 281.832031 88.128906 282.625 87.800781 283.214844 87.214844 C 283.800781 86.625 284.128906 85.832031 284.128906 85 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 318.128906 59 C 318.128906 58.167969 317.800781 57.375 317.214844 56.785156 C 316.625 56.199219 315.832031 55.871094 315 55.871094 C 314.167969 55.871094 313.375 56.199219 312.785156 56.785156 C 312.199219 57.375 311.871094 58.167969 311.871094 59 C 311.871094 59.832031 312.199219 60.625 312.785156 61.214844 C 313.375 61.800781 314.167969 62.128906 315 62.128906 C 315.832031 62.128906 316.625 61.800781 317.214844 61.214844 C 317.800781 60.625 318.128906 59.832031 318.128906 59 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 352.128906 31 C 352.128906 30.167969 351.800781 29.375 351.214844 28.785156 C 350.625 28.199219 349.832031 27.871094 349 27.871094 C 348.167969 27.871094 347.375 28.199219 346.785156 28.785156 C 346.199219 29.375 345.871094 30.167969 345.871094 31 C 345.871094 31.832031 346.199219 32.625 346.785156 33.214844 C 347.375 33.800781 348.167969 34.128906 349 34.128906 C 349.832031 34.128906 350.625 33.800781 351.214844 33.214844 C 351.800781 32.625 352.128906 31.832031 352.128906 31 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 49.128906 205 C 49.128906 204.167969 48.800781 203.375 48.214844 202.785156 C 47.625 202.199219 46.832031 201.871094 46 201.871094 C 45.167969 201.871094 44.375 202.199219 43.785156 202.785156 C 43.199219 203.375 42.871094 204.167969 42.871094 205 C 42.871094 205.832031 43.199219 206.625 43.785156 207.214844 C 44.375 207.800781 45.167969 208.128906 46 208.128906 C 46.832031 208.128906 47.625 207.800781 48.214844 207.214844 C 48.800781 206.625 49.128906 205.832031 49.128906 205 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 82.128906 199 C 82.128906 198.167969 81.800781 197.375 81.214844 196.785156 C 80.625 196.199219 79.832031 195.871094 79 195.871094 C 78.167969 195.871094 77.375 196.199219 76.785156 196.785156 C 76.199219 197.375 75.871094 198.167969 75.871094 199 C 75.871094 199.832031 76.199219 200.625 76.785156 201.214844 C 77.375 201.800781 78.167969 202.128906 79 202.128906 C 79.832031 202.128906 80.625 201.800781 81.214844 201.214844 C 81.800781 200.625 82.128906 199.832031 82.128906 199 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 116.128906 190 C 116.128906 189.167969 115.800781 188.375 115.214844 187.785156 C 114.625 187.199219 113.832031 186.871094 113 186.871094 C 112.167969 186.871094 111.375 187.199219 110.785156 187.785156 C 110.199219 188.375 109.871094 189.167969 109.871094 190 C 109.871094 190.832031 110.199219 191.625 110.785156 192.214844 C 111.375 192.800781 112.167969 193.128906 113 193.128906 C 113.832031 193.128906 114.625 192.800781 115.214844 192.214844 C 115.800781 191.625 116.128906 190.832031 116.128906 190 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 150.128906 177 C 150.128906 176.167969 149.800781 175.375 149.214844 174.785156 C 148.625 174.199219 147.832031 173.871094 147 173.871094 C 146.167969 173.871094 145.375 174.199219 144.785156 174.785156 C 144.199219 175.375 143.871094 176.167969 143.871094 177 C 143.871094 177.832031 144.199219 178.625 144.785156 179.214844 C 145.375 179.800781 146.167969 180.128906 147 180.128906 C 147.832031 180.128906 148.625 179.800781 149.214844 179.214844 C 149.800781 178.625 150.128906 177.832031 150.128906 177 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 183.128906 159 C 183.128906 158.167969 182.800781 157.375 182.214844 156.785156 C 181.625 156.199219 180.832031 155.871094 180 155.871094 C 179.167969 155.871094 178.375 156.199219 177.785156 156.785156 C 177.199219 157.375 176.871094 158.167969 176.871094 159 C 176.871094 159.832031 177.199219 160.625 177.785156 161.214844 C 178.375 161.800781 179.167969 162.128906 180 162.128906 C 180.832031 162.128906 181.625 161.800781 182.214844 161.214844 C 182.800781 160.625 183.128906 159.832031 183.128906 159 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 217.128906 138 C 217.128906 137.167969 216.800781 136.375 216.214844 135.785156 C 215.625 135.199219 214.832031 134.871094 214 134.871094 C 213.167969 134.871094 212.375 135.199219 211.785156 135.785156 C 211.199219 136.375 210.871094 137.167969 210.871094 138 C 210.871094 138.832031 211.199219 139.625 211.785156 140.214844 C 212.375 140.800781 213.167969 141.128906 214 141.128906 C 214.832031 141.128906 215.625 140.800781 216.214844 140.214844 C 216.800781 139.625 217.128906 138.832031 217.128906 138 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 251.128906 115 C 251.128906 114.167969 250.800781 113.375 250.214844 112.785156 C 249.625 112.199219 248.832031 111.871094 248 111.871094 C 247.167969 111.871094 246.375 112.199219 245.785156 112.785156 C 245.199219 113.375 244.871094 114.167969 244.871094 115 C 244.871094 115.832031 245.199219 116.625 245.785156 117.214844 C 246.375 117.800781 247.167969 118.128906 248 118.128906 C 248.832031 118.128906 249.625 117.800781 250.214844 117.214844 C 250.800781 116.625 251.128906 115.832031 251.128906 115 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 284.128906 91 C 284.128906 90.167969 283.800781 89.375 283.214844 88.785156 C 282.625 88.199219 281.832031 87.871094 281 87.871094 C 280.167969 87.871094 279.375 88.199219 278.785156 88.785156 C 278.199219 89.375 277.871094 90.167969 277.871094 91 C 277.871094 91.832031 278.199219 92.625 278.785156 93.214844 C 279.375 93.800781 280.167969 94.128906 281 94.128906 C 281.832031 94.128906 282.625 93.800781 283.214844 93.214844 C 283.800781 92.625 284.128906 91.832031 284.128906 91 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 318.128906 65 C 318.128906 64.167969 317.800781 63.375 317.214844 62.785156 C 316.625 62.199219 315.832031 61.871094 315 61.871094 C 314.167969 61.871094 313.375 62.199219 312.785156 62.785156 C 312.199219 63.375 311.871094 64.167969 311.871094 65 C 311.871094 65.832031 312.199219 66.625 312.785156 67.214844 C 313.375 67.800781 314.167969 68.128906 315 68.128906 C 315.832031 68.128906 316.625 67.800781 317.214844 67.214844 C 317.800781 66.625 318.128906 65.832031 318.128906 65 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 352.128906 38 C 352.128906 37.167969 351.800781 36.375 351.214844 35.785156 C 350.625 35.199219 349.832031 34.871094 349 34.871094 C 348.167969 34.871094 347.375 35.199219 346.785156 35.785156 C 346.199219 36.375 345.871094 37.167969 345.871094 38 C 345.871094 38.832031 346.199219 39.625 346.785156 40.214844 C 347.375 40.800781 348.167969 41.128906 349 41.128906 C 349.832031 41.128906 350.625 40.800781 351.214844 40.214844 C 351.800781 39.625 352.128906 38.832031 352.128906 38 Z "/>
-<path style="fill:none;stroke-width:0.5;stroke-linecap:square;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 220.007812 L 33 220.007812 "/>
-<path style="fill:none;stroke-width:0.5;stroke-linecap:square;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 220.007812 L 33 21 "/>
-<path style="fill:none;stroke-width:0.5;stroke-linecap:square;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 21 L 355 21 "/>
-<path style="fill:none;stroke-width:0.5;stroke-linecap:square;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 21 L 355 220.007812 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 90.226562 220.007812 L 90.226562 216.785156 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-1" x="84.725786" y="232.006944"/>
-  <use xlink:href="#glyph0-2" x="90.28731" y="232.006944"/>
-</g>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 201.996094 220.007812 L 201.996094 216.785156 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-1" x="193.49443" y="232.006944"/>
-  <use xlink:href="#glyph0-2" x="199.055953" y="232.006944"/>
-  <use xlink:href="#glyph0-2" x="204.617477" y="232.006944"/>
-</g>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 313.761719 220.007812 L 313.761719 216.785156 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-1" x="302.763074" y="232.006944"/>
-  <use xlink:href="#glyph0-2" x="308.324597" y="232.006944"/>
-  <use xlink:href="#glyph0-2" x="313.88612" y="232.006944"/>
-  <use xlink:href="#glyph0-2" x="319.447644" y="232.006944"/>
-</g>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 45.75 220.007812 L 45.75 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 56.578125 220.007812 L 56.578125 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 65.429688 220.007812 L 65.429688 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 72.914062 220.007812 L 72.914062 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 79.394531 220.007812 L 79.394531 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 85.113281 220.007812 L 85.113281 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 123.871094 220.007812 L 123.871094 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 143.554688 220.007812 L 143.554688 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 157.515625 220.007812 L 157.515625 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 168.347656 220.007812 L 168.347656 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 177.199219 220.007812 L 177.199219 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 184.679688 220.007812 L 184.679688 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 191.164062 220.007812 L 191.164062 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 196.878906 220.007812 L 196.878906 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 235.640625 220.007812 L 235.640625 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 255.320312 220.007812 L 255.320312 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 269.285156 220.007812 L 269.285156 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 280.117188 220.007812 L 280.117188 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 288.96875 220.007812 L 288.96875 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 296.449219 220.007812 L 296.449219 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 302.929688 220.007812 L 302.929688 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 308.648438 220.007812 L 308.648438 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 347.410156 220.007812 L 347.410156 218.398438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 180.734375 L 36.21875 180.734375 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-3" x="24" y="183.235493"/>
-</g>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 146.960938 L 36.21875 146.960938 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-4" x="24" y="149.45964"/>
-</g>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 121.410156 L 36.21875 121.410156 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-1" x="19" y="123.909193"/>
-  <use xlink:href="#glyph0-2" x="24.561523" y="123.909193"/>
-</g>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 95.859375 L 36.21875 95.859375 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-3" x="19" y="98.358747"/>
-  <use xlink:href="#glyph0-2" x="24.561523" y="98.358747"/>
-</g>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 62.082031 L 36.21875 62.082031 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-4" x="19" y="64.582894"/>
-  <use xlink:href="#glyph0-2" x="24.561523" y="64.582894"/>
-</g>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 206.285156 L 34.609375 206.285156 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 165.789062 L 34.609375 165.789062 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 155.183594 L 34.609375 155.183594 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 140.238281 L 34.609375 140.238281 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 134.558594 L 34.609375 134.558594 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 129.632812 L 34.609375 129.632812 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 125.292969 L 34.609375 125.292969 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 80.914062 L 34.609375 80.914062 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 70.308594 L 34.609375 70.308594 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 33 36.53125 L 34.609375 36.53125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 90.226562 21 L 90.226562 24.21875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 201.996094 21 L 201.996094 24.21875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 313.761719 21 L 313.761719 24.21875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 45.75 21 L 45.75 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 56.578125 21 L 56.578125 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 65.429688 21 L 65.429688 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 72.914062 21 L 72.914062 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 79.394531 21 L 79.394531 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 85.113281 21 L 85.113281 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 123.871094 21 L 123.871094 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 143.554688 21 L 143.554688 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 157.515625 21 L 157.515625 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 168.347656 21 L 168.347656 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 177.199219 21 L 177.199219 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 184.679688 21 L 184.679688 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 191.164062 21 L 191.164062 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 196.878906 21 L 196.878906 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 235.640625 21 L 235.640625 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 255.320312 21 L 255.320312 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 269.285156 21 L 269.285156 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 280.117188 21 L 280.117188 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 288.96875 21 L 288.96875 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 296.449219 21 L 296.449219 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 302.929688 21 L 302.929688 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 308.648438 21 L 308.648438 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 347.410156 21 L 347.410156 22.609375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 180.734375 L 351.78125 180.734375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 146.960938 L 351.78125 146.960938 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 121.410156 L 351.78125 121.410156 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 95.859375 L 351.78125 95.859375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 62.082031 L 351.78125 62.082031 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 206.285156 L 353.390625 206.285156 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 165.789062 L 353.390625 165.789062 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 155.183594 L 353.390625 155.183594 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 140.238281 L 353.390625 140.238281 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 134.558594 L 353.390625 134.558594 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 129.632812 L 353.390625 129.632812 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 125.292969 L 353.390625 125.292969 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 80.914062 L 353.390625 80.914062 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 70.308594 L 353.390625 70.308594 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 36.53125 L 353.390625 36.53125 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-5" x="172.5" y="251.006944"/>
-  <use xlink:href="#glyph0-6" x="178.608398" y="251.006944"/>
-  <use xlink:href="#glyph0-7" x="184.169922" y="251.006944"/>
-  <use xlink:href="#glyph0-8" x="189.731445" y="251.006944"/>
-  <use xlink:href="#glyph0-9" x="194.731445" y="251.006944"/>
-  <use xlink:href="#glyph0-10" x="197.509766" y="251.006944"/>
-  <use xlink:href="#glyph0-11" x="199.731445" y="251.006944"/>
-  <use xlink:href="#glyph0-7" x="205.292969" y="251.006944"/>
-  <use xlink:href="#glyph0-12" x="210.854492" y="251.006944"/>
-</g>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph1-1" x="9" y="140.003472"/>
-  <use xlink:href="#glyph1-2" x="9" y="133.33355"/>
-  <use xlink:href="#glyph1-3" x="9" y="127.772027"/>
-  <use xlink:href="#glyph1-4" x="9" y="122.772027"/>
-  <use xlink:href="#glyph1-5" x="9" y="117.210503"/>
-  <use xlink:href="#glyph1-6" x="9" y="111.64898"/>
-  <use xlink:href="#glyph1-7" x="9" y="106.087457"/>
-</g>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph2-1" x="122" y="12"/>
-  <use xlink:href="#glyph2-2" x="130.666016" y="12"/>
-  <use xlink:href="#glyph2-3" x="137.339844" y="12"/>
-  <use xlink:href="#glyph2-4" x="147.335938" y="12"/>
-  <use xlink:href="#glyph2-5" x="154.009766" y="12"/>
-  <use xlink:href="#glyph2-6" x="156.675781" y="12"/>
-  <use xlink:href="#glyph2-7" x="159.341797" y="12"/>
-  <use xlink:href="#glyph2-8" x="166.015625" y="12"/>
-  <use xlink:href="#glyph2-5" x="169.349609" y="12"/>
-  <use xlink:href="#glyph2-2" x="172.015625" y="12"/>
-  <use xlink:href="#glyph2-9" x="178.689453" y="12"/>
-</g>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph2-8" x="188" y="12"/>
-  <use xlink:href="#glyph2-5" x="191.333984" y="12"/>
-  <use xlink:href="#glyph2-3" x="194" y="12"/>
-  <use xlink:href="#glyph2-10" x="203.996094" y="12"/>
-</g>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph2-2" x="214" y="12"/>
-  <use xlink:href="#glyph2-11" x="220.673828" y="12"/>
-</g>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph2-3" x="227" y="12"/>
-  <use xlink:href="#glyph2-2" x="236.996094" y="12"/>
-  <use xlink:href="#glyph2-12" x="243.669922" y="12"/>
-  <use xlink:href="#glyph2-13" x="250.34375" y="12"/>
-  <use xlink:href="#glyph2-6" x="257.017578" y="12"/>
-  <use xlink:href="#glyph2-10" x="259.683594" y="12"/>
-</g>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 382.148438 116 C 382.148438 115.164062 381.816406 114.363281 381.226562 113.773438 C 380.636719 113.183594 379.835938 112.851562 379 112.851562 C 378.164062 112.851562 377.363281 113.183594 376.773438 113.773438 C 376.183594 114.363281 375.851562 115.164062 375.851562 116 C 375.851562 116.835938 376.183594 117.636719 376.773438 118.226562 C 377.363281 118.816406 378.164062 119.148438 379 119.148438 C 379.835938 119.148438 380.636719 118.816406 381.226562 118.226562 C 381.816406 117.636719 382.148438 116.835938 382.148438 116 Z "/>
-<g style="fill:rgb(0%,0%,0%);fill-opacity:1;">
-  <use xlink:href="#glyph3-1" x="391" y="120.28418"/>
-  <use xlink:href="#glyph3-2" x="399.670898" y="120.28418"/>
-  <use xlink:href="#glyph3-2" x="406.901367" y="120.28418"/>
-  <use xlink:href="#glyph3-3" x="414.131836" y="120.28418"/>
-  <use xlink:href="#glyph3-4" x="420.631836" y="120.28418"/>
-</g>
-<g style="fill:rgb(0%,0%,0%);fill-opacity:1;">
-  <use xlink:href="#glyph3-5" x="424" y="120.28418"/>
-</g>
-<g style="fill:rgb(0%,0%,0%);fill-opacity:1;">
-  <use xlink:href="#glyph3-6" x="428" y="120.28418"/>
-  <use xlink:href="#glyph3-7" x="436.670898" y="120.28418"/>
-  <use xlink:href="#glyph3-4" x="443.170898" y="120.28418"/>
-  <use xlink:href="#glyph3-8" x="446.783203" y="120.28418"/>
-  <use xlink:href="#glyph3-2" x="454.013672" y="120.28418"/>
-  <use xlink:href="#glyph3-9" x="461.244141" y="120.28418"/>
-</g>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 382.148438 139 C 382.148438 138.164062 381.816406 137.363281 381.226562 136.773438 C 380.636719 136.183594 379.835938 135.851562 379 135.851562 C 378.164062 135.851562 377.363281 136.183594 376.773438 136.773438 C 376.183594 137.363281 375.851562 138.164062 375.851562 139 C 375.851562 139.835938 376.183594 140.636719 376.773438 141.226562 C 377.363281 141.816406 378.164062 142.148438 379 142.148438 C 379.835938 142.148438 380.636719 141.816406 381.226562 141.226562 C 381.816406 140.636719 382.148438 139.835938 382.148438 139 Z "/>
-<g style="fill:rgb(0%,0%,0%);fill-opacity:1;">
-  <use xlink:href="#glyph3-10" x="391" y="143.28418"/>
-  <use xlink:href="#glyph3-7" x="398.230469" y="143.28418"/>
-  <use xlink:href="#glyph3-11" x="404.730469" y="143.28418"/>
-  <use xlink:href="#glyph3-12" x="411.960938" y="143.28418"/>
-  <use xlink:href="#glyph3-9" x="414.849609" y="143.28418"/>
-  <use xlink:href="#glyph3-13" x="422.080078" y="143.28418"/>
-  <use xlink:href="#glyph3-14" x="429.310547" y="143.28418"/>
-  <use xlink:href="#glyph3-14" x="436.541016" y="143.28418"/>
-</g>
-</g>
-</svg>
diff --git a/tmap/lib/pybind11/docs/pybind11_vs_boost_python2.svg b/tmap/lib/pybind11/docs/pybind11_vs_boost_python2.svg
deleted file mode 100644
index 5ed6530..0000000
--- a/tmap/lib/pybind11/docs/pybind11_vs_boost_python2.svg
+++ /dev/null
@@ -1,427 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="468pt" height="246pt" viewBox="0 0 468 246" version="1.1">
-<defs>
-<g>
-<symbol overflow="visible" id="glyph0-0">
-<path style="stroke:none;" d=""/>
-</symbol>
-<symbol overflow="visible" id="glyph0-1">
-<path style="stroke:none;" d="M 3.726562 0 L 2.847656 0 L 2.847656 -5.601562 C 2.636719 -5.398438 2.359375 -5.195312 2.015625 -4.996094 C 1.671875 -4.792969 1.363281 -4.640625 1.089844 -4.539062 L 1.089844 -5.390625 C 1.582031 -5.621094 2.011719 -5.902344 2.378906 -6.230469 C 2.746094 -6.558594 3.007812 -6.878906 3.160156 -7.1875 L 3.726562 -7.1875 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-2">
-<path style="stroke:none;" d="M 0.414062 -3.53125 C 0.414062 -4.375 0.503906 -5.058594 0.675781 -5.574219 C 0.851562 -6.089844 1.109375 -6.488281 1.453125 -6.765625 C 1.796875 -7.046875 2.226562 -7.1875 2.75 -7.1875 C 3.132812 -7.1875 3.46875 -7.109375 3.757812 -6.957031 C 4.046875 -6.800781 4.289062 -6.578125 4.476562 -6.285156 C 4.664062 -5.996094 4.8125 -5.640625 4.921875 -5.222656 C 5.03125 -4.804688 5.082031 -4.238281 5.082031 -3.53125 C 5.082031 -2.691406 4.996094 -2.011719 4.824219 -1.496094 C 4.652344 -0.980469 4.394531 -0.582031 4.050781 -0.300781 C 3.707031 -0.0195312 3.273438 0.121094 2.75 0.121094 C 2.058594 0.121094 1.515625 -0.125 1.125 -0.621094 C 0.652344 -1.214844 0.414062 -2.1875 0.414062 -3.53125 Z M 1.320312 -3.53125 C 1.320312 -2.355469 1.457031 -1.574219 1.730469 -1.183594 C 2.007812 -0.796875 2.34375 -0.601562 2.75 -0.601562 C 3.152344 -0.601562 3.492188 -0.796875 3.765625 -1.1875 C 4.042969 -1.578125 4.179688 -2.359375 4.179688 -3.53125 C 4.179688 -4.710938 4.042969 -5.492188 3.765625 -5.878906 C 3.492188 -6.265625 3.148438 -6.460938 2.738281 -6.460938 C 2.335938 -6.460938 2.011719 -6.289062 1.773438 -5.945312 C 1.46875 -5.511719 1.320312 -4.707031 1.320312 -3.53125 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-3">
-<path style="stroke:none;" d="M 0.820312 0 L 0.820312 -7.15625 L 5.648438 -7.15625 L 5.648438 -6.3125 L 1.765625 -6.3125 L 1.765625 -4.097656 L 5.125 -4.097656 L 5.125 -3.25 L 1.765625 -3.25 L 1.765625 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-4">
-<path style="stroke:none;" d="M 4.058594 0 L 4.058594 -0.761719 C 3.65625 -0.175781 3.105469 0.117188 2.414062 0.117188 C 2.105469 0.117188 1.820312 0.0585938 1.554688 -0.0585938 C 1.289062 -0.175781 1.09375 -0.324219 0.964844 -0.5 C 0.835938 -0.679688 0.746094 -0.894531 0.695312 -1.152344 C 0.65625 -1.324219 0.640625 -1.597656 0.640625 -1.972656 L 0.640625 -5.1875 L 1.519531 -5.1875 L 1.519531 -2.308594 C 1.519531 -1.851562 1.535156 -1.542969 1.570312 -1.382812 C 1.625 -1.152344 1.746094 -0.96875 1.921875 -0.835938 C 2.101562 -0.703125 2.324219 -0.640625 2.585938 -0.640625 C 2.851562 -0.640625 3.097656 -0.707031 3.328125 -0.84375 C 3.5625 -0.976562 3.726562 -1.160156 3.820312 -1.394531 C 3.917969 -1.625 3.964844 -1.964844 3.964844 -2.40625 L 3.964844 -5.1875 L 4.84375 -5.1875 L 4.84375 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-5">
-<path style="stroke:none;" d="M 0.660156 0 L 0.660156 -5.1875 L 1.449219 -5.1875 L 1.449219 -4.449219 C 1.832031 -5.019531 2.382812 -5.304688 3.101562 -5.304688 C 3.414062 -5.304688 3.699219 -5.246094 3.960938 -5.132812 C 4.222656 -5.023438 4.421875 -4.875 4.550781 -4.691406 C 4.679688 -4.507812 4.773438 -4.292969 4.824219 -4.042969 C 4.855469 -3.878906 4.875 -3.59375 4.875 -3.1875 L 4.875 0 L 3.992188 0 L 3.992188 -3.15625 C 3.992188 -3.511719 3.960938 -3.78125 3.890625 -3.957031 C 3.824219 -4.132812 3.703125 -4.277344 3.527344 -4.382812 C 3.351562 -4.488281 3.148438 -4.539062 2.914062 -4.539062 C 2.539062 -4.539062 2.21875 -4.421875 1.945312 -4.183594 C 1.671875 -3.945312 1.539062 -3.496094 1.539062 -2.832031 L 1.539062 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-6">
-<path style="stroke:none;" d="M 4.042969 -1.898438 L 4.90625 -1.789062 C 4.8125 -1.191406 4.570312 -0.726562 4.183594 -0.386719 C 3.792969 -0.0507812 3.316406 0.117188 2.75 0.117188 C 2.039062 0.117188 1.46875 -0.113281 1.039062 -0.578125 C 0.605469 -1.042969 0.390625 -1.707031 0.390625 -2.574219 C 0.390625 -3.132812 0.484375 -3.625 0.667969 -4.042969 C 0.855469 -4.460938 1.136719 -4.777344 1.515625 -4.988281 C 1.894531 -5.199219 2.308594 -5.304688 2.753906 -5.304688 C 3.316406 -5.304688 3.777344 -5.160156 4.136719 -4.875 C 4.492188 -4.589844 4.722656 -4.1875 4.824219 -3.664062 L 3.96875 -3.53125 C 3.886719 -3.878906 3.746094 -4.140625 3.539062 -4.316406 C 3.332031 -4.492188 3.082031 -4.578125 2.789062 -4.578125 C 2.34375 -4.578125 1.984375 -4.421875 1.710938 -4.105469 C 1.433594 -3.789062 1.292969 -3.285156 1.292969 -2.597656 C 1.292969 -1.902344 1.425781 -1.394531 1.695312 -1.078125 C 1.960938 -0.761719 2.308594 -0.605469 2.738281 -0.605469 C 3.085938 -0.605469 3.371094 -0.710938 3.601562 -0.921875 C 3.835938 -1.132812 3.980469 -1.460938 4.042969 -1.898438 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-7">
-<path style="stroke:none;" d="M 2.578125 -0.785156 L 2.703125 -0.0078125 C 2.457031 0.0429688 2.234375 0.0703125 2.039062 0.0703125 C 1.722656 0.0703125 1.476562 0.0195312 1.296875 -0.0820312 C 1.121094 -0.183594 1 -0.316406 0.929688 -0.480469 C 0.855469 -0.644531 0.820312 -0.992188 0.820312 -1.519531 L 0.820312 -4.5 L 0.175781 -4.5 L 0.175781 -5.1875 L 0.820312 -5.1875 L 0.820312 -6.46875 L 1.695312 -6.996094 L 1.695312 -5.1875 L 2.578125 -5.1875 L 2.578125 -4.5 L 1.695312 -4.5 L 1.695312 -1.46875 C 1.695312 -1.21875 1.710938 -1.058594 1.742188 -0.984375 C 1.773438 -0.914062 1.820312 -0.859375 1.890625 -0.816406 C 1.960938 -0.773438 2.0625 -0.75 2.191406 -0.75 C 2.289062 -0.75 2.417969 -0.761719 2.578125 -0.785156 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-8">
-<path style="stroke:none;" d="M 0.664062 -6.148438 L 0.664062 -7.15625 L 1.542969 -7.15625 L 1.542969 -6.148438 Z M 0.664062 0 L 0.664062 -5.1875 L 1.542969 -5.1875 L 1.542969 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-9">
-<path style="stroke:none;" d="M 0.332031 -2.59375 C 0.332031 -3.554688 0.597656 -4.265625 1.132812 -4.726562 C 1.578125 -5.109375 2.121094 -5.304688 2.765625 -5.304688 C 3.476562 -5.304688 4.058594 -5.070312 4.511719 -4.601562 C 4.964844 -4.132812 5.191406 -3.488281 5.191406 -2.664062 C 5.191406 -2 5.089844 -1.472656 4.890625 -1.089844 C 4.691406 -0.707031 4.398438 -0.410156 4.015625 -0.199219 C 3.632812 0.0117188 3.214844 0.117188 2.765625 0.117188 C 2.039062 0.117188 1.449219 -0.117188 1.003906 -0.582031 C 0.554688 -1.046875 0.332031 -1.71875 0.332031 -2.59375 Z M 1.234375 -2.59375 C 1.234375 -1.929688 1.378906 -1.429688 1.671875 -1.101562 C 1.960938 -0.769531 2.324219 -0.605469 2.765625 -0.605469 C 3.199219 -0.605469 3.5625 -0.773438 3.851562 -1.101562 C 4.140625 -1.433594 4.289062 -1.941406 4.289062 -2.621094 C 4.289062 -3.261719 4.140625 -3.75 3.851562 -4.078125 C 3.558594 -4.410156 3.195312 -4.574219 2.765625 -4.574219 C 2.324219 -4.574219 1.960938 -4.410156 1.671875 -4.082031 C 1.382812 -3.753906 1.234375 -3.257812 1.234375 -2.59375 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph0-10">
-<path style="stroke:none;" d="M 0.308594 -1.546875 L 1.175781 -1.683594 C 1.226562 -1.335938 1.363281 -1.070312 1.585938 -0.882812 C 1.808594 -0.699219 2.117188 -0.605469 2.519531 -0.605469 C 2.921875 -0.605469 3.222656 -0.6875 3.417969 -0.851562 C 3.613281 -1.015625 3.710938 -1.210938 3.710938 -1.429688 C 3.710938 -1.628906 3.625 -1.785156 3.453125 -1.898438 C 3.332031 -1.976562 3.03125 -2.078125 2.554688 -2.195312 C 1.910156 -2.359375 1.460938 -2.5 1.214844 -2.621094 C 0.964844 -2.738281 0.777344 -2.902344 0.648438 -3.113281 C 0.519531 -3.324219 0.453125 -3.554688 0.453125 -3.808594 C 0.453125 -4.039062 0.507812 -4.253906 0.613281 -4.449219 C 0.71875 -4.648438 0.863281 -4.8125 1.046875 -4.941406 C 1.183594 -5.042969 1.367188 -5.128906 1.605469 -5.199219 C 1.839844 -5.269531 2.09375 -5.304688 2.363281 -5.304688 C 2.769531 -5.304688 3.128906 -5.242188 3.433594 -5.125 C 3.742188 -5.007812 3.96875 -4.851562 4.117188 -4.652344 C 4.261719 -4.453125 4.363281 -4.183594 4.417969 -3.847656 L 3.558594 -3.730469 C 3.519531 -3.996094 3.40625 -4.207031 3.21875 -4.355469 C 3.03125 -4.503906 2.769531 -4.578125 2.425781 -4.578125 C 2.023438 -4.578125 1.734375 -4.511719 1.5625 -4.378906 C 1.390625 -4.246094 1.304688 -4.089844 1.304688 -3.910156 C 1.304688 -3.796875 1.339844 -3.695312 1.410156 -3.601562 C 1.484375 -3.507812 1.59375 -3.429688 1.75 -3.367188 C 1.835938 -3.335938 2.09375 -3.261719 2.523438 -3.144531 C 3.144531 -2.976562 3.578125 -2.84375 3.824219 -2.738281 C 4.070312 -2.632812 4.265625 -2.476562 4.40625 -2.273438 C 4.546875 -2.074219 4.613281 -1.824219 4.613281 -1.523438 C 4.613281 -1.230469 4.527344 -0.953125 4.359375 -0.695312 C 4.1875 -0.4375 3.941406 -0.238281 3.617188 -0.09375 C 3.296875 0.046875 2.929688 0.117188 2.523438 0.117188 C 1.851562 0.117188 1.335938 -0.0234375 0.984375 -0.304688 C 0.632812 -0.582031 0.40625 -0.996094 0.308594 -1.546875 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph1-0">
-<path style="stroke:none;" d=""/>
-</symbol>
-<symbol overflow="visible" id="glyph1-1">
-<path style="stroke:none;" d="M 0.375 -1.6875 L 1.203125 -1.757812 C 1.265625 -1.351562 1.410156 -1.050781 1.632812 -0.847656 C 1.855469 -0.644531 2.125 -0.539062 2.445312 -0.539062 C 2.824219 -0.539062 3.148438 -0.683594 3.410156 -0.972656 C 3.671875 -1.257812 3.804688 -1.640625 3.804688 -2.113281 C 3.804688 -2.566406 3.679688 -2.921875 3.425781 -3.179688 C 3.171875 -3.441406 2.839844 -3.574219 2.429688 -3.574219 C 2.175781 -3.574219 1.945312 -3.515625 1.742188 -3.398438 C 1.535156 -3.28125 1.375 -3.132812 1.257812 -2.949219 L 0.515625 -3.046875 L 1.136719 -6.355469 L 4.34375 -6.355469 L 4.34375 -5.597656 L 1.769531 -5.597656 L 1.421875 -3.867188 C 1.808594 -4.136719 2.214844 -4.273438 2.640625 -4.273438 C 3.203125 -4.273438 3.679688 -4.078125 4.066406 -3.6875 C 4.453125 -3.296875 4.644531 -2.796875 4.644531 -2.183594 C 4.644531 -1.601562 4.476562 -1.097656 4.136719 -0.671875 C 3.722656 -0.152344 3.15625 0.109375 2.445312 0.109375 C 1.859375 0.109375 1.378906 -0.0546875 1.007812 -0.382812 C 0.636719 -0.710938 0.425781 -1.144531 0.375 -1.6875 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph1-2">
-<path style="stroke:none;" d="M 4.476562 -4.863281 L 3.691406 -4.804688 C 3.621094 -5.113281 3.523438 -5.339844 3.390625 -5.480469 C 3.179688 -5.707031 2.914062 -5.820312 2.601562 -5.820312 C 2.351562 -5.820312 2.128906 -5.75 1.9375 -5.609375 C 1.6875 -5.425781 1.492188 -5.160156 1.347656 -4.8125 C 1.203125 -4.464844 1.132812 -3.96875 1.125 -3.320312 C 1.316406 -3.613281 1.546875 -3.828125 1.824219 -3.96875 C 2.097656 -4.109375 2.386719 -4.179688 2.6875 -4.179688 C 3.214844 -4.179688 3.664062 -3.984375 4.035156 -3.597656 C 4.40625 -3.210938 4.59375 -2.707031 4.59375 -2.09375 C 4.59375 -1.6875 4.503906 -1.3125 4.332031 -0.964844 C 4.15625 -0.617188 3.917969 -0.351562 3.613281 -0.167969 C 3.308594 0.015625 2.960938 0.109375 2.574219 0.109375 C 1.914062 0.109375 1.378906 -0.132812 0.960938 -0.617188 C 0.546875 -1.101562 0.339844 -1.902344 0.339844 -3.015625 C 0.339844 -4.261719 0.570312 -5.164062 1.027344 -5.730469 C 1.429688 -6.222656 1.96875 -6.46875 2.648438 -6.46875 C 3.15625 -6.46875 3.570312 -6.328125 3.894531 -6.042969 C 4.21875 -5.757812 4.414062 -5.367188 4.476562 -4.863281 Z M 1.25 -2.085938 C 1.25 -1.8125 1.304688 -1.554688 1.421875 -1.304688 C 1.539062 -1.054688 1.699219 -0.867188 1.90625 -0.734375 C 2.113281 -0.605469 2.332031 -0.539062 2.5625 -0.539062 C 2.894531 -0.539062 3.183594 -0.675781 3.421875 -0.945312 C 3.664062 -1.214844 3.785156 -1.582031 3.785156 -2.042969 C 3.785156 -2.488281 3.664062 -2.839844 3.429688 -3.097656 C 3.191406 -3.351562 2.890625 -3.480469 2.53125 -3.480469 C 2.171875 -3.480469 1.871094 -3.351562 1.621094 -3.097656 C 1.371094 -2.839844 1.25 -2.503906 1.25 -2.085938 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph1-3">
-<path style="stroke:none;" d="M 0.425781 -5.597656 L 0.425781 -6.359375 L 4.597656 -6.359375 L 4.597656 -5.742188 C 4.1875 -5.304688 3.78125 -4.726562 3.378906 -4.003906 C 2.976562 -3.28125 2.664062 -2.535156 2.445312 -1.769531 C 2.285156 -1.230469 2.183594 -0.640625 2.140625 0 L 1.328125 0 C 1.335938 -0.507812 1.4375 -1.117188 1.625 -1.835938 C 1.816406 -2.554688 2.089844 -3.246094 2.445312 -3.914062 C 2.800781 -4.578125 3.179688 -5.140625 3.582031 -5.597656 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-0">
-<path style="stroke:none;" d=""/>
-</symbol>
-<symbol overflow="visible" id="glyph2-1">
-<path style="stroke:none;" d="M 0 -0.734375 L -7.15625 -0.734375 L -7.15625 -3.417969 C -7.15625 -3.964844 -7.085938 -4.402344 -6.941406 -4.734375 C -6.796875 -5.0625 -6.574219 -5.324219 -6.273438 -5.511719 C -5.972656 -5.699219 -5.65625 -5.789062 -5.328125 -5.789062 C -5.023438 -5.789062 -4.734375 -5.707031 -4.460938 -5.542969 C -4.191406 -5.375 -3.976562 -5.125 -3.808594 -4.789062 C -3.679688 -5.222656 -3.464844 -5.554688 -3.160156 -5.789062 C -2.851562 -6.023438 -2.492188 -6.136719 -2.074219 -6.136719 C -1.738281 -6.136719 -1.429688 -6.066406 -1.140625 -5.925781 C -0.851562 -5.785156 -0.628906 -5.609375 -0.472656 -5.398438 C -0.316406 -5.191406 -0.199219 -4.929688 -0.121094 -4.617188 C -0.0390625 -4.304688 0 -3.917969 0 -3.460938 Z M -4.148438 -1.679688 L -4.148438 -3.226562 C -4.148438 -3.648438 -4.179688 -3.949219 -4.234375 -4.132812 C -4.304688 -4.371094 -4.421875 -4.554688 -4.589844 -4.675781 C -4.757812 -4.796875 -4.964844 -4.859375 -5.214844 -4.859375 C -5.453125 -4.859375 -5.660156 -4.800781 -5.84375 -4.6875 C -6.023438 -4.574219 -6.148438 -4.410156 -6.214844 -4.199219 C -6.28125 -3.988281 -6.3125 -3.625 -6.3125 -3.109375 L -6.3125 -1.679688 Z M -0.84375 -1.679688 L -0.84375 -3.460938 C -0.84375 -3.765625 -0.855469 -3.984375 -0.878906 -4.105469 C -0.917969 -4.324219 -0.984375 -4.507812 -1.074219 -4.652344 C -1.164062 -4.800781 -1.296875 -4.921875 -1.472656 -5.015625 C -1.648438 -5.109375 -1.847656 -5.15625 -2.074219 -5.15625 C -2.34375 -5.15625 -2.574219 -5.085938 -2.769531 -4.953125 C -2.96875 -4.816406 -3.105469 -4.625 -3.1875 -4.382812 C -3.265625 -4.140625 -3.304688 -3.789062 -3.304688 -3.335938 L -3.304688 -1.679688 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-2">
-<path style="stroke:none;" d="M 1.996094 -0.621094 L 1.171875 -0.523438 C 1.222656 -0.714844 1.25 -0.882812 1.25 -1.023438 C 1.25 -1.21875 1.21875 -1.375 1.152344 -1.492188 C 1.085938 -1.609375 0.996094 -1.707031 0.878906 -1.78125 C 0.789062 -1.835938 0.574219 -1.925781 0.226562 -2.050781 C 0.175781 -2.066406 0.105469 -2.09375 0.0078125 -2.128906 L -5.1875 -0.160156 L -5.1875 -1.109375 L -2.183594 -2.1875 C -1.800781 -2.328125 -1.402344 -2.453125 -0.980469 -2.5625 C -1.382812 -2.664062 -1.777344 -2.785156 -2.164062 -2.925781 L -5.1875 -4.03125 L -5.1875 -4.914062 L 0.0859375 -2.9375 C 0.65625 -2.726562 1.050781 -2.5625 1.265625 -2.445312 C 1.554688 -2.289062 1.765625 -2.109375 1.902344 -1.910156 C 2.039062 -1.707031 2.105469 -1.464844 2.105469 -1.1875 C 2.105469 -1.015625 2.070312 -0.828125 1.996094 -0.621094 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-3">
-<path style="stroke:none;" d="M -0.785156 -2.578125 L -0.0078125 -2.703125 C 0.0429688 -2.457031 0.0703125 -2.234375 0.0703125 -2.039062 C 0.0703125 -1.722656 0.0195312 -1.476562 -0.0820312 -1.296875 C -0.183594 -1.121094 -0.316406 -1 -0.480469 -0.929688 C -0.644531 -0.855469 -0.992188 -0.820312 -1.519531 -0.820312 L -4.5 -0.820312 L -4.5 -0.175781 L -5.1875 -0.175781 L -5.1875 -0.820312 L -6.46875 -0.820312 L -6.996094 -1.695312 L -5.1875 -1.695312 L -5.1875 -2.578125 L -4.5 -2.578125 L -4.5 -1.695312 L -1.46875 -1.695312 C -1.21875 -1.695312 -1.058594 -1.710938 -0.984375 -1.742188 C -0.914062 -1.773438 -0.859375 -1.820312 -0.816406 -1.890625 C -0.773438 -1.960938 -0.75 -2.0625 -0.75 -2.191406 C -0.75 -2.289062 -0.761719 -2.417969 -0.785156 -2.578125 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-4">
-<path style="stroke:none;" d="M -1.671875 -4.210938 L -1.558594 -5.117188 C -1.027344 -4.972656 -0.617188 -4.707031 -0.320312 -4.320312 C -0.0273438 -3.933594 0.117188 -3.4375 0.117188 -2.835938 C 0.117188 -2.078125 -0.117188 -1.476562 -0.582031 -1.03125 C -1.050781 -0.585938 -1.707031 -0.367188 -2.546875 -0.367188 C -3.421875 -0.367188 -4.097656 -0.589844 -4.578125 -1.039062 C -5.0625 -1.488281 -5.304688 -2.070312 -5.304688 -2.789062 C -5.304688 -3.480469 -5.066406 -4.046875 -4.59375 -4.488281 C -4.121094 -4.925781 -3.457031 -5.148438 -2.601562 -5.148438 C -2.550781 -5.148438 -2.472656 -5.144531 -2.367188 -5.140625 L -2.367188 -1.273438 C -1.796875 -1.304688 -1.363281 -1.46875 -1.058594 -1.757812 C -0.757812 -2.046875 -0.605469 -2.410156 -0.605469 -2.84375 C -0.605469 -3.164062 -0.691406 -3.4375 -0.859375 -3.667969 C -1.027344 -3.894531 -1.296875 -4.074219 -1.671875 -4.210938 Z M -3.089844 -1.324219 L -3.089844 -4.21875 C -3.527344 -4.179688 -3.855469 -4.070312 -4.070312 -3.886719 C -4.410156 -3.605469 -4.578125 -3.242188 -4.578125 -2.796875 C -4.578125 -2.394531 -4.445312 -2.054688 -4.175781 -1.78125 C -3.90625 -1.503906 -3.542969 -1.351562 -3.089844 -1.324219 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph2-5">
-<path style="stroke:none;" d="M -1.546875 -0.308594 L -1.683594 -1.175781 C -1.335938 -1.226562 -1.070312 -1.363281 -0.882812 -1.585938 C -0.699219 -1.808594 -0.605469 -2.117188 -0.605469 -2.519531 C -0.605469 -2.921875 -0.6875 -3.222656 -0.851562 -3.417969 C -1.015625 -3.613281 -1.210938 -3.710938 -1.429688 -3.710938 C -1.628906 -3.710938 -1.785156 -3.625 -1.898438 -3.453125 C -1.976562 -3.332031 -2.078125 -3.03125 -2.195312 -2.554688 C -2.359375 -1.910156 -2.5 -1.460938 -2.621094 -1.214844 C -2.738281 -0.964844 -2.902344 -0.777344 -3.113281 -0.648438 C -3.324219 -0.519531 -3.554688 -0.453125 -3.808594 -0.453125 C -4.039062 -0.453125 -4.253906 -0.507812 -4.449219 -0.613281 C -4.648438 -0.71875 -4.8125 -0.863281 -4.941406 -1.046875 C -5.042969 -1.183594 -5.128906 -1.367188 -5.199219 -1.605469 C -5.269531 -1.839844 -5.304688 -2.09375 -5.304688 -2.363281 C -5.304688 -2.769531 -5.242188 -3.128906 -5.125 -3.433594 C -5.007812 -3.742188 -4.851562 -3.96875 -4.652344 -4.117188 C -4.453125 -4.261719 -4.183594 -4.363281 -3.847656 -4.417969 L -3.730469 -3.558594 C -3.996094 -3.519531 -4.207031 -3.40625 -4.355469 -3.21875 C -4.503906 -3.03125 -4.578125 -2.769531 -4.578125 -2.425781 C -4.578125 -2.023438 -4.511719 -1.734375 -4.378906 -1.5625 C -4.246094 -1.390625 -4.089844 -1.304688 -3.910156 -1.304688 C -3.796875 -1.304688 -3.695312 -1.339844 -3.601562 -1.410156 C -3.507812 -1.484375 -3.429688 -1.59375 -3.367188 -1.75 C -3.335938 -1.835938 -3.261719 -2.09375 -3.144531 -2.523438 C -2.976562 -3.144531 -2.84375 -3.578125 -2.738281 -3.824219 C -2.632812 -4.070312 -2.476562 -4.265625 -2.273438 -4.40625 C -2.074219 -4.546875 -1.824219 -4.613281 -1.523438 -4.613281 C -1.230469 -4.613281 -0.953125 -4.527344 -0.695312 -4.359375 C -0.4375 -4.1875 -0.238281 -3.941406 -0.09375 -3.617188 C 0.046875 -3.296875 0.117188 -2.929688 0.117188 -2.523438 C 0.117188 -1.851562 -0.0234375 -1.335938 -0.304688 -0.984375 C -0.582031 -0.632812 -0.996094 -0.40625 -1.546875 -0.308594 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-0">
-<path style="stroke:none;" d=""/>
-</symbol>
-<symbol overflow="visible" id="glyph3-1">
-<path style="stroke:none;" d="M 0.984375 0 L 0.984375 -8.589844 L 6.78125 -8.589844 L 6.78125 -7.578125 L 2.121094 -7.578125 L 2.121094 -4.914062 L 6.152344 -4.914062 L 6.152344 -3.902344 L 2.121094 -3.902344 L 2.121094 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-2">
-<path style="stroke:none;" d="M 0.796875 -7.375 L 0.796875 -8.589844 L 1.851562 -8.589844 L 1.851562 -7.375 Z M 0.796875 0 L 0.796875 -6.222656 L 1.851562 -6.222656 L 1.851562 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-3">
-<path style="stroke:none;" d="M 0.765625 0 L 0.765625 -8.589844 L 1.820312 -8.589844 L 1.820312 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-4">
-<path style="stroke:none;" d="M 5.050781 -2.003906 L 6.140625 -1.867188 C 5.96875 -1.230469 5.648438 -0.738281 5.1875 -0.386719 C 4.722656 -0.0351562 4.125 0.140625 3.40625 0.140625 C 2.496094 0.140625 1.773438 -0.140625 1.238281 -0.699219 C 0.707031 -1.261719 0.4375 -2.046875 0.4375 -3.058594 C 0.4375 -4.105469 0.710938 -4.917969 1.25 -5.496094 C 1.789062 -6.074219 2.484375 -6.363281 3.34375 -6.363281 C 4.175781 -6.363281 4.859375 -6.078125 5.382812 -5.515625 C 5.910156 -4.949219 6.175781 -4.148438 6.175781 -3.125 C 6.175781 -3.0625 6.171875 -2.96875 6.171875 -2.84375 L 1.53125 -2.84375 C 1.570312 -2.160156 1.761719 -1.632812 2.109375 -1.273438 C 2.457031 -0.910156 2.890625 -0.726562 3.410156 -0.726562 C 3.796875 -0.726562 4.125 -0.828125 4.398438 -1.03125 C 4.671875 -1.234375 4.890625 -1.558594 5.050781 -2.003906 Z M 1.585938 -3.710938 L 5.0625 -3.710938 C 5.015625 -4.234375 4.882812 -4.625 4.664062 -4.886719 C 4.328125 -5.292969 3.890625 -5.496094 3.359375 -5.496094 C 2.875 -5.496094 2.464844 -5.335938 2.136719 -5.007812 C 1.804688 -4.683594 1.625 -4.25 1.585938 -3.710938 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-5">
-<path style="stroke:none;" d="M 0.367188 -1.859375 L 1.414062 -2.023438 C 1.472656 -1.605469 1.632812 -1.28125 1.902344 -1.0625 C 2.167969 -0.839844 2.542969 -0.726562 3.023438 -0.726562 C 3.507812 -0.726562 3.867188 -0.824219 4.101562 -1.023438 C 4.335938 -1.21875 4.453125 -1.453125 4.453125 -1.71875 C 4.453125 -1.957031 4.351562 -2.140625 4.140625 -2.28125 C 3.996094 -2.375 3.640625 -2.492188 3.0625 -2.636719 C 2.289062 -2.832031 1.753906 -3 1.457031 -3.144531 C 1.15625 -3.285156 0.929688 -3.484375 0.777344 -3.734375 C 0.621094 -3.988281 0.546875 -4.265625 0.546875 -4.570312 C 0.546875 -4.847656 0.609375 -5.105469 0.734375 -5.339844 C 0.863281 -5.578125 1.035156 -5.773438 1.253906 -5.929688 C 1.417969 -6.050781 1.640625 -6.152344 1.925781 -6.238281 C 2.207031 -6.320312 2.511719 -6.363281 2.835938 -6.363281 C 3.324219 -6.363281 3.753906 -6.292969 4.121094 -6.152344 C 4.492188 -6.011719 4.765625 -5.820312 4.9375 -5.582031 C 5.113281 -5.339844 5.234375 -5.019531 5.304688 -4.617188 L 4.273438 -4.476562 C 4.226562 -4.796875 4.089844 -5.046875 3.863281 -5.226562 C 3.640625 -5.40625 3.320312 -5.496094 2.914062 -5.496094 C 2.429688 -5.496094 2.082031 -5.414062 1.875 -5.257812 C 1.667969 -5.097656 1.5625 -4.90625 1.5625 -4.695312 C 1.5625 -4.558594 1.609375 -4.433594 1.695312 -4.324219 C 1.78125 -4.210938 1.914062 -4.117188 2.097656 -4.042969 C 2.203125 -4.003906 2.515625 -3.914062 3.03125 -3.773438 C 3.777344 -3.574219 4.296875 -3.410156 4.589844 -3.285156 C 4.886719 -3.15625 5.117188 -2.972656 5.285156 -2.730469 C 5.453125 -2.488281 5.539062 -2.1875 5.539062 -1.828125 C 5.539062 -1.476562 5.433594 -1.144531 5.230469 -0.835938 C 5.023438 -0.523438 4.726562 -0.285156 4.34375 -0.113281 C 3.957031 0.0546875 3.515625 0.140625 3.03125 0.140625 C 2.222656 0.140625 1.605469 -0.0273438 1.179688 -0.363281 C 0.757812 -0.699219 0.484375 -1.195312 0.367188 -1.859375 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-6">
-<path style="stroke:none;" d="M 0.234375 0 L 0.234375 -0.855469 L 4.195312 -5.402344 C 3.746094 -5.378906 3.351562 -5.367188 3.007812 -5.367188 L 0.46875 -5.367188 L 0.46875 -6.222656 L 5.554688 -6.222656 L 5.554688 -5.523438 L 2.1875 -1.578125 L 1.535156 -0.855469 C 2.007812 -0.890625 2.453125 -0.90625 2.867188 -0.90625 L 5.742188 -0.90625 L 5.742188 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-7">
-<path style="stroke:none;" d="M 0.398438 -3.109375 C 0.398438 -4.261719 0.71875 -5.117188 1.359375 -5.671875 C 1.894531 -6.132812 2.546875 -6.363281 3.316406 -6.363281 C 4.171875 -6.363281 4.871094 -6.082031 5.414062 -5.523438 C 5.957031 -4.960938 6.226562 -4.1875 6.226562 -3.199219 C 6.226562 -2.398438 6.109375 -1.769531 5.867188 -1.308594 C 5.628906 -0.851562 5.277344 -0.492188 4.820312 -0.242188 C 4.359375 0.0117188 3.859375 0.140625 3.316406 0.140625 C 2.445312 0.140625 1.742188 -0.140625 1.203125 -0.695312 C 0.667969 -1.253906 0.398438 -2.0625 0.398438 -3.109375 Z M 1.484375 -3.109375 C 1.484375 -2.3125 1.65625 -1.71875 2.003906 -1.320312 C 2.351562 -0.925781 2.789062 -0.726562 3.316406 -0.726562 C 3.839844 -0.726562 4.273438 -0.925781 4.625 -1.324219 C 4.972656 -1.722656 5.144531 -2.328125 5.144531 -3.148438 C 5.144531 -3.917969 4.96875 -4.5 4.621094 -4.894531 C 4.269531 -5.292969 3.835938 -5.492188 3.316406 -5.492188 C 2.789062 -5.492188 2.351562 -5.292969 2.003906 -4.898438 C 1.65625 -4.503906 1.484375 -3.90625 1.484375 -3.109375 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-8">
-<path style="stroke:none;" d="M 1.042969 0 L 1.042969 -5.402344 L 0.109375 -5.402344 L 0.109375 -6.222656 L 1.042969 -6.222656 L 1.042969 -6.882812 C 1.042969 -7.300781 1.078125 -7.613281 1.15625 -7.816406 C 1.257812 -8.089844 1.433594 -8.3125 1.691406 -8.480469 C 1.945312 -8.652344 2.304688 -8.734375 2.765625 -8.734375 C 3.0625 -8.734375 3.390625 -8.703125 3.75 -8.632812 L 3.59375 -7.710938 C 3.375 -7.75 3.164062 -7.769531 2.96875 -7.769531 C 2.648438 -7.769531 2.421875 -7.703125 2.289062 -7.5625 C 2.15625 -7.425781 2.09375 -7.171875 2.09375 -6.796875 L 2.09375 -6.222656 L 3.304688 -6.222656 L 3.304688 -5.402344 L 2.09375 -5.402344 L 2.09375 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-9">
-<path style="stroke:none;" d="M 0.789062 0 L 0.789062 -6.222656 L 1.734375 -6.222656 L 1.734375 -5.351562 C 1.929688 -5.65625 2.1875 -5.898438 2.515625 -6.085938 C 2.839844 -6.269531 3.207031 -6.363281 3.621094 -6.363281 C 4.082031 -6.363281 4.460938 -6.265625 4.753906 -6.078125 C 5.050781 -5.886719 5.257812 -5.617188 5.378906 -5.273438 C 5.871094 -6 6.511719 -6.363281 7.300781 -6.363281 C 7.917969 -6.363281 8.390625 -6.191406 8.726562 -5.851562 C 9.058594 -5.507812 9.222656 -4.984375 9.222656 -4.273438 L 9.222656 0 L 8.171875 0 L 8.171875 -3.921875 C 8.171875 -4.34375 8.140625 -4.644531 8.070312 -4.832031 C 8.003906 -5.015625 7.878906 -5.164062 7.699219 -5.28125 C 7.519531 -5.394531 7.308594 -5.449219 7.066406 -5.449219 C 6.628906 -5.449219 6.265625 -5.304688 5.976562 -5.011719 C 5.6875 -4.722656 5.542969 -4.257812 5.542969 -3.617188 L 5.542969 0 L 4.488281 0 L 4.488281 -4.042969 C 4.488281 -4.511719 4.402344 -4.863281 4.230469 -5.097656 C 4.058594 -5.332031 3.777344 -5.449219 3.386719 -5.449219 C 3.089844 -5.449219 2.816406 -5.371094 2.5625 -5.214844 C 2.3125 -5.058594 2.128906 -4.828125 2.015625 -4.53125 C 1.902344 -4.230469 1.84375 -3.796875 1.84375 -3.226562 L 1.84375 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-10">
-<path style="stroke:none;" d="M 4.828125 0 L 4.828125 -0.785156 C 4.433594 -0.167969 3.851562 0.140625 3.085938 0.140625 C 2.589844 0.140625 2.136719 0.00390625 1.71875 -0.269531 C 1.304688 -0.542969 0.980469 -0.925781 0.753906 -1.414062 C 0.523438 -1.90625 0.410156 -2.46875 0.410156 -3.105469 C 0.410156 -3.726562 0.515625 -4.289062 0.71875 -4.796875 C 0.925781 -5.300781 1.238281 -5.6875 1.652344 -5.960938 C 2.066406 -6.230469 2.53125 -6.363281 3.039062 -6.363281 C 3.414062 -6.363281 3.75 -6.285156 4.042969 -6.125 C 4.335938 -5.96875 4.574219 -5.761719 4.757812 -5.507812 L 4.757812 -8.589844 L 5.804688 -8.589844 L 5.804688 0 Z M 1.492188 -3.105469 C 1.492188 -2.308594 1.664062 -1.710938 2 -1.320312 C 2.335938 -0.925781 2.730469 -0.726562 3.1875 -0.726562 C 3.648438 -0.726562 4.039062 -0.914062 4.363281 -1.292969 C 4.683594 -1.667969 4.84375 -2.242188 4.84375 -3.015625 C 4.84375 -3.867188 4.679688 -4.492188 4.351562 -4.890625 C 4.023438 -5.289062 3.621094 -5.492188 3.140625 -5.492188 C 2.671875 -5.492188 2.28125 -5.296875 1.964844 -4.914062 C 1.652344 -4.53125 1.492188 -3.929688 1.492188 -3.105469 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph3-11">
-<path style="stroke:none;" d="M 4.867188 0 L 4.867188 -0.914062 C 4.382812 -0.210938 3.726562 0.140625 2.894531 0.140625 C 2.527344 0.140625 2.183594 0.0703125 1.867188 -0.0703125 C 1.546875 -0.210938 1.3125 -0.386719 1.15625 -0.601562 C 1.003906 -0.8125 0.894531 -1.074219 0.832031 -1.382812 C 0.789062 -1.589844 0.765625 -1.917969 0.765625 -2.367188 L 0.765625 -6.222656 L 1.820312 -6.222656 L 1.820312 -2.773438 C 1.820312 -2.222656 1.84375 -1.851562 1.886719 -1.65625 C 1.953125 -1.378906 2.09375 -1.164062 2.308594 -1.003906 C 2.523438 -0.847656 2.789062 -0.765625 3.105469 -0.765625 C 3.421875 -0.765625 3.71875 -0.847656 3.996094 -1.011719 C 4.273438 -1.171875 4.46875 -1.394531 4.585938 -1.671875 C 4.699219 -1.953125 4.757812 -2.359375 4.757812 -2.890625 L 4.757812 -6.222656 L 5.8125 -6.222656 L 5.8125 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph4-0">
-<path style="stroke:none;" d=""/>
-</symbol>
-<symbol overflow="visible" id="glyph4-1">
-<path style="stroke:none;" d="M 0.953125 0 L 0.953125 -9.304688 L 4.445312 -9.304688 C 5.15625 -9.304688 5.722656 -9.210938 6.152344 -9.023438 C 6.582031 -8.835938 6.921875 -8.546875 7.164062 -8.152344 C 7.40625 -7.761719 7.527344 -7.351562 7.527344 -6.925781 C 7.527344 -6.527344 7.421875 -6.152344 7.203125 -5.800781 C 6.988281 -5.449219 6.664062 -5.167969 6.226562 -4.953125 C 6.789062 -4.785156 7.222656 -4.503906 7.523438 -4.105469 C 7.828125 -3.707031 7.980469 -3.238281 7.980469 -2.699219 C 7.980469 -2.261719 7.886719 -1.855469 7.703125 -1.480469 C 7.519531 -1.105469 7.292969 -0.820312 7.019531 -0.617188 C 6.75 -0.414062 6.410156 -0.257812 6 -0.15625 C 5.59375 -0.0507812 5.09375 0 4.5 0 Z M 2.183594 -5.394531 L 4.195312 -5.394531 C 4.742188 -5.394531 5.132812 -5.429688 5.371094 -5.503906 C 5.683594 -5.597656 5.917969 -5.75 6.078125 -5.96875 C 6.238281 -6.183594 6.316406 -6.453125 6.316406 -6.78125 C 6.316406 -7.089844 6.242188 -7.359375 6.09375 -7.59375 C 5.945312 -7.828125 5.734375 -7.992188 5.460938 -8.078125 C 5.183594 -8.164062 4.710938 -8.207031 4.042969 -8.207031 L 2.183594 -8.207031 Z M 2.183594 -1.097656 L 4.5 -1.097656 C 4.898438 -1.097656 5.175781 -1.113281 5.339844 -1.140625 C 5.621094 -1.191406 5.859375 -1.277344 6.050781 -1.398438 C 6.242188 -1.515625 6.394531 -1.6875 6.519531 -1.914062 C 6.640625 -2.140625 6.703125 -2.402344 6.703125 -2.699219 C 6.703125 -3.046875 6.613281 -3.347656 6.4375 -3.601562 C 6.257812 -3.859375 6.011719 -4.039062 5.695312 -4.140625 C 5.382812 -4.246094 4.929688 -4.296875 4.335938 -4.296875 L 2.183594 -4.296875 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph4-2">
-<path style="stroke:none;" d="M 0.429688 -3.371094 C 0.429688 -4.617188 0.777344 -5.542969 1.472656 -6.144531 C 2.050781 -6.644531 2.757812 -6.894531 3.59375 -6.894531 C 4.519531 -6.894531 5.277344 -6.589844 5.867188 -5.984375 C 6.453125 -5.375 6.746094 -4.535156 6.746094 -3.464844 C 6.746094 -2.597656 6.617188 -1.914062 6.355469 -1.417969 C 6.097656 -0.921875 5.71875 -0.535156 5.222656 -0.261719 C 4.722656 0.015625 4.179688 0.152344 3.59375 0.152344 C 2.648438 0.152344 1.886719 -0.148438 1.304688 -0.753906 C 0.722656 -1.359375 0.429688 -2.230469 0.429688 -3.371094 Z M 1.605469 -3.371094 C 1.605469 -2.507812 1.792969 -1.859375 2.171875 -1.429688 C 2.546875 -1 3.023438 -0.789062 3.59375 -0.789062 C 4.160156 -0.789062 4.632812 -1.003906 5.007812 -1.433594 C 5.382812 -1.867188 5.574219 -2.523438 5.574219 -3.410156 C 5.574219 -4.242188 5.382812 -4.875 5.003906 -5.304688 C 4.625 -5.734375 4.15625 -5.949219 3.59375 -5.949219 C 3.023438 -5.949219 2.546875 -5.734375 2.171875 -5.304688 C 1.792969 -4.878906 1.605469 -4.234375 1.605469 -3.371094 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph4-3">
-<path style="stroke:none;" d="M 0.398438 -2.011719 L 1.53125 -2.191406 C 1.59375 -1.738281 1.769531 -1.390625 2.058594 -1.148438 C 2.347656 -0.90625 2.753906 -0.789062 3.273438 -0.789062 C 3.800781 -0.789062 4.1875 -0.894531 4.445312 -1.109375 C 4.699219 -1.320312 4.824219 -1.570312 4.824219 -1.859375 C 4.824219 -2.117188 4.710938 -2.320312 4.488281 -2.46875 C 4.332031 -2.570312 3.941406 -2.699219 3.320312 -2.855469 C 2.480469 -3.066406 1.902344 -3.25 1.578125 -3.40625 C 1.253906 -3.558594 1.007812 -3.773438 0.839844 -4.046875 C 0.671875 -4.320312 0.589844 -4.621094 0.589844 -4.953125 C 0.589844 -5.253906 0.660156 -5.53125 0.796875 -5.785156 C 0.933594 -6.042969 1.121094 -6.253906 1.359375 -6.421875 C 1.535156 -6.554688 1.777344 -6.667969 2.085938 -6.757812 C 2.390625 -6.847656 2.722656 -6.894531 3.070312 -6.894531 C 3.601562 -6.894531 4.066406 -6.816406 4.464844 -6.664062 C 4.867188 -6.511719 5.160156 -6.304688 5.351562 -6.046875 C 5.542969 -5.785156 5.671875 -5.4375 5.746094 -5 L 4.628906 -4.851562 C 4.578125 -5.195312 4.429688 -5.46875 4.1875 -5.664062 C 3.945312 -5.859375 3.597656 -5.953125 3.15625 -5.953125 C 2.628906 -5.953125 2.253906 -5.867188 2.03125 -5.695312 C 1.808594 -5.519531 1.695312 -5.316406 1.695312 -5.085938 C 1.695312 -4.9375 1.742188 -4.804688 1.835938 -4.683594 C 1.929688 -4.5625 2.074219 -4.460938 2.273438 -4.378906 C 2.386719 -4.335938 2.722656 -4.242188 3.28125 -4.085938 C 4.089844 -3.871094 4.652344 -3.695312 4.972656 -3.558594 C 5.292969 -3.421875 5.542969 -3.21875 5.726562 -2.957031 C 5.90625 -2.695312 6 -2.371094 6 -1.980469 C 6 -1.601562 5.886719 -1.242188 5.664062 -0.90625 C 5.441406 -0.570312 5.121094 -0.308594 4.703125 -0.125 C 4.285156 0.0585938 3.8125 0.152344 3.28125 0.152344 C 2.40625 0.152344 1.738281 -0.03125 1.277344 -0.394531 C 0.820312 -0.757812 0.527344 -1.296875 0.398438 -2.011719 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph4-4">
-<path style="stroke:none;" d="M 3.351562 -1.023438 L 3.515625 -0.0117188 C 3.195312 0.0546875 2.90625 0.0898438 2.652344 0.0898438 C 2.238281 0.0898438 1.917969 0.0234375 1.6875 -0.109375 C 1.460938 -0.238281 1.300781 -0.410156 1.207031 -0.625 C 1.113281 -0.839844 1.066406 -1.289062 1.066406 -1.972656 L 1.066406 -5.851562 L 0.226562 -5.851562 L 0.226562 -6.742188 L 1.066406 -6.742188 L 1.066406 -8.410156 L 2.203125 -9.097656 L 2.203125 -6.742188 L 3.351562 -6.742188 L 3.351562 -5.851562 L 2.203125 -5.851562 L 2.203125 -1.910156 C 2.203125 -1.585938 2.222656 -1.375 2.261719 -1.28125 C 2.304688 -1.1875 2.367188 -1.113281 2.460938 -1.058594 C 2.550781 -1.003906 2.679688 -0.976562 2.851562 -0.976562 C 2.976562 -0.976562 3.144531 -0.992188 3.351562 -1.023438 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph4-5">
-<path style="stroke:none;" d="M 1.179688 0 L 1.179688 -1.300781 L 2.480469 -1.300781 L 2.480469 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph4-6">
-<path style="stroke:none;" d="M 1.003906 0 L 1.003906 -9.304688 L 4.511719 -9.304688 C 5.128906 -9.304688 5.601562 -9.277344 5.929688 -9.21875 C 6.386719 -9.140625 6.769531 -8.996094 7.078125 -8.78125 C 7.386719 -8.566406 7.636719 -8.269531 7.824219 -7.882812 C 8.011719 -7.5 8.105469 -7.074219 8.105469 -6.613281 C 8.105469 -5.824219 7.855469 -5.152344 7.351562 -4.605469 C 6.847656 -4.058594 5.9375 -3.78125 4.621094 -3.78125 L 2.234375 -3.78125 L 2.234375 0 Z M 2.234375 -4.882812 L 4.640625 -4.882812 C 5.4375 -4.882812 6 -5.03125 6.335938 -5.324219 C 6.667969 -5.621094 6.835938 -6.039062 6.835938 -6.578125 C 6.835938 -6.964844 6.738281 -7.296875 6.542969 -7.574219 C 6.34375 -7.851562 6.085938 -8.035156 5.765625 -8.125 C 5.558594 -8.179688 5.171875 -8.207031 4.613281 -8.207031 L 2.234375 -8.207031 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph4-7">
-<path style="stroke:none;" d="M 0.804688 2.597656 L 0.679688 1.523438 C 0.929688 1.589844 1.148438 1.625 1.332031 1.625 C 1.585938 1.625 1.789062 1.582031 1.941406 1.5 C 2.09375 1.414062 2.21875 1.296875 2.316406 1.140625 C 2.390625 1.027344 2.503906 0.746094 2.664062 0.292969 C 2.6875 0.230469 2.722656 0.136719 2.765625 0.0117188 L 0.210938 -6.742188 L 1.441406 -6.742188 L 2.84375 -2.835938 C 3.027344 -2.34375 3.1875 -1.820312 3.332031 -1.277344 C 3.464844 -1.800781 3.621094 -2.3125 3.800781 -2.8125 L 5.242188 -6.742188 L 6.386719 -6.742188 L 3.820312 0.113281 C 3.546875 0.855469 3.332031 1.363281 3.179688 1.644531 C 2.976562 2.019531 2.746094 2.296875 2.480469 2.472656 C 2.21875 2.648438 1.90625 2.734375 1.542969 2.734375 C 1.324219 2.734375 1.078125 2.6875 0.804688 2.597656 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph4-8">
-<path style="stroke:none;" d="M 0.855469 0 L 0.855469 -9.304688 L 2 -9.304688 L 2 -5.96875 C 2.53125 -6.585938 3.207031 -6.894531 4.019531 -6.894531 C 4.519531 -6.894531 4.953125 -6.796875 5.320312 -6.597656 C 5.6875 -6.402344 5.949219 -6.128906 6.109375 -5.78125 C 6.269531 -5.433594 6.347656 -4.933594 6.347656 -4.273438 L 6.347656 0 L 5.203125 0 L 5.203125 -4.273438 C 5.203125 -4.84375 5.082031 -5.257812 4.832031 -5.519531 C 4.585938 -5.78125 4.234375 -5.910156 3.78125 -5.910156 C 3.445312 -5.910156 3.125 -5.820312 2.828125 -5.644531 C 2.53125 -5.46875 2.316406 -5.234375 2.191406 -4.933594 C 2.0625 -4.632812 2 -4.21875 2 -3.6875 L 2 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph4-9">
-<path style="stroke:none;" d="M 0.855469 0 L 0.855469 -6.742188 L 1.886719 -6.742188 L 1.886719 -5.78125 C 2.382812 -6.523438 3.09375 -6.894531 4.03125 -6.894531 C 4.4375 -6.894531 4.808594 -6.820312 5.152344 -6.675781 C 5.492188 -6.527344 5.746094 -6.335938 5.914062 -6.101562 C 6.085938 -5.863281 6.203125 -5.582031 6.273438 -5.257812 C 6.3125 -5.046875 6.335938 -4.675781 6.335938 -4.144531 L 6.335938 0 L 5.191406 0 L 5.191406 -4.101562 C 5.191406 -4.566406 5.148438 -4.914062 5.058594 -5.144531 C 4.96875 -5.375 4.8125 -5.558594 4.585938 -5.695312 C 4.359375 -5.835938 4.09375 -5.902344 3.789062 -5.902344 C 3.304688 -5.902344 2.882812 -5.75 2.53125 -5.441406 C 2.175781 -5.132812 2 -4.546875 2 -3.679688 L 2 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph4-10">
-<path style="stroke:none;" d="M 0.855469 2.582031 L 0.855469 -6.742188 L 1.898438 -6.742188 L 1.898438 -5.867188 C 2.144531 -6.207031 2.421875 -6.464844 2.730469 -6.636719 C 3.039062 -6.808594 3.414062 -6.894531 3.851562 -6.894531 C 4.429688 -6.894531 4.9375 -6.746094 5.375 -6.449219 C 5.816406 -6.152344 6.148438 -5.734375 6.375 -5.195312 C 6.597656 -4.65625 6.710938 -4.066406 6.710938 -3.421875 C 6.710938 -2.730469 6.585938 -2.109375 6.339844 -1.558594 C 6.089844 -1.007812 5.730469 -0.582031 5.257812 -0.289062 C 4.785156 0.00390625 4.289062 0.152344 3.769531 0.152344 C 3.390625 0.152344 3.046875 0.0703125 2.746094 -0.0898438 C 2.441406 -0.25 2.195312 -0.453125 2 -0.699219 L 2 2.582031 Z M 1.890625 -3.332031 C 1.890625 -2.464844 2.066406 -1.824219 2.417969 -1.410156 C 2.769531 -0.996094 3.195312 -0.789062 3.695312 -0.789062 C 4.203125 -0.789062 4.636719 -1 5 -1.429688 C 5.359375 -1.859375 5.542969 -2.527344 5.542969 -3.429688 C 5.542969 -4.289062 5.363281 -4.929688 5.011719 -5.359375 C 4.65625 -5.785156 4.234375 -6 3.746094 -6 C 3.257812 -6 2.828125 -5.769531 2.453125 -5.316406 C 2.078125 -4.859375 1.890625 -4.199219 1.890625 -3.332031 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph4-11">
-<path style="stroke:none;" d="M 1.910156 0 L 0.851562 0 L 0.851562 -9.304688 L 1.992188 -9.304688 L 1.992188 -5.984375 C 2.476562 -6.589844 3.089844 -6.894531 3.839844 -6.894531 C 4.253906 -6.894531 4.648438 -6.808594 5.019531 -6.644531 C 5.390625 -6.476562 5.691406 -6.242188 5.933594 -5.9375 C 6.171875 -5.636719 6.359375 -5.269531 6.492188 -4.84375 C 6.628906 -4.414062 6.695312 -3.957031 6.695312 -3.472656 C 6.695312 -2.316406 6.410156 -1.425781 5.839844 -0.792969 C 5.269531 -0.164062 4.582031 0.152344 3.78125 0.152344 C 2.988281 0.152344 2.363281 -0.179688 1.910156 -0.84375 Z M 1.898438 -3.421875 C 1.898438 -2.613281 2.007812 -2.027344 2.226562 -1.667969 C 2.585938 -1.082031 3.074219 -0.789062 3.6875 -0.789062 C 4.1875 -0.789062 4.617188 -1.003906 4.984375 -1.4375 C 5.347656 -1.871094 5.527344 -2.519531 5.527344 -3.375 C 5.527344 -4.257812 5.355469 -4.90625 5.003906 -5.324219 C 4.65625 -5.742188 4.234375 -5.953125 3.738281 -5.953125 C 3.238281 -5.953125 2.808594 -5.738281 2.445312 -5.304688 C 2.082031 -4.871094 1.898438 -4.242188 1.898438 -3.421875 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph4-12">
-<path style="stroke:none;" d="M 0.863281 -7.992188 L 0.863281 -9.304688 L 2.007812 -9.304688 L 2.007812 -7.992188 Z M 0.863281 0 L 0.863281 -6.742188 L 2.007812 -6.742188 L 2.007812 0 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph4-13">
-<path style="stroke:none;" d="M 5.230469 0 L 5.230469 -0.851562 C 4.804688 -0.183594 4.175781 0.152344 3.34375 0.152344 C 2.808594 0.152344 2.3125 0.00390625 1.863281 -0.292969 C 1.414062 -0.589844 1.0625 -1 0.816406 -1.53125 C 0.570312 -2.0625 0.445312 -2.675781 0.445312 -3.363281 C 0.445312 -4.035156 0.554688 -4.648438 0.78125 -5.195312 C 1.003906 -5.742188 1.339844 -6.164062 1.789062 -6.457031 C 2.238281 -6.75 2.738281 -6.894531 3.292969 -6.894531 C 3.699219 -6.894531 4.0625 -6.808594 4.378906 -6.636719 C 4.695312 -6.464844 4.957031 -6.242188 5.15625 -5.96875 L 5.15625 -9.304688 L 6.289062 -9.304688 L 6.289062 0 Z M 1.617188 -3.363281 C 1.617188 -2.5 1.800781 -1.855469 2.164062 -1.429688 C 2.527344 -1 2.957031 -0.789062 3.453125 -0.789062 C 3.953125 -0.789062 4.375 -0.992188 4.726562 -1.398438 C 5.074219 -1.808594 5.25 -2.429688 5.25 -3.269531 C 5.25 -4.191406 5.070312 -4.867188 4.714844 -5.300781 C 4.359375 -5.730469 3.921875 -5.949219 3.402344 -5.949219 C 2.894531 -5.949219 2.46875 -5.742188 2.128906 -5.324219 C 1.789062 -4.910156 1.617188 -4.257812 1.617188 -3.363281 Z "/>
-</symbol>
-<symbol overflow="visible" id="glyph4-14">
-<path style="stroke:none;" d="M 4.84375 0 L 3.699219 0 L 3.699219 -7.28125 C 3.425781 -7.019531 3.066406 -6.757812 2.617188 -6.492188 C 2.171875 -6.230469 1.769531 -6.035156 1.414062 -5.902344 L 1.414062 -7.007812 C 2.054688 -7.308594 2.613281 -7.671875 3.089844 -8.101562 C 3.570312 -8.527344 3.90625 -8.941406 4.105469 -9.34375 L 4.84375 -9.34375 Z "/>
-</symbol>
-</g>
-<clipPath id="clip1">
-  <path d="M 94 19 L 96 19 L 96 215 L 94 215 Z "/>
-</clipPath>
-<clipPath id="clip2">
-  <path d="M 204 19 L 206 19 L 206 215 L 204 215 Z "/>
-</clipPath>
-<clipPath id="clip3">
-  <path d="M 314 19 L 316 19 L 316 215 L 314 215 Z "/>
-</clipPath>
-<clipPath id="clip4">
-  <path d="M 39 171 L 355 171 L 355 173 L 39 173 Z "/>
-</clipPath>
-<clipPath id="clip5">
-  <path d="M 39 107 L 355 107 L 355 109 L 39 109 Z "/>
-</clipPath>
-<clipPath id="clip6">
-  <path d="M 39 44 L 355 44 L 355 46 L 39 46 Z "/>
-</clipPath>
-</defs>
-<g id="surface18">
-<g clip-path="url(#clip1)" clip-rule="nonzero">
-<path style="fill:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:0.5;stroke-dasharray:1,2;stroke-miterlimit:3.25;" d="M 95.160156 214.296875 L 95.160156 19 "/>
-</g>
-<g clip-path="url(#clip2)" clip-rule="nonzero">
-<path style="fill:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:0.5;stroke-dasharray:1,2;stroke-miterlimit:3.25;" d="M 204.84375 214.296875 L 204.84375 19 "/>
-</g>
-<g clip-path="url(#clip3)" clip-rule="nonzero">
-<path style="fill:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:0.5;stroke-dasharray:1,2;stroke-miterlimit:3.25;" d="M 314.53125 214.296875 L 314.53125 19 "/>
-</g>
-<g clip-path="url(#clip4)" clip-rule="nonzero">
-<path style="fill:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:0.5;stroke-dasharray:1,2;stroke-miterlimit:3.25;" d="M 39 171.960938 L 355 171.960938 "/>
-</g>
-<g clip-path="url(#clip5)" clip-rule="nonzero">
-<path style="fill:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:0.5;stroke-dasharray:1,2;stroke-miterlimit:3.25;" d="M 39 108.234375 L 355 108.234375 "/>
-</g>
-<g clip-path="url(#clip6)" clip-rule="nonzero">
-<path style="fill:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:0.5;stroke-dasharray:1,2;stroke-miterlimit:3.25;" d="M 39 44.511719 L 355 44.511719 "/>
-</g>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 55.070312 201 C 55.070312 200.183594 54.75 199.402344 54.171875 198.828125 C 53.597656 198.25 52.816406 197.929688 52 197.929688 C 51.183594 197.929688 50.402344 198.25 49.828125 198.828125 C 49.25 199.402344 48.929688 200.183594 48.929688 201 C 48.929688 201.816406 49.25 202.597656 49.828125 203.171875 C 50.402344 203.75 51.183594 204.070312 52 204.070312 C 52.816406 204.070312 53.597656 203.75 54.171875 203.171875 C 54.75 202.597656 55.070312 201.816406 55.070312 201 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 88.070312 176 C 88.070312 175.183594 87.75 174.402344 87.171875 173.828125 C 86.597656 173.25 85.816406 172.929688 85 172.929688 C 84.183594 172.929688 83.402344 173.25 82.828125 173.828125 C 82.25 174.402344 81.929688 175.183594 81.929688 176 C 81.929688 176.816406 82.25 177.597656 82.828125 178.171875 C 83.402344 178.75 84.183594 179.070312 85 179.070312 C 85.816406 179.070312 86.597656 178.75 87.171875 178.171875 C 87.75 177.597656 88.070312 176.816406 88.070312 176 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 121.070312 160 C 121.070312 159.183594 120.75 158.402344 120.171875 157.828125 C 119.597656 157.25 118.816406 156.929688 118 156.929688 C 117.183594 156.929688 116.402344 157.25 115.828125 157.828125 C 115.25 158.402344 114.929688 159.183594 114.929688 160 C 114.929688 160.816406 115.25 161.597656 115.828125 162.171875 C 116.402344 162.75 117.183594 163.070312 118 163.070312 C 118.816406 163.070312 119.597656 162.75 120.171875 162.171875 C 120.75 161.597656 121.070312 160.816406 121.070312 160 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 154.070312 142 C 154.070312 141.183594 153.75 140.402344 153.171875 139.828125 C 152.597656 139.25 151.816406 138.929688 151 138.929688 C 150.183594 138.929688 149.402344 139.25 148.828125 139.828125 C 148.25 140.402344 147.929688 141.183594 147.929688 142 C 147.929688 142.816406 148.25 143.597656 148.828125 144.171875 C 149.402344 144.75 150.183594 145.070312 151 145.070312 C 151.816406 145.070312 152.597656 144.75 153.171875 144.171875 C 153.75 143.597656 154.070312 142.816406 154.070312 142 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 187.070312 124 C 187.070312 123.183594 186.75 122.402344 186.171875 121.828125 C 185.597656 121.25 184.816406 120.929688 184 120.929688 C 183.183594 120.929688 182.402344 121.25 181.828125 121.828125 C 181.25 122.402344 180.929688 123.183594 180.929688 124 C 180.929688 124.816406 181.25 125.597656 181.828125 126.171875 C 182.402344 126.75 183.183594 127.070312 184 127.070312 C 184.816406 127.070312 185.597656 126.75 186.171875 126.171875 C 186.75 125.597656 187.070312 124.816406 187.070312 124 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 220.070312 105 C 220.070312 104.183594 219.75 103.402344 219.171875 102.828125 C 218.597656 102.25 217.816406 101.929688 217 101.929688 C 216.183594 101.929688 215.402344 102.25 214.828125 102.828125 C 214.25 103.402344 213.929688 104.183594 213.929688 105 C 213.929688 105.816406 214.25 106.597656 214.828125 107.171875 C 215.402344 107.75 216.183594 108.070312 217 108.070312 C 217.816406 108.070312 218.597656 107.75 219.171875 107.171875 C 219.75 106.597656 220.070312 105.816406 220.070312 105 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 253.070312 86 C 253.070312 85.183594 252.75 84.402344 252.171875 83.828125 C 251.597656 83.25 250.816406 82.929688 250 82.929688 C 249.183594 82.929688 248.402344 83.25 247.828125 83.828125 C 247.25 84.402344 246.929688 85.183594 246.929688 86 C 246.929688 86.816406 247.25 87.597656 247.828125 88.171875 C 248.402344 88.75 249.183594 89.070312 250 89.070312 C 250.816406 89.070312 251.597656 88.75 252.171875 88.171875 C 252.75 87.597656 253.070312 86.816406 253.070312 86 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 286.070312 67 C 286.070312 66.183594 285.75 65.402344 285.171875 64.828125 C 284.597656 64.25 283.816406 63.929688 283 63.929688 C 282.183594 63.929688 281.402344 64.25 280.828125 64.828125 C 280.25 65.402344 279.929688 66.183594 279.929688 67 C 279.929688 67.816406 280.25 68.597656 280.828125 69.171875 C 281.402344 69.75 282.183594 70.070312 283 70.070312 C 283.816406 70.070312 284.597656 69.75 285.171875 69.171875 C 285.75 68.597656 286.070312 67.816406 286.070312 67 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 319.070312 48 C 319.070312 47.183594 318.75 46.402344 318.171875 45.828125 C 317.597656 45.25 316.816406 44.929688 316 44.929688 C 315.183594 44.929688 314.402344 45.25 313.828125 45.828125 C 313.25 46.402344 312.929688 47.183594 312.929688 48 C 312.929688 48.816406 313.25 49.597656 313.828125 50.171875 C 314.402344 50.75 315.183594 51.070312 316 51.070312 C 316.816406 51.070312 317.597656 50.75 318.171875 50.171875 C 318.75 49.597656 319.070312 48.816406 319.070312 48 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 352.070312 29 C 352.070312 28.183594 351.75 27.402344 351.171875 26.828125 C 350.597656 26.25 349.816406 25.929688 349 25.929688 C 348.183594 25.929688 347.402344 26.25 346.828125 26.828125 C 346.25 27.402344 345.929688 28.183594 345.929688 29 C 345.929688 29.816406 346.25 30.597656 346.828125 31.171875 C 347.402344 31.75 348.183594 32.070312 349 32.070312 C 349.816406 32.070312 350.597656 31.75 351.171875 31.171875 C 351.75 30.597656 352.070312 29.816406 352.070312 29 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 55.070312 191 C 55.070312 190.183594 54.75 189.402344 54.171875 188.828125 C 53.597656 188.25 52.816406 187.929688 52 187.929688 C 51.183594 187.929688 50.402344 188.25 49.828125 188.828125 C 49.25 189.402344 48.929688 190.183594 48.929688 191 C 48.929688 191.816406 49.25 192.597656 49.828125 193.171875 C 50.402344 193.75 51.183594 194.070312 52 194.070312 C 52.816406 194.070312 53.597656 193.75 54.171875 193.171875 C 54.75 192.597656 55.070312 191.816406 55.070312 191 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 88.070312 181 C 88.070312 180.183594 87.75 179.402344 87.171875 178.828125 C 86.597656 178.25 85.816406 177.929688 85 177.929688 C 84.183594 177.929688 83.402344 178.25 82.828125 178.828125 C 82.25 179.402344 81.929688 180.183594 81.929688 181 C 81.929688 181.816406 82.25 182.597656 82.828125 183.171875 C 83.402344 183.75 84.183594 184.070312 85 184.070312 C 85.816406 184.070312 86.597656 183.75 87.171875 183.171875 C 87.75 182.597656 88.070312 181.816406 88.070312 181 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 121.070312 170 C 121.070312 169.183594 120.75 168.402344 120.171875 167.828125 C 119.597656 167.25 118.816406 166.929688 118 166.929688 C 117.183594 166.929688 116.402344 167.25 115.828125 167.828125 C 115.25 168.402344 114.929688 169.183594 114.929688 170 C 114.929688 170.816406 115.25 171.597656 115.828125 172.171875 C 116.402344 172.75 117.183594 173.070312 118 173.070312 C 118.816406 173.070312 119.597656 172.75 120.171875 172.171875 C 120.75 171.597656 121.070312 170.816406 121.070312 170 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 154.070312 157 C 154.070312 156.183594 153.75 155.402344 153.171875 154.828125 C 152.597656 154.25 151.816406 153.929688 151 153.929688 C 150.183594 153.929688 149.402344 154.25 148.828125 154.828125 C 148.25 155.402344 147.929688 156.183594 147.929688 157 C 147.929688 157.816406 148.25 158.597656 148.828125 159.171875 C 149.402344 159.75 150.183594 160.070312 151 160.070312 C 151.816406 160.070312 152.597656 159.75 153.171875 159.171875 C 153.75 158.597656 154.070312 157.816406 154.070312 157 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 187.070312 142 C 187.070312 141.183594 186.75 140.402344 186.171875 139.828125 C 185.597656 139.25 184.816406 138.929688 184 138.929688 C 183.183594 138.929688 182.402344 139.25 181.828125 139.828125 C 181.25 140.402344 180.929688 141.183594 180.929688 142 C 180.929688 142.816406 181.25 143.597656 181.828125 144.171875 C 182.402344 144.75 183.183594 145.070312 184 145.070312 C 184.816406 145.070312 185.597656 144.75 186.171875 144.171875 C 186.75 143.597656 187.070312 142.816406 187.070312 142 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 220.070312 125 C 220.070312 124.183594 219.75 123.402344 219.171875 122.828125 C 218.597656 122.25 217.816406 121.929688 217 121.929688 C 216.183594 121.929688 215.402344 122.25 214.828125 122.828125 C 214.25 123.402344 213.929688 124.183594 213.929688 125 C 213.929688 125.816406 214.25 126.597656 214.828125 127.171875 C 215.402344 127.75 216.183594 128.070312 217 128.070312 C 217.816406 128.070312 218.597656 127.75 219.171875 127.171875 C 219.75 126.597656 220.070312 125.816406 220.070312 125 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 253.070312 107 C 253.070312 106.183594 252.75 105.402344 252.171875 104.828125 C 251.597656 104.25 250.816406 103.929688 250 103.929688 C 249.183594 103.929688 248.402344 104.25 247.828125 104.828125 C 247.25 105.402344 246.929688 106.183594 246.929688 107 C 246.929688 107.816406 247.25 108.597656 247.828125 109.171875 C 248.402344 109.75 249.183594 110.070312 250 110.070312 C 250.816406 110.070312 251.597656 109.75 252.171875 109.171875 C 252.75 108.597656 253.070312 107.816406 253.070312 107 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 286.070312 88 C 286.070312 87.183594 285.75 86.402344 285.171875 85.828125 C 284.597656 85.25 283.816406 84.929688 283 84.929688 C 282.183594 84.929688 281.402344 85.25 280.828125 85.828125 C 280.25 86.402344 279.929688 87.183594 279.929688 88 C 279.929688 88.816406 280.25 89.597656 280.828125 90.171875 C 281.402344 90.75 282.183594 91.070312 283 91.070312 C 283.816406 91.070312 284.597656 90.75 285.171875 90.171875 C 285.75 89.597656 286.070312 88.816406 286.070312 88 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 319.070312 69 C 319.070312 68.183594 318.75 67.402344 318.171875 66.828125 C 317.597656 66.25 316.816406 65.929688 316 65.929688 C 315.183594 65.929688 314.402344 66.25 313.828125 66.828125 C 313.25 67.402344 312.929688 68.183594 312.929688 69 C 312.929688 69.816406 313.25 70.597656 313.828125 71.171875 C 314.402344 71.75 315.183594 72.070312 316 72.070312 C 316.816406 72.070312 317.597656 71.75 318.171875 71.171875 C 318.75 70.597656 319.070312 69.816406 319.070312 69 Z "/>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 352.070312 50 C 352.070312 49.183594 351.75 48.402344 351.171875 47.828125 C 350.597656 47.25 349.816406 46.929688 349 46.929688 C 348.183594 46.929688 347.402344 47.25 346.828125 47.828125 C 346.25 48.402344 345.929688 49.183594 345.929688 50 C 345.929688 50.816406 346.25 51.597656 346.828125 52.171875 C 347.402344 52.75 348.183594 53.070312 349 53.070312 C 349.816406 53.070312 350.597656 52.75 351.171875 52.171875 C 351.75 51.597656 352.070312 50.816406 352.070312 50 Z "/>
-<path style="fill:none;stroke-width:0.5;stroke-linecap:square;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 214.296875 L 39 214.296875 "/>
-<path style="fill:none;stroke-width:0.5;stroke-linecap:square;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 214.296875 L 39 19 "/>
-<path style="fill:none;stroke-width:0.5;stroke-linecap:square;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 19 L 355 19 "/>
-<path style="fill:none;stroke-width:0.5;stroke-linecap:square;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 19 L 355 214.296875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 95.160156 214.296875 L 95.160156 211.140625 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-1" x="89.659467" y="226.29874"/>
-  <use xlink:href="#glyph0-2" x="95.220991" y="226.29874"/>
-</g>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 204.84375 214.296875 L 204.84375 211.140625 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-1" x="196.345465" y="226.29874"/>
-  <use xlink:href="#glyph0-2" x="201.906989" y="226.29874"/>
-  <use xlink:href="#glyph0-2" x="207.468512" y="226.29874"/>
-</g>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 314.53125 214.296875 L 314.53125 211.140625 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-1" x="303.531463" y="226.29874"/>
-  <use xlink:href="#glyph0-2" x="309.092987" y="226.29874"/>
-  <use xlink:href="#glyph0-2" x="314.65451" y="226.29874"/>
-  <use xlink:href="#glyph0-2" x="320.216034" y="226.29874"/>
-</g>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 51.511719 214.296875 L 51.511719 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 62.140625 214.296875 L 62.140625 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 70.824219 214.296875 L 70.824219 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 78.167969 214.296875 L 78.167969 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 84.53125 214.296875 L 84.53125 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 90.140625 214.296875 L 90.140625 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 128.179688 214.296875 L 128.179688 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 147.492188 214.296875 L 147.492188 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 161.195312 214.296875 L 161.195312 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 171.828125 214.296875 L 171.828125 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 180.511719 214.296875 L 180.511719 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 187.855469 214.296875 L 187.855469 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 194.214844 214.296875 L 194.214844 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 199.828125 214.296875 L 199.828125 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 237.863281 214.296875 L 237.863281 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 257.179688 214.296875 L 257.179688 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 270.882812 214.296875 L 270.882812 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 281.511719 214.296875 L 281.511719 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 290.199219 214.296875 L 290.199219 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 297.539062 214.296875 L 297.539062 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 303.902344 214.296875 L 303.902344 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 309.511719 214.296875 L 309.511719 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 347.550781 214.296875 L 347.550781 212.71875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 171.960938 L 42.160156 171.960938 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-1" x="19" y="176.961688"/>
-  <use xlink:href="#glyph0-2" x="24.561523" y="176.961688"/>
-</g>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph1-1" x="30" y="172.81325"/>
-</g>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 108.234375 L 42.160156 108.234375 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-1" x="19" y="113.23603"/>
-  <use xlink:href="#glyph0-2" x="24.561523" y="113.23603"/>
-</g>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph1-2" x="30" y="109.087593"/>
-</g>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 44.511719 L 42.160156 44.511719 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-1" x="19" y="49.510373"/>
-  <use xlink:href="#glyph0-2" x="24.561523" y="49.510373"/>
-</g>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph1-3" x="30" y="45.361936"/>
-</g>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 205.28125 L 40.578125 205.28125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 197.320312 L 40.578125 197.320312 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 191.144531 L 40.578125 191.144531 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 186.097656 L 40.578125 186.097656 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 181.832031 L 40.578125 181.832031 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 178.136719 L 40.578125 178.136719 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 174.878906 L 40.578125 174.878906 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 152.777344 L 40.578125 152.777344 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 141.558594 L 40.578125 141.558594 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 133.59375 L 40.578125 133.59375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 127.417969 L 40.578125 127.417969 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 122.375 L 40.578125 122.375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 118.105469 L 40.578125 118.105469 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 114.410156 L 40.578125 114.410156 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 111.152344 L 40.578125 111.152344 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 89.050781 L 40.578125 89.050781 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 77.832031 L 40.578125 77.832031 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 69.871094 L 40.578125 69.871094 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 63.695312 L 40.578125 63.695312 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 58.648438 L 40.578125 58.648438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 54.382812 L 40.578125 54.382812 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 50.6875 L 40.578125 50.6875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 47.425781 L 40.578125 47.425781 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 39 25.328125 L 40.578125 25.328125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 95.160156 19 L 95.160156 22.160156 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 204.84375 19 L 204.84375 22.160156 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 314.53125 19 L 314.53125 22.160156 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 51.511719 19 L 51.511719 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 62.140625 19 L 62.140625 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 70.824219 19 L 70.824219 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 78.167969 19 L 78.167969 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 84.53125 19 L 84.53125 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 90.140625 19 L 90.140625 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 128.179688 19 L 128.179688 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 147.492188 19 L 147.492188 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 161.195312 19 L 161.195312 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 171.828125 19 L 171.828125 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 180.511719 19 L 180.511719 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 187.855469 19 L 187.855469 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 194.214844 19 L 194.214844 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 199.828125 19 L 199.828125 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 237.863281 19 L 237.863281 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 257.179688 19 L 257.179688 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 270.882812 19 L 270.882812 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 281.511719 19 L 281.511719 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 290.199219 19 L 290.199219 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 297.539062 19 L 297.539062 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 303.902344 19 L 303.902344 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 309.511719 19 L 309.511719 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 347.550781 19 L 347.550781 20.578125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 171.960938 L 351.839844 171.960938 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 108.234375 L 351.839844 108.234375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 44.511719 L 351.839844 44.511719 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 205.28125 L 353.421875 205.28125 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 197.320312 L 353.421875 197.320312 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 191.144531 L 353.421875 191.144531 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 186.097656 L 353.421875 186.097656 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 181.832031 L 353.421875 181.832031 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 178.136719 L 353.421875 178.136719 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 174.878906 L 353.421875 174.878906 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 152.777344 L 353.421875 152.777344 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 141.558594 L 353.421875 141.558594 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 133.59375 L 353.421875 133.59375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 127.417969 L 353.421875 127.417969 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 122.375 L 353.421875 122.375 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 118.105469 L 353.421875 118.105469 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 114.410156 L 353.421875 114.410156 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 111.152344 L 353.421875 111.152344 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 89.050781 L 353.421875 89.050781 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 77.832031 L 353.421875 77.832031 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 69.871094 L 353.421875 69.871094 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 63.695312 L 353.421875 63.695312 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 58.648438 L 353.421875 58.648438 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 54.382812 L 353.421875 54.382812 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 50.6875 L 353.421875 50.6875 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 47.425781 L 353.421875 47.425781 "/>
-<path style="fill:none;stroke-width:0.1;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(39.99939%,39.99939%,39.99939%);stroke-opacity:1;stroke-miterlimit:3.25;" d="M 355 25.328125 L 353.421875 25.328125 "/>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph0-3" x="175.5" y="245.29874"/>
-  <use xlink:href="#glyph0-4" x="181.608398" y="245.29874"/>
-  <use xlink:href="#glyph0-5" x="187.169922" y="245.29874"/>
-  <use xlink:href="#glyph0-6" x="192.731445" y="245.29874"/>
-  <use xlink:href="#glyph0-7" x="197.731445" y="245.29874"/>
-  <use xlink:href="#glyph0-8" x="200.509766" y="245.29874"/>
-  <use xlink:href="#glyph0-9" x="202.731445" y="245.29874"/>
-  <use xlink:href="#glyph0-5" x="208.292969" y="245.29874"/>
-  <use xlink:href="#glyph0-10" x="213.854492" y="245.29874"/>
-</g>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph2-1" x="9" y="129.14937"/>
-  <use xlink:href="#glyph2-2" x="9" y="122.479448"/>
-  <use xlink:href="#glyph2-3" x="9" y="117.479448"/>
-  <use xlink:href="#glyph2-4" x="9" y="114.701128"/>
-  <use xlink:href="#glyph2-5" x="9" y="109.139605"/>
-</g>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph3-1" x="148" y="12"/>
-  <use xlink:href="#glyph3-2" x="155.330078" y="12"/>
-  <use xlink:href="#glyph3-3" x="157.996094" y="12"/>
-  <use xlink:href="#glyph3-4" x="160.662109" y="12"/>
-</g>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph3-5" x="170" y="12"/>
-  <use xlink:href="#glyph3-2" x="176" y="12"/>
-  <use xlink:href="#glyph3-6" x="178.666016" y="12"/>
-  <use xlink:href="#glyph3-4" x="184.666016" y="12"/>
-</g>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph3-7" x="194" y="12"/>
-  <use xlink:href="#glyph3-8" x="200.673828" y="12"/>
-</g>
-<g style="fill:rgb(39.99939%,39.99939%,39.99939%);fill-opacity:1;">
-  <use xlink:href="#glyph3-9" x="207" y="12"/>
-  <use xlink:href="#glyph3-7" x="216.996094" y="12"/>
-  <use xlink:href="#glyph3-10" x="223.669922" y="12"/>
-  <use xlink:href="#glyph3-11" x="230.34375" y="12"/>
-  <use xlink:href="#glyph3-3" x="237.017578" y="12"/>
-  <use xlink:href="#glyph3-4" x="239.683594" y="12"/>
-</g>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(36.84082%,50.67749%,70.979309%);fill-opacity:1;" d="M 382.148438 113 C 382.148438 112.164062 381.816406 111.363281 381.226562 110.773438 C 380.636719 110.183594 379.835938 109.851562 379 109.851562 C 378.164062 109.851562 377.363281 110.183594 376.773438 110.773438 C 376.183594 111.363281 375.851562 112.164062 375.851562 113 C 375.851562 113.835938 376.183594 114.636719 376.773438 115.226562 C 377.363281 115.816406 378.164062 116.148438 379 116.148438 C 379.835938 116.148438 380.636719 115.816406 381.226562 115.226562 C 381.816406 114.636719 382.148438 113.835938 382.148438 113 Z "/>
-<g style="fill:rgb(0%,0%,0%);fill-opacity:1;">
-  <use xlink:href="#glyph4-1" x="391" y="117.28418"/>
-  <use xlink:href="#glyph4-2" x="399.670898" y="117.28418"/>
-  <use xlink:href="#glyph4-2" x="406.901367" y="117.28418"/>
-  <use xlink:href="#glyph4-3" x="414.131836" y="117.28418"/>
-  <use xlink:href="#glyph4-4" x="420.631836" y="117.28418"/>
-</g>
-<g style="fill:rgb(0%,0%,0%);fill-opacity:1;">
-  <use xlink:href="#glyph4-5" x="424" y="117.28418"/>
-</g>
-<g style="fill:rgb(0%,0%,0%);fill-opacity:1;">
-  <use xlink:href="#glyph4-6" x="428" y="117.28418"/>
-  <use xlink:href="#glyph4-7" x="436.670898" y="117.28418"/>
-  <use xlink:href="#glyph4-4" x="443.170898" y="117.28418"/>
-  <use xlink:href="#glyph4-8" x="446.783203" y="117.28418"/>
-  <use xlink:href="#glyph4-2" x="454.013672" y="117.28418"/>
-  <use xlink:href="#glyph4-9" x="461.244141" y="117.28418"/>
-</g>
-<path style=" stroke:none;fill-rule:evenodd;fill:rgb(88.070679%,61.103821%,14.204407%);fill-opacity:1;" d="M 382.148438 136 C 382.148438 135.164062 381.816406 134.363281 381.226562 133.773438 C 380.636719 133.183594 379.835938 132.851562 379 132.851562 C 378.164062 132.851562 377.363281 133.183594 376.773438 133.773438 C 376.183594 134.363281 375.851562 135.164062 375.851562 136 C 375.851562 136.835938 376.183594 137.636719 376.773438 138.226562 C 377.363281 138.816406 378.164062 139.148438 379 139.148438 C 379.835938 139.148438 380.636719 138.816406 381.226562 138.226562 C 381.816406 137.636719 382.148438 136.835938 382.148438 136 Z "/>
-<g style="fill:rgb(0%,0%,0%);fill-opacity:1;">
-  <use xlink:href="#glyph4-10" x="391" y="140.28418"/>
-  <use xlink:href="#glyph4-7" x="398.230469" y="140.28418"/>
-  <use xlink:href="#glyph4-11" x="404.730469" y="140.28418"/>
-  <use xlink:href="#glyph4-12" x="411.960938" y="140.28418"/>
-  <use xlink:href="#glyph4-9" x="414.849609" y="140.28418"/>
-  <use xlink:href="#glyph4-13" x="422.080078" y="140.28418"/>
-  <use xlink:href="#glyph4-14" x="429.310547" y="140.28418"/>
-  <use xlink:href="#glyph4-14" x="436.541016" y="140.28418"/>
-</g>
-</g>
-</svg>
diff --git a/tmap/lib/pybind11/docs/reference.rst b/tmap/lib/pybind11/docs/reference.rst
deleted file mode 100644
index e41141b..0000000
--- a/tmap/lib/pybind11/docs/reference.rst
+++ /dev/null
@@ -1,102 +0,0 @@
-.. _reference:
-
-.. warning::
-
-    Please be advised that the reference documentation discussing pybind11
-    internals is currently incomplete. Please refer to the previous sections
-    and the pybind11 header files for the nitty gritty details.
-
-Reference
-#########
-
-.. _macros:
-
-Macros
-======
-
-.. doxygendefine:: PYBIND11_MODULE
-
-.. _core_types:
-
-Convenience classes for arbitrary Python types
-==============================================
-
-Common member functions
------------------------
-
-.. doxygenclass:: object_api
-    :members:
-
-Without reference counting
---------------------------
-
-.. doxygenclass:: handle
-    :members:
-
-With reference counting
------------------------
-
-.. doxygenclass:: object
-    :members:
-
-.. doxygenfunction:: reinterpret_borrow
-
-.. doxygenfunction:: reinterpret_steal
-
-Convenience classes for specific Python types
-=============================================
-
-.. doxygenclass:: module
-    :members:
-
-.. doxygengroup:: pytypes
-    :members:
-
-.. _extras:
-
-Passing extra arguments to ``def`` or ``class_``
-================================================
-
-.. doxygengroup:: annotations
-    :members:
-
-Embedding the interpreter
-=========================
-
-.. doxygendefine:: PYBIND11_EMBEDDED_MODULE
-
-.. doxygenfunction:: initialize_interpreter
-
-.. doxygenfunction:: finalize_interpreter
-
-.. doxygenclass:: scoped_interpreter
-
-Redirecting C++ streams
-=======================
-
-.. doxygenclass:: scoped_ostream_redirect
-
-.. doxygenclass:: scoped_estream_redirect
-
-.. doxygenfunction:: add_ostream_redirect
-
-Python build-in functions
-=========================
-
-.. doxygengroup:: python_builtins
-    :members:
-
-Exceptions
-==========
-
-.. doxygenclass:: error_already_set
-    :members:
-
-.. doxygenclass:: builtin_exception
-    :members:
-
-
-Literals
-========
-
-.. doxygennamespace:: literals
diff --git a/tmap/lib/pybind11/docs/release.rst b/tmap/lib/pybind11/docs/release.rst
deleted file mode 100644
index 39fccd2..0000000
--- a/tmap/lib/pybind11/docs/release.rst
+++ /dev/null
@@ -1,24 +0,0 @@
-To release a new version of pybind11:
-
-- Update the version number and push to pypi
-    - Update ``pybind11/_version.py`` (set release version, remove 'dev').
-    - Update ``PYBIND11_VERSION_MAJOR`` etc. in ``include/pybind11/detail/common.h``.
-    - Ensure that all the information in ``setup.py`` is up-to-date.
-    - Update version in ``docs/conf.py``.
-    - Tag release date in ``docs/changelog.rst``.
-    - ``git add`` and ``git commit``.
-    - if new minor version: ``git checkout -b vX.Y``, ``git push -u origin vX.Y``
-    - ``git tag -a vX.Y.Z -m 'vX.Y.Z release'``.
-    - ``git push``
-    - ``git push --tags``.
-    - ``python setup.py sdist upload``.
-    - ``python setup.py bdist_wheel upload``.
-- Update conda-forge (https://github.com/conda-forge/pybind11-feedstock) via PR
-    - change version number in ``recipe/meta.yml``
-    - update checksum to match the one computed by pypi
-- Get back to work
-    - Update ``_version.py`` (add 'dev' and increment minor).
-    - Update version in ``docs/conf.py``
-    - Update version macros in ``include/pybind11/common.h``
-    - ``git add`` and ``git commit``.
-      ``git push``
diff --git a/tmap/lib/pybind11/docs/requirements.txt b/tmap/lib/pybind11/docs/requirements.txt
deleted file mode 100644
index 3818fe8..0000000
--- a/tmap/lib/pybind11/docs/requirements.txt
+++ /dev/null
@@ -1 +0,0 @@
-breathe == 4.5.0
diff --git a/tmap/lib/pybind11/docs/upgrade.rst b/tmap/lib/pybind11/docs/upgrade.rst
deleted file mode 100644
index 5ad7c29..0000000
--- a/tmap/lib/pybind11/docs/upgrade.rst
+++ /dev/null
@@ -1,377 +0,0 @@
-Upgrade guide
-#############
-
-This is a companion guide to the :doc:`changelog`. While the changelog briefly
-lists all of the new features, improvements and bug fixes, this upgrade guide
-focuses only the subset which directly impacts your experience when upgrading
-to a new version. But it goes into more detail. This includes things like
-deprecated APIs and their replacements, build system changes, general code
-modernization and other useful information.
-
-
-v2.2
-====
-
-Deprecation of the ``PYBIND11_PLUGIN`` macro
---------------------------------------------
-
-``PYBIND11_MODULE`` is now the preferred way to create module entry points.
-The old macro emits a compile-time deprecation warning.
-
-.. code-block:: cpp
-
-    // old
-    PYBIND11_PLUGIN(example) {
-        py::module m("example", "documentation string");
-
-        m.def("add", [](int a, int b) { return a + b; });
-
-        return m.ptr();
-    }
-
-    // new
-    PYBIND11_MODULE(example, m) {
-        m.doc() = "documentation string"; // optional
-
-        m.def("add", [](int a, int b) { return a + b; });
-    }
-
-
-New API for defining custom constructors and pickling functions
----------------------------------------------------------------
-
-The old placement-new custom constructors have been deprecated. The new approach
-uses ``py::init()`` and factory functions to greatly improve type safety.
-
-Placement-new can be called accidentally with an incompatible type (without any
-compiler errors or warnings), or it can initialize the same object multiple times
-if not careful with the Python-side ``__init__`` calls. The new-style custom
-constructors prevent such mistakes. See :ref:`custom_constructors` for details.
-
-.. code-block:: cpp
-
-    // old -- deprecated (runtime warning shown only in debug mode)
-    py::class<Foo>(m, "Foo")
-        .def("__init__", [](Foo &self, ...) {
-            new (&self) Foo(...); // uses placement-new
-        });
-
-    // new
-    py::class<Foo>(m, "Foo")
-        .def(py::init([](...) { // Note: no `self` argument
-            return new Foo(...); // return by raw pointer
-            // or: return std::make_unique<Foo>(...); // return by holder
-            // or: return Foo(...); // return by value (move constructor)
-        }));
-
-Mirroring the custom constructor changes, ``py::pickle()`` is now the preferred
-way to get and set object state. See :ref:`pickling` for details.
-
-.. code-block:: cpp
-
-    // old -- deprecated (runtime warning shown only in debug mode)
-    py::class<Foo>(m, "Foo")
-        ...
-        .def("__getstate__", [](const Foo &self) {
-            return py::make_tuple(self.value1(), self.value2(), ...);
-        })
-        .def("__setstate__", [](Foo &self, py::tuple t) {
-            new (&self) Foo(t[0].cast<std::string>(), ...);
-        });
-
-    // new
-    py::class<Foo>(m, "Foo")
-        ...
-        .def(py::pickle(
-            [](const Foo &self) { // __getstate__
-                return py::make_tuple(f.value1(), f.value2(), ...); // unchanged
-            },
-            [](py::tuple t) { // __setstate__, note: no `self` argument
-                return new Foo(t[0].cast<std::string>(), ...);
-                // or: return std::make_unique<Foo>(...); // return by holder
-                // or: return Foo(...); // return by value (move constructor)
-            }
-        ));
-
-For both the constructors and pickling, warnings are shown at module
-initialization time (on import, not when the functions are called).
-They're only visible when compiled in debug mode. Sample warning:
-
-.. code-block:: none
-
-    pybind11-bound class 'mymodule.Foo' is using an old-style placement-new '__init__'
-    which has been deprecated. See the upgrade guide in pybind11's docs.
-
-
-Stricter enforcement of hidden symbol visibility for pybind11 modules
----------------------------------------------------------------------
-
-pybind11 now tries to actively enforce hidden symbol visibility for modules.
-If you're using either one of pybind11's :doc:`CMake or Python build systems
-<compiling>` (the two example repositories) and you haven't been exporting any
-symbols, there's nothing to be concerned about. All the changes have been done
-transparently in the background. If you were building manually or relied on
-specific default visibility, read on.
-
-Setting default symbol visibility to *hidden* has always been recommended for
-pybind11 (see :ref:`faq:symhidden`). On Linux and macOS, hidden symbol
-visibility (in conjunction with the ``strip`` utility) yields much smaller
-module binaries. `CPython's extension docs`_ also recommend hiding symbols
-by default, with the goal of avoiding symbol name clashes between modules.
-Starting with v2.2, pybind11 enforces this more strictly: (1) by declaring
-all symbols inside the ``pybind11`` namespace as hidden and (2) by including
-the ``-fvisibility=hidden`` flag on Linux and macOS (only for extension
-modules, not for embedding the interpreter).
-
-.. _CPython's extension docs: https://docs.python.org/3/extending/extending.html#providing-a-c-api-for-an-extension-module
-
-The namespace-scope hidden visibility is done automatically in pybind11's
-headers and it's generally transparent to users. It ensures that:
-
-* Modules compiled with different pybind11 versions don't clash with each other.
-
-* Some new features, like ``py::module_local`` bindings, can work as intended.
-
-The ``-fvisibility=hidden`` flag applies the same visibility to user bindings
-outside of the ``pybind11`` namespace. It's now set automatic by pybind11's
-CMake and Python build systems, but this needs to be done manually by users
-of other build systems. Adding this flag:
-
-* Minimizes the chances of symbol conflicts between modules. E.g. if two
-  unrelated modules were statically linked to different (ABI-incompatible)
-  versions of the same third-party library, a symbol clash would be likely
-  (and would end with unpredictable results).
-
-* Produces smaller binaries on Linux and macOS, as pointed out previously.
-
-Within pybind11's CMake build system, ``pybind11_add_module`` has always been
-setting the ``-fvisibility=hidden`` flag in release mode. From now on, it's
-being applied unconditionally, even in debug mode and it can no longer be opted
-out of with the ``NO_EXTRAS`` option. The ``pybind11::module`` target now also
-adds this flag to it's interface. The ``pybind11::embed`` target is unchanged.
-
-The most significant change here is for the ``pybind11::module`` target. If you
-were previously relying on default visibility, i.e. if your Python module was
-doubling as a shared library with dependents, you'll need to either export
-symbols manually (recommended for cross-platform libraries) or factor out the
-shared library (and have the Python module link to it like the other
-dependents). As a temporary workaround, you can also restore default visibility
-using the CMake code below, but this is not recommended in the long run:
-
-.. code-block:: cmake
-
-    target_link_libraries(mymodule PRIVATE pybind11::module)
-
-    add_library(restore_default_visibility INTERFACE)
-    target_compile_options(restore_default_visibility INTERFACE -fvisibility=default)
-    target_link_libraries(mymodule PRIVATE restore_default_visibility)
-
-
-Local STL container bindings
-----------------------------
-
-Previous pybind11 versions could only bind types globally -- all pybind11
-modules, even unrelated ones, would have access to the same exported types.
-However, this would also result in a conflict if two modules exported the
-same C++ type, which is especially problematic for very common types, e.g.
-``std::vector<int>``. :ref:`module_local` were added to resolve this (see
-that section for a complete usage guide).
-
-``py::class_`` still defaults to global bindings (because these types are
-usually unique across modules), however in order to avoid clashes of opaque
-types, ``py::bind_vector`` and ``py::bind_map`` will now bind STL containers
-as ``py::module_local`` if their elements are: builtins (``int``, ``float``,
-etc.), not bound using ``py::class_``, or bound as ``py::module_local``. For
-example, this change allows multiple modules to bind ``std::vector<int>``
-without causing conflicts. See :ref:`stl_bind` for more details.
-
-When upgrading to this version, if you have multiple modules which depend on
-a single global binding of an STL container, note that all modules can still
-accept foreign  ``py::module_local`` types in the direction of Python-to-C++.
-The locality only affects the C++-to-Python direction. If this is needed in
-multiple modules, you'll need to either:
-
-* Add a copy of the same STL binding to all of the modules which need it.
-
-* Restore the global status of that single binding by marking it
-  ``py::module_local(false)``.
-
-The latter is an easy workaround, but in the long run it would be best to
-localize all common type bindings in order to avoid conflicts with
-third-party modules.
-
-
-Negative strides for Python buffer objects and numpy arrays
------------------------------------------------------------
-
-Support for negative strides required changing the integer type from unsigned
-to signed in the interfaces of ``py::buffer_info`` and ``py::array``. If you
-have compiler warnings enabled, you may notice some new conversion warnings
-after upgrading. These can be resolved using ``static_cast``.
-
-
-Deprecation of some ``py::object`` APIs
----------------------------------------
-
-To compare ``py::object`` instances by pointer, you should now use
-``obj1.is(obj2)`` which is equivalent to ``obj1 is obj2`` in Python.
-Previously, pybind11 used ``operator==`` for this (``obj1 == obj2``), but
-that could be confusing and is now deprecated (so that it can eventually
-be replaced with proper rich object comparison in a future release).
-
-For classes which inherit from ``py::object``, ``borrowed`` and ``stolen``
-were previously available as protected constructor tags. Now the types
-should be used directly instead: ``borrowed_t{}`` and ``stolen_t{}``
-(`#771 <https://github.com/pybind/pybind11/pull/771>`_).
-
-
-v2.1
-====
-
-Minimum compiler versions are enforced at compile time
-------------------------------------------------------
-
-The minimums also apply to v2.0 but the check is now explicit and a compile-time
-error is raised if the compiler does not meet the requirements:
-
-* GCC >= 4.8
-* clang >= 3.3 (appleclang >= 5.0)
-* MSVC >= 2015u3
-* Intel C++ >= 15.0
-
-
-The ``py::metaclass`` attribute is not required for static properties
----------------------------------------------------------------------
-
-Binding classes with static properties is now possible by default. The
-zero-parameter version of ``py::metaclass()`` is deprecated. However, a new
-one-parameter ``py::metaclass(python_type)`` version was added for rare
-cases when a custom metaclass is needed to override pybind11's default.
-
-.. code-block:: cpp
-
-    // old -- emits a deprecation warning
-    py::class_<Foo>(m, "Foo", py::metaclass())
-        .def_property_readonly_static("foo", ...);
-
-    // new -- static properties work without the attribute
-    py::class_<Foo>(m, "Foo")
-        .def_property_readonly_static("foo", ...);
-
-    // new -- advanced feature, override pybind11's default metaclass
-    py::class_<Bar>(m, "Bar", py::metaclass(custom_python_type))
-        ...
-
-
-v2.0
-====
-
-Breaking changes in ``py::class_``
-----------------------------------
-
-These changes were necessary to make type definitions in pybind11
-future-proof, to support PyPy via its ``cpyext`` mechanism (`#527
-<https://github.com/pybind/pybind11/pull/527>`_), and to improve efficiency
-(`rev. 86d825 <https://github.com/pybind/pybind11/commit/86d825>`_).
-
-1. Declarations of types that provide access via the buffer protocol must
-   now include the ``py::buffer_protocol()`` annotation as an argument to
-   the ``py::class_`` constructor.
-
-   .. code-block:: cpp
-
-       py::class_<Matrix>("Matrix", py::buffer_protocol())
-           .def(py::init<...>())
-           .def_buffer(...);
-
-2. Classes which include static properties (e.g. ``def_readwrite_static()``)
-   must now include the ``py::metaclass()`` attribute. Note: this requirement
-   has since been removed in v2.1. If you're upgrading from 1.x, it's
-   recommended to skip directly to v2.1 or newer.
-
-3. This version of pybind11 uses a redesigned mechanism for instantiating
-   trampoline classes that are used to override virtual methods from within
-   Python. This led to the following user-visible syntax change:
-
-   .. code-block:: cpp
-
-       // old v1.x syntax
-       py::class_<TrampolineClass>("MyClass")
-           .alias<MyClass>()
-           ...
-
-       // new v2.x syntax
-       py::class_<MyClass, TrampolineClass>("MyClass")
-           ...
-
-   Importantly, both the original and the trampoline class are now specified
-   as arguments to the ``py::class_`` template, and the ``alias<..>()`` call
-   is gone. The new scheme has zero overhead in cases when Python doesn't
-   override any functions of the underlying C++ class.
-   `rev. 86d825 <https://github.com/pybind/pybind11/commit/86d825>`_.
-
-   The class type must be the first template argument given to ``py::class_``
-   while the trampoline can be mixed in arbitrary order with other arguments
-   (see the following section).
-
-
-Deprecation of the ``py::base<T>()`` attribute
-----------------------------------------------
-
-``py::base<T>()`` was deprecated in favor of specifying ``T`` as a template
-argument to ``py::class_``. This new syntax also supports multiple inheritance.
-Note that, while the type being exported must be the first argument in the
-``py::class_<Class, ...>`` template, the order of the following types (bases,
-holder and/or trampoline) is not important.
-
-.. code-block:: cpp
-
-    // old v1.x
-    py::class_<Derived>("Derived", py::base<Base>());
-
-    // new v2.x
-    py::class_<Derived, Base>("Derived");
-
-    // new -- multiple inheritance
-    py::class_<Derived, Base1, Base2>("Derived");
-
-    // new -- apart from `Derived` the argument order can be arbitrary
-    py::class_<Derived, Base1, Holder, Base2, Trampoline>("Derived");
-
-
-Out-of-the-box support for ``std::shared_ptr``
-----------------------------------------------
-
-The relevant type caster is now built in, so it's no longer necessary to
-include a declaration of the form:
-
-.. code-block:: cpp
-
-    PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
-
-Continuing to do so won’t cause an error or even a deprecation warning,
-but it's completely redundant.
-
-
-Deprecation of a few ``py::object`` APIs
-----------------------------------------
-
-All of the old-style calls emit deprecation warnings.
-
-+---------------------------------------+---------------------------------------------+
-|  Old syntax                           |  New syntax                                 |
-+=======================================+=============================================+
-| ``obj.call(args...)``                 | ``obj(args...)``                            |
-+---------------------------------------+---------------------------------------------+
-| ``obj.str()``                         | ``py::str(obj)``                            |
-+---------------------------------------+---------------------------------------------+
-| ``auto l = py::list(obj); l.check()`` | ``py::isinstance<py::list>(obj)``           |
-+---------------------------------------+---------------------------------------------+
-| ``py::object(ptr, true)``             | ``py::reinterpret_borrow<py::object>(ptr)`` |
-+---------------------------------------+---------------------------------------------+
-| ``py::object(ptr, false)``            | ``py::reinterpret_steal<py::object>(ptr)``  |
-+---------------------------------------+---------------------------------------------+
-| ``if (obj.attr("foo"))``              | ``if (py::hasattr(obj, "foo"))``            |
-+---------------------------------------+---------------------------------------------+
-| ``if (obj["bar"])``                   | ``if (obj.contains("bar"))``                |
-+---------------------------------------+---------------------------------------------+
diff --git a/tmap/lib/pybind11/include/pybind11/attr.h b/tmap/lib/pybind11/include/pybind11/attr.h
deleted file mode 100644
index dce875a..0000000
--- a/tmap/lib/pybind11/include/pybind11/attr.h
+++ /dev/null
@@ -1,489 +0,0 @@
-/*
-    pybind11/attr.h: Infrastructure for processing custom
-    type and function attributes
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "cast.h"
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-
-/// \addtogroup annotations
-/// @{
-
-/// Annotation for methods
-struct is_method { handle class_; is_method(const handle &c) : class_(c) { } };
-
-/// Annotation for operators
-struct is_operator { };
-
-/// Annotation for parent scope
-struct scope { handle value; scope(const handle &s) : value(s) { } };
-
-/// Annotation for documentation
-struct doc { const char *value; doc(const char *value) : value(value) { } };
-
-/// Annotation for function names
-struct name { const char *value; name(const char *value) : value(value) { } };
-
-/// Annotation indicating that a function is an overload associated with a given "sibling"
-struct sibling { handle value; sibling(const handle &value) : value(value.ptr()) { } };
-
-/// Annotation indicating that a class derives from another given type
-template <typename T> struct base {
-    PYBIND11_DEPRECATED("base<T>() was deprecated in favor of specifying 'T' as a template argument to class_")
-    base() { }
-};
-
-/// Keep patient alive while nurse lives
-template <size_t Nurse, size_t Patient> struct keep_alive { };
-
-/// Annotation indicating that a class is involved in a multiple inheritance relationship
-struct multiple_inheritance { };
-
-/// Annotation which enables dynamic attributes, i.e. adds `__dict__` to a class
-struct dynamic_attr { };
-
-/// Annotation which enables the buffer protocol for a type
-struct buffer_protocol { };
-
-/// Annotation which requests that a special metaclass is created for a type
-struct metaclass {
-    handle value;
-
-    PYBIND11_DEPRECATED("py::metaclass() is no longer required. It's turned on by default now.")
-    metaclass() {}
-
-    /// Override pybind11's default metaclass
-    explicit metaclass(handle value) : value(value) { }
-};
-
-/// Annotation that marks a class as local to the module:
-struct module_local { const bool value; constexpr module_local(bool v = true) : value(v) { } };
-
-/// Annotation to mark enums as an arithmetic type
-struct arithmetic { };
-
-/** \rst
-    A call policy which places one or more guard variables (``Ts...``) around the function call.
-
-    For example, this definition:
-
-    .. code-block:: cpp
-
-        m.def("foo", foo, py::call_guard<T>());
-
-    is equivalent to the following pseudocode:
-
-    .. code-block:: cpp
-
-        m.def("foo", [](args...) {
-            T scope_guard;
-            return foo(args...); // forwarded arguments
-        });
- \endrst */
-template <typename... Ts> struct call_guard;
-
-template <> struct call_guard<> { using type = detail::void_type; };
-
-template <typename T>
-struct call_guard<T> {
-    static_assert(std::is_default_constructible<T>::value,
-                  "The guard type must be default constructible");
-
-    using type = T;
-};
-
-template <typename T, typename... Ts>
-struct call_guard<T, Ts...> {
-    struct type {
-        T guard{}; // Compose multiple guard types with left-to-right default-constructor order
-        typename call_guard<Ts...>::type next{};
-    };
-};
-
-/// @} annotations
-
-NAMESPACE_BEGIN(detail)
-/* Forward declarations */
-enum op_id : int;
-enum op_type : int;
-struct undefined_t;
-template <op_id id, op_type ot, typename L = undefined_t, typename R = undefined_t> struct op_;
-inline void keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret);
-
-/// Internal data structure which holds metadata about a keyword argument
-struct argument_record {
-    const char *name;  ///< Argument name
-    const char *descr; ///< Human-readable version of the argument value
-    handle value;      ///< Associated Python object
-    bool convert : 1;  ///< True if the argument is allowed to convert when loading
-    bool none : 1;     ///< True if None is allowed when loading
-
-    argument_record(const char *name, const char *descr, handle value, bool convert, bool none)
-        : name(name), descr(descr), value(value), convert(convert), none(none) { }
-};
-
-/// Internal data structure which holds metadata about a bound function (signature, overloads, etc.)
-struct function_record {
-    function_record()
-        : is_constructor(false), is_new_style_constructor(false), is_stateless(false),
-          is_operator(false), has_args(false), has_kwargs(false), is_method(false) { }
-
-    /// Function name
-    char *name = nullptr; /* why no C++ strings? They generate heavier code.. */
-
-    // User-specified documentation string
-    char *doc = nullptr;
-
-    /// Human-readable version of the function signature
-    char *signature = nullptr;
-
-    /// List of registered keyword arguments
-    std::vector<argument_record> args;
-
-    /// Pointer to lambda function which converts arguments and performs the actual call
-    handle (*impl) (function_call &) = nullptr;
-
-    /// Storage for the wrapped function pointer and captured data, if any
-    void *data[3] = { };
-
-    /// Pointer to custom destructor for 'data' (if needed)
-    void (*free_data) (function_record *ptr) = nullptr;
-
-    /// Return value policy associated with this function
-    return_value_policy policy = return_value_policy::automatic;
-
-    /// True if name == '__init__'
-    bool is_constructor : 1;
-
-    /// True if this is a new-style `__init__` defined in `detail/init.h`
-    bool is_new_style_constructor : 1;
-
-    /// True if this is a stateless function pointer
-    bool is_stateless : 1;
-
-    /// True if this is an operator (__add__), etc.
-    bool is_operator : 1;
-
-    /// True if the function has a '*args' argument
-    bool has_args : 1;
-
-    /// True if the function has a '**kwargs' argument
-    bool has_kwargs : 1;
-
-    /// True if this is a method
-    bool is_method : 1;
-
-    /// Number of arguments (including py::args and/or py::kwargs, if present)
-    std::uint16_t nargs;
-
-    /// Python method object
-    PyMethodDef *def = nullptr;
-
-    /// Python handle to the parent scope (a class or a module)
-    handle scope;
-
-    /// Python handle to the sibling function representing an overload chain
-    handle sibling;
-
-    /// Pointer to next overload
-    function_record *next = nullptr;
-};
-
-/// Special data structure which (temporarily) holds metadata about a bound class
-struct type_record {
-    PYBIND11_NOINLINE type_record()
-        : multiple_inheritance(false), dynamic_attr(false), buffer_protocol(false), module_local(false) { }
-
-    /// Handle to the parent scope
-    handle scope;
-
-    /// Name of the class
-    const char *name = nullptr;
-
-    // Pointer to RTTI type_info data structure
-    const std::type_info *type = nullptr;
-
-    /// How large is the underlying C++ type?
-    size_t type_size = 0;
-
-    /// How large is the type's holder?
-    size_t holder_size = 0;
-
-    /// The global operator new can be overridden with a class-specific variant
-    void *(*operator_new)(size_t) = ::operator new;
-
-    /// Function pointer to class_<..>::init_instance
-    void (*init_instance)(instance *, const void *) = nullptr;
-
-    /// Function pointer to class_<..>::dealloc
-    void (*dealloc)(detail::value_and_holder &) = nullptr;
-
-    /// List of base classes of the newly created type
-    list bases;
-
-    /// Optional docstring
-    const char *doc = nullptr;
-
-    /// Custom metaclass (optional)
-    handle metaclass;
-
-    /// Multiple inheritance marker
-    bool multiple_inheritance : 1;
-
-    /// Does the class manage a __dict__?
-    bool dynamic_attr : 1;
-
-    /// Does the class implement the buffer protocol?
-    bool buffer_protocol : 1;
-
-    /// Is the default (unique_ptr) holder type used?
-    bool default_holder : 1;
-
-    /// Is the class definition local to the module shared object?
-    bool module_local : 1;
-
-    PYBIND11_NOINLINE void add_base(const std::type_info &base, void *(*caster)(void *)) {
-        auto base_info = detail::get_type_info(base, false);
-        if (!base_info) {
-            std::string tname(base.name());
-            detail::clean_type_id(tname);
-            pybind11_fail("generic_type: type \"" + std::string(name) +
-                          "\" referenced unknown base type \"" + tname + "\"");
-        }
-
-        if (default_holder != base_info->default_holder) {
-            std::string tname(base.name());
-            detail::clean_type_id(tname);
-            pybind11_fail("generic_type: type \"" + std::string(name) + "\" " +
-                    (default_holder ? "does not have" : "has") +
-                    " a non-default holder type while its base \"" + tname + "\" " +
-                    (base_info->default_holder ? "does not" : "does"));
-        }
-
-        bases.append((PyObject *) base_info->type);
-
-        if (base_info->type->tp_dictoffset != 0)
-            dynamic_attr = true;
-
-        if (caster)
-            base_info->implicit_casts.emplace_back(type, caster);
-    }
-};
-
-inline function_call::function_call(function_record &f, handle p) :
-        func(f), parent(p) {
-    args.reserve(f.nargs);
-    args_convert.reserve(f.nargs);
-}
-
-/// Tag for a new-style `__init__` defined in `detail/init.h`
-struct is_new_style_constructor { };
-
-/**
- * Partial template specializations to process custom attributes provided to
- * cpp_function_ and class_. These are either used to initialize the respective
- * fields in the type_record and function_record data structures or executed at
- * runtime to deal with custom call policies (e.g. keep_alive).
- */
-template <typename T, typename SFINAE = void> struct process_attribute;
-
-template <typename T> struct process_attribute_default {
-    /// Default implementation: do nothing
-    static void init(const T &, function_record *) { }
-    static void init(const T &, type_record *) { }
-    static void precall(function_call &) { }
-    static void postcall(function_call &, handle) { }
-};
-
-/// Process an attribute specifying the function's name
-template <> struct process_attribute<name> : process_attribute_default<name> {
-    static void init(const name &n, function_record *r) { r->name = const_cast<char *>(n.value); }
-};
-
-/// Process an attribute specifying the function's docstring
-template <> struct process_attribute<doc> : process_attribute_default<doc> {
-    static void init(const doc &n, function_record *r) { r->doc = const_cast<char *>(n.value); }
-};
-
-/// Process an attribute specifying the function's docstring (provided as a C-style string)
-template <> struct process_attribute<const char *> : process_attribute_default<const char *> {
-    static void init(const char *d, function_record *r) { r->doc = const_cast<char *>(d); }
-    static void init(const char *d, type_record *r) { r->doc = const_cast<char *>(d); }
-};
-template <> struct process_attribute<char *> : process_attribute<const char *> { };
-
-/// Process an attribute indicating the function's return value policy
-template <> struct process_attribute<return_value_policy> : process_attribute_default<return_value_policy> {
-    static void init(const return_value_policy &p, function_record *r) { r->policy = p; }
-};
-
-/// Process an attribute which indicates that this is an overloaded function associated with a given sibling
-template <> struct process_attribute<sibling> : process_attribute_default<sibling> {
-    static void init(const sibling &s, function_record *r) { r->sibling = s.value; }
-};
-
-/// Process an attribute which indicates that this function is a method
-template <> struct process_attribute<is_method> : process_attribute_default<is_method> {
-    static void init(const is_method &s, function_record *r) { r->is_method = true; r->scope = s.class_; }
-};
-
-/// Process an attribute which indicates the parent scope of a method
-template <> struct process_attribute<scope> : process_attribute_default<scope> {
-    static void init(const scope &s, function_record *r) { r->scope = s.value; }
-};
-
-/// Process an attribute which indicates that this function is an operator
-template <> struct process_attribute<is_operator> : process_attribute_default<is_operator> {
-    static void init(const is_operator &, function_record *r) { r->is_operator = true; }
-};
-
-template <> struct process_attribute<is_new_style_constructor> : process_attribute_default<is_new_style_constructor> {
-    static void init(const is_new_style_constructor &, function_record *r) { r->is_new_style_constructor = true; }
-};
-
-/// Process a keyword argument attribute (*without* a default value)
-template <> struct process_attribute<arg> : process_attribute_default<arg> {
-    static void init(const arg &a, function_record *r) {
-        if (r->is_method && r->args.empty())
-            r->args.emplace_back("self", nullptr, handle(), true /*convert*/, false /*none not allowed*/);
-        r->args.emplace_back(a.name, nullptr, handle(), !a.flag_noconvert, a.flag_none);
-    }
-};
-
-/// Process a keyword argument attribute (*with* a default value)
-template <> struct process_attribute<arg_v> : process_attribute_default<arg_v> {
-    static void init(const arg_v &a, function_record *r) {
-        if (r->is_method && r->args.empty())
-            r->args.emplace_back("self", nullptr /*descr*/, handle() /*parent*/, true /*convert*/, false /*none not allowed*/);
-
-        if (!a.value) {
-#if !defined(NDEBUG)
-            std::string descr("'");
-            if (a.name) descr += std::string(a.name) + ": ";
-            descr += a.type + "'";
-            if (r->is_method) {
-                if (r->name)
-                    descr += " in method '" + (std::string) str(r->scope) + "." + (std::string) r->name + "'";
-                else
-                    descr += " in method of '" + (std::string) str(r->scope) + "'";
-            } else if (r->name) {
-                descr += " in function '" + (std::string) r->name + "'";
-            }
-            pybind11_fail("arg(): could not convert default argument "
-                          + descr + " into a Python object (type not registered yet?)");
-#else
-            pybind11_fail("arg(): could not convert default argument "
-                          "into a Python object (type not registered yet?). "
-                          "Compile in debug mode for more information.");
-#endif
-        }
-        r->args.emplace_back(a.name, a.descr, a.value.inc_ref(), !a.flag_noconvert, a.flag_none);
-    }
-};
-
-/// Process a parent class attribute.  Single inheritance only (class_ itself already guarantees that)
-template <typename T>
-struct process_attribute<T, enable_if_t<is_pyobject<T>::value>> : process_attribute_default<handle> {
-    static void init(const handle &h, type_record *r) { r->bases.append(h); }
-};
-
-/// Process a parent class attribute (deprecated, does not support multiple inheritance)
-template <typename T>
-struct process_attribute<base<T>> : process_attribute_default<base<T>> {
-    static void init(const base<T> &, type_record *r) { r->add_base(typeid(T), nullptr); }
-};
-
-/// Process a multiple inheritance attribute
-template <>
-struct process_attribute<multiple_inheritance> : process_attribute_default<multiple_inheritance> {
-    static void init(const multiple_inheritance &, type_record *r) { r->multiple_inheritance = true; }
-};
-
-template <>
-struct process_attribute<dynamic_attr> : process_attribute_default<dynamic_attr> {
-    static void init(const dynamic_attr &, type_record *r) { r->dynamic_attr = true; }
-};
-
-template <>
-struct process_attribute<buffer_protocol> : process_attribute_default<buffer_protocol> {
-    static void init(const buffer_protocol &, type_record *r) { r->buffer_protocol = true; }
-};
-
-template <>
-struct process_attribute<metaclass> : process_attribute_default<metaclass> {
-    static void init(const metaclass &m, type_record *r) { r->metaclass = m.value; }
-};
-
-template <>
-struct process_attribute<module_local> : process_attribute_default<module_local> {
-    static void init(const module_local &l, type_record *r) { r->module_local = l.value; }
-};
-
-/// Process an 'arithmetic' attribute for enums (does nothing here)
-template <>
-struct process_attribute<arithmetic> : process_attribute_default<arithmetic> {};
-
-template <typename... Ts>
-struct process_attribute<call_guard<Ts...>> : process_attribute_default<call_guard<Ts...>> { };
-
-/**
- * Process a keep_alive call policy -- invokes keep_alive_impl during the
- * pre-call handler if both Nurse, Patient != 0 and use the post-call handler
- * otherwise
- */
-template <size_t Nurse, size_t Patient> struct process_attribute<keep_alive<Nurse, Patient>> : public process_attribute_default<keep_alive<Nurse, Patient>> {
-    template <size_t N = Nurse, size_t P = Patient, enable_if_t<N != 0 && P != 0, int> = 0>
-    static void precall(function_call &call) { keep_alive_impl(Nurse, Patient, call, handle()); }
-    template <size_t N = Nurse, size_t P = Patient, enable_if_t<N != 0 && P != 0, int> = 0>
-    static void postcall(function_call &, handle) { }
-    template <size_t N = Nurse, size_t P = Patient, enable_if_t<N == 0 || P == 0, int> = 0>
-    static void precall(function_call &) { }
-    template <size_t N = Nurse, size_t P = Patient, enable_if_t<N == 0 || P == 0, int> = 0>
-    static void postcall(function_call &call, handle ret) { keep_alive_impl(Nurse, Patient, call, ret); }
-};
-
-/// Recursively iterate over variadic template arguments
-template <typename... Args> struct process_attributes {
-    static void init(const Args&... args, function_record *r) {
-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::init(args, r), 0) ... };
-        ignore_unused(unused);
-    }
-    static void init(const Args&... args, type_record *r) {
-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::init(args, r), 0) ... };
-        ignore_unused(unused);
-    }
-    static void precall(function_call &call) {
-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::precall(call), 0) ... };
-        ignore_unused(unused);
-    }
-    static void postcall(function_call &call, handle fn_ret) {
-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::postcall(call, fn_ret), 0) ... };
-        ignore_unused(unused);
-    }
-};
-
-template <typename T>
-using is_call_guard = is_instantiation<call_guard, T>;
-
-/// Extract the ``type`` from the first `call_guard` in `Extras...` (or `void_type` if none found)
-template <typename... Extra>
-using extract_guard_t = typename exactly_one_t<is_call_guard, call_guard<>, Extra...>::type;
-
-/// Check the number of named arguments at compile time
-template <typename... Extra,
-          size_t named = constexpr_sum(std::is_base_of<arg, Extra>::value...),
-          size_t self  = constexpr_sum(std::is_same<is_method, Extra>::value...)>
-constexpr bool expected_num_args(size_t nargs, bool has_args, bool has_kwargs) {
-    return named == 0 || (self + named + has_args + has_kwargs) == nargs;
-}
-
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/buffer_info.h b/tmap/lib/pybind11/include/pybind11/buffer_info.h
deleted file mode 100644
index 9f072fa..0000000
--- a/tmap/lib/pybind11/include/pybind11/buffer_info.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
-    pybind11/buffer_info.h: Python buffer object interface
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "detail/common.h"
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-
-/// Information record describing a Python buffer object
-struct buffer_info {
-    void *ptr = nullptr;          // Pointer to the underlying storage
-    ssize_t itemsize = 0;         // Size of individual items in bytes
-    ssize_t size = 0;             // Total number of entries
-    std::string format;           // For homogeneous buffers, this should be set to format_descriptor<T>::format()
-    ssize_t ndim = 0;             // Number of dimensions
-    std::vector<ssize_t> shape;   // Shape of the tensor (1 entry per dimension)
-    std::vector<ssize_t> strides; // Number of entries between adjacent entries (for each per dimension)
-
-    buffer_info() { }
-
-    buffer_info(void *ptr, ssize_t itemsize, const std::string &format, ssize_t ndim,
-                detail::any_container<ssize_t> shape_in, detail::any_container<ssize_t> strides_in)
-    : ptr(ptr), itemsize(itemsize), size(1), format(format), ndim(ndim),
-      shape(std::move(shape_in)), strides(std::move(strides_in)) {
-        if (ndim != (ssize_t) shape.size() || ndim != (ssize_t) strides.size())
-            pybind11_fail("buffer_info: ndim doesn't match shape and/or strides length");
-        for (size_t i = 0; i < (size_t) ndim; ++i)
-            size *= shape[i];
-    }
-
-    template <typename T>
-    buffer_info(T *ptr, detail::any_container<ssize_t> shape_in, detail::any_container<ssize_t> strides_in)
-    : buffer_info(private_ctr_tag(), ptr, sizeof(T), format_descriptor<T>::format(), static_cast<ssize_t>(shape_in->size()), std::move(shape_in), std::move(strides_in)) { }
-
-    buffer_info(void *ptr, ssize_t itemsize, const std::string &format, ssize_t size)
-    : buffer_info(ptr, itemsize, format, 1, {size}, {itemsize}) { }
-
-    template <typename T>
-    buffer_info(T *ptr, ssize_t size)
-    : buffer_info(ptr, sizeof(T), format_descriptor<T>::format(), size) { }
-
-    explicit buffer_info(Py_buffer *view, bool ownview = true)
-    : buffer_info(view->buf, view->itemsize, view->format, view->ndim,
-            {view->shape, view->shape + view->ndim}, {view->strides, view->strides + view->ndim}) {
-        this->view = view;
-        this->ownview = ownview;
-    }
-
-    buffer_info(const buffer_info &) = delete;
-    buffer_info& operator=(const buffer_info &) = delete;
-
-    buffer_info(buffer_info &&other) {
-        (*this) = std::move(other);
-    }
-
-    buffer_info& operator=(buffer_info &&rhs) {
-        ptr = rhs.ptr;
-        itemsize = rhs.itemsize;
-        size = rhs.size;
-        format = std::move(rhs.format);
-        ndim = rhs.ndim;
-        shape = std::move(rhs.shape);
-        strides = std::move(rhs.strides);
-        std::swap(view, rhs.view);
-        std::swap(ownview, rhs.ownview);
-        return *this;
-    }
-
-    ~buffer_info() {
-        if (view && ownview) { PyBuffer_Release(view); delete view; }
-    }
-
-private:
-    struct private_ctr_tag { };
-
-    buffer_info(private_ctr_tag, void *ptr, ssize_t itemsize, const std::string &format, ssize_t ndim,
-                detail::any_container<ssize_t> &&shape_in, detail::any_container<ssize_t> &&strides_in)
-    : buffer_info(ptr, itemsize, format, ndim, std::move(shape_in), std::move(strides_in)) { }
-
-    Py_buffer *view = nullptr;
-    bool ownview = false;
-};
-
-NAMESPACE_BEGIN(detail)
-
-template <typename T, typename SFINAE = void> struct compare_buffer_info {
-    static bool compare(const buffer_info& b) {
-        return b.format == format_descriptor<T>::format() && b.itemsize == (ssize_t) sizeof(T);
-    }
-};
-
-template <typename T> struct compare_buffer_info<T, detail::enable_if_t<std::is_integral<T>::value>> {
-    static bool compare(const buffer_info& b) {
-        return (size_t) b.itemsize == sizeof(T) && (b.format == format_descriptor<T>::value ||
-            ((sizeof(T) == sizeof(long)) && b.format == (std::is_unsigned<T>::value ? "L" : "l")) ||
-            ((sizeof(T) == sizeof(size_t)) && b.format == (std::is_unsigned<T>::value ? "N" : "n")));
-    }
-};
-
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/cast.h b/tmap/lib/pybind11/include/pybind11/cast.h
deleted file mode 100644
index 2a41937..0000000
--- a/tmap/lib/pybind11/include/pybind11/cast.h
+++ /dev/null
@@ -1,2049 +0,0 @@
-/*
-    pybind11/cast.h: Partial template specializations to cast between
-    C++ and Python types
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "pytypes.h"
-#include "detail/typeid.h"
-#include "detail/descr.h"
-#include "detail/internals.h"
-#include <array>
-#include <limits>
-#include <tuple>
-
-#if defined(PYBIND11_CPP17)
-#  if defined(__has_include)
-#    if __has_include(<string_view>)
-#      define PYBIND11_HAS_STRING_VIEW
-#    endif
-#  elif defined(_MSC_VER)
-#    define PYBIND11_HAS_STRING_VIEW
-#  endif
-#endif
-#ifdef PYBIND11_HAS_STRING_VIEW
-#include <string_view>
-#endif
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
-
-/// A life support system for temporary objects created by `type_caster::load()`.
-/// Adding a patient will keep it alive up until the enclosing function returns.
-class loader_life_support {
-public:
-    /// A new patient frame is created when a function is entered
-    loader_life_support() {
-        get_internals().loader_patient_stack.push_back(nullptr);
-    }
-
-    /// ... and destroyed after it returns
-    ~loader_life_support() {
-        auto &stack = get_internals().loader_patient_stack;
-        if (stack.empty())
-            pybind11_fail("loader_life_support: internal error");
-
-        auto ptr = stack.back();
-        stack.pop_back();
-        Py_CLEAR(ptr);
-
-        // A heuristic to reduce the stack's capacity (e.g. after long recursive calls)
-        if (stack.capacity() > 16 && stack.size() != 0 && stack.capacity() / stack.size() > 2)
-            stack.shrink_to_fit();
-    }
-
-    /// This can only be used inside a pybind11-bound function, either by `argument_loader`
-    /// at argument preparation time or by `py::cast()` at execution time.
-    PYBIND11_NOINLINE static void add_patient(handle h) {
-        auto &stack = get_internals().loader_patient_stack;
-        if (stack.empty())
-            throw cast_error("When called outside a bound function, py::cast() cannot "
-                             "do Python -> C++ conversions which require the creation "
-                             "of temporary values");
-
-        auto &list_ptr = stack.back();
-        if (list_ptr == nullptr) {
-            list_ptr = PyList_New(1);
-            if (!list_ptr)
-                pybind11_fail("loader_life_support: error allocating list");
-            PyList_SET_ITEM(list_ptr, 0, h.inc_ref().ptr());
-        } else {
-            auto result = PyList_Append(list_ptr, h.ptr());
-            if (result == -1)
-                pybind11_fail("loader_life_support: error adding patient");
-        }
-    }
-};
-
-// Gets the cache entry for the given type, creating it if necessary.  The return value is the pair
-// returned by emplace, i.e. an iterator for the entry and a bool set to `true` if the entry was
-// just created.
-inline std::pair<decltype(internals::registered_types_py)::iterator, bool> all_type_info_get_cache(PyTypeObject *type);
-
-// Populates a just-created cache entry.
-PYBIND11_NOINLINE inline void all_type_info_populate(PyTypeObject *t, std::vector<type_info *> &bases) {
-    std::vector<PyTypeObject *> check;
-    for (handle parent : reinterpret_borrow<tuple>(t->tp_bases))
-        check.push_back((PyTypeObject *) parent.ptr());
-
-    auto const &type_dict = get_internals().registered_types_py;
-    for (size_t i = 0; i < check.size(); i++) {
-        auto type = check[i];
-        // Ignore Python2 old-style class super type:
-        if (!PyType_Check((PyObject *) type)) continue;
-
-        // Check `type` in the current set of registered python types:
-        auto it = type_dict.find(type);
-        if (it != type_dict.end()) {
-            // We found a cache entry for it, so it's either pybind-registered or has pre-computed
-            // pybind bases, but we have to make sure we haven't already seen the type(s) before: we
-            // want to follow Python/virtual C++ rules that there should only be one instance of a
-            // common base.
-            for (auto *tinfo : it->second) {
-                // NB: Could use a second set here, rather than doing a linear search, but since
-                // having a large number of immediate pybind11-registered types seems fairly
-                // unlikely, that probably isn't worthwhile.
-                bool found = false;
-                for (auto *known : bases) {
-                    if (known == tinfo) { found = true; break; }
-                }
-                if (!found) bases.push_back(tinfo);
-            }
-        }
-        else if (type->tp_bases) {
-            // It's some python type, so keep follow its bases classes to look for one or more
-            // registered types
-            if (i + 1 == check.size()) {
-                // When we're at the end, we can pop off the current element to avoid growing
-                // `check` when adding just one base (which is typical--i.e. when there is no
-                // multiple inheritance)
-                check.pop_back();
-                i--;
-            }
-            for (handle parent : reinterpret_borrow<tuple>(type->tp_bases))
-                check.push_back((PyTypeObject *) parent.ptr());
-        }
-    }
-}
-
-/**
- * Extracts vector of type_info pointers of pybind-registered roots of the given Python type.  Will
- * be just 1 pybind type for the Python type of a pybind-registered class, or for any Python-side
- * derived class that uses single inheritance.  Will contain as many types as required for a Python
- * class that uses multiple inheritance to inherit (directly or indirectly) from multiple
- * pybind-registered classes.  Will be empty if neither the type nor any base classes are
- * pybind-registered.
- *
- * The value is cached for the lifetime of the Python type.
- */
-inline const std::vector<detail::type_info *> &all_type_info(PyTypeObject *type) {
-    auto ins = all_type_info_get_cache(type);
-    if (ins.second)
-        // New cache entry: populate it
-        all_type_info_populate(type, ins.first->second);
-
-    return ins.first->second;
-}
-
-/**
- * Gets a single pybind11 type info for a python type.  Returns nullptr if neither the type nor any
- * ancestors are pybind11-registered.  Throws an exception if there are multiple bases--use
- * `all_type_info` instead if you want to support multiple bases.
- */
-PYBIND11_NOINLINE inline detail::type_info* get_type_info(PyTypeObject *type) {
-    auto &bases = all_type_info(type);
-    if (bases.size() == 0)
-        return nullptr;
-    if (bases.size() > 1)
-        pybind11_fail("pybind11::detail::get_type_info: type has multiple pybind11-registered bases");
-    return bases.front();
-}
-
-inline detail::type_info *get_local_type_info(const std::type_index &tp) {
-    auto &locals = registered_local_types_cpp();
-    auto it = locals.find(tp);
-    if (it != locals.end())
-        return it->second;
-    return nullptr;
-}
-
-inline detail::type_info *get_global_type_info(const std::type_index &tp) {
-    auto &types = get_internals().registered_types_cpp;
-    auto it = types.find(tp);
-    if (it != types.end())
-        return it->second;
-    return nullptr;
-}
-
-/// Return the type info for a given C++ type; on lookup failure can either throw or return nullptr.
-PYBIND11_NOINLINE inline detail::type_info *get_type_info(const std::type_index &tp,
-                                                          bool throw_if_missing = false) {
-    if (auto ltype = get_local_type_info(tp))
-        return ltype;
-    if (auto gtype = get_global_type_info(tp))
-        return gtype;
-
-    if (throw_if_missing) {
-        std::string tname = tp.name();
-        detail::clean_type_id(tname);
-        pybind11_fail("pybind11::detail::get_type_info: unable to find type info for \"" + tname + "\"");
-    }
-    return nullptr;
-}
-
-PYBIND11_NOINLINE inline handle get_type_handle(const std::type_info &tp, bool throw_if_missing) {
-    detail::type_info *type_info = get_type_info(tp, throw_if_missing);
-    return handle(type_info ? ((PyObject *) type_info->type) : nullptr);
-}
-
-struct value_and_holder {
-    instance *inst;
-    size_t index;
-    const detail::type_info *type;
-    void **vh;
-
-    // Main constructor for a found value/holder:
-    value_and_holder(instance *i, const detail::type_info *type, size_t vpos, size_t index) :
-        inst{i}, index{index}, type{type},
-        vh{inst->simple_layout ? inst->simple_value_holder : &inst->nonsimple.values_and_holders[vpos]}
-    {}
-
-    // Default constructor (used to signal a value-and-holder not found by get_value_and_holder())
-    value_and_holder() : inst{nullptr} {}
-
-    // Used for past-the-end iterator
-    value_and_holder(size_t index) : index{index} {}
-
-    template <typename V = void> V *&value_ptr() const {
-        return reinterpret_cast<V *&>(vh[0]);
-    }
-    // True if this `value_and_holder` has a non-null value pointer
-    explicit operator bool() const { return value_ptr(); }
-
-    template <typename H> H &holder() const {
-        return reinterpret_cast<H &>(vh[1]);
-    }
-    bool holder_constructed() const {
-        return inst->simple_layout
-            ? inst->simple_holder_constructed
-            : inst->nonsimple.status[index] & instance::status_holder_constructed;
-    }
-    void set_holder_constructed(bool v = true) {
-        if (inst->simple_layout)
-            inst->simple_holder_constructed = v;
-        else if (v)
-            inst->nonsimple.status[index] |= instance::status_holder_constructed;
-        else
-            inst->nonsimple.status[index] &= (uint8_t) ~instance::status_holder_constructed;
-    }
-    bool instance_registered() const {
-        return inst->simple_layout
-            ? inst->simple_instance_registered
-            : inst->nonsimple.status[index] & instance::status_instance_registered;
-    }
-    void set_instance_registered(bool v = true) {
-        if (inst->simple_layout)
-            inst->simple_instance_registered = v;
-        else if (v)
-            inst->nonsimple.status[index] |= instance::status_instance_registered;
-        else
-            inst->nonsimple.status[index] &= (uint8_t) ~instance::status_instance_registered;
-    }
-};
-
-// Container for accessing and iterating over an instance's values/holders
-struct values_and_holders {
-private:
-    instance *inst;
-    using type_vec = std::vector<detail::type_info *>;
-    const type_vec &tinfo;
-
-public:
-    values_and_holders(instance *inst) : inst{inst}, tinfo(all_type_info(Py_TYPE(inst))) {}
-
-    struct iterator {
-    private:
-        instance *inst;
-        const type_vec *types;
-        value_and_holder curr;
-        friend struct values_and_holders;
-        iterator(instance *inst, const type_vec *tinfo)
-            : inst{inst}, types{tinfo},
-            curr(inst /* instance */,
-                 types->empty() ? nullptr : (*types)[0] /* type info */,
-                 0, /* vpos: (non-simple types only): the first vptr comes first */
-                 0 /* index */)
-        {}
-        // Past-the-end iterator:
-        iterator(size_t end) : curr(end) {}
-    public:
-        bool operator==(const iterator &other) { return curr.index == other.curr.index; }
-        bool operator!=(const iterator &other) { return curr.index != other.curr.index; }
-        iterator &operator++() {
-            if (!inst->simple_layout)
-                curr.vh += 1 + (*types)[curr.index]->holder_size_in_ptrs;
-            ++curr.index;
-            curr.type = curr.index < types->size() ? (*types)[curr.index] : nullptr;
-            return *this;
-        }
-        value_and_holder &operator*() { return curr; }
-        value_and_holder *operator->() { return &curr; }
-    };
-
-    iterator begin() { return iterator(inst, &tinfo); }
-    iterator end() { return iterator(tinfo.size()); }
-
-    iterator find(const type_info *find_type) {
-        auto it = begin(), endit = end();
-        while (it != endit && it->type != find_type) ++it;
-        return it;
-    }
-
-    size_t size() { return tinfo.size(); }
-};
-
-/**
- * Extracts C++ value and holder pointer references from an instance (which may contain multiple
- * values/holders for python-side multiple inheritance) that match the given type.  Throws an error
- * if the given type (or ValueType, if omitted) is not a pybind11 base of the given instance.  If
- * `find_type` is omitted (or explicitly specified as nullptr) the first value/holder are returned,
- * regardless of type (and the resulting .type will be nullptr).
- *
- * The returned object should be short-lived: in particular, it must not outlive the called-upon
- * instance.
- */
-PYBIND11_NOINLINE inline value_and_holder instance::get_value_and_holder(const type_info *find_type /*= nullptr default in common.h*/, bool throw_if_missing /*= true in common.h*/) {
-    // Optimize common case:
-    if (!find_type || Py_TYPE(this) == find_type->type)
-        return value_and_holder(this, find_type, 0, 0);
-
-    detail::values_and_holders vhs(this);
-    auto it = vhs.find(find_type);
-    if (it != vhs.end())
-        return *it;
-
-    if (!throw_if_missing)
-        return value_and_holder();
-
-#if defined(NDEBUG)
-    pybind11_fail("pybind11::detail::instance::get_value_and_holder: "
-            "type is not a pybind11 base of the given instance "
-            "(compile in debug mode for type details)");
-#else
-    pybind11_fail("pybind11::detail::instance::get_value_and_holder: `" +
-            std::string(find_type->type->tp_name) + "' is not a pybind11 base of the given `" +
-            std::string(Py_TYPE(this)->tp_name) + "' instance");
-#endif
-}
-
-PYBIND11_NOINLINE inline void instance::allocate_layout() {
-    auto &tinfo = all_type_info(Py_TYPE(this));
-
-    const size_t n_types = tinfo.size();
-
-    if (n_types == 0)
-        pybind11_fail("instance allocation failed: new instance has no pybind11-registered base types");
-
-    simple_layout =
-        n_types == 1 && tinfo.front()->holder_size_in_ptrs <= instance_simple_holder_in_ptrs();
-
-    // Simple path: no python-side multiple inheritance, and a small-enough holder
-    if (simple_layout) {
-        simple_value_holder[0] = nullptr;
-        simple_holder_constructed = false;
-        simple_instance_registered = false;
-    }
-    else { // multiple base types or a too-large holder
-        // Allocate space to hold: [v1*][h1][v2*][h2]...[bb...] where [vN*] is a value pointer,
-        // [hN] is the (uninitialized) holder instance for value N, and [bb...] is a set of bool
-        // values that tracks whether each associated holder has been initialized.  Each [block] is
-        // padded, if necessary, to an integer multiple of sizeof(void *).
-        size_t space = 0;
-        for (auto t : tinfo) {
-            space += 1; // value pointer
-            space += t->holder_size_in_ptrs; // holder instance
-        }
-        size_t flags_at = space;
-        space += size_in_ptrs(n_types); // status bytes (holder_constructed and instance_registered)
-
-        // Allocate space for flags, values, and holders, and initialize it to 0 (flags and values,
-        // in particular, need to be 0).  Use Python's memory allocation functions: in Python 3.6
-        // they default to using pymalloc, which is designed to be efficient for small allocations
-        // like the one we're doing here; in earlier versions (and for larger allocations) they are
-        // just wrappers around malloc.
-#if PY_VERSION_HEX >= 0x03050000
-        nonsimple.values_and_holders = (void **) PyMem_Calloc(space, sizeof(void *));
-        if (!nonsimple.values_and_holders) throw std::bad_alloc();
-#else
-        nonsimple.values_and_holders = (void **) PyMem_New(void *, space);
-        if (!nonsimple.values_and_holders) throw std::bad_alloc();
-        std::memset(nonsimple.values_and_holders, 0, space * sizeof(void *));
-#endif
-        nonsimple.status = reinterpret_cast<uint8_t *>(&nonsimple.values_and_holders[flags_at]);
-    }
-    owned = true;
-}
-
-PYBIND11_NOINLINE inline void instance::deallocate_layout() {
-    if (!simple_layout)
-        PyMem_Free(nonsimple.values_and_holders);
-}
-
-PYBIND11_NOINLINE inline bool isinstance_generic(handle obj, const std::type_info &tp) {
-    handle type = detail::get_type_handle(tp, false);
-    if (!type)
-        return false;
-    return isinstance(obj, type);
-}
-
-PYBIND11_NOINLINE inline std::string error_string() {
-    if (!PyErr_Occurred()) {
-        PyErr_SetString(PyExc_RuntimeError, "Unknown internal error occurred");
-        return "Unknown internal error occurred";
-    }
-
-    error_scope scope; // Preserve error state
-
-    std::string errorString;
-    if (scope.type) {
-        errorString += handle(scope.type).attr("__name__").cast<std::string>();
-        errorString += ": ";
-    }
-    if (scope.value)
-        errorString += (std::string) str(scope.value);
-
-    PyErr_NormalizeException(&scope.type, &scope.value, &scope.trace);
-
-#if PY_MAJOR_VERSION >= 3
-    if (scope.trace != nullptr)
-        PyException_SetTraceback(scope.value, scope.trace);
-#endif
-
-#if !defined(PYPY_VERSION)
-    if (scope.trace) {
-        PyTracebackObject *trace = (PyTracebackObject *) scope.trace;
-
-        /* Get the deepest trace possible */
-        while (trace->tb_next)
-            trace = trace->tb_next;
-
-        PyFrameObject *frame = trace->tb_frame;
-        errorString += "\n\nAt:\n";
-        while (frame) {
-            int lineno = PyFrame_GetLineNumber(frame);
-            errorString +=
-                "  " + handle(frame->f_code->co_filename).cast<std::string>() +
-                "(" + std::to_string(lineno) + "): " +
-                handle(frame->f_code->co_name).cast<std::string>() + "\n";
-            frame = frame->f_back;
-        }
-        trace = trace->tb_next;
-    }
-#endif
-
-    return errorString;
-}
-
-PYBIND11_NOINLINE inline handle get_object_handle(const void *ptr, const detail::type_info *type ) {
-    auto &instances = get_internals().registered_instances;
-    auto range = instances.equal_range(ptr);
-    for (auto it = range.first; it != range.second; ++it) {
-        for (auto vh : values_and_holders(it->second)) {
-            if (vh.type == type)
-                return handle((PyObject *) it->second);
-        }
-    }
-    return handle();
-}
-
-inline PyThreadState *get_thread_state_unchecked() {
-#if defined(PYPY_VERSION)
-    return PyThreadState_GET();
-#elif PY_VERSION_HEX < 0x03000000
-    return _PyThreadState_Current;
-#elif PY_VERSION_HEX < 0x03050000
-    return (PyThreadState*) _Py_atomic_load_relaxed(&_PyThreadState_Current);
-#elif PY_VERSION_HEX < 0x03050200
-    return (PyThreadState*) _PyThreadState_Current.value;
-#else
-    return _PyThreadState_UncheckedGet();
-#endif
-}
-
-// Forward declarations
-inline void keep_alive_impl(handle nurse, handle patient);
-inline PyObject *make_new_instance(PyTypeObject *type);
-
-class type_caster_generic {
-public:
-    PYBIND11_NOINLINE type_caster_generic(const std::type_info &type_info)
-     : typeinfo(get_type_info(type_info)) { }
-
-    type_caster_generic(const type_info *typeinfo) : typeinfo(typeinfo) { }
-
-    bool load(handle src, bool convert) {
-        return load_impl<type_caster_generic>(src, convert);
-    }
-
-    PYBIND11_NOINLINE static handle cast(const void *_src, return_value_policy policy, handle parent,
-                                         const detail::type_info *tinfo,
-                                         void *(*copy_constructor)(const void *),
-                                         void *(*move_constructor)(const void *),
-                                         const void *existing_holder = nullptr) {
-        if (!tinfo) // no type info: error will be set already
-            return handle();
-
-        void *src = const_cast<void *>(_src);
-        if (src == nullptr)
-            return none().release();
-
-        auto it_instances = get_internals().registered_instances.equal_range(src);
-        for (auto it_i = it_instances.first; it_i != it_instances.second; ++it_i) {
-            for (auto instance_type : detail::all_type_info(Py_TYPE(it_i->second))) {
-                if (instance_type && same_type(*instance_type->cpptype, *tinfo->cpptype))
-                    return handle((PyObject *) it_i->second).inc_ref();
-            }
-        }
-
-        auto inst = reinterpret_steal<object>(make_new_instance(tinfo->type));
-        auto wrapper = reinterpret_cast<instance *>(inst.ptr());
-        wrapper->owned = false;
-        void *&valueptr = values_and_holders(wrapper).begin()->value_ptr();
-
-        switch (policy) {
-            case return_value_policy::automatic:
-            case return_value_policy::take_ownership:
-                valueptr = src;
-                wrapper->owned = true;
-                break;
-
-            case return_value_policy::automatic_reference:
-            case return_value_policy::reference:
-                valueptr = src;
-                wrapper->owned = false;
-                break;
-
-            case return_value_policy::copy:
-                if (copy_constructor)
-                    valueptr = copy_constructor(src);
-                else
-                    throw cast_error("return_value_policy = copy, but the "
-                                     "object is non-copyable!");
-                wrapper->owned = true;
-                break;
-
-            case return_value_policy::move:
-                if (move_constructor)
-                    valueptr = move_constructor(src);
-                else if (copy_constructor)
-                    valueptr = copy_constructor(src);
-                else
-                    throw cast_error("return_value_policy = move, but the "
-                                     "object is neither movable nor copyable!");
-                wrapper->owned = true;
-                break;
-
-            case return_value_policy::reference_internal:
-                valueptr = src;
-                wrapper->owned = false;
-                keep_alive_impl(inst, parent);
-                break;
-
-            default:
-                throw cast_error("unhandled return_value_policy: should not happen!");
-        }
-
-        tinfo->init_instance(wrapper, existing_holder);
-
-        return inst.release();
-    }
-
-    // Base methods for generic caster; there are overridden in copyable_holder_caster
-    void load_value(value_and_holder &&v_h) {
-        auto *&vptr = v_h.value_ptr();
-        // Lazy allocation for unallocated values:
-        if (vptr == nullptr) {
-            auto *type = v_h.type ? v_h.type : typeinfo;
-            vptr = type->operator_new(type->type_size);
-        }
-        value = vptr;
-    }
-    bool try_implicit_casts(handle src, bool convert) {
-        for (auto &cast : typeinfo->implicit_casts) {
-            type_caster_generic sub_caster(*cast.first);
-            if (sub_caster.load(src, convert)) {
-                value = cast.second(sub_caster.value);
-                return true;
-            }
-        }
-        return false;
-    }
-    bool try_direct_conversions(handle src) {
-        for (auto &converter : *typeinfo->direct_conversions) {
-            if (converter(src.ptr(), value))
-                return true;
-        }
-        return false;
-    }
-    void check_holder_compat() {}
-
-    PYBIND11_NOINLINE static void *local_load(PyObject *src, const type_info *ti) {
-        auto caster = type_caster_generic(ti);
-        if (caster.load(src, false))
-            return caster.value;
-        return nullptr;
-    }
-
-    /// Try to load with foreign typeinfo, if available. Used when there is no
-    /// native typeinfo, or when the native one wasn't able to produce a value.
-    PYBIND11_NOINLINE bool try_load_foreign_module_local(handle src) {
-        constexpr auto *local_key = PYBIND11_MODULE_LOCAL_ID;
-        const auto pytype = src.get_type();
-        if (!hasattr(pytype, local_key))
-            return false;
-
-        type_info *foreign_typeinfo = reinterpret_borrow<capsule>(getattr(pytype, local_key));
-        // Only consider this foreign loader if actually foreign and is a loader of the correct cpp type
-        if (foreign_typeinfo->module_local_load == &local_load
-                || !same_type(*typeinfo->cpptype, *foreign_typeinfo->cpptype))
-            return false;
-
-        if (auto result = foreign_typeinfo->module_local_load(src.ptr(), foreign_typeinfo)) {
-            value = result;
-            return true;
-        }
-        return false;
-    }
-
-    // Implementation of `load`; this takes the type of `this` so that it can dispatch the relevant
-    // bits of code between here and copyable_holder_caster where the two classes need different
-    // logic (without having to resort to virtual inheritance).
-    template <typename ThisT>
-    PYBIND11_NOINLINE bool load_impl(handle src, bool convert) {
-        if (!src) return false;
-        if (!typeinfo) return try_load_foreign_module_local(src);
-        if (src.is_none()) {
-            // Defer accepting None to other overloads (if we aren't in convert mode):
-            if (!convert) return false;
-            value = nullptr;
-            return true;
-        }
-
-        auto &this_ = static_cast<ThisT &>(*this);
-        this_.check_holder_compat();
-
-        PyTypeObject *srctype = Py_TYPE(src.ptr());
-
-        // Case 1: If src is an exact type match for the target type then we can reinterpret_cast
-        // the instance's value pointer to the target type:
-        if (srctype == typeinfo->type) {
-            this_.load_value(reinterpret_cast<instance *>(src.ptr())->get_value_and_holder());
-            return true;
-        }
-        // Case 2: We have a derived class
-        else if (PyType_IsSubtype(srctype, typeinfo->type)) {
-            auto &bases = all_type_info(srctype);
-            bool no_cpp_mi = typeinfo->simple_type;
-
-            // Case 2a: the python type is a Python-inherited derived class that inherits from just
-            // one simple (no MI) pybind11 class, or is an exact match, so the C++ instance is of
-            // the right type and we can use reinterpret_cast.
-            // (This is essentially the same as case 2b, but because not using multiple inheritance
-            // is extremely common, we handle it specially to avoid the loop iterator and type
-            // pointer lookup overhead)
-            if (bases.size() == 1 && (no_cpp_mi || bases.front()->type == typeinfo->type)) {
-                this_.load_value(reinterpret_cast<instance *>(src.ptr())->get_value_and_holder());
-                return true;
-            }
-            // Case 2b: the python type inherits from multiple C++ bases.  Check the bases to see if
-            // we can find an exact match (or, for a simple C++ type, an inherited match); if so, we
-            // can safely reinterpret_cast to the relevant pointer.
-            else if (bases.size() > 1) {
-                for (auto base : bases) {
-                    if (no_cpp_mi ? PyType_IsSubtype(base->type, typeinfo->type) : base->type == typeinfo->type) {
-                        this_.load_value(reinterpret_cast<instance *>(src.ptr())->get_value_and_holder(base));
-                        return true;
-                    }
-                }
-            }
-
-            // Case 2c: C++ multiple inheritance is involved and we couldn't find an exact type match
-            // in the registered bases, above, so try implicit casting (needed for proper C++ casting
-            // when MI is involved).
-            if (this_.try_implicit_casts(src, convert))
-                return true;
-        }
-
-        // Perform an implicit conversion
-        if (convert) {
-            for (auto &converter : typeinfo->implicit_conversions) {
-                auto temp = reinterpret_steal<object>(converter(src.ptr(), typeinfo->type));
-                if (load_impl<ThisT>(temp, false)) {
-                    loader_life_support::add_patient(temp);
-                    return true;
-                }
-            }
-            if (this_.try_direct_conversions(src))
-                return true;
-        }
-
-        // Failed to match local typeinfo. Try again with global.
-        if (typeinfo->module_local) {
-            if (auto gtype = get_global_type_info(*typeinfo->cpptype)) {
-                typeinfo = gtype;
-                return load(src, false);
-            }
-        }
-
-        // Global typeinfo has precedence over foreign module_local
-        return try_load_foreign_module_local(src);
-    }
-
-
-    // Called to do type lookup and wrap the pointer and type in a pair when a dynamic_cast
-    // isn't needed or can't be used.  If the type is unknown, sets the error and returns a pair
-    // with .second = nullptr.  (p.first = nullptr is not an error: it becomes None).
-    PYBIND11_NOINLINE static std::pair<const void *, const type_info *> src_and_type(
-            const void *src, const std::type_info &cast_type, const std::type_info *rtti_type = nullptr) {
-        if (auto *tpi = get_type_info(cast_type))
-            return {src, const_cast<const type_info *>(tpi)};
-
-        // Not found, set error:
-        std::string tname = rtti_type ? rtti_type->name() : cast_type.name();
-        detail::clean_type_id(tname);
-        std::string msg = "Unregistered type : " + tname;
-        PyErr_SetString(PyExc_TypeError, msg.c_str());
-        return {nullptr, nullptr};
-    }
-
-    const type_info *typeinfo = nullptr;
-    void *value = nullptr;
-};
-
-/**
- * Determine suitable casting operator for pointer-or-lvalue-casting type casters.  The type caster
- * needs to provide `operator T*()` and `operator T&()` operators.
- *
- * If the type supports moving the value away via an `operator T&&() &&` method, it should use
- * `movable_cast_op_type` instead.
- */
-template <typename T>
-using cast_op_type =
-    conditional_t<std::is_pointer<remove_reference_t<T>>::value,
-        typename std::add_pointer<intrinsic_t<T>>::type,
-        typename std::add_lvalue_reference<intrinsic_t<T>>::type>;
-
-/**
- * Determine suitable casting operator for a type caster with a movable value.  Such a type caster
- * needs to provide `operator T*()`, `operator T&()`, and `operator T&&() &&`.  The latter will be
- * called in appropriate contexts where the value can be moved rather than copied.
- *
- * These operator are automatically provided when using the PYBIND11_TYPE_CASTER macro.
- */
-template <typename T>
-using movable_cast_op_type =
-    conditional_t<std::is_pointer<typename std::remove_reference<T>::type>::value,
-        typename std::add_pointer<intrinsic_t<T>>::type,
-    conditional_t<std::is_rvalue_reference<T>::value,
-        typename std::add_rvalue_reference<intrinsic_t<T>>::type,
-        typename std::add_lvalue_reference<intrinsic_t<T>>::type>>;
-
-// std::is_copy_constructible isn't quite enough: it lets std::vector<T> (and similar) through when
-// T is non-copyable, but code containing such a copy constructor fails to actually compile.
-template <typename T, typename SFINAE = void> struct is_copy_constructible : std::is_copy_constructible<T> {};
-
-// Specialization for types that appear to be copy constructible but also look like stl containers
-// (we specifically check for: has `value_type` and `reference` with `reference = value_type&`): if
-// so, copy constructability depends on whether the value_type is copy constructible.
-template <typename Container> struct is_copy_constructible<Container, enable_if_t<all_of<
-        std::is_copy_constructible<Container>,
-        std::is_same<typename Container::value_type &, typename Container::reference>
-    >::value>> : is_copy_constructible<typename Container::value_type> {};
-
-#if !defined(PYBIND11_CPP17)
-// Likewise for std::pair before C++17 (which mandates that the copy constructor not exist when the
-// two types aren't themselves copy constructible).
-template <typename T1, typename T2> struct is_copy_constructible<std::pair<T1, T2>>
-    : all_of<is_copy_constructible<T1>, is_copy_constructible<T2>> {};
-#endif
-
-/// Generic type caster for objects stored on the heap
-template <typename type> class type_caster_base : public type_caster_generic {
-    using itype = intrinsic_t<type>;
-public:
-    static PYBIND11_DESCR name() { return type_descr(_<type>()); }
-
-    type_caster_base() : type_caster_base(typeid(type)) { }
-    explicit type_caster_base(const std::type_info &info) : type_caster_generic(info) { }
-
-    static handle cast(const itype &src, return_value_policy policy, handle parent) {
-        if (policy == return_value_policy::automatic || policy == return_value_policy::automatic_reference)
-            policy = return_value_policy::copy;
-        return cast(&src, policy, parent);
-    }
-
-    static handle cast(itype &&src, return_value_policy, handle parent) {
-        return cast(&src, return_value_policy::move, parent);
-    }
-
-    // Returns a (pointer, type_info) pair taking care of necessary RTTI type lookup for a
-    // polymorphic type.  If the instance isn't derived, returns the non-RTTI base version.
-    template <typename T = itype, enable_if_t<std::is_polymorphic<T>::value, int> = 0>
-    static std::pair<const void *, const type_info *> src_and_type(const itype *src) {
-        const void *vsrc = src;
-        auto &cast_type = typeid(itype);
-        const std::type_info *instance_type = nullptr;
-        if (vsrc) {
-            instance_type = &typeid(*src);
-            if (!same_type(cast_type, *instance_type)) {
-                // This is a base pointer to a derived type; if it is a pybind11-registered type, we
-                // can get the correct derived pointer (which may be != base pointer) by a
-                // dynamic_cast to most derived type:
-                if (auto *tpi = get_type_info(*instance_type))
-                    return {dynamic_cast<const void *>(src), const_cast<const type_info *>(tpi)};
-            }
-        }
-        // Otherwise we have either a nullptr, an `itype` pointer, or an unknown derived pointer, so
-        // don't do a cast
-        return type_caster_generic::src_and_type(vsrc, cast_type, instance_type);
-    }
-
-    // Non-polymorphic type, so no dynamic casting; just call the generic version directly
-    template <typename T = itype, enable_if_t<!std::is_polymorphic<T>::value, int> = 0>
-    static std::pair<const void *, const type_info *> src_and_type(const itype *src) {
-        return type_caster_generic::src_and_type(src, typeid(itype));
-    }
-
-    static handle cast(const itype *src, return_value_policy policy, handle parent) {
-        auto st = src_and_type(src);
-        return type_caster_generic::cast(
-            st.first, policy, parent, st.second,
-            make_copy_constructor(src), make_move_constructor(src));
-    }
-
-    static handle cast_holder(const itype *src, const void *holder) {
-        auto st = src_and_type(src);
-        return type_caster_generic::cast(
-            st.first, return_value_policy::take_ownership, {}, st.second,
-            nullptr, nullptr, holder);
-    }
-
-    template <typename T> using cast_op_type = cast_op_type<T>;
-
-    operator itype*() { return (type *) value; }
-    operator itype&() { if (!value) throw reference_cast_error(); return *((itype *) value); }
-
-protected:
-    using Constructor = void *(*)(const void *);
-
-    /* Only enabled when the types are {copy,move}-constructible *and* when the type
-       does not have a private operator new implementation. */
-    template <typename T, typename = enable_if_t<is_copy_constructible<T>::value>>
-    static auto make_copy_constructor(const T *x) -> decltype(new T(*x), Constructor{}) {
-        return [](const void *arg) -> void * {
-            return new T(*reinterpret_cast<const T *>(arg));
-        };
-    }
-
-    template <typename T, typename = enable_if_t<std::is_move_constructible<T>::value>>
-    static auto make_move_constructor(const T *x) -> decltype(new T(std::move(*const_cast<T *>(x))), Constructor{}) {
-        return [](const void *arg) -> void * {
-            return new T(std::move(*const_cast<T *>(reinterpret_cast<const T *>(arg))));
-        };
-    }
-
-    static Constructor make_copy_constructor(...) { return nullptr; }
-    static Constructor make_move_constructor(...) { return nullptr; }
-};
-
-template <typename type, typename SFINAE = void> class type_caster : public type_caster_base<type> { };
-template <typename type> using make_caster = type_caster<intrinsic_t<type>>;
-
-// Shortcut for calling a caster's `cast_op_type` cast operator for casting a type_caster to a T
-template <typename T> typename make_caster<T>::template cast_op_type<T> cast_op(make_caster<T> &caster) {
-    return caster.operator typename make_caster<T>::template cast_op_type<T>();
-}
-template <typename T> typename make_caster<T>::template cast_op_type<typename std::add_rvalue_reference<T>::type>
-cast_op(make_caster<T> &&caster) {
-    return std::move(caster).operator
-        typename make_caster<T>::template cast_op_type<typename std::add_rvalue_reference<T>::type>();
-}
-
-template <typename type> class type_caster<std::reference_wrapper<type>> {
-private:
-    using caster_t = make_caster<type>;
-    caster_t subcaster;
-    using subcaster_cast_op_type = typename caster_t::template cast_op_type<type>;
-    static_assert(std::is_same<typename std::remove_const<type>::type &, subcaster_cast_op_type>::value,
-            "std::reference_wrapper<T> caster requires T to have a caster with an `T &` operator");
-public:
-    bool load(handle src, bool convert) { return subcaster.load(src, convert); }
-    static PYBIND11_DESCR name() { return caster_t::name(); }
-    static handle cast(const std::reference_wrapper<type> &src, return_value_policy policy, handle parent) {
-        // It is definitely wrong to take ownership of this pointer, so mask that rvp
-        if (policy == return_value_policy::take_ownership || policy == return_value_policy::automatic)
-            policy = return_value_policy::automatic_reference;
-        return caster_t::cast(&src.get(), policy, parent);
-    }
-    template <typename T> using cast_op_type = std::reference_wrapper<type>;
-    operator std::reference_wrapper<type>() { return subcaster.operator subcaster_cast_op_type&(); }
-};
-
-#define PYBIND11_TYPE_CASTER(type, py_name) \
-    protected: \
-        type value; \
-    public: \
-        static PYBIND11_DESCR name() { return type_descr(py_name); } \
-        template <typename T_, enable_if_t<std::is_same<type, remove_cv_t<T_>>::value, int> = 0> \
-        static handle cast(T_ *src, return_value_policy policy, handle parent) { \
-            if (!src) return none().release(); \
-            if (policy == return_value_policy::take_ownership) { \
-                auto h = cast(std::move(*src), policy, parent); delete src; return h; \
-            } else { \
-                return cast(*src, policy, parent); \
-            } \
-        } \
-        operator type*() { return &value; } \
-        operator type&() { return value; } \
-        operator type&&() && { return std::move(value); } \
-        template <typename T_> using cast_op_type = pybind11::detail::movable_cast_op_type<T_>
-
-
-template <typename CharT> using is_std_char_type = any_of<
-    std::is_same<CharT, char>, /* std::string */
-    std::is_same<CharT, char16_t>, /* std::u16string */
-    std::is_same<CharT, char32_t>, /* std::u32string */
-    std::is_same<CharT, wchar_t> /* std::wstring */
->;
-
-template <typename T>
-struct type_caster<T, enable_if_t<std::is_arithmetic<T>::value && !is_std_char_type<T>::value>> {
-    using _py_type_0 = conditional_t<sizeof(T) <= sizeof(long), long, long long>;
-    using _py_type_1 = conditional_t<std::is_signed<T>::value, _py_type_0, typename std::make_unsigned<_py_type_0>::type>;
-    using py_type = conditional_t<std::is_floating_point<T>::value, double, _py_type_1>;
-public:
-
-    bool load(handle src, bool convert) {
-        py_type py_value;
-
-        if (!src)
-            return false;
-
-        if (std::is_floating_point<T>::value) {
-            if (convert || PyFloat_Check(src.ptr()))
-                py_value = (py_type) PyFloat_AsDouble(src.ptr());
-            else
-                return false;
-        } else if (PyFloat_Check(src.ptr())) {
-            return false;
-        } else if (std::is_unsigned<py_type>::value) {
-            py_value = as_unsigned<py_type>(src.ptr());
-        } else { // signed integer:
-            py_value = sizeof(T) <= sizeof(long)
-                ? (py_type) PyLong_AsLong(src.ptr())
-                : (py_type) PYBIND11_LONG_AS_LONGLONG(src.ptr());
-        }
-
-        bool py_err = py_value == (py_type) -1 && PyErr_Occurred();
-        if (py_err || (std::is_integral<T>::value && sizeof(py_type) != sizeof(T) &&
-                       (py_value < (py_type) std::numeric_limits<T>::min() ||
-                        py_value > (py_type) std::numeric_limits<T>::max()))) {
-            bool type_error = py_err && PyErr_ExceptionMatches(
-#if PY_VERSION_HEX < 0x03000000 && !defined(PYPY_VERSION)
-                PyExc_SystemError
-#else
-                PyExc_TypeError
-#endif
-            );
-            PyErr_Clear();
-            if (type_error && convert && PyNumber_Check(src.ptr())) {
-                auto tmp = reinterpret_borrow<object>(std::is_floating_point<T>::value
-                                                      ? PyNumber_Float(src.ptr())
-                                                      : PyNumber_Long(src.ptr()));
-                PyErr_Clear();
-                return load(tmp, false);
-            }
-            return false;
-        }
-
-        value = (T) py_value;
-        return true;
-    }
-
-    static handle cast(T src, return_value_policy /* policy */, handle /* parent */) {
-        if (std::is_floating_point<T>::value) {
-            return PyFloat_FromDouble((double) src);
-        } else if (sizeof(T) <= sizeof(long)) {
-            if (std::is_signed<T>::value)
-                return PyLong_FromLong((long) src);
-            else
-                return PyLong_FromUnsignedLong((unsigned long) src);
-        } else {
-            if (std::is_signed<T>::value)
-                return PyLong_FromLongLong((long long) src);
-            else
-                return PyLong_FromUnsignedLongLong((unsigned long long) src);
-        }
-    }
-
-    PYBIND11_TYPE_CASTER(T, _<std::is_integral<T>::value>("int", "float"));
-};
-
-template<typename T> struct void_caster {
-public:
-    bool load(handle src, bool) {
-        if (src && src.is_none())
-            return true;
-        return false;
-    }
-    static handle cast(T, return_value_policy /* policy */, handle /* parent */) {
-        return none().inc_ref();
-    }
-    PYBIND11_TYPE_CASTER(T, _("None"));
-};
-
-template <> class type_caster<void_type> : public void_caster<void_type> {};
-
-template <> class type_caster<void> : public type_caster<void_type> {
-public:
-    using type_caster<void_type>::cast;
-
-    bool load(handle h, bool) {
-        if (!h) {
-            return false;
-        } else if (h.is_none()) {
-            value = nullptr;
-            return true;
-        }
-
-        /* Check if this is a capsule */
-        if (isinstance<capsule>(h)) {
-            value = reinterpret_borrow<capsule>(h);
-            return true;
-        }
-
-        /* Check if this is a C++ type */
-        auto &bases = all_type_info((PyTypeObject *) h.get_type().ptr());
-        if (bases.size() == 1) { // Only allowing loading from a single-value type
-            value = values_and_holders(reinterpret_cast<instance *>(h.ptr())).begin()->value_ptr();
-            return true;
-        }
-
-        /* Fail */
-        return false;
-    }
-
-    static handle cast(const void *ptr, return_value_policy /* policy */, handle /* parent */) {
-        if (ptr)
-            return capsule(ptr).release();
-        else
-            return none().inc_ref();
-    }
-
-    template <typename T> using cast_op_type = void*&;
-    operator void *&() { return value; }
-    static PYBIND11_DESCR name() { return type_descr(_("capsule")); }
-private:
-    void *value = nullptr;
-};
-
-template <> class type_caster<std::nullptr_t> : public void_caster<std::nullptr_t> { };
-
-template <> class type_caster<bool> {
-public:
-    bool load(handle src, bool convert) {
-        if (!src) return false;
-        else if (src.ptr() == Py_True) { value = true; return true; }
-        else if (src.ptr() == Py_False) { value = false; return true; }
-        else if (convert || !strcmp("numpy.bool_", Py_TYPE(src.ptr())->tp_name)) {
-            // (allow non-implicit conversion for numpy booleans)
-
-            Py_ssize_t res = -1;
-            if (src.is_none()) {
-                res = 0;  // None is implicitly converted to False
-            }
-            #if defined(PYPY_VERSION)
-            // On PyPy, check that "__bool__" (or "__nonzero__" on Python 2.7) attr exists
-            else if (hasattr(src, PYBIND11_BOOL_ATTR)) {
-                res = PyObject_IsTrue(src.ptr());
-            }
-            #else
-            // Alternate approach for CPython: this does the same as the above, but optimized
-            // using the CPython API so as to avoid an unneeded attribute lookup.
-            else if (auto tp_as_number = src.ptr()->ob_type->tp_as_number) {
-                if (PYBIND11_NB_BOOL(tp_as_number)) {
-                    res = (*PYBIND11_NB_BOOL(tp_as_number))(src.ptr());
-                }
-            }
-            #endif
-            if (res == 0 || res == 1) {
-                value = (bool) res;
-                return true;
-            }
-        }
-        return false;
-    }
-    static handle cast(bool src, return_value_policy /* policy */, handle /* parent */) {
-        return handle(src ? Py_True : Py_False).inc_ref();
-    }
-    PYBIND11_TYPE_CASTER(bool, _("bool"));
-};
-
-// Helper class for UTF-{8,16,32} C++ stl strings:
-template <typename StringType, bool IsView = false> struct string_caster {
-    using CharT = typename StringType::value_type;
-
-    // Simplify life by being able to assume standard char sizes (the standard only guarantees
-    // minimums, but Python requires exact sizes)
-    static_assert(!std::is_same<CharT, char>::value || sizeof(CharT) == 1, "Unsupported char size != 1");
-    static_assert(!std::is_same<CharT, char16_t>::value || sizeof(CharT) == 2, "Unsupported char16_t size != 2");
-    static_assert(!std::is_same<CharT, char32_t>::value || sizeof(CharT) == 4, "Unsupported char32_t size != 4");
-    // wchar_t can be either 16 bits (Windows) or 32 (everywhere else)
-    static_assert(!std::is_same<CharT, wchar_t>::value || sizeof(CharT) == 2 || sizeof(CharT) == 4,
-            "Unsupported wchar_t size != 2/4");
-    static constexpr size_t UTF_N = 8 * sizeof(CharT);
-
-    bool load(handle src, bool) {
-#if PY_MAJOR_VERSION < 3
-        object temp;
-#endif
-        handle load_src = src;
-        if (!src) {
-            return false;
-        } else if (!PyUnicode_Check(load_src.ptr())) {
-#if PY_MAJOR_VERSION >= 3
-            return load_bytes(load_src);
-#else
-            if (sizeof(CharT) == 1) {
-                return load_bytes(load_src);
-            }
-
-            // The below is a guaranteed failure in Python 3 when PyUnicode_Check returns false
-            if (!PYBIND11_BYTES_CHECK(load_src.ptr()))
-                return false;
-
-            temp = reinterpret_steal<object>(PyUnicode_FromObject(load_src.ptr()));
-            if (!temp) { PyErr_Clear(); return false; }
-            load_src = temp;
-#endif
-        }
-
-        object utfNbytes = reinterpret_steal<object>(PyUnicode_AsEncodedString(
-            load_src.ptr(), UTF_N == 8 ? "utf-8" : UTF_N == 16 ? "utf-16" : "utf-32", nullptr));
-        if (!utfNbytes) { PyErr_Clear(); return false; }
-
-        const CharT *buffer = reinterpret_cast<const CharT *>(PYBIND11_BYTES_AS_STRING(utfNbytes.ptr()));
-        size_t length = (size_t) PYBIND11_BYTES_SIZE(utfNbytes.ptr()) / sizeof(CharT);
-        if (UTF_N > 8) { buffer++; length--; } // Skip BOM for UTF-16/32
-        value = StringType(buffer, length);
-
-        // If we're loading a string_view we need to keep the encoded Python object alive:
-        if (IsView)
-            loader_life_support::add_patient(utfNbytes);
-
-        return true;
-    }
-
-    static handle cast(const StringType &src, return_value_policy /* policy */, handle /* parent */) {
-        const char *buffer = reinterpret_cast<const char *>(src.data());
-        ssize_t nbytes = ssize_t(src.size() * sizeof(CharT));
-        handle s = decode_utfN(buffer, nbytes);
-        if (!s) throw error_already_set();
-        return s;
-    }
-
-    PYBIND11_TYPE_CASTER(StringType, _(PYBIND11_STRING_NAME));
-
-private:
-    static handle decode_utfN(const char *buffer, ssize_t nbytes) {
-#if !defined(PYPY_VERSION)
-        return
-            UTF_N == 8  ? PyUnicode_DecodeUTF8(buffer, nbytes, nullptr) :
-            UTF_N == 16 ? PyUnicode_DecodeUTF16(buffer, nbytes, nullptr, nullptr) :
-                          PyUnicode_DecodeUTF32(buffer, nbytes, nullptr, nullptr);
-#else
-        // PyPy seems to have multiple problems related to PyUnicode_UTF*: the UTF8 version
-        // sometimes segfaults for unknown reasons, while the UTF16 and 32 versions require a
-        // non-const char * arguments, which is also a nuissance, so bypass the whole thing by just
-        // passing the encoding as a string value, which works properly:
-        return PyUnicode_Decode(buffer, nbytes, UTF_N == 8 ? "utf-8" : UTF_N == 16 ? "utf-16" : "utf-32", nullptr);
-#endif
-    }
-
-    // When loading into a std::string or char*, accept a bytes object as-is (i.e.
-    // without any encoding/decoding attempt).  For other C++ char sizes this is a no-op.
-    // which supports loading a unicode from a str, doesn't take this path.
-    template <typename C = CharT>
-    bool load_bytes(enable_if_t<sizeof(C) == 1, handle> src) {
-        if (PYBIND11_BYTES_CHECK(src.ptr())) {
-            // We were passed a Python 3 raw bytes; accept it into a std::string or char*
-            // without any encoding attempt.
-            const char *bytes = PYBIND11_BYTES_AS_STRING(src.ptr());
-            if (bytes) {
-                value = StringType(bytes, (size_t) PYBIND11_BYTES_SIZE(src.ptr()));
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    template <typename C = CharT>
-    bool load_bytes(enable_if_t<sizeof(C) != 1, handle>) { return false; }
-};
-
-template <typename CharT, class Traits, class Allocator>
-struct type_caster<std::basic_string<CharT, Traits, Allocator>, enable_if_t<is_std_char_type<CharT>::value>>
-    : string_caster<std::basic_string<CharT, Traits, Allocator>> {};
-
-#ifdef PYBIND11_HAS_STRING_VIEW
-template <typename CharT, class Traits>
-struct type_caster<std::basic_string_view<CharT, Traits>, enable_if_t<is_std_char_type<CharT>::value>>
-    : string_caster<std::basic_string_view<CharT, Traits>, true> {};
-#endif
-
-// Type caster for C-style strings.  We basically use a std::string type caster, but also add the
-// ability to use None as a nullptr char* (which the string caster doesn't allow).
-template <typename CharT> struct type_caster<CharT, enable_if_t<is_std_char_type<CharT>::value>> {
-    using StringType = std::basic_string<CharT>;
-    using StringCaster = type_caster<StringType>;
-    StringCaster str_caster;
-    bool none = false;
-public:
-    bool load(handle src, bool convert) {
-        if (!src) return false;
-        if (src.is_none()) {
-            // Defer accepting None to other overloads (if we aren't in convert mode):
-            if (!convert) return false;
-            none = true;
-            return true;
-        }
-        return str_caster.load(src, convert);
-    }
-
-    static handle cast(const CharT *src, return_value_policy policy, handle parent) {
-        if (src == nullptr) return pybind11::none().inc_ref();
-        return StringCaster::cast(StringType(src), policy, parent);
-    }
-
-    static handle cast(CharT src, return_value_policy policy, handle parent) {
-        if (std::is_same<char, CharT>::value) {
-            handle s = PyUnicode_DecodeLatin1((const char *) &src, 1, nullptr);
-            if (!s) throw error_already_set();
-            return s;
-        }
-        return StringCaster::cast(StringType(1, src), policy, parent);
-    }
-
-    operator CharT*() { return none ? nullptr : const_cast<CharT *>(static_cast<StringType &>(str_caster).c_str()); }
-    operator CharT() {
-        if (none)
-            throw value_error("Cannot convert None to a character");
-
-        auto &value = static_cast<StringType &>(str_caster);
-        size_t str_len = value.size();
-        if (str_len == 0)
-            throw value_error("Cannot convert empty string to a character");
-
-        // If we're in UTF-8 mode, we have two possible failures: one for a unicode character that
-        // is too high, and one for multiple unicode characters (caught later), so we need to figure
-        // out how long the first encoded character is in bytes to distinguish between these two
-        // errors.  We also allow want to allow unicode characters U+0080 through U+00FF, as those
-        // can fit into a single char value.
-        if (StringCaster::UTF_N == 8 && str_len > 1 && str_len <= 4) {
-            unsigned char v0 = static_cast<unsigned char>(value[0]);
-            size_t char0_bytes = !(v0 & 0x80) ? 1 : // low bits only: 0-127
-                (v0 & 0xE0) == 0xC0 ? 2 : // 0b110xxxxx - start of 2-byte sequence
-                (v0 & 0xF0) == 0xE0 ? 3 : // 0b1110xxxx - start of 3-byte sequence
-                4; // 0b11110xxx - start of 4-byte sequence
-
-            if (char0_bytes == str_len) {
-                // If we have a 128-255 value, we can decode it into a single char:
-                if (char0_bytes == 2 && (v0 & 0xFC) == 0xC0) { // 0x110000xx 0x10xxxxxx
-                    return static_cast<CharT>(((v0 & 3) << 6) + (static_cast<unsigned char>(value[1]) & 0x3F));
-                }
-                // Otherwise we have a single character, but it's > U+00FF
-                throw value_error("Character code point not in range(0x100)");
-            }
-        }
-
-        // UTF-16 is much easier: we can only have a surrogate pair for values above U+FFFF, thus a
-        // surrogate pair with total length 2 instantly indicates a range error (but not a "your
-        // string was too long" error).
-        else if (StringCaster::UTF_N == 16 && str_len == 2) {
-            char16_t v0 = static_cast<char16_t>(value[0]);
-            if (v0 >= 0xD800 && v0 < 0xE000)
-                throw value_error("Character code point not in range(0x10000)");
-        }
-
-        if (str_len != 1)
-            throw value_error("Expected a character, but multi-character string found");
-
-        return value[0];
-    }
-
-    static PYBIND11_DESCR name() { return type_descr(_(PYBIND11_STRING_NAME)); }
-    template <typename _T> using cast_op_type = remove_reference_t<pybind11::detail::cast_op_type<_T>>;
-};
-
-// Base implementation for std::tuple and std::pair
-template <template<typename...> class Tuple, typename... Ts> class tuple_caster {
-    using type = Tuple<Ts...>;
-    static constexpr auto size = sizeof...(Ts);
-    using indices = make_index_sequence<size>;
-public:
-
-    bool load(handle src, bool convert) {
-        if (!isinstance<sequence>(src))
-            return false;
-        const auto seq = reinterpret_borrow<sequence>(src);
-        if (seq.size() != size)
-            return false;
-        return load_impl(seq, convert, indices{});
-    }
-
-    template <typename T>
-    static handle cast(T &&src, return_value_policy policy, handle parent) {
-        return cast_impl(std::forward<T>(src), policy, parent, indices{});
-    }
-
-    static PYBIND11_DESCR name() {
-        return type_descr(_("Tuple[") + detail::concat(make_caster<Ts>::name()...) + _("]"));
-    }
-
-    template <typename T> using cast_op_type = type;
-
-    operator type() & { return implicit_cast(indices{}); }
-    operator type() && { return std::move(*this).implicit_cast(indices{}); }
-
-protected:
-    template <size_t... Is>
-    type implicit_cast(index_sequence<Is...>) & { return type(cast_op<Ts>(std::get<Is>(subcasters))...); }
-    template <size_t... Is>
-    type implicit_cast(index_sequence<Is...>) && { return type(cast_op<Ts>(std::move(std::get<Is>(subcasters)))...); }
-
-    static constexpr bool load_impl(const sequence &, bool, index_sequence<>) { return true; }
-
-    template <size_t... Is>
-    bool load_impl(const sequence &seq, bool convert, index_sequence<Is...>) {
-        for (bool r : {std::get<Is>(subcasters).load(seq[Is], convert)...})
-            if (!r)
-                return false;
-        return true;
-    }
-
-    /* Implementation: Convert a C++ tuple into a Python tuple */
-    template <typename T, size_t... Is>
-    static handle cast_impl(T &&src, return_value_policy policy, handle parent, index_sequence<Is...>) {
-        std::array<object, size> entries{{
-            reinterpret_steal<object>(make_caster<Ts>::cast(std::get<Is>(std::forward<T>(src)), policy, parent))...
-        }};
-        for (const auto &entry: entries)
-            if (!entry)
-                return handle();
-        tuple result(size);
-        int counter = 0;
-        for (auto & entry: entries)
-            PyTuple_SET_ITEM(result.ptr(), counter++, entry.release().ptr());
-        return result.release();
-    }
-
-    Tuple<make_caster<Ts>...> subcasters;
-};
-
-template <typename T1, typename T2> class type_caster<std::pair<T1, T2>>
-    : public tuple_caster<std::pair, T1, T2> {};
-
-template <typename... Ts> class type_caster<std::tuple<Ts...>>
-    : public tuple_caster<std::tuple, Ts...> {};
-
-/// Helper class which abstracts away certain actions. Users can provide specializations for
-/// custom holders, but it's only necessary if the type has a non-standard interface.
-template <typename T>
-struct holder_helper {
-    static auto get(const T &p) -> decltype(p.get()) { return p.get(); }
-};
-
-/// Type caster for holder types like std::shared_ptr, etc.
-template <typename type, typename holder_type>
-struct copyable_holder_caster : public type_caster_base<type> {
-public:
-    using base = type_caster_base<type>;
-    static_assert(std::is_base_of<base, type_caster<type>>::value,
-            "Holder classes are only supported for custom types");
-    using base::base;
-    using base::cast;
-    using base::typeinfo;
-    using base::value;
-
-    bool load(handle src, bool convert) {
-        return base::template load_impl<copyable_holder_caster<type, holder_type>>(src, convert);
-    }
-
-    explicit operator type*() { return this->value; }
-    explicit operator type&() { return *(this->value); }
-    explicit operator holder_type*() { return &holder; }
-
-    // Workaround for Intel compiler bug
-    // see pybind11 issue 94
-    #if defined(__ICC) || defined(__INTEL_COMPILER)
-    operator holder_type&() { return holder; }
-    #else
-    explicit operator holder_type&() { return holder; }
-    #endif
-
-    static handle cast(const holder_type &src, return_value_policy, handle) {
-        const auto *ptr = holder_helper<holder_type>::get(src);
-        return type_caster_base<type>::cast_holder(ptr, &src);
-    }
-
-protected:
-    friend class type_caster_generic;
-    void check_holder_compat() {
-        if (typeinfo->default_holder)
-            throw cast_error("Unable to load a custom holder type from a default-holder instance");
-    }
-
-    bool load_value(value_and_holder &&v_h) {
-        if (v_h.holder_constructed()) {
-            value = v_h.value_ptr();
-            holder = v_h.holder<holder_type>();
-            return true;
-        } else {
-            throw cast_error("Unable to cast from non-held to held instance (T& to Holder<T>) "
-#if defined(NDEBUG)
-                             "(compile in debug mode for type information)");
-#else
-                             "of type '" + type_id<holder_type>() + "''");
-#endif
-        }
-    }
-
-    template <typename T = holder_type, detail::enable_if_t<!std::is_constructible<T, const T &, type*>::value, int> = 0>
-    bool try_implicit_casts(handle, bool) { return false; }
-
-    template <typename T = holder_type, detail::enable_if_t<std::is_constructible<T, const T &, type*>::value, int> = 0>
-    bool try_implicit_casts(handle src, bool convert) {
-        for (auto &cast : typeinfo->implicit_casts) {
-            copyable_holder_caster sub_caster(*cast.first);
-            if (sub_caster.load(src, convert)) {
-                value = cast.second(sub_caster.value);
-                holder = holder_type(sub_caster.holder, (type *) value);
-                return true;
-            }
-        }
-        return false;
-    }
-
-    static bool try_direct_conversions(handle) { return false; }
-
-
-    holder_type holder;
-};
-
-/// Specialize for the common std::shared_ptr, so users don't need to
-template <typename T>
-class type_caster<std::shared_ptr<T>> : public copyable_holder_caster<T, std::shared_ptr<T>> { };
-
-template <typename type, typename holder_type>
-struct move_only_holder_caster {
-    static_assert(std::is_base_of<type_caster_base<type>, type_caster<type>>::value,
-            "Holder classes are only supported for custom types");
-
-    static handle cast(holder_type &&src, return_value_policy, handle) {
-        auto *ptr = holder_helper<holder_type>::get(src);
-        return type_caster_base<type>::cast_holder(ptr, &src);
-    }
-    static PYBIND11_DESCR name() { return type_caster_base<type>::name(); }
-};
-
-template <typename type, typename deleter>
-class type_caster<std::unique_ptr<type, deleter>>
-    : public move_only_holder_caster<type, std::unique_ptr<type, deleter>> { };
-
-template <typename type, typename holder_type>
-using type_caster_holder = conditional_t<is_copy_constructible<holder_type>::value,
-                                         copyable_holder_caster<type, holder_type>,
-                                         move_only_holder_caster<type, holder_type>>;
-
-template <typename T, bool Value = false> struct always_construct_holder { static constexpr bool value = Value; };
-
-/// Create a specialization for custom holder types (silently ignores std::shared_ptr)
-#define PYBIND11_DECLARE_HOLDER_TYPE(type, holder_type, ...) \
-    namespace pybind11 { namespace detail { \
-    template <typename type> \
-    struct always_construct_holder<holder_type> : always_construct_holder<void, ##__VA_ARGS__>  { }; \
-    template <typename type> \
-    class type_caster<holder_type, enable_if_t<!is_shared_ptr<holder_type>::value>> \
-        : public type_caster_holder<type, holder_type> { }; \
-    }}
-
-// PYBIND11_DECLARE_HOLDER_TYPE holder types:
-template <typename base, typename holder> struct is_holder_type :
-    std::is_base_of<detail::type_caster_holder<base, holder>, detail::type_caster<holder>> {};
-// Specialization for always-supported unique_ptr holders:
-template <typename base, typename deleter> struct is_holder_type<base, std::unique_ptr<base, deleter>> :
-    std::true_type {};
-
-template <typename T> struct handle_type_name { static PYBIND11_DESCR name() { return _<T>(); } };
-template <> struct handle_type_name<bytes> { static PYBIND11_DESCR name() { return _(PYBIND11_BYTES_NAME); } };
-template <> struct handle_type_name<args> { static PYBIND11_DESCR name() { return _("*args"); } };
-template <> struct handle_type_name<kwargs> { static PYBIND11_DESCR name() { return _("**kwargs"); } };
-
-template <typename type>
-struct pyobject_caster {
-    template <typename T = type, enable_if_t<std::is_same<T, handle>::value, int> = 0>
-    bool load(handle src, bool /* convert */) { value = src; return static_cast<bool>(value); }
-
-    template <typename T = type, enable_if_t<std::is_base_of<object, T>::value, int> = 0>
-    bool load(handle src, bool /* convert */) {
-        if (!isinstance<type>(src))
-            return false;
-        value = reinterpret_borrow<type>(src);
-        return true;
-    }
-
-    static handle cast(const handle &src, return_value_policy /* policy */, handle /* parent */) {
-        return src.inc_ref();
-    }
-    PYBIND11_TYPE_CASTER(type, handle_type_name<type>::name());
-};
-
-template <typename T>
-class type_caster<T, enable_if_t<is_pyobject<T>::value>> : public pyobject_caster<T> { };
-
-// Our conditions for enabling moving are quite restrictive:
-// At compile time:
-// - T needs to be a non-const, non-pointer, non-reference type
-// - type_caster<T>::operator T&() must exist
-// - the type must be move constructible (obviously)
-// At run-time:
-// - if the type is non-copy-constructible, the object must be the sole owner of the type (i.e. it
-//   must have ref_count() == 1)h
-// If any of the above are not satisfied, we fall back to copying.
-template <typename T> using move_is_plain_type = satisfies_none_of<T,
-    std::is_void, std::is_pointer, std::is_reference, std::is_const
->;
-template <typename T, typename SFINAE = void> struct move_always : std::false_type {};
-template <typename T> struct move_always<T, enable_if_t<all_of<
-    move_is_plain_type<T>,
-    negation<is_copy_constructible<T>>,
-    std::is_move_constructible<T>,
-    std::is_same<decltype(std::declval<make_caster<T>>().operator T&()), T&>
->::value>> : std::true_type {};
-template <typename T, typename SFINAE = void> struct move_if_unreferenced : std::false_type {};
-template <typename T> struct move_if_unreferenced<T, enable_if_t<all_of<
-    move_is_plain_type<T>,
-    negation<move_always<T>>,
-    std::is_move_constructible<T>,
-    std::is_same<decltype(std::declval<make_caster<T>>().operator T&()), T&>
->::value>> : std::true_type {};
-template <typename T> using move_never = none_of<move_always<T>, move_if_unreferenced<T>>;
-
-// Detect whether returning a `type` from a cast on type's type_caster is going to result in a
-// reference or pointer to a local variable of the type_caster.  Basically, only
-// non-reference/pointer `type`s and reference/pointers from a type_caster_generic are safe;
-// everything else returns a reference/pointer to a local variable.
-template <typename type> using cast_is_temporary_value_reference = bool_constant<
-    (std::is_reference<type>::value || std::is_pointer<type>::value) &&
-    !std::is_base_of<type_caster_generic, make_caster<type>>::value
->;
-
-// When a value returned from a C++ function is being cast back to Python, we almost always want to
-// force `policy = move`, regardless of the return value policy the function/method was declared
-// with.  Some classes (most notably Eigen::Ref and related) need to avoid this, and so can do so by
-// specializing this struct.
-template <typename Return, typename SFINAE = void> struct return_value_policy_override {
-    static return_value_policy policy(return_value_policy p) {
-        return !std::is_lvalue_reference<Return>::value && !std::is_pointer<Return>::value
-            ? return_value_policy::move : p;
-    }
-};
-
-// Basic python -> C++ casting; throws if casting fails
-template <typename T, typename SFINAE> type_caster<T, SFINAE> &load_type(type_caster<T, SFINAE> &conv, const handle &handle) {
-    if (!conv.load(handle, true)) {
-#if defined(NDEBUG)
-        throw cast_error("Unable to cast Python instance to C++ type (compile in debug mode for details)");
-#else
-        throw cast_error("Unable to cast Python instance of type " +
-            (std::string) str(handle.get_type()) + " to C++ type '" + type_id<T>() + "''");
-#endif
-    }
-    return conv;
-}
-// Wrapper around the above that also constructs and returns a type_caster
-template <typename T> make_caster<T> load_type(const handle &handle) {
-    make_caster<T> conv;
-    load_type(conv, handle);
-    return conv;
-}
-
-NAMESPACE_END(detail)
-
-// pytype -> C++ type
-template <typename T, detail::enable_if_t<!detail::is_pyobject<T>::value, int> = 0>
-T cast(const handle &handle) {
-    using namespace detail;
-    static_assert(!cast_is_temporary_value_reference<T>::value,
-            "Unable to cast type to reference: value is local to type caster");
-    return cast_op<T>(load_type<T>(handle));
-}
-
-// pytype -> pytype (calls converting constructor)
-template <typename T, detail::enable_if_t<detail::is_pyobject<T>::value, int> = 0>
-T cast(const handle &handle) { return T(reinterpret_borrow<object>(handle)); }
-
-// C++ type -> py::object
-template <typename T, detail::enable_if_t<!detail::is_pyobject<T>::value, int> = 0>
-object cast(const T &value, return_value_policy policy = return_value_policy::automatic_reference,
-            handle parent = handle()) {
-    if (policy == return_value_policy::automatic)
-        policy = std::is_pointer<T>::value ? return_value_policy::take_ownership : return_value_policy::copy;
-    else if (policy == return_value_policy::automatic_reference)
-        policy = std::is_pointer<T>::value ? return_value_policy::reference : return_value_policy::copy;
-    return reinterpret_steal<object>(detail::make_caster<T>::cast(value, policy, parent));
-}
-
-template <typename T> T handle::cast() const { return pybind11::cast<T>(*this); }
-template <> inline void handle::cast() const { return; }
-
-template <typename T>
-detail::enable_if_t<!detail::move_never<T>::value, T> move(object &&obj) {
-    if (obj.ref_count() > 1)
-#if defined(NDEBUG)
-        throw cast_error("Unable to cast Python instance to C++ rvalue: instance has multiple references"
-            " (compile in debug mode for details)");
-#else
-        throw cast_error("Unable to move from Python " + (std::string) str(obj.get_type()) +
-                " instance to C++ " + type_id<T>() + " instance: instance has multiple references");
-#endif
-
-    // Move into a temporary and return that, because the reference may be a local value of `conv`
-    T ret = std::move(detail::load_type<T>(obj).operator T&());
-    return ret;
-}
-
-// Calling cast() on an rvalue calls pybind::cast with the object rvalue, which does:
-// - If we have to move (because T has no copy constructor), do it.  This will fail if the moved
-//   object has multiple references, but trying to copy will fail to compile.
-// - If both movable and copyable, check ref count: if 1, move; otherwise copy
-// - Otherwise (not movable), copy.
-template <typename T> detail::enable_if_t<detail::move_always<T>::value, T> cast(object &&object) {
-    return move<T>(std::move(object));
-}
-template <typename T> detail::enable_if_t<detail::move_if_unreferenced<T>::value, T> cast(object &&object) {
-    if (object.ref_count() > 1)
-        return cast<T>(object);
-    else
-        return move<T>(std::move(object));
-}
-template <typename T> detail::enable_if_t<detail::move_never<T>::value, T> cast(object &&object) {
-    return cast<T>(object);
-}
-
-template <typename T> T object::cast() const & { return pybind11::cast<T>(*this); }
-template <typename T> T object::cast() && { return pybind11::cast<T>(std::move(*this)); }
-template <> inline void object::cast() const & { return; }
-template <> inline void object::cast() && { return; }
-
-NAMESPACE_BEGIN(detail)
-
-// Declared in pytypes.h:
-template <typename T, enable_if_t<!is_pyobject<T>::value, int>>
-object object_or_cast(T &&o) { return pybind11::cast(std::forward<T>(o)); }
-
-struct overload_unused {}; // Placeholder type for the unneeded (and dead code) static variable in the OVERLOAD_INT macro
-template <typename ret_type> using overload_caster_t = conditional_t<
-    cast_is_temporary_value_reference<ret_type>::value, make_caster<ret_type>, overload_unused>;
-
-// Trampoline use: for reference/pointer types to value-converted values, we do a value cast, then
-// store the result in the given variable.  For other types, this is a no-op.
-template <typename T> enable_if_t<cast_is_temporary_value_reference<T>::value, T> cast_ref(object &&o, make_caster<T> &caster) {
-    return cast_op<T>(load_type(caster, o));
-}
-template <typename T> enable_if_t<!cast_is_temporary_value_reference<T>::value, T> cast_ref(object &&, overload_unused &) {
-    pybind11_fail("Internal error: cast_ref fallback invoked"); }
-
-// Trampoline use: Having a pybind11::cast with an invalid reference type is going to static_assert, even
-// though if it's in dead code, so we provide a "trampoline" to pybind11::cast that only does anything in
-// cases where pybind11::cast is valid.
-template <typename T> enable_if_t<!cast_is_temporary_value_reference<T>::value, T> cast_safe(object &&o) {
-    return pybind11::cast<T>(std::move(o)); }
-template <typename T> enable_if_t<cast_is_temporary_value_reference<T>::value, T> cast_safe(object &&) {
-    pybind11_fail("Internal error: cast_safe fallback invoked"); }
-template <> inline void cast_safe<void>(object &&) {}
-
-NAMESPACE_END(detail)
-
-template <return_value_policy policy = return_value_policy::automatic_reference,
-          typename... Args> tuple make_tuple(Args&&... args_) {
-    constexpr size_t size = sizeof...(Args);
-    std::array<object, size> args {
-        { reinterpret_steal<object>(detail::make_caster<Args>::cast(
-            std::forward<Args>(args_), policy, nullptr))... }
-    };
-    for (size_t i = 0; i < args.size(); i++) {
-        if (!args[i]) {
-#if defined(NDEBUG)
-            throw cast_error("make_tuple(): unable to convert arguments to Python object (compile in debug mode for details)");
-#else
-            std::array<std::string, size> argtypes { {type_id<Args>()...} };
-            throw cast_error("make_tuple(): unable to convert argument of type '" +
-                argtypes[i] + "' to Python object");
-#endif
-        }
-    }
-    tuple result(size);
-    int counter = 0;
-    for (auto &arg_value : args)
-        PyTuple_SET_ITEM(result.ptr(), counter++, arg_value.release().ptr());
-    return result;
-}
-
-/// \ingroup annotations
-/// Annotation for arguments
-struct arg {
-    /// Constructs an argument with the name of the argument; if null or omitted, this is a positional argument.
-    constexpr explicit arg(const char *name = nullptr) : name(name), flag_noconvert(false), flag_none(true) { }
-    /// Assign a value to this argument
-    template <typename T> arg_v operator=(T &&value) const;
-    /// Indicate that the type should not be converted in the type caster
-    arg &noconvert(bool flag = true) { flag_noconvert = flag; return *this; }
-    /// Indicates that the argument should/shouldn't allow None (e.g. for nullable pointer args)
-    arg &none(bool flag = true) { flag_none = flag; return *this; }
-
-    const char *name; ///< If non-null, this is a named kwargs argument
-    bool flag_noconvert : 1; ///< If set, do not allow conversion (requires a supporting type caster!)
-    bool flag_none : 1; ///< If set (the default), allow None to be passed to this argument
-};
-
-/// \ingroup annotations
-/// Annotation for arguments with values
-struct arg_v : arg {
-private:
-    template <typename T>
-    arg_v(arg &&base, T &&x, const char *descr = nullptr)
-        : arg(base),
-          value(reinterpret_steal<object>(
-              detail::make_caster<T>::cast(x, return_value_policy::automatic, {})
-          )),
-          descr(descr)
-#if !defined(NDEBUG)
-        , type(type_id<T>())
-#endif
-    { }
-
-public:
-    /// Direct construction with name, default, and description
-    template <typename T>
-    arg_v(const char *name, T &&x, const char *descr = nullptr)
-        : arg_v(arg(name), std::forward<T>(x), descr) { }
-
-    /// Called internally when invoking `py::arg("a") = value`
-    template <typename T>
-    arg_v(const arg &base, T &&x, const char *descr = nullptr)
-        : arg_v(arg(base), std::forward<T>(x), descr) { }
-
-    /// Same as `arg::noconvert()`, but returns *this as arg_v&, not arg&
-    arg_v &noconvert(bool flag = true) { arg::noconvert(flag); return *this; }
-
-    /// Same as `arg::nonone()`, but returns *this as arg_v&, not arg&
-    arg_v &none(bool flag = true) { arg::none(flag); return *this; }
-
-    /// The default value
-    object value;
-    /// The (optional) description of the default value
-    const char *descr;
-#if !defined(NDEBUG)
-    /// The C++ type name of the default value (only available when compiled in debug mode)
-    std::string type;
-#endif
-};
-
-template <typename T>
-arg_v arg::operator=(T &&value) const { return {std::move(*this), std::forward<T>(value)}; }
-
-/// Alias for backward compatibility -- to be removed in version 2.0
-template <typename /*unused*/> using arg_t = arg_v;
-
-inline namespace literals {
-/** \rst
-    String literal version of `arg`
- \endrst */
-constexpr arg operator"" _a(const char *name, size_t) { return arg(name); }
-}
-
-NAMESPACE_BEGIN(detail)
-
-// forward declaration (definition in attr.h)
-struct function_record;
-
-/// Internal data associated with a single function call
-struct function_call {
-    function_call(function_record &f, handle p); // Implementation in attr.h
-
-    /// The function data:
-    const function_record &func;
-
-    /// Arguments passed to the function:
-    std::vector<handle> args;
-
-    /// The `convert` value the arguments should be loaded with
-    std::vector<bool> args_convert;
-
-    /// The parent, if any
-    handle parent;
-};
-
-
-/// Helper class which loads arguments for C++ functions called from Python
-template <typename... Args>
-class argument_loader {
-    using indices = make_index_sequence<sizeof...(Args)>;
-
-    template <typename Arg> using argument_is_args   = std::is_same<intrinsic_t<Arg>, args>;
-    template <typename Arg> using argument_is_kwargs = std::is_same<intrinsic_t<Arg>, kwargs>;
-    // Get args/kwargs argument positions relative to the end of the argument list:
-    static constexpr auto args_pos = constexpr_first<argument_is_args, Args...>() - (int) sizeof...(Args),
-                        kwargs_pos = constexpr_first<argument_is_kwargs, Args...>() - (int) sizeof...(Args);
-
-    static constexpr bool args_kwargs_are_last = kwargs_pos >= - 1 && args_pos >= kwargs_pos - 1;
-
-    static_assert(args_kwargs_are_last, "py::args/py::kwargs are only permitted as the last argument(s) of a function");
-
-public:
-    static constexpr bool has_kwargs = kwargs_pos < 0;
-    static constexpr bool has_args = args_pos < 0;
-
-    static PYBIND11_DESCR arg_names() { return detail::concat(make_caster<Args>::name()...); }
-
-    bool load_args(function_call &call) {
-        return load_impl_sequence(call, indices{});
-    }
-
-    template <typename Return, typename Guard, typename Func>
-    enable_if_t<!std::is_void<Return>::value, Return> call(Func &&f) && {
-        return std::move(*this).template call_impl<Return>(std::forward<Func>(f), indices{}, Guard{});
-    }
-
-    template <typename Return, typename Guard, typename Func>
-    enable_if_t<std::is_void<Return>::value, void_type> call(Func &&f) && {
-        std::move(*this).template call_impl<Return>(std::forward<Func>(f), indices{}, Guard{});
-        return void_type();
-    }
-
-private:
-
-    static bool load_impl_sequence(function_call &, index_sequence<>) { return true; }
-
-    template <size_t... Is>
-    bool load_impl_sequence(function_call &call, index_sequence<Is...>) {
-        for (bool r : {std::get<Is>(argcasters).load(call.args[Is], call.args_convert[Is])...})
-            if (!r)
-                return false;
-        return true;
-    }
-
-    template <typename Return, typename Func, size_t... Is, typename Guard>
-    Return call_impl(Func &&f, index_sequence<Is...>, Guard &&) {
-        return std::forward<Func>(f)(cast_op<Args>(std::move(std::get<Is>(argcasters)))...);
-    }
-
-    std::tuple<make_caster<Args>...> argcasters;
-};
-
-/// Helper class which collects only positional arguments for a Python function call.
-/// A fancier version below can collect any argument, but this one is optimal for simple calls.
-template <return_value_policy policy>
-class simple_collector {
-public:
-    template <typename... Ts>
-    explicit simple_collector(Ts &&...values)
-        : m_args(pybind11::make_tuple<policy>(std::forward<Ts>(values)...)) { }
-
-    const tuple &args() const & { return m_args; }
-    dict kwargs() const { return {}; }
-
-    tuple args() && { return std::move(m_args); }
-
-    /// Call a Python function and pass the collected arguments
-    object call(PyObject *ptr) const {
-        PyObject *result = PyObject_CallObject(ptr, m_args.ptr());
-        if (!result)
-            throw error_already_set();
-        return reinterpret_steal<object>(result);
-    }
-
-private:
-    tuple m_args;
-};
-
-/// Helper class which collects positional, keyword, * and ** arguments for a Python function call
-template <return_value_policy policy>
-class unpacking_collector {
-public:
-    template <typename... Ts>
-    explicit unpacking_collector(Ts &&...values) {
-        // Tuples aren't (easily) resizable so a list is needed for collection,
-        // but the actual function call strictly requires a tuple.
-        auto args_list = list();
-        int _[] = { 0, (process(args_list, std::forward<Ts>(values)), 0)... };
-        ignore_unused(_);
-
-        m_args = std::move(args_list);
-    }
-
-    const tuple &args() const & { return m_args; }
-    const dict &kwargs() const & { return m_kwargs; }
-
-    tuple args() && { return std::move(m_args); }
-    dict kwargs() && { return std::move(m_kwargs); }
-
-    /// Call a Python function and pass the collected arguments
-    object call(PyObject *ptr) const {
-        PyObject *result = PyObject_Call(ptr, m_args.ptr(), m_kwargs.ptr());
-        if (!result)
-            throw error_already_set();
-        return reinterpret_steal<object>(result);
-    }
-
-private:
-    template <typename T>
-    void process(list &args_list, T &&x) {
-        auto o = reinterpret_steal<object>(detail::make_caster<T>::cast(std::forward<T>(x), policy, {}));
-        if (!o) {
-#if defined(NDEBUG)
-            argument_cast_error();
-#else
-            argument_cast_error(std::to_string(args_list.size()), type_id<T>());
-#endif
-        }
-        args_list.append(o);
-    }
-
-    void process(list &args_list, detail::args_proxy ap) {
-        for (const auto &a : ap)
-            args_list.append(a);
-    }
-
-    void process(list &/*args_list*/, arg_v a) {
-        if (!a.name)
-#if defined(NDEBUG)
-            nameless_argument_error();
-#else
-            nameless_argument_error(a.type);
-#endif
-
-        if (m_kwargs.contains(a.name)) {
-#if defined(NDEBUG)
-            multiple_values_error();
-#else
-            multiple_values_error(a.name);
-#endif
-        }
-        if (!a.value) {
-#if defined(NDEBUG)
-            argument_cast_error();
-#else
-            argument_cast_error(a.name, a.type);
-#endif
-        }
-        m_kwargs[a.name] = a.value;
-    }
-
-    void process(list &/*args_list*/, detail::kwargs_proxy kp) {
-        if (!kp)
-            return;
-        for (const auto &k : reinterpret_borrow<dict>(kp)) {
-            if (m_kwargs.contains(k.first)) {
-#if defined(NDEBUG)
-                multiple_values_error();
-#else
-                multiple_values_error(str(k.first));
-#endif
-            }
-            m_kwargs[k.first] = k.second;
-        }
-    }
-
-    [[noreturn]] static void nameless_argument_error() {
-        throw type_error("Got kwargs without a name; only named arguments "
-                         "may be passed via py::arg() to a python function call. "
-                         "(compile in debug mode for details)");
-    }
-    [[noreturn]] static void nameless_argument_error(std::string type) {
-        throw type_error("Got kwargs without a name of type '" + type + "'; only named "
-                         "arguments may be passed via py::arg() to a python function call. ");
-    }
-    [[noreturn]] static void multiple_values_error() {
-        throw type_error("Got multiple values for keyword argument "
-                         "(compile in debug mode for details)");
-    }
-
-    [[noreturn]] static void multiple_values_error(std::string name) {
-        throw type_error("Got multiple values for keyword argument '" + name + "'");
-    }
-
-    [[noreturn]] static void argument_cast_error() {
-        throw cast_error("Unable to convert call argument to Python object "
-                         "(compile in debug mode for details)");
-    }
-
-    [[noreturn]] static void argument_cast_error(std::string name, std::string type) {
-        throw cast_error("Unable to convert call argument '" + name
-                         + "' of type '" + type + "' to Python object");
-    }
-
-private:
-    tuple m_args;
-    dict m_kwargs;
-};
-
-/// Collect only positional arguments for a Python function call
-template <return_value_policy policy, typename... Args,
-          typename = enable_if_t<all_of<is_positional<Args>...>::value>>
-simple_collector<policy> collect_arguments(Args &&...args) {
-    return simple_collector<policy>(std::forward<Args>(args)...);
-}
-
-/// Collect all arguments, including keywords and unpacking (only instantiated when needed)
-template <return_value_policy policy, typename... Args,
-          typename = enable_if_t<!all_of<is_positional<Args>...>::value>>
-unpacking_collector<policy> collect_arguments(Args &&...args) {
-    // Following argument order rules for generalized unpacking according to PEP 448
-    static_assert(
-        constexpr_last<is_positional, Args...>() < constexpr_first<is_keyword_or_ds, Args...>()
-        && constexpr_last<is_s_unpacking, Args...>() < constexpr_first<is_ds_unpacking, Args...>(),
-        "Invalid function call: positional args must precede keywords and ** unpacking; "
-        "* unpacking must precede ** unpacking"
-    );
-    return unpacking_collector<policy>(std::forward<Args>(args)...);
-}
-
-template <typename Derived>
-template <return_value_policy policy, typename... Args>
-object object_api<Derived>::operator()(Args &&...args) const {
-    return detail::collect_arguments<policy>(std::forward<Args>(args)...).call(derived().ptr());
-}
-
-template <typename Derived>
-template <return_value_policy policy, typename... Args>
-object object_api<Derived>::call(Args &&...args) const {
-    return operator()<policy>(std::forward<Args>(args)...);
-}
-
-NAMESPACE_END(detail)
-
-#define PYBIND11_MAKE_OPAQUE(Type) \
-    namespace pybind11 { namespace detail { \
-        template<> class type_caster<Type> : public type_caster_base<Type> { }; \
-    }}
-
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/chrono.h b/tmap/lib/pybind11/include/pybind11/chrono.h
deleted file mode 100644
index 95ada76..0000000
--- a/tmap/lib/pybind11/include/pybind11/chrono.h
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
-    pybind11/chrono.h: Transparent conversion between std::chrono and python's datetime
-
-    Copyright (c) 2016 Trent Houliston <trent@houliston.me> and
-                       Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "pybind11.h"
-#include <cmath>
-#include <ctime>
-#include <chrono>
-#include <datetime.h>
-
-// Backport the PyDateTime_DELTA functions from Python3.3 if required
-#ifndef PyDateTime_DELTA_GET_DAYS
-#define PyDateTime_DELTA_GET_DAYS(o)         (((PyDateTime_Delta*)o)->days)
-#endif
-#ifndef PyDateTime_DELTA_GET_SECONDS
-#define PyDateTime_DELTA_GET_SECONDS(o)      (((PyDateTime_Delta*)o)->seconds)
-#endif
-#ifndef PyDateTime_DELTA_GET_MICROSECONDS
-#define PyDateTime_DELTA_GET_MICROSECONDS(o) (((PyDateTime_Delta*)o)->microseconds)
-#endif
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
-
-template <typename type> class duration_caster {
-public:
-    typedef typename type::rep rep;
-    typedef typename type::period period;
-
-    typedef std::chrono::duration<uint_fast32_t, std::ratio<86400>> days;
-
-    bool load(handle src, bool) {
-        using namespace std::chrono;
-
-        // Lazy initialise the PyDateTime import
-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }
-
-        if (!src) return false;
-        // If invoked with datetime.delta object
-        if (PyDelta_Check(src.ptr())) {
-            value = type(duration_cast<duration<rep, period>>(
-                  days(PyDateTime_DELTA_GET_DAYS(src.ptr()))
-                + seconds(PyDateTime_DELTA_GET_SECONDS(src.ptr()))
-                + microseconds(PyDateTime_DELTA_GET_MICROSECONDS(src.ptr()))));
-            return true;
-        }
-        // If invoked with a float we assume it is seconds and convert
-        else if (PyFloat_Check(src.ptr())) {
-            value = type(duration_cast<duration<rep, period>>(duration<double>(PyFloat_AsDouble(src.ptr()))));
-            return true;
-        }
-        else return false;
-    }
-
-    // If this is a duration just return it back
-    static const std::chrono::duration<rep, period>& get_duration(const std::chrono::duration<rep, period> &src) {
-        return src;
-    }
-
-    // If this is a time_point get the time_since_epoch
-    template <typename Clock> static std::chrono::duration<rep, period> get_duration(const std::chrono::time_point<Clock, std::chrono::duration<rep, period>> &src) {
-        return src.time_since_epoch();
-    }
-
-    static handle cast(const type &src, return_value_policy /* policy */, handle /* parent */) {
-        using namespace std::chrono;
-
-        // Use overloaded function to get our duration from our source
-        // Works out if it is a duration or time_point and get the duration
-        auto d = get_duration(src);
-
-        // Lazy initialise the PyDateTime import
-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }
-
-        // Declare these special duration types so the conversions happen with the correct primitive types (int)
-        using dd_t = duration<int, std::ratio<86400>>;
-        using ss_t = duration<int, std::ratio<1>>;
-        using us_t = duration<int, std::micro>;
-
-        auto dd = duration_cast<dd_t>(d);
-        auto subd = d - dd;
-        auto ss = duration_cast<ss_t>(subd);
-        auto us = duration_cast<us_t>(subd - ss);
-        return PyDelta_FromDSU(dd.count(), ss.count(), us.count());
-    }
-
-    PYBIND11_TYPE_CASTER(type, _("datetime.timedelta"));
-};
-
-// This is for casting times on the system clock into datetime.datetime instances
-template <typename Duration> class type_caster<std::chrono::time_point<std::chrono::system_clock, Duration>> {
-public:
-    typedef std::chrono::time_point<std::chrono::system_clock, Duration> type;
-    bool load(handle src, bool) {
-        using namespace std::chrono;
-
-        // Lazy initialise the PyDateTime import
-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }
-
-        if (!src) return false;
-        if (PyDateTime_Check(src.ptr())) {
-            std::tm cal;
-            cal.tm_sec   = PyDateTime_DATE_GET_SECOND(src.ptr());
-            cal.tm_min   = PyDateTime_DATE_GET_MINUTE(src.ptr());
-            cal.tm_hour  = PyDateTime_DATE_GET_HOUR(src.ptr());
-            cal.tm_mday  = PyDateTime_GET_DAY(src.ptr());
-            cal.tm_mon   = PyDateTime_GET_MONTH(src.ptr()) - 1;
-            cal.tm_year  = PyDateTime_GET_YEAR(src.ptr()) - 1900;
-            cal.tm_isdst = -1;
-
-            value = system_clock::from_time_t(std::mktime(&cal)) + microseconds(PyDateTime_DATE_GET_MICROSECOND(src.ptr()));
-            return true;
-        }
-        else return false;
-    }
-
-    static handle cast(const std::chrono::time_point<std::chrono::system_clock, Duration> &src, return_value_policy /* policy */, handle /* parent */) {
-        using namespace std::chrono;
-
-        // Lazy initialise the PyDateTime import
-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }
-
-        std::time_t tt = system_clock::to_time_t(src);
-        // this function uses static memory so it's best to copy it out asap just in case
-        // otherwise other code that is using localtime may break this (not just python code)
-        std::tm localtime = *std::localtime(&tt);
-
-        // Declare these special duration types so the conversions happen with the correct primitive types (int)
-        using us_t = duration<int, std::micro>;
-
-        return PyDateTime_FromDateAndTime(localtime.tm_year + 1900,
-                                          localtime.tm_mon + 1,
-                                          localtime.tm_mday,
-                                          localtime.tm_hour,
-                                          localtime.tm_min,
-                                          localtime.tm_sec,
-                                          (duration_cast<us_t>(src.time_since_epoch() % seconds(1))).count());
-    }
-    PYBIND11_TYPE_CASTER(type, _("datetime.datetime"));
-};
-
-// Other clocks that are not the system clock are not measured as datetime.datetime objects
-// since they are not measured on calendar time. So instead we just make them timedeltas
-// Or if they have passed us a time as a float we convert that
-template <typename Clock, typename Duration> class type_caster<std::chrono::time_point<Clock, Duration>>
-: public duration_caster<std::chrono::time_point<Clock, Duration>> {
-};
-
-template <typename Rep, typename Period> class type_caster<std::chrono::duration<Rep, Period>>
-: public duration_caster<std::chrono::duration<Rep, Period>> {
-};
-
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/complex.h b/tmap/lib/pybind11/include/pybind11/complex.h
deleted file mode 100644
index 5dac27c..0000000
--- a/tmap/lib/pybind11/include/pybind11/complex.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
-    pybind11/complex.h: Complex number support
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "pybind11.h"
-#include <complex>
-
-/// glibc defines I as a macro which breaks things, e.g., boost template names
-#ifdef I
-#  undef I
-#endif
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-
-template <typename T> struct format_descriptor<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {
-    static constexpr const char c = format_descriptor<T>::c;
-    static constexpr const char value[3] = { 'Z', c, '\0' };
-    static std::string format() { return std::string(value); }
-};
-
-template <typename T> constexpr const char format_descriptor<
-    std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>>::value[3];
-
-NAMESPACE_BEGIN(detail)
-
-template <typename T> struct is_fmt_numeric<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {
-    static constexpr bool value = true;
-    static constexpr int index = is_fmt_numeric<T>::index + 3;
-};
-
-template <typename T> class type_caster<std::complex<T>> {
-public:
-    bool load(handle src, bool convert) {
-        if (!src)
-            return false;
-        if (!convert && !PyComplex_Check(src.ptr()))
-            return false;
-        Py_complex result = PyComplex_AsCComplex(src.ptr());
-        if (result.real == -1.0 && PyErr_Occurred()) {
-            PyErr_Clear();
-            return false;
-        }
-        value = std::complex<T>((T) result.real, (T) result.imag);
-        return true;
-    }
-
-    static handle cast(const std::complex<T> &src, return_value_policy /* policy */, handle /* parent */) {
-        return PyComplex_FromDoubles((double) src.real(), (double) src.imag());
-    }
-
-    PYBIND11_TYPE_CASTER(std::complex<T>, _("complex"));
-};
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/detail/class.h b/tmap/lib/pybind11/include/pybind11/detail/class.h
deleted file mode 100644
index f745992..0000000
--- a/tmap/lib/pybind11/include/pybind11/detail/class.h
+++ /dev/null
@@ -1,606 +0,0 @@
-/*
-    pybind11/detail/class.h: Python C API implementation details for py::class_
-
-    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "../attr.h"
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
-
-inline PyTypeObject *type_incref(PyTypeObject *type) {
-    Py_INCREF(type);
-    return type;
-}
-
-#if !defined(PYPY_VERSION)
-
-/// `pybind11_static_property.__get__()`: Always pass the class instead of the instance.
-extern "C" inline PyObject *pybind11_static_get(PyObject *self, PyObject * /*ob*/, PyObject *cls) {
-    return PyProperty_Type.tp_descr_get(self, cls, cls);
-}
-
-/// `pybind11_static_property.__set__()`: Just like the above `__get__()`.
-extern "C" inline int pybind11_static_set(PyObject *self, PyObject *obj, PyObject *value) {
-    PyObject *cls = PyType_Check(obj) ? obj : (PyObject *) Py_TYPE(obj);
-    return PyProperty_Type.tp_descr_set(self, cls, value);
-}
-
-/** A `static_property` is the same as a `property` but the `__get__()` and `__set__()`
-    methods are modified to always use the object type instead of a concrete instance.
-    Return value: New reference. */
-inline PyTypeObject *make_static_property_type() {
-    constexpr auto *name = "pybind11_static_property";
-    auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));
-
-    /* Danger zone: from now (and until PyType_Ready), make sure to
-       issue no Python C API calls which could potentially invoke the
-       garbage collector (the GC will call type_traverse(), which will in
-       turn find the newly constructed type in an invalid state) */
-    auto heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
-    if (!heap_type)
-        pybind11_fail("make_static_property_type(): error allocating type!");
-
-    heap_type->ht_name = name_obj.inc_ref().ptr();
-#if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 3
-    heap_type->ht_qualname = name_obj.inc_ref().ptr();
-#endif
-
-    auto type = &heap_type->ht_type;
-    type->tp_name = name;
-    type->tp_base = type_incref(&PyProperty_Type);
-    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
-    type->tp_descr_get = pybind11_static_get;
-    type->tp_descr_set = pybind11_static_set;
-
-    if (PyType_Ready(type) < 0)
-        pybind11_fail("make_static_property_type(): failure in PyType_Ready()!");
-
-    setattr((PyObject *) type, "__module__", str("pybind11_builtins"));
-
-    return type;
-}
-
-#else // PYPY
-
-/** PyPy has some issues with the above C API, so we evaluate Python code instead.
-    This function will only be called once so performance isn't really a concern.
-    Return value: New reference. */
-inline PyTypeObject *make_static_property_type() {
-    auto d = dict();
-    PyObject *result = PyRun_String(R"(\
-        class pybind11_static_property(property):
-            def __get__(self, obj, cls):
-                return property.__get__(self, cls, cls)
-
-            def __set__(self, obj, value):
-                cls = obj if isinstance(obj, type) else type(obj)
-                property.__set__(self, cls, value)
-        )", Py_file_input, d.ptr(), d.ptr()
-    );
-    if (result == nullptr)
-        throw error_already_set();
-    Py_DECREF(result);
-    return (PyTypeObject *) d["pybind11_static_property"].cast<object>().release().ptr();
-}
-
-#endif // PYPY
-
-/** Types with static properties need to handle `Type.static_prop = x` in a specific way.
-    By default, Python replaces the `static_property` itself, but for wrapped C++ types
-    we need to call `static_property.__set__()` in order to propagate the new value to
-    the underlying C++ data structure. */
-extern "C" inline int pybind11_meta_setattro(PyObject* obj, PyObject* name, PyObject* value) {
-    // Use `_PyType_Lookup()` instead of `PyObject_GetAttr()` in order to get the raw
-    // descriptor (`property`) instead of calling `tp_descr_get` (`property.__get__()`).
-    PyObject *descr = _PyType_Lookup((PyTypeObject *) obj, name);
-
-    // The following assignment combinations are possible:
-    //   1. `Type.static_prop = value`             --> descr_set: `Type.static_prop.__set__(value)`
-    //   2. `Type.static_prop = other_static_prop` --> setattro:  replace existing `static_prop`
-    //   3. `Type.regular_attribute = value`       --> setattro:  regular attribute assignment
-    const auto static_prop = (PyObject *) get_internals().static_property_type;
-    const auto call_descr_set = descr && PyObject_IsInstance(descr, static_prop)
-                                && !PyObject_IsInstance(value, static_prop);
-    if (call_descr_set) {
-        // Call `static_property.__set__()` instead of replacing the `static_property`.
-#if !defined(PYPY_VERSION)
-        return Py_TYPE(descr)->tp_descr_set(descr, obj, value);
-#else
-        if (PyObject *result = PyObject_CallMethod(descr, "__set__", "OO", obj, value)) {
-            Py_DECREF(result);
-            return 0;
-        } else {
-            return -1;
-        }
-#endif
-    } else {
-        // Replace existing attribute.
-        return PyType_Type.tp_setattro(obj, name, value);
-    }
-}
-
-#if PY_MAJOR_VERSION >= 3
-/**
- * Python 3's PyInstanceMethod_Type hides itself via its tp_descr_get, which prevents aliasing
- * methods via cls.attr("m2") = cls.attr("m1"): instead the tp_descr_get returns a plain function,
- * when called on a class, or a PyMethod, when called on an instance.  Override that behaviour here
- * to do a special case bypass for PyInstanceMethod_Types.
- */
-extern "C" inline PyObject *pybind11_meta_getattro(PyObject *obj, PyObject *name) {
-    PyObject *descr = _PyType_Lookup((PyTypeObject *) obj, name);
-    if (descr && PyInstanceMethod_Check(descr)) {
-        Py_INCREF(descr);
-        return descr;
-    }
-    else {
-        return PyType_Type.tp_getattro(obj, name);
-    }
-}
-#endif
-
-/** This metaclass is assigned by default to all pybind11 types and is required in order
-    for static properties to function correctly. Users may override this using `py::metaclass`.
-    Return value: New reference. */
-inline PyTypeObject* make_default_metaclass() {
-    constexpr auto *name = "pybind11_type";
-    auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));
-
-    /* Danger zone: from now (and until PyType_Ready), make sure to
-       issue no Python C API calls which could potentially invoke the
-       garbage collector (the GC will call type_traverse(), which will in
-       turn find the newly constructed type in an invalid state) */
-    auto heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
-    if (!heap_type)
-        pybind11_fail("make_default_metaclass(): error allocating metaclass!");
-
-    heap_type->ht_name = name_obj.inc_ref().ptr();
-#if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 3
-    heap_type->ht_qualname = name_obj.inc_ref().ptr();
-#endif
-
-    auto type = &heap_type->ht_type;
-    type->tp_name = name;
-    type->tp_base = type_incref(&PyType_Type);
-    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
-
-    type->tp_setattro = pybind11_meta_setattro;
-#if PY_MAJOR_VERSION >= 3
-    type->tp_getattro = pybind11_meta_getattro;
-#endif
-
-    if (PyType_Ready(type) < 0)
-        pybind11_fail("make_default_metaclass(): failure in PyType_Ready()!");
-
-    setattr((PyObject *) type, "__module__", str("pybind11_builtins"));
-
-    return type;
-}
-
-/// For multiple inheritance types we need to recursively register/deregister base pointers for any
-/// base classes with pointers that are difference from the instance value pointer so that we can
-/// correctly recognize an offset base class pointer. This calls a function with any offset base ptrs.
-inline void traverse_offset_bases(void *valueptr, const detail::type_info *tinfo, instance *self,
-        bool (*f)(void * /*parentptr*/, instance * /*self*/)) {
-    for (handle h : reinterpret_borrow<tuple>(tinfo->type->tp_bases)) {
-        if (auto parent_tinfo = get_type_info((PyTypeObject *) h.ptr())) {
-            for (auto &c : parent_tinfo->implicit_casts) {
-                if (c.first == tinfo->cpptype) {
-                    auto *parentptr = c.second(valueptr);
-                    if (parentptr != valueptr)
-                        f(parentptr, self);
-                    traverse_offset_bases(parentptr, parent_tinfo, self, f);
-                    break;
-                }
-            }
-        }
-    }
-}
-
-inline bool register_instance_impl(void *ptr, instance *self) {
-    get_internals().registered_instances.emplace(ptr, self);
-    return true; // unused, but gives the same signature as the deregister func
-}
-inline bool deregister_instance_impl(void *ptr, instance *self) {
-    auto &registered_instances = get_internals().registered_instances;
-    auto range = registered_instances.equal_range(ptr);
-    for (auto it = range.first; it != range.second; ++it) {
-        if (Py_TYPE(self) == Py_TYPE(it->second)) {
-            registered_instances.erase(it);
-            return true;
-        }
-    }
-    return false;
-}
-
-inline void register_instance(instance *self, void *valptr, const type_info *tinfo) {
-    register_instance_impl(valptr, self);
-    if (!tinfo->simple_ancestors)
-        traverse_offset_bases(valptr, tinfo, self, register_instance_impl);
-}
-
-inline bool deregister_instance(instance *self, void *valptr, const type_info *tinfo) {
-    bool ret = deregister_instance_impl(valptr, self);
-    if (!tinfo->simple_ancestors)
-        traverse_offset_bases(valptr, tinfo, self, deregister_instance_impl);
-    return ret;
-}
-
-/// Instance creation function for all pybind11 types. It allocates the internal instance layout for
-/// holding C++ objects and holders.  Allocation is done lazily (the first time the instance is cast
-/// to a reference or pointer), and initialization is done by an `__init__` function.
-inline PyObject *make_new_instance(PyTypeObject *type) {
-#if defined(PYPY_VERSION)
-    // PyPy gets tp_basicsize wrong (issue 2482) under multiple inheritance when the first inherited
-    // object is a a plain Python type (i.e. not derived from an extension type).  Fix it.
-    ssize_t instance_size = static_cast<ssize_t>(sizeof(instance));
-    if (type->tp_basicsize < instance_size) {
-        type->tp_basicsize = instance_size;
-    }
-#endif
-    PyObject *self = type->tp_alloc(type, 0);
-    auto inst = reinterpret_cast<instance *>(self);
-    // Allocate the value/holder internals:
-    inst->allocate_layout();
-
-    inst->owned = true;
-
-    return self;
-}
-
-/// Instance creation function for all pybind11 types. It only allocates space for the
-/// C++ object, but doesn't call the constructor -- an `__init__` function must do that.
-extern "C" inline PyObject *pybind11_object_new(PyTypeObject *type, PyObject *, PyObject *) {
-    return make_new_instance(type);
-}
-
-/// An `__init__` function constructs the C++ object. Users should provide at least one
-/// of these using `py::init` or directly with `.def(__init__, ...)`. Otherwise, the
-/// following default function will be used which simply throws an exception.
-extern "C" inline int pybind11_object_init(PyObject *self, PyObject *, PyObject *) {
-    PyTypeObject *type = Py_TYPE(self);
-    std::string msg;
-#if defined(PYPY_VERSION)
-    msg += handle((PyObject *) type).attr("__module__").cast<std::string>() + ".";
-#endif
-    msg += type->tp_name;
-    msg += ": No constructor defined!";
-    PyErr_SetString(PyExc_TypeError, msg.c_str());
-    return -1;
-}
-
-inline void add_patient(PyObject *nurse, PyObject *patient) {
-    auto &internals = get_internals();
-    auto instance = reinterpret_cast<detail::instance *>(nurse);
-    instance->has_patients = true;
-    Py_INCREF(patient);
-    internals.patients[nurse].push_back(patient);
-}
-
-inline void clear_patients(PyObject *self) {
-    auto instance = reinterpret_cast<detail::instance *>(self);
-    auto &internals = get_internals();
-    auto pos = internals.patients.find(self);
-    assert(pos != internals.patients.end());
-    // Clearing the patients can cause more Python code to run, which
-    // can invalidate the iterator. Extract the vector of patients
-    // from the unordered_map first.
-    auto patients = std::move(pos->second);
-    internals.patients.erase(pos);
-    instance->has_patients = false;
-    for (PyObject *&patient : patients)
-        Py_CLEAR(patient);
-}
-
-/// Clears all internal data from the instance and removes it from registered instances in
-/// preparation for deallocation.
-inline void clear_instance(PyObject *self) {
-    auto instance = reinterpret_cast<detail::instance *>(self);
-
-    // Deallocate any values/holders, if present:
-    for (auto &v_h : values_and_holders(instance)) {
-        if (v_h) {
-
-            // We have to deregister before we call dealloc because, for virtual MI types, we still
-            // need to be able to get the parent pointers.
-            if (v_h.instance_registered() && !deregister_instance(instance, v_h.value_ptr(), v_h.type))
-                pybind11_fail("pybind11_object_dealloc(): Tried to deallocate unregistered instance!");
-
-            if (instance->owned || v_h.holder_constructed())
-                v_h.type->dealloc(v_h);
-        }
-    }
-    // Deallocate the value/holder layout internals:
-    instance->deallocate_layout();
-
-    if (instance->weakrefs)
-        PyObject_ClearWeakRefs(self);
-
-    PyObject **dict_ptr = _PyObject_GetDictPtr(self);
-    if (dict_ptr)
-        Py_CLEAR(*dict_ptr);
-
-    if (instance->has_patients)
-        clear_patients(self);
-}
-
-/// Instance destructor function for all pybind11 types. It calls `type_info.dealloc`
-/// to destroy the C++ object itself, while the rest is Python bookkeeping.
-extern "C" inline void pybind11_object_dealloc(PyObject *self) {
-    clear_instance(self);
-
-    auto type = Py_TYPE(self);
-    type->tp_free(self);
-
-    // `type->tp_dealloc != pybind11_object_dealloc` means that we're being called
-    // as part of a derived type's dealloc, in which case we're not allowed to decref
-    // the type here. For cross-module compatibility, we shouldn't compare directly
-    // with `pybind11_object_dealloc`, but with the common one stashed in internals.
-    auto pybind11_object_type = (PyTypeObject *) get_internals().instance_base;
-    if (type->tp_dealloc == pybind11_object_type->tp_dealloc)
-        Py_DECREF(type);
-}
-
-/** Create the type which can be used as a common base for all classes.  This is
-    needed in order to satisfy Python's requirements for multiple inheritance.
-    Return value: New reference. */
-inline PyObject *make_object_base_type(PyTypeObject *metaclass) {
-    constexpr auto *name = "pybind11_object";
-    auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));
-
-    /* Danger zone: from now (and until PyType_Ready), make sure to
-       issue no Python C API calls which could potentially invoke the
-       garbage collector (the GC will call type_traverse(), which will in
-       turn find the newly constructed type in an invalid state) */
-    auto heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);
-    if (!heap_type)
-        pybind11_fail("make_object_base_type(): error allocating type!");
-
-    heap_type->ht_name = name_obj.inc_ref().ptr();
-#if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 3
-    heap_type->ht_qualname = name_obj.inc_ref().ptr();
-#endif
-
-    auto type = &heap_type->ht_type;
-    type->tp_name = name;
-    type->tp_base = type_incref(&PyBaseObject_Type);
-    type->tp_basicsize = static_cast<ssize_t>(sizeof(instance));
-    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
-
-    type->tp_new = pybind11_object_new;
-    type->tp_init = pybind11_object_init;
-    type->tp_dealloc = pybind11_object_dealloc;
-
-    /* Support weak references (needed for the keep_alive feature) */
-    type->tp_weaklistoffset = offsetof(instance, weakrefs);
-
-    if (PyType_Ready(type) < 0)
-        pybind11_fail("PyType_Ready failed in make_object_base_type():" + error_string());
-
-    setattr((PyObject *) type, "__module__", str("pybind11_builtins"));
-
-    assert(!PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));
-    return (PyObject *) heap_type;
-}
-
-/// dynamic_attr: Support for `d = instance.__dict__`.
-extern "C" inline PyObject *pybind11_get_dict(PyObject *self, void *) {
-    PyObject *&dict = *_PyObject_GetDictPtr(self);
-    if (!dict)
-        dict = PyDict_New();
-    Py_XINCREF(dict);
-    return dict;
-}
-
-/// dynamic_attr: Support for `instance.__dict__ = dict()`.
-extern "C" inline int pybind11_set_dict(PyObject *self, PyObject *new_dict, void *) {
-    if (!PyDict_Check(new_dict)) {
-        PyErr_Format(PyExc_TypeError, "__dict__ must be set to a dictionary, not a '%.200s'",
-                     Py_TYPE(new_dict)->tp_name);
-        return -1;
-    }
-    PyObject *&dict = *_PyObject_GetDictPtr(self);
-    Py_INCREF(new_dict);
-    Py_CLEAR(dict);
-    dict = new_dict;
-    return 0;
-}
-
-/// dynamic_attr: Allow the garbage collector to traverse the internal instance `__dict__`.
-extern "C" inline int pybind11_traverse(PyObject *self, visitproc visit, void *arg) {
-    PyObject *&dict = *_PyObject_GetDictPtr(self);
-    Py_VISIT(dict);
-    return 0;
-}
-
-/// dynamic_attr: Allow the GC to clear the dictionary.
-extern "C" inline int pybind11_clear(PyObject *self) {
-    PyObject *&dict = *_PyObject_GetDictPtr(self);
-    Py_CLEAR(dict);
-    return 0;
-}
-
-/// Give instances of this type a `__dict__` and opt into garbage collection.
-inline void enable_dynamic_attributes(PyHeapTypeObject *heap_type) {
-    auto type = &heap_type->ht_type;
-#if defined(PYPY_VERSION)
-    pybind11_fail(std::string(type->tp_name) + ": dynamic attributes are "
-                                               "currently not supported in "
-                                               "conjunction with PyPy!");
-#endif
-    type->tp_flags |= Py_TPFLAGS_HAVE_GC;
-    type->tp_dictoffset = type->tp_basicsize; // place dict at the end
-    type->tp_basicsize += (ssize_t)sizeof(PyObject *); // and allocate enough space for it
-    type->tp_traverse = pybind11_traverse;
-    type->tp_clear = pybind11_clear;
-
-    static PyGetSetDef getset[] = {
-        {const_cast<char*>("__dict__"), pybind11_get_dict, pybind11_set_dict, nullptr, nullptr},
-        {nullptr, nullptr, nullptr, nullptr, nullptr}
-    };
-    type->tp_getset = getset;
-}
-
-/// buffer_protocol: Fill in the view as specified by flags.
-extern "C" inline int pybind11_getbuffer(PyObject *obj, Py_buffer *view, int flags) {
-    // Look for a `get_buffer` implementation in this type's info or any bases (following MRO).
-    type_info *tinfo = nullptr;
-    for (auto type : reinterpret_borrow<tuple>(Py_TYPE(obj)->tp_mro)) {
-        tinfo = get_type_info((PyTypeObject *) type.ptr());
-        if (tinfo && tinfo->get_buffer)
-            break;
-    }
-    if (view == nullptr || obj == nullptr || !tinfo || !tinfo->get_buffer) {
-        if (view)
-            view->obj = nullptr;
-        PyErr_SetString(PyExc_BufferError, "pybind11_getbuffer(): Internal error");
-        return -1;
-    }
-    std::memset(view, 0, sizeof(Py_buffer));
-    buffer_info *info = tinfo->get_buffer(obj, tinfo->get_buffer_data);
-    view->obj = obj;
-    view->ndim = 1;
-    view->internal = info;
-    view->buf = info->ptr;
-    view->itemsize = info->itemsize;
-    view->len = view->itemsize;
-    for (auto s : info->shape)
-        view->len *= s;
-    if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT)
-        view->format = const_cast<char *>(info->format.c_str());
-    if ((flags & PyBUF_STRIDES) == PyBUF_STRIDES) {
-        view->ndim = (int) info->ndim;
-        view->strides = &info->strides[0];
-        view->shape = &info->shape[0];
-    }
-    Py_INCREF(view->obj);
-    return 0;
-}
-
-/// buffer_protocol: Release the resources of the buffer.
-extern "C" inline void pybind11_releasebuffer(PyObject *, Py_buffer *view) {
-    delete (buffer_info *) view->internal;
-}
-
-/// Give this type a buffer interface.
-inline void enable_buffer_protocol(PyHeapTypeObject *heap_type) {
-    heap_type->ht_type.tp_as_buffer = &heap_type->as_buffer;
-#if PY_MAJOR_VERSION < 3
-    heap_type->ht_type.tp_flags |= Py_TPFLAGS_HAVE_NEWBUFFER;
-#endif
-
-    heap_type->as_buffer.bf_getbuffer = pybind11_getbuffer;
-    heap_type->as_buffer.bf_releasebuffer = pybind11_releasebuffer;
-}
-
-/** Create a brand new Python type according to the `type_record` specification.
-    Return value: New reference. */
-inline PyObject* make_new_python_type(const type_record &rec) {
-    auto name = reinterpret_steal<object>(PYBIND11_FROM_STRING(rec.name));
-
-#if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 3
-    auto ht_qualname = name;
-    if (rec.scope && hasattr(rec.scope, "__qualname__")) {
-        ht_qualname = reinterpret_steal<object>(
-            PyUnicode_FromFormat("%U.%U", rec.scope.attr("__qualname__").ptr(), name.ptr()));
-    }
-#endif
-
-    object module;
-    if (rec.scope) {
-        if (hasattr(rec.scope, "__module__"))
-            module = rec.scope.attr("__module__");
-        else if (hasattr(rec.scope, "__name__"))
-            module = rec.scope.attr("__name__");
-    }
-
-    auto full_name = c_str(
-#if !defined(PYPY_VERSION)
-        module ? str(module).cast<std::string>() + "." + rec.name :
-#endif
-        rec.name);
-
-    char *tp_doc = nullptr;
-    if (rec.doc && options::show_user_defined_docstrings()) {
-        /* Allocate memory for docstring (using PyObject_MALLOC, since
-           Python will free this later on) */
-        size_t size = strlen(rec.doc) + 1;
-        tp_doc = (char *) PyObject_MALLOC(size);
-        memcpy((void *) tp_doc, rec.doc, size);
-    }
-
-    auto &internals = get_internals();
-    auto bases = tuple(rec.bases);
-    auto base = (bases.size() == 0) ? internals.instance_base
-                                    : bases[0].ptr();
-
-    /* Danger zone: from now (and until PyType_Ready), make sure to
-       issue no Python C API calls which could potentially invoke the
-       garbage collector (the GC will call type_traverse(), which will in
-       turn find the newly constructed type in an invalid state) */
-    auto metaclass = rec.metaclass.ptr() ? (PyTypeObject *) rec.metaclass.ptr()
-                                         : internals.default_metaclass;
-
-    auto heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);
-    if (!heap_type)
-        pybind11_fail(std::string(rec.name) + ": Unable to create type object!");
-
-    heap_type->ht_name = name.release().ptr();
-#if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 3
-    heap_type->ht_qualname = ht_qualname.release().ptr();
-#endif
-
-    auto type = &heap_type->ht_type;
-    type->tp_name = full_name;
-    type->tp_doc = tp_doc;
-    type->tp_base = type_incref((PyTypeObject *)base);
-    type->tp_basicsize = static_cast<ssize_t>(sizeof(instance));
-    if (bases.size() > 0)
-        type->tp_bases = bases.release().ptr();
-
-    /* Don't inherit base __init__ */
-    type->tp_init = pybind11_object_init;
-
-    /* Supported protocols */
-    type->tp_as_number = &heap_type->as_number;
-    type->tp_as_sequence = &heap_type->as_sequence;
-    type->tp_as_mapping = &heap_type->as_mapping;
-
-    /* Flags */
-    type->tp_flags |= Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
-#if PY_MAJOR_VERSION < 3
-    type->tp_flags |= Py_TPFLAGS_CHECKTYPES;
-#endif
-
-    if (rec.dynamic_attr)
-        enable_dynamic_attributes(heap_type);
-
-    if (rec.buffer_protocol)
-        enable_buffer_protocol(heap_type);
-
-    if (PyType_Ready(type) < 0)
-        pybind11_fail(std::string(rec.name) + ": PyType_Ready failed (" + error_string() + ")!");
-
-    assert(rec.dynamic_attr ? PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC)
-                            : !PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));
-
-    /* Register type with the parent scope */
-    if (rec.scope)
-        setattr(rec.scope, rec.name, (PyObject *) type);
-    else
-        Py_INCREF(type); // Keep it alive forever (reference leak)
-
-    if (module) // Needed by pydoc
-        setattr((PyObject *) type, "__module__", module);
-
-    return (PyObject *) type;
-}
-
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/detail/common.h b/tmap/lib/pybind11/include/pybind11/detail/common.h
deleted file mode 100644
index b5ee173..0000000
--- a/tmap/lib/pybind11/include/pybind11/detail/common.h
+++ /dev/null
@@ -1,799 +0,0 @@
-/*
-    pybind11/detail/common.h -- Basic macros
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#if !defined(NAMESPACE_BEGIN)
-#  define NAMESPACE_BEGIN(name) namespace name {
-#endif
-#if !defined(NAMESPACE_END)
-#  define NAMESPACE_END(name) }
-#endif
-
-// Robust support for some features and loading modules compiled against different pybind versions
-// requires forcing hidden visibility on pybind code, so we enforce this by setting the attribute on
-// the main `pybind11` namespace.
-#if !defined(PYBIND11_NAMESPACE)
-#  ifdef __GNUG__
-#    define PYBIND11_NAMESPACE pybind11 __attribute__((visibility("hidden")))
-#  else
-#    define PYBIND11_NAMESPACE pybind11
-#  endif
-#endif
-
-#if !defined(_MSC_VER) && !defined(__INTEL_COMPILER)
-#  if __cplusplus >= 201402L
-#    define PYBIND11_CPP14
-#    if __cplusplus > 201402L /* Temporary: should be updated to >= the final C++17 value once known */
-#      define PYBIND11_CPP17
-#    endif
-#  endif
-#elif defined(_MSC_VER)
-// MSVC sets _MSVC_LANG rather than __cplusplus (supposedly until the standard is fully implemented)
-#  if _MSVC_LANG >= 201402L
-#    define PYBIND11_CPP14
-#    if _MSVC_LANG > 201402L && _MSC_VER >= 1910
-#      define PYBIND11_CPP17
-#    endif
-#  endif
-#endif
-
-// Compiler version assertions
-#if defined(__INTEL_COMPILER)
-#  if __INTEL_COMPILER < 1500
-#    error pybind11 requires Intel C++ compiler v15 or newer
-#  endif
-#elif defined(__clang__) && !defined(__apple_build_version__)
-#  if __clang_major__ < 3 || (__clang_major__ == 3 && __clang_minor__ < 3)
-#    error pybind11 requires clang 3.3 or newer
-#  endif
-#elif defined(__clang__)
-// Apple changes clang version macros to its Xcode version; the first Xcode release based on
-// (upstream) clang 3.3 was Xcode 5:
-#  if __clang_major__ < 5
-#    error pybind11 requires Xcode/clang 5.0 or newer
-#  endif
-#elif defined(__GNUG__)
-#  if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8)
-#    error pybind11 requires gcc 4.8 or newer
-#  endif
-#elif defined(_MSC_VER)
-// Pybind hits various compiler bugs in 2015u2 and earlier, and also makes use of some stl features
-// (e.g. std::negation) added in 2015u3:
-#  if _MSC_FULL_VER < 190024210
-#    error pybind11 requires MSVC 2015 update 3 or newer
-#  endif
-#endif
-
-#if !defined(PYBIND11_EXPORT)
-#  if defined(WIN32) || defined(_WIN32)
-#    define PYBIND11_EXPORT __declspec(dllexport)
-#  else
-#    define PYBIND11_EXPORT __attribute__ ((visibility("default")))
-#  endif
-#endif
-
-#if defined(_MSC_VER)
-#  define PYBIND11_NOINLINE __declspec(noinline)
-#else
-#  define PYBIND11_NOINLINE __attribute__ ((noinline))
-#endif
-
-#if defined(PYBIND11_CPP14)
-#  define PYBIND11_DEPRECATED(reason) [[deprecated(reason)]]
-#else
-#  define PYBIND11_DEPRECATED(reason) __attribute__((deprecated(reason)))
-#endif
-
-#define PYBIND11_VERSION_MAJOR 2
-#define PYBIND11_VERSION_MINOR 2
-#define PYBIND11_VERSION_PATCH 0
-
-/// Include Python header, disable linking to pythonX_d.lib on Windows in debug mode
-#if defined(_MSC_VER)
-#  if (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION < 4)
-#    define HAVE_ROUND 1
-#  endif
-#  pragma warning(push)
-#  pragma warning(disable: 4510 4610 4512 4005)
-#  if defined(_DEBUG)
-#    define PYBIND11_DEBUG_MARKER
-#    undef _DEBUG
-#  endif
-#endif
-
-#include <Python.h>
-#include <frameobject.h>
-#include <pythread.h>
-
-#if defined(_WIN32) && (defined(min) || defined(max))
-#  error Macro clash with min and max -- define NOMINMAX when compiling your program on Windows
-#endif
-
-#if defined(isalnum)
-#  undef isalnum
-#  undef isalpha
-#  undef islower
-#  undef isspace
-#  undef isupper
-#  undef tolower
-#  undef toupper
-#endif
-
-#if defined(_MSC_VER)
-#  if defined(PYBIND11_DEBUG_MARKER)
-#    define _DEBUG
-#    undef PYBIND11_DEBUG_MARKER
-#  endif
-#  pragma warning(pop)
-#endif
-
-#include <cstddef>
-#include <cstring>
-#include <forward_list>
-#include <vector>
-#include <string>
-#include <stdexcept>
-#include <unordered_set>
-#include <unordered_map>
-#include <memory>
-#include <typeindex>
-#include <type_traits>
-
-#if PY_MAJOR_VERSION >= 3 /// Compatibility macros for various Python versions
-#define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyInstanceMethod_New(ptr)
-#define PYBIND11_INSTANCE_METHOD_CHECK PyInstanceMethod_Check
-#define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyInstanceMethod_GET_FUNCTION
-#define PYBIND11_BYTES_CHECK PyBytes_Check
-#define PYBIND11_BYTES_FROM_STRING PyBytes_FromString
-#define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyBytes_FromStringAndSize
-#define PYBIND11_BYTES_AS_STRING_AND_SIZE PyBytes_AsStringAndSize
-#define PYBIND11_BYTES_AS_STRING PyBytes_AsString
-#define PYBIND11_BYTES_SIZE PyBytes_Size
-#define PYBIND11_LONG_CHECK(o) PyLong_Check(o)
-#define PYBIND11_LONG_AS_LONGLONG(o) PyLong_AsLongLong(o)
-#define PYBIND11_BYTES_NAME "bytes"
-#define PYBIND11_STRING_NAME "str"
-#define PYBIND11_SLICE_OBJECT PyObject
-#define PYBIND11_FROM_STRING PyUnicode_FromString
-#define PYBIND11_STR_TYPE ::pybind11::str
-#define PYBIND11_BOOL_ATTR "__bool__"
-#define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_bool)
-#define PYBIND11_PLUGIN_IMPL(name) \
-    extern "C" PYBIND11_EXPORT PyObject *PyInit_##name()
-
-#else
-#define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyMethod_New(ptr, nullptr, class_)
-#define PYBIND11_INSTANCE_METHOD_CHECK PyMethod_Check
-#define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyMethod_GET_FUNCTION
-#define PYBIND11_BYTES_CHECK PyString_Check
-#define PYBIND11_BYTES_FROM_STRING PyString_FromString
-#define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyString_FromStringAndSize
-#define PYBIND11_BYTES_AS_STRING_AND_SIZE PyString_AsStringAndSize
-#define PYBIND11_BYTES_AS_STRING PyString_AsString
-#define PYBIND11_BYTES_SIZE PyString_Size
-#define PYBIND11_LONG_CHECK(o) (PyInt_Check(o) || PyLong_Check(o))
-#define PYBIND11_LONG_AS_LONGLONG(o) (PyInt_Check(o) ? (long long) PyLong_AsLong(o) : PyLong_AsLongLong(o))
-#define PYBIND11_BYTES_NAME "str"
-#define PYBIND11_STRING_NAME "unicode"
-#define PYBIND11_SLICE_OBJECT PySliceObject
-#define PYBIND11_FROM_STRING PyString_FromString
-#define PYBIND11_STR_TYPE ::pybind11::bytes
-#define PYBIND11_BOOL_ATTR "__nonzero__"
-#define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_nonzero)
-#define PYBIND11_PLUGIN_IMPL(name) \
-    static PyObject *pybind11_init_wrapper();               \
-    extern "C" PYBIND11_EXPORT void init##name() {          \
-        (void)pybind11_init_wrapper();                      \
-    }                                                       \
-    PyObject *pybind11_init_wrapper()
-#endif
-
-#if PY_VERSION_HEX >= 0x03050000 && PY_VERSION_HEX < 0x03050200
-extern "C" {
-    struct _Py_atomic_address { void *value; };
-    PyAPI_DATA(_Py_atomic_address) _PyThreadState_Current;
-}
-#endif
-
-#define PYBIND11_TRY_NEXT_OVERLOAD ((PyObject *) 1) // special failure return code
-#define PYBIND11_STRINGIFY(x) #x
-#define PYBIND11_TOSTRING(x) PYBIND11_STRINGIFY(x)
-
-/** \rst
-    ***Deprecated in favor of PYBIND11_MODULE***
-
-    This macro creates the entry point that will be invoked when the Python interpreter
-    imports a plugin library. Please create a `module` in the function body and return
-    the pointer to its underlying Python object at the end.
-
-    .. code-block:: cpp
-
-        PYBIND11_PLUGIN(example) {
-            pybind11::module m("example", "pybind11 example plugin");
-            /// Set up bindings here
-            return m.ptr();
-        }
-\endrst */
-#define PYBIND11_PLUGIN(name)                                                  \
-    PYBIND11_DEPRECATED("PYBIND11_PLUGIN is deprecated, use PYBIND11_MODULE")  \
-    static PyObject *pybind11_init();                                          \
-    PYBIND11_PLUGIN_IMPL(name) {                                               \
-        int major, minor;                                                      \
-        if (sscanf(Py_GetVersion(), "%i.%i", &major, &minor) != 2) {           \
-            PyErr_SetString(PyExc_ImportError, "Can't parse Python version."); \
-            return nullptr;                                                    \
-        } else if (major != PY_MAJOR_VERSION || minor != PY_MINOR_VERSION) {   \
-            PyErr_Format(PyExc_ImportError,                                    \
-                         "Python version mismatch: module was compiled for "   \
-                         "version %i.%i, while the interpreter is running "    \
-                         "version %i.%i.", PY_MAJOR_VERSION, PY_MINOR_VERSION, \
-                         major, minor);                                        \
-            return nullptr;                                                    \
-        }                                                                      \
-        try {                                                                  \
-            return pybind11_init();                                            \
-        } catch (pybind11::error_already_set &e) {                             \
-            PyErr_SetString(PyExc_ImportError, e.what());                      \
-            return nullptr;                                                    \
-        } catch (const std::exception &e) {                                    \
-            PyErr_SetString(PyExc_ImportError, e.what());                      \
-            return nullptr;                                                    \
-        }                                                                      \
-    }                                                                          \
-    PyObject *pybind11_init()
-
-/** \rst
-    This macro creates the entry point that will be invoked when the Python interpreter
-    imports an extension module. The module name is given as the fist argument and it
-    should not be in quotes. The second macro argument defines a variable of type
-    `py::module` which can be used to initialize the module.
-
-    .. code-block:: cpp
-
-        PYBIND11_MODULE(example, m) {
-            m.doc() = "pybind11 example module";
-
-            // Add bindings here
-            m.def("foo", []() {
-                return "Hello, World!";
-            });
-        }
-\endrst */
-#define PYBIND11_MODULE(name, variable)                                        \
-    static void pybind11_init_##name(pybind11::module &);                      \
-    PYBIND11_PLUGIN_IMPL(name) {                                               \
-        int major, minor;                                                      \
-        if (sscanf(Py_GetVersion(), "%i.%i", &major, &minor) != 2) {           \
-            PyErr_SetString(PyExc_ImportError, "Can't parse Python version."); \
-            return nullptr;                                                    \
-        } else if (major != PY_MAJOR_VERSION || minor != PY_MINOR_VERSION) {   \
-            PyErr_Format(PyExc_ImportError,                                    \
-                         "Python version mismatch: module was compiled for "   \
-                         "version %i.%i, while the interpreter is running "    \
-                         "version %i.%i.", PY_MAJOR_VERSION, PY_MINOR_VERSION, \
-                         major, minor);                                        \
-            return nullptr;                                                    \
-        }                                                                      \
-        auto m = pybind11::module(#name);                                      \
-        try {                                                                  \
-            pybind11_init_##name(m);                                           \
-            return m.ptr();                                                    \
-        } catch (pybind11::error_already_set &e) {                             \
-            PyErr_SetString(PyExc_ImportError, e.what());                      \
-            return nullptr;                                                    \
-        } catch (const std::exception &e) {                                    \
-            PyErr_SetString(PyExc_ImportError, e.what());                      \
-            return nullptr;                                                    \
-        }                                                                      \
-    }                                                                          \
-    void pybind11_init_##name(pybind11::module &variable)
-
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-
-using ssize_t = Py_ssize_t;
-using size_t  = std::size_t;
-
-/// Approach used to cast a previously unknown C++ instance into a Python object
-enum class return_value_policy : uint8_t {
-    /** This is the default return value policy, which falls back to the policy
-        return_value_policy::take_ownership when the return value is a pointer.
-        Otherwise, it uses return_value::move or return_value::copy for rvalue
-        and lvalue references, respectively. See below for a description of what
-        all of these different policies do. */
-    automatic = 0,
-
-    /** As above, but use policy return_value_policy::reference when the return
-        value is a pointer. This is the default conversion policy for function
-        arguments when calling Python functions manually from C++ code (i.e. via
-        handle::operator()). You probably won't need to use this. */
-    automatic_reference,
-
-    /** Reference an existing object (i.e. do not create a new copy) and take
-        ownership. Python will call the destructor and delete operator when the
-        object’s reference count reaches zero. Undefined behavior ensues when
-        the C++ side does the same.. */
-    take_ownership,
-
-    /** Create a new copy of the returned object, which will be owned by
-        Python. This policy is comparably safe because the lifetimes of the two
-        instances are decoupled. */
-    copy,
-
-    /** Use std::move to move the return value contents into a new instance
-        that will be owned by Python. This policy is comparably safe because the
-        lifetimes of the two instances (move source and destination) are
-        decoupled. */
-    move,
-
-    /** Reference an existing object, but do not take ownership. The C++ side
-        is responsible for managing the object’s lifetime and deallocating it
-        when it is no longer used. Warning: undefined behavior will ensue when
-        the C++ side deletes an object that is still referenced and used by
-        Python. */
-    reference,
-
-    /** This policy only applies to methods and properties. It references the
-        object without taking ownership similar to the above
-        return_value_policy::reference policy. In contrast to that policy, the
-        function or property’s implicit this argument (called the parent) is
-        considered to be the the owner of the return value (the child).
-        pybind11 then couples the lifetime of the parent to the child via a
-        reference relationship that ensures that the parent cannot be garbage
-        collected while Python is still using the child. More advanced
-        variations of this scheme are also possible using combinations of
-        return_value_policy::reference and the keep_alive call policy */
-    reference_internal
-};
-
-NAMESPACE_BEGIN(detail)
-
-inline static constexpr int log2(size_t n, int k = 0) { return (n <= 1) ? k : log2(n >> 1, k + 1); }
-
-// Returns the size as a multiple of sizeof(void *), rounded up.
-inline static constexpr size_t size_in_ptrs(size_t s) { return 1 + ((s - 1) >> log2(sizeof(void *))); }
-
-/**
- * The space to allocate for simple layout instance holders (see below) in multiple of the size of
- * a pointer (e.g.  2 means 16 bytes on 64-bit architectures).  The default is the minimum required
- * to holder either a std::unique_ptr or std::shared_ptr (which is almost always
- * sizeof(std::shared_ptr<T>)).
- */
-constexpr size_t instance_simple_holder_in_ptrs() {
-    static_assert(sizeof(std::shared_ptr<int>) >= sizeof(std::unique_ptr<int>),
-            "pybind assumes std::shared_ptrs are at least as big as std::unique_ptrs");
-    return size_in_ptrs(sizeof(std::shared_ptr<int>));
-}
-
-// Forward declarations
-struct type_info;
-struct value_and_holder;
-
-/// The 'instance' type which needs to be standard layout (need to be able to use 'offsetof')
-struct instance {
-    PyObject_HEAD
-    /// Storage for pointers and holder; see simple_layout, below, for a description
-    union {
-        void *simple_value_holder[1 + instance_simple_holder_in_ptrs()];
-        struct {
-            void **values_and_holders;
-            uint8_t *status;
-        } nonsimple;
-    };
-    /// Weak references (needed for keep alive):
-    PyObject *weakrefs;
-    /// If true, the pointer is owned which means we're free to manage it with a holder.
-    bool owned : 1;
-    /**
-     * An instance has two possible value/holder layouts.
-     *
-     * Simple layout (when this flag is true), means the `simple_value_holder` is set with a pointer
-     * and the holder object governing that pointer, i.e. [val1*][holder].  This layout is applied
-     * whenever there is no python-side multiple inheritance of bound C++ types *and* the type's
-     * holder will fit in the default space (which is large enough to hold either a std::unique_ptr
-     * or std::shared_ptr).
-     *
-     * Non-simple layout applies when using custom holders that require more space than `shared_ptr`
-     * (which is typically the size of two pointers), or when multiple inheritance is used on the
-     * python side.  Non-simple layout allocates the required amount of memory to have multiple
-     * bound C++ classes as parents.  Under this layout, `nonsimple.values_and_holders` is set to a
-     * pointer to allocated space of the required space to hold a a sequence of value pointers and
-     * holders followed `status`, a set of bit flags (1 byte each), i.e.
-     * [val1*][holder1][val2*][holder2]...[bb...]  where each [block] is rounded up to a multiple of
-     * `sizeof(void *)`.  `nonsimple.holder_constructed` is, for convenience, a pointer to the
-     * beginning of the [bb...] block (but not independently allocated).
-     *
-     * Status bits indicate whether the associated holder is constructed (&
-     * status_holder_constructed) and whether the value pointer is registered (&
-     * status_instance_registered) in `registered_instances`.
-     */
-    bool simple_layout : 1;
-    /// For simple layout, tracks whether the holder has been constructed
-    bool simple_holder_constructed : 1;
-    /// For simple layout, tracks whether the instance is registered in `registered_instances`
-    bool simple_instance_registered : 1;
-    /// If true, get_internals().patients has an entry for this object
-    bool has_patients : 1;
-
-    /// Initializes all of the above type/values/holders data (but not the instance values themselves)
-    void allocate_layout();
-
-    /// Destroys/deallocates all of the above
-    void deallocate_layout();
-
-    /// Returns the value_and_holder wrapper for the given type (or the first, if `find_type`
-    /// omitted).  Returns a default-constructed (with `.inst = nullptr`) object on failure if
-    /// `throw_if_missing` is false.
-    value_and_holder get_value_and_holder(const type_info *find_type = nullptr, bool throw_if_missing = true);
-
-    /// Bit values for the non-simple status flags
-    static constexpr uint8_t status_holder_constructed  = 1;
-    static constexpr uint8_t status_instance_registered = 2;
-};
-
-static_assert(std::is_standard_layout<instance>::value, "Internal error: `pybind11::detail::instance` is not standard layout!");
-
-/// from __cpp_future__ import (convenient aliases from C++14/17)
-#if defined(PYBIND11_CPP14) && (!defined(_MSC_VER) || _MSC_VER >= 1910)
-using std::enable_if_t;
-using std::conditional_t;
-using std::remove_cv_t;
-using std::remove_reference_t;
-#else
-template <bool B, typename T = void> using enable_if_t = typename std::enable_if<B, T>::type;
-template <bool B, typename T, typename F> using conditional_t = typename std::conditional<B, T, F>::type;
-template <typename T> using remove_cv_t = typename std::remove_cv<T>::type;
-template <typename T> using remove_reference_t = typename std::remove_reference<T>::type;
-#endif
-
-/// Index sequences
-#if defined(PYBIND11_CPP14)
-using std::index_sequence;
-using std::make_index_sequence;
-#else
-template<size_t ...> struct index_sequence  { };
-template<size_t N, size_t ...S> struct make_index_sequence_impl : make_index_sequence_impl <N - 1, N - 1, S...> { };
-template<size_t ...S> struct make_index_sequence_impl <0, S...> { typedef index_sequence<S...> type; };
-template<size_t N> using make_index_sequence = typename make_index_sequence_impl<N>::type;
-#endif
-
-/// Make an index sequence of the indices of true arguments
-template <typename ISeq, size_t, bool...> struct select_indices_impl { using type = ISeq; };
-template <size_t... IPrev, size_t I, bool B, bool... Bs> struct select_indices_impl<index_sequence<IPrev...>, I, B, Bs...>
-    : select_indices_impl<conditional_t<B, index_sequence<IPrev..., I>, index_sequence<IPrev...>>, I + 1, Bs...> {};
-template <bool... Bs> using select_indices = typename select_indices_impl<index_sequence<>, 0, Bs...>::type;
-
-/// Backports of std::bool_constant and std::negation to accomodate older compilers
-template <bool B> using bool_constant = std::integral_constant<bool, B>;
-template <typename T> struct negation : bool_constant<!T::value> { };
-
-template <typename...> struct void_t_impl { using type = void; };
-template <typename... Ts> using void_t = typename void_t_impl<Ts...>::type;
-
-/// Compile-time all/any/none of that check the boolean value of all template types
-#ifdef __cpp_fold_expressions
-template <class... Ts> using all_of = bool_constant<(Ts::value && ...)>;
-template <class... Ts> using any_of = bool_constant<(Ts::value || ...)>;
-#elif !defined(_MSC_VER)
-template <bool...> struct bools {};
-template <class... Ts> using all_of = std::is_same<
-    bools<Ts::value..., true>,
-    bools<true, Ts::value...>>;
-template <class... Ts> using any_of = negation<all_of<negation<Ts>...>>;
-#else
-// MSVC has trouble with the above, but supports std::conjunction, which we can use instead (albeit
-// at a slight loss of compilation efficiency).
-template <class... Ts> using all_of = std::conjunction<Ts...>;
-template <class... Ts> using any_of = std::disjunction<Ts...>;
-#endif
-template <class... Ts> using none_of = negation<any_of<Ts...>>;
-
-template <class T, template<class> class... Predicates> using satisfies_all_of = all_of<Predicates<T>...>;
-template <class T, template<class> class... Predicates> using satisfies_any_of = any_of<Predicates<T>...>;
-template <class T, template<class> class... Predicates> using satisfies_none_of = none_of<Predicates<T>...>;
-
-/// Strip the class from a method type
-template <typename T> struct remove_class { };
-template <typename C, typename R, typename... A> struct remove_class<R (C::*)(A...)> { typedef R type(A...); };
-template <typename C, typename R, typename... A> struct remove_class<R (C::*)(A...) const> { typedef R type(A...); };
-
-/// Helper template to strip away type modifiers
-template <typename T> struct intrinsic_type                       { typedef T type; };
-template <typename T> struct intrinsic_type<const T>              { typedef typename intrinsic_type<T>::type type; };
-template <typename T> struct intrinsic_type<T*>                   { typedef typename intrinsic_type<T>::type type; };
-template <typename T> struct intrinsic_type<T&>                   { typedef typename intrinsic_type<T>::type type; };
-template <typename T> struct intrinsic_type<T&&>                  { typedef typename intrinsic_type<T>::type type; };
-template <typename T, size_t N> struct intrinsic_type<const T[N]> { typedef typename intrinsic_type<T>::type type; };
-template <typename T, size_t N> struct intrinsic_type<T[N]>       { typedef typename intrinsic_type<T>::type type; };
-template <typename T> using intrinsic_t = typename intrinsic_type<T>::type;
-
-/// Helper type to replace 'void' in some expressions
-struct void_type { };
-
-/// Helper template which holds a list of types
-template <typename...> struct type_list { };
-
-/// Compile-time integer sum
-#ifdef __cpp_fold_expressions
-template <typename... Ts> constexpr size_t constexpr_sum(Ts... ns) { return (0 + ... + size_t{ns}); }
-#else
-constexpr size_t constexpr_sum() { return 0; }
-template <typename T, typename... Ts>
-constexpr size_t constexpr_sum(T n, Ts... ns) { return size_t{n} + constexpr_sum(ns...); }
-#endif
-
-NAMESPACE_BEGIN(constexpr_impl)
-/// Implementation details for constexpr functions
-constexpr int first(int i) { return i; }
-template <typename T, typename... Ts>
-constexpr int first(int i, T v, Ts... vs) { return v ? i : first(i + 1, vs...); }
-
-constexpr int last(int /*i*/, int result) { return result; }
-template <typename T, typename... Ts>
-constexpr int last(int i, int result, T v, Ts... vs) { return last(i + 1, v ? i : result, vs...); }
-NAMESPACE_END(constexpr_impl)
-
-/// Return the index of the first type in Ts which satisfies Predicate<T>.  Returns sizeof...(Ts) if
-/// none match.
-template <template<typename> class Predicate, typename... Ts>
-constexpr int constexpr_first() { return constexpr_impl::first(0, Predicate<Ts>::value...); }
-
-/// Return the index of the last type in Ts which satisfies Predicate<T>, or -1 if none match.
-template <template<typename> class Predicate, typename... Ts>
-constexpr int constexpr_last() { return constexpr_impl::last(0, -1, Predicate<Ts>::value...); }
-
-/// Return the Nth element from the parameter pack
-template <size_t N, typename T, typename... Ts>
-struct pack_element { using type = typename pack_element<N - 1, Ts...>::type; };
-template <typename T, typename... Ts>
-struct pack_element<0, T, Ts...> { using type = T; };
-
-/// Return the one and only type which matches the predicate, or Default if none match.
-/// If more than one type matches the predicate, fail at compile-time.
-template <template<typename> class Predicate, typename Default, typename... Ts>
-struct exactly_one {
-    static constexpr auto found = constexpr_sum(Predicate<Ts>::value...);
-    static_assert(found <= 1, "Found more than one type matching the predicate");
-
-    static constexpr auto index = found ? constexpr_first<Predicate, Ts...>() : 0;
-    using type = conditional_t<found, typename pack_element<index, Ts...>::type, Default>;
-};
-template <template<typename> class P, typename Default>
-struct exactly_one<P, Default> { using type = Default; };
-
-template <template<typename> class Predicate, typename Default, typename... Ts>
-using exactly_one_t = typename exactly_one<Predicate, Default, Ts...>::type;
-
-/// Defer the evaluation of type T until types Us are instantiated
-template <typename T, typename... /*Us*/> struct deferred_type { using type = T; };
-template <typename T, typename... Us> using deferred_t = typename deferred_type<T, Us...>::type;
-
-/// Like is_base_of, but requires a strict base (i.e. `is_strict_base_of<T, T>::value == false`,
-/// unlike `std::is_base_of`)
-template <typename Base, typename Derived> using is_strict_base_of = bool_constant<
-    std::is_base_of<Base, Derived>::value && !std::is_same<Base, Derived>::value>;
-
-template <template<typename...> class Base>
-struct is_template_base_of_impl {
-    template <typename... Us> static std::true_type check(Base<Us...> *);
-    static std::false_type check(...);
-};
-
-/// Check if a template is the base of a type. For example:
-/// `is_template_base_of<Base, T>` is true if `struct T : Base<U> {}` where U can be anything
-template <template<typename...> class Base, typename T>
-#if !defined(_MSC_VER)
-using is_template_base_of = decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T>*)nullptr));
-#else // MSVC2015 has trouble with decltype in template aliases
-struct is_template_base_of : decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T>*)nullptr)) { };
-#endif
-
-/// Check if T is an instantiation of the template `Class`. For example:
-/// `is_instantiation<shared_ptr, T>` is true if `T == shared_ptr<U>` where U can be anything.
-template <template<typename...> class Class, typename T>
-struct is_instantiation : std::false_type { };
-template <template<typename...> class Class, typename... Us>
-struct is_instantiation<Class, Class<Us...>> : std::true_type { };
-
-/// Check if T is std::shared_ptr<U> where U can be anything
-template <typename T> using is_shared_ptr = is_instantiation<std::shared_ptr, T>;
-
-/// Check if T looks like an input iterator
-template <typename T, typename = void> struct is_input_iterator : std::false_type {};
-template <typename T>
-struct is_input_iterator<T, void_t<decltype(*std::declval<T &>()), decltype(++std::declval<T &>())>>
-    : std::true_type {};
-
-template <typename T> using is_function_pointer = bool_constant<
-    std::is_pointer<T>::value && std::is_function<typename std::remove_pointer<T>::type>::value>;
-
-template <typename F> struct strip_function_object {
-    using type = typename remove_class<decltype(&F::operator())>::type;
-};
-
-// Extracts the function signature from a function, function pointer or lambda.
-template <typename Function, typename F = remove_reference_t<Function>>
-using function_signature_t = conditional_t<
-    std::is_function<F>::value,
-    F,
-    typename conditional_t<
-        std::is_pointer<F>::value || std::is_member_pointer<F>::value,
-        std::remove_pointer<F>,
-        strip_function_object<F>
-    >::type
->;
-
-/// Returns true if the type looks like a lambda: that is, isn't a function, pointer or member
-/// pointer.  Note that this can catch all sorts of other things, too; this is intended to be used
-/// in a place where passing a lambda makes sense.
-template <typename T> using is_lambda = satisfies_none_of<remove_reference_t<T>,
-        std::is_function, std::is_pointer, std::is_member_pointer>;
-
-/// Ignore that a variable is unused in compiler warnings
-inline void ignore_unused(const int *) { }
-
-/// Apply a function over each element of a parameter pack
-#ifdef __cpp_fold_expressions
-#define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) (((PATTERN), void()), ...)
-#else
-using expand_side_effects = bool[];
-#define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) pybind11::detail::expand_side_effects{ ((PATTERN), void(), false)..., false }
-#endif
-
-NAMESPACE_END(detail)
-
-/// C++ bindings of builtin Python exceptions
-class builtin_exception : public std::runtime_error {
-public:
-    using std::runtime_error::runtime_error;
-    /// Set the error using the Python C API
-    virtual void set_error() const = 0;
-};
-
-#define PYBIND11_RUNTIME_EXCEPTION(name, type) \
-    class name : public builtin_exception { public: \
-        using builtin_exception::builtin_exception; \
-        name() : name("") { } \
-        void set_error() const override { PyErr_SetString(type, what()); } \
-    };
-
-PYBIND11_RUNTIME_EXCEPTION(stop_iteration, PyExc_StopIteration)
-PYBIND11_RUNTIME_EXCEPTION(index_error, PyExc_IndexError)
-PYBIND11_RUNTIME_EXCEPTION(key_error, PyExc_KeyError)
-PYBIND11_RUNTIME_EXCEPTION(value_error, PyExc_ValueError)
-PYBIND11_RUNTIME_EXCEPTION(type_error, PyExc_TypeError)
-PYBIND11_RUNTIME_EXCEPTION(cast_error, PyExc_RuntimeError) /// Thrown when pybind11::cast or handle::call fail due to a type casting error
-PYBIND11_RUNTIME_EXCEPTION(reference_cast_error, PyExc_RuntimeError) /// Used internally
-
-[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const char *reason) { throw std::runtime_error(reason); }
-[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const std::string &reason) { throw std::runtime_error(reason); }
-
-template <typename T, typename SFINAE = void> struct format_descriptor { };
-
-NAMESPACE_BEGIN(detail)
-// Returns the index of the given type in the type char array below, and in the list in numpy.h
-// The order here is: bool; 8 ints ((signed,unsigned)x(8,16,32,64)bits); float,double,long double;
-// complex float,double,long double.  Note that the long double types only participate when long
-// double is actually longer than double (it isn't under MSVC).
-// NB: not only the string below but also complex.h and numpy.h rely on this order.
-template <typename T, typename SFINAE = void> struct is_fmt_numeric { static constexpr bool value = false; };
-template <typename T> struct is_fmt_numeric<T, enable_if_t<std::is_arithmetic<T>::value>> {
-    static constexpr bool value = true;
-    static constexpr int index = std::is_same<T, bool>::value ? 0 : 1 + (
-        std::is_integral<T>::value ? detail::log2(sizeof(T))*2 + std::is_unsigned<T>::value : 8 + (
-        std::is_same<T, double>::value ? 1 : std::is_same<T, long double>::value ? 2 : 0));
-};
-NAMESPACE_END(detail)
-
-template <typename T> struct format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>> {
-    static constexpr const char c = "?bBhHiIqQfdg"[detail::is_fmt_numeric<T>::index];
-    static constexpr const char value[2] = { c, '\0' };
-    static std::string format() { return std::string(1, c); }
-};
-
-template <typename T> constexpr const char format_descriptor<
-    T, detail::enable_if_t<std::is_arithmetic<T>::value>>::value[2];
-
-/// RAII wrapper that temporarily clears any Python error state
-struct error_scope {
-    PyObject *type, *value, *trace;
-    error_scope() { PyErr_Fetch(&type, &value, &trace); }
-    ~error_scope() { PyErr_Restore(type, value, trace); }
-};
-
-/// Dummy destructor wrapper that can be used to expose classes with a private destructor
-struct nodelete { template <typename T> void operator()(T*) { } };
-
-// overload_cast requires variable templates: C++14
-#if defined(PYBIND11_CPP14)
-#define PYBIND11_OVERLOAD_CAST 1
-
-NAMESPACE_BEGIN(detail)
-template <typename... Args>
-struct overload_cast_impl {
-    constexpr overload_cast_impl() {} // MSVC 2015 needs this
-
-    template <typename Return>
-    constexpr auto operator()(Return (*pf)(Args...)) const noexcept
-                              -> decltype(pf) { return pf; }
-
-    template <typename Return, typename Class>
-    constexpr auto operator()(Return (Class::*pmf)(Args...), std::false_type = {}) const noexcept
-                              -> decltype(pmf) { return pmf; }
-
-    template <typename Return, typename Class>
-    constexpr auto operator()(Return (Class::*pmf)(Args...) const, std::true_type) const noexcept
-                              -> decltype(pmf) { return pmf; }
-};
-NAMESPACE_END(detail)
-
-/// Syntax sugar for resolving overloaded function pointers:
-///  - regular: static_cast<Return (Class::*)(Arg0, Arg1, Arg2)>(&Class::func)
-///  - sweet:   overload_cast<Arg0, Arg1, Arg2>(&Class::func)
-template <typename... Args>
-static constexpr detail::overload_cast_impl<Args...> overload_cast = {};
-// MSVC 2015 only accepts this particular initialization syntax for this variable template.
-
-/// Const member function selector for overload_cast
-///  - regular: static_cast<Return (Class::*)(Arg) const>(&Class::func)
-///  - sweet:   overload_cast<Arg>(&Class::func, const_)
-static constexpr auto const_ = std::true_type{};
-
-#else // no overload_cast: providing something that static_assert-fails:
-template <typename... Args> struct overload_cast {
-    static_assert(detail::deferred_t<std::false_type, Args...>::value,
-                  "pybind11::overload_cast<...> requires compiling in C++14 mode");
-};
-#endif // overload_cast
-
-NAMESPACE_BEGIN(detail)
-
-// Adaptor for converting arbitrary container arguments into a vector; implicitly convertible from
-// any standard container (or C-style array) supporting std::begin/std::end, any singleton
-// arithmetic type (if T is arithmetic), or explicitly constructible from an iterator pair.
-template <typename T>
-class any_container {
-    std::vector<T> v;
-public:
-    any_container() = default;
-
-    // Can construct from a pair of iterators
-    template <typename It, typename = enable_if_t<is_input_iterator<It>::value>>
-    any_container(It first, It last) : v(first, last) { }
-
-    // Implicit conversion constructor from any arbitrary container type with values convertible to T
-    template <typename Container, typename = enable_if_t<std::is_convertible<decltype(*std::begin(std::declval<const Container &>())), T>::value>>
-    any_container(const Container &c) : any_container(std::begin(c), std::end(c)) { }
-
-    // initializer_list's aren't deducible, so don't get matched by the above template; we need this
-    // to explicitly allow implicit conversion from one:
-    template <typename TIn, typename = enable_if_t<std::is_convertible<TIn, T>::value>>
-    any_container(const std::initializer_list<TIn> &c) : any_container(c.begin(), c.end()) { }
-
-    // Avoid copying if given an rvalue vector of the correct type.
-    any_container(std::vector<T> &&v) : v(std::move(v)) { }
-
-    // Moves the vector out of an rvalue any_container
-    operator std::vector<T> &&() && { return std::move(v); }
-
-    // Dereferencing obtains a reference to the underlying vector
-    std::vector<T> &operator*() { return v; }
-    const std::vector<T> &operator*() const { return v; }
-
-    // -> lets you call methods on the underlying vector
-    std::vector<T> *operator->() { return &v; }
-    const std::vector<T> *operator->() const { return &v; }
-};
-
-NAMESPACE_END(detail)
-
-
-
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/detail/descr.h b/tmap/lib/pybind11/include/pybind11/detail/descr.h
deleted file mode 100644
index e3bf2ba..0000000
--- a/tmap/lib/pybind11/include/pybind11/detail/descr.h
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
-    pybind11/detail/descr.h: Helper type for concatenating type signatures
-    either at runtime (C++11) or compile time (C++14)
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "common.h"
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
-
-/* Concatenate type signatures at compile time using C++14 */
-#if defined(PYBIND11_CPP14) && !defined(_MSC_VER)
-#define PYBIND11_CONSTEXPR_DESCR
-
-template <size_t Size1, size_t Size2> class descr {
-    template <size_t Size1_, size_t Size2_> friend class descr;
-public:
-    constexpr descr(char const (&text) [Size1+1], const std::type_info * const (&types)[Size2+1])
-        : descr(text, types,
-                make_index_sequence<Size1>(),
-                make_index_sequence<Size2>()) { }
-
-    constexpr const char *text() const { return m_text; }
-    constexpr const std::type_info * const * types() const { return m_types; }
-
-    template <size_t OtherSize1, size_t OtherSize2>
-    constexpr descr<Size1 + OtherSize1, Size2 + OtherSize2> operator+(const descr<OtherSize1, OtherSize2> &other) const {
-        return concat(other,
-                      make_index_sequence<Size1>(),
-                      make_index_sequence<Size2>(),
-                      make_index_sequence<OtherSize1>(),
-                      make_index_sequence<OtherSize2>());
-    }
-
-protected:
-    template <size_t... Indices1, size_t... Indices2>
-    constexpr descr(
-        char const (&text) [Size1+1],
-        const std::type_info * const (&types) [Size2+1],
-        index_sequence<Indices1...>, index_sequence<Indices2...>)
-        : m_text{text[Indices1]..., '\0'},
-          m_types{types[Indices2]...,  nullptr } {}
-
-    template <size_t OtherSize1, size_t OtherSize2, size_t... Indices1,
-              size_t... Indices2, size_t... OtherIndices1, size_t... OtherIndices2>
-    constexpr descr<Size1 + OtherSize1, Size2 + OtherSize2>
-    concat(const descr<OtherSize1, OtherSize2> &other,
-           index_sequence<Indices1...>, index_sequence<Indices2...>,
-           index_sequence<OtherIndices1...>, index_sequence<OtherIndices2...>) const {
-        return descr<Size1 + OtherSize1, Size2 + OtherSize2>(
-            { m_text[Indices1]..., other.m_text[OtherIndices1]..., '\0' },
-            { m_types[Indices2]..., other.m_types[OtherIndices2]..., nullptr }
-        );
-    }
-
-protected:
-    char m_text[Size1 + 1];
-    const std::type_info * m_types[Size2 + 1];
-};
-
-template <size_t Size> constexpr descr<Size - 1, 0> _(char const(&text)[Size]) {
-    return descr<Size - 1, 0>(text, { nullptr });
-}
-
-template <size_t Rem, size_t... Digits> struct int_to_str : int_to_str<Rem/10, Rem%10, Digits...> { };
-template <size_t...Digits> struct int_to_str<0, Digits...> {
-    static constexpr auto digits = descr<sizeof...(Digits), 0>({ ('0' + Digits)..., '\0' }, { nullptr });
-};
-
-// Ternary description (like std::conditional)
-template <bool B, size_t Size1, size_t Size2>
-constexpr enable_if_t<B, descr<Size1 - 1, 0>> _(char const(&text1)[Size1], char const(&)[Size2]) {
-    return _(text1);
-}
-template <bool B, size_t Size1, size_t Size2>
-constexpr enable_if_t<!B, descr<Size2 - 1, 0>> _(char const(&)[Size1], char const(&text2)[Size2]) {
-    return _(text2);
-}
-template <bool B, size_t SizeA1, size_t SizeA2, size_t SizeB1, size_t SizeB2>
-constexpr enable_if_t<B, descr<SizeA1, SizeA2>> _(descr<SizeA1, SizeA2> d, descr<SizeB1, SizeB2>) { return d; }
-template <bool B, size_t SizeA1, size_t SizeA2, size_t SizeB1, size_t SizeB2>
-constexpr enable_if_t<!B, descr<SizeB1, SizeB2>> _(descr<SizeA1, SizeA2>, descr<SizeB1, SizeB2> d) { return d; }
-
-template <size_t Size> auto constexpr _() -> decltype(int_to_str<Size / 10, Size % 10>::digits) {
-    return int_to_str<Size / 10, Size % 10>::digits;
-}
-
-template <typename Type> constexpr descr<1, 1> _() {
-    return descr<1, 1>({ '%', '\0' }, { &typeid(Type), nullptr });
-}
-
-inline constexpr descr<0, 0> concat() { return _(""); }
-template <size_t Size1, size_t Size2, typename... Args> auto constexpr concat(descr<Size1, Size2> descr) { return descr; }
-template <size_t Size1, size_t Size2, typename... Args> auto constexpr concat(descr<Size1, Size2> descr, Args&&... args) { return descr + _(", ") + concat(args...); }
-template <size_t Size1, size_t Size2> auto constexpr type_descr(descr<Size1, Size2> descr) { return _("{") + descr + _("}"); }
-
-#define PYBIND11_DESCR constexpr auto
-
-#else /* Simpler C++11 implementation based on run-time memory allocation and copying */
-
-class descr {
-public:
-    PYBIND11_NOINLINE descr(const char *text, const std::type_info * const * types) {
-        size_t nChars = len(text), nTypes = len(types);
-        m_text  = new char[nChars];
-        m_types = new const std::type_info *[nTypes];
-        memcpy(m_text, text, nChars * sizeof(char));
-        memcpy(m_types, types, nTypes * sizeof(const std::type_info *));
-    }
-
-    PYBIND11_NOINLINE descr operator+(descr &&d2) && {
-        descr r;
-
-        size_t nChars1 = len(m_text),    nTypes1 = len(m_types);
-        size_t nChars2 = len(d2.m_text), nTypes2 = len(d2.m_types);
-
-        r.m_text  = new char[nChars1 + nChars2 - 1];
-        r.m_types = new const std::type_info *[nTypes1 + nTypes2 - 1];
-        memcpy(r.m_text, m_text, (nChars1-1) * sizeof(char));
-        memcpy(r.m_text + nChars1 - 1, d2.m_text, nChars2 * sizeof(char));
-        memcpy(r.m_types, m_types, (nTypes1-1) * sizeof(std::type_info *));
-        memcpy(r.m_types + nTypes1 - 1, d2.m_types, nTypes2 * sizeof(std::type_info *));
-
-        delete[] m_text;    delete[] m_types;
-        delete[] d2.m_text; delete[] d2.m_types;
-
-        return r;
-    }
-
-    char *text() { return m_text; }
-    const std::type_info * * types() { return m_types; }
-
-protected:
-    PYBIND11_NOINLINE descr() { }
-
-    template <typename T> static size_t len(const T *ptr) { // return length including null termination
-        const T *it = ptr;
-        while (*it++ != (T) 0)
-            ;
-        return static_cast<size_t>(it - ptr);
-    }
-
-    const std::type_info **m_types = nullptr;
-    char *m_text = nullptr;
-};
-
-/* The 'PYBIND11_NOINLINE inline' combinations below are intentional to get the desired linkage while producing as little object code as possible */
-
-PYBIND11_NOINLINE inline descr _(const char *text) {
-    const std::type_info *types[1] = { nullptr };
-    return descr(text, types);
-}
-
-template <bool B> PYBIND11_NOINLINE enable_if_t<B, descr> _(const char *text1, const char *) { return _(text1); }
-template <bool B> PYBIND11_NOINLINE enable_if_t<!B, descr> _(char const *, const char *text2) { return _(text2); }
-template <bool B> PYBIND11_NOINLINE enable_if_t<B, descr> _(descr d, descr) { return d; }
-template <bool B> PYBIND11_NOINLINE enable_if_t<!B, descr> _(descr, descr d) { return d; }
-
-template <typename Type> PYBIND11_NOINLINE descr _() {
-    const std::type_info *types[2] = { &typeid(Type), nullptr };
-    return descr("%", types);
-}
-
-template <size_t Size> PYBIND11_NOINLINE descr _() {
-    const std::type_info *types[1] = { nullptr };
-    return descr(std::to_string(Size).c_str(), types);
-}
-
-PYBIND11_NOINLINE inline descr concat() { return _(""); }
-PYBIND11_NOINLINE inline descr concat(descr &&d) { return d; }
-template <typename... Args> PYBIND11_NOINLINE descr concat(descr &&d, Args&&... args) { return std::move(d) + _(", ") + concat(std::forward<Args>(args)...); }
-PYBIND11_NOINLINE inline descr type_descr(descr&& d) { return _("{") + std::move(d) + _("}"); }
-
-#define PYBIND11_DESCR ::pybind11::detail::descr
-#endif
-
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/detail/init.h b/tmap/lib/pybind11/include/pybind11/detail/init.h
deleted file mode 100644
index deace19..0000000
--- a/tmap/lib/pybind11/include/pybind11/detail/init.h
+++ /dev/null
@@ -1,325 +0,0 @@
-/*
-    pybind11/detail/init.h: init factory function implementation and support code.
-
-    Copyright (c) 2017 Jason Rhinelander <jason@imaginary.ca>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "class.h"
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
-
-template <>
-class type_caster<value_and_holder> {
-public:
-    bool load(handle h, bool) {
-        value = reinterpret_cast<value_and_holder *>(h.ptr());
-        return true;
-    }
-
-    template <typename> using cast_op_type = value_and_holder &;
-    operator value_and_holder &() { return *value; }
-    static PYBIND11_DESCR name() { return type_descr(_<value_and_holder>()); }
-
-private:
-    value_and_holder *value = nullptr;
-};
-
-NAMESPACE_BEGIN(initimpl)
-
-inline void no_nullptr(void *ptr) {
-    if (!ptr) throw type_error("pybind11::init(): factory function returned nullptr");
-}
-
-// Implementing functions for all forms of py::init<...> and py::init(...)
-template <typename Class> using Cpp = typename Class::type;
-template <typename Class> using Alias = typename Class::type_alias;
-template <typename Class> using Holder = typename Class::holder_type;
-
-template <typename Class> using is_alias_constructible = std::is_constructible<Alias<Class>, Cpp<Class> &&>;
-
-// Takes a Cpp pointer and returns true if it actually is a polymorphic Alias instance.
-template <typename Class, enable_if_t<Class::has_alias, int> = 0>
-bool is_alias(Cpp<Class> *ptr) {
-    return dynamic_cast<Alias<Class> *>(ptr) != nullptr;
-}
-// Failing fallback version of the above for a no-alias class (always returns false)
-template <typename /*Class*/>
-constexpr bool is_alias(void *) { return false; }
-
-// Attempts to constructs an alias using a `Alias(Cpp &&)` constructor.  This allows types with
-// an alias to provide only a single Cpp factory function as long as the Alias can be
-// constructed from an rvalue reference of the base Cpp type.  This means that Alias classes
-// can, when appropriate, simply define a `Alias(Cpp &&)` constructor rather than needing to
-// inherit all the base class constructors.
-template <typename Class>
-void construct_alias_from_cpp(std::true_type /*is_alias_constructible*/,
-                              value_and_holder &v_h, Cpp<Class> &&base) {
-    v_h.value_ptr() = new Alias<Class>(std::move(base));
-}
-template <typename Class>
-[[noreturn]] void construct_alias_from_cpp(std::false_type /*!is_alias_constructible*/,
-                                           value_and_holder &, Cpp<Class> &&) {
-    throw type_error("pybind11::init(): unable to convert returned instance to required "
-                     "alias class: no `Alias<Class>(Class &&)` constructor available");
-}
-
-// Error-generating fallback for factories that don't match one of the below construction
-// mechanisms.
-template <typename Class>
-void construct(...) {
-    static_assert(!std::is_same<Class, Class>::value /* always false */,
-            "pybind11::init(): init function must return a compatible pointer, "
-            "holder, or value");
-}
-
-// Pointer return v1: the factory function returns a class pointer for a registered class.
-// If we don't need an alias (because this class doesn't have one, or because the final type is
-// inherited on the Python side) we can simply take over ownership.  Otherwise we need to try to
-// construct an Alias from the returned base instance.
-template <typename Class>
-void construct(value_and_holder &v_h, Cpp<Class> *ptr, bool need_alias) {
-    no_nullptr(ptr);
-    if (Class::has_alias && need_alias && !is_alias<Class>(ptr)) {
-        // We're going to try to construct an alias by moving the cpp type.  Whether or not
-        // that succeeds, we still need to destroy the original cpp pointer (either the
-        // moved away leftover, if the alias construction works, or the value itself if we
-        // throw an error), but we can't just call `delete ptr`: it might have a special
-        // deleter, or might be shared_from_this.  So we construct a holder around it as if
-        // it was a normal instance, then steal the holder away into a local variable; thus
-        // the holder and destruction happens when we leave the C++ scope, and the holder
-        // class gets to handle the destruction however it likes.
-        v_h.value_ptr() = ptr;
-        v_h.set_instance_registered(true); // To prevent init_instance from registering it
-        v_h.type->init_instance(v_h.inst, nullptr); // Set up the holder
-        Holder<Class> temp_holder(std::move(v_h.holder<Holder<Class>>())); // Steal the holder
-        v_h.type->dealloc(v_h); // Destroys the moved-out holder remains, resets value ptr to null
-        v_h.set_instance_registered(false);
-
-        construct_alias_from_cpp<Class>(is_alias_constructible<Class>{}, v_h, std::move(*ptr));
-    } else {
-        // Otherwise the type isn't inherited, so we don't need an Alias
-        v_h.value_ptr() = ptr;
-    }
-}
-
-// Pointer return v2: a factory that always returns an alias instance ptr.  We simply take over
-// ownership of the pointer.
-template <typename Class, enable_if_t<Class::has_alias, int> = 0>
-void construct(value_and_holder &v_h, Alias<Class> *alias_ptr, bool) {
-    no_nullptr(alias_ptr);
-    v_h.value_ptr() = static_cast<Cpp<Class> *>(alias_ptr);
-}
-
-// Holder return: copy its pointer, and move or copy the returned holder into the new instance's
-// holder.  This also handles types like std::shared_ptr<T> and std::unique_ptr<T> where T is a
-// derived type (through those holder's implicit conversion from derived class holder constructors).
-template <typename Class>
-void construct(value_and_holder &v_h, Holder<Class> holder, bool need_alias) {
-    auto *ptr = holder_helper<Holder<Class>>::get(holder);
-    // If we need an alias, check that the held pointer is actually an alias instance
-    if (Class::has_alias && need_alias && !is_alias<Class>(ptr))
-        throw type_error("pybind11::init(): construction failed: returned holder-wrapped instance "
-                         "is not an alias instance");
-
-    v_h.value_ptr() = ptr;
-    v_h.type->init_instance(v_h.inst, &holder);
-}
-
-// return-by-value version 1: returning a cpp class by value.  If the class has an alias and an
-// alias is required the alias must have an `Alias(Cpp &&)` constructor so that we can construct
-// the alias from the base when needed (i.e. because of Python-side inheritance).  When we don't
-// need it, we simply move-construct the cpp value into a new instance.
-template <typename Class>
-void construct(value_and_holder &v_h, Cpp<Class> &&result, bool need_alias) {
-    static_assert(std::is_move_constructible<Cpp<Class>>::value,
-        "pybind11::init() return-by-value factory function requires a movable class");
-    if (Class::has_alias && need_alias)
-        construct_alias_from_cpp<Class>(is_alias_constructible<Class>{}, v_h, std::move(result));
-    else
-        v_h.value_ptr() = new Cpp<Class>(std::move(result));
-}
-
-// return-by-value version 2: returning a value of the alias type itself.  We move-construct an
-// Alias instance (even if no the python-side inheritance is involved).  The is intended for
-// cases where Alias initialization is always desired.
-template <typename Class>
-void construct(value_and_holder &v_h, Alias<Class> &&result, bool) {
-    static_assert(std::is_move_constructible<Alias<Class>>::value,
-        "pybind11::init() return-by-alias-value factory function requires a movable alias class");
-    v_h.value_ptr() = new Alias<Class>(std::move(result));
-}
-
-// Implementing class for py::init<...>()
-template <typename... Args>
-struct constructor {
-    template <typename Class, typename... Extra, enable_if_t<!Class::has_alias, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
-            v_h.value_ptr() = new Cpp<Class>{std::forward<Args>(args)...};
-        }, is_new_style_constructor(), extra...);
-    }
-
-    template <typename Class, typename... Extra,
-              enable_if_t<Class::has_alias &&
-                          std::is_constructible<Cpp<Class>, Args...>::value, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
-            if (Py_TYPE(v_h.inst) == v_h.type->type)
-                v_h.value_ptr() = new Cpp<Class>{std::forward<Args>(args)...};
-            else
-                v_h.value_ptr() = new Alias<Class>{std::forward<Args>(args)...};
-        }, is_new_style_constructor(), extra...);
-    }
-
-    template <typename Class, typename... Extra,
-              enable_if_t<Class::has_alias &&
-                          !std::is_constructible<Cpp<Class>, Args...>::value, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
-            v_h.value_ptr() = new Alias<Class>{std::forward<Args>(args)...};
-        }, is_new_style_constructor(), extra...);
-    }
-};
-
-// Implementing class for py::init_alias<...>()
-template <typename... Args> struct alias_constructor {
-    template <typename Class, typename... Extra,
-              enable_if_t<Class::has_alias && std::is_constructible<Alias<Class>, Args...>::value, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
-            v_h.value_ptr() = new Alias<Class>{std::forward<Args>(args)...};
-        }, is_new_style_constructor(), extra...);
-    }
-};
-
-// Implementation class for py::init(Func) and py::init(Func, AliasFunc)
-template <typename CFunc, typename AFunc = void_type (*)(),
-          typename = function_signature_t<CFunc>, typename = function_signature_t<AFunc>>
-struct factory;
-
-// Specialization for py::init(Func)
-template <typename Func, typename Return, typename... Args>
-struct factory<Func, void_type (*)(), Return(Args...)> {
-    remove_reference_t<Func> class_factory;
-
-    factory(Func &&f) : class_factory(std::forward<Func>(f)) { }
-
-    // The given class either has no alias or has no separate alias factory;
-    // this always constructs the class itself.  If the class is registered with an alias
-    // type and an alias instance is needed (i.e. because the final type is a Python class
-    // inheriting from the C++ type) the returned value needs to either already be an alias
-    // instance, or the alias needs to be constructible from a `Class &&` argument.
-    template <typename Class, typename... Extra>
-    void execute(Class &cl, const Extra &...extra) && {
-        #if defined(PYBIND11_CPP14)
-        cl.def("__init__", [func = std::move(class_factory)]
-        #else
-        auto &func = class_factory;
-        cl.def("__init__", [func]
-        #endif
-        (value_and_holder &v_h, Args... args) {
-            construct<Class>(v_h, func(std::forward<Args>(args)...),
-                             Py_TYPE(v_h.inst) != v_h.type->type);
-        }, is_new_style_constructor(), extra...);
-    }
-};
-
-// Specialization for py::init(Func, AliasFunc)
-template <typename CFunc, typename AFunc,
-          typename CReturn, typename... CArgs, typename AReturn, typename... AArgs>
-struct factory<CFunc, AFunc, CReturn(CArgs...), AReturn(AArgs...)> {
-    static_assert(sizeof...(CArgs) == sizeof...(AArgs),
-                  "pybind11::init(class_factory, alias_factory): class and alias factories "
-                  "must have identical argument signatures");
-    static_assert(all_of<std::is_same<CArgs, AArgs>...>::value,
-                  "pybind11::init(class_factory, alias_factory): class and alias factories "
-                  "must have identical argument signatures");
-
-    remove_reference_t<CFunc> class_factory;
-    remove_reference_t<AFunc> alias_factory;
-
-    factory(CFunc &&c, AFunc &&a)
-        : class_factory(std::forward<CFunc>(c)), alias_factory(std::forward<AFunc>(a)) { }
-
-    // The class factory is called when the `self` type passed to `__init__` is the direct
-    // class (i.e. not inherited), the alias factory when `self` is a Python-side subtype.
-    template <typename Class, typename... Extra>
-    void execute(Class &cl, const Extra&... extra) && {
-        static_assert(Class::has_alias, "The two-argument version of `py::init()` can "
-                                        "only be used if the class has an alias");
-        #if defined(PYBIND11_CPP14)
-        cl.def("__init__", [class_func = std::move(class_factory), alias_func = std::move(alias_factory)]
-        #else
-        auto &class_func = class_factory;
-        auto &alias_func = alias_factory;
-        cl.def("__init__", [class_func, alias_func]
-        #endif
-        (value_and_holder &v_h, CArgs... args) {
-            if (Py_TYPE(v_h.inst) == v_h.type->type)
-                // If the instance type equals the registered type we don't have inheritance, so
-                // don't need the alias and can construct using the class function:
-                construct<Class>(v_h, class_func(std::forward<CArgs>(args)...), false);
-            else
-                construct<Class>(v_h, alias_func(std::forward<CArgs>(args)...), true);
-        }, is_new_style_constructor(), extra...);
-    }
-};
-
-/// Set just the C++ state. Same as `__init__`.
-template <typename Class, typename T>
-void setstate(value_and_holder &v_h, T &&result, bool need_alias) {
-    construct<Class>(v_h, std::forward<T>(result), need_alias);
-}
-
-/// Set both the C++ and Python states
-template <typename Class, typename T, typename O,
-          enable_if_t<std::is_convertible<O, handle>::value, int> = 0>
-void setstate(value_and_holder &v_h, std::pair<T, O> &&result, bool need_alias) {
-    construct<Class>(v_h, std::move(result.first), need_alias);
-    setattr((PyObject *) v_h.inst, "__dict__", result.second);
-}
-
-/// Implementation for py::pickle(GetState, SetState)
-template <typename Get, typename Set,
-          typename = function_signature_t<Get>, typename = function_signature_t<Set>>
-struct pickle_factory;
-
-template <typename Get, typename Set,
-          typename RetState, typename Self, typename NewInstance, typename ArgState>
-struct pickle_factory<Get, Set, RetState(Self), NewInstance(ArgState)> {
-    static_assert(std::is_same<RetState, ArgState>::value,
-                  "The type returned by `__getstate__` must be the same "
-                  "as the argument accepted by `__setstate__`");
-
-    remove_reference_t<Get> get;
-    remove_reference_t<Set> set;
-
-    pickle_factory(Get get, Set set)
-        : get(std::forward<Get>(get)), set(std::forward<Set>(set)) { }
-
-    template <typename Class, typename... Extra>
-    void execute(Class &cl, const Extra &...extra) && {
-        cl.def("__getstate__", std::move(get));
-
-#if defined(PYBIND11_CPP14)
-        cl.def("__setstate__", [func = std::move(set)]
-#else
-        auto &func = set;
-        cl.def("__setstate__", [func]
-#endif
-        (value_and_holder &v_h, ArgState state) {
-            setstate<Class>(v_h, func(std::forward<ArgState>(state)),
-                            Py_TYPE(v_h.inst) != v_h.type->type);
-        }, is_new_style_constructor(), extra...);
-    }
-};
-
-NAMESPACE_END(initimpl)
-NAMESPACE_END(detail)
-NAMESPACE_END(pybind11)
diff --git a/tmap/lib/pybind11/include/pybind11/detail/internals.h b/tmap/lib/pybind11/include/pybind11/detail/internals.h
deleted file mode 100644
index 213cbae..0000000
--- a/tmap/lib/pybind11/include/pybind11/detail/internals.h
+++ /dev/null
@@ -1,247 +0,0 @@
-/*
-    pybind11/detail/internals.h: Internal data structure and related functions
-
-    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "../pytypes.h"
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
-// Forward declarations
-inline PyTypeObject *make_static_property_type();
-inline PyTypeObject *make_default_metaclass();
-inline PyObject *make_object_base_type(PyTypeObject *metaclass);
-
-// Python loads modules by default with dlopen with the RTLD_LOCAL flag; under libc++ and possibly
-// other STLs, this means `typeid(A)` from one module won't equal `typeid(A)` from another module
-// even when `A` is the same, non-hidden-visibility type (e.g. from a common include).  Under
-// libstdc++, this doesn't happen: equality and the type_index hash are based on the type name,
-// which works.  If not under a known-good stl, provide our own name-based hash and equality
-// functions that use the type name.
-#if defined(__GLIBCXX__)
-inline bool same_type(const std::type_info &lhs, const std::type_info &rhs) { return lhs == rhs; }
-using type_hash = std::hash<std::type_index>;
-using type_equal_to = std::equal_to<std::type_index>;
-#else
-inline bool same_type(const std::type_info &lhs, const std::type_info &rhs) {
-    return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;
-}
-
-struct type_hash {
-    size_t operator()(const std::type_index &t) const {
-        size_t hash = 5381;
-        const char *ptr = t.name();
-        while (auto c = static_cast<unsigned char>(*ptr++))
-            hash = (hash * 33) ^ c;
-        return hash;
-    }
-};
-
-struct type_equal_to {
-    bool operator()(const std::type_index &lhs, const std::type_index &rhs) const {
-        return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;
-    }
-};
-#endif
-
-template <typename value_type>
-using type_map = std::unordered_map<std::type_index, value_type, type_hash, type_equal_to>;
-
-struct overload_hash {
-    inline size_t operator()(const std::pair<const PyObject *, const char *>& v) const {
-        size_t value = std::hash<const void *>()(v.first);
-        value ^= std::hash<const void *>()(v.second)  + 0x9e3779b9 + (value<<6) + (value>>2);
-        return value;
-    }
-};
-
-/// Internal data structure used to track registered instances and types.
-/// Whenever binary incompatible changes are made to this structure,
-/// `PYBIND11_INTERNALS_VERSION` must be incremented.
-struct internals {
-    type_map<type_info *> registered_types_cpp; // std::type_index -> pybind11's type information
-    std::unordered_map<PyTypeObject *, std::vector<type_info *>> registered_types_py; // PyTypeObject* -> base type_info(s)
-    std::unordered_multimap<const void *, instance*> registered_instances; // void * -> instance*
-    std::unordered_set<std::pair<const PyObject *, const char *>, overload_hash> inactive_overload_cache;
-    type_map<std::vector<bool (*)(PyObject *, void *&)>> direct_conversions;
-    std::unordered_map<const PyObject *, std::vector<PyObject *>> patients;
-    std::forward_list<void (*) (std::exception_ptr)> registered_exception_translators;
-    std::unordered_map<std::string, void *> shared_data; // Custom data to be shared across extensions
-    std::vector<PyObject *> loader_patient_stack; // Used by `loader_life_support`
-    std::forward_list<std::string> static_strings; // Stores the std::strings backing detail::c_str()
-    PyTypeObject *static_property_type;
-    PyTypeObject *default_metaclass;
-    PyObject *instance_base;
-#if defined(WITH_THREAD)
-    decltype(PyThread_create_key()) tstate = 0; // Usually an int but a long on Cygwin64 with Python 3.x
-    PyInterpreterState *istate = nullptr;
-#endif
-};
-
-/// Additional type information which does not fit into the PyTypeObject.
-/// Changes to this struct also require bumping `PYBIND11_INTERNALS_VERSION`.
-struct type_info {
-    PyTypeObject *type;
-    const std::type_info *cpptype;
-    size_t type_size, holder_size_in_ptrs;
-    void *(*operator_new)(size_t);
-    void (*init_instance)(instance *, const void *);
-    void (*dealloc)(value_and_holder &v_h);
-    std::vector<PyObject *(*)(PyObject *, PyTypeObject *)> implicit_conversions;
-    std::vector<std::pair<const std::type_info *, void *(*)(void *)>> implicit_casts;
-    std::vector<bool (*)(PyObject *, void *&)> *direct_conversions;
-    buffer_info *(*get_buffer)(PyObject *, void *) = nullptr;
-    void *get_buffer_data = nullptr;
-    void *(*module_local_load)(PyObject *, const type_info *) = nullptr;
-    /* A simple type never occurs as a (direct or indirect) parent
-     * of a class that makes use of multiple inheritance */
-    bool simple_type : 1;
-    /* True if there is no multiple inheritance in this type's inheritance tree */
-    bool simple_ancestors : 1;
-    /* for base vs derived holder_type checks */
-    bool default_holder : 1;
-    /* true if this is a type registered with py::module_local */
-    bool module_local : 1;
-};
-
-/// Tracks the `internals` and `type_info` ABI version independent of the main library version
-#define PYBIND11_INTERNALS_VERSION 1
-
-#if defined(WITH_THREAD)
-#  define PYBIND11_INTERNALS_KIND ""
-#else
-#  define PYBIND11_INTERNALS_KIND "_without_thread"
-#endif
-
-#define PYBIND11_INTERNALS_ID "__pybind11_internals_v" \
-    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND "__"
-
-#define PYBIND11_MODULE_LOCAL_ID "__pybind11_module_local_v" \
-    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND "__"
-
-/// Each module locally stores a pointer to the `internals` data. The data
-/// itself is shared among modules with the same `PYBIND11_INTERNALS_ID`.
-inline internals *&get_internals_ptr() {
-    static internals *internals_ptr = nullptr;
-    return internals_ptr;
-}
-
-/// Return a reference to the current `internals` data
-PYBIND11_NOINLINE inline internals &get_internals() {
-    auto *&internals_ptr = get_internals_ptr();
-    if (internals_ptr)
-        return *internals_ptr;
-
-    constexpr auto *id = PYBIND11_INTERNALS_ID;
-    auto builtins = handle(PyEval_GetBuiltins());
-    if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {
-        internals_ptr = *static_cast<internals **>(capsule(builtins[id]));
-
-        // We loaded builtins through python's builtins, which means that our `error_already_set`
-        // and `builtin_exception` may be different local classes than the ones set up in the
-        // initial exception translator, below, so add another for our local exception classes.
-        //
-        // libstdc++ doesn't require this (types there are identified only by name)
-#if !defined(__GLIBCXX__)
-        internals_ptr->registered_exception_translators.push_front(
-            [](std::exception_ptr p) -> void {
-                try {
-                    if (p) std::rethrow_exception(p);
-                } catch (error_already_set &e)       { e.restore();   return;
-                } catch (const builtin_exception &e) { e.set_error(); return;
-                }
-            }
-        );
-#endif
-    } else {
-        internals_ptr = new internals();
-#if defined(WITH_THREAD)
-        PyEval_InitThreads();
-        PyThreadState *tstate = PyThreadState_Get();
-        internals_ptr->tstate = PyThread_create_key();
-        PyThread_set_key_value(internals_ptr->tstate, tstate);
-        internals_ptr->istate = tstate->interp;
-#endif
-        builtins[id] = capsule(&internals_ptr);
-        internals_ptr->registered_exception_translators.push_front(
-            [](std::exception_ptr p) -> void {
-                try {
-                    if (p) std::rethrow_exception(p);
-                } catch (error_already_set &e)           { e.restore();                                    return;
-                } catch (const builtin_exception &e)     { e.set_error();                                  return;
-                } catch (const std::bad_alloc &e)        { PyErr_SetString(PyExc_MemoryError,   e.what()); return;
-                } catch (const std::domain_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;
-                } catch (const std::invalid_argument &e) { PyErr_SetString(PyExc_ValueError,    e.what()); return;
-                } catch (const std::length_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;
-                } catch (const std::out_of_range &e)     { PyErr_SetString(PyExc_IndexError,    e.what()); return;
-                } catch (const std::range_error &e)      { PyErr_SetString(PyExc_ValueError,    e.what()); return;
-                } catch (const std::exception &e)        { PyErr_SetString(PyExc_RuntimeError,  e.what()); return;
-                } catch (...) {
-                    PyErr_SetString(PyExc_RuntimeError, "Caught an unknown exception!");
-                    return;
-                }
-            }
-        );
-        internals_ptr->static_property_type = make_static_property_type();
-        internals_ptr->default_metaclass = make_default_metaclass();
-        internals_ptr->instance_base = make_object_base_type(internals_ptr->default_metaclass);
-    }
-    return *internals_ptr;
-}
-
-/// Works like `internals.registered_types_cpp`, but for module-local registered types:
-inline type_map<type_info *> &registered_local_types_cpp() {
-    static type_map<type_info *> locals{};
-    return locals;
-}
-
-/// Constructs a std::string with the given arguments, stores it in `internals`, and returns its
-/// `c_str()`.  Such strings objects have a long storage duration -- the internal strings are only
-/// cleared when the program exits or after interpreter shutdown (when embedding), and so are
-/// suitable for c-style strings needed by Python internals (such as PyTypeObject's tp_name).
-template <typename... Args>
-const char *c_str(Args &&...args) {
-    auto &strings = get_internals().static_strings;
-    strings.emplace_front(std::forward<Args>(args)...);
-    return strings.front().c_str();
-}
-
-NAMESPACE_END(detail)
-
-/// Returns a named pointer that is shared among all extension modules (using the same
-/// pybind11 version) running in the current interpreter. Names starting with underscores
-/// are reserved for internal usage. Returns `nullptr` if no matching entry was found.
-inline PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {
-    auto &internals = detail::get_internals();
-    auto it = internals.shared_data.find(name);
-    return it != internals.shared_data.end() ? it->second : nullptr;
-}
-
-/// Set the shared data that can be later recovered by `get_shared_data()`.
-inline PYBIND11_NOINLINE void *set_shared_data(const std::string &name, void *data) {
-    detail::get_internals().shared_data[name] = data;
-    return data;
-}
-
-/// Returns a typed reference to a shared data entry (by using `get_shared_data()`) if
-/// such entry exists. Otherwise, a new object of default-constructible type `T` is
-/// added to the shared data under the given name and a reference to it is returned.
-template<typename T>
-T &get_or_create_shared_data(const std::string &name) {
-    auto &internals = detail::get_internals();
-    auto it = internals.shared_data.find(name);
-    T *ptr = (T *) (it != internals.shared_data.end() ? it->second : nullptr);
-    if (!ptr) {
-        ptr = new T();
-        internals.shared_data[name] = ptr;
-    }
-    return *ptr;
-}
-
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/detail/typeid.h b/tmap/lib/pybind11/include/pybind11/detail/typeid.h
deleted file mode 100644
index 6f36aab..0000000
--- a/tmap/lib/pybind11/include/pybind11/detail/typeid.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
-    pybind11/detail/typeid.h: Compiler-independent access to type identifiers
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include <cstdio>
-#include <cstdlib>
-
-#if defined(__GNUG__)
-#include <cxxabi.h>
-#endif
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
-/// Erase all occurrences of a substring
-inline void erase_all(std::string &string, const std::string &search) {
-    for (size_t pos = 0;;) {
-        pos = string.find(search, pos);
-        if (pos == std::string::npos) break;
-        string.erase(pos, search.length());
-    }
-}
-
-PYBIND11_NOINLINE inline void clean_type_id(std::string &name) {
-#if defined(__GNUG__)
-    int status = 0;
-    std::unique_ptr<char, void (*)(void *)> res {
-        abi::__cxa_demangle(name.c_str(), nullptr, nullptr, &status), std::free };
-    if (status == 0)
-        name = res.get();
-#else
-    detail::erase_all(name, "class ");
-    detail::erase_all(name, "struct ");
-    detail::erase_all(name, "enum ");
-#endif
-    detail::erase_all(name, "pybind11::");
-}
-NAMESPACE_END(detail)
-
-/// Return a string representation of a C++ type
-template <typename T> static std::string type_id() {
-    std::string name(typeid(T).name());
-    detail::clean_type_id(name);
-    return name;
-}
-
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/eigen.h b/tmap/lib/pybind11/include/pybind11/eigen.h
deleted file mode 100644
index a702bf3..0000000
--- a/tmap/lib/pybind11/include/pybind11/eigen.h
+++ /dev/null
@@ -1,610 +0,0 @@
-/*
-    pybind11/eigen.h: Transparent conversion for dense and sparse Eigen matrices
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "numpy.h"
-
-#if defined(__INTEL_COMPILER)
-#  pragma warning(disable: 1682) // implicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem)
-#elif defined(__GNUG__) || defined(__clang__)
-#  pragma GCC diagnostic push
-#  pragma GCC diagnostic ignored "-Wconversion"
-#  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-#  if __GNUC__ >= 7
-#    pragma GCC diagnostic ignored "-Wint-in-bool-context"
-#  endif
-#endif
-
-#include <Eigen/Core>
-#include <Eigen/SparseCore>
-
-#if defined(_MSC_VER)
-#  pragma warning(push)
-#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#endif
-
-// Eigen prior to 3.2.7 doesn't have proper move constructors--but worse, some classes get implicit
-// move constructors that break things.  We could detect this an explicitly copy, but an extra copy
-// of matrices seems highly undesirable.
-static_assert(EIGEN_VERSION_AT_LEAST(3,2,7), "Eigen support in pybind11 requires Eigen >= 3.2.7");
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-
-// Provide a convenience alias for easier pass-by-ref usage with fully dynamic strides:
-using EigenDStride = Eigen::Stride<Eigen::Dynamic, Eigen::Dynamic>;
-template <typename MatrixType> using EigenDRef = Eigen::Ref<MatrixType, 0, EigenDStride>;
-template <typename MatrixType> using EigenDMap = Eigen::Map<MatrixType, 0, EigenDStride>;
-
-NAMESPACE_BEGIN(detail)
-
-#if EIGEN_VERSION_AT_LEAST(3,3,0)
-using EigenIndex = Eigen::Index;
-#else
-using EigenIndex = EIGEN_DEFAULT_DENSE_INDEX_TYPE;
-#endif
-
-// Matches Eigen::Map, Eigen::Ref, blocks, etc:
-template <typename T> using is_eigen_dense_map = all_of<is_template_base_of<Eigen::DenseBase, T>, std::is_base_of<Eigen::MapBase<T, Eigen::ReadOnlyAccessors>, T>>;
-template <typename T> using is_eigen_mutable_map = std::is_base_of<Eigen::MapBase<T, Eigen::WriteAccessors>, T>;
-template <typename T> using is_eigen_dense_plain = all_of<negation<is_eigen_dense_map<T>>, is_template_base_of<Eigen::PlainObjectBase, T>>;
-template <typename T> using is_eigen_sparse = is_template_base_of<Eigen::SparseMatrixBase, T>;
-// Test for objects inheriting from EigenBase<Derived> that aren't captured by the above.  This
-// basically covers anything that can be assigned to a dense matrix but that don't have a typical
-// matrix data layout that can be copied from their .data().  For example, DiagonalMatrix and
-// SelfAdjointView fall into this category.
-template <typename T> using is_eigen_other = all_of<
-    is_template_base_of<Eigen::EigenBase, T>,
-    negation<any_of<is_eigen_dense_map<T>, is_eigen_dense_plain<T>, is_eigen_sparse<T>>>
->;
-
-// Captures numpy/eigen conformability status (returned by EigenProps::conformable()):
-template <bool EigenRowMajor> struct EigenConformable {
-    bool conformable = false;
-    EigenIndex rows = 0, cols = 0;
-    EigenDStride stride{0, 0};      // Only valid if negativestrides is false!
-    bool negativestrides = false;   // If true, do not use stride!
-
-    EigenConformable(bool fits = false) : conformable{fits} {}
-    // Matrix type:
-    EigenConformable(EigenIndex r, EigenIndex c,
-            EigenIndex rstride, EigenIndex cstride) :
-        conformable{true}, rows{r}, cols{c} {
-        // TODO: when Eigen bug #747 is fixed, remove the tests for non-negativity. http://eigen.tuxfamily.org/bz/show_bug.cgi?id=747
-        if (rstride < 0 || cstride < 0) {
-            negativestrides = true;
-        } else {
-            stride = {EigenRowMajor ? rstride : cstride /* outer stride */,
-                      EigenRowMajor ? cstride : rstride /* inner stride */ };
-        }
-    }
-    // Vector type:
-    EigenConformable(EigenIndex r, EigenIndex c, EigenIndex stride)
-        : EigenConformable(r, c, r == 1 ? c*stride : stride, c == 1 ? r : r*stride) {}
-
-    template <typename props> bool stride_compatible() const {
-        // To have compatible strides, we need (on both dimensions) one of fully dynamic strides,
-        // matching strides, or a dimension size of 1 (in which case the stride value is irrelevant)
-        return
-            !negativestrides &&
-            (props::inner_stride == Eigen::Dynamic || props::inner_stride == stride.inner() ||
-                (EigenRowMajor ? cols : rows) == 1) &&
-            (props::outer_stride == Eigen::Dynamic || props::outer_stride == stride.outer() ||
-                (EigenRowMajor ? rows : cols) == 1);
-    }
-    operator bool() const { return conformable; }
-};
-
-template <typename Type> struct eigen_extract_stride { using type = Type; };
-template <typename PlainObjectType, int MapOptions, typename StrideType>
-struct eigen_extract_stride<Eigen::Map<PlainObjectType, MapOptions, StrideType>> { using type = StrideType; };
-template <typename PlainObjectType, int Options, typename StrideType>
-struct eigen_extract_stride<Eigen::Ref<PlainObjectType, Options, StrideType>> { using type = StrideType; };
-
-// Helper struct for extracting information from an Eigen type
-template <typename Type_> struct EigenProps {
-    using Type = Type_;
-    using Scalar = typename Type::Scalar;
-    using StrideType = typename eigen_extract_stride<Type>::type;
-    static constexpr EigenIndex
-        rows = Type::RowsAtCompileTime,
-        cols = Type::ColsAtCompileTime,
-        size = Type::SizeAtCompileTime;
-    static constexpr bool
-        row_major = Type::IsRowMajor,
-        vector = Type::IsVectorAtCompileTime, // At least one dimension has fixed size 1
-        fixed_rows = rows != Eigen::Dynamic,
-        fixed_cols = cols != Eigen::Dynamic,
-        fixed = size != Eigen::Dynamic, // Fully-fixed size
-        dynamic = !fixed_rows && !fixed_cols; // Fully-dynamic size
-
-    template <EigenIndex i, EigenIndex ifzero> using if_zero = std::integral_constant<EigenIndex, i == 0 ? ifzero : i>;
-    static constexpr EigenIndex inner_stride = if_zero<StrideType::InnerStrideAtCompileTime, 1>::value,
-                                outer_stride = if_zero<StrideType::OuterStrideAtCompileTime,
-                                                       vector ? size : row_major ? cols : rows>::value;
-    static constexpr bool dynamic_stride = inner_stride == Eigen::Dynamic && outer_stride == Eigen::Dynamic;
-    static constexpr bool requires_row_major = !dynamic_stride && !vector && (row_major ? inner_stride : outer_stride) == 1;
-    static constexpr bool requires_col_major = !dynamic_stride && !vector && (row_major ? outer_stride : inner_stride) == 1;
-
-    // Takes an input array and determines whether we can make it fit into the Eigen type.  If
-    // the array is a vector, we attempt to fit it into either an Eigen 1xN or Nx1 vector
-    // (preferring the latter if it will fit in either, i.e. for a fully dynamic matrix type).
-    static EigenConformable<row_major> conformable(const array &a) {
-        const auto dims = a.ndim();
-        if (dims < 1 || dims > 2)
-            return false;
-
-        if (dims == 2) { // Matrix type: require exact match (or dynamic)
-
-            EigenIndex
-                np_rows = a.shape(0),
-                np_cols = a.shape(1),
-                np_rstride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar)),
-                np_cstride = a.strides(1) / static_cast<ssize_t>(sizeof(Scalar));
-            if ((fixed_rows && np_rows != rows) || (fixed_cols && np_cols != cols))
-                return false;
-
-            return {np_rows, np_cols, np_rstride, np_cstride};
-        }
-
-        // Otherwise we're storing an n-vector.  Only one of the strides will be used, but whichever
-        // is used, we want the (single) numpy stride value.
-        const EigenIndex n = a.shape(0),
-              stride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar));
-
-        if (vector) { // Eigen type is a compile-time vector
-            if (fixed && size != n)
-                return false; // Vector size mismatch
-            return {rows == 1 ? 1 : n, cols == 1 ? 1 : n, stride};
-        }
-        else if (fixed) {
-            // The type has a fixed size, but is not a vector: abort
-            return false;
-        }
-        else if (fixed_cols) {
-            // Since this isn't a vector, cols must be != 1.  We allow this only if it exactly
-            // equals the number of elements (rows is Dynamic, and so 1 row is allowed).
-            if (cols != n) return false;
-            return {1, n, stride};
-        }
-        else {
-            // Otherwise it's either fully dynamic, or column dynamic; both become a column vector
-            if (fixed_rows && rows != n) return false;
-            return {n, 1, stride};
-        }
-    }
-
-    static PYBIND11_DESCR descriptor() {
-        constexpr bool show_writeable = is_eigen_dense_map<Type>::value && is_eigen_mutable_map<Type>::value;
-        constexpr bool show_order = is_eigen_dense_map<Type>::value;
-        constexpr bool show_c_contiguous = show_order && requires_row_major;
-        constexpr bool show_f_contiguous = !show_c_contiguous && show_order && requires_col_major;
-
-        return type_descr(_("numpy.ndarray[") + npy_format_descriptor<Scalar>::name() +
-            _("[")  + _<fixed_rows>(_<(size_t) rows>(), _("m")) +
-            _(", ") + _<fixed_cols>(_<(size_t) cols>(), _("n")) +
-            _("]") +
-            // For a reference type (e.g. Ref<MatrixXd>) we have other constraints that might need to be
-            // satisfied: writeable=True (for a mutable reference), and, depending on the map's stride
-            // options, possibly f_contiguous or c_contiguous.  We include them in the descriptor output
-            // to provide some hint as to why a TypeError is occurring (otherwise it can be confusing to
-            // see that a function accepts a 'numpy.ndarray[float64[3,2]]' and an error message that you
-            // *gave* a numpy.ndarray of the right type and dimensions.
-            _<show_writeable>(", flags.writeable", "") +
-            _<show_c_contiguous>(", flags.c_contiguous", "") +
-            _<show_f_contiguous>(", flags.f_contiguous", "") +
-            _("]")
-        );
-    }
-};
-
-// Casts an Eigen type to numpy array.  If given a base, the numpy array references the src data,
-// otherwise it'll make a copy.  writeable lets you turn off the writeable flag for the array.
-template <typename props> handle eigen_array_cast(typename props::Type const &src, handle base = handle(), bool writeable = true) {
-    constexpr ssize_t elem_size = sizeof(typename props::Scalar);
-    array a;
-    if (props::vector)
-        a = array({ src.size() }, { elem_size * src.innerStride() }, src.data(), base);
-    else
-        a = array({ src.rows(), src.cols() }, { elem_size * src.rowStride(), elem_size * src.colStride() },
-                  src.data(), base);
-
-    if (!writeable)
-        array_proxy(a.ptr())->flags &= ~detail::npy_api::NPY_ARRAY_WRITEABLE_;
-
-    return a.release();
-}
-
-// Takes an lvalue ref to some Eigen type and a (python) base object, creating a numpy array that
-// reference the Eigen object's data with `base` as the python-registered base class (if omitted,
-// the base will be set to None, and lifetime management is up to the caller).  The numpy array is
-// non-writeable if the given type is const.
-template <typename props, typename Type>
-handle eigen_ref_array(Type &src, handle parent = none()) {
-    // none here is to get past array's should-we-copy detection, which currently always
-    // copies when there is no base.  Setting the base to None should be harmless.
-    return eigen_array_cast<props>(src, parent, !std::is_const<Type>::value);
-}
-
-// Takes a pointer to some dense, plain Eigen type, builds a capsule around it, then returns a numpy
-// array that references the encapsulated data with a python-side reference to the capsule to tie
-// its destruction to that of any dependent python objects.  Const-ness is determined by whether or
-// not the Type of the pointer given is const.
-template <typename props, typename Type, typename = enable_if_t<is_eigen_dense_plain<Type>::value>>
-handle eigen_encapsulate(Type *src) {
-    capsule base(src, [](void *o) { delete static_cast<Type *>(o); });
-    return eigen_ref_array<props>(*src, base);
-}
-
-// Type caster for regular, dense matrix types (e.g. MatrixXd), but not maps/refs/etc. of dense
-// types.
-template<typename Type>
-struct type_caster<Type, enable_if_t<is_eigen_dense_plain<Type>::value>> {
-    using Scalar = typename Type::Scalar;
-    using props = EigenProps<Type>;
-
-    bool load(handle src, bool convert) {
-        // If we're in no-convert mode, only load if given an array of the correct type
-        if (!convert && !isinstance<array_t<Scalar>>(src))
-            return false;
-
-        // Coerce into an array, but don't do type conversion yet; the copy below handles it.
-        auto buf = array::ensure(src);
-
-        if (!buf)
-            return false;
-
-        auto dims = buf.ndim();
-        if (dims < 1 || dims > 2)
-            return false;
-
-        auto fits = props::conformable(buf);
-        if (!fits)
-            return false;
-
-        // Allocate the new type, then build a numpy reference into it
-        value = Type(fits.rows, fits.cols);
-        auto ref = reinterpret_steal<array>(eigen_ref_array<props>(value));
-        if (dims == 1) ref = ref.squeeze();
-
-        int result = detail::npy_api::get().PyArray_CopyInto_(ref.ptr(), buf.ptr());
-
-        if (result < 0) { // Copy failed!
-            PyErr_Clear();
-            return false;
-        }
-
-        return true;
-    }
-
-private:
-
-    // Cast implementation
-    template <typename CType>
-    static handle cast_impl(CType *src, return_value_policy policy, handle parent) {
-        switch (policy) {
-            case return_value_policy::take_ownership:
-            case return_value_policy::automatic:
-                return eigen_encapsulate<props>(src);
-            case return_value_policy::move:
-                return eigen_encapsulate<props>(new CType(std::move(*src)));
-            case return_value_policy::copy:
-                return eigen_array_cast<props>(*src);
-            case return_value_policy::reference:
-            case return_value_policy::automatic_reference:
-                return eigen_ref_array<props>(*src);
-            case return_value_policy::reference_internal:
-                return eigen_ref_array<props>(*src, parent);
-            default:
-                throw cast_error("unhandled return_value_policy: should not happen!");
-        };
-    }
-
-public:
-
-    // Normal returned non-reference, non-const value:
-    static handle cast(Type &&src, return_value_policy /* policy */, handle parent) {
-        return cast_impl(&src, return_value_policy::move, parent);
-    }
-    // If you return a non-reference const, we mark the numpy array readonly:
-    static handle cast(const Type &&src, return_value_policy /* policy */, handle parent) {
-        return cast_impl(&src, return_value_policy::move, parent);
-    }
-    // lvalue reference return; default (automatic) becomes copy
-    static handle cast(Type &src, return_value_policy policy, handle parent) {
-        if (policy == return_value_policy::automatic || policy == return_value_policy::automatic_reference)
-            policy = return_value_policy::copy;
-        return cast_impl(&src, policy, parent);
-    }
-    // const lvalue reference return; default (automatic) becomes copy
-    static handle cast(const Type &src, return_value_policy policy, handle parent) {
-        if (policy == return_value_policy::automatic || policy == return_value_policy::automatic_reference)
-            policy = return_value_policy::copy;
-        return cast(&src, policy, parent);
-    }
-    // non-const pointer return
-    static handle cast(Type *src, return_value_policy policy, handle parent) {
-        return cast_impl(src, policy, parent);
-    }
-    // const pointer return
-    static handle cast(const Type *src, return_value_policy policy, handle parent) {
-        return cast_impl(src, policy, parent);
-    }
-
-    static PYBIND11_DESCR name() { return props::descriptor(); }
-
-    operator Type*() { return &value; }
-    operator Type&() { return value; }
-    operator Type&&() && { return std::move(value); }
-    template <typename T> using cast_op_type = movable_cast_op_type<T>;
-
-private:
-    Type value;
-};
-
-// Eigen Ref/Map classes have slightly different policy requirements, meaning we don't want to force
-// `move` when a Ref/Map rvalue is returned; we treat Ref<> sort of like a pointer (we care about
-// the underlying data, not the outer shell).
-template <typename Return>
-struct return_value_policy_override<Return, enable_if_t<is_eigen_dense_map<Return>::value>> {
-    static return_value_policy policy(return_value_policy p) { return p; }
-};
-
-// Base class for casting reference/map/block/etc. objects back to python.
-template <typename MapType> struct eigen_map_caster {
-private:
-    using props = EigenProps<MapType>;
-
-public:
-
-    // Directly referencing a ref/map's data is a bit dangerous (whatever the map/ref points to has
-    // to stay around), but we'll allow it under the assumption that you know what you're doing (and
-    // have an appropriate keep_alive in place).  We return a numpy array pointing directly at the
-    // ref's data (The numpy array ends up read-only if the ref was to a const matrix type.) Note
-    // that this means you need to ensure you don't destroy the object in some other way (e.g. with
-    // an appropriate keep_alive, or with a reference to a statically allocated matrix).
-    static handle cast(const MapType &src, return_value_policy policy, handle parent) {
-        switch (policy) {
-            case return_value_policy::copy:
-                return eigen_array_cast<props>(src);
-            case return_value_policy::reference_internal:
-                return eigen_array_cast<props>(src, parent, is_eigen_mutable_map<MapType>::value);
-            case return_value_policy::reference:
-            case return_value_policy::automatic:
-            case return_value_policy::automatic_reference:
-                return eigen_array_cast<props>(src, none(), is_eigen_mutable_map<MapType>::value);
-            default:
-                // move, take_ownership don't make any sense for a ref/map:
-                pybind11_fail("Invalid return_value_policy for Eigen Map/Ref/Block type");
-        }
-    }
-
-    static PYBIND11_DESCR name() { return props::descriptor(); }
-
-    // Explicitly delete these: support python -> C++ conversion on these (i.e. these can be return
-    // types but not bound arguments).  We still provide them (with an explicitly delete) so that
-    // you end up here if you try anyway.
-    bool load(handle, bool) = delete;
-    operator MapType() = delete;
-    template <typename> using cast_op_type = MapType;
-};
-
-// We can return any map-like object (but can only load Refs, specialized next):
-template <typename Type> struct type_caster<Type, enable_if_t<is_eigen_dense_map<Type>::value>>
-    : eigen_map_caster<Type> {};
-
-// Loader for Ref<...> arguments.  See the documentation for info on how to make this work without
-// copying (it requires some extra effort in many cases).
-template <typename PlainObjectType, typename StrideType>
-struct type_caster<
-    Eigen::Ref<PlainObjectType, 0, StrideType>,
-    enable_if_t<is_eigen_dense_map<Eigen::Ref<PlainObjectType, 0, StrideType>>::value>
-> : public eigen_map_caster<Eigen::Ref<PlainObjectType, 0, StrideType>> {
-private:
-    using Type = Eigen::Ref<PlainObjectType, 0, StrideType>;
-    using props = EigenProps<Type>;
-    using Scalar = typename props::Scalar;
-    using MapType = Eigen::Map<PlainObjectType, 0, StrideType>;
-    using Array = array_t<Scalar, array::forcecast |
-                ((props::row_major ? props::inner_stride : props::outer_stride) == 1 ? array::c_style :
-                 (props::row_major ? props::outer_stride : props::inner_stride) == 1 ? array::f_style : 0)>;
-    static constexpr bool need_writeable = is_eigen_mutable_map<Type>::value;
-    // Delay construction (these have no default constructor)
-    std::unique_ptr<MapType> map;
-    std::unique_ptr<Type> ref;
-    // Our array.  When possible, this is just a numpy array pointing to the source data, but
-    // sometimes we can't avoid copying (e.g. input is not a numpy array at all, has an incompatible
-    // layout, or is an array of a type that needs to be converted).  Using a numpy temporary
-    // (rather than an Eigen temporary) saves an extra copy when we need both type conversion and
-    // storage order conversion.  (Note that we refuse to use this temporary copy when loading an
-    // argument for a Ref<M> with M non-const, i.e. a read-write reference).
-    Array copy_or_ref;
-public:
-    bool load(handle src, bool convert) {
-        // First check whether what we have is already an array of the right type.  If not, we can't
-        // avoid a copy (because the copy is also going to do type conversion).
-        bool need_copy = !isinstance<Array>(src);
-
-        EigenConformable<props::row_major> fits;
-        if (!need_copy) {
-            // We don't need a converting copy, but we also need to check whether the strides are
-            // compatible with the Ref's stride requirements
-            Array aref = reinterpret_borrow<Array>(src);
-
-            if (aref && (!need_writeable || aref.writeable())) {
-                fits = props::conformable(aref);
-                if (!fits) return false; // Incompatible dimensions
-                if (!fits.template stride_compatible<props>())
-                    need_copy = true;
-                else
-                    copy_or_ref = std::move(aref);
-            }
-            else {
-                need_copy = true;
-            }
-        }
-
-        if (need_copy) {
-            // We need to copy: If we need a mutable reference, or we're not supposed to convert
-            // (either because we're in the no-convert overload pass, or because we're explicitly
-            // instructed not to copy (via `py::arg().noconvert()`) we have to fail loading.
-            if (!convert || need_writeable) return false;
-
-            Array copy = Array::ensure(src);
-            if (!copy) return false;
-            fits = props::conformable(copy);
-            if (!fits || !fits.template stride_compatible<props>())
-                return false;
-            copy_or_ref = std::move(copy);
-            loader_life_support::add_patient(copy_or_ref);
-        }
-
-        ref.reset();
-        map.reset(new MapType(data(copy_or_ref), fits.rows, fits.cols, make_stride(fits.stride.outer(), fits.stride.inner())));
-        ref.reset(new Type(*map));
-
-        return true;
-    }
-
-    operator Type*() { return ref.get(); }
-    operator Type&() { return *ref; }
-    template <typename _T> using cast_op_type = pybind11::detail::cast_op_type<_T>;
-
-private:
-    template <typename T = Type, enable_if_t<is_eigen_mutable_map<T>::value, int> = 0>
-    Scalar *data(Array &a) { return a.mutable_data(); }
-
-    template <typename T = Type, enable_if_t<!is_eigen_mutable_map<T>::value, int> = 0>
-    const Scalar *data(Array &a) { return a.data(); }
-
-    // Attempt to figure out a constructor of `Stride` that will work.
-    // If both strides are fixed, use a default constructor:
-    template <typename S> using stride_ctor_default = bool_constant<
-        S::InnerStrideAtCompileTime != Eigen::Dynamic && S::OuterStrideAtCompileTime != Eigen::Dynamic &&
-        std::is_default_constructible<S>::value>;
-    // Otherwise, if there is a two-index constructor, assume it is (outer,inner) like
-    // Eigen::Stride, and use it:
-    template <typename S> using stride_ctor_dual = bool_constant<
-        !stride_ctor_default<S>::value && std::is_constructible<S, EigenIndex, EigenIndex>::value>;
-    // Otherwise, if there is a one-index constructor, and just one of the strides is dynamic, use
-    // it (passing whichever stride is dynamic).
-    template <typename S> using stride_ctor_outer = bool_constant<
-        !any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value &&
-        S::OuterStrideAtCompileTime == Eigen::Dynamic && S::InnerStrideAtCompileTime != Eigen::Dynamic &&
-        std::is_constructible<S, EigenIndex>::value>;
-    template <typename S> using stride_ctor_inner = bool_constant<
-        !any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value &&
-        S::InnerStrideAtCompileTime == Eigen::Dynamic && S::OuterStrideAtCompileTime != Eigen::Dynamic &&
-        std::is_constructible<S, EigenIndex>::value>;
-
-    template <typename S = StrideType, enable_if_t<stride_ctor_default<S>::value, int> = 0>
-    static S make_stride(EigenIndex, EigenIndex) { return S(); }
-    template <typename S = StrideType, enable_if_t<stride_ctor_dual<S>::value, int> = 0>
-    static S make_stride(EigenIndex outer, EigenIndex inner) { return S(outer, inner); }
-    template <typename S = StrideType, enable_if_t<stride_ctor_outer<S>::value, int> = 0>
-    static S make_stride(EigenIndex outer, EigenIndex) { return S(outer); }
-    template <typename S = StrideType, enable_if_t<stride_ctor_inner<S>::value, int> = 0>
-    static S make_stride(EigenIndex, EigenIndex inner) { return S(inner); }
-
-};
-
-// type_caster for special matrix types (e.g. DiagonalMatrix), which are EigenBase, but not
-// EigenDense (i.e. they don't have a data(), at least not with the usual matrix layout).
-// load() is not supported, but we can cast them into the python domain by first copying to a
-// regular Eigen::Matrix, then casting that.
-template <typename Type>
-struct type_caster<Type, enable_if_t<is_eigen_other<Type>::value>> {
-protected:
-    using Matrix = Eigen::Matrix<typename Type::Scalar, Type::RowsAtCompileTime, Type::ColsAtCompileTime>;
-    using props = EigenProps<Matrix>;
-public:
-    static handle cast(const Type &src, return_value_policy /* policy */, handle /* parent */) {
-        handle h = eigen_encapsulate<props>(new Matrix(src));
-        return h;
-    }
-    static handle cast(const Type *src, return_value_policy policy, handle parent) { return cast(*src, policy, parent); }
-
-    static PYBIND11_DESCR name() { return props::descriptor(); }
-
-    // Explicitly delete these: support python -> C++ conversion on these (i.e. these can be return
-    // types but not bound arguments).  We still provide them (with an explicitly delete) so that
-    // you end up here if you try anyway.
-    bool load(handle, bool) = delete;
-    operator Type() = delete;
-    template <typename> using cast_op_type = Type;
-};
-
-template<typename Type>
-struct type_caster<Type, enable_if_t<is_eigen_sparse<Type>::value>> {
-    typedef typename Type::Scalar Scalar;
-    typedef remove_reference_t<decltype(*std::declval<Type>().outerIndexPtr())> StorageIndex;
-    typedef typename Type::Index Index;
-    static constexpr bool rowMajor = Type::IsRowMajor;
-
-    bool load(handle src, bool) {
-        if (!src)
-            return false;
-
-        auto obj = reinterpret_borrow<object>(src);
-        object sparse_module = module::import("scipy.sparse");
-        object matrix_type = sparse_module.attr(
-            rowMajor ? "csr_matrix" : "csc_matrix");
-
-        if (!obj.get_type().is(matrix_type)) {
-            try {
-                obj = matrix_type(obj);
-            } catch (const error_already_set &) {
-                return false;
-            }
-        }
-
-        auto values = array_t<Scalar>((object) obj.attr("data"));
-        auto innerIndices = array_t<StorageIndex>((object) obj.attr("indices"));
-        auto outerIndices = array_t<StorageIndex>((object) obj.attr("indptr"));
-        auto shape = pybind11::tuple((pybind11::object) obj.attr("shape"));
-        auto nnz = obj.attr("nnz").cast<Index>();
-
-        if (!values || !innerIndices || !outerIndices)
-            return false;
-
-        value = Eigen::MappedSparseMatrix<Scalar, Type::Flags, StorageIndex>(
-            shape[0].cast<Index>(), shape[1].cast<Index>(), nnz,
-            outerIndices.mutable_data(), innerIndices.mutable_data(), values.mutable_data());
-
-        return true;
-    }
-
-    static handle cast(const Type &src, return_value_policy /* policy */, handle /* parent */) {
-        const_cast<Type&>(src).makeCompressed();
-
-        object matrix_type = module::import("scipy.sparse").attr(
-            rowMajor ? "csr_matrix" : "csc_matrix");
-
-        array data(src.nonZeros(), src.valuePtr());
-        array outerIndices((rowMajor ? src.rows() : src.cols()) + 1, src.outerIndexPtr());
-        array innerIndices(src.nonZeros(), src.innerIndexPtr());
-
-        return matrix_type(
-            std::make_tuple(data, innerIndices, outerIndices),
-            std::make_pair(src.rows(), src.cols())
-        ).release();
-    }
-
-    PYBIND11_TYPE_CASTER(Type, _<(Type::IsRowMajor) != 0>("scipy.sparse.csr_matrix[", "scipy.sparse.csc_matrix[")
-            + npy_format_descriptor<Scalar>::name() + _("]"));
-};
-
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
-
-#if defined(__GNUG__) || defined(__clang__)
-#  pragma GCC diagnostic pop
-#elif defined(_MSC_VER)
-#  pragma warning(pop)
-#endif
diff --git a/tmap/lib/pybind11/include/pybind11/embed.h b/tmap/lib/pybind11/include/pybind11/embed.h
deleted file mode 100644
index 79ad020..0000000
--- a/tmap/lib/pybind11/include/pybind11/embed.h
+++ /dev/null
@@ -1,193 +0,0 @@
-/*
-    pybind11/embed.h: Support for embedding the interpreter
-
-    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "pybind11.h"
-#include "eval.h"
-
-#if defined(PYPY_VERSION)
-#  error Embedding the interpreter is not supported with PyPy
-#endif
-
-#if PY_MAJOR_VERSION >= 3
-#  define PYBIND11_EMBEDDED_MODULE_IMPL(name)            \
-      extern "C" PyObject *pybind11_init_impl_##name() { \
-          return pybind11_init_wrapper_##name();         \
-      }
-#else
-#  define PYBIND11_EMBEDDED_MODULE_IMPL(name)            \
-      extern "C" void pybind11_init_impl_##name() {      \
-          pybind11_init_wrapper_##name();                \
-      }
-#endif
-
-/** \rst
-    Add a new module to the table of builtins for the interpreter. Must be
-    defined in global scope. The first macro parameter is the name of the
-    module (without quotes). The second parameter is the variable which will
-    be used as the interface to add functions and classes to the module.
-
-    .. code-block:: cpp
-
-        PYBIND11_EMBEDDED_MODULE(example, m) {
-            // ... initialize functions and classes here
-            m.def("foo", []() {
-                return "Hello, World!";
-            });
-        }
- \endrst */
-#define PYBIND11_EMBEDDED_MODULE(name, variable)                              \
-    static void pybind11_init_##name(pybind11::module &);                     \
-    static PyObject *pybind11_init_wrapper_##name() {                         \
-        auto m = pybind11::module(#name);                                     \
-        try {                                                                 \
-            pybind11_init_##name(m);                                          \
-            return m.ptr();                                                   \
-        } catch (pybind11::error_already_set &e) {                            \
-            PyErr_SetString(PyExc_ImportError, e.what());                     \
-            return nullptr;                                                   \
-        } catch (const std::exception &e) {                                   \
-            PyErr_SetString(PyExc_ImportError, e.what());                     \
-            return nullptr;                                                   \
-        }                                                                     \
-    }                                                                         \
-    PYBIND11_EMBEDDED_MODULE_IMPL(name)                                       \
-    pybind11::detail::embedded_module name(#name, pybind11_init_impl_##name); \
-    void pybind11_init_##name(pybind11::module &variable)
-
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
-
-/// Python 2.7/3.x compatible version of `PyImport_AppendInittab` and error checks.
-struct embedded_module {
-#if PY_MAJOR_VERSION >= 3
-    using init_t = PyObject *(*)();
-#else
-    using init_t = void (*)();
-#endif
-    embedded_module(const char *name, init_t init) {
-        if (Py_IsInitialized())
-            pybind11_fail("Can't add new modules after the interpreter has been initialized");
-
-        auto result = PyImport_AppendInittab(name, init);
-        if (result == -1)
-            pybind11_fail("Insufficient memory to add a new module");
-    }
-};
-
-NAMESPACE_END(detail)
-
-/** \rst
-    Initialize the Python interpreter. No other pybind11 or CPython API functions can be
-    called before this is done; with the exception of `PYBIND11_EMBEDDED_MODULE`. The
-    optional parameter can be used to skip the registration of signal handlers (see the
-    Python documentation for details). Calling this function again after the interpreter
-    has already been initialized is a fatal error.
- \endrst */
-inline void initialize_interpreter(bool init_signal_handlers = true) {
-    if (Py_IsInitialized())
-        pybind11_fail("The interpreter is already running");
-
-    Py_InitializeEx(init_signal_handlers ? 1 : 0);
-
-    // Make .py files in the working directory available by default
-    module::import("sys").attr("path").cast<list>().append(".");
-}
-
-/** \rst
-    Shut down the Python interpreter. No pybind11 or CPython API functions can be called
-    after this. In addition, pybind11 objects must not outlive the interpreter:
-
-    .. code-block:: cpp
-
-        { // BAD
-            py::initialize_interpreter();
-            auto hello = py::str("Hello, World!");
-            py::finalize_interpreter();
-        } // <-- BOOM, hello's destructor is called after interpreter shutdown
-
-        { // GOOD
-            py::initialize_interpreter();
-            { // scoped
-                auto hello = py::str("Hello, World!");
-            } // <-- OK, hello is cleaned up properly
-            py::finalize_interpreter();
-        }
-
-        { // BETTER
-            py::scoped_interpreter guard{};
-            auto hello = py::str("Hello, World!");
-        }
-
-    .. warning::
-
-        The interpreter can be restarted by calling `initialize_interpreter` again.
-        Modules created using pybind11 can be safely re-initialized. However, Python
-        itself cannot completely unload binary extension modules and there are several
-        caveats with regard to interpreter restarting. All the details can be found
-        in the CPython documentation. In short, not all interpreter memory may be
-        freed, either due to reference cycles or user-created global data.
-
- \endrst */
-inline void finalize_interpreter() {
-    handle builtins(PyEval_GetBuiltins());
-    const char *id = PYBIND11_INTERNALS_ID;
-
-    // Get the internals pointer (without creating it if it doesn't exist).  It's possible for the
-    // internals to be created during Py_Finalize() (e.g. if a py::capsule calls `get_internals()`
-    // during destruction), so we get the pointer-pointer here and check it after Py_Finalize().
-    detail::internals **internals_ptr_ptr = &detail::get_internals_ptr();
-    // It could also be stashed in builtins, so look there too:
-    if (builtins.contains(id) && isinstance<capsule>(builtins[id]))
-        internals_ptr_ptr = capsule(builtins[id]);
-
-    Py_Finalize();
-
-    if (internals_ptr_ptr) {
-        delete *internals_ptr_ptr;
-        *internals_ptr_ptr = nullptr;
-    }
-}
-
-/** \rst
-    Scope guard version of `initialize_interpreter` and `finalize_interpreter`.
-    This a move-only guard and only a single instance can exist.
-
-    .. code-block:: cpp
-
-        #include <pybind11/embed.h>
-
-        int main() {
-            py::scoped_interpreter guard{};
-            py::print(Hello, World!);
-        } // <-- interpreter shutdown
- \endrst */
-class scoped_interpreter {
-public:
-    scoped_interpreter(bool init_signal_handlers = true) {
-        initialize_interpreter(init_signal_handlers);
-    }
-
-    scoped_interpreter(const scoped_interpreter &) = delete;
-    scoped_interpreter(scoped_interpreter &&other) noexcept { other.is_valid = false; }
-    scoped_interpreter &operator=(const scoped_interpreter &) = delete;
-    scoped_interpreter &operator=(scoped_interpreter &&) = delete;
-
-    ~scoped_interpreter() {
-        if (is_valid)
-            finalize_interpreter();
-    }
-
-private:
-    bool is_valid = true;
-};
-
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/eval.h b/tmap/lib/pybind11/include/pybind11/eval.h
deleted file mode 100644
index ea85ba1..0000000
--- a/tmap/lib/pybind11/include/pybind11/eval.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
-    pybind11/exec.h: Support for evaluating Python expressions and statements
-    from strings and files
-
-    Copyright (c) 2016 Klemens Morgenstern <klemens.morgenstern@ed-chemnitz.de> and
-                       Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "pybind11.h"
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-
-enum eval_mode {
-    /// Evaluate a string containing an isolated expression
-    eval_expr,
-
-    /// Evaluate a string containing a single statement. Returns \c none
-    eval_single_statement,
-
-    /// Evaluate a string containing a sequence of statement. Returns \c none
-    eval_statements
-};
-
-template <eval_mode mode = eval_expr>
-object eval(str expr, object global = globals(), object local = object()) {
-    if (!local)
-        local = global;
-
-    /* PyRun_String does not accept a PyObject / encoding specifier,
-       this seems to be the only alternative */
-    std::string buffer = "# -*- coding: utf-8 -*-\n" + (std::string) expr;
-
-    int start;
-    switch (mode) {
-        case eval_expr:             start = Py_eval_input;   break;
-        case eval_single_statement: start = Py_single_input; break;
-        case eval_statements:       start = Py_file_input;   break;
-        default: pybind11_fail("invalid evaluation mode");
-    }
-
-    PyObject *result = PyRun_String(buffer.c_str(), start, global.ptr(), local.ptr());
-    if (!result)
-        throw error_already_set();
-    return reinterpret_steal<object>(result);
-}
-
-template <eval_mode mode = eval_expr, size_t N>
-object eval(const char (&s)[N], object global = globals(), object local = object()) {
-    /* Support raw string literals by removing common leading whitespace */
-    auto expr = (s[0] == '\n') ? str(module::import("textwrap").attr("dedent")(s))
-                               : str(s);
-    return eval<mode>(expr, global, local);
-}
-
-inline void exec(str expr, object global = globals(), object local = object()) {
-    eval<eval_statements>(expr, global, local);
-}
-
-template <size_t N>
-void exec(const char (&s)[N], object global = globals(), object local = object()) {
-    eval<eval_statements>(s, global, local);
-}
-
-template <eval_mode mode = eval_statements>
-object eval_file(str fname, object global = globals(), object local = object()) {
-    if (!local)
-        local = global;
-
-    int start;
-    switch (mode) {
-        case eval_expr:             start = Py_eval_input;   break;
-        case eval_single_statement: start = Py_single_input; break;
-        case eval_statements:       start = Py_file_input;   break;
-        default: pybind11_fail("invalid evaluation mode");
-    }
-
-    int closeFile = 1;
-    std::string fname_str = (std::string) fname;
-#if PY_VERSION_HEX >= 0x03040000
-    FILE *f = _Py_fopen_obj(fname.ptr(), "r");
-#elif PY_VERSION_HEX >= 0x03000000
-    FILE *f = _Py_fopen(fname.ptr(), "r");
-#else
-    /* No unicode support in open() :( */
-    auto fobj = reinterpret_steal<object>(PyFile_FromString(
-        const_cast<char *>(fname_str.c_str()),
-        const_cast<char*>("r")));
-    FILE *f = nullptr;
-    if (fobj)
-        f = PyFile_AsFile(fobj.ptr());
-    closeFile = 0;
-#endif
-    if (!f) {
-        PyErr_Clear();
-        pybind11_fail("File \"" + fname_str + "\" could not be opened!");
-    }
-
-#if PY_VERSION_HEX < 0x03000000 && defined(PYPY_VERSION)
-    PyObject *result = PyRun_File(f, fname_str.c_str(), start, global.ptr(),
-                                  local.ptr());
-    (void) closeFile;
-#else
-    PyObject *result = PyRun_FileEx(f, fname_str.c_str(), start, global.ptr(),
-                                    local.ptr(), closeFile);
-#endif
-
-    if (!result)
-        throw error_already_set();
-    return reinterpret_steal<object>(result);
-}
-
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/functional.h b/tmap/lib/pybind11/include/pybind11/functional.h
deleted file mode 100644
index eda14ba..0000000
--- a/tmap/lib/pybind11/include/pybind11/functional.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
-    pybind11/functional.h: std::function<> support
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "pybind11.h"
-#include <functional>
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
-
-template <typename Return, typename... Args>
-struct type_caster<std::function<Return(Args...)>> {
-    using type = std::function<Return(Args...)>;
-    using retval_type = conditional_t<std::is_same<Return, void>::value, void_type, Return>;
-    using function_type = Return (*) (Args...);
-
-public:
-    bool load(handle src, bool convert) {
-        if (src.is_none()) {
-            // Defer accepting None to other overloads (if we aren't in convert mode):
-            if (!convert) return false;
-            return true;
-        }
-
-        if (!isinstance<function>(src))
-            return false;
-
-        auto func = reinterpret_borrow<function>(src);
-
-        /*
-           When passing a C++ function as an argument to another C++
-           function via Python, every function call would normally involve
-           a full C++ -> Python -> C++ roundtrip, which can be prohibitive.
-           Here, we try to at least detect the case where the function is
-           stateless (i.e. function pointer or lambda function without
-           captured variables), in which case the roundtrip can be avoided.
-         */
-        if (auto cfunc = func.cpp_function()) {
-            auto c = reinterpret_borrow<capsule>(PyCFunction_GET_SELF(cfunc.ptr()));
-            auto rec = (function_record *) c;
-
-            if (rec && rec->is_stateless &&
-                    same_type(typeid(function_type), *reinterpret_cast<const std::type_info *>(rec->data[1]))) {
-                struct capture { function_type f; };
-                value = ((capture *) &rec->data)->f;
-                return true;
-            }
-        }
-
-        value = [func](Args... args) -> Return {
-            gil_scoped_acquire acq;
-            object retval(func(std::forward<Args>(args)...));
-            /* Visual studio 2015 parser issue: need parentheses around this expression */
-            return (retval.template cast<Return>());
-        };
-        return true;
-    }
-
-    template <typename Func>
-    static handle cast(Func &&f_, return_value_policy policy, handle /* parent */) {
-        if (!f_)
-            return none().inc_ref();
-
-        auto result = f_.template target<function_type>();
-        if (result)
-            return cpp_function(*result, policy).release();
-        else
-            return cpp_function(std::forward<Func>(f_), policy).release();
-    }
-
-    PYBIND11_TYPE_CASTER(type, _("Callable[[") +
-            argument_loader<Args...>::arg_names() + _("], ") +
-            make_caster<retval_type>::name() +
-            _("]"));
-};
-
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/iostream.h b/tmap/lib/pybind11/include/pybind11/iostream.h
deleted file mode 100644
index a9c27aa..0000000
--- a/tmap/lib/pybind11/include/pybind11/iostream.h
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
-    pybind11/iostream.h -- Tools to assist with redirecting cout and cerr to Python
-
-    Copyright (c) 2017 Henry F. Schreiner
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "pybind11.h"
-
-#include <streambuf>
-#include <ostream>
-#include <string>
-#include <memory>
-#include <iostream>
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
-
-// Buffer that writes to Python instead of C++
-class pythonbuf : public std::streambuf {
-private:
-    using traits_type = std::streambuf::traits_type;
-
-    char d_buffer[1024];
-    object pywrite;
-    object pyflush;
-
-    int overflow(int c) {
-        if (!traits_type::eq_int_type(c, traits_type::eof())) {
-            *pptr() = traits_type::to_char_type(c);
-            pbump(1);
-        }
-        return sync() ? traits_type::not_eof(c) : traits_type::eof();
-    }
-
-    int sync() {
-        if (pbase() != pptr()) {
-            // This subtraction cannot be negative, so dropping the sign
-            str line(pbase(), static_cast<size_t>(pptr() - pbase()));
-
-            pywrite(line);
-            pyflush();
-
-            setp(pbase(), epptr());
-        }
-        return 0;
-    }
-
-public:
-    pythonbuf(object pyostream)
-        : pywrite(pyostream.attr("write")),
-          pyflush(pyostream.attr("flush")) {
-        setp(d_buffer, d_buffer + sizeof(d_buffer) - 1);
-    }
-
-    /// Sync before destroy
-    ~pythonbuf() {
-        sync();
-    }
-};
-
-NAMESPACE_END(detail)
-
-
-/** \rst
-    This a move-only guard that redirects output.
-
-    .. code-block:: cpp
-
-        #include <pybind11/iostream.h>
-
-        ...
-
-        {
-            py::scoped_ostream_redirect output;
-            std::cout << "Hello, World!"; // Python stdout
-        } // <-- return std::cout to normal
-
-    You can explicitly pass the c++ stream and the python object,
-    for example to guard stderr instead.
-
-    .. code-block:: cpp
-
-        {
-            py::scoped_ostream_redirect output{std::cerr, py::module::import("sys").attr("stderr")};
-            std::cerr << "Hello, World!";
-        }
- \endrst */
-class scoped_ostream_redirect {
-protected:
-    std::streambuf *old;
-    std::ostream &costream;
-    detail::pythonbuf buffer;
-
-public:
-    scoped_ostream_redirect(
-            std::ostream &costream = std::cout,
-            object pyostream = module::import("sys").attr("stdout"))
-        : costream(costream), buffer(pyostream) {
-        old = costream.rdbuf(&buffer);
-    }
-
-    ~scoped_ostream_redirect() {
-        costream.rdbuf(old);
-    }
-
-    scoped_ostream_redirect(const scoped_ostream_redirect &) = delete;
-    scoped_ostream_redirect(scoped_ostream_redirect &&other) = default;
-    scoped_ostream_redirect &operator=(const scoped_ostream_redirect &) = delete;
-    scoped_ostream_redirect &operator=(scoped_ostream_redirect &&) = delete;
-};
-
-
-/** \rst
-    Like `scoped_ostream_redirect`, but redirects cerr by default. This class
-    is provided primary to make ``py::call_guard`` easier to make.
-
-    .. code-block:: cpp
-
-     m.def("noisy_func", &noisy_func,
-           py::call_guard<scoped_ostream_redirect,
-                          scoped_estream_redirect>());
-
-\endrst */
-class scoped_estream_redirect : public scoped_ostream_redirect {
-public:
-    scoped_estream_redirect(
-            std::ostream &costream = std::cerr,
-            object pyostream = module::import("sys").attr("stderr"))
-        : scoped_ostream_redirect(costream,pyostream) {}
-};
-
-
-NAMESPACE_BEGIN(detail)
-
-// Class to redirect output as a context manager. C++ backend.
-class OstreamRedirect {
-    bool do_stdout_;
-    bool do_stderr_;
-    std::unique_ptr<scoped_ostream_redirect> redirect_stdout;
-    std::unique_ptr<scoped_estream_redirect> redirect_stderr;
-
-public:
-    OstreamRedirect(bool do_stdout = true, bool do_stderr = true)
-        : do_stdout_(do_stdout), do_stderr_(do_stderr) {}
-
-    void enter() {
-        if (do_stdout_)
-            redirect_stdout.reset(new scoped_ostream_redirect());
-        if (do_stderr_)
-            redirect_stderr.reset(new scoped_estream_redirect());
-    }
-
-    void exit() {
-        redirect_stdout.reset();
-        redirect_stderr.reset();
-    }
-};
-
-NAMESPACE_END(detail)
-
-/** \rst
-    This is a helper function to add a C++ redirect context manager to Python
-    instead of using a C++ guard. To use it, add the following to your binding code:
-
-    .. code-block:: cpp
-
-        #include <pybind11/iostream.h>
-
-        ...
-
-        py::add_ostream_redirect(m, "ostream_redirect");
-
-    You now have a Python context manager that redirects your output:
-
-    .. code-block:: python
-
-        with m.ostream_redirect():
-            m.print_to_cout_function()
-
-    This manager can optionally be told which streams to operate on:
-
-    .. code-block:: python
-
-        with m.ostream_redirect(stdout=true, stderr=true):
-            m.noisy_function_with_error_printing()
-
- \endrst */
-inline class_<detail::OstreamRedirect> add_ostream_redirect(module m, std::string name = "ostream_redirect") {
-    return class_<detail::OstreamRedirect>(m, name.c_str(), module_local())
-        .def(init<bool,bool>(), arg("stdout")=true, arg("stderr")=true)
-        .def("__enter__", &detail::OstreamRedirect::enter)
-        .def("__exit__", [](detail::OstreamRedirect &self, args) { self.exit(); });
-}
-
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/numpy.h b/tmap/lib/pybind11/include/pybind11/numpy.h
deleted file mode 100644
index ce8c329..0000000
--- a/tmap/lib/pybind11/include/pybind11/numpy.h
+++ /dev/null
@@ -1,1598 +0,0 @@
-/*
-    pybind11/numpy.h: Basic NumPy support, vectorize() wrapper
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "pybind11.h"
-#include "complex.h"
-#include <numeric>
-#include <algorithm>
-#include <array>
-#include <cstdlib>
-#include <cstring>
-#include <sstream>
-#include <string>
-#include <initializer_list>
-#include <functional>
-#include <utility>
-#include <typeindex>
-
-#if defined(_MSC_VER)
-#  pragma warning(push)
-#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#endif
-
-/* This will be true on all flat address space platforms and allows us to reduce the
-   whole npy_intp / ssize_t / Py_intptr_t business down to just ssize_t for all size
-   and dimension types (e.g. shape, strides, indexing), instead of inflicting this
-   upon the library user. */
-static_assert(sizeof(ssize_t) == sizeof(Py_intptr_t), "ssize_t != Py_intptr_t");
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-
-class array; // Forward declaration
-
-NAMESPACE_BEGIN(detail)
-template <typename type, typename SFINAE = void> struct npy_format_descriptor;
-
-struct PyArrayDescr_Proxy {
-    PyObject_HEAD
-    PyObject *typeobj;
-    char kind;
-    char type;
-    char byteorder;
-    char flags;
-    int type_num;
-    int elsize;
-    int alignment;
-    char *subarray;
-    PyObject *fields;
-    PyObject *names;
-};
-
-struct PyArray_Proxy {
-    PyObject_HEAD
-    char *data;
-    int nd;
-    ssize_t *dimensions;
-    ssize_t *strides;
-    PyObject *base;
-    PyObject *descr;
-    int flags;
-};
-
-struct PyVoidScalarObject_Proxy {
-    PyObject_VAR_HEAD
-    char *obval;
-    PyArrayDescr_Proxy *descr;
-    int flags;
-    PyObject *base;
-};
-
-struct numpy_type_info {
-    PyObject* dtype_ptr;
-    std::string format_str;
-};
-
-struct numpy_internals {
-    std::unordered_map<std::type_index, numpy_type_info> registered_dtypes;
-
-    numpy_type_info *get_type_info(const std::type_info& tinfo, bool throw_if_missing = true) {
-        auto it = registered_dtypes.find(std::type_index(tinfo));
-        if (it != registered_dtypes.end())
-            return &(it->second);
-        if (throw_if_missing)
-            pybind11_fail(std::string("NumPy type info missing for ") + tinfo.name());
-        return nullptr;
-    }
-
-    template<typename T> numpy_type_info *get_type_info(bool throw_if_missing = true) {
-        return get_type_info(typeid(typename std::remove_cv<T>::type), throw_if_missing);
-    }
-};
-
-inline PYBIND11_NOINLINE void load_numpy_internals(numpy_internals* &ptr) {
-    ptr = &get_or_create_shared_data<numpy_internals>("_numpy_internals");
-}
-
-inline numpy_internals& get_numpy_internals() {
-    static numpy_internals* ptr = nullptr;
-    if (!ptr)
-        load_numpy_internals(ptr);
-    return *ptr;
-}
-
-struct npy_api {
-    enum constants {
-        NPY_ARRAY_C_CONTIGUOUS_ = 0x0001,
-        NPY_ARRAY_F_CONTIGUOUS_ = 0x0002,
-        NPY_ARRAY_OWNDATA_ = 0x0004,
-        NPY_ARRAY_FORCECAST_ = 0x0010,
-        NPY_ARRAY_ENSUREARRAY_ = 0x0040,
-        NPY_ARRAY_ALIGNED_ = 0x0100,
-        NPY_ARRAY_WRITEABLE_ = 0x0400,
-        NPY_BOOL_ = 0,
-        NPY_BYTE_, NPY_UBYTE_,
-        NPY_SHORT_, NPY_USHORT_,
-        NPY_INT_, NPY_UINT_,
-        NPY_LONG_, NPY_ULONG_,
-        NPY_LONGLONG_, NPY_ULONGLONG_,
-        NPY_FLOAT_, NPY_DOUBLE_, NPY_LONGDOUBLE_,
-        NPY_CFLOAT_, NPY_CDOUBLE_, NPY_CLONGDOUBLE_,
-        NPY_OBJECT_ = 17,
-        NPY_STRING_, NPY_UNICODE_, NPY_VOID_
-    };
-
-    typedef struct {
-        Py_intptr_t *ptr;
-        int len;
-    } PyArray_Dims;
-
-    static npy_api& get() {
-        static npy_api api = lookup();
-        return api;
-    }
-
-    bool PyArray_Check_(PyObject *obj) const {
-        return (bool) PyObject_TypeCheck(obj, PyArray_Type_);
-    }
-    bool PyArrayDescr_Check_(PyObject *obj) const {
-        return (bool) PyObject_TypeCheck(obj, PyArrayDescr_Type_);
-    }
-
-    unsigned int (*PyArray_GetNDArrayCFeatureVersion_)();
-    PyObject *(*PyArray_DescrFromType_)(int);
-    PyObject *(*PyArray_NewFromDescr_)
-        (PyTypeObject *, PyObject *, int, Py_intptr_t *,
-         Py_intptr_t *, void *, int, PyObject *);
-    PyObject *(*PyArray_DescrNewFromType_)(int);
-    int (*PyArray_CopyInto_)(PyObject *, PyObject *);
-    PyObject *(*PyArray_NewCopy_)(PyObject *, int);
-    PyTypeObject *PyArray_Type_;
-    PyTypeObject *PyVoidArrType_Type_;
-    PyTypeObject *PyArrayDescr_Type_;
-    PyObject *(*PyArray_DescrFromScalar_)(PyObject *);
-    PyObject *(*PyArray_FromAny_) (PyObject *, PyObject *, int, int, int, PyObject *);
-    int (*PyArray_DescrConverter_) (PyObject *, PyObject **);
-    bool (*PyArray_EquivTypes_) (PyObject *, PyObject *);
-    int (*PyArray_GetArrayParamsFromObject_)(PyObject *, PyObject *, char, PyObject **, int *,
-                                             Py_ssize_t *, PyObject **, PyObject *);
-    PyObject *(*PyArray_Squeeze_)(PyObject *);
-    int (*PyArray_SetBaseObject_)(PyObject *, PyObject *);
-    PyObject* (*PyArray_Resize_)(PyObject*, PyArray_Dims*, int, int);
-private:
-    enum functions {
-        API_PyArray_GetNDArrayCFeatureVersion = 211,
-        API_PyArray_Type = 2,
-        API_PyArrayDescr_Type = 3,
-        API_PyVoidArrType_Type = 39,
-        API_PyArray_DescrFromType = 45,
-        API_PyArray_DescrFromScalar = 57,
-        API_PyArray_FromAny = 69,
-        API_PyArray_Resize = 80,
-        API_PyArray_CopyInto = 82,
-        API_PyArray_NewCopy = 85,
-        API_PyArray_NewFromDescr = 94,
-        API_PyArray_DescrNewFromType = 9,
-        API_PyArray_DescrConverter = 174,
-        API_PyArray_EquivTypes = 182,
-        API_PyArray_GetArrayParamsFromObject = 278,
-        API_PyArray_Squeeze = 136,
-        API_PyArray_SetBaseObject = 282
-    };
-
-    static npy_api lookup() {
-        module m = module::import("numpy.core.multiarray");
-        auto c = m.attr("_ARRAY_API");
-#if PY_MAJOR_VERSION >= 3
-        void **api_ptr = (void **) PyCapsule_GetPointer(c.ptr(), NULL);
-#else
-        void **api_ptr = (void **) PyCObject_AsVoidPtr(c.ptr());
-#endif
-        npy_api api;
-#define DECL_NPY_API(Func) api.Func##_ = (decltype(api.Func##_)) api_ptr[API_##Func];
-        DECL_NPY_API(PyArray_GetNDArrayCFeatureVersion);
-        if (api.PyArray_GetNDArrayCFeatureVersion_() < 0x7)
-            pybind11_fail("pybind11 numpy support requires numpy >= 1.7.0");
-        DECL_NPY_API(PyArray_Type);
-        DECL_NPY_API(PyVoidArrType_Type);
-        DECL_NPY_API(PyArrayDescr_Type);
-        DECL_NPY_API(PyArray_DescrFromType);
-        DECL_NPY_API(PyArray_DescrFromScalar);
-        DECL_NPY_API(PyArray_FromAny);
-        DECL_NPY_API(PyArray_Resize);
-        DECL_NPY_API(PyArray_CopyInto);
-        DECL_NPY_API(PyArray_NewCopy);
-        DECL_NPY_API(PyArray_NewFromDescr);
-        DECL_NPY_API(PyArray_DescrNewFromType);
-        DECL_NPY_API(PyArray_DescrConverter);
-        DECL_NPY_API(PyArray_EquivTypes);
-        DECL_NPY_API(PyArray_GetArrayParamsFromObject);
-        DECL_NPY_API(PyArray_Squeeze);
-        DECL_NPY_API(PyArray_SetBaseObject);
-#undef DECL_NPY_API
-        return api;
-    }
-};
-
-inline PyArray_Proxy* array_proxy(void* ptr) {
-    return reinterpret_cast<PyArray_Proxy*>(ptr);
-}
-
-inline const PyArray_Proxy* array_proxy(const void* ptr) {
-    return reinterpret_cast<const PyArray_Proxy*>(ptr);
-}
-
-inline PyArrayDescr_Proxy* array_descriptor_proxy(PyObject* ptr) {
-   return reinterpret_cast<PyArrayDescr_Proxy*>(ptr);
-}
-
-inline const PyArrayDescr_Proxy* array_descriptor_proxy(const PyObject* ptr) {
-   return reinterpret_cast<const PyArrayDescr_Proxy*>(ptr);
-}
-
-inline bool check_flags(const void* ptr, int flag) {
-    return (flag == (array_proxy(ptr)->flags & flag));
-}
-
-template <typename T> struct is_std_array : std::false_type { };
-template <typename T, size_t N> struct is_std_array<std::array<T, N>> : std::true_type { };
-template <typename T> struct is_complex : std::false_type { };
-template <typename T> struct is_complex<std::complex<T>> : std::true_type { };
-
-template <typename T> struct array_info_scalar {
-    typedef T type;
-    static constexpr bool is_array = false;
-    static constexpr bool is_empty = false;
-    static PYBIND11_DESCR extents() { return _(""); }
-    static void append_extents(list& /* shape */) { }
-};
-// Computes underlying type and a comma-separated list of extents for array
-// types (any mix of std::array and built-in arrays). An array of char is
-// treated as scalar because it gets special handling.
-template <typename T> struct array_info : array_info_scalar<T> { };
-template <typename T, size_t N> struct array_info<std::array<T, N>> {
-    using type = typename array_info<T>::type;
-    static constexpr bool is_array = true;
-    static constexpr bool is_empty = (N == 0) || array_info<T>::is_empty;
-    static constexpr size_t extent = N;
-
-    // appends the extents to shape
-    static void append_extents(list& shape) {
-        shape.append(N);
-        array_info<T>::append_extents(shape);
-    }
-
-    template<typename T2 = T, enable_if_t<!array_info<T2>::is_array, int> = 0>
-    static PYBIND11_DESCR extents() {
-        return _<N>();
-    }
-
-    template<typename T2 = T, enable_if_t<array_info<T2>::is_array, int> = 0>
-    static PYBIND11_DESCR extents() {
-        return concat(_<N>(), array_info<T>::extents());
-    }
-};
-// For numpy we have special handling for arrays of characters, so we don't include
-// the size in the array extents.
-template <size_t N> struct array_info<char[N]> : array_info_scalar<char[N]> { };
-template <size_t N> struct array_info<std::array<char, N>> : array_info_scalar<std::array<char, N>> { };
-template <typename T, size_t N> struct array_info<T[N]> : array_info<std::array<T, N>> { };
-template <typename T> using remove_all_extents_t = typename array_info<T>::type;
-
-template <typename T> using is_pod_struct = all_of<
-    std::is_standard_layout<T>,     // since we're accessing directly in memory we need a standard layout type
-#if !defined(__GNUG__) || defined(__clang__) || __GNUC__ >= 5
-    std::is_trivially_copyable<T>,
-#else
-    // GCC 4 doesn't implement is_trivially_copyable, so approximate it
-    std::is_trivially_destructible<T>,
-    satisfies_any_of<T, std::has_trivial_copy_constructor, std::has_trivial_copy_assign>,
-#endif
-    satisfies_none_of<T, std::is_reference, std::is_array, is_std_array, std::is_arithmetic, is_complex, std::is_enum>
->;
-
-template <ssize_t Dim = 0, typename Strides> ssize_t byte_offset_unsafe(const Strides &) { return 0; }
-template <ssize_t Dim = 0, typename Strides, typename... Ix>
-ssize_t byte_offset_unsafe(const Strides &strides, ssize_t i, Ix... index) {
-    return i * strides[Dim] + byte_offset_unsafe<Dim + 1>(strides, index...);
-}
-
-/**
- * Proxy class providing unsafe, unchecked const access to array data.  This is constructed through
- * the `unchecked<T, N>()` method of `array` or the `unchecked<N>()` method of `array_t<T>`.  `Dims`
- * will be -1 for dimensions determined at runtime.
- */
-template <typename T, ssize_t Dims>
-class unchecked_reference {
-protected:
-    static constexpr bool Dynamic = Dims < 0;
-    const unsigned char *data_;
-    // Storing the shape & strides in local variables (i.e. these arrays) allows the compiler to
-    // make large performance gains on big, nested loops, but requires compile-time dimensions
-    conditional_t<Dynamic, const ssize_t *, std::array<ssize_t, (size_t) Dims>>
-            shape_, strides_;
-    const ssize_t dims_;
-
-    friend class pybind11::array;
-    // Constructor for compile-time dimensions:
-    template <bool Dyn = Dynamic>
-    unchecked_reference(const void *data, const ssize_t *shape, const ssize_t *strides, enable_if_t<!Dyn, ssize_t>)
-    : data_{reinterpret_cast<const unsigned char *>(data)}, dims_{Dims} {
-        for (size_t i = 0; i < (size_t) dims_; i++) {
-            shape_[i] = shape[i];
-            strides_[i] = strides[i];
-        }
-    }
-    // Constructor for runtime dimensions:
-    template <bool Dyn = Dynamic>
-    unchecked_reference(const void *data, const ssize_t *shape, const ssize_t *strides, enable_if_t<Dyn, ssize_t> dims)
-    : data_{reinterpret_cast<const unsigned char *>(data)}, shape_{shape}, strides_{strides}, dims_{dims} {}
-
-public:
-    /**
-     * Unchecked const reference access to data at the given indices.  For a compile-time known
-     * number of dimensions, this requires the correct number of arguments; for run-time
-     * dimensionality, this is not checked (and so is up to the caller to use safely).
-     */
-    template <typename... Ix> const T &operator()(Ix... index) const {
-        static_assert(ssize_t{sizeof...(Ix)} == Dims || Dynamic,
-                "Invalid number of indices for unchecked array reference");
-        return *reinterpret_cast<const T *>(data_ + byte_offset_unsafe(strides_, ssize_t(index)...));
-    }
-    /**
-     * Unchecked const reference access to data; this operator only participates if the reference
-     * is to a 1-dimensional array.  When present, this is exactly equivalent to `obj(index)`.
-     */
-    template <ssize_t D = Dims, typename = enable_if_t<D == 1 || Dynamic>>
-    const T &operator[](ssize_t index) const { return operator()(index); }
-
-    /// Pointer access to the data at the given indices.
-    template <typename... Ix> const T *data(Ix... ix) const { return &operator()(ssize_t(ix)...); }
-
-    /// Returns the item size, i.e. sizeof(T)
-    constexpr static ssize_t itemsize() { return sizeof(T); }
-
-    /// Returns the shape (i.e. size) of dimension `dim`
-    ssize_t shape(ssize_t dim) const { return shape_[(size_t) dim]; }
-
-    /// Returns the number of dimensions of the array
-    ssize_t ndim() const { return dims_; }
-
-    /// Returns the total number of elements in the referenced array, i.e. the product of the shapes
-    template <bool Dyn = Dynamic>
-    enable_if_t<!Dyn, ssize_t> size() const {
-        return std::accumulate(shape_.begin(), shape_.end(), (ssize_t) 1, std::multiplies<ssize_t>());
-    }
-    template <bool Dyn = Dynamic>
-    enable_if_t<Dyn, ssize_t> size() const {
-        return std::accumulate(shape_, shape_ + ndim(), (ssize_t) 1, std::multiplies<ssize_t>());
-    }
-
-    /// Returns the total number of bytes used by the referenced data.  Note that the actual span in
-    /// memory may be larger if the referenced array has non-contiguous strides (e.g. for a slice).
-    ssize_t nbytes() const {
-        return size() * itemsize();
-    }
-};
-
-template <typename T, ssize_t Dims>
-class unchecked_mutable_reference : public unchecked_reference<T, Dims> {
-    friend class pybind11::array;
-    using ConstBase = unchecked_reference<T, Dims>;
-    using ConstBase::ConstBase;
-    using ConstBase::Dynamic;
-public:
-    /// Mutable, unchecked access to data at the given indices.
-    template <typename... Ix> T& operator()(Ix... index) {
-        static_assert(ssize_t{sizeof...(Ix)} == Dims || Dynamic,
-                "Invalid number of indices for unchecked array reference");
-        return const_cast<T &>(ConstBase::operator()(index...));
-    }
-    /**
-     * Mutable, unchecked access data at the given index; this operator only participates if the
-     * reference is to a 1-dimensional array (or has runtime dimensions).  When present, this is
-     * exactly equivalent to `obj(index)`.
-     */
-    template <ssize_t D = Dims, typename = enable_if_t<D == 1 || Dynamic>>
-    T &operator[](ssize_t index) { return operator()(index); }
-
-    /// Mutable pointer access to the data at the given indices.
-    template <typename... Ix> T *mutable_data(Ix... ix) { return &operator()(ssize_t(ix)...); }
-};
-
-template <typename T, ssize_t Dim>
-struct type_caster<unchecked_reference<T, Dim>> {
-    static_assert(Dim == 0 && Dim > 0 /* always fail */, "unchecked array proxy object is not castable");
-};
-template <typename T, ssize_t Dim>
-struct type_caster<unchecked_mutable_reference<T, Dim>> : type_caster<unchecked_reference<T, Dim>> {};
-
-NAMESPACE_END(detail)
-
-class dtype : public object {
-public:
-    PYBIND11_OBJECT_DEFAULT(dtype, object, detail::npy_api::get().PyArrayDescr_Check_);
-
-    explicit dtype(const buffer_info &info) {
-        dtype descr(_dtype_from_pep3118()(PYBIND11_STR_TYPE(info.format)));
-        // If info.itemsize == 0, use the value calculated from the format string
-        m_ptr = descr.strip_padding(info.itemsize ? info.itemsize : descr.itemsize()).release().ptr();
-    }
-
-    explicit dtype(const std::string &format) {
-        m_ptr = from_args(pybind11::str(format)).release().ptr();
-    }
-
-    dtype(const char *format) : dtype(std::string(format)) { }
-
-    dtype(list names, list formats, list offsets, ssize_t itemsize) {
-        dict args;
-        args["names"] = names;
-        args["formats"] = formats;
-        args["offsets"] = offsets;
-        args["itemsize"] = pybind11::int_(itemsize);
-        m_ptr = from_args(args).release().ptr();
-    }
-
-    /// This is essentially the same as calling numpy.dtype(args) in Python.
-    static dtype from_args(object args) {
-        PyObject *ptr = nullptr;
-        if (!detail::npy_api::get().PyArray_DescrConverter_(args.release().ptr(), &ptr) || !ptr)
-            throw error_already_set();
-        return reinterpret_steal<dtype>(ptr);
-    }
-
-    /// Return dtype associated with a C++ type.
-    template <typename T> static dtype of() {
-        return detail::npy_format_descriptor<typename std::remove_cv<T>::type>::dtype();
-    }
-
-    /// Size of the data type in bytes.
-    ssize_t itemsize() const {
-        return detail::array_descriptor_proxy(m_ptr)->elsize;
-    }
-
-    /// Returns true for structured data types.
-    bool has_fields() const {
-        return detail::array_descriptor_proxy(m_ptr)->names != nullptr;
-    }
-
-    /// Single-character type code.
-    char kind() const {
-        return detail::array_descriptor_proxy(m_ptr)->kind;
-    }
-
-private:
-    static object _dtype_from_pep3118() {
-        static PyObject *obj = module::import("numpy.core._internal")
-            .attr("_dtype_from_pep3118").cast<object>().release().ptr();
-        return reinterpret_borrow<object>(obj);
-    }
-
-    dtype strip_padding(ssize_t itemsize) {
-        // Recursively strip all void fields with empty names that are generated for
-        // padding fields (as of NumPy v1.11).
-        if (!has_fields())
-            return *this;
-
-        struct field_descr { PYBIND11_STR_TYPE name; object format; pybind11::int_ offset; };
-        std::vector<field_descr> field_descriptors;
-
-        for (auto field : attr("fields").attr("items")()) {
-            auto spec = field.cast<tuple>();
-            auto name = spec[0].cast<pybind11::str>();
-            auto format = spec[1].cast<tuple>()[0].cast<dtype>();
-            auto offset = spec[1].cast<tuple>()[1].cast<pybind11::int_>();
-            if (!len(name) && format.kind() == 'V')
-                continue;
-            field_descriptors.push_back({(PYBIND11_STR_TYPE) name, format.strip_padding(format.itemsize()), offset});
-        }
-
-        std::sort(field_descriptors.begin(), field_descriptors.end(),
-                  [](const field_descr& a, const field_descr& b) {
-                      return a.offset.cast<int>() < b.offset.cast<int>();
-                  });
-
-        list names, formats, offsets;
-        for (auto& descr : field_descriptors) {
-            names.append(descr.name);
-            formats.append(descr.format);
-            offsets.append(descr.offset);
-        }
-        return dtype(names, formats, offsets, itemsize);
-    }
-};
-
-class array : public buffer {
-public:
-    PYBIND11_OBJECT_CVT(array, buffer, detail::npy_api::get().PyArray_Check_, raw_array)
-
-    enum {
-        c_style = detail::npy_api::NPY_ARRAY_C_CONTIGUOUS_,
-        f_style = detail::npy_api::NPY_ARRAY_F_CONTIGUOUS_,
-        forcecast = detail::npy_api::NPY_ARRAY_FORCECAST_
-    };
-
-    array() : array({{0}}, static_cast<const double *>(nullptr)) {}
-
-    using ShapeContainer = detail::any_container<ssize_t>;
-    using StridesContainer = detail::any_container<ssize_t>;
-
-    // Constructs an array taking shape/strides from arbitrary container types
-    array(const pybind11::dtype &dt, ShapeContainer shape, StridesContainer strides,
-          const void *ptr = nullptr, handle base = handle()) {
-
-        if (strides->empty())
-            *strides = c_strides(*shape, dt.itemsize());
-
-        auto ndim = shape->size();
-        if (ndim != strides->size())
-            pybind11_fail("NumPy: shape ndim doesn't match strides ndim");
-        auto descr = dt;
-
-        int flags = 0;
-        if (base && ptr) {
-            if (isinstance<array>(base))
-                /* Copy flags from base (except ownership bit) */
-                flags = reinterpret_borrow<array>(base).flags() & ~detail::npy_api::NPY_ARRAY_OWNDATA_;
-            else
-                /* Writable by default, easy to downgrade later on if needed */
-                flags = detail::npy_api::NPY_ARRAY_WRITEABLE_;
-        }
-
-        auto &api = detail::npy_api::get();
-        auto tmp = reinterpret_steal<object>(api.PyArray_NewFromDescr_(
-            api.PyArray_Type_, descr.release().ptr(), (int) ndim, shape->data(), strides->data(),
-            const_cast<void *>(ptr), flags, nullptr));
-        if (!tmp)
-            throw error_already_set();
-        if (ptr) {
-            if (base) {
-                api.PyArray_SetBaseObject_(tmp.ptr(), base.inc_ref().ptr());
-            } else {
-                tmp = reinterpret_steal<object>(api.PyArray_NewCopy_(tmp.ptr(), -1 /* any order */));
-            }
-        }
-        m_ptr = tmp.release().ptr();
-    }
-
-    array(const pybind11::dtype &dt, ShapeContainer shape, const void *ptr = nullptr, handle base = handle())
-        : array(dt, std::move(shape), {}, ptr, base) { }
-
-    template <typename T, typename = detail::enable_if_t<std::is_integral<T>::value && !std::is_same<bool, T>::value>>
-    array(const pybind11::dtype &dt, T count, const void *ptr = nullptr, handle base = handle())
-        : array(dt, {{count}}, ptr, base) { }
-
-    template <typename T>
-    array(ShapeContainer shape, StridesContainer strides, const T *ptr, handle base = handle())
-        : array(pybind11::dtype::of<T>(), std::move(shape), std::move(strides), ptr, base) { }
-
-    template <typename T>
-    array(ShapeContainer shape, const T *ptr, handle base = handle())
-        : array(std::move(shape), {}, ptr, base) { }
-
-    template <typename T>
-    explicit array(ssize_t count, const T *ptr, handle base = handle()) : array({count}, {}, ptr, base) { }
-
-    explicit array(const buffer_info &info)
-    : array(pybind11::dtype(info), info.shape, info.strides, info.ptr) { }
-
-    /// Array descriptor (dtype)
-    pybind11::dtype dtype() const {
-        return reinterpret_borrow<pybind11::dtype>(detail::array_proxy(m_ptr)->descr);
-    }
-
-    /// Total number of elements
-    ssize_t size() const {
-        return std::accumulate(shape(), shape() + ndim(), (ssize_t) 1, std::multiplies<ssize_t>());
-    }
-
-    /// Byte size of a single element
-    ssize_t itemsize() const {
-        return detail::array_descriptor_proxy(detail::array_proxy(m_ptr)->descr)->elsize;
-    }
-
-    /// Total number of bytes
-    ssize_t nbytes() const {
-        return size() * itemsize();
-    }
-
-    /// Number of dimensions
-    ssize_t ndim() const {
-        return detail::array_proxy(m_ptr)->nd;
-    }
-
-    /// Base object
-    object base() const {
-        return reinterpret_borrow<object>(detail::array_proxy(m_ptr)->base);
-    }
-
-    /// Dimensions of the array
-    const ssize_t* shape() const {
-        return detail::array_proxy(m_ptr)->dimensions;
-    }
-
-    /// Dimension along a given axis
-    ssize_t shape(ssize_t dim) const {
-        if (dim >= ndim())
-            fail_dim_check(dim, "invalid axis");
-        return shape()[dim];
-    }
-
-    /// Strides of the array
-    const ssize_t* strides() const {
-        return detail::array_proxy(m_ptr)->strides;
-    }
-
-    /// Stride along a given axis
-    ssize_t strides(ssize_t dim) const {
-        if (dim >= ndim())
-            fail_dim_check(dim, "invalid axis");
-        return strides()[dim];
-    }
-
-    /// Return the NumPy array flags
-    int flags() const {
-        return detail::array_proxy(m_ptr)->flags;
-    }
-
-    /// If set, the array is writeable (otherwise the buffer is read-only)
-    bool writeable() const {
-        return detail::check_flags(m_ptr, detail::npy_api::NPY_ARRAY_WRITEABLE_);
-    }
-
-    /// If set, the array owns the data (will be freed when the array is deleted)
-    bool owndata() const {
-        return detail::check_flags(m_ptr, detail::npy_api::NPY_ARRAY_OWNDATA_);
-    }
-
-    /// Pointer to the contained data. If index is not provided, points to the
-    /// beginning of the buffer. May throw if the index would lead to out of bounds access.
-    template<typename... Ix> const void* data(Ix... index) const {
-        return static_cast<const void *>(detail::array_proxy(m_ptr)->data + offset_at(index...));
-    }
-
-    /// Mutable pointer to the contained data. If index is not provided, points to the
-    /// beginning of the buffer. May throw if the index would lead to out of bounds access.
-    /// May throw if the array is not writeable.
-    template<typename... Ix> void* mutable_data(Ix... index) {
-        check_writeable();
-        return static_cast<void *>(detail::array_proxy(m_ptr)->data + offset_at(index...));
-    }
-
-    /// Byte offset from beginning of the array to a given index (full or partial).
-    /// May throw if the index would lead to out of bounds access.
-    template<typename... Ix> ssize_t offset_at(Ix... index) const {
-        if ((ssize_t) sizeof...(index) > ndim())
-            fail_dim_check(sizeof...(index), "too many indices for an array");
-        return byte_offset(ssize_t(index)...);
-    }
-
-    ssize_t offset_at() const { return 0; }
-
-    /// Item count from beginning of the array to a given index (full or partial).
-    /// May throw if the index would lead to out of bounds access.
-    template<typename... Ix> ssize_t index_at(Ix... index) const {
-        return offset_at(index...) / itemsize();
-    }
-
-    /**
-     * Returns a proxy object that provides access to the array's data without bounds or
-     * dimensionality checking.  Will throw if the array is missing the `writeable` flag.  Use with
-     * care: the array must not be destroyed or reshaped for the duration of the returned object,
-     * and the caller must take care not to access invalid dimensions or dimension indices.
-     */
-    template <typename T, ssize_t Dims = -1> detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {
-        if (Dims >= 0 && ndim() != Dims)
-            throw std::domain_error("array has incorrect number of dimensions: " + std::to_string(ndim()) +
-                    "; expected " + std::to_string(Dims));
-        return detail::unchecked_mutable_reference<T, Dims>(mutable_data(), shape(), strides(), ndim());
-    }
-
-    /**
-     * Returns a proxy object that provides const access to the array's data without bounds or
-     * dimensionality checking.  Unlike `mutable_unchecked()`, this does not require that the
-     * underlying array have the `writable` flag.  Use with care: the array must not be destroyed or
-     * reshaped for the duration of the returned object, and the caller must take care not to access
-     * invalid dimensions or dimension indices.
-     */
-    template <typename T, ssize_t Dims = -1> detail::unchecked_reference<T, Dims> unchecked() const & {
-        if (Dims >= 0 && ndim() != Dims)
-            throw std::domain_error("array has incorrect number of dimensions: " + std::to_string(ndim()) +
-                    "; expected " + std::to_string(Dims));
-        return detail::unchecked_reference<T, Dims>(data(), shape(), strides(), ndim());
-    }
-
-    /// Return a new view with all of the dimensions of length 1 removed
-    array squeeze() {
-        auto& api = detail::npy_api::get();
-        return reinterpret_steal<array>(api.PyArray_Squeeze_(m_ptr));
-    }
-
-    /// Resize array to given shape
-    /// If refcheck is true and more that one reference exist to this array
-    /// then resize will succeed only if it makes a reshape, i.e. original size doesn't change
-    void resize(ShapeContainer new_shape, bool refcheck = true) {
-        detail::npy_api::PyArray_Dims d = {
-            new_shape->data(), int(new_shape->size())
-        };
-        // try to resize, set ordering param to -1 cause it's not used anyway
-        object new_array = reinterpret_steal<object>(
-            detail::npy_api::get().PyArray_Resize_(m_ptr, &d, int(refcheck), -1)
-        );
-        if (!new_array) throw error_already_set();
-        if (isinstance<array>(new_array)) { *this = std::move(new_array); }
-    }
-
-    /// Ensure that the argument is a NumPy array
-    /// In case of an error, nullptr is returned and the Python error is cleared.
-    static array ensure(handle h, int ExtraFlags = 0) {
-        auto result = reinterpret_steal<array>(raw_array(h.ptr(), ExtraFlags));
-        if (!result)
-            PyErr_Clear();
-        return result;
-    }
-
-protected:
-    template<typename, typename> friend struct detail::npy_format_descriptor;
-
-    void fail_dim_check(ssize_t dim, const std::string& msg) const {
-        throw index_error(msg + ": " + std::to_string(dim) +
-                          " (ndim = " + std::to_string(ndim()) + ")");
-    }
-
-    template<typename... Ix> ssize_t byte_offset(Ix... index) const {
-        check_dimensions(index...);
-        return detail::byte_offset_unsafe(strides(), ssize_t(index)...);
-    }
-
-    void check_writeable() const {
-        if (!writeable())
-            throw std::domain_error("array is not writeable");
-    }
-
-    // Default, C-style strides
-    static std::vector<ssize_t> c_strides(const std::vector<ssize_t> &shape, ssize_t itemsize) {
-        auto ndim = shape.size();
-        std::vector<ssize_t> strides(ndim, itemsize);
-        for (size_t i = ndim - 1; i > 0; --i)
-            strides[i - 1] = strides[i] * shape[i];
-        return strides;
-    }
-
-    // F-style strides; default when constructing an array_t with `ExtraFlags & f_style`
-    static std::vector<ssize_t> f_strides(const std::vector<ssize_t> &shape, ssize_t itemsize) {
-        auto ndim = shape.size();
-        std::vector<ssize_t> strides(ndim, itemsize);
-        for (size_t i = 1; i < ndim; ++i)
-            strides[i] = strides[i - 1] * shape[i - 1];
-        return strides;
-    }
-
-    template<typename... Ix> void check_dimensions(Ix... index) const {
-        check_dimensions_impl(ssize_t(0), shape(), ssize_t(index)...);
-    }
-
-    void check_dimensions_impl(ssize_t, const ssize_t*) const { }
-
-    template<typename... Ix> void check_dimensions_impl(ssize_t axis, const ssize_t* shape, ssize_t i, Ix... index) const {
-        if (i >= *shape) {
-            throw index_error(std::string("index ") + std::to_string(i) +
-                              " is out of bounds for axis " + std::to_string(axis) +
-                              " with size " + std::to_string(*shape));
-        }
-        check_dimensions_impl(axis + 1, shape + 1, index...);
-    }
-
-    /// Create array from any object -- always returns a new reference
-    static PyObject *raw_array(PyObject *ptr, int ExtraFlags = 0) {
-        if (ptr == nullptr) {
-            PyErr_SetString(PyExc_ValueError, "cannot create a pybind11::array from a nullptr");
-            return nullptr;
-        }
-        return detail::npy_api::get().PyArray_FromAny_(
-            ptr, nullptr, 0, 0, detail::npy_api::NPY_ARRAY_ENSUREARRAY_ | ExtraFlags, nullptr);
-    }
-};
-
-template <typename T, int ExtraFlags = array::forcecast> class array_t : public array {
-private:
-    struct private_ctor {};
-    // Delegating constructor needed when both moving and accessing in the same constructor
-    array_t(private_ctor, ShapeContainer &&shape, StridesContainer &&strides, const T *ptr, handle base)
-        : array(std::move(shape), std::move(strides), ptr, base) {}
-public:
-    static_assert(!detail::array_info<T>::is_array, "Array types cannot be used with array_t");
-
-    using value_type = T;
-
-    array_t() : array(0, static_cast<const T *>(nullptr)) {}
-    array_t(handle h, borrowed_t) : array(h, borrowed_t{}) { }
-    array_t(handle h, stolen_t) : array(h, stolen_t{}) { }
-
-    PYBIND11_DEPRECATED("Use array_t<T>::ensure() instead")
-    array_t(handle h, bool is_borrowed) : array(raw_array_t(h.ptr()), stolen_t{}) {
-        if (!m_ptr) PyErr_Clear();
-        if (!is_borrowed) Py_XDECREF(h.ptr());
-    }
-
-    array_t(const object &o) : array(raw_array_t(o.ptr()), stolen_t{}) {
-        if (!m_ptr) throw error_already_set();
-    }
-
-    explicit array_t(const buffer_info& info) : array(info) { }
-
-    array_t(ShapeContainer shape, StridesContainer strides, const T *ptr = nullptr, handle base = handle())
-        : array(std::move(shape), std::move(strides), ptr, base) { }
-
-    explicit array_t(ShapeContainer shape, const T *ptr = nullptr, handle base = handle())
-        : array_t(private_ctor{}, std::move(shape),
-                ExtraFlags & f_style ? f_strides(*shape, itemsize()) : c_strides(*shape, itemsize()),
-                ptr, base) { }
-
-    explicit array_t(size_t count, const T *ptr = nullptr, handle base = handle())
-        : array({count}, {}, ptr, base) { }
-
-    constexpr ssize_t itemsize() const {
-        return sizeof(T);
-    }
-
-    template<typename... Ix> ssize_t index_at(Ix... index) const {
-        return offset_at(index...) / itemsize();
-    }
-
-    template<typename... Ix> const T* data(Ix... index) const {
-        return static_cast<const T*>(array::data(index...));
-    }
-
-    template<typename... Ix> T* mutable_data(Ix... index) {
-        return static_cast<T*>(array::mutable_data(index...));
-    }
-
-    // Reference to element at a given index
-    template<typename... Ix> const T& at(Ix... index) const {
-        if (sizeof...(index) != ndim())
-            fail_dim_check(sizeof...(index), "index dimension mismatch");
-        return *(static_cast<const T*>(array::data()) + byte_offset(ssize_t(index)...) / itemsize());
-    }
-
-    // Mutable reference to element at a given index
-    template<typename... Ix> T& mutable_at(Ix... index) {
-        if (sizeof...(index) != ndim())
-            fail_dim_check(sizeof...(index), "index dimension mismatch");
-        return *(static_cast<T*>(array::mutable_data()) + byte_offset(ssize_t(index)...) / itemsize());
-    }
-
-    /**
-     * Returns a proxy object that provides access to the array's data without bounds or
-     * dimensionality checking.  Will throw if the array is missing the `writeable` flag.  Use with
-     * care: the array must not be destroyed or reshaped for the duration of the returned object,
-     * and the caller must take care not to access invalid dimensions or dimension indices.
-     */
-    template <ssize_t Dims = -1> detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {
-        return array::mutable_unchecked<T, Dims>();
-    }
-
-    /**
-     * Returns a proxy object that provides const access to the array's data without bounds or
-     * dimensionality checking.  Unlike `unchecked()`, this does not require that the underlying
-     * array have the `writable` flag.  Use with care: the array must not be destroyed or reshaped
-     * for the duration of the returned object, and the caller must take care not to access invalid
-     * dimensions or dimension indices.
-     */
-    template <ssize_t Dims = -1> detail::unchecked_reference<T, Dims> unchecked() const & {
-        return array::unchecked<T, Dims>();
-    }
-
-    /// Ensure that the argument is a NumPy array of the correct dtype (and if not, try to convert
-    /// it).  In case of an error, nullptr is returned and the Python error is cleared.
-    static array_t ensure(handle h) {
-        auto result = reinterpret_steal<array_t>(raw_array_t(h.ptr()));
-        if (!result)
-            PyErr_Clear();
-        return result;
-    }
-
-    static bool check_(handle h) {
-        const auto &api = detail::npy_api::get();
-        return api.PyArray_Check_(h.ptr())
-               && api.PyArray_EquivTypes_(detail::array_proxy(h.ptr())->descr, dtype::of<T>().ptr());
-    }
-
-protected:
-    /// Create array from any object -- always returns a new reference
-    static PyObject *raw_array_t(PyObject *ptr) {
-        if (ptr == nullptr) {
-            PyErr_SetString(PyExc_ValueError, "cannot create a pybind11::array_t from a nullptr");
-            return nullptr;
-        }
-        return detail::npy_api::get().PyArray_FromAny_(
-            ptr, dtype::of<T>().release().ptr(), 0, 0,
-            detail::npy_api::NPY_ARRAY_ENSUREARRAY_ | ExtraFlags, nullptr);
-    }
-};
-
-template <typename T>
-struct format_descriptor<T, detail::enable_if_t<detail::is_pod_struct<T>::value>> {
-    static std::string format() {
-        return detail::npy_format_descriptor<typename std::remove_cv<T>::type>::format();
-    }
-};
-
-template <size_t N> struct format_descriptor<char[N]> {
-    static std::string format() { return std::to_string(N) + "s"; }
-};
-template <size_t N> struct format_descriptor<std::array<char, N>> {
-    static std::string format() { return std::to_string(N) + "s"; }
-};
-
-template <typename T>
-struct format_descriptor<T, detail::enable_if_t<std::is_enum<T>::value>> {
-    static std::string format() {
-        return format_descriptor<
-            typename std::remove_cv<typename std::underlying_type<T>::type>::type>::format();
-    }
-};
-
-template <typename T>
-struct format_descriptor<T, detail::enable_if_t<detail::array_info<T>::is_array>> {
-    static std::string format() {
-        using detail::_;
-        PYBIND11_DESCR extents = _("(") + detail::array_info<T>::extents() + _(")");
-        return extents.text() + format_descriptor<detail::remove_all_extents_t<T>>::format();
-    }
-};
-
-NAMESPACE_BEGIN(detail)
-template <typename T, int ExtraFlags>
-struct pyobject_caster<array_t<T, ExtraFlags>> {
-    using type = array_t<T, ExtraFlags>;
-
-    bool load(handle src, bool convert) {
-        if (!convert && !type::check_(src))
-            return false;
-        value = type::ensure(src);
-        return static_cast<bool>(value);
-    }
-
-    static handle cast(const handle &src, return_value_policy /* policy */, handle /* parent */) {
-        return src.inc_ref();
-    }
-    PYBIND11_TYPE_CASTER(type, handle_type_name<type>::name());
-};
-
-template <typename T>
-struct compare_buffer_info<T, detail::enable_if_t<detail::is_pod_struct<T>::value>> {
-    static bool compare(const buffer_info& b) {
-        return npy_api::get().PyArray_EquivTypes_(dtype::of<T>().ptr(), dtype(b).ptr());
-    }
-};
-
-template <typename T> struct npy_format_descriptor<T, enable_if_t<satisfies_any_of<T, std::is_arithmetic, is_complex>::value>> {
-private:
-    // NB: the order here must match the one in common.h
-    constexpr static const int values[15] = {
-        npy_api::NPY_BOOL_,
-        npy_api::NPY_BYTE_,   npy_api::NPY_UBYTE_,   npy_api::NPY_SHORT_,    npy_api::NPY_USHORT_,
-        npy_api::NPY_INT_,    npy_api::NPY_UINT_,    npy_api::NPY_LONGLONG_, npy_api::NPY_ULONGLONG_,
-        npy_api::NPY_FLOAT_,  npy_api::NPY_DOUBLE_,  npy_api::NPY_LONGDOUBLE_,
-        npy_api::NPY_CFLOAT_, npy_api::NPY_CDOUBLE_, npy_api::NPY_CLONGDOUBLE_
-    };
-
-public:
-    static constexpr int value = values[detail::is_fmt_numeric<T>::index];
-
-    static pybind11::dtype dtype() {
-        if (auto ptr = npy_api::get().PyArray_DescrFromType_(value))
-            return reinterpret_borrow<pybind11::dtype>(ptr);
-        pybind11_fail("Unsupported buffer format!");
-    }
-    template <typename T2 = T, enable_if_t<std::is_integral<T2>::value, int> = 0>
-    static PYBIND11_DESCR name() {
-        return _<std::is_same<T, bool>::value>(_("bool"),
-            _<std::is_signed<T>::value>("int", "uint") + _<sizeof(T)*8>());
-    }
-    template <typename T2 = T, enable_if_t<std::is_floating_point<T2>::value, int> = 0>
-    static PYBIND11_DESCR name() {
-        return _<std::is_same<T, float>::value || std::is_same<T, double>::value>(
-                _("float") + _<sizeof(T)*8>(), _("longdouble"));
-    }
-    template <typename T2 = T, enable_if_t<is_complex<T2>::value, int> = 0>
-    static PYBIND11_DESCR name() {
-        return _<std::is_same<typename T2::value_type, float>::value || std::is_same<typename T2::value_type, double>::value>(
-                _("complex") + _<sizeof(typename T2::value_type)*16>(), _("longcomplex"));
-    }
-};
-
-#define PYBIND11_DECL_CHAR_FMT \
-    static PYBIND11_DESCR name() { return _("S") + _<N>(); } \
-    static pybind11::dtype dtype() { return pybind11::dtype(std::string("S") + std::to_string(N)); }
-template <size_t N> struct npy_format_descriptor<char[N]> { PYBIND11_DECL_CHAR_FMT };
-template <size_t N> struct npy_format_descriptor<std::array<char, N>> { PYBIND11_DECL_CHAR_FMT };
-#undef PYBIND11_DECL_CHAR_FMT
-
-template<typename T> struct npy_format_descriptor<T, enable_if_t<array_info<T>::is_array>> {
-private:
-    using base_descr = npy_format_descriptor<typename array_info<T>::type>;
-public:
-    static_assert(!array_info<T>::is_empty, "Zero-sized arrays are not supported");
-
-    static PYBIND11_DESCR name() { return _("(") + array_info<T>::extents() + _(")") + base_descr::name(); }
-    static pybind11::dtype dtype() {
-        list shape;
-        array_info<T>::append_extents(shape);
-        return pybind11::dtype::from_args(pybind11::make_tuple(base_descr::dtype(), shape));
-    }
-};
-
-template<typename T> struct npy_format_descriptor<T, enable_if_t<std::is_enum<T>::value>> {
-private:
-    using base_descr = npy_format_descriptor<typename std::underlying_type<T>::type>;
-public:
-    static PYBIND11_DESCR name() { return base_descr::name(); }
-    static pybind11::dtype dtype() { return base_descr::dtype(); }
-};
-
-struct field_descriptor {
-    const char *name;
-    ssize_t offset;
-    ssize_t size;
-    std::string format;
-    dtype descr;
-};
-
-inline PYBIND11_NOINLINE void register_structured_dtype(
-    const std::initializer_list<field_descriptor>& fields,
-    const std::type_info& tinfo, ssize_t itemsize,
-    bool (*direct_converter)(PyObject *, void *&)) {
-
-    auto& numpy_internals = get_numpy_internals();
-    if (numpy_internals.get_type_info(tinfo, false))
-        pybind11_fail("NumPy: dtype is already registered");
-
-    list names, formats, offsets;
-    for (auto field : fields) {
-        if (!field.descr)
-            pybind11_fail(std::string("NumPy: unsupported field dtype: `") +
-                            field.name + "` @ " + tinfo.name());
-        names.append(PYBIND11_STR_TYPE(field.name));
-        formats.append(field.descr);
-        offsets.append(pybind11::int_(field.offset));
-    }
-    auto dtype_ptr = pybind11::dtype(names, formats, offsets, itemsize).release().ptr();
-
-    // There is an existing bug in NumPy (as of v1.11): trailing bytes are
-    // not encoded explicitly into the format string. This will supposedly
-    // get fixed in v1.12; for further details, see these:
-    // - https://github.com/numpy/numpy/issues/7797
-    // - https://github.com/numpy/numpy/pull/7798
-    // Because of this, we won't use numpy's logic to generate buffer format
-    // strings and will just do it ourselves.
-    std::vector<field_descriptor> ordered_fields(fields);
-    std::sort(ordered_fields.begin(), ordered_fields.end(),
-        [](const field_descriptor &a, const field_descriptor &b) { return a.offset < b.offset; });
-    ssize_t offset = 0;
-    std::ostringstream oss;
-    // mark the structure as unaligned with '^', because numpy and C++ don't
-    // always agree about alignment (particularly for complex), and we're
-    // explicitly listing all our padding. This depends on none of the fields
-    // overriding the endianness. Putting the ^ in front of individual fields
-    // isn't guaranteed to work due to https://github.com/numpy/numpy/issues/9049
-    oss << "^T{";
-    for (auto& field : ordered_fields) {
-        if (field.offset > offset)
-            oss << (field.offset - offset) << 'x';
-        oss << field.format << ':' << field.name << ':';
-        offset = field.offset + field.size;
-    }
-    if (itemsize > offset)
-        oss << (itemsize - offset) << 'x';
-    oss << '}';
-    auto format_str = oss.str();
-
-    // Sanity check: verify that NumPy properly parses our buffer format string
-    auto& api = npy_api::get();
-    auto arr =  array(buffer_info(nullptr, itemsize, format_str, 1));
-    if (!api.PyArray_EquivTypes_(dtype_ptr, arr.dtype().ptr()))
-        pybind11_fail("NumPy: invalid buffer descriptor!");
-
-    auto tindex = std::type_index(tinfo);
-    numpy_internals.registered_dtypes[tindex] = { dtype_ptr, format_str };
-    get_internals().direct_conversions[tindex].push_back(direct_converter);
-}
-
-template <typename T, typename SFINAE> struct npy_format_descriptor {
-    static_assert(is_pod_struct<T>::value, "Attempt to use a non-POD or unimplemented POD type as a numpy dtype");
-
-    static PYBIND11_DESCR name() { return make_caster<T>::name(); }
-
-    static pybind11::dtype dtype() {
-        return reinterpret_borrow<pybind11::dtype>(dtype_ptr());
-    }
-
-    static std::string format() {
-        static auto format_str = get_numpy_internals().get_type_info<T>(true)->format_str;
-        return format_str;
-    }
-
-    static void register_dtype(const std::initializer_list<field_descriptor>& fields) {
-        register_structured_dtype(fields, typeid(typename std::remove_cv<T>::type),
-                                  sizeof(T), &direct_converter);
-    }
-
-private:
-    static PyObject* dtype_ptr() {
-        static PyObject* ptr = get_numpy_internals().get_type_info<T>(true)->dtype_ptr;
-        return ptr;
-    }
-
-    static bool direct_converter(PyObject *obj, void*& value) {
-        auto& api = npy_api::get();
-        if (!PyObject_TypeCheck(obj, api.PyVoidArrType_Type_))
-            return false;
-        if (auto descr = reinterpret_steal<object>(api.PyArray_DescrFromScalar_(obj))) {
-            if (api.PyArray_EquivTypes_(dtype_ptr(), descr.ptr())) {
-                value = ((PyVoidScalarObject_Proxy *) obj)->obval;
-                return true;
-            }
-        }
-        return false;
-    }
-};
-
-#ifdef __CLION_IDE__ // replace heavy macro with dummy code for the IDE (doesn't affect code)
-# define PYBIND11_NUMPY_DTYPE(Type, ...) ((void)0)
-# define PYBIND11_NUMPY_DTYPE_EX(Type, ...) ((void)0)
-#else
-
-#define PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, Name)                                          \
-    ::pybind11::detail::field_descriptor {                                                    \
-        Name, offsetof(T, Field), sizeof(decltype(std::declval<T>().Field)),                  \
-        ::pybind11::format_descriptor<decltype(std::declval<T>().Field)>::format(),           \
-        ::pybind11::detail::npy_format_descriptor<decltype(std::declval<T>().Field)>::dtype() \
-    }
-
-// Extract name, offset and format descriptor for a struct field
-#define PYBIND11_FIELD_DESCRIPTOR(T, Field) PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, #Field)
-
-// The main idea of this macro is borrowed from https://github.com/swansontec/map-macro
-// (C) William Swanson, Paul Fultz
-#define PYBIND11_EVAL0(...) __VA_ARGS__
-#define PYBIND11_EVAL1(...) PYBIND11_EVAL0 (PYBIND11_EVAL0 (PYBIND11_EVAL0 (__VA_ARGS__)))
-#define PYBIND11_EVAL2(...) PYBIND11_EVAL1 (PYBIND11_EVAL1 (PYBIND11_EVAL1 (__VA_ARGS__)))
-#define PYBIND11_EVAL3(...) PYBIND11_EVAL2 (PYBIND11_EVAL2 (PYBIND11_EVAL2 (__VA_ARGS__)))
-#define PYBIND11_EVAL4(...) PYBIND11_EVAL3 (PYBIND11_EVAL3 (PYBIND11_EVAL3 (__VA_ARGS__)))
-#define PYBIND11_EVAL(...)  PYBIND11_EVAL4 (PYBIND11_EVAL4 (PYBIND11_EVAL4 (__VA_ARGS__)))
-#define PYBIND11_MAP_END(...)
-#define PYBIND11_MAP_OUT
-#define PYBIND11_MAP_COMMA ,
-#define PYBIND11_MAP_GET_END() 0, PYBIND11_MAP_END
-#define PYBIND11_MAP_NEXT0(test, next, ...) next PYBIND11_MAP_OUT
-#define PYBIND11_MAP_NEXT1(test, next) PYBIND11_MAP_NEXT0 (test, next, 0)
-#define PYBIND11_MAP_NEXT(test, next)  PYBIND11_MAP_NEXT1 (PYBIND11_MAP_GET_END test, next)
-#ifdef _MSC_VER // MSVC is not as eager to expand macros, hence this workaround
-#define PYBIND11_MAP_LIST_NEXT1(test, next) \
-    PYBIND11_EVAL0 (PYBIND11_MAP_NEXT0 (test, PYBIND11_MAP_COMMA next, 0))
-#else
-#define PYBIND11_MAP_LIST_NEXT1(test, next) \
-    PYBIND11_MAP_NEXT0 (test, PYBIND11_MAP_COMMA next, 0)
-#endif
-#define PYBIND11_MAP_LIST_NEXT(test, next) \
-    PYBIND11_MAP_LIST_NEXT1 (PYBIND11_MAP_GET_END test, next)
-#define PYBIND11_MAP_LIST0(f, t, x, peek, ...) \
-    f(t, x) PYBIND11_MAP_LIST_NEXT (peek, PYBIND11_MAP_LIST1) (f, t, peek, __VA_ARGS__)
-#define PYBIND11_MAP_LIST1(f, t, x, peek, ...) \
-    f(t, x) PYBIND11_MAP_LIST_NEXT (peek, PYBIND11_MAP_LIST0) (f, t, peek, __VA_ARGS__)
-// PYBIND11_MAP_LIST(f, t, a1, a2, ...) expands to f(t, a1), f(t, a2), ...
-#define PYBIND11_MAP_LIST(f, t, ...) \
-    PYBIND11_EVAL (PYBIND11_MAP_LIST1 (f, t, __VA_ARGS__, (), 0))
-
-#define PYBIND11_NUMPY_DTYPE(Type, ...) \
-    ::pybind11::detail::npy_format_descriptor<Type>::register_dtype \
-        ({PYBIND11_MAP_LIST (PYBIND11_FIELD_DESCRIPTOR, Type, __VA_ARGS__)})
-
-#ifdef _MSC_VER
-#define PYBIND11_MAP2_LIST_NEXT1(test, next) \
-    PYBIND11_EVAL0 (PYBIND11_MAP_NEXT0 (test, PYBIND11_MAP_COMMA next, 0))
-#else
-#define PYBIND11_MAP2_LIST_NEXT1(test, next) \
-    PYBIND11_MAP_NEXT0 (test, PYBIND11_MAP_COMMA next, 0)
-#endif
-#define PYBIND11_MAP2_LIST_NEXT(test, next) \
-    PYBIND11_MAP2_LIST_NEXT1 (PYBIND11_MAP_GET_END test, next)
-#define PYBIND11_MAP2_LIST0(f, t, x1, x2, peek, ...) \
-    f(t, x1, x2) PYBIND11_MAP2_LIST_NEXT (peek, PYBIND11_MAP2_LIST1) (f, t, peek, __VA_ARGS__)
-#define PYBIND11_MAP2_LIST1(f, t, x1, x2, peek, ...) \
-    f(t, x1, x2) PYBIND11_MAP2_LIST_NEXT (peek, PYBIND11_MAP2_LIST0) (f, t, peek, __VA_ARGS__)
-// PYBIND11_MAP2_LIST(f, t, a1, a2, ...) expands to f(t, a1, a2), f(t, a3, a4), ...
-#define PYBIND11_MAP2_LIST(f, t, ...) \
-    PYBIND11_EVAL (PYBIND11_MAP2_LIST1 (f, t, __VA_ARGS__, (), 0))
-
-#define PYBIND11_NUMPY_DTYPE_EX(Type, ...) \
-    ::pybind11::detail::npy_format_descriptor<Type>::register_dtype \
-        ({PYBIND11_MAP2_LIST (PYBIND11_FIELD_DESCRIPTOR_EX, Type, __VA_ARGS__)})
-
-#endif // __CLION_IDE__
-
-template  <class T>
-using array_iterator = typename std::add_pointer<T>::type;
-
-template <class T>
-array_iterator<T> array_begin(const buffer_info& buffer) {
-    return array_iterator<T>(reinterpret_cast<T*>(buffer.ptr));
-}
-
-template <class T>
-array_iterator<T> array_end(const buffer_info& buffer) {
-    return array_iterator<T>(reinterpret_cast<T*>(buffer.ptr) + buffer.size);
-}
-
-class common_iterator {
-public:
-    using container_type = std::vector<ssize_t>;
-    using value_type = container_type::value_type;
-    using size_type = container_type::size_type;
-
-    common_iterator() : p_ptr(0), m_strides() {}
-
-    common_iterator(void* ptr, const container_type& strides, const container_type& shape)
-        : p_ptr(reinterpret_cast<char*>(ptr)), m_strides(strides.size()) {
-        m_strides.back() = static_cast<value_type>(strides.back());
-        for (size_type i = m_strides.size() - 1; i != 0; --i) {
-            size_type j = i - 1;
-            value_type s = static_cast<value_type>(shape[i]);
-            m_strides[j] = strides[j] + m_strides[i] - strides[i] * s;
-        }
-    }
-
-    void increment(size_type dim) {
-        p_ptr += m_strides[dim];
-    }
-
-    void* data() const {
-        return p_ptr;
-    }
-
-private:
-    char* p_ptr;
-    container_type m_strides;
-};
-
-template <size_t N> class multi_array_iterator {
-public:
-    using container_type = std::vector<ssize_t>;
-
-    multi_array_iterator(const std::array<buffer_info, N> &buffers,
-                         const container_type &shape)
-        : m_shape(shape.size()), m_index(shape.size(), 0),
-          m_common_iterator() {
-
-        // Manual copy to avoid conversion warning if using std::copy
-        for (size_t i = 0; i < shape.size(); ++i)
-            m_shape[i] = shape[i];
-
-        container_type strides(shape.size());
-        for (size_t i = 0; i < N; ++i)
-            init_common_iterator(buffers[i], shape, m_common_iterator[i], strides);
-    }
-
-    multi_array_iterator& operator++() {
-        for (size_t j = m_index.size(); j != 0; --j) {
-            size_t i = j - 1;
-            if (++m_index[i] != m_shape[i]) {
-                increment_common_iterator(i);
-                break;
-            } else {
-                m_index[i] = 0;
-            }
-        }
-        return *this;
-    }
-
-    template <size_t K, class T = void> T* data() const {
-        return reinterpret_cast<T*>(m_common_iterator[K].data());
-    }
-
-private:
-
-    using common_iter = common_iterator;
-
-    void init_common_iterator(const buffer_info &buffer,
-                              const container_type &shape,
-                              common_iter &iterator,
-                              container_type &strides) {
-        auto buffer_shape_iter = buffer.shape.rbegin();
-        auto buffer_strides_iter = buffer.strides.rbegin();
-        auto shape_iter = shape.rbegin();
-        auto strides_iter = strides.rbegin();
-
-        while (buffer_shape_iter != buffer.shape.rend()) {
-            if (*shape_iter == *buffer_shape_iter)
-                *strides_iter = *buffer_strides_iter;
-            else
-                *strides_iter = 0;
-
-            ++buffer_shape_iter;
-            ++buffer_strides_iter;
-            ++shape_iter;
-            ++strides_iter;
-        }
-
-        std::fill(strides_iter, strides.rend(), 0);
-        iterator = common_iter(buffer.ptr, strides, shape);
-    }
-
-    void increment_common_iterator(size_t dim) {
-        for (auto &iter : m_common_iterator)
-            iter.increment(dim);
-    }
-
-    container_type m_shape;
-    container_type m_index;
-    std::array<common_iter, N> m_common_iterator;
-};
-
-enum class broadcast_trivial { non_trivial, c_trivial, f_trivial };
-
-// Populates the shape and number of dimensions for the set of buffers.  Returns a broadcast_trivial
-// enum value indicating whether the broadcast is "trivial"--that is, has each buffer being either a
-// singleton or a full-size, C-contiguous (`c_trivial`) or Fortran-contiguous (`f_trivial`) storage
-// buffer; returns `non_trivial` otherwise.
-template <size_t N>
-broadcast_trivial broadcast(const std::array<buffer_info, N> &buffers, ssize_t &ndim, std::vector<ssize_t> &shape) {
-    ndim = std::accumulate(buffers.begin(), buffers.end(), ssize_t(0), [](ssize_t res, const buffer_info &buf) {
-        return std::max(res, buf.ndim);
-    });
-
-    shape.clear();
-    shape.resize((size_t) ndim, 1);
-
-    // Figure out the output size, and make sure all input arrays conform (i.e. are either size 1 or
-    // the full size).
-    for (size_t i = 0; i < N; ++i) {
-        auto res_iter = shape.rbegin();
-        auto end = buffers[i].shape.rend();
-        for (auto shape_iter = buffers[i].shape.rbegin(); shape_iter != end; ++shape_iter, ++res_iter) {
-            const auto &dim_size_in = *shape_iter;
-            auto &dim_size_out = *res_iter;
-
-            // Each input dimension can either be 1 or `n`, but `n` values must match across buffers
-            if (dim_size_out == 1)
-                dim_size_out = dim_size_in;
-            else if (dim_size_in != 1 && dim_size_in != dim_size_out)
-                pybind11_fail("pybind11::vectorize: incompatible size/dimension of inputs!");
-        }
-    }
-
-    bool trivial_broadcast_c = true;
-    bool trivial_broadcast_f = true;
-    for (size_t i = 0; i < N && (trivial_broadcast_c || trivial_broadcast_f); ++i) {
-        if (buffers[i].size == 1)
-            continue;
-
-        // Require the same number of dimensions:
-        if (buffers[i].ndim != ndim)
-            return broadcast_trivial::non_trivial;
-
-        // Require all dimensions be full-size:
-        if (!std::equal(buffers[i].shape.cbegin(), buffers[i].shape.cend(), shape.cbegin()))
-            return broadcast_trivial::non_trivial;
-
-        // Check for C contiguity (but only if previous inputs were also C contiguous)
-        if (trivial_broadcast_c) {
-            ssize_t expect_stride = buffers[i].itemsize;
-            auto end = buffers[i].shape.crend();
-            for (auto shape_iter = buffers[i].shape.crbegin(), stride_iter = buffers[i].strides.crbegin();
-                    trivial_broadcast_c && shape_iter != end; ++shape_iter, ++stride_iter) {
-                if (expect_stride == *stride_iter)
-                    expect_stride *= *shape_iter;
-                else
-                    trivial_broadcast_c = false;
-            }
-        }
-
-        // Check for Fortran contiguity (if previous inputs were also F contiguous)
-        if (trivial_broadcast_f) {
-            ssize_t expect_stride = buffers[i].itemsize;
-            auto end = buffers[i].shape.cend();
-            for (auto shape_iter = buffers[i].shape.cbegin(), stride_iter = buffers[i].strides.cbegin();
-                    trivial_broadcast_f && shape_iter != end; ++shape_iter, ++stride_iter) {
-                if (expect_stride == *stride_iter)
-                    expect_stride *= *shape_iter;
-                else
-                    trivial_broadcast_f = false;
-            }
-        }
-    }
-
-    return
-        trivial_broadcast_c ? broadcast_trivial::c_trivial :
-        trivial_broadcast_f ? broadcast_trivial::f_trivial :
-        broadcast_trivial::non_trivial;
-}
-
-template <typename T>
-struct vectorize_arg {
-    static_assert(!std::is_rvalue_reference<T>::value, "Functions with rvalue reference arguments cannot be vectorized");
-    // The wrapped function gets called with this type:
-    using call_type = remove_reference_t<T>;
-    // Is this a vectorized argument?
-    static constexpr bool vectorize =
-        satisfies_any_of<call_type, std::is_arithmetic, is_complex, std::is_pod>::value &&
-        satisfies_none_of<call_type, std::is_pointer, std::is_array, is_std_array, std::is_enum>::value &&
-        (!std::is_reference<T>::value ||
-         (std::is_lvalue_reference<T>::value && std::is_const<call_type>::value));
-    // Accept this type: an array for vectorized types, otherwise the type as-is:
-    using type = conditional_t<vectorize, array_t<remove_cv_t<call_type>, array::forcecast>, T>;
-};
-
-template <typename Func, typename Return, typename... Args>
-struct vectorize_helper {
-private:
-    static constexpr size_t N = sizeof...(Args);
-    static constexpr size_t NVectorized = constexpr_sum(vectorize_arg<Args>::vectorize...);
-    static_assert(NVectorized >= 1,
-            "pybind11::vectorize(...) requires a function with at least one vectorizable argument");
-
-public:
-    template <typename T>
-    explicit vectorize_helper(T &&f) : f(std::forward<T>(f)) { }
-
-    object operator()(typename vectorize_arg<Args>::type... args) {
-        return run(args...,
-                   make_index_sequence<N>(),
-                   select_indices<vectorize_arg<Args>::vectorize...>(),
-                   make_index_sequence<NVectorized>());
-    }
-
-private:
-    remove_reference_t<Func> f;
-
-    template <size_t Index> using param_n_t = typename pack_element<Index, typename vectorize_arg<Args>::call_type...>::type;
-
-    // Runs a vectorized function given arguments tuple and three index sequences:
-    //     - Index is the full set of 0 ... (N-1) argument indices;
-    //     - VIndex is the subset of argument indices with vectorized parameters, letting us access
-    //       vectorized arguments (anything not in this sequence is passed through)
-    //     - BIndex is a incremental sequence (beginning at 0) of the same size as VIndex, so that
-    //       we can store vectorized buffer_infos in an array (argument VIndex has its buffer at
-    //       index BIndex in the array).
-    template <size_t... Index, size_t... VIndex, size_t... BIndex> object run(
-            typename vectorize_arg<Args>::type &...args,
-            index_sequence<Index...> i_seq, index_sequence<VIndex...> vi_seq, index_sequence<BIndex...> bi_seq) {
-
-        // Pointers to values the function was called with; the vectorized ones set here will start
-        // out as array_t<T> pointers, but they will be changed them to T pointers before we make
-        // call the wrapped function.  Non-vectorized pointers are left as-is.
-        std::array<void *, N> params{{ &args... }};
-
-        // The array of `buffer_info`s of vectorized arguments:
-        std::array<buffer_info, NVectorized> buffers{{ reinterpret_cast<array *>(params[VIndex])->request()... }};
-
-        /* Determine dimensions parameters of output array */
-        ssize_t nd = 0;
-        std::vector<ssize_t> shape(0);
-        auto trivial = broadcast(buffers, nd, shape);
-        size_t ndim = (size_t) nd;
-
-        size_t size = std::accumulate(shape.begin(), shape.end(), (size_t) 1, std::multiplies<size_t>());
-
-        // If all arguments are 0-dimension arrays (i.e. single values) return a plain value (i.e.
-        // not wrapped in an array).
-        if (size == 1 && ndim == 0) {
-            PYBIND11_EXPAND_SIDE_EFFECTS(params[VIndex] = buffers[BIndex].ptr);
-            return cast(f(*reinterpret_cast<param_n_t<Index> *>(params[Index])...));
-        }
-
-        array_t<Return> result;
-        if (trivial == broadcast_trivial::f_trivial) result = array_t<Return, array::f_style>(shape);
-        else result = array_t<Return>(shape);
-
-        if (size == 0) return result;
-
-        /* Call the function */
-        if (trivial == broadcast_trivial::non_trivial)
-            apply_broadcast(buffers, params, result, i_seq, vi_seq, bi_seq);
-        else
-            apply_trivial(buffers, params, result.mutable_data(), size, i_seq, vi_seq, bi_seq);
-
-        return result;
-    }
-
-    template <size_t... Index, size_t... VIndex, size_t... BIndex>
-    void apply_trivial(std::array<buffer_info, NVectorized> &buffers,
-                       std::array<void *, N> &params,
-                       Return *out,
-                       size_t size,
-                       index_sequence<Index...>, index_sequence<VIndex...>, index_sequence<BIndex...>) {
-
-        // Initialize an array of mutable byte references and sizes with references set to the
-        // appropriate pointer in `params`; as we iterate, we'll increment each pointer by its size
-        // (except for singletons, which get an increment of 0).
-        std::array<std::pair<unsigned char *&, const size_t>, NVectorized> vecparams{{
-            std::pair<unsigned char *&, const size_t>(
-                    reinterpret_cast<unsigned char *&>(params[VIndex] = buffers[BIndex].ptr),
-                    buffers[BIndex].size == 1 ? 0 : sizeof(param_n_t<VIndex>)
-            )...
-        }};
-
-        for (size_t i = 0; i < size; ++i) {
-            out[i] = f(*reinterpret_cast<param_n_t<Index> *>(params[Index])...);
-            for (auto &x : vecparams) x.first += x.second;
-        }
-    }
-
-    template <size_t... Index, size_t... VIndex, size_t... BIndex>
-    void apply_broadcast(std::array<buffer_info, NVectorized> &buffers,
-                         std::array<void *, N> &params,
-                         array_t<Return> &output_array,
-                         index_sequence<Index...>, index_sequence<VIndex...>, index_sequence<BIndex...>) {
-
-        buffer_info output = output_array.request();
-        multi_array_iterator<NVectorized> input_iter(buffers, output.shape);
-
-        for (array_iterator<Return> iter = array_begin<Return>(output), end = array_end<Return>(output);
-             iter != end;
-             ++iter, ++input_iter) {
-            PYBIND11_EXPAND_SIDE_EFFECTS((
-                params[VIndex] = input_iter.template data<BIndex>()
-            ));
-            *iter = f(*reinterpret_cast<param_n_t<Index> *>(std::get<Index>(params))...);
-        }
-    }
-};
-
-template <typename Func, typename Return, typename... Args>
-vectorize_helper<Func, Return, Args...>
-vectorize_extractor(const Func &f, Return (*) (Args ...)) {
-    return detail::vectorize_helper<Func, Return, Args...>(f);
-}
-
-template <typename T, int Flags> struct handle_type_name<array_t<T, Flags>> {
-    static PYBIND11_DESCR name() {
-        return _("numpy.ndarray[") + npy_format_descriptor<T>::name() + _("]");
-    }
-};
-
-NAMESPACE_END(detail)
-
-// Vanilla pointer vectorizer:
-template <typename Return, typename... Args>
-detail::vectorize_helper<Return (*)(Args...), Return, Args...>
-vectorize(Return (*f) (Args ...)) {
-    return detail::vectorize_helper<Return (*)(Args...), Return, Args...>(f);
-}
-
-// lambda vectorizer:
-template <typename Func, detail::enable_if_t<detail::is_lambda<Func>::value, int> = 0>
-auto vectorize(Func &&f) -> decltype(
-        detail::vectorize_extractor(std::forward<Func>(f), (detail::function_signature_t<Func> *) nullptr)) {
-    return detail::vectorize_extractor(std::forward<Func>(f), (detail::function_signature_t<Func> *) nullptr);
-}
-
-// Vectorize a class method (non-const):
-template <typename Return, typename Class, typename... Args,
-          typename Helper = detail::vectorize_helper<decltype(std::mem_fn(std::declval<Return (Class::*)(Args...)>())), Return, Class *, Args...>>
-Helper vectorize(Return (Class::*f)(Args...)) {
-    return Helper(std::mem_fn(f));
-}
-
-// Vectorize a class method (non-const):
-template <typename Return, typename Class, typename... Args,
-          typename Helper = detail::vectorize_helper<decltype(std::mem_fn(std::declval<Return (Class::*)(Args...) const>())), Return, const Class *, Args...>>
-Helper vectorize(Return (Class::*f)(Args...) const) {
-    return Helper(std::mem_fn(f));
-}
-
-NAMESPACE_END(PYBIND11_NAMESPACE)
-
-#if defined(_MSC_VER)
-#pragma warning(pop)
-#endif
diff --git a/tmap/lib/pybind11/include/pybind11/operators.h b/tmap/lib/pybind11/include/pybind11/operators.h
deleted file mode 100644
index b3dd62c..0000000
--- a/tmap/lib/pybind11/include/pybind11/operators.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
-    pybind11/operator.h: Metatemplates for operator overloading
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "pybind11.h"
-
-#if defined(__clang__) && !defined(__INTEL_COMPILER)
-#  pragma clang diagnostic ignored "-Wunsequenced" // multiple unsequenced modifications to 'self' (when using def(py::self OP Type()))
-#elif defined(_MSC_VER)
-#  pragma warning(push)
-#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#endif
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
-
-/// Enumeration with all supported operator types
-enum op_id : int {
-    op_add, op_sub, op_mul, op_div, op_mod, op_divmod, op_pow, op_lshift,
-    op_rshift, op_and, op_xor, op_or, op_neg, op_pos, op_abs, op_invert,
-    op_int, op_long, op_float, op_str, op_cmp, op_gt, op_ge, op_lt, op_le,
-    op_eq, op_ne, op_iadd, op_isub, op_imul, op_idiv, op_imod, op_ilshift,
-    op_irshift, op_iand, op_ixor, op_ior, op_complex, op_bool, op_nonzero,
-    op_repr, op_truediv, op_itruediv, op_hash
-};
-
-enum op_type : int {
-    op_l, /* base type on left */
-    op_r, /* base type on right */
-    op_u  /* unary operator */
-};
-
-struct self_t { };
-static const self_t self = self_t();
-
-/// Type for an unused type slot
-struct undefined_t { };
-
-/// Don't warn about an unused variable
-inline self_t __self() { return self; }
-
-/// base template of operator implementations
-template <op_id, op_type, typename B, typename L, typename R> struct op_impl { };
-
-/// Operator implementation generator
-template <op_id id, op_type ot, typename L, typename R> struct op_ {
-    template <typename Class, typename... Extra> void execute(Class &cl, const Extra&... extra) const {
-        using Base = typename Class::type;
-        using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;
-        using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;
-        using op = op_impl<id, ot, Base, L_type, R_type>;
-        cl.def(op::name(), &op::execute, is_operator(), extra...);
-        #if PY_MAJOR_VERSION < 3
-        if (id == op_truediv || id == op_itruediv)
-            cl.def(id == op_itruediv ? "__idiv__" : ot == op_l ? "__div__" : "__rdiv__",
-                    &op::execute, is_operator(), extra...);
-        #endif
-    }
-    template <typename Class, typename... Extra> void execute_cast(Class &cl, const Extra&... extra) const {
-        using Base = typename Class::type;
-        using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;
-        using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;
-        using op = op_impl<id, ot, Base, L_type, R_type>;
-        cl.def(op::name(), &op::execute_cast, is_operator(), extra...);
-        #if PY_MAJOR_VERSION < 3
-        if (id == op_truediv || id == op_itruediv)
-            cl.def(id == op_itruediv ? "__idiv__" : ot == op_l ? "__div__" : "__rdiv__",
-                    &op::execute, is_operator(), extra...);
-        #endif
-    }
-};
-
-#define PYBIND11_BINARY_OPERATOR(id, rid, op, expr)                                    \
-template <typename B, typename L, typename R> struct op_impl<op_##id, op_l, B, L, R> { \
-    static char const* name() { return "__" #id "__"; }                                \
-    static auto execute(const L &l, const R &r) -> decltype(expr) { return (expr); }   \
-    static B execute_cast(const L &l, const R &r) { return B(expr); }                  \
-};                                                                                     \
-template <typename B, typename L, typename R> struct op_impl<op_##id, op_r, B, L, R> { \
-    static char const* name() { return "__" #rid "__"; }                               \
-    static auto execute(const R &r, const L &l) -> decltype(expr) { return (expr); }   \
-    static B execute_cast(const R &r, const L &l) { return B(expr); }                  \
-};                                                                                     \
-inline op_<op_##id, op_l, self_t, self_t> op(const self_t &, const self_t &) {         \
-    return op_<op_##id, op_l, self_t, self_t>();                                       \
-}                                                                                      \
-template <typename T> op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {    \
-    return op_<op_##id, op_l, self_t, T>();                                            \
-}                                                                                      \
-template <typename T> op_<op_##id, op_r, T, self_t> op(const T &, const self_t &) {    \
-    return op_<op_##id, op_r, T, self_t>();                                            \
-}
-
-#define PYBIND11_INPLACE_OPERATOR(id, op, expr)                                        \
-template <typename B, typename L, typename R> struct op_impl<op_##id, op_l, B, L, R> { \
-    static char const* name() { return "__" #id "__"; }                                \
-    static auto execute(L &l, const R &r) -> decltype(expr) { return expr; }           \
-    static B execute_cast(L &l, const R &r) { return B(expr); }                        \
-};                                                                                     \
-template <typename T> op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {    \
-    return op_<op_##id, op_l, self_t, T>();                                            \
-}
-
-#define PYBIND11_UNARY_OPERATOR(id, op, expr)                                          \
-template <typename B, typename L> struct op_impl<op_##id, op_u, B, L, undefined_t> {   \
-    static char const* name() { return "__" #id "__"; }                                \
-    static auto execute(const L &l) -> decltype(expr) { return expr; }                 \
-    static B execute_cast(const L &l) { return B(expr); }                              \
-};                                                                                     \
-inline op_<op_##id, op_u, self_t, undefined_t> op(const self_t &) {                    \
-    return op_<op_##id, op_u, self_t, undefined_t>();                                  \
-}
-
-PYBIND11_BINARY_OPERATOR(sub,       rsub,         operator-,    l - r)
-PYBIND11_BINARY_OPERATOR(add,       radd,         operator+,    l + r)
-PYBIND11_BINARY_OPERATOR(mul,       rmul,         operator*,    l * r)
-PYBIND11_BINARY_OPERATOR(truediv,   rtruediv,     operator/,    l / r)
-PYBIND11_BINARY_OPERATOR(mod,       rmod,         operator%,    l % r)
-PYBIND11_BINARY_OPERATOR(lshift,    rlshift,      operator<<,   l << r)
-PYBIND11_BINARY_OPERATOR(rshift,    rrshift,      operator>>,   l >> r)
-PYBIND11_BINARY_OPERATOR(and,       rand,         operator&,    l & r)
-PYBIND11_BINARY_OPERATOR(xor,       rxor,         operator^,    l ^ r)
-PYBIND11_BINARY_OPERATOR(eq,        eq,           operator==,   l == r)
-PYBIND11_BINARY_OPERATOR(ne,        ne,           operator!=,   l != r)
-PYBIND11_BINARY_OPERATOR(or,        ror,          operator|,    l | r)
-PYBIND11_BINARY_OPERATOR(gt,        lt,           operator>,    l > r)
-PYBIND11_BINARY_OPERATOR(ge,        le,           operator>=,   l >= r)
-PYBIND11_BINARY_OPERATOR(lt,        gt,           operator<,    l < r)
-PYBIND11_BINARY_OPERATOR(le,        ge,           operator<=,   l <= r)
-//PYBIND11_BINARY_OPERATOR(pow,       rpow,         pow,          std::pow(l,  r))
-PYBIND11_INPLACE_OPERATOR(iadd,     operator+=,   l += r)
-PYBIND11_INPLACE_OPERATOR(isub,     operator-=,   l -= r)
-PYBIND11_INPLACE_OPERATOR(imul,     operator*=,   l *= r)
-PYBIND11_INPLACE_OPERATOR(itruediv, operator/=,   l /= r)
-PYBIND11_INPLACE_OPERATOR(imod,     operator%=,   l %= r)
-PYBIND11_INPLACE_OPERATOR(ilshift,  operator<<=,  l <<= r)
-PYBIND11_INPLACE_OPERATOR(irshift,  operator>>=,  l >>= r)
-PYBIND11_INPLACE_OPERATOR(iand,     operator&=,   l &= r)
-PYBIND11_INPLACE_OPERATOR(ixor,     operator^=,   l ^= r)
-PYBIND11_INPLACE_OPERATOR(ior,      operator|=,   l |= r)
-PYBIND11_UNARY_OPERATOR(neg,        operator-,    -l)
-PYBIND11_UNARY_OPERATOR(pos,        operator+,    +l)
-PYBIND11_UNARY_OPERATOR(abs,        abs,          std::abs(l))
-PYBIND11_UNARY_OPERATOR(hash,       hash,         std::hash<L>()(l))
-PYBIND11_UNARY_OPERATOR(invert,     operator~,    (~l))
-PYBIND11_UNARY_OPERATOR(bool,       operator!,    !!l)
-PYBIND11_UNARY_OPERATOR(int,        int_,         (int) l)
-PYBIND11_UNARY_OPERATOR(float,      float_,       (double) l)
-
-#undef PYBIND11_BINARY_OPERATOR
-#undef PYBIND11_INPLACE_OPERATOR
-#undef PYBIND11_UNARY_OPERATOR
-NAMESPACE_END(detail)
-
-using detail::self;
-
-NAMESPACE_END(PYBIND11_NAMESPACE)
-
-#if defined(_MSC_VER)
-#  pragma warning(pop)
-#endif
diff --git a/tmap/lib/pybind11/include/pybind11/options.h b/tmap/lib/pybind11/include/pybind11/options.h
deleted file mode 100644
index cc1e1f6..0000000
--- a/tmap/lib/pybind11/include/pybind11/options.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
-    pybind11/options.h: global settings that are configurable at runtime.
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "detail/common.h"
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-
-class options {
-public:
-
-    // Default RAII constructor, which leaves settings as they currently are.
-    options() : previous_state(global_state()) {}
-
-    // Class is non-copyable.
-    options(const options&) = delete;
-    options& operator=(const options&) = delete;
-
-    // Destructor, which restores settings that were in effect before.
-    ~options() {
-        global_state() = previous_state;
-    }
-
-    // Setter methods (affect the global state):
-
-    options& disable_user_defined_docstrings() & { global_state().show_user_defined_docstrings = false; return *this; }
-
-    options& enable_user_defined_docstrings() & { global_state().show_user_defined_docstrings = true; return *this; }
-
-    options& disable_function_signatures() & { global_state().show_function_signatures = false; return *this; }
-
-    options& enable_function_signatures() & { global_state().show_function_signatures = true; return *this; }
-
-    // Getter methods (return the global state):
-
-    static bool show_user_defined_docstrings() { return global_state().show_user_defined_docstrings; }
-
-    static bool show_function_signatures() { return global_state().show_function_signatures; }
-
-    // This type is not meant to be allocated on the heap.
-    void* operator new(size_t) = delete;
-
-private:
-
-    struct state {
-        bool show_user_defined_docstrings = true;  //< Include user-supplied texts in docstrings.
-        bool show_function_signatures = true;      //< Include auto-generated function signatures in docstrings.
-    };
-
-    static state &global_state() {
-        static state instance;
-        return instance;
-    }
-
-    state previous_state;
-};
-
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/pybind11.h b/tmap/lib/pybind11/include/pybind11/pybind11.h
deleted file mode 100644
index fbde332..0000000
--- a/tmap/lib/pybind11/include/pybind11/pybind11.h
+++ /dev/null
@@ -1,1937 +0,0 @@
-/*
-    pybind11/pybind11.h: Main header file of the C++11 python
-    binding generator library
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#if defined(_MSC_VER)
-#  pragma warning(push)
-#  pragma warning(disable: 4100) // warning C4100: Unreferenced formal parameter
-#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#  pragma warning(disable: 4512) // warning C4512: Assignment operator was implicitly defined as deleted
-#  pragma warning(disable: 4800) // warning C4800: 'int': forcing value to bool 'true' or 'false' (performance warning)
-#  pragma warning(disable: 4996) // warning C4996: The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name
-#  pragma warning(disable: 4702) // warning C4702: unreachable code
-#  pragma warning(disable: 4522) // warning C4522: multiple assignment operators specified
-#elif defined(__INTEL_COMPILER)
-#  pragma warning(push)
-#  pragma warning(disable: 68)    // integer conversion resulted in a change of sign
-#  pragma warning(disable: 186)   // pointless comparison of unsigned integer with zero
-#  pragma warning(disable: 878)   // incompatible exception specifications
-#  pragma warning(disable: 1334)  // the "template" keyword used for syntactic disambiguation may only be used within a template
-#  pragma warning(disable: 1682)  // implicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem)
-#  pragma warning(disable: 1875)  // offsetof applied to non-POD (Plain Old Data) types is nonstandard
-#  pragma warning(disable: 2196)  // warning #2196: routine is both "inline" and "noinline"
-#elif defined(__GNUG__) && !defined(__clang__)
-#  pragma GCC diagnostic push
-#  pragma GCC diagnostic ignored "-Wunused-but-set-parameter"
-#  pragma GCC diagnostic ignored "-Wunused-but-set-variable"
-#  pragma GCC diagnostic ignored "-Wmissing-field-initializers"
-#  pragma GCC diagnostic ignored "-Wstrict-aliasing"
-#  pragma GCC diagnostic ignored "-Wattributes"
-#  if __GNUC__ >= 7
-#    pragma GCC diagnostic ignored "-Wnoexcept-type"
-#  endif
-#endif
-
-#include "attr.h"
-#include "options.h"
-#include "detail/class.h"
-#include "detail/init.h"
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-
-/// Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object
-class cpp_function : public function {
-public:
-    cpp_function() { }
-
-    /// Construct a cpp_function from a vanilla function pointer
-    template <typename Return, typename... Args, typename... Extra>
-    cpp_function(Return (*f)(Args...), const Extra&... extra) {
-        initialize(f, f, extra...);
-    }
-
-    /// Construct a cpp_function from a lambda function (possibly with internal state)
-    template <typename Func, typename... Extra,
-              typename = detail::enable_if_t<detail::is_lambda<Func>::value>>
-    cpp_function(Func &&f, const Extra&... extra) {
-        initialize(std::forward<Func>(f),
-                   (detail::function_signature_t<Func> *) nullptr, extra...);
-    }
-
-    /// Construct a cpp_function from a class method (non-const)
-    template <typename Return, typename Class, typename... Arg, typename... Extra>
-    cpp_function(Return (Class::*f)(Arg...), const Extra&... extra) {
-        initialize([f](Class *c, Arg... args) -> Return { return (c->*f)(args...); },
-                   (Return (*) (Class *, Arg...)) nullptr, extra...);
-    }
-
-    /// Construct a cpp_function from a class method (const)
-    template <typename Return, typename Class, typename... Arg, typename... Extra>
-    cpp_function(Return (Class::*f)(Arg...) const, const Extra&... extra) {
-        initialize([f](const Class *c, Arg... args) -> Return { return (c->*f)(args...); },
-                   (Return (*)(const Class *, Arg ...)) nullptr, extra...);
-    }
-
-    /// Return the function name
-    object name() const { return attr("__name__"); }
-
-protected:
-    /// Space optimization: don't inline this frequently instantiated fragment
-    PYBIND11_NOINLINE detail::function_record *make_function_record() {
-        return new detail::function_record();
-    }
-
-    /// Special internal constructor for functors, lambda functions, etc.
-    template <typename Func, typename Return, typename... Args, typename... Extra>
-    void initialize(Func &&f, Return (*)(Args...), const Extra&... extra) {
-
-        struct capture { detail::remove_reference_t<Func> f; };
-
-        /* Store the function including any extra state it might have (e.g. a lambda capture object) */
-        auto rec = make_function_record();
-
-        /* Store the capture object directly in the function record if there is enough space */
-        if (sizeof(capture) <= sizeof(rec->data)) {
-            /* Without these pragmas, GCC warns that there might not be
-               enough space to use the placement new operator. However, the
-               'if' statement above ensures that this is the case. */
-#if defined(__GNUG__) && !defined(__clang__) && __GNUC__ >= 6
-#  pragma GCC diagnostic push
-#  pragma GCC diagnostic ignored "-Wplacement-new"
-#endif
-            new ((capture *) &rec->data) capture { std::forward<Func>(f) };
-#if defined(__GNUG__) && !defined(__clang__) && __GNUC__ >= 6
-#  pragma GCC diagnostic pop
-#endif
-            if (!std::is_trivially_destructible<Func>::value)
-                rec->free_data = [](detail::function_record *r) { ((capture *) &r->data)->~capture(); };
-        } else {
-            rec->data[0] = new capture { std::forward<Func>(f) };
-            rec->free_data = [](detail::function_record *r) { delete ((capture *) r->data[0]); };
-        }
-
-        /* Type casters for the function arguments and return value */
-        using cast_in = detail::argument_loader<Args...>;
-        using cast_out = detail::make_caster<
-            detail::conditional_t<std::is_void<Return>::value, detail::void_type, Return>
-        >;
-
-        static_assert(detail::expected_num_args<Extra...>(sizeof...(Args), cast_in::has_args, cast_in::has_kwargs),
-                      "The number of argument annotations does not match the number of function arguments");
-
-        /* Dispatch code which converts function arguments and performs the actual function call */
-        rec->impl = [](detail::function_call &call) -> handle {
-            cast_in args_converter;
-
-            /* Try to cast the function arguments into the C++ domain */
-            if (!args_converter.load_args(call))
-                return PYBIND11_TRY_NEXT_OVERLOAD;
-
-            /* Invoke call policy pre-call hook */
-            detail::process_attributes<Extra...>::precall(call);
-
-            /* Get a pointer to the capture object */
-            auto data = (sizeof(capture) <= sizeof(call.func.data)
-                         ? &call.func.data : call.func.data[0]);
-            capture *cap = const_cast<capture *>(reinterpret_cast<const capture *>(data));
-
-            /* Override policy for rvalues -- usually to enforce rvp::move on an rvalue */
-            const auto policy = detail::return_value_policy_override<Return>::policy(call.func.policy);
-
-            /* Function scope guard -- defaults to the compile-to-nothing `void_type` */
-            using Guard = detail::extract_guard_t<Extra...>;
-
-            /* Perform the function call */
-            handle result = cast_out::cast(
-                std::move(args_converter).template call<Return, Guard>(cap->f), policy, call.parent);
-
-            /* Invoke call policy post-call hook */
-            detail::process_attributes<Extra...>::postcall(call, result);
-
-            return result;
-        };
-
-        /* Process any user-provided function attributes */
-        detail::process_attributes<Extra...>::init(extra..., rec);
-
-        /* Generate a readable signature describing the function's arguments and return value types */
-        using detail::descr; using detail::_;
-        PYBIND11_DESCR signature = _("(") + cast_in::arg_names() + _(") -> ") + cast_out::name();
-
-        /* Register the function with Python from generic (non-templated) code */
-        initialize_generic(rec, signature.text(), signature.types(), sizeof...(Args));
-
-        if (cast_in::has_args) rec->has_args = true;
-        if (cast_in::has_kwargs) rec->has_kwargs = true;
-
-        /* Stash some additional information used by an important optimization in 'functional.h' */
-        using FunctionType = Return (*)(Args...);
-        constexpr bool is_function_ptr =
-            std::is_convertible<Func, FunctionType>::value &&
-            sizeof(capture) == sizeof(void *);
-        if (is_function_ptr) {
-            rec->is_stateless = true;
-            rec->data[1] = const_cast<void *>(reinterpret_cast<const void *>(&typeid(FunctionType)));
-        }
-    }
-
-    /// Register a function call with Python (generic non-templated code goes here)
-    void initialize_generic(detail::function_record *rec, const char *text,
-                            const std::type_info *const *types, size_t args) {
-
-        /* Create copies of all referenced C-style strings */
-        rec->name = strdup(rec->name ? rec->name : "");
-        if (rec->doc) rec->doc = strdup(rec->doc);
-        for (auto &a: rec->args) {
-            if (a.name)
-                a.name = strdup(a.name);
-            if (a.descr)
-                a.descr = strdup(a.descr);
-            else if (a.value)
-                a.descr = strdup(a.value.attr("__repr__")().cast<std::string>().c_str());
-        }
-
-        rec->is_constructor = !strcmp(rec->name, "__init__") || !strcmp(rec->name, "__setstate__");
-
-#if !defined(NDEBUG) && !defined(PYBIND11_DISABLE_NEW_STYLE_INIT_WARNING)
-        if (rec->is_constructor && !rec->is_new_style_constructor) {
-            const auto class_name = std::string(((PyTypeObject *) rec->scope.ptr())->tp_name);
-            const auto func_name = std::string(rec->name);
-            PyErr_WarnEx(
-                PyExc_FutureWarning,
-                ("pybind11-bound class '" + class_name + "' is using an old-style "
-                 "placement-new '" + func_name + "' which has been deprecated. See "
-                 "the upgrade guide in pybind11's docs. This message is only visible "
-                 "when compiled in debug mode.").c_str(), 0
-            );
-        }
-#endif
-
-        /* Generate a proper function signature */
-        std::string signature;
-        size_t type_depth = 0, char_index = 0, type_index = 0, arg_index = 0;
-        while (true) {
-            char c = text[char_index++];
-            if (c == '\0')
-                break;
-
-            if (c == '{') {
-                // Write arg name for everything except *args, **kwargs and return type.
-                if (type_depth == 0 && text[char_index] != '*' && arg_index < args) {
-                    if (!rec->args.empty() && rec->args[arg_index].name) {
-                        signature += rec->args[arg_index].name;
-                    } else if (arg_index == 0 && rec->is_method) {
-                        signature += "self";
-                    } else {
-                        signature += "arg" + std::to_string(arg_index - (rec->is_method ? 1 : 0));
-                    }
-                    signature += ": ";
-                }
-                ++type_depth;
-            } else if (c == '}') {
-                --type_depth;
-                if (type_depth == 0) {
-                    if (arg_index < rec->args.size() && rec->args[arg_index].descr) {
-                        signature += "=";
-                        signature += rec->args[arg_index].descr;
-                    }
-                    arg_index++;
-                }
-            } else if (c == '%') {
-                const std::type_info *t = types[type_index++];
-                if (!t)
-                    pybind11_fail("Internal error while parsing type signature (1)");
-                if (auto tinfo = detail::get_type_info(*t)) {
-#if defined(PYPY_VERSION)
-                    signature += handle((PyObject *) tinfo->type)
-                                     .attr("__module__")
-                                     .cast<std::string>() + ".";
-#endif
-                    signature += tinfo->type->tp_name;
-                } else if (rec->is_new_style_constructor && arg_index == 0) {
-                    // A new-style `__init__` takes `self` as `value_and_holder`.
-                    // Rewrite it to the proper class type.
-#if defined(PYPY_VERSION)
-                    signature += rec->scope.attr("__module__").cast<std::string>() + ".";
-#endif
-                    signature += ((PyTypeObject *) rec->scope.ptr())->tp_name;
-                } else {
-                    std::string tname(t->name());
-                    detail::clean_type_id(tname);
-                    signature += tname;
-                }
-            } else {
-                signature += c;
-            }
-        }
-        if (type_depth != 0 || types[type_index] != nullptr)
-            pybind11_fail("Internal error while parsing type signature (2)");
-
-        #if !defined(PYBIND11_CONSTEXPR_DESCR)
-            delete[] types;
-            delete[] text;
-        #endif
-
-#if PY_MAJOR_VERSION < 3
-        if (strcmp(rec->name, "__next__") == 0) {
-            std::free(rec->name);
-            rec->name = strdup("next");
-        } else if (strcmp(rec->name, "__bool__") == 0) {
-            std::free(rec->name);
-            rec->name = strdup("__nonzero__");
-        }
-#endif
-        rec->signature = strdup(signature.c_str());
-        rec->args.shrink_to_fit();
-        rec->nargs = (std::uint16_t) args;
-
-        if (rec->sibling && PYBIND11_INSTANCE_METHOD_CHECK(rec->sibling.ptr()))
-            rec->sibling = PYBIND11_INSTANCE_METHOD_GET_FUNCTION(rec->sibling.ptr());
-
-        detail::function_record *chain = nullptr, *chain_start = rec;
-        if (rec->sibling) {
-            if (PyCFunction_Check(rec->sibling.ptr())) {
-                auto rec_capsule = reinterpret_borrow<capsule>(PyCFunction_GET_SELF(rec->sibling.ptr()));
-                chain = (detail::function_record *) rec_capsule;
-                /* Never append a method to an overload chain of a parent class;
-                   instead, hide the parent's overloads in this case */
-                if (!chain->scope.is(rec->scope))
-                    chain = nullptr;
-            }
-            // Don't trigger for things like the default __init__, which are wrapper_descriptors that we are intentionally replacing
-            else if (!rec->sibling.is_none() && rec->name[0] != '_')
-                pybind11_fail("Cannot overload existing non-function object \"" + std::string(rec->name) +
-                        "\" with a function of the same name");
-        }
-
-        if (!chain) {
-            /* No existing overload was found, create a new function object */
-            rec->def = new PyMethodDef();
-            std::memset(rec->def, 0, sizeof(PyMethodDef));
-            rec->def->ml_name = rec->name;
-            rec->def->ml_meth = reinterpret_cast<PyCFunction>(*dispatcher);
-            rec->def->ml_flags = METH_VARARGS | METH_KEYWORDS;
-
-            capsule rec_capsule(rec, [](void *ptr) {
-                destruct((detail::function_record *) ptr);
-            });
-
-            object scope_module;
-            if (rec->scope) {
-                if (hasattr(rec->scope, "__module__")) {
-                    scope_module = rec->scope.attr("__module__");
-                } else if (hasattr(rec->scope, "__name__")) {
-                    scope_module = rec->scope.attr("__name__");
-                }
-            }
-
-            m_ptr = PyCFunction_NewEx(rec->def, rec_capsule.ptr(), scope_module.ptr());
-            if (!m_ptr)
-                pybind11_fail("cpp_function::cpp_function(): Could not allocate function object");
-        } else {
-            /* Append at the end of the overload chain */
-            m_ptr = rec->sibling.ptr();
-            inc_ref();
-            chain_start = chain;
-            if (chain->is_method != rec->is_method)
-                pybind11_fail("overloading a method with both static and instance methods is not supported; "
-                    #if defined(NDEBUG)
-                        "compile in debug mode for more details"
-                    #else
-                        "error while attempting to bind " + std::string(rec->is_method ? "instance" : "static") + " method " +
-                        std::string(pybind11::str(rec->scope.attr("__name__"))) + "." + std::string(rec->name) + signature
-                    #endif
-                );
-            while (chain->next)
-                chain = chain->next;
-            chain->next = rec;
-        }
-
-        std::string signatures;
-        int index = 0;
-        /* Create a nice pydoc rec including all signatures and
-           docstrings of the functions in the overload chain */
-        if (chain && options::show_function_signatures()) {
-            // First a generic signature
-            signatures += rec->name;
-            signatures += "(*args, **kwargs)\n";
-            signatures += "Overloaded function.\n\n";
-        }
-        // Then specific overload signatures
-        bool first_user_def = true;
-        for (auto it = chain_start; it != nullptr; it = it->next) {
-            if (options::show_function_signatures()) {
-                if (index > 0) signatures += "\n";
-                if (chain)
-                    signatures += std::to_string(++index) + ". ";
-                signatures += rec->name;
-                signatures += it->signature;
-                signatures += "\n";
-            }
-            if (it->doc && strlen(it->doc) > 0 && options::show_user_defined_docstrings()) {
-                // If we're appending another docstring, and aren't printing function signatures, we
-                // need to append a newline first:
-                if (!options::show_function_signatures()) {
-                    if (first_user_def) first_user_def = false;
-                    else signatures += "\n";
-                }
-                if (options::show_function_signatures()) signatures += "\n";
-                signatures += it->doc;
-                if (options::show_function_signatures()) signatures += "\n";
-            }
-        }
-
-        /* Install docstring */
-        PyCFunctionObject *func = (PyCFunctionObject *) m_ptr;
-        if (func->m_ml->ml_doc)
-            std::free(const_cast<char *>(func->m_ml->ml_doc));
-        func->m_ml->ml_doc = strdup(signatures.c_str());
-
-        if (rec->is_method) {
-            m_ptr = PYBIND11_INSTANCE_METHOD_NEW(m_ptr, rec->scope.ptr());
-            if (!m_ptr)
-                pybind11_fail("cpp_function::cpp_function(): Could not allocate instance method object");
-            Py_DECREF(func);
-        }
-    }
-
-    /// When a cpp_function is GCed, release any memory allocated by pybind11
-    static void destruct(detail::function_record *rec) {
-        while (rec) {
-            detail::function_record *next = rec->next;
-            if (rec->free_data)
-                rec->free_data(rec);
-            std::free((char *) rec->name);
-            std::free((char *) rec->doc);
-            std::free((char *) rec->signature);
-            for (auto &arg: rec->args) {
-                std::free(const_cast<char *>(arg.name));
-                std::free(const_cast<char *>(arg.descr));
-                arg.value.dec_ref();
-            }
-            if (rec->def) {
-                std::free(const_cast<char *>(rec->def->ml_doc));
-                delete rec->def;
-            }
-            delete rec;
-            rec = next;
-        }
-    }
-
-    /// Main dispatch logic for calls to functions bound using pybind11
-    static PyObject *dispatcher(PyObject *self, PyObject *args_in, PyObject *kwargs_in) {
-        using namespace detail;
-
-        /* Iterator over the list of potentially admissible overloads */
-        function_record *overloads = (function_record *) PyCapsule_GetPointer(self, nullptr),
-                        *it = overloads;
-
-        /* Need to know how many arguments + keyword arguments there are to pick the right overload */
-        const size_t n_args_in = (size_t) PyTuple_GET_SIZE(args_in);
-
-        handle parent = n_args_in > 0 ? PyTuple_GET_ITEM(args_in, 0) : nullptr,
-               result = PYBIND11_TRY_NEXT_OVERLOAD;
-
-        auto self_value_and_holder = value_and_holder();
-        if (overloads->is_constructor) {
-            const auto tinfo = get_type_info((PyTypeObject *) overloads->scope.ptr());
-            const auto pi = reinterpret_cast<instance *>(parent.ptr());
-            self_value_and_holder = pi->get_value_and_holder(tinfo, false);
-
-            if (!self_value_and_holder.type || !self_value_and_holder.inst) {
-                PyErr_SetString(PyExc_TypeError, "__init__(self, ...) called with invalid `self` argument");
-                return nullptr;
-            }
-
-            // If this value is already registered it must mean __init__ is invoked multiple times;
-            // we really can't support that in C++, so just ignore the second __init__.
-            if (self_value_and_holder.instance_registered())
-                return none().release().ptr();
-        }
-
-        try {
-            // We do this in two passes: in the first pass, we load arguments with `convert=false`;
-            // in the second, we allow conversion (except for arguments with an explicit
-            // py::arg().noconvert()).  This lets us prefer calls without conversion, with
-            // conversion as a fallback.
-            std::vector<function_call> second_pass;
-
-            // However, if there are no overloads, we can just skip the no-convert pass entirely
-            const bool overloaded = it != nullptr && it->next != nullptr;
-
-            for (; it != nullptr; it = it->next) {
-
-                /* For each overload:
-                   1. Copy all positional arguments we were given, also checking to make sure that
-                      named positional arguments weren't *also* specified via kwarg.
-                   2. If we weren't given enough, try to make up the omitted ones by checking
-                      whether they were provided by a kwarg matching the `py::arg("name")` name.  If
-                      so, use it (and remove it from kwargs; if not, see if the function binding
-                      provided a default that we can use.
-                   3. Ensure that either all keyword arguments were "consumed", or that the function
-                      takes a kwargs argument to accept unconsumed kwargs.
-                   4. Any positional arguments still left get put into a tuple (for args), and any
-                      leftover kwargs get put into a dict.
-                   5. Pack everything into a vector; if we have py::args or py::kwargs, they are an
-                      extra tuple or dict at the end of the positional arguments.
-                   6. Call the function call dispatcher (function_record::impl)
-
-                   If one of these fail, move on to the next overload and keep trying until we get a
-                   result other than PYBIND11_TRY_NEXT_OVERLOAD.
-                 */
-
-                function_record &func = *it;
-                size_t pos_args = func.nargs;    // Number of positional arguments that we need
-                if (func.has_args) --pos_args;   // (but don't count py::args
-                if (func.has_kwargs) --pos_args; //  or py::kwargs)
-
-                if (!func.has_args && n_args_in > pos_args)
-                    continue; // Too many arguments for this overload
-
-                if (n_args_in < pos_args && func.args.size() < pos_args)
-                    continue; // Not enough arguments given, and not enough defaults to fill in the blanks
-
-                function_call call(func, parent);
-
-                size_t args_to_copy = std::min(pos_args, n_args_in);
-                size_t args_copied = 0;
-
-                // 0. Inject new-style `self` argument
-                if (func.is_new_style_constructor) {
-                    // The `value` may have been preallocated by an old-style `__init__`
-                    // if it was a preceding candidate for overload resolution.
-                    if (self_value_and_holder)
-                        self_value_and_holder.type->dealloc(self_value_and_holder);
-
-                    call.args.push_back(reinterpret_cast<PyObject *>(&self_value_and_holder));
-                    call.args_convert.push_back(false);
-                    ++args_copied;
-                }
-
-                // 1. Copy any position arguments given.
-                bool bad_arg = false;
-                for (; args_copied < args_to_copy; ++args_copied) {
-                    argument_record *arg_rec = args_copied < func.args.size() ? &func.args[args_copied] : nullptr;
-                    if (kwargs_in && arg_rec && arg_rec->name && PyDict_GetItemString(kwargs_in, arg_rec->name)) {
-                        bad_arg = true;
-                        break;
-                    }
-
-                    handle arg(PyTuple_GET_ITEM(args_in, args_copied));
-                    if (arg_rec && !arg_rec->none && arg.is_none()) {
-                        bad_arg = true;
-                        break;
-                    }
-                    call.args.push_back(arg);
-                    call.args_convert.push_back(arg_rec ? arg_rec->convert : true);
-                }
-                if (bad_arg)
-                    continue; // Maybe it was meant for another overload (issue #688)
-
-                // We'll need to copy this if we steal some kwargs for defaults
-                dict kwargs = reinterpret_borrow<dict>(kwargs_in);
-
-                // 2. Check kwargs and, failing that, defaults that may help complete the list
-                if (args_copied < pos_args) {
-                    bool copied_kwargs = false;
-
-                    for (; args_copied < pos_args; ++args_copied) {
-                        const auto &arg = func.args[args_copied];
-
-                        handle value;
-                        if (kwargs_in && arg.name)
-                            value = PyDict_GetItemString(kwargs.ptr(), arg.name);
-
-                        if (value) {
-                            // Consume a kwargs value
-                            if (!copied_kwargs) {
-                                kwargs = reinterpret_steal<dict>(PyDict_Copy(kwargs.ptr()));
-                                copied_kwargs = true;
-                            }
-                            PyDict_DelItemString(kwargs.ptr(), arg.name);
-                        } else if (arg.value) {
-                            value = arg.value;
-                        }
-
-                        if (value) {
-                            call.args.push_back(value);
-                            call.args_convert.push_back(arg.convert);
-                        }
-                        else
-                            break;
-                    }
-
-                    if (args_copied < pos_args)
-                        continue; // Not enough arguments, defaults, or kwargs to fill the positional arguments
-                }
-
-                // 3. Check everything was consumed (unless we have a kwargs arg)
-                if (kwargs && kwargs.size() > 0 && !func.has_kwargs)
-                    continue; // Unconsumed kwargs, but no py::kwargs argument to accept them
-
-                // 4a. If we have a py::args argument, create a new tuple with leftovers
-                tuple extra_args;
-                if (func.has_args) {
-                    if (args_to_copy == 0) {
-                        // We didn't copy out any position arguments from the args_in tuple, so we
-                        // can reuse it directly without copying:
-                        extra_args = reinterpret_borrow<tuple>(args_in);
-                    } else if (args_copied >= n_args_in) {
-                        extra_args = tuple(0);
-                    } else {
-                        size_t args_size = n_args_in - args_copied;
-                        extra_args = tuple(args_size);
-                        for (size_t i = 0; i < args_size; ++i) {
-                            handle item = PyTuple_GET_ITEM(args_in, args_copied + i);
-                            extra_args[i] = item.inc_ref().ptr();
-                        }
-                    }
-                    call.args.push_back(extra_args);
-                    call.args_convert.push_back(false);
-                }
-
-                // 4b. If we have a py::kwargs, pass on any remaining kwargs
-                if (func.has_kwargs) {
-                    if (!kwargs.ptr())
-                        kwargs = dict(); // If we didn't get one, send an empty one
-                    call.args.push_back(kwargs);
-                    call.args_convert.push_back(false);
-                }
-
-                // 5. Put everything in a vector.  Not technically step 5, we've been building it
-                // in `call.args` all along.
-                #if !defined(NDEBUG)
-                if (call.args.size() != func.nargs || call.args_convert.size() != func.nargs)
-                    pybind11_fail("Internal error: function call dispatcher inserted wrong number of arguments!");
-                #endif
-
-                std::vector<bool> second_pass_convert;
-                if (overloaded) {
-                    // We're in the first no-convert pass, so swap out the conversion flags for a
-                    // set of all-false flags.  If the call fails, we'll swap the flags back in for
-                    // the conversion-allowed call below.
-                    second_pass_convert.resize(func.nargs, false);
-                    call.args_convert.swap(second_pass_convert);
-                }
-
-                // 6. Call the function.
-                try {
-                    loader_life_support guard{};
-                    result = func.impl(call);
-                } catch (reference_cast_error &) {
-                    result = PYBIND11_TRY_NEXT_OVERLOAD;
-                }
-
-                if (result.ptr() != PYBIND11_TRY_NEXT_OVERLOAD)
-                    break;
-
-                if (overloaded) {
-                    // The (overloaded) call failed; if the call has at least one argument that
-                    // permits conversion (i.e. it hasn't been explicitly specified `.noconvert()`)
-                    // then add this call to the list of second pass overloads to try.
-                    for (size_t i = func.is_method ? 1 : 0; i < pos_args; i++) {
-                        if (second_pass_convert[i]) {
-                            // Found one: swap the converting flags back in and store the call for
-                            // the second pass.
-                            call.args_convert.swap(second_pass_convert);
-                            second_pass.push_back(std::move(call));
-                            break;
-                        }
-                    }
-                }
-            }
-
-            if (overloaded && !second_pass.empty() && result.ptr() == PYBIND11_TRY_NEXT_OVERLOAD) {
-                // The no-conversion pass finished without success, try again with conversion allowed
-                for (auto &call : second_pass) {
-                    try {
-                        loader_life_support guard{};
-                        result = call.func.impl(call);
-                    } catch (reference_cast_error &) {
-                        result = PYBIND11_TRY_NEXT_OVERLOAD;
-                    }
-
-                    if (result.ptr() != PYBIND11_TRY_NEXT_OVERLOAD)
-                        break;
-                }
-            }
-        } catch (error_already_set &e) {
-            e.restore();
-            return nullptr;
-        } catch (...) {
-            /* When an exception is caught, give each registered exception
-               translator a chance to translate it to a Python exception
-               in reverse order of registration.
-
-               A translator may choose to do one of the following:
-
-                - catch the exception and call PyErr_SetString or PyErr_SetObject
-                  to set a standard (or custom) Python exception, or
-                - do nothing and let the exception fall through to the next translator, or
-                - delegate translation to the next translator by throwing a new type of exception. */
-
-            auto last_exception = std::current_exception();
-            auto &registered_exception_translators = get_internals().registered_exception_translators;
-            for (auto& translator : registered_exception_translators) {
-                try {
-                    translator(last_exception);
-                } catch (...) {
-                    last_exception = std::current_exception();
-                    continue;
-                }
-                return nullptr;
-            }
-            PyErr_SetString(PyExc_SystemError, "Exception escaped from default exception translator!");
-            return nullptr;
-        }
-
-        if (result.ptr() == PYBIND11_TRY_NEXT_OVERLOAD) {
-            if (overloads->is_operator)
-                return handle(Py_NotImplemented).inc_ref().ptr();
-
-            std::string msg = std::string(overloads->name) + "(): incompatible " +
-                std::string(overloads->is_constructor ? "constructor" : "function") +
-                " arguments. The following argument types are supported:\n";
-
-            int ctr = 0;
-            for (function_record *it2 = overloads; it2 != nullptr; it2 = it2->next) {
-                msg += "    "+ std::to_string(++ctr) + ". ";
-
-                bool wrote_sig = false;
-                if (overloads->is_constructor) {
-                    // For a constructor, rewrite `(self: Object, arg0, ...) -> NoneType` as `Object(arg0, ...)`
-                    std::string sig = it2->signature;
-                    size_t start = sig.find('(') + 7; // skip "(self: "
-                    if (start < sig.size()) {
-                        // End at the , for the next argument
-                        size_t end = sig.find(", "), next = end + 2;
-                        size_t ret = sig.rfind(" -> ");
-                        // Or the ), if there is no comma:
-                        if (end >= sig.size()) next = end = sig.find(')');
-                        if (start < end && next < sig.size()) {
-                            msg.append(sig, start, end - start);
-                            msg += '(';
-                            msg.append(sig, next, ret - next);
-                            wrote_sig = true;
-                        }
-                    }
-                }
-                if (!wrote_sig) msg += it2->signature;
-
-                msg += "\n";
-            }
-            msg += "\nInvoked with: ";
-            auto args_ = reinterpret_borrow<tuple>(args_in);
-            bool some_args = false;
-            for (size_t ti = overloads->is_constructor ? 1 : 0; ti < args_.size(); ++ti) {
-                if (!some_args) some_args = true;
-                else msg += ", ";
-                msg += pybind11::repr(args_[ti]);
-            }
-            if (kwargs_in) {
-                auto kwargs = reinterpret_borrow<dict>(kwargs_in);
-                if (kwargs.size() > 0) {
-                    if (some_args) msg += "; ";
-                    msg += "kwargs: ";
-                    bool first = true;
-                    for (auto kwarg : kwargs) {
-                        if (first) first = false;
-                        else msg += ", ";
-                        msg += pybind11::str("{}={!r}").format(kwarg.first, kwarg.second);
-                    }
-                }
-            }
-
-            PyErr_SetString(PyExc_TypeError, msg.c_str());
-            return nullptr;
-        } else if (!result) {
-            std::string msg = "Unable to convert function return value to a "
-                              "Python type! The signature was\n\t";
-            msg += it->signature;
-            PyErr_SetString(PyExc_TypeError, msg.c_str());
-            return nullptr;
-        } else {
-            if (overloads->is_constructor && !self_value_and_holder.holder_constructed()) {
-                auto *pi = reinterpret_cast<instance *>(parent.ptr());
-                self_value_and_holder.type->init_instance(pi, nullptr);
-            }
-            return result.ptr();
-        }
-    }
-};
-
-/// Wrapper for Python extension modules
-class module : public object {
-public:
-    PYBIND11_OBJECT_DEFAULT(module, object, PyModule_Check)
-
-    /// Create a new top-level Python module with the given name and docstring
-    explicit module(const char *name, const char *doc = nullptr) {
-        if (!options::show_user_defined_docstrings()) doc = nullptr;
-#if PY_MAJOR_VERSION >= 3
-        PyModuleDef *def = new PyModuleDef();
-        std::memset(def, 0, sizeof(PyModuleDef));
-        def->m_name = name;
-        def->m_doc = doc;
-        def->m_size = -1;
-        Py_INCREF(def);
-        m_ptr = PyModule_Create(def);
-#else
-        m_ptr = Py_InitModule3(name, nullptr, doc);
-#endif
-        if (m_ptr == nullptr)
-            pybind11_fail("Internal error in module::module()");
-        inc_ref();
-    }
-
-    /** \rst
-        Create Python binding for a new function within the module scope. ``Func``
-        can be a plain C++ function, a function pointer, or a lambda function. For
-        details on the ``Extra&& ... extra`` argument, see section :ref:`extras`.
-    \endrst */
-    template <typename Func, typename... Extra>
-    module &def(const char *name_, Func &&f, const Extra& ... extra) {
-        cpp_function func(std::forward<Func>(f), name(name_), scope(*this),
-                          sibling(getattr(*this, name_, none())), extra...);
-        // NB: allow overwriting here because cpp_function sets up a chain with the intention of
-        // overwriting (and has already checked internally that it isn't overwriting non-functions).
-        add_object(name_, func, true /* overwrite */);
-        return *this;
-    }
-
-    /** \rst
-        Create and return a new Python submodule with the given name and docstring.
-        This also works recursively, i.e.
-
-        .. code-block:: cpp
-
-            py::module m("example", "pybind11 example plugin");
-            py::module m2 = m.def_submodule("sub", "A submodule of 'example'");
-            py::module m3 = m2.def_submodule("subsub", "A submodule of 'example.sub'");
-    \endrst */
-    module def_submodule(const char *name, const char *doc = nullptr) {
-        std::string full_name = std::string(PyModule_GetName(m_ptr))
-            + std::string(".") + std::string(name);
-        auto result = reinterpret_borrow<module>(PyImport_AddModule(full_name.c_str()));
-        if (doc && options::show_user_defined_docstrings())
-            result.attr("__doc__") = pybind11::str(doc);
-        attr(name) = result;
-        return result;
-    }
-
-    /// Import and return a module or throws `error_already_set`.
-    static module import(const char *name) {
-        PyObject *obj = PyImport_ImportModule(name);
-        if (!obj)
-            throw error_already_set();
-        return reinterpret_steal<module>(obj);
-    }
-
-    // Adds an object to the module using the given name.  Throws if an object with the given name
-    // already exists.
-    //
-    // overwrite should almost always be false: attempting to overwrite objects that pybind11 has
-    // established will, in most cases, break things.
-    PYBIND11_NOINLINE void add_object(const char *name, handle obj, bool overwrite = false) {
-        if (!overwrite && hasattr(*this, name))
-            pybind11_fail("Error during initialization: multiple incompatible definitions with name \"" +
-                    std::string(name) + "\"");
-
-        PyModule_AddObject(ptr(), name, obj.inc_ref().ptr() /* steals a reference */);
-    }
-};
-
-/// \ingroup python_builtins
-/// Return a dictionary representing the global variables in the current execution frame,
-/// or ``__main__.__dict__`` if there is no frame (usually when the interpreter is embedded).
-inline dict globals() {
-    PyObject *p = PyEval_GetGlobals();
-    return reinterpret_borrow<dict>(p ? p : module::import("__main__").attr("__dict__").ptr());
-}
-
-NAMESPACE_BEGIN(detail)
-/// Generic support for creating new Python heap types
-class generic_type : public object {
-    template <typename...> friend class class_;
-public:
-    PYBIND11_OBJECT_DEFAULT(generic_type, object, PyType_Check)
-protected:
-    void initialize(const type_record &rec) {
-        if (rec.scope && hasattr(rec.scope, rec.name))
-            pybind11_fail("generic_type: cannot initialize type \"" + std::string(rec.name) +
-                          "\": an object with that name is already defined");
-
-        if (rec.module_local ? get_local_type_info(*rec.type) : get_global_type_info(*rec.type))
-            pybind11_fail("generic_type: type \"" + std::string(rec.name) +
-                          "\" is already registered!");
-
-        m_ptr = make_new_python_type(rec);
-
-        /* Register supplemental type information in C++ dict */
-        auto *tinfo = new detail::type_info();
-        tinfo->type = (PyTypeObject *) m_ptr;
-        tinfo->cpptype = rec.type;
-        tinfo->type_size = rec.type_size;
-        tinfo->operator_new = rec.operator_new;
-        tinfo->holder_size_in_ptrs = size_in_ptrs(rec.holder_size);
-        tinfo->init_instance = rec.init_instance;
-        tinfo->dealloc = rec.dealloc;
-        tinfo->simple_type = true;
-        tinfo->simple_ancestors = true;
-        tinfo->default_holder = rec.default_holder;
-        tinfo->module_local = rec.module_local;
-
-        auto &internals = get_internals();
-        auto tindex = std::type_index(*rec.type);
-        tinfo->direct_conversions = &internals.direct_conversions[tindex];
-        if (rec.module_local)
-            registered_local_types_cpp()[tindex] = tinfo;
-        else
-            internals.registered_types_cpp[tindex] = tinfo;
-        internals.registered_types_py[(PyTypeObject *) m_ptr] = { tinfo };
-
-        if (rec.bases.size() > 1 || rec.multiple_inheritance) {
-            mark_parents_nonsimple(tinfo->type);
-            tinfo->simple_ancestors = false;
-        }
-        else if (rec.bases.size() == 1) {
-            auto parent_tinfo = get_type_info((PyTypeObject *) rec.bases[0].ptr());
-            tinfo->simple_ancestors = parent_tinfo->simple_ancestors;
-        }
-
-        if (rec.module_local) {
-            // Stash the local typeinfo and loader so that external modules can access it.
-            tinfo->module_local_load = &type_caster_generic::local_load;
-            setattr(m_ptr, PYBIND11_MODULE_LOCAL_ID, capsule(tinfo));
-        }
-    }
-
-    /// Helper function which tags all parents of a type using mult. inheritance
-    void mark_parents_nonsimple(PyTypeObject *value) {
-        auto t = reinterpret_borrow<tuple>(value->tp_bases);
-        for (handle h : t) {
-            auto tinfo2 = get_type_info((PyTypeObject *) h.ptr());
-            if (tinfo2)
-                tinfo2->simple_type = false;
-            mark_parents_nonsimple((PyTypeObject *) h.ptr());
-        }
-    }
-
-    void install_buffer_funcs(
-            buffer_info *(*get_buffer)(PyObject *, void *),
-            void *get_buffer_data) {
-        PyHeapTypeObject *type = (PyHeapTypeObject*) m_ptr;
-        auto tinfo = detail::get_type_info(&type->ht_type);
-
-        if (!type->ht_type.tp_as_buffer)
-            pybind11_fail(
-                "To be able to register buffer protocol support for the type '" +
-                std::string(tinfo->type->tp_name) +
-                "' the associated class<>(..) invocation must "
-                "include the pybind11::buffer_protocol() annotation!");
-
-        tinfo->get_buffer = get_buffer;
-        tinfo->get_buffer_data = get_buffer_data;
-    }
-
-    void def_property_static_impl(const char *name,
-                                  handle fget, handle fset,
-                                  detail::function_record *rec_fget) {
-        const auto is_static = !(rec_fget->is_method && rec_fget->scope);
-        const auto has_doc = rec_fget->doc && pybind11::options::show_user_defined_docstrings();
-
-        auto property = handle((PyObject *) (is_static ? get_internals().static_property_type
-                                                       : &PyProperty_Type));
-        attr(name) = property(fget.ptr() ? fget : none(),
-                              fset.ptr() ? fset : none(),
-                              /*deleter*/none(),
-                              pybind11::str(has_doc ? rec_fget->doc : ""));
-    }
-};
-
-/// Set the pointer to operator new if it exists. The cast is needed because it can be overloaded.
-template <typename T, typename = void_t<decltype(static_cast<void *(*)(size_t)>(T::operator new))>>
-void set_operator_new(type_record *r) { r->operator_new = &T::operator new; }
-
-template <typename> void set_operator_new(...) { }
-
-template <typename T, typename SFINAE = void> struct has_operator_delete : std::false_type { };
-template <typename T> struct has_operator_delete<T, void_t<decltype(static_cast<void (*)(void *)>(T::operator delete))>>
-    : std::true_type { };
-template <typename T, typename SFINAE = void> struct has_operator_delete_size : std::false_type { };
-template <typename T> struct has_operator_delete_size<T, void_t<decltype(static_cast<void (*)(void *, size_t)>(T::operator delete))>>
-    : std::true_type { };
-/// Call class-specific delete if it exists or global otherwise. Can also be an overload set.
-template <typename T, enable_if_t<has_operator_delete<T>::value, int> = 0>
-void call_operator_delete(T *p, size_t) { T::operator delete(p); }
-template <typename T, enable_if_t<!has_operator_delete<T>::value && has_operator_delete_size<T>::value, int> = 0>
-void call_operator_delete(T *p, size_t s) { T::operator delete(p, s); }
-
-inline void call_operator_delete(void *p, size_t) { ::operator delete(p); }
-
-NAMESPACE_END(detail)
-
-/// Given a pointer to a member function, cast it to its `Derived` version.
-/// Forward everything else unchanged.
-template <typename /*Derived*/, typename F>
-auto method_adaptor(F &&f) -> decltype(std::forward<F>(f)) { return std::forward<F>(f); }
-
-template <typename Derived, typename Return, typename Class, typename... Args>
-auto method_adaptor(Return (Class::*pmf)(Args...)) -> Return (Derived::*)(Args...) { return pmf; }
-
-template <typename Derived, typename Return, typename Class, typename... Args>
-auto method_adaptor(Return (Class::*pmf)(Args...) const) -> Return (Derived::*)(Args...) const { return pmf; }
-
-template <typename type_, typename... options>
-class class_ : public detail::generic_type {
-    template <typename T> using is_holder = detail::is_holder_type<type_, T>;
-    template <typename T> using is_subtype = detail::is_strict_base_of<type_, T>;
-    template <typename T> using is_base = detail::is_strict_base_of<T, type_>;
-    // struct instead of using here to help MSVC:
-    template <typename T> struct is_valid_class_option :
-        detail::any_of<is_holder<T>, is_subtype<T>, is_base<T>> {};
-
-public:
-    using type = type_;
-    using type_alias = detail::exactly_one_t<is_subtype, void, options...>;
-    constexpr static bool has_alias = !std::is_void<type_alias>::value;
-    using holder_type = detail::exactly_one_t<is_holder, std::unique_ptr<type>, options...>;
-
-    static_assert(detail::all_of<is_valid_class_option<options>...>::value,
-            "Unknown/invalid class_ template parameters provided");
-
-    static_assert(!has_alias || std::is_polymorphic<type>::value,
-            "Cannot use an alias class with a non-polymorphic type");
-
-    PYBIND11_OBJECT(class_, generic_type, PyType_Check)
-
-    template <typename... Extra>
-    class_(handle scope, const char *name, const Extra &... extra) {
-        using namespace detail;
-
-        // MI can only be specified via class_ template options, not constructor parameters
-        static_assert(
-            none_of<is_pyobject<Extra>...>::value || // no base class arguments, or:
-            (   constexpr_sum(is_pyobject<Extra>::value...) == 1 && // Exactly one base
-                constexpr_sum(is_base<options>::value...)   == 0 && // no template option bases
-                none_of<std::is_same<multiple_inheritance, Extra>...>::value), // no multiple_inheritance attr
-            "Error: multiple inheritance bases must be specified via class_ template options");
-
-        type_record record;
-        record.scope = scope;
-        record.name = name;
-        record.type = &typeid(type);
-        record.type_size = sizeof(conditional_t<has_alias, type_alias, type>);
-        record.holder_size = sizeof(holder_type);
-        record.init_instance = init_instance;
-        record.dealloc = dealloc;
-        record.default_holder = std::is_same<holder_type, std::unique_ptr<type>>::value;
-
-        set_operator_new<type>(&record);
-
-        /* Register base classes specified via template arguments to class_, if any */
-        PYBIND11_EXPAND_SIDE_EFFECTS(add_base<options>(record));
-
-        /* Process optional arguments, if any */
-        process_attributes<Extra...>::init(extra..., &record);
-
-        generic_type::initialize(record);
-
-        if (has_alias) {
-            auto &instances = record.module_local ? registered_local_types_cpp() : get_internals().registered_types_cpp;
-            instances[std::type_index(typeid(type_alias))] = instances[std::type_index(typeid(type))];
-        }
-    }
-
-    template <typename Base, detail::enable_if_t<is_base<Base>::value, int> = 0>
-    static void add_base(detail::type_record &rec) {
-        rec.add_base(typeid(Base), [](void *src) -> void * {
-            return static_cast<Base *>(reinterpret_cast<type *>(src));
-        });
-    }
-
-    template <typename Base, detail::enable_if_t<!is_base<Base>::value, int> = 0>
-    static void add_base(detail::type_record &) { }
-
-    template <typename Func, typename... Extra>
-    class_ &def(const char *name_, Func&& f, const Extra&... extra) {
-        cpp_function cf(method_adaptor<type>(std::forward<Func>(f)), name(name_), is_method(*this),
-                        sibling(getattr(*this, name_, none())), extra...);
-        attr(cf.name()) = cf;
-        return *this;
-    }
-
-    template <typename Func, typename... Extra> class_ &
-    def_static(const char *name_, Func &&f, const Extra&... extra) {
-        static_assert(!std::is_member_function_pointer<Func>::value,
-                "def_static(...) called with a non-static member function pointer");
-        cpp_function cf(std::forward<Func>(f), name(name_), scope(*this),
-                        sibling(getattr(*this, name_, none())), extra...);
-        attr(cf.name()) = cf;
-        return *this;
-    }
-
-    template <detail::op_id id, detail::op_type ot, typename L, typename R, typename... Extra>
-    class_ &def(const detail::op_<id, ot, L, R> &op, const Extra&... extra) {
-        op.execute(*this, extra...);
-        return *this;
-    }
-
-    template <detail::op_id id, detail::op_type ot, typename L, typename R, typename... Extra>
-    class_ & def_cast(const detail::op_<id, ot, L, R> &op, const Extra&... extra) {
-        op.execute_cast(*this, extra...);
-        return *this;
-    }
-
-    template <typename... Args, typename... Extra>
-    class_ &def(const detail::initimpl::constructor<Args...> &init, const Extra&... extra) {
-        init.execute(*this, extra...);
-        return *this;
-    }
-
-    template <typename... Args, typename... Extra>
-    class_ &def(const detail::initimpl::alias_constructor<Args...> &init, const Extra&... extra) {
-        init.execute(*this, extra...);
-        return *this;
-    }
-
-    template <typename... Args, typename... Extra>
-    class_ &def(detail::initimpl::factory<Args...> &&init, const Extra&... extra) {
-        std::move(init).execute(*this, extra...);
-        return *this;
-    }
-
-    template <typename... Args, typename... Extra>
-    class_ &def(detail::initimpl::pickle_factory<Args...> &&pf, const Extra &...extra) {
-        std::move(pf).execute(*this, extra...);
-        return *this;
-    }
-
-    template <typename Func> class_& def_buffer(Func &&func) {
-        struct capture { Func func; };
-        capture *ptr = new capture { std::forward<Func>(func) };
-        install_buffer_funcs([](PyObject *obj, void *ptr) -> buffer_info* {
-            detail::make_caster<type> caster;
-            if (!caster.load(obj, false))
-                return nullptr;
-            return new buffer_info(((capture *) ptr)->func(caster));
-        }, ptr);
-        return *this;
-    }
-
-    template <typename Return, typename Class, typename... Args>
-    class_ &def_buffer(Return (Class::*func)(Args...)) {
-        return def_buffer([func] (type &obj) { return (obj.*func)(); });
-    }
-
-    template <typename Return, typename Class, typename... Args>
-    class_ &def_buffer(Return (Class::*func)(Args...) const) {
-        return def_buffer([func] (const type &obj) { return (obj.*func)(); });
-    }
-
-    template <typename C, typename D, typename... Extra>
-    class_ &def_readwrite(const char *name, D C::*pm, const Extra&... extra) {
-        static_assert(std::is_base_of<C, type>::value, "def_readwrite() requires a class member (or base class member)");
-        cpp_function fget([pm](const type &c) -> const D &{ return c.*pm; }, is_method(*this)),
-                     fset([pm](type &c, const D &value) { c.*pm = value; }, is_method(*this));
-        def_property(name, fget, fset, return_value_policy::reference_internal, extra...);
-        return *this;
-    }
-
-    template <typename C, typename D, typename... Extra>
-    class_ &def_readonly(const char *name, const D C::*pm, const Extra& ...extra) {
-        static_assert(std::is_base_of<C, type>::value, "def_readonly() requires a class member (or base class member)");
-        cpp_function fget([pm](const type &c) -> const D &{ return c.*pm; }, is_method(*this));
-        def_property_readonly(name, fget, return_value_policy::reference_internal, extra...);
-        return *this;
-    }
-
-    template <typename D, typename... Extra>
-    class_ &def_readwrite_static(const char *name, D *pm, const Extra& ...extra) {
-        cpp_function fget([pm](object) -> const D &{ return *pm; }, scope(*this)),
-                     fset([pm](object, const D &value) { *pm = value; }, scope(*this));
-        def_property_static(name, fget, fset, return_value_policy::reference, extra...);
-        return *this;
-    }
-
-    template <typename D, typename... Extra>
-    class_ &def_readonly_static(const char *name, const D *pm, const Extra& ...extra) {
-        cpp_function fget([pm](object) -> const D &{ return *pm; }, scope(*this));
-        def_property_readonly_static(name, fget, return_value_policy::reference, extra...);
-        return *this;
-    }
-
-    /// Uses return_value_policy::reference_internal by default
-    template <typename Getter, typename... Extra>
-    class_ &def_property_readonly(const char *name, const Getter &fget, const Extra& ...extra) {
-        return def_property_readonly(name, cpp_function(method_adaptor<type>(fget)),
-                                     return_value_policy::reference_internal, extra...);
-    }
-
-    /// Uses cpp_function's return_value_policy by default
-    template <typename... Extra>
-    class_ &def_property_readonly(const char *name, const cpp_function &fget, const Extra& ...extra) {
-        return def_property(name, fget, cpp_function(), extra...);
-    }
-
-    /// Uses return_value_policy::reference by default
-    template <typename Getter, typename... Extra>
-    class_ &def_property_readonly_static(const char *name, const Getter &fget, const Extra& ...extra) {
-        return def_property_readonly_static(name, cpp_function(fget), return_value_policy::reference, extra...);
-    }
-
-    /// Uses cpp_function's return_value_policy by default
-    template <typename... Extra>
-    class_ &def_property_readonly_static(const char *name, const cpp_function &fget, const Extra& ...extra) {
-        return def_property_static(name, fget, cpp_function(), extra...);
-    }
-
-    /// Uses return_value_policy::reference_internal by default
-    template <typename Getter, typename Setter, typename... Extra>
-    class_ &def_property(const char *name, const Getter &fget, const Setter &fset, const Extra& ...extra) {
-        return def_property(name, fget, cpp_function(method_adaptor<type>(fset)), extra...);
-    }
-    template <typename Getter, typename... Extra>
-    class_ &def_property(const char *name, const Getter &fget, const cpp_function &fset, const Extra& ...extra) {
-        return def_property(name, cpp_function(method_adaptor<type>(fget)), fset,
-                            return_value_policy::reference_internal, extra...);
-    }
-
-    /// Uses cpp_function's return_value_policy by default
-    template <typename... Extra>
-    class_ &def_property(const char *name, const cpp_function &fget, const cpp_function &fset, const Extra& ...extra) {
-        return def_property_static(name, fget, fset, is_method(*this), extra...);
-    }
-
-    /// Uses return_value_policy::reference by default
-    template <typename Getter, typename... Extra>
-    class_ &def_property_static(const char *name, const Getter &fget, const cpp_function &fset, const Extra& ...extra) {
-        return def_property_static(name, cpp_function(fget), fset, return_value_policy::reference, extra...);
-    }
-
-    /// Uses cpp_function's return_value_policy by default
-    template <typename... Extra>
-    class_ &def_property_static(const char *name, const cpp_function &fget, const cpp_function &fset, const Extra& ...extra) {
-        auto rec_fget = get_function_record(fget), rec_fset = get_function_record(fset);
-        char *doc_prev = rec_fget->doc; /* 'extra' field may include a property-specific documentation string */
-        detail::process_attributes<Extra...>::init(extra..., rec_fget);
-        if (rec_fget->doc && rec_fget->doc != doc_prev) {
-            free(doc_prev);
-            rec_fget->doc = strdup(rec_fget->doc);
-        }
-        if (rec_fset) {
-            doc_prev = rec_fset->doc;
-            detail::process_attributes<Extra...>::init(extra..., rec_fset);
-            if (rec_fset->doc && rec_fset->doc != doc_prev) {
-                free(doc_prev);
-                rec_fset->doc = strdup(rec_fset->doc);
-            }
-        }
-        def_property_static_impl(name, fget, fset, rec_fget);
-        return *this;
-    }
-
-private:
-    /// Initialize holder object, variant 1: object derives from enable_shared_from_this
-    template <typename T>
-    static void init_holder(detail::instance *inst, detail::value_and_holder &v_h,
-            const holder_type * /* unused */, const std::enable_shared_from_this<T> * /* dummy */) {
-        try {
-            auto sh = std::dynamic_pointer_cast<typename holder_type::element_type>(
-                    v_h.value_ptr<type>()->shared_from_this());
-            if (sh) {
-                new (&v_h.holder<holder_type>()) holder_type(std::move(sh));
-                v_h.set_holder_constructed();
-            }
-        } catch (const std::bad_weak_ptr &) {}
-
-        if (!v_h.holder_constructed() && inst->owned) {
-            new (&v_h.holder<holder_type>()) holder_type(v_h.value_ptr<type>());
-            v_h.set_holder_constructed();
-        }
-    }
-
-    static void init_holder_from_existing(const detail::value_and_holder &v_h,
-            const holder_type *holder_ptr, std::true_type /*is_copy_constructible*/) {
-        new (&v_h.holder<holder_type>()) holder_type(*reinterpret_cast<const holder_type *>(holder_ptr));
-    }
-
-    static void init_holder_from_existing(const detail::value_and_holder &v_h,
-            const holder_type *holder_ptr, std::false_type /*is_copy_constructible*/) {
-        new (&v_h.holder<holder_type>()) holder_type(std::move(*const_cast<holder_type *>(holder_ptr)));
-    }
-
-    /// Initialize holder object, variant 2: try to construct from existing holder object, if possible
-    static void init_holder(detail::instance *inst, detail::value_and_holder &v_h,
-            const holder_type *holder_ptr, const void * /* dummy -- not enable_shared_from_this<T>) */) {
-        if (holder_ptr) {
-            init_holder_from_existing(v_h, holder_ptr, std::is_copy_constructible<holder_type>());
-            v_h.set_holder_constructed();
-        } else if (inst->owned || detail::always_construct_holder<holder_type>::value) {
-            new (&v_h.holder<holder_type>()) holder_type(v_h.value_ptr<type>());
-            v_h.set_holder_constructed();
-        }
-    }
-
-    /// Performs instance initialization including constructing a holder and registering the known
-    /// instance.  Should be called as soon as the `type` value_ptr is set for an instance.  Takes an
-    /// optional pointer to an existing holder to use; if not specified and the instance is
-    /// `.owned`, a new holder will be constructed to manage the value pointer.
-    static void init_instance(detail::instance *inst, const void *holder_ptr) {
-        auto v_h = inst->get_value_and_holder(detail::get_type_info(typeid(type)));
-        if (!v_h.instance_registered()) {
-            register_instance(inst, v_h.value_ptr(), v_h.type);
-            v_h.set_instance_registered();
-        }
-        init_holder(inst, v_h, (const holder_type *) holder_ptr, v_h.value_ptr<type>());
-    }
-
-    /// Deallocates an instance; via holder, if constructed; otherwise via operator delete.
-    static void dealloc(detail::value_and_holder &v_h) {
-        if (v_h.holder_constructed()) {
-            v_h.holder<holder_type>().~holder_type();
-            v_h.set_holder_constructed(false);
-        }
-        else {
-            detail::call_operator_delete(v_h.value_ptr<type>(), v_h.type->type_size);
-        }
-        v_h.value_ptr() = nullptr;
-    }
-
-    static detail::function_record *get_function_record(handle h) {
-        h = detail::get_function(h);
-        return h ? (detail::function_record *) reinterpret_borrow<capsule>(PyCFunction_GET_SELF(h.ptr()))
-                 : nullptr;
-    }
-};
-
-/// Binds an existing constructor taking arguments Args...
-template <typename... Args> detail::initimpl::constructor<Args...> init() { return {}; }
-/// Like `init<Args...>()`, but the instance is always constructed through the alias class (even
-/// when not inheriting on the Python side).
-template <typename... Args> detail::initimpl::alias_constructor<Args...> init_alias() { return {}; }
-
-/// Binds a factory function as a constructor
-template <typename Func, typename Ret = detail::initimpl::factory<Func>>
-Ret init(Func &&f) { return {std::forward<Func>(f)}; }
-
-/// Dual-argument factory function: the first function is called when no alias is needed, the second
-/// when an alias is needed (i.e. due to python-side inheritance).  Arguments must be identical.
-template <typename CFunc, typename AFunc, typename Ret = detail::initimpl::factory<CFunc, AFunc>>
-Ret init(CFunc &&c, AFunc &&a) {
-    return {std::forward<CFunc>(c), std::forward<AFunc>(a)};
-}
-
-/// Binds pickling functions `__getstate__` and `__setstate__` and ensures that the type
-/// returned by `__getstate__` is the same as the argument accepted by `__setstate__`.
-template <typename GetState, typename SetState>
-detail::initimpl::pickle_factory<GetState, SetState> pickle(GetState &&g, SetState &&s) {
-    return {std::forward<GetState>(g), std::forward<SetState>(s)};
-};
-
-/// Binds C++ enumerations and enumeration classes to Python
-template <typename Type> class enum_ : public class_<Type> {
-public:
-    using class_<Type>::def;
-    using class_<Type>::def_property_readonly_static;
-    using Scalar = typename std::underlying_type<Type>::type;
-
-    template <typename... Extra>
-    enum_(const handle &scope, const char *name, const Extra&... extra)
-      : class_<Type>(scope, name, extra...), m_entries(), m_parent(scope) {
-
-        constexpr bool is_arithmetic = detail::any_of<std::is_same<arithmetic, Extra>...>::value;
-
-        auto m_entries_ptr = m_entries.inc_ref().ptr();
-        def("__repr__", [name, m_entries_ptr](Type value) -> pybind11::str {
-            for (const auto &kv : reinterpret_borrow<dict>(m_entries_ptr)) {
-                if (pybind11::cast<Type>(kv.second) == value)
-                    return pybind11::str("{}.{}").format(name, kv.first);
-            }
-            return pybind11::str("{}.???").format(name);
-        });
-        def_property_readonly_static("__members__", [m_entries_ptr](object /* self */) {
-            dict m;
-            for (const auto &kv : reinterpret_borrow<dict>(m_entries_ptr))
-                m[kv.first] = kv.second;
-            return m;
-        }, return_value_policy::copy);
-        def(init([](Scalar i) { return static_cast<Type>(i); }));
-        def("__int__", [](Type value) { return (Scalar) value; });
-        #if PY_MAJOR_VERSION < 3
-            def("__long__", [](Type value) { return (Scalar) value; });
-        #endif
-        def("__eq__", [](const Type &value, Type *value2) { return value2 && value == *value2; });
-        def("__ne__", [](const Type &value, Type *value2) { return !value2 || value != *value2; });
-        if (is_arithmetic) {
-            def("__lt__", [](const Type &value, Type *value2) { return value2 && value < *value2; });
-            def("__gt__", [](const Type &value, Type *value2) { return value2 && value > *value2; });
-            def("__le__", [](const Type &value, Type *value2) { return value2 && value <= *value2; });
-            def("__ge__", [](const Type &value, Type *value2) { return value2 && value >= *value2; });
-        }
-        if (std::is_convertible<Type, Scalar>::value) {
-            // Don't provide comparison with the underlying type if the enum isn't convertible,
-            // i.e. if Type is a scoped enum, mirroring the C++ behaviour.  (NB: we explicitly
-            // convert Type to Scalar below anyway because this needs to compile).
-            def("__eq__", [](const Type &value, Scalar value2) { return (Scalar) value == value2; });
-            def("__ne__", [](const Type &value, Scalar value2) { return (Scalar) value != value2; });
-            if (is_arithmetic) {
-                def("__lt__", [](const Type &value, Scalar value2) { return (Scalar) value < value2; });
-                def("__gt__", [](const Type &value, Scalar value2) { return (Scalar) value > value2; });
-                def("__le__", [](const Type &value, Scalar value2) { return (Scalar) value <= value2; });
-                def("__ge__", [](const Type &value, Scalar value2) { return (Scalar) value >= value2; });
-                def("__invert__", [](const Type &value) { return ~((Scalar) value); });
-                def("__and__", [](const Type &value, Scalar value2) { return (Scalar) value & value2; });
-                def("__or__", [](const Type &value, Scalar value2) { return (Scalar) value | value2; });
-                def("__xor__", [](const Type &value, Scalar value2) { return (Scalar) value ^ value2; });
-                def("__rand__", [](const Type &value, Scalar value2) { return (Scalar) value & value2; });
-                def("__ror__", [](const Type &value, Scalar value2) { return (Scalar) value | value2; });
-                def("__rxor__", [](const Type &value, Scalar value2) { return (Scalar) value ^ value2; });
-                def("__and__", [](const Type &value, const Type &value2) { return (Scalar) value & (Scalar) value2; });
-                def("__or__", [](const Type &value, const Type &value2) { return (Scalar) value | (Scalar) value2; });
-                def("__xor__", [](const Type &value, const Type &value2) { return (Scalar) value ^ (Scalar) value2; });
-            }
-        }
-        def("__hash__", [](const Type &value) { return (Scalar) value; });
-        // Pickling and unpickling -- needed for use with the 'multiprocessing' module
-        def(pickle([](const Type &value) { return pybind11::make_tuple((Scalar) value); },
-                   [](tuple t) { return static_cast<Type>(t[0].cast<Scalar>()); }));
-    }
-
-    /// Export enumeration entries into the parent scope
-    enum_& export_values() {
-        for (const auto &kv : m_entries)
-            m_parent.attr(kv.first) = kv.second;
-        return *this;
-    }
-
-    /// Add an enumeration entry
-    enum_& value(char const* name, Type value) {
-        auto v = pybind11::cast(value, return_value_policy::copy);
-        this->attr(name) = v;
-        m_entries[pybind11::str(name)] = v;
-        return *this;
-    }
-
-private:
-    dict m_entries;
-    handle m_parent;
-};
-
-NAMESPACE_BEGIN(detail)
-
-
-inline void keep_alive_impl(handle nurse, handle patient) {
-    if (!nurse || !patient)
-        pybind11_fail("Could not activate keep_alive!");
-
-    if (patient.is_none() || nurse.is_none())
-        return; /* Nothing to keep alive or nothing to be kept alive by */
-
-    auto tinfo = all_type_info(Py_TYPE(nurse.ptr()));
-    if (!tinfo.empty()) {
-        /* It's a pybind-registered type, so we can store the patient in the
-         * internal list. */
-        add_patient(nurse.ptr(), patient.ptr());
-    }
-    else {
-        /* Fall back to clever approach based on weak references taken from
-         * Boost.Python. This is not used for pybind-registered types because
-         * the objects can be destroyed out-of-order in a GC pass. */
-        cpp_function disable_lifesupport(
-            [patient](handle weakref) { patient.dec_ref(); weakref.dec_ref(); });
-
-        weakref wr(nurse, disable_lifesupport);
-
-        patient.inc_ref(); /* reference patient and leak the weak reference */
-        (void) wr.release();
-    }
-}
-
-PYBIND11_NOINLINE inline void keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret) {
-    keep_alive_impl(
-        Nurse   == 0 ? ret : Nurse   <= call.args.size() ? call.args[Nurse   - 1] : handle(),
-        Patient == 0 ? ret : Patient <= call.args.size() ? call.args[Patient - 1] : handle()
-    );
-}
-
-inline std::pair<decltype(internals::registered_types_py)::iterator, bool> all_type_info_get_cache(PyTypeObject *type) {
-    auto res = get_internals().registered_types_py
-#ifdef __cpp_lib_unordered_map_try_emplace
-        .try_emplace(type);
-#else
-        .emplace(type, std::vector<detail::type_info *>());
-#endif
-    if (res.second) {
-        // New cache entry created; set up a weak reference to automatically remove it if the type
-        // gets destroyed:
-        weakref((PyObject *) type, cpp_function([type](handle wr) {
-            get_internals().registered_types_py.erase(type);
-            wr.dec_ref();
-        })).release();
-    }
-
-    return res;
-}
-
-template <typename Iterator, typename Sentinel, bool KeyIterator, return_value_policy Policy>
-struct iterator_state {
-    Iterator it;
-    Sentinel end;
-    bool first_or_done;
-};
-
-NAMESPACE_END(detail)
-
-/// Makes a python iterator from a first and past-the-end C++ InputIterator.
-template <return_value_policy Policy = return_value_policy::reference_internal,
-          typename Iterator,
-          typename Sentinel,
-          typename ValueType = decltype(*std::declval<Iterator>()),
-          typename... Extra>
-iterator make_iterator(Iterator first, Sentinel last, Extra &&... extra) {
-    typedef detail::iterator_state<Iterator, Sentinel, false, Policy> state;
-
-    if (!detail::get_type_info(typeid(state), false)) {
-        class_<state>(handle(), "iterator", pybind11::module_local())
-            .def("__iter__", [](state &s) -> state& { return s; })
-            .def("__next__", [](state &s) -> ValueType {
-                if (!s.first_or_done)
-                    ++s.it;
-                else
-                    s.first_or_done = false;
-                if (s.it == s.end) {
-                    s.first_or_done = true;
-                    throw stop_iteration();
-                }
-                return *s.it;
-            }, std::forward<Extra>(extra)..., Policy);
-    }
-
-    return cast(state{first, last, true});
-}
-
-/// Makes an python iterator over the keys (`.first`) of a iterator over pairs from a
-/// first and past-the-end InputIterator.
-template <return_value_policy Policy = return_value_policy::reference_internal,
-          typename Iterator,
-          typename Sentinel,
-          typename KeyType = decltype((*std::declval<Iterator>()).first),
-          typename... Extra>
-iterator make_key_iterator(Iterator first, Sentinel last, Extra &&... extra) {
-    typedef detail::iterator_state<Iterator, Sentinel, true, Policy> state;
-
-    if (!detail::get_type_info(typeid(state), false)) {
-        class_<state>(handle(), "iterator", pybind11::module_local())
-            .def("__iter__", [](state &s) -> state& { return s; })
-            .def("__next__", [](state &s) -> KeyType {
-                if (!s.first_or_done)
-                    ++s.it;
-                else
-                    s.first_or_done = false;
-                if (s.it == s.end) {
-                    s.first_or_done = true;
-                    throw stop_iteration();
-                }
-                return (*s.it).first;
-            }, std::forward<Extra>(extra)..., Policy);
-    }
-
-    return cast(state{first, last, true});
-}
-
-/// Makes an iterator over values of an stl container or other container supporting
-/// `std::begin()`/`std::end()`
-template <return_value_policy Policy = return_value_policy::reference_internal,
-          typename Type, typename... Extra> iterator make_iterator(Type &value, Extra&&... extra) {
-    return make_iterator<Policy>(std::begin(value), std::end(value), extra...);
-}
-
-/// Makes an iterator over the keys (`.first`) of a stl map-like container supporting
-/// `std::begin()`/`std::end()`
-template <return_value_policy Policy = return_value_policy::reference_internal,
-          typename Type, typename... Extra> iterator make_key_iterator(Type &value, Extra&&... extra) {
-    return make_key_iterator<Policy>(std::begin(value), std::end(value), extra...);
-}
-
-template <typename InputType, typename OutputType> void implicitly_convertible() {
-    struct set_flag {
-        bool &flag;
-        set_flag(bool &flag) : flag(flag) { flag = true; }
-        ~set_flag() { flag = false; }
-    };
-    auto implicit_caster = [](PyObject *obj, PyTypeObject *type) -> PyObject * {
-        static bool currently_used = false;
-        if (currently_used) // implicit conversions are non-reentrant
-            return nullptr;
-        set_flag flag_helper(currently_used);
-        if (!detail::make_caster<InputType>().load(obj, false))
-            return nullptr;
-        tuple args(1);
-        args[0] = obj;
-        PyObject *result = PyObject_Call((PyObject *) type, args.ptr(), nullptr);
-        if (result == nullptr)
-            PyErr_Clear();
-        return result;
-    };
-
-    if (auto tinfo = detail::get_type_info(typeid(OutputType)))
-        tinfo->implicit_conversions.push_back(implicit_caster);
-    else
-        pybind11_fail("implicitly_convertible: Unable to find type " + type_id<OutputType>());
-}
-
-template <typename ExceptionTranslator>
-void register_exception_translator(ExceptionTranslator&& translator) {
-    detail::get_internals().registered_exception_translators.push_front(
-        std::forward<ExceptionTranslator>(translator));
-}
-
-/**
- * Wrapper to generate a new Python exception type.
- *
- * This should only be used with PyErr_SetString for now.
- * It is not (yet) possible to use as a py::base.
- * Template type argument is reserved for future use.
- */
-template <typename type>
-class exception : public object {
-public:
-    exception(handle scope, const char *name, PyObject *base = PyExc_Exception) {
-        std::string full_name = scope.attr("__name__").cast<std::string>() +
-                                std::string(".") + name;
-        m_ptr = PyErr_NewException(const_cast<char *>(full_name.c_str()), base, NULL);
-        if (hasattr(scope, name))
-            pybind11_fail("Error during initialization: multiple incompatible "
-                          "definitions with name \"" + std::string(name) + "\"");
-        scope.attr(name) = *this;
-    }
-
-    // Sets the current python exception to this exception object with the given message
-    void operator()(const char *message) {
-        PyErr_SetString(m_ptr, message);
-    }
-};
-
-/**
- * Registers a Python exception in `m` of the given `name` and installs an exception translator to
- * translate the C++ exception to the created Python exception using the exceptions what() method.
- * This is intended for simple exception translations; for more complex translation, register the
- * exception object and translator directly.
- */
-template <typename CppException>
-exception<CppException> &register_exception(handle scope,
-                                            const char *name,
-                                            PyObject *base = PyExc_Exception) {
-    static exception<CppException> ex(scope, name, base);
-    register_exception_translator([](std::exception_ptr p) {
-        if (!p) return;
-        try {
-            std::rethrow_exception(p);
-        } catch (const CppException &e) {
-            ex(e.what());
-        }
-    });
-    return ex;
-}
-
-NAMESPACE_BEGIN(detail)
-PYBIND11_NOINLINE inline void print(tuple args, dict kwargs) {
-    auto strings = tuple(args.size());
-    for (size_t i = 0; i < args.size(); ++i) {
-        strings[i] = str(args[i]);
-    }
-    auto sep = kwargs.contains("sep") ? kwargs["sep"] : cast(" ");
-    auto line = sep.attr("join")(strings);
-
-    object file;
-    if (kwargs.contains("file")) {
-        file = kwargs["file"].cast<object>();
-    } else {
-        try {
-            file = module::import("sys").attr("stdout");
-        } catch (const error_already_set &) {
-            /* If print() is called from code that is executed as
-               part of garbage collection during interpreter shutdown,
-               importing 'sys' can fail. Give up rather than crashing the
-               interpreter in this case. */
-            return;
-        }
-    }
-
-    auto write = file.attr("write");
-    write(line);
-    write(kwargs.contains("end") ? kwargs["end"] : cast("\n"));
-
-    if (kwargs.contains("flush") && kwargs["flush"].cast<bool>())
-        file.attr("flush")();
-}
-NAMESPACE_END(detail)
-
-template <return_value_policy policy = return_value_policy::automatic_reference, typename... Args>
-void print(Args &&...args) {
-    auto c = detail::collect_arguments<policy>(std::forward<Args>(args)...);
-    detail::print(c.args(), c.kwargs());
-}
-
-#if defined(WITH_THREAD) && !defined(PYPY_VERSION)
-
-/* The functions below essentially reproduce the PyGILState_* API using a RAII
- * pattern, but there are a few important differences:
- *
- * 1. When acquiring the GIL from an non-main thread during the finalization
- *    phase, the GILState API blindly terminates the calling thread, which
- *    is often not what is wanted. This API does not do this.
- *
- * 2. The gil_scoped_release function can optionally cut the relationship
- *    of a PyThreadState and its associated thread, which allows moving it to
- *    another thread (this is a fairly rare/advanced use case).
- *
- * 3. The reference count of an acquired thread state can be controlled. This
- *    can be handy to prevent cases where callbacks issued from an external
- *    thread would otherwise constantly construct and destroy thread state data
- *    structures.
- *
- * See the Python bindings of NanoGUI (http://github.com/wjakob/nanogui) for an
- * example which uses features 2 and 3 to migrate the Python thread of
- * execution to another thread (to run the event loop on the original thread,
- * in this case).
- */
-
-class gil_scoped_acquire {
-public:
-    PYBIND11_NOINLINE gil_scoped_acquire() {
-        auto const &internals = detail::get_internals();
-        tstate = (PyThreadState *) PyThread_get_key_value(internals.tstate);
-
-        if (!tstate) {
-            tstate = PyThreadState_New(internals.istate);
-            #if !defined(NDEBUG)
-                if (!tstate)
-                    pybind11_fail("scoped_acquire: could not create thread state!");
-            #endif
-            tstate->gilstate_counter = 0;
-            #if PY_MAJOR_VERSION < 3
-                PyThread_delete_key_value(internals.tstate);
-            #endif
-            PyThread_set_key_value(internals.tstate, tstate);
-        } else {
-            release = detail::get_thread_state_unchecked() != tstate;
-        }
-
-        if (release) {
-            /* Work around an annoying assertion in PyThreadState_Swap */
-            #if defined(Py_DEBUG)
-                PyInterpreterState *interp = tstate->interp;
-                tstate->interp = nullptr;
-            #endif
-            PyEval_AcquireThread(tstate);
-            #if defined(Py_DEBUG)
-                tstate->interp = interp;
-            #endif
-        }
-
-        inc_ref();
-    }
-
-    void inc_ref() {
-        ++tstate->gilstate_counter;
-    }
-
-    PYBIND11_NOINLINE void dec_ref() {
-        --tstate->gilstate_counter;
-        #if !defined(NDEBUG)
-            if (detail::get_thread_state_unchecked() != tstate)
-                pybind11_fail("scoped_acquire::dec_ref(): thread state must be current!");
-            if (tstate->gilstate_counter < 0)
-                pybind11_fail("scoped_acquire::dec_ref(): reference count underflow!");
-        #endif
-        if (tstate->gilstate_counter == 0) {
-            #if !defined(NDEBUG)
-                if (!release)
-                    pybind11_fail("scoped_acquire::dec_ref(): internal error!");
-            #endif
-            PyThreadState_Clear(tstate);
-            PyThreadState_DeleteCurrent();
-            PyThread_delete_key_value(detail::get_internals().tstate);
-            release = false;
-        }
-    }
-
-    PYBIND11_NOINLINE ~gil_scoped_acquire() {
-        dec_ref();
-        if (release)
-           PyEval_SaveThread();
-    }
-private:
-    PyThreadState *tstate = nullptr;
-    bool release = true;
-};
-
-class gil_scoped_release {
-public:
-    explicit gil_scoped_release(bool disassoc = false) : disassoc(disassoc) {
-        // `get_internals()` must be called here unconditionally in order to initialize
-        // `internals.tstate` for subsequent `gil_scoped_acquire` calls. Otherwise, an
-        // initialization race could occur as multiple threads try `gil_scoped_acquire`.
-        const auto &internals = detail::get_internals();
-        tstate = PyEval_SaveThread();
-        if (disassoc) {
-            auto key = internals.tstate;
-            #if PY_MAJOR_VERSION < 3
-                PyThread_delete_key_value(key);
-            #else
-                PyThread_set_key_value(key, nullptr);
-            #endif
-        }
-    }
-    ~gil_scoped_release() {
-        if (!tstate)
-            return;
-        PyEval_RestoreThread(tstate);
-        if (disassoc) {
-            auto key = detail::get_internals().tstate;
-            #if PY_MAJOR_VERSION < 3
-                PyThread_delete_key_value(key);
-            #endif
-            PyThread_set_key_value(key, tstate);
-        }
-    }
-private:
-    PyThreadState *tstate;
-    bool disassoc;
-};
-#elif defined(PYPY_VERSION)
-class gil_scoped_acquire {
-    PyGILState_STATE state;
-public:
-    gil_scoped_acquire() { state = PyGILState_Ensure(); }
-    ~gil_scoped_acquire() { PyGILState_Release(state); }
-};
-
-class gil_scoped_release {
-    PyThreadState *state;
-public:
-    gil_scoped_release() { state = PyEval_SaveThread(); }
-    ~gil_scoped_release() { PyEval_RestoreThread(state); }
-};
-#else
-class gil_scoped_acquire { };
-class gil_scoped_release { };
-#endif
-
-error_already_set::~error_already_set() {
-    if (type) {
-        gil_scoped_acquire gil;
-        type.release().dec_ref();
-        value.release().dec_ref();
-        trace.release().dec_ref();
-    }
-}
-
-inline function get_type_overload(const void *this_ptr, const detail::type_info *this_type, const char *name)  {
-    handle self = detail::get_object_handle(this_ptr, this_type);
-    if (!self)
-        return function();
-    handle type = self.get_type();
-    auto key = std::make_pair(type.ptr(), name);
-
-    /* Cache functions that aren't overloaded in Python to avoid
-       many costly Python dictionary lookups below */
-    auto &cache = detail::get_internals().inactive_overload_cache;
-    if (cache.find(key) != cache.end())
-        return function();
-
-    function overload = getattr(self, name, function());
-    if (overload.is_cpp_function()) {
-        cache.insert(key);
-        return function();
-    }
-
-    /* Don't call dispatch code if invoked from overridden function.
-       Unfortunately this doesn't work on PyPy. */
-#if !defined(PYPY_VERSION)
-    PyFrameObject *frame = PyThreadState_Get()->frame;
-    if (frame && (std::string) str(frame->f_code->co_name) == name &&
-        frame->f_code->co_argcount > 0) {
-        PyFrame_FastToLocals(frame);
-        PyObject *self_caller = PyDict_GetItem(
-            frame->f_locals, PyTuple_GET_ITEM(frame->f_code->co_varnames, 0));
-        if (self_caller == self.ptr())
-            return function();
-    }
-#else
-    /* PyPy currently doesn't provide a detailed cpyext emulation of
-       frame objects, so we have to emulate this using Python. This
-       is going to be slow..*/
-    dict d; d["self"] = self; d["name"] = pybind11::str(name);
-    PyObject *result = PyRun_String(
-        "import inspect\n"
-        "frame = inspect.currentframe()\n"
-        "if frame is not None:\n"
-        "    frame = frame.f_back\n"
-        "    if frame is not None and str(frame.f_code.co_name) == name and "
-        "frame.f_code.co_argcount > 0:\n"
-        "        self_caller = frame.f_locals[frame.f_code.co_varnames[0]]\n"
-        "        if self_caller == self:\n"
-        "            self = None\n",
-        Py_file_input, d.ptr(), d.ptr());
-    if (result == nullptr)
-        throw error_already_set();
-    if (d["self"].is_none())
-        return function();
-    Py_DECREF(result);
-#endif
-
-    return overload;
-}
-
-template <class T> function get_overload(const T *this_ptr, const char *name) {
-    auto tinfo = detail::get_type_info(typeid(T));
-    return tinfo ? get_type_overload(this_ptr, tinfo, name) : function();
-}
-
-#define PYBIND11_OVERLOAD_INT(ret_type, cname, name, ...) { \
-        pybind11::gil_scoped_acquire gil; \
-        pybind11::function overload = pybind11::get_overload(static_cast<const cname *>(this), name); \
-        if (overload) { \
-            auto o = overload(__VA_ARGS__); \
-            if (pybind11::detail::cast_is_temporary_value_reference<ret_type>::value) { \
-                static pybind11::detail::overload_caster_t<ret_type> caster; \
-                return pybind11::detail::cast_ref<ret_type>(std::move(o), caster); \
-            } \
-            else return pybind11::detail::cast_safe<ret_type>(std::move(o)); \
-        } \
-    }
-
-#define PYBIND11_OVERLOAD_NAME(ret_type, cname, name, fn, ...) \
-    PYBIND11_OVERLOAD_INT(ret_type, cname, name, __VA_ARGS__) \
-    return cname::fn(__VA_ARGS__)
-
-#define PYBIND11_OVERLOAD_PURE_NAME(ret_type, cname, name, fn, ...) \
-    PYBIND11_OVERLOAD_INT(ret_type, cname, name, __VA_ARGS__) \
-    pybind11::pybind11_fail("Tried to call pure virtual function \"" #cname "::" name "\"");
-
-#define PYBIND11_OVERLOAD(ret_type, cname, fn, ...) \
-    PYBIND11_OVERLOAD_NAME(ret_type, cname, #fn, fn, __VA_ARGS__)
-
-#define PYBIND11_OVERLOAD_PURE(ret_type, cname, fn, ...) \
-    PYBIND11_OVERLOAD_PURE_NAME(ret_type, cname, #fn, fn, __VA_ARGS__)
-
-NAMESPACE_END(PYBIND11_NAMESPACE)
-
-#if defined(_MSC_VER)
-#  pragma warning(pop)
-#elif defined(__INTEL_COMPILER)
-/* Leave ignored warnings on */
-#elif defined(__GNUG__) && !defined(__clang__)
-#  pragma GCC diagnostic pop
-#endif
diff --git a/tmap/lib/pybind11/include/pybind11/pytypes.h b/tmap/lib/pybind11/include/pybind11/pytypes.h
deleted file mode 100644
index 92316c3..0000000
--- a/tmap/lib/pybind11/include/pybind11/pytypes.h
+++ /dev/null
@@ -1,1330 +0,0 @@
-/*
-    pybind11/pytypes.h: Convenience wrapper classes for basic Python types
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "detail/common.h"
-#include "buffer_info.h"
-#include <utility>
-#include <type_traits>
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-
-/* A few forward declarations */
-class handle; class object;
-class str; class iterator;
-struct arg; struct arg_v;
-
-NAMESPACE_BEGIN(detail)
-class args_proxy;
-inline bool isinstance_generic(handle obj, const std::type_info &tp);
-
-// Accessor forward declarations
-template <typename Policy> class accessor;
-namespace accessor_policies {
-    struct obj_attr;
-    struct str_attr;
-    struct generic_item;
-    struct sequence_item;
-    struct list_item;
-    struct tuple_item;
-}
-using obj_attr_accessor = accessor<accessor_policies::obj_attr>;
-using str_attr_accessor = accessor<accessor_policies::str_attr>;
-using item_accessor = accessor<accessor_policies::generic_item>;
-using sequence_accessor = accessor<accessor_policies::sequence_item>;
-using list_accessor = accessor<accessor_policies::list_item>;
-using tuple_accessor = accessor<accessor_policies::tuple_item>;
-
-/// Tag and check to identify a class which implements the Python object API
-class pyobject_tag { };
-template <typename T> using is_pyobject = std::is_base_of<pyobject_tag, remove_reference_t<T>>;
-
-/** \rst
-    A mixin class which adds common functions to `handle`, `object` and various accessors.
-    The only requirement for `Derived` is to implement ``PyObject *Derived::ptr() const``.
-\endrst */
-template <typename Derived>
-class object_api : public pyobject_tag {
-    const Derived &derived() const { return static_cast<const Derived &>(*this); }
-
-public:
-    /** \rst
-        Return an iterator equivalent to calling ``iter()`` in Python. The object
-        must be a collection which supports the iteration protocol.
-    \endrst */
-    iterator begin() const;
-    /// Return a sentinel which ends iteration.
-    iterator end() const;
-
-    /** \rst
-        Return an internal functor to invoke the object's sequence protocol. Casting
-        the returned ``detail::item_accessor`` instance to a `handle` or `object`
-        subclass causes a corresponding call to ``__getitem__``. Assigning a `handle`
-        or `object` subclass causes a call to ``__setitem__``.
-    \endrst */
-    item_accessor operator[](handle key) const;
-    /// See above (the only difference is that they key is provided as a string literal)
-    item_accessor operator[](const char *key) const;
-
-    /** \rst
-        Return an internal functor to access the object's attributes. Casting the
-        returned ``detail::obj_attr_accessor`` instance to a `handle` or `object`
-        subclass causes a corresponding call to ``getattr``. Assigning a `handle`
-        or `object` subclass causes a call to ``setattr``.
-    \endrst */
-    obj_attr_accessor attr(handle key) const;
-    /// See above (the only difference is that they key is provided as a string literal)
-    str_attr_accessor attr(const char *key) const;
-
-    /** \rst
-        Matches * unpacking in Python, e.g. to unpack arguments out of a ``tuple``
-        or ``list`` for a function call. Applying another * to the result yields
-        ** unpacking, e.g. to unpack a dict as function keyword arguments.
-        See :ref:`calling_python_functions`.
-    \endrst */
-    args_proxy operator*() const;
-
-    /// Check if the given item is contained within this object, i.e. ``item in obj``.
-    template <typename T> bool contains(T &&item) const;
-
-    /** \rst
-        Assuming the Python object is a function or implements the ``__call__``
-        protocol, ``operator()`` invokes the underlying function, passing an
-        arbitrary set of parameters. The result is returned as a `object` and
-        may need to be converted back into a Python object using `handle::cast()`.
-
-        When some of the arguments cannot be converted to Python objects, the
-        function will throw a `cast_error` exception. When the Python function
-        call fails, a `error_already_set` exception is thrown.
-    \endrst */
-    template <return_value_policy policy = return_value_policy::automatic_reference, typename... Args>
-    object operator()(Args &&...args) const;
-    template <return_value_policy policy = return_value_policy::automatic_reference, typename... Args>
-    PYBIND11_DEPRECATED("call(...) was deprecated in favor of operator()(...)")
-        object call(Args&&... args) const;
-
-    /// Equivalent to ``obj is other`` in Python.
-    bool is(object_api const& other) const { return derived().ptr() == other.derived().ptr(); }
-    /// Equivalent to ``obj is None`` in Python.
-    bool is_none() const { return derived().ptr() == Py_None; }
-    PYBIND11_DEPRECATED("Use py::str(obj) instead")
-    pybind11::str str() const;
-
-    /// Get or set the object's docstring, i.e. ``obj.__doc__``.
-    str_attr_accessor doc() const;
-
-    /// Return the object's current reference count
-    int ref_count() const { return static_cast<int>(Py_REFCNT(derived().ptr())); }
-    /// Return a handle to the Python type object underlying the instance
-    handle get_type() const;
-};
-
-NAMESPACE_END(detail)
-
-/** \rst
-    Holds a reference to a Python object (no reference counting)
-
-    The `handle` class is a thin wrapper around an arbitrary Python object (i.e. a
-    ``PyObject *`` in Python's C API). It does not perform any automatic reference
-    counting and merely provides a basic C++ interface to various Python API functions.
-
-    .. seealso::
-        The `object` class inherits from `handle` and adds automatic reference
-        counting features.
-\endrst */
-class handle : public detail::object_api<handle> {
-public:
-    /// The default constructor creates a handle with a ``nullptr``-valued pointer
-    handle() = default;
-    /// Creates a ``handle`` from the given raw Python object pointer
-    handle(PyObject *ptr) : m_ptr(ptr) { } // Allow implicit conversion from PyObject*
-
-    /// Return the underlying ``PyObject *`` pointer
-    PyObject *ptr() const { return m_ptr; }
-    PyObject *&ptr() { return m_ptr; }
-
-    /** \rst
-        Manually increase the reference count of the Python object. Usually, it is
-        preferable to use the `object` class which derives from `handle` and calls
-        this function automatically. Returns a reference to itself.
-    \endrst */
-    const handle& inc_ref() const & { Py_XINCREF(m_ptr); return *this; }
-
-    /** \rst
-        Manually decrease the reference count of the Python object. Usually, it is
-        preferable to use the `object` class which derives from `handle` and calls
-        this function automatically. Returns a reference to itself.
-    \endrst */
-    const handle& dec_ref() const & { Py_XDECREF(m_ptr); return *this; }
-
-    /** \rst
-        Attempt to cast the Python object into the given C++ type. A `cast_error`
-        will be throw upon failure.
-    \endrst */
-    template <typename T> T cast() const;
-    /// Return ``true`` when the `handle` wraps a valid Python object
-    explicit operator bool() const { return m_ptr != nullptr; }
-    /** \rst
-        Deprecated: Check that the underlying pointers are the same.
-        Equivalent to ``obj1 is obj2`` in Python.
-    \endrst */
-    PYBIND11_DEPRECATED("Use obj1.is(obj2) instead")
-    bool operator==(const handle &h) const { return m_ptr == h.m_ptr; }
-    PYBIND11_DEPRECATED("Use !obj1.is(obj2) instead")
-    bool operator!=(const handle &h) const { return m_ptr != h.m_ptr; }
-    PYBIND11_DEPRECATED("Use handle::operator bool() instead")
-    bool check() const { return m_ptr != nullptr; }
-protected:
-    PyObject *m_ptr = nullptr;
-};
-
-/** \rst
-    Holds a reference to a Python object (with reference counting)
-
-    Like `handle`, the `object` class is a thin wrapper around an arbitrary Python
-    object (i.e. a ``PyObject *`` in Python's C API). In contrast to `handle`, it
-    optionally increases the object's reference count upon construction, and it
-    *always* decreases the reference count when the `object` instance goes out of
-    scope and is destructed. When using `object` instances consistently, it is much
-    easier to get reference counting right at the first attempt.
-\endrst */
-class object : public handle {
-public:
-    object() = default;
-    PYBIND11_DEPRECATED("Use reinterpret_borrow<object>() or reinterpret_steal<object>()")
-    object(handle h, bool is_borrowed) : handle(h) { if (is_borrowed) inc_ref(); }
-    /// Copy constructor; always increases the reference count
-    object(const object &o) : handle(o) { inc_ref(); }
-    /// Move constructor; steals the object from ``other`` and preserves its reference count
-    object(object &&other) noexcept { m_ptr = other.m_ptr; other.m_ptr = nullptr; }
-    /// Destructor; automatically calls `handle::dec_ref()`
-    ~object() { dec_ref(); }
-
-    /** \rst
-        Resets the internal pointer to ``nullptr`` without without decreasing the
-        object's reference count. The function returns a raw handle to the original
-        Python object.
-    \endrst */
-    handle release() {
-      PyObject *tmp = m_ptr;
-      m_ptr = nullptr;
-      return handle(tmp);
-    }
-
-    object& operator=(const object &other) {
-        other.inc_ref();
-        dec_ref();
-        m_ptr = other.m_ptr;
-        return *this;
-    }
-
-    object& operator=(object &&other) noexcept {
-        if (this != &other) {
-            handle temp(m_ptr);
-            m_ptr = other.m_ptr;
-            other.m_ptr = nullptr;
-            temp.dec_ref();
-        }
-        return *this;
-    }
-
-    // Calling cast() on an object lvalue just copies (via handle::cast)
-    template <typename T> T cast() const &;
-    // Calling on an object rvalue does a move, if needed and/or possible
-    template <typename T> T cast() &&;
-
-protected:
-    // Tags for choosing constructors from raw PyObject *
-    struct borrowed_t { };
-    struct stolen_t { };
-
-    template <typename T> friend T reinterpret_borrow(handle);
-    template <typename T> friend T reinterpret_steal(handle);
-
-public:
-    // Only accessible from derived classes and the reinterpret_* functions
-    object(handle h, borrowed_t) : handle(h) { inc_ref(); }
-    object(handle h, stolen_t) : handle(h) { }
-};
-
-/** \rst
-    Declare that a `handle` or ``PyObject *`` is a certain type and borrow the reference.
-    The target type ``T`` must be `object` or one of its derived classes. The function
-    doesn't do any conversions or checks. It's up to the user to make sure that the
-    target type is correct.
-
-    .. code-block:: cpp
-
-        PyObject *p = PyList_GetItem(obj, index);
-        py::object o = reinterpret_borrow<py::object>(p);
-        // or
-        py::tuple t = reinterpret_borrow<py::tuple>(p); // <-- `p` must be already be a `tuple`
-\endrst */
-template <typename T> T reinterpret_borrow(handle h) { return {h, object::borrowed_t{}}; }
-
-/** \rst
-    Like `reinterpret_borrow`, but steals the reference.
-
-     .. code-block:: cpp
-
-        PyObject *p = PyObject_Str(obj);
-        py::str s = reinterpret_steal<py::str>(p); // <-- `p` must be already be a `str`
-\endrst */
-template <typename T> T reinterpret_steal(handle h) { return {h, object::stolen_t{}}; }
-
-NAMESPACE_BEGIN(detail)
-inline std::string error_string();
-NAMESPACE_END(detail)
-
-/// Fetch and hold an error which was already set in Python.  An instance of this is typically
-/// thrown to propagate python-side errors back through C++ which can either be caught manually or
-/// else falls back to the function dispatcher (which then raises the captured error back to
-/// python).
-class error_already_set : public std::runtime_error {
-public:
-    /// Constructs a new exception from the current Python error indicator, if any.  The current
-    /// Python error indicator will be cleared.
-    error_already_set() : std::runtime_error(detail::error_string()) {
-        PyErr_Fetch(&type.ptr(), &value.ptr(), &trace.ptr());
-    }
-
-    inline ~error_already_set();
-
-    /// Give the currently-held error back to Python, if any.  If there is currently a Python error
-    /// already set it is cleared first.  After this call, the current object no longer stores the
-    /// error variables (but the `.what()` string is still available).
-    void restore() { PyErr_Restore(type.release().ptr(), value.release().ptr(), trace.release().ptr()); }
-
-    // Does nothing; provided for backwards compatibility.
-    PYBIND11_DEPRECATED("Use of error_already_set.clear() is deprecated")
-    void clear() {}
-
-    /// Check if the currently trapped error type matches the given Python exception class (or a
-    /// subclass thereof).  May also be passed a tuple to search for any exception class matches in
-    /// the given tuple.
-    bool matches(handle ex) const { return PyErr_GivenExceptionMatches(ex.ptr(), type.ptr()); }
-
-private:
-    object type, value, trace;
-};
-
-/** \defgroup python_builtins _
-    Unless stated otherwise, the following C++ functions behave the same
-    as their Python counterparts.
- */
-
-/** \ingroup python_builtins
-    \rst
-    Return true if ``obj`` is an instance of ``T``. Type ``T`` must be a subclass of
-    `object` or a class which was exposed to Python as ``py::class_<T>``.
-\endrst */
-template <typename T, detail::enable_if_t<std::is_base_of<object, T>::value, int> = 0>
-bool isinstance(handle obj) { return T::check_(obj); }
-
-template <typename T, detail::enable_if_t<!std::is_base_of<object, T>::value, int> = 0>
-bool isinstance(handle obj) { return detail::isinstance_generic(obj, typeid(T)); }
-
-template <> inline bool isinstance<handle>(handle obj) = delete;
-template <> inline bool isinstance<object>(handle obj) { return obj.ptr() != nullptr; }
-
-/// \ingroup python_builtins
-/// Return true if ``obj`` is an instance of the ``type``.
-inline bool isinstance(handle obj, handle type) {
-    const auto result = PyObject_IsInstance(obj.ptr(), type.ptr());
-    if (result == -1)
-        throw error_already_set();
-    return result != 0;
-}
-
-/// \addtogroup python_builtins
-/// @{
-inline bool hasattr(handle obj, handle name) {
-    return PyObject_HasAttr(obj.ptr(), name.ptr()) == 1;
-}
-
-inline bool hasattr(handle obj, const char *name) {
-    return PyObject_HasAttrString(obj.ptr(), name) == 1;
-}
-
-inline object getattr(handle obj, handle name) {
-    PyObject *result = PyObject_GetAttr(obj.ptr(), name.ptr());
-    if (!result) { throw error_already_set(); }
-    return reinterpret_steal<object>(result);
-}
-
-inline object getattr(handle obj, const char *name) {
-    PyObject *result = PyObject_GetAttrString(obj.ptr(), name);
-    if (!result) { throw error_already_set(); }
-    return reinterpret_steal<object>(result);
-}
-
-inline object getattr(handle obj, handle name, handle default_) {
-    if (PyObject *result = PyObject_GetAttr(obj.ptr(), name.ptr())) {
-        return reinterpret_steal<object>(result);
-    } else {
-        PyErr_Clear();
-        return reinterpret_borrow<object>(default_);
-    }
-}
-
-inline object getattr(handle obj, const char *name, handle default_) {
-    if (PyObject *result = PyObject_GetAttrString(obj.ptr(), name)) {
-        return reinterpret_steal<object>(result);
-    } else {
-        PyErr_Clear();
-        return reinterpret_borrow<object>(default_);
-    }
-}
-
-inline void setattr(handle obj, handle name, handle value) {
-    if (PyObject_SetAttr(obj.ptr(), name.ptr(), value.ptr()) != 0) { throw error_already_set(); }
-}
-
-inline void setattr(handle obj, const char *name, handle value) {
-    if (PyObject_SetAttrString(obj.ptr(), name, value.ptr()) != 0) { throw error_already_set(); }
-}
-
-inline ssize_t hash(handle obj) {
-    auto h = PyObject_Hash(obj.ptr());
-    if (h == -1) { throw error_already_set(); }
-    return h;
-}
-
-/// @} python_builtins
-
-NAMESPACE_BEGIN(detail)
-inline handle get_function(handle value) {
-    if (value) {
-#if PY_MAJOR_VERSION >= 3
-        if (PyInstanceMethod_Check(value.ptr()))
-            value = PyInstanceMethod_GET_FUNCTION(value.ptr());
-        else
-#endif
-        if (PyMethod_Check(value.ptr()))
-            value = PyMethod_GET_FUNCTION(value.ptr());
-    }
-    return value;
-}
-
-// Helper aliases/functions to support implicit casting of values given to python accessors/methods.
-// When given a pyobject, this simply returns the pyobject as-is; for other C++ type, the value goes
-// through pybind11::cast(obj) to convert it to an `object`.
-template <typename T, enable_if_t<is_pyobject<T>::value, int> = 0>
-auto object_or_cast(T &&o) -> decltype(std::forward<T>(o)) { return std::forward<T>(o); }
-// The following casting version is implemented in cast.h:
-template <typename T, enable_if_t<!is_pyobject<T>::value, int> = 0>
-object object_or_cast(T &&o);
-// Match a PyObject*, which we want to convert directly to handle via its converting constructor
-inline handle object_or_cast(PyObject *ptr) { return ptr; }
-
-
-template <typename Policy>
-class accessor : public object_api<accessor<Policy>> {
-    using key_type = typename Policy::key_type;
-
-public:
-    accessor(handle obj, key_type key) : obj(obj), key(std::move(key)) { }
-    accessor(const accessor &a) = default;
-    accessor(accessor &&a) = default;
-
-    // accessor overload required to override default assignment operator (templates are not allowed
-    // to replace default compiler-generated assignments).
-    void operator=(const accessor &a) && { std::move(*this).operator=(handle(a)); }
-    void operator=(const accessor &a) & { operator=(handle(a)); }
-
-    template <typename T> void operator=(T &&value) && {
-        Policy::set(obj, key, object_or_cast(std::forward<T>(value)));
-    }
-    template <typename T> void operator=(T &&value) & {
-        get_cache() = reinterpret_borrow<object>(object_or_cast(std::forward<T>(value)));
-    }
-
-    template <typename T = Policy>
-    PYBIND11_DEPRECATED("Use of obj.attr(...) as bool is deprecated in favor of pybind11::hasattr(obj, ...)")
-    explicit operator enable_if_t<std::is_same<T, accessor_policies::str_attr>::value ||
-            std::is_same<T, accessor_policies::obj_attr>::value, bool>() const {
-        return hasattr(obj, key);
-    }
-    template <typename T = Policy>
-    PYBIND11_DEPRECATED("Use of obj[key] as bool is deprecated in favor of obj.contains(key)")
-    explicit operator enable_if_t<std::is_same<T, accessor_policies::generic_item>::value, bool>() const {
-        return obj.contains(key);
-    }
-
-    operator object() const { return get_cache(); }
-    PyObject *ptr() const { return get_cache().ptr(); }
-    template <typename T> T cast() const { return get_cache().template cast<T>(); }
-
-private:
-    object &get_cache() const {
-        if (!cache) { cache = Policy::get(obj, key); }
-        return cache;
-    }
-
-private:
-    handle obj;
-    key_type key;
-    mutable object cache;
-};
-
-NAMESPACE_BEGIN(accessor_policies)
-struct obj_attr {
-    using key_type = object;
-    static object get(handle obj, handle key) { return getattr(obj, key); }
-    static void set(handle obj, handle key, handle val) { setattr(obj, key, val); }
-};
-
-struct str_attr {
-    using key_type = const char *;
-    static object get(handle obj, const char *key) { return getattr(obj, key); }
-    static void set(handle obj, const char *key, handle val) { setattr(obj, key, val); }
-};
-
-struct generic_item {
-    using key_type = object;
-
-    static object get(handle obj, handle key) {
-        PyObject *result = PyObject_GetItem(obj.ptr(), key.ptr());
-        if (!result) { throw error_already_set(); }
-        return reinterpret_steal<object>(result);
-    }
-
-    static void set(handle obj, handle key, handle val) {
-        if (PyObject_SetItem(obj.ptr(), key.ptr(), val.ptr()) != 0) { throw error_already_set(); }
-    }
-};
-
-struct sequence_item {
-    using key_type = size_t;
-
-    static object get(handle obj, size_t index) {
-        PyObject *result = PySequence_GetItem(obj.ptr(), static_cast<ssize_t>(index));
-        if (!result) { throw error_already_set(); }
-        return reinterpret_steal<object>(result);
-    }
-
-    static void set(handle obj, size_t index, handle val) {
-        // PySequence_SetItem does not steal a reference to 'val'
-        if (PySequence_SetItem(obj.ptr(), static_cast<ssize_t>(index), val.ptr()) != 0) {
-            throw error_already_set();
-        }
-    }
-};
-
-struct list_item {
-    using key_type = size_t;
-
-    static object get(handle obj, size_t index) {
-        PyObject *result = PyList_GetItem(obj.ptr(), static_cast<ssize_t>(index));
-        if (!result) { throw error_already_set(); }
-        return reinterpret_borrow<object>(result);
-    }
-
-    static void set(handle obj, size_t index, handle val) {
-        // PyList_SetItem steals a reference to 'val'
-        if (PyList_SetItem(obj.ptr(), static_cast<ssize_t>(index), val.inc_ref().ptr()) != 0) {
-            throw error_already_set();
-        }
-    }
-};
-
-struct tuple_item {
-    using key_type = size_t;
-
-    static object get(handle obj, size_t index) {
-        PyObject *result = PyTuple_GetItem(obj.ptr(), static_cast<ssize_t>(index));
-        if (!result) { throw error_already_set(); }
-        return reinterpret_borrow<object>(result);
-    }
-
-    static void set(handle obj, size_t index, handle val) {
-        // PyTuple_SetItem steals a reference to 'val'
-        if (PyTuple_SetItem(obj.ptr(), static_cast<ssize_t>(index), val.inc_ref().ptr()) != 0) {
-            throw error_already_set();
-        }
-    }
-};
-NAMESPACE_END(accessor_policies)
-
-/// STL iterator template used for tuple, list, sequence and dict
-template <typename Policy>
-class generic_iterator : public Policy {
-    using It = generic_iterator;
-
-public:
-    using difference_type = ssize_t;
-    using iterator_category = typename Policy::iterator_category;
-    using value_type = typename Policy::value_type;
-    using reference = typename Policy::reference;
-    using pointer = typename Policy::pointer;
-
-    generic_iterator() = default;
-    generic_iterator(handle seq, ssize_t index) : Policy(seq, index) { }
-
-    reference operator*() const { return Policy::dereference(); }
-    reference operator[](difference_type n) const { return *(*this + n); }
-    pointer operator->() const { return **this; }
-
-    It &operator++() { Policy::increment(); return *this; }
-    It operator++(int) { auto copy = *this; Policy::increment(); return copy; }
-    It &operator--() { Policy::decrement(); return *this; }
-    It operator--(int) { auto copy = *this; Policy::decrement(); return copy; }
-    It &operator+=(difference_type n) { Policy::advance(n); return *this; }
-    It &operator-=(difference_type n) { Policy::advance(-n); return *this; }
-
-    friend It operator+(const It &a, difference_type n) { auto copy = a; return copy += n; }
-    friend It operator+(difference_type n, const It &b) { return b + n; }
-    friend It operator-(const It &a, difference_type n) { auto copy = a; return copy -= n; }
-    friend difference_type operator-(const It &a, const It &b) { return a.distance_to(b); }
-
-    friend bool operator==(const It &a, const It &b) { return a.equal(b); }
-    friend bool operator!=(const It &a, const It &b) { return !(a == b); }
-    friend bool operator< (const It &a, const It &b) { return b - a > 0; }
-    friend bool operator> (const It &a, const It &b) { return b < a; }
-    friend bool operator>=(const It &a, const It &b) { return !(a < b); }
-    friend bool operator<=(const It &a, const It &b) { return !(a > b); }
-};
-
-NAMESPACE_BEGIN(iterator_policies)
-/// Quick proxy class needed to implement ``operator->`` for iterators which can't return pointers
-template <typename T>
-struct arrow_proxy {
-    T value;
-
-    arrow_proxy(T &&value) : value(std::move(value)) { }
-    T *operator->() const { return &value; }
-};
-
-/// Lightweight iterator policy using just a simple pointer: see ``PySequence_Fast_ITEMS``
-class sequence_fast_readonly {
-protected:
-    using iterator_category = std::random_access_iterator_tag;
-    using value_type = handle;
-    using reference = const handle;
-    using pointer = arrow_proxy<const handle>;
-
-    sequence_fast_readonly(handle obj, ssize_t n) : ptr(PySequence_Fast_ITEMS(obj.ptr()) + n) { }
-
-    reference dereference() const { return *ptr; }
-    void increment() { ++ptr; }
-    void decrement() { --ptr; }
-    void advance(ssize_t n) { ptr += n; }
-    bool equal(const sequence_fast_readonly &b) const { return ptr == b.ptr; }
-    ssize_t distance_to(const sequence_fast_readonly &b) const { return ptr - b.ptr; }
-
-private:
-    PyObject **ptr;
-};
-
-/// Full read and write access using the sequence protocol: see ``detail::sequence_accessor``
-class sequence_slow_readwrite {
-protected:
-    using iterator_category = std::random_access_iterator_tag;
-    using value_type = object;
-    using reference = sequence_accessor;
-    using pointer = arrow_proxy<const sequence_accessor>;
-
-    sequence_slow_readwrite(handle obj, ssize_t index) : obj(obj), index(index) { }
-
-    reference dereference() const { return {obj, static_cast<size_t>(index)}; }
-    void increment() { ++index; }
-    void decrement() { --index; }
-    void advance(ssize_t n) { index += n; }
-    bool equal(const sequence_slow_readwrite &b) const { return index == b.index; }
-    ssize_t distance_to(const sequence_slow_readwrite &b) const { return index - b.index; }
-
-private:
-    handle obj;
-    ssize_t index;
-};
-
-/// Python's dictionary protocol permits this to be a forward iterator
-class dict_readonly {
-protected:
-    using iterator_category = std::forward_iterator_tag;
-    using value_type = std::pair<handle, handle>;
-    using reference = const value_type;
-    using pointer = arrow_proxy<const value_type>;
-
-    dict_readonly() = default;
-    dict_readonly(handle obj, ssize_t pos) : obj(obj), pos(pos) { increment(); }
-
-    reference dereference() const { return {key, value}; }
-    void increment() { if (!PyDict_Next(obj.ptr(), &pos, &key, &value)) { pos = -1; } }
-    bool equal(const dict_readonly &b) const { return pos == b.pos; }
-
-private:
-    handle obj;
-    PyObject *key, *value;
-    ssize_t pos = -1;
-};
-NAMESPACE_END(iterator_policies)
-
-#if !defined(PYPY_VERSION)
-using tuple_iterator = generic_iterator<iterator_policies::sequence_fast_readonly>;
-using list_iterator = generic_iterator<iterator_policies::sequence_fast_readonly>;
-#else
-using tuple_iterator = generic_iterator<iterator_policies::sequence_slow_readwrite>;
-using list_iterator = generic_iterator<iterator_policies::sequence_slow_readwrite>;
-#endif
-
-using sequence_iterator = generic_iterator<iterator_policies::sequence_slow_readwrite>;
-using dict_iterator = generic_iterator<iterator_policies::dict_readonly>;
-
-inline bool PyIterable_Check(PyObject *obj) {
-    PyObject *iter = PyObject_GetIter(obj);
-    if (iter) {
-        Py_DECREF(iter);
-        return true;
-    } else {
-        PyErr_Clear();
-        return false;
-    }
-}
-
-inline bool PyNone_Check(PyObject *o) { return o == Py_None; }
-
-inline bool PyUnicode_Check_Permissive(PyObject *o) { return PyUnicode_Check(o) || PYBIND11_BYTES_CHECK(o); }
-
-class kwargs_proxy : public handle {
-public:
-    explicit kwargs_proxy(handle h) : handle(h) { }
-};
-
-class args_proxy : public handle {
-public:
-    explicit args_proxy(handle h) : handle(h) { }
-    kwargs_proxy operator*() const { return kwargs_proxy(*this); }
-};
-
-/// Python argument categories (using PEP 448 terms)
-template <typename T> using is_keyword = std::is_base_of<arg, T>;
-template <typename T> using is_s_unpacking = std::is_same<args_proxy, T>; // * unpacking
-template <typename T> using is_ds_unpacking = std::is_same<kwargs_proxy, T>; // ** unpacking
-template <typename T> using is_positional = satisfies_none_of<T,
-    is_keyword, is_s_unpacking, is_ds_unpacking
->;
-template <typename T> using is_keyword_or_ds = satisfies_any_of<T, is_keyword, is_ds_unpacking>;
-
-// Call argument collector forward declarations
-template <return_value_policy policy = return_value_policy::automatic_reference>
-class simple_collector;
-template <return_value_policy policy = return_value_policy::automatic_reference>
-class unpacking_collector;
-
-NAMESPACE_END(detail)
-
-// TODO: After the deprecated constructors are removed, this macro can be simplified by
-//       inheriting ctors: `using Parent::Parent`. It's not an option right now because
-//       the `using` statement triggers the parent deprecation warning even if the ctor
-//       isn't even used.
-#define PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun) \
-    public: \
-        PYBIND11_DEPRECATED("Use reinterpret_borrow<"#Name">() or reinterpret_steal<"#Name">()") \
-        Name(handle h, bool is_borrowed) : Parent(is_borrowed ? Parent(h, borrowed_t{}) : Parent(h, stolen_t{})) { } \
-        Name(handle h, borrowed_t) : Parent(h, borrowed_t{}) { } \
-        Name(handle h, stolen_t) : Parent(h, stolen_t{}) { } \
-        PYBIND11_DEPRECATED("Use py::isinstance<py::python_type>(obj) instead") \
-        bool check() const { return m_ptr != nullptr && (bool) CheckFun(m_ptr); } \
-        static bool check_(handle h) { return h.ptr() != nullptr && CheckFun(h.ptr()); }
-
-#define PYBIND11_OBJECT_CVT(Name, Parent, CheckFun, ConvertFun) \
-    PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun) \
-    /* This is deliberately not 'explicit' to allow implicit conversion from object: */ \
-    Name(const object &o) \
-    : Parent(check_(o) ? o.inc_ref().ptr() : ConvertFun(o.ptr()), stolen_t{}) \
-    { if (!m_ptr) throw error_already_set(); } \
-    Name(object &&o) \
-    : Parent(check_(o) ? o.release().ptr() : ConvertFun(o.ptr()), stolen_t{}) \
-    { if (!m_ptr) throw error_already_set(); }
-
-#define PYBIND11_OBJECT(Name, Parent, CheckFun) \
-    PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun) \
-    /* This is deliberately not 'explicit' to allow implicit conversion from object: */ \
-    Name(const object &o) : Parent(o) { } \
-    Name(object &&o) : Parent(std::move(o)) { }
-
-#define PYBIND11_OBJECT_DEFAULT(Name, Parent, CheckFun) \
-    PYBIND11_OBJECT(Name, Parent, CheckFun) \
-    Name() : Parent() { }
-
-/// \addtogroup pytypes
-/// @{
-
-/** \rst
-    Wraps a Python iterator so that it can also be used as a C++ input iterator
-
-    Caveat: copying an iterator does not (and cannot) clone the internal
-    state of the Python iterable. This also applies to the post-increment
-    operator. This iterator should only be used to retrieve the current
-    value using ``operator*()``.
-\endrst */
-class iterator : public object {
-public:
-    using iterator_category = std::input_iterator_tag;
-    using difference_type = ssize_t;
-    using value_type = handle;
-    using reference = const handle;
-    using pointer = const handle *;
-
-    PYBIND11_OBJECT_DEFAULT(iterator, object, PyIter_Check)
-
-    iterator& operator++() {
-        advance();
-        return *this;
-    }
-
-    iterator operator++(int) {
-        auto rv = *this;
-        advance();
-        return rv;
-    }
-
-    reference operator*() const {
-        if (m_ptr && !value.ptr()) {
-            auto& self = const_cast<iterator &>(*this);
-            self.advance();
-        }
-        return value;
-    }
-
-    pointer operator->() const { operator*(); return &value; }
-
-    /** \rst
-         The value which marks the end of the iteration. ``it == iterator::sentinel()``
-         is equivalent to catching ``StopIteration`` in Python.
-
-         .. code-block:: cpp
-
-             void foo(py::iterator it) {
-                 while (it != py::iterator::sentinel()) {
-                    // use `*it`
-                    ++it;
-                 }
-             }
-    \endrst */
-    static iterator sentinel() { return {}; }
-
-    friend bool operator==(const iterator &a, const iterator &b) { return a->ptr() == b->ptr(); }
-    friend bool operator!=(const iterator &a, const iterator &b) { return a->ptr() != b->ptr(); }
-
-private:
-    void advance() {
-        value = reinterpret_steal<object>(PyIter_Next(m_ptr));
-        if (PyErr_Occurred()) { throw error_already_set(); }
-    }
-
-private:
-    object value = {};
-};
-
-class iterable : public object {
-public:
-    PYBIND11_OBJECT_DEFAULT(iterable, object, detail::PyIterable_Check)
-};
-
-class bytes;
-
-class str : public object {
-public:
-    PYBIND11_OBJECT_CVT(str, object, detail::PyUnicode_Check_Permissive, raw_str)
-
-    str(const char *c, size_t n)
-        : object(PyUnicode_FromStringAndSize(c, (ssize_t) n), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate string object!");
-    }
-
-    // 'explicit' is explicitly omitted from the following constructors to allow implicit conversion to py::str from C++ string-like objects
-    str(const char *c = "")
-        : object(PyUnicode_FromString(c), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate string object!");
-    }
-
-    str(const std::string &s) : str(s.data(), s.size()) { }
-
-    explicit str(const bytes &b);
-
-    /** \rst
-        Return a string representation of the object. This is analogous to
-        the ``str()`` function in Python.
-    \endrst */
-    explicit str(handle h) : object(raw_str(h.ptr()), stolen_t{}) { }
-
-    operator std::string() const {
-        object temp = *this;
-        if (PyUnicode_Check(m_ptr)) {
-            temp = reinterpret_steal<object>(PyUnicode_AsUTF8String(m_ptr));
-            if (!temp)
-                pybind11_fail("Unable to extract string contents! (encoding issue)");
-        }
-        char *buffer;
-        ssize_t length;
-        if (PYBIND11_BYTES_AS_STRING_AND_SIZE(temp.ptr(), &buffer, &length))
-            pybind11_fail("Unable to extract string contents! (invalid type)");
-        return std::string(buffer, (size_t) length);
-    }
-
-    template <typename... Args>
-    str format(Args &&...args) const {
-        return attr("format")(std::forward<Args>(args)...);
-    }
-
-private:
-    /// Return string representation -- always returns a new reference, even if already a str
-    static PyObject *raw_str(PyObject *op) {
-        PyObject *str_value = PyObject_Str(op);
-#if PY_MAJOR_VERSION < 3
-        if (!str_value) throw error_already_set();
-        PyObject *unicode = PyUnicode_FromEncodedObject(str_value, "utf-8", nullptr);
-        Py_XDECREF(str_value); str_value = unicode;
-#endif
-        return str_value;
-    }
-};
-/// @} pytypes
-
-inline namespace literals {
-/** \rst
-    String literal version of `str`
- \endrst */
-inline str operator"" _s(const char *s, size_t size) { return {s, size}; }
-}
-
-/// \addtogroup pytypes
-/// @{
-class bytes : public object {
-public:
-    PYBIND11_OBJECT(bytes, object, PYBIND11_BYTES_CHECK)
-
-    // Allow implicit conversion:
-    bytes(const char *c = "")
-        : object(PYBIND11_BYTES_FROM_STRING(c), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate bytes object!");
-    }
-
-    bytes(const char *c, size_t n)
-        : object(PYBIND11_BYTES_FROM_STRING_AND_SIZE(c, (ssize_t) n), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate bytes object!");
-    }
-
-    // Allow implicit conversion:
-    bytes(const std::string &s) : bytes(s.data(), s.size()) { }
-
-    explicit bytes(const pybind11::str &s);
-
-    operator std::string() const {
-        char *buffer;
-        ssize_t length;
-        if (PYBIND11_BYTES_AS_STRING_AND_SIZE(m_ptr, &buffer, &length))
-            pybind11_fail("Unable to extract bytes contents!");
-        return std::string(buffer, (size_t) length);
-    }
-};
-
-inline bytes::bytes(const pybind11::str &s) {
-    object temp = s;
-    if (PyUnicode_Check(s.ptr())) {
-        temp = reinterpret_steal<object>(PyUnicode_AsUTF8String(s.ptr()));
-        if (!temp)
-            pybind11_fail("Unable to extract string contents! (encoding issue)");
-    }
-    char *buffer;
-    ssize_t length;
-    if (PYBIND11_BYTES_AS_STRING_AND_SIZE(temp.ptr(), &buffer, &length))
-        pybind11_fail("Unable to extract string contents! (invalid type)");
-    auto obj = reinterpret_steal<object>(PYBIND11_BYTES_FROM_STRING_AND_SIZE(buffer, length));
-    if (!obj)
-        pybind11_fail("Could not allocate bytes object!");
-    m_ptr = obj.release().ptr();
-}
-
-inline str::str(const bytes& b) {
-    char *buffer;
-    ssize_t length;
-    if (PYBIND11_BYTES_AS_STRING_AND_SIZE(b.ptr(), &buffer, &length))
-        pybind11_fail("Unable to extract bytes contents!");
-    auto obj = reinterpret_steal<object>(PyUnicode_FromStringAndSize(buffer, (ssize_t) length));
-    if (!obj)
-        pybind11_fail("Could not allocate string object!");
-    m_ptr = obj.release().ptr();
-}
-
-class none : public object {
-public:
-    PYBIND11_OBJECT(none, object, detail::PyNone_Check)
-    none() : object(Py_None, borrowed_t{}) { }
-};
-
-class bool_ : public object {
-public:
-    PYBIND11_OBJECT_CVT(bool_, object, PyBool_Check, raw_bool)
-    bool_() : object(Py_False, borrowed_t{}) { }
-    // Allow implicit conversion from and to `bool`:
-    bool_(bool value) : object(value ? Py_True : Py_False, borrowed_t{}) { }
-    operator bool() const { return m_ptr && PyLong_AsLong(m_ptr) != 0; }
-
-private:
-    /// Return the truth value of an object -- always returns a new reference
-    static PyObject *raw_bool(PyObject *op) {
-        const auto value = PyObject_IsTrue(op);
-        if (value == -1) return nullptr;
-        return handle(value ? Py_True : Py_False).inc_ref().ptr();
-    }
-};
-
-NAMESPACE_BEGIN(detail)
-// Converts a value to the given unsigned type.  If an error occurs, you get back (Unsigned) -1;
-// otherwise you get back the unsigned long or unsigned long long value cast to (Unsigned).
-// (The distinction is critically important when casting a returned -1 error value to some other
-// unsigned type: (A)-1 != (B)-1 when A and B are unsigned types of different sizes).
-template <typename Unsigned>
-Unsigned as_unsigned(PyObject *o) {
-    if (sizeof(Unsigned) <= sizeof(unsigned long)
-#if PY_VERSION_HEX < 0x03000000
-            || PyInt_Check(o)
-#endif
-    ) {
-        unsigned long v = PyLong_AsUnsignedLong(o);
-        return v == (unsigned long) -1 && PyErr_Occurred() ? (Unsigned) -1 : (Unsigned) v;
-    }
-    else {
-        unsigned long long v = PyLong_AsUnsignedLongLong(o);
-        return v == (unsigned long long) -1 && PyErr_Occurred() ? (Unsigned) -1 : (Unsigned) v;
-    }
-}
-NAMESPACE_END(detail)
-
-class int_ : public object {
-public:
-    PYBIND11_OBJECT_CVT(int_, object, PYBIND11_LONG_CHECK, PyNumber_Long)
-    int_() : object(PyLong_FromLong(0), stolen_t{}) { }
-    // Allow implicit conversion from C++ integral types:
-    template <typename T,
-              detail::enable_if_t<std::is_integral<T>::value, int> = 0>
-    int_(T value) {
-        if (sizeof(T) <= sizeof(long)) {
-            if (std::is_signed<T>::value)
-                m_ptr = PyLong_FromLong((long) value);
-            else
-                m_ptr = PyLong_FromUnsignedLong((unsigned long) value);
-        } else {
-            if (std::is_signed<T>::value)
-                m_ptr = PyLong_FromLongLong((long long) value);
-            else
-                m_ptr = PyLong_FromUnsignedLongLong((unsigned long long) value);
-        }
-        if (!m_ptr) pybind11_fail("Could not allocate int object!");
-    }
-
-    template <typename T,
-              detail::enable_if_t<std::is_integral<T>::value, int> = 0>
-    operator T() const {
-        return std::is_unsigned<T>::value
-            ? detail::as_unsigned<T>(m_ptr)
-            : sizeof(T) <= sizeof(long)
-              ? (T) PyLong_AsLong(m_ptr)
-              : (T) PYBIND11_LONG_AS_LONGLONG(m_ptr);
-    }
-};
-
-class float_ : public object {
-public:
-    PYBIND11_OBJECT_CVT(float_, object, PyFloat_Check, PyNumber_Float)
-    // Allow implicit conversion from float/double:
-    float_(float value) : object(PyFloat_FromDouble((double) value), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate float object!");
-    }
-    float_(double value = .0) : object(PyFloat_FromDouble((double) value), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate float object!");
-    }
-    operator float() const { return (float) PyFloat_AsDouble(m_ptr); }
-    operator double() const { return (double) PyFloat_AsDouble(m_ptr); }
-};
-
-class weakref : public object {
-public:
-    PYBIND11_OBJECT_DEFAULT(weakref, object, PyWeakref_Check)
-    explicit weakref(handle obj, handle callback = {})
-        : object(PyWeakref_NewRef(obj.ptr(), callback.ptr()), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate weak reference!");
-    }
-};
-
-class slice : public object {
-public:
-    PYBIND11_OBJECT_DEFAULT(slice, object, PySlice_Check)
-    slice(ssize_t start_, ssize_t stop_, ssize_t step_) {
-        int_ start(start_), stop(stop_), step(step_);
-        m_ptr = PySlice_New(start.ptr(), stop.ptr(), step.ptr());
-        if (!m_ptr) pybind11_fail("Could not allocate slice object!");
-    }
-    bool compute(size_t length, size_t *start, size_t *stop, size_t *step,
-                 size_t *slicelength) const {
-        return PySlice_GetIndicesEx((PYBIND11_SLICE_OBJECT *) m_ptr,
-                                    (ssize_t) length, (ssize_t *) start,
-                                    (ssize_t *) stop, (ssize_t *) step,
-                                    (ssize_t *) slicelength) == 0;
-    }
-};
-
-class capsule : public object {
-public:
-    PYBIND11_OBJECT_DEFAULT(capsule, object, PyCapsule_CheckExact)
-    PYBIND11_DEPRECATED("Use reinterpret_borrow<capsule>() or reinterpret_steal<capsule>()")
-    capsule(PyObject *ptr, bool is_borrowed) : object(is_borrowed ? object(ptr, borrowed_t{}) : object(ptr, stolen_t{})) { }
-
-    explicit capsule(const void *value, const char *name = nullptr, void (*destructor)(PyObject *) = nullptr)
-        : object(PyCapsule_New(const_cast<void *>(value), name, destructor), stolen_t{}) {
-        if (!m_ptr)
-            pybind11_fail("Could not allocate capsule object!");
-    }
-
-    PYBIND11_DEPRECATED("Please pass a destructor that takes a void pointer as input")
-    capsule(const void *value, void (*destruct)(PyObject *))
-        : object(PyCapsule_New(const_cast<void*>(value), nullptr, destruct), stolen_t{}) {
-        if (!m_ptr)
-            pybind11_fail("Could not allocate capsule object!");
-    }
-
-    capsule(const void *value, void (*destructor)(void *)) {
-        m_ptr = PyCapsule_New(const_cast<void *>(value), nullptr, [](PyObject *o) {
-            auto destructor = reinterpret_cast<void (*)(void *)>(PyCapsule_GetContext(o));
-            void *ptr = PyCapsule_GetPointer(o, nullptr);
-            destructor(ptr);
-        });
-
-        if (!m_ptr)
-            pybind11_fail("Could not allocate capsule object!");
-
-        if (PyCapsule_SetContext(m_ptr, (void *) destructor) != 0)
-            pybind11_fail("Could not set capsule context!");
-    }
-
-    capsule(void (*destructor)()) {
-        m_ptr = PyCapsule_New(reinterpret_cast<void *>(destructor), nullptr, [](PyObject *o) {
-            auto destructor = reinterpret_cast<void (*)()>(PyCapsule_GetPointer(o, nullptr));
-            destructor();
-        });
-
-        if (!m_ptr)
-            pybind11_fail("Could not allocate capsule object!");
-    }
-
-    template <typename T> operator T *() const {
-        auto name = this->name();
-        T * result = static_cast<T *>(PyCapsule_GetPointer(m_ptr, name));
-        if (!result) pybind11_fail("Unable to extract capsule contents!");
-        return result;
-    }
-
-    const char *name() const { return PyCapsule_GetName(m_ptr); }
-};
-
-class tuple : public object {
-public:
-    PYBIND11_OBJECT_CVT(tuple, object, PyTuple_Check, PySequence_Tuple)
-    explicit tuple(size_t size = 0) : object(PyTuple_New((ssize_t) size), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate tuple object!");
-    }
-    size_t size() const { return (size_t) PyTuple_Size(m_ptr); }
-    detail::tuple_accessor operator[](size_t index) const { return {*this, index}; }
-    detail::tuple_iterator begin() const { return {*this, 0}; }
-    detail::tuple_iterator end() const { return {*this, PyTuple_GET_SIZE(m_ptr)}; }
-};
-
-class dict : public object {
-public:
-    PYBIND11_OBJECT_CVT(dict, object, PyDict_Check, raw_dict)
-    dict() : object(PyDict_New(), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate dict object!");
-    }
-    template <typename... Args,
-              typename = detail::enable_if_t<detail::all_of<detail::is_keyword_or_ds<Args>...>::value>,
-              // MSVC workaround: it can't compile an out-of-line definition, so defer the collector
-              typename collector = detail::deferred_t<detail::unpacking_collector<>, Args...>>
-    explicit dict(Args &&...args) : dict(collector(std::forward<Args>(args)...).kwargs()) { }
-
-    size_t size() const { return (size_t) PyDict_Size(m_ptr); }
-    detail::dict_iterator begin() const { return {*this, 0}; }
-    detail::dict_iterator end() const { return {}; }
-    void clear() const { PyDict_Clear(ptr()); }
-    bool contains(handle key) const { return PyDict_Contains(ptr(), key.ptr()) == 1; }
-    bool contains(const char *key) const { return PyDict_Contains(ptr(), pybind11::str(key).ptr()) == 1; }
-
-private:
-    /// Call the `dict` Python type -- always returns a new reference
-    static PyObject *raw_dict(PyObject *op) {
-        if (PyDict_Check(op))
-            return handle(op).inc_ref().ptr();
-        return PyObject_CallFunctionObjArgs((PyObject *) &PyDict_Type, op, nullptr);
-    }
-};
-
-class sequence : public object {
-public:
-    PYBIND11_OBJECT_DEFAULT(sequence, object, PySequence_Check)
-    size_t size() const { return (size_t) PySequence_Size(m_ptr); }
-    detail::sequence_accessor operator[](size_t index) const { return {*this, index}; }
-    detail::sequence_iterator begin() const { return {*this, 0}; }
-    detail::sequence_iterator end() const { return {*this, PySequence_Size(m_ptr)}; }
-};
-
-class list : public object {
-public:
-    PYBIND11_OBJECT_CVT(list, object, PyList_Check, PySequence_List)
-    explicit list(size_t size = 0) : object(PyList_New((ssize_t) size), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate list object!");
-    }
-    size_t size() const { return (size_t) PyList_Size(m_ptr); }
-    detail::list_accessor operator[](size_t index) const { return {*this, index}; }
-    detail::list_iterator begin() const { return {*this, 0}; }
-    detail::list_iterator end() const { return {*this, PyList_GET_SIZE(m_ptr)}; }
-    template <typename T> void append(T &&val) const {
-        PyList_Append(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr());
-    }
-};
-
-class args : public tuple { PYBIND11_OBJECT_DEFAULT(args, tuple, PyTuple_Check) };
-class kwargs : public dict { PYBIND11_OBJECT_DEFAULT(kwargs, dict, PyDict_Check)  };
-
-class set : public object {
-public:
-    PYBIND11_OBJECT_CVT(set, object, PySet_Check, PySet_New)
-    set() : object(PySet_New(nullptr), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate set object!");
-    }
-    size_t size() const { return (size_t) PySet_Size(m_ptr); }
-    template <typename T> bool add(T &&val) const {
-        return PySet_Add(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr()) == 0;
-    }
-    void clear() const { PySet_Clear(m_ptr); }
-};
-
-class function : public object {
-public:
-    PYBIND11_OBJECT_DEFAULT(function, object, PyCallable_Check)
-    handle cpp_function() const {
-        handle fun = detail::get_function(m_ptr);
-        if (fun && PyCFunction_Check(fun.ptr()))
-            return fun;
-        return handle();
-    }
-    bool is_cpp_function() const { return (bool) cpp_function(); }
-};
-
-class buffer : public object {
-public:
-    PYBIND11_OBJECT_DEFAULT(buffer, object, PyObject_CheckBuffer)
-
-    buffer_info request(bool writable = false) {
-        int flags = PyBUF_STRIDES | PyBUF_FORMAT;
-        if (writable) flags |= PyBUF_WRITABLE;
-        Py_buffer *view = new Py_buffer();
-        if (PyObject_GetBuffer(m_ptr, view, flags) != 0) {
-            delete view;
-            throw error_already_set();
-        }
-        return buffer_info(view);
-    }
-};
-
-class memoryview : public object {
-public:
-    explicit memoryview(const buffer_info& info) {
-        static Py_buffer buf { };
-        // Py_buffer uses signed sizes, strides and shape!..
-        static std::vector<Py_ssize_t> py_strides { };
-        static std::vector<Py_ssize_t> py_shape { };
-        buf.buf = info.ptr;
-        buf.itemsize = info.itemsize;
-        buf.format = const_cast<char *>(info.format.c_str());
-        buf.ndim = (int) info.ndim;
-        buf.len = info.size;
-        py_strides.clear();
-        py_shape.clear();
-        for (size_t i = 0; i < (size_t) info.ndim; ++i) {
-            py_strides.push_back(info.strides[i]);
-            py_shape.push_back(info.shape[i]);
-        }
-        buf.strides = py_strides.data();
-        buf.shape = py_shape.data();
-        buf.suboffsets = nullptr;
-        buf.readonly = false;
-        buf.internal = nullptr;
-
-        m_ptr = PyMemoryView_FromBuffer(&buf);
-        if (!m_ptr)
-            pybind11_fail("Unable to create memoryview from buffer descriptor");
-    }
-
-    PYBIND11_OBJECT_CVT(memoryview, object, PyMemoryView_Check, PyMemoryView_FromObject)
-};
-/// @} pytypes
-
-/// \addtogroup python_builtins
-/// @{
-inline size_t len(handle h) {
-    ssize_t result = PyObject_Length(h.ptr());
-    if (result < 0)
-        pybind11_fail("Unable to compute length of object");
-    return (size_t) result;
-}
-
-inline str repr(handle h) {
-    PyObject *str_value = PyObject_Repr(h.ptr());
-    if (!str_value) throw error_already_set();
-#if PY_MAJOR_VERSION < 3
-    PyObject *unicode = PyUnicode_FromEncodedObject(str_value, "utf-8", nullptr);
-    Py_XDECREF(str_value); str_value = unicode;
-    if (!str_value) throw error_already_set();
-#endif
-    return reinterpret_steal<str>(str_value);
-}
-
-inline iterator iter(handle obj) {
-    PyObject *result = PyObject_GetIter(obj.ptr());
-    if (!result) { throw error_already_set(); }
-    return reinterpret_steal<iterator>(result);
-}
-/// @} python_builtins
-
-NAMESPACE_BEGIN(detail)
-template <typename D> iterator object_api<D>::begin() const { return iter(derived()); }
-template <typename D> iterator object_api<D>::end() const { return iterator::sentinel(); }
-template <typename D> item_accessor object_api<D>::operator[](handle key) const {
-    return {derived(), reinterpret_borrow<object>(key)};
-}
-template <typename D> item_accessor object_api<D>::operator[](const char *key) const {
-    return {derived(), pybind11::str(key)};
-}
-template <typename D> obj_attr_accessor object_api<D>::attr(handle key) const {
-    return {derived(), reinterpret_borrow<object>(key)};
-}
-template <typename D> str_attr_accessor object_api<D>::attr(const char *key) const {
-    return {derived(), key};
-}
-template <typename D> args_proxy object_api<D>::operator*() const {
-    return args_proxy(derived().ptr());
-}
-template <typename D> template <typename T> bool object_api<D>::contains(T &&item) const {
-    return attr("__contains__")(std::forward<T>(item)).template cast<bool>();
-}
-
-template <typename D>
-pybind11::str object_api<D>::str() const { return pybind11::str(derived()); }
-
-template <typename D>
-str_attr_accessor object_api<D>::doc() const { return attr("__doc__"); }
-
-template <typename D>
-handle object_api<D>::get_type() const { return (PyObject *) Py_TYPE(derived().ptr()); }
-
-NAMESPACE_END(detail)
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/include/pybind11/stl.h b/tmap/lib/pybind11/include/pybind11/stl.h
deleted file mode 100644
index ac212bf..0000000
--- a/tmap/lib/pybind11/include/pybind11/stl.h
+++ /dev/null
@@ -1,369 +0,0 @@
-/*
-    pybind11/stl.h: Transparent conversion for STL data types
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "pybind11.h"
-#include <set>
-#include <unordered_set>
-#include <map>
-#include <unordered_map>
-#include <iostream>
-#include <list>
-#include <valarray>
-
-#if defined(_MSC_VER)
-#pragma warning(push)
-#pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#endif
-
-#ifdef __has_include
-// std::optional (but including it in c++14 mode isn't allowed)
-#  if defined(PYBIND11_CPP17) && __has_include(<optional>)
-#    include <optional>
-#    define PYBIND11_HAS_OPTIONAL 1
-#  endif
-// std::experimental::optional (but not allowed in c++11 mode)
-#  if defined(PYBIND11_CPP14) && __has_include(<experimental/optional>)
-#    include <experimental/optional>
-#    define PYBIND11_HAS_EXP_OPTIONAL 1
-#  endif
-// std::variant
-#  if defined(PYBIND11_CPP17) && __has_include(<variant>)
-#    include <variant>
-#    define PYBIND11_HAS_VARIANT 1
-#  endif
-#elif defined(_MSC_VER) && defined(PYBIND11_CPP17)
-#  include <optional>
-#  include <variant>
-#  define PYBIND11_HAS_OPTIONAL 1
-#  define PYBIND11_HAS_VARIANT 1
-#endif
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
-
-/// Extracts an const lvalue reference or rvalue reference for U based on the type of T (e.g. for
-/// forwarding a container element).  Typically used indirect via forwarded_type(), below.
-template <typename T, typename U>
-using forwarded_type = conditional_t<
-    std::is_lvalue_reference<T>::value, remove_reference_t<U> &, remove_reference_t<U> &&>;
-
-/// Forwards a value U as rvalue or lvalue according to whether T is rvalue or lvalue; typically
-/// used for forwarding a container's elements.
-template <typename T, typename U>
-forwarded_type<T, U> forward_like(U &&u) {
-    return std::forward<detail::forwarded_type<T, U>>(std::forward<U>(u));
-}
-
-template <typename Type, typename Key> struct set_caster {
-    using type = Type;
-    using key_conv = make_caster<Key>;
-
-    bool load(handle src, bool convert) {
-        if (!isinstance<pybind11::set>(src))
-            return false;
-        auto s = reinterpret_borrow<pybind11::set>(src);
-        value.clear();
-        for (auto entry : s) {
-            key_conv conv;
-            if (!conv.load(entry, convert))
-                return false;
-            value.insert(cast_op<Key &&>(std::move(conv)));
-        }
-        return true;
-    }
-
-    template <typename T>
-    static handle cast(T &&src, return_value_policy policy, handle parent) {
-        pybind11::set s;
-        for (auto &value: src) {
-            auto value_ = reinterpret_steal<object>(key_conv::cast(forward_like<T>(value), policy, parent));
-            if (!value_ || !s.add(value_))
-                return handle();
-        }
-        return s.release();
-    }
-
-    PYBIND11_TYPE_CASTER(type, _("Set[") + key_conv::name() + _("]"));
-};
-
-template <typename Type, typename Key, typename Value> struct map_caster {
-    using key_conv   = make_caster<Key>;
-    using value_conv = make_caster<Value>;
-
-    bool load(handle src, bool convert) {
-        if (!isinstance<dict>(src))
-            return false;
-        auto d = reinterpret_borrow<dict>(src);
-        value.clear();
-        for (auto it : d) {
-            key_conv kconv;
-            value_conv vconv;
-            if (!kconv.load(it.first.ptr(), convert) ||
-                !vconv.load(it.second.ptr(), convert))
-                return false;
-            value.emplace(cast_op<Key &&>(std::move(kconv)), cast_op<Value &&>(std::move(vconv)));
-        }
-        return true;
-    }
-
-    template <typename T>
-    static handle cast(T &&src, return_value_policy policy, handle parent) {
-        dict d;
-        for (auto &kv: src) {
-            auto key = reinterpret_steal<object>(key_conv::cast(forward_like<T>(kv.first), policy, parent));
-            auto value = reinterpret_steal<object>(value_conv::cast(forward_like<T>(kv.second), policy, parent));
-            if (!key || !value)
-                return handle();
-            d[key] = value;
-        }
-        return d.release();
-    }
-
-    PYBIND11_TYPE_CASTER(Type, _("Dict[") + key_conv::name() + _(", ") + value_conv::name() + _("]"));
-};
-
-template <typename Type, typename Value> struct list_caster {
-    using value_conv = make_caster<Value>;
-
-    bool load(handle src, bool convert) {
-        if (!isinstance<sequence>(src))
-            return false;
-        auto s = reinterpret_borrow<sequence>(src);
-        value.clear();
-        reserve_maybe(s, &value);
-        for (auto it : s) {
-            value_conv conv;
-            if (!conv.load(it, convert))
-                return false;
-            value.push_back(cast_op<Value &&>(std::move(conv)));
-        }
-        return true;
-    }
-
-private:
-    template <typename T = Type,
-              enable_if_t<std::is_same<decltype(std::declval<T>().reserve(0)), void>::value, int> = 0>
-    void reserve_maybe(sequence s, Type *) { value.reserve(s.size()); }
-    void reserve_maybe(sequence, void *) { }
-
-public:
-    template <typename T>
-    static handle cast(T &&src, return_value_policy policy, handle parent) {
-        list l(src.size());
-        size_t index = 0;
-        for (auto &value: src) {
-            auto value_ = reinterpret_steal<object>(value_conv::cast(forward_like<T>(value), policy, parent));
-            if (!value_)
-                return handle();
-            PyList_SET_ITEM(l.ptr(), (ssize_t) index++, value_.release().ptr()); // steals a reference
-        }
-        return l.release();
-    }
-
-    PYBIND11_TYPE_CASTER(Type, _("List[") + value_conv::name() + _("]"));
-};
-
-template <typename Type, typename Alloc> struct type_caster<std::vector<Type, Alloc>>
- : list_caster<std::vector<Type, Alloc>, Type> { };
-
-template <typename Type, typename Alloc> struct type_caster<std::list<Type, Alloc>>
- : list_caster<std::list<Type, Alloc>, Type> { };
-
-template <typename ArrayType, typename Value, bool Resizable, size_t Size = 0> struct array_caster {
-    using value_conv = make_caster<Value>;
-
-private:
-    template <bool R = Resizable>
-    bool require_size(enable_if_t<R, size_t> size) {
-        if (value.size() != size)
-            value.resize(size);
-        return true;
-    }
-    template <bool R = Resizable>
-    bool require_size(enable_if_t<!R, size_t> size) {
-        return size == Size;
-    }
-
-public:
-    bool load(handle src, bool convert) {
-        if (!isinstance<list>(src))
-            return false;
-        auto l = reinterpret_borrow<list>(src);
-        if (!require_size(l.size()))
-            return false;
-        size_t ctr = 0;
-        for (auto it : l) {
-            value_conv conv;
-            if (!conv.load(it, convert))
-                return false;
-            value[ctr++] = cast_op<Value &&>(std::move(conv));
-        }
-        return true;
-    }
-
-    template <typename T>
-    static handle cast(T &&src, return_value_policy policy, handle parent) {
-        list l(src.size());
-        size_t index = 0;
-        for (auto &value: src) {
-            auto value_ = reinterpret_steal<object>(value_conv::cast(forward_like<T>(value), policy, parent));
-            if (!value_)
-                return handle();
-            PyList_SET_ITEM(l.ptr(), (ssize_t) index++, value_.release().ptr()); // steals a reference
-        }
-        return l.release();
-    }
-
-    PYBIND11_TYPE_CASTER(ArrayType, _("List[") + value_conv::name() + _<Resizable>(_(""), _("[") + _<Size>() + _("]")) + _("]"));
-};
-
-template <typename Type, size_t Size> struct type_caster<std::array<Type, Size>>
- : array_caster<std::array<Type, Size>, Type, false, Size> { };
-
-template <typename Type> struct type_caster<std::valarray<Type>>
- : array_caster<std::valarray<Type>, Type, true> { };
-
-template <typename Key, typename Compare, typename Alloc> struct type_caster<std::set<Key, Compare, Alloc>>
-  : set_caster<std::set<Key, Compare, Alloc>, Key> { };
-
-template <typename Key, typename Hash, typename Equal, typename Alloc> struct type_caster<std::unordered_set<Key, Hash, Equal, Alloc>>
-  : set_caster<std::unordered_set<Key, Hash, Equal, Alloc>, Key> { };
-
-template <typename Key, typename Value, typename Compare, typename Alloc> struct type_caster<std::map<Key, Value, Compare, Alloc>>
-  : map_caster<std::map<Key, Value, Compare, Alloc>, Key, Value> { };
-
-template <typename Key, typename Value, typename Hash, typename Equal, typename Alloc> struct type_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>>
-  : map_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>, Key, Value> { };
-
-// This type caster is intended to be used for std::optional and std::experimental::optional
-template<typename T> struct optional_caster {
-    using value_conv = make_caster<typename T::value_type>;
-
-    template <typename T_>
-    static handle cast(T_ &&src, return_value_policy policy, handle parent) {
-        if (!src)
-            return none().inc_ref();
-        return value_conv::cast(*std::forward<T_>(src), policy, parent);
-    }
-
-    bool load(handle src, bool convert) {
-        if (!src) {
-            return false;
-        } else if (src.is_none()) {
-            return true;  // default-constructed value is already empty
-        }
-        value_conv inner_caster;
-        if (!inner_caster.load(src, convert))
-            return false;
-
-        value.emplace(cast_op<typename T::value_type &&>(std::move(inner_caster)));
-        return true;
-    }
-
-    PYBIND11_TYPE_CASTER(T, _("Optional[") + value_conv::name() + _("]"));
-};
-
-#if PYBIND11_HAS_OPTIONAL
-template<typename T> struct type_caster<std::optional<T>>
-    : public optional_caster<std::optional<T>> {};
-
-template<> struct type_caster<std::nullopt_t>
-    : public void_caster<std::nullopt_t> {};
-#endif
-
-#if PYBIND11_HAS_EXP_OPTIONAL
-template<typename T> struct type_caster<std::experimental::optional<T>>
-    : public optional_caster<std::experimental::optional<T>> {};
-
-template<> struct type_caster<std::experimental::nullopt_t>
-    : public void_caster<std::experimental::nullopt_t> {};
-#endif
-
-/// Visit a variant and cast any found type to Python
-struct variant_caster_visitor {
-    return_value_policy policy;
-    handle parent;
-
-    using result_type = handle; // required by boost::variant in C++11
-
-    template <typename T>
-    result_type operator()(T &&src) const {
-        return make_caster<T>::cast(std::forward<T>(src), policy, parent);
-    }
-};
-
-/// Helper class which abstracts away variant's `visit` function. `std::variant` and similar
-/// `namespace::variant` types which provide a `namespace::visit()` function are handled here
-/// automatically using argument-dependent lookup. Users can provide specializations for other
-/// variant-like classes, e.g. `boost::variant` and `boost::apply_visitor`.
-template <template<typename...> class Variant>
-struct visit_helper {
-    template <typename... Args>
-    static auto call(Args &&...args) -> decltype(visit(std::forward<Args>(args)...)) {
-        return visit(std::forward<Args>(args)...);
-    }
-};
-
-/// Generic variant caster
-template <typename Variant> struct variant_caster;
-
-template <template<typename...> class V, typename... Ts>
-struct variant_caster<V<Ts...>> {
-    static_assert(sizeof...(Ts) > 0, "Variant must consist of at least one alternative.");
-
-    template <typename U, typename... Us>
-    bool load_alternative(handle src, bool convert, type_list<U, Us...>) {
-        auto caster = make_caster<U>();
-        if (caster.load(src, convert)) {
-            value = cast_op<U>(caster);
-            return true;
-        }
-        return load_alternative(src, convert, type_list<Us...>{});
-    }
-
-    bool load_alternative(handle, bool, type_list<>) { return false; }
-
-    bool load(handle src, bool convert) {
-        // Do a first pass without conversions to improve constructor resolution.
-        // E.g. `py::int_(1).cast<variant<double, int>>()` needs to fill the `int`
-        // slot of the variant. Without two-pass loading `double` would be filled
-        // because it appears first and a conversion is possible.
-        if (convert && load_alternative(src, false, type_list<Ts...>{}))
-            return true;
-        return load_alternative(src, convert, type_list<Ts...>{});
-    }
-
-    template <typename Variant>
-    static handle cast(Variant &&src, return_value_policy policy, handle parent) {
-        return visit_helper<V>::call(variant_caster_visitor{policy, parent},
-                                     std::forward<Variant>(src));
-    }
-
-    using Type = V<Ts...>;
-    PYBIND11_TYPE_CASTER(Type, _("Union[") + detail::concat(make_caster<Ts>::name()...) + _("]"));
-};
-
-#if PYBIND11_HAS_VARIANT
-template <typename... Ts>
-struct type_caster<std::variant<Ts...>> : variant_caster<std::variant<Ts...>> { };
-#endif
-NAMESPACE_END(detail)
-
-inline std::ostream &operator<<(std::ostream &os, const handle &obj) {
-    os << (std::string) str(obj);
-    return os;
-}
-
-NAMESPACE_END(PYBIND11_NAMESPACE)
-
-#if defined(_MSC_VER)
-#pragma warning(pop)
-#endif
diff --git a/tmap/lib/pybind11/include/pybind11/stl_bind.h b/tmap/lib/pybind11/include/pybind11/stl_bind.h
deleted file mode 100644
index 7ef6878..0000000
--- a/tmap/lib/pybind11/include/pybind11/stl_bind.h
+++ /dev/null
@@ -1,599 +0,0 @@
-/*
-    pybind11/std_bind.h: Binding generators for STL data types
-
-    Copyright (c) 2016 Sergey Lyskov and Wenzel Jakob
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "detail/common.h"
-#include "operators.h"
-
-#include <algorithm>
-#include <sstream>
-
-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-NAMESPACE_BEGIN(detail)
-
-/* SFINAE helper class used by 'is_comparable */
-template <typename T>  struct container_traits {
-    template <typename T2> static std::true_type test_comparable(decltype(std::declval<const T2 &>() == std::declval<const T2 &>())*);
-    template <typename T2> static std::false_type test_comparable(...);
-    template <typename T2> static std::true_type test_value(typename T2::value_type *);
-    template <typename T2> static std::false_type test_value(...);
-    template <typename T2> static std::true_type test_pair(typename T2::first_type *, typename T2::second_type *);
-    template <typename T2> static std::false_type test_pair(...);
-
-    static constexpr const bool is_comparable = std::is_same<std::true_type, decltype(test_comparable<T>(nullptr))>::value;
-    static constexpr const bool is_pair = std::is_same<std::true_type, decltype(test_pair<T>(nullptr, nullptr))>::value;
-    static constexpr const bool is_vector = std::is_same<std::true_type, decltype(test_value<T>(nullptr))>::value;
-    static constexpr const bool is_element = !is_pair && !is_vector;
-};
-
-/* Default: is_comparable -> std::false_type */
-template <typename T, typename SFINAE = void>
-struct is_comparable : std::false_type { };
-
-/* For non-map data structures, check whether operator== can be instantiated */
-template <typename T>
-struct is_comparable<
-    T, enable_if_t<container_traits<T>::is_element &&
-                   container_traits<T>::is_comparable>>
-    : std::true_type { };
-
-/* For a vector/map data structure, recursively check the value type (which is std::pair for maps) */
-template <typename T>
-struct is_comparable<T, enable_if_t<container_traits<T>::is_vector>> {
-    static constexpr const bool value =
-        is_comparable<typename T::value_type>::value;
-};
-
-/* For pairs, recursively check the two data types */
-template <typename T>
-struct is_comparable<T, enable_if_t<container_traits<T>::is_pair>> {
-    static constexpr const bool value =
-        is_comparable<typename T::first_type>::value &&
-        is_comparable<typename T::second_type>::value;
-};
-
-/* Fallback functions */
-template <typename, typename, typename... Args> void vector_if_copy_constructible(const Args &...) { }
-template <typename, typename, typename... Args> void vector_if_equal_operator(const Args &...) { }
-template <typename, typename, typename... Args> void vector_if_insertion_operator(const Args &...) { }
-template <typename, typename, typename... Args> void vector_modifiers(const Args &...) { }
-
-template<typename Vector, typename Class_>
-void vector_if_copy_constructible(enable_if_t<is_copy_constructible<Vector>::value, Class_> &cl) {
-    cl.def(init<const Vector &>(), "Copy constructor");
-}
-
-template<typename Vector, typename Class_>
-void vector_if_equal_operator(enable_if_t<is_comparable<Vector>::value, Class_> &cl) {
-    using T = typename Vector::value_type;
-
-    cl.def(self == self);
-    cl.def(self != self);
-
-    cl.def("count",
-        [](const Vector &v, const T &x) {
-            return std::count(v.begin(), v.end(), x);
-        },
-        arg("x"),
-        "Return the number of times ``x`` appears in the list"
-    );
-
-    cl.def("remove", [](Vector &v, const T &x) {
-            auto p = std::find(v.begin(), v.end(), x);
-            if (p != v.end())
-                v.erase(p);
-            else
-                throw value_error();
-        },
-        arg("x"),
-        "Remove the first item from the list whose value is x. "
-        "It is an error if there is no such item."
-    );
-
-    cl.def("__contains__",
-        [](const Vector &v, const T &x) {
-            return std::find(v.begin(), v.end(), x) != v.end();
-        },
-        arg("x"),
-        "Return true the container contains ``x``"
-    );
-}
-
-// Vector modifiers -- requires a copyable vector_type:
-// (Technically, some of these (pop and __delitem__) don't actually require copyability, but it seems
-// silly to allow deletion but not insertion, so include them here too.)
-template <typename Vector, typename Class_>
-void vector_modifiers(enable_if_t<is_copy_constructible<typename Vector::value_type>::value, Class_> &cl) {
-    using T = typename Vector::value_type;
-    using SizeType = typename Vector::size_type;
-    using DiffType = typename Vector::difference_type;
-
-    cl.def("append",
-           [](Vector &v, const T &value) { v.push_back(value); },
-           arg("x"),
-           "Add an item to the end of the list");
-
-    cl.def(init([](iterable it) {
-        auto v = std::unique_ptr<Vector>(new Vector());
-        v->reserve(len(it));
-        for (handle h : it)
-           v->push_back(h.cast<T>());
-        return v.release();
-    }));
-
-    cl.def("extend",
-       [](Vector &v, const Vector &src) {
-           v.insert(v.end(), src.begin(), src.end());
-       },
-       arg("L"),
-       "Extend the list by appending all the items in the given list"
-    );
-
-    cl.def("insert",
-        [](Vector &v, SizeType i, const T &x) {
-            if (i > v.size())
-                throw index_error();
-            v.insert(v.begin() + (DiffType) i, x);
-        },
-        arg("i") , arg("x"),
-        "Insert an item at a given position."
-    );
-
-    cl.def("pop",
-        [](Vector &v) {
-            if (v.empty())
-                throw index_error();
-            T t = v.back();
-            v.pop_back();
-            return t;
-        },
-        "Remove and return the last item"
-    );
-
-    cl.def("pop",
-        [](Vector &v, SizeType i) {
-            if (i >= v.size())
-                throw index_error();
-            T t = v[i];
-            v.erase(v.begin() + (DiffType) i);
-            return t;
-        },
-        arg("i"),
-        "Remove and return the item at index ``i``"
-    );
-
-    cl.def("__setitem__",
-        [](Vector &v, SizeType i, const T &t) {
-            if (i >= v.size())
-                throw index_error();
-            v[i] = t;
-        }
-    );
-
-    /// Slicing protocol
-    cl.def("__getitem__",
-        [](const Vector &v, slice slice) -> Vector * {
-            size_t start, stop, step, slicelength;
-
-            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))
-                throw error_already_set();
-
-            Vector *seq = new Vector();
-            seq->reserve((size_t) slicelength);
-
-            for (size_t i=0; i<slicelength; ++i) {
-                seq->push_back(v[start]);
-                start += step;
-            }
-            return seq;
-        },
-        arg("s"),
-        "Retrieve list elements using a slice object"
-    );
-
-    cl.def("__setitem__",
-        [](Vector &v, slice slice,  const Vector &value) {
-            size_t start, stop, step, slicelength;
-            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))
-                throw error_already_set();
-
-            if (slicelength != value.size())
-                throw std::runtime_error("Left and right hand size of slice assignment have different sizes!");
-
-            for (size_t i=0; i<slicelength; ++i) {
-                v[start] = value[i];
-                start += step;
-            }
-        },
-        "Assign list elements using a slice object"
-    );
-
-    cl.def("__delitem__",
-        [](Vector &v, SizeType i) {
-            if (i >= v.size())
-                throw index_error();
-            v.erase(v.begin() + DiffType(i));
-        },
-        "Delete the list elements at index ``i``"
-    );
-
-    cl.def("__delitem__",
-        [](Vector &v, slice slice) {
-            size_t start, stop, step, slicelength;
-
-            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))
-                throw error_already_set();
-
-            if (step == 1 && false) {
-                v.erase(v.begin() + (DiffType) start, v.begin() + DiffType(start + slicelength));
-            } else {
-                for (size_t i = 0; i < slicelength; ++i) {
-                    v.erase(v.begin() + DiffType(start));
-                    start += step - 1;
-                }
-            }
-        },
-        "Delete list elements using a slice object"
-    );
-
-}
-
-// If the type has an operator[] that doesn't return a reference (most notably std::vector<bool>),
-// we have to access by copying; otherwise we return by reference.
-template <typename Vector> using vector_needs_copy = negation<
-    std::is_same<decltype(std::declval<Vector>()[typename Vector::size_type()]), typename Vector::value_type &>>;
-
-// The usual case: access and iterate by reference
-template <typename Vector, typename Class_>
-void vector_accessor(enable_if_t<!vector_needs_copy<Vector>::value, Class_> &cl) {
-    using T = typename Vector::value_type;
-    using SizeType = typename Vector::size_type;
-    using ItType   = typename Vector::iterator;
-
-    cl.def("__getitem__",
-        [](Vector &v, SizeType i) -> T & {
-            if (i >= v.size())
-                throw index_error();
-            return v[i];
-        },
-        return_value_policy::reference_internal // ref + keepalive
-    );
-
-    cl.def("__iter__",
-           [](Vector &v) {
-               return make_iterator<
-                   return_value_policy::reference_internal, ItType, ItType, T&>(
-                   v.begin(), v.end());
-           },
-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
-    );
-}
-
-// The case for special objects, like std::vector<bool>, that have to be returned-by-copy:
-template <typename Vector, typename Class_>
-void vector_accessor(enable_if_t<vector_needs_copy<Vector>::value, Class_> &cl) {
-    using T = typename Vector::value_type;
-    using SizeType = typename Vector::size_type;
-    using ItType   = typename Vector::iterator;
-    cl.def("__getitem__",
-        [](const Vector &v, SizeType i) -> T {
-            if (i >= v.size())
-                throw index_error();
-            return v[i];
-        }
-    );
-
-    cl.def("__iter__",
-           [](Vector &v) {
-               return make_iterator<
-                   return_value_policy::copy, ItType, ItType, T>(
-                   v.begin(), v.end());
-           },
-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
-    );
-}
-
-template <typename Vector, typename Class_> auto vector_if_insertion_operator(Class_ &cl, std::string const &name)
-    -> decltype(std::declval<std::ostream&>() << std::declval<typename Vector::value_type>(), void()) {
-    using size_type = typename Vector::size_type;
-
-    cl.def("__repr__",
-           [name](Vector &v) {
-            std::ostringstream s;
-            s << name << '[';
-            for (size_type i=0; i < v.size(); ++i) {
-                s << v[i];
-                if (i != v.size() - 1)
-                    s << ", ";
-            }
-            s << ']';
-            return s.str();
-        },
-        "Return the canonical string representation of this list."
-    );
-}
-
-// Provide the buffer interface for vectors if we have data() and we have a format for it
-// GCC seems to have "void std::vector<bool>::data()" - doing SFINAE on the existence of data() is insufficient, we need to check it returns an appropriate pointer
-template <typename Vector, typename = void>
-struct vector_has_data_and_format : std::false_type {};
-template <typename Vector>
-struct vector_has_data_and_format<Vector, enable_if_t<std::is_same<decltype(format_descriptor<typename Vector::value_type>::format(), std::declval<Vector>().data()), typename Vector::value_type*>::value>> : std::true_type {};
-
-// Add the buffer interface to a vector
-template <typename Vector, typename Class_, typename... Args>
-enable_if_t<detail::any_of<std::is_same<Args, buffer_protocol>...>::value>
-vector_buffer(Class_& cl) {
-    using T = typename Vector::value_type;
-
-    static_assert(vector_has_data_and_format<Vector>::value, "There is not an appropriate format descriptor for this vector");
-
-    // numpy.h declares this for arbitrary types, but it may raise an exception and crash hard at runtime if PYBIND11_NUMPY_DTYPE hasn't been called, so check here
-    format_descriptor<T>::format();
-
-    cl.def_buffer([](Vector& v) -> buffer_info {
-        return buffer_info(v.data(), static_cast<ssize_t>(sizeof(T)), format_descriptor<T>::format(), 1, {v.size()}, {sizeof(T)});
-    });
-
-    cl.def(init([](buffer buf) {
-        auto info = buf.request();
-        if (info.ndim != 1 || info.strides[0] % static_cast<ssize_t>(sizeof(T)))
-            throw type_error("Only valid 1D buffers can be copied to a vector");
-        if (!detail::compare_buffer_info<T>::compare(info) || (ssize_t) sizeof(T) != info.itemsize)
-            throw type_error("Format mismatch (Python: " + info.format + " C++: " + format_descriptor<T>::format() + ")");
-
-        auto vec = std::unique_ptr<Vector>(new Vector());
-        vec->reserve((size_t) info.shape[0]);
-        T *p = static_cast<T*>(info.ptr);
-        ssize_t step = info.strides[0] / static_cast<ssize_t>(sizeof(T));
-        T *end = p + info.shape[0] * step;
-        for (; p != end; p += step)
-            vec->push_back(*p);
-        return vec.release();
-    }));
-
-    return;
-}
-
-template <typename Vector, typename Class_, typename... Args>
-enable_if_t<!detail::any_of<std::is_same<Args, buffer_protocol>...>::value> vector_buffer(Class_&) {}
-
-NAMESPACE_END(detail)
-
-//
-// std::vector
-//
-template <typename Vector, typename holder_type = std::unique_ptr<Vector>, typename... Args>
-class_<Vector, holder_type> bind_vector(handle scope, std::string const &name, Args&&... args) {
-    using Class_ = class_<Vector, holder_type>;
-
-    // If the value_type is unregistered (e.g. a converting type) or is itself registered
-    // module-local then make the vector binding module-local as well:
-    using vtype = typename Vector::value_type;
-    auto vtype_info = detail::get_type_info(typeid(vtype));
-    bool local = !vtype_info || vtype_info->module_local;
-
-    Class_ cl(scope, name.c_str(), pybind11::module_local(local), std::forward<Args>(args)...);
-
-    // Declare the buffer interface if a buffer_protocol() is passed in
-    detail::vector_buffer<Vector, Class_, Args...>(cl);
-
-    cl.def(init<>());
-
-    // Register copy constructor (if possible)
-    detail::vector_if_copy_constructible<Vector, Class_>(cl);
-
-    // Register comparison-related operators and functions (if possible)
-    detail::vector_if_equal_operator<Vector, Class_>(cl);
-
-    // Register stream insertion operator (if possible)
-    detail::vector_if_insertion_operator<Vector, Class_>(cl, name);
-
-    // Modifiers require copyable vector value type
-    detail::vector_modifiers<Vector, Class_>(cl);
-
-    // Accessor and iterator; return by value if copyable, otherwise we return by ref + keep-alive
-    detail::vector_accessor<Vector, Class_>(cl);
-
-    cl.def("__bool__",
-        [](const Vector &v) -> bool {
-            return !v.empty();
-        },
-        "Check whether the list is nonempty"
-    );
-
-    cl.def("__len__", &Vector::size);
-
-
-
-
-#if 0
-    // C++ style functions deprecated, leaving it here as an example
-    cl.def(init<size_type>());
-
-    cl.def("resize",
-         (void (Vector::*) (size_type count)) & Vector::resize,
-         "changes the number of elements stored");
-
-    cl.def("erase",
-        [](Vector &v, SizeType i) {
-        if (i >= v.size())
-            throw index_error();
-        v.erase(v.begin() + i);
-    }, "erases element at index ``i``");
-
-    cl.def("empty",         &Vector::empty,         "checks whether the container is empty");
-    cl.def("size",          &Vector::size,          "returns the number of elements");
-    cl.def("push_back", (void (Vector::*)(const T&)) &Vector::push_back, "adds an element to the end");
-    cl.def("pop_back",                               &Vector::pop_back, "removes the last element");
-
-    cl.def("max_size",      &Vector::max_size,      "returns the maximum possible number of elements");
-    cl.def("reserve",       &Vector::reserve,       "reserves storage");
-    cl.def("capacity",      &Vector::capacity,      "returns the number of elements that can be held in currently allocated storage");
-    cl.def("shrink_to_fit", &Vector::shrink_to_fit, "reduces memory usage by freeing unused memory");
-
-    cl.def("clear", &Vector::clear, "clears the contents");
-    cl.def("swap",   &Vector::swap, "swaps the contents");
-
-    cl.def("front", [](Vector &v) {
-        if (v.size()) return v.front();
-        else throw index_error();
-    }, "access the first element");
-
-    cl.def("back", [](Vector &v) {
-        if (v.size()) return v.back();
-        else throw index_error();
-    }, "access the last element ");
-
-#endif
-
-    return cl;
-}
-
-
-
-//
-// std::map, std::unordered_map
-//
-
-NAMESPACE_BEGIN(detail)
-
-/* Fallback functions */
-template <typename, typename, typename... Args> void map_if_insertion_operator(const Args &...) { }
-template <typename, typename, typename... Args> void map_assignment(const Args &...) { }
-
-// Map assignment when copy-assignable: just copy the value
-template <typename Map, typename Class_>
-void map_assignment(enable_if_t<std::is_copy_assignable<typename Map::mapped_type>::value, Class_> &cl) {
-    using KeyType = typename Map::key_type;
-    using MappedType = typename Map::mapped_type;
-
-    cl.def("__setitem__",
-           [](Map &m, const KeyType &k, const MappedType &v) {
-               auto it = m.find(k);
-               if (it != m.end()) it->second = v;
-               else m.emplace(k, v);
-           }
-    );
-}
-
-// Not copy-assignable, but still copy-constructible: we can update the value by erasing and reinserting
-template<typename Map, typename Class_>
-void map_assignment(enable_if_t<
-        !std::is_copy_assignable<typename Map::mapped_type>::value &&
-        is_copy_constructible<typename Map::mapped_type>::value,
-        Class_> &cl) {
-    using KeyType = typename Map::key_type;
-    using MappedType = typename Map::mapped_type;
-
-    cl.def("__setitem__",
-           [](Map &m, const KeyType &k, const MappedType &v) {
-               // We can't use m[k] = v; because value type might not be default constructable
-               auto r = m.emplace(k, v);
-               if (!r.second) {
-                   // value type is not copy assignable so the only way to insert it is to erase it first...
-                   m.erase(r.first);
-                   m.emplace(k, v);
-               }
-           }
-    );
-}
-
-
-template <typename Map, typename Class_> auto map_if_insertion_operator(Class_ &cl, std::string const &name)
--> decltype(std::declval<std::ostream&>() << std::declval<typename Map::key_type>() << std::declval<typename Map::mapped_type>(), void()) {
-
-    cl.def("__repr__",
-           [name](Map &m) {
-            std::ostringstream s;
-            s << name << '{';
-            bool f = false;
-            for (auto const &kv : m) {
-                if (f)
-                    s << ", ";
-                s << kv.first << ": " << kv.second;
-                f = true;
-            }
-            s << '}';
-            return s.str();
-        },
-        "Return the canonical string representation of this map."
-    );
-}
-
-
-NAMESPACE_END(detail)
-
-template <typename Map, typename holder_type = std::unique_ptr<Map>, typename... Args>
-class_<Map, holder_type> bind_map(handle scope, const std::string &name, Args&&... args) {
-    using KeyType = typename Map::key_type;
-    using MappedType = typename Map::mapped_type;
-    using Class_ = class_<Map, holder_type>;
-
-    // If either type is a non-module-local bound type then make the map binding non-local as well;
-    // otherwise (e.g. both types are either module-local or converting) the map will be
-    // module-local.
-    auto tinfo = detail::get_type_info(typeid(MappedType));
-    bool local = !tinfo || tinfo->module_local;
-    if (local) {
-        tinfo = detail::get_type_info(typeid(KeyType));
-        local = !tinfo || tinfo->module_local;
-    }
-
-    Class_ cl(scope, name.c_str(), pybind11::module_local(local), std::forward<Args>(args)...);
-
-    cl.def(init<>());
-
-    // Register stream insertion operator (if possible)
-    detail::map_if_insertion_operator<Map, Class_>(cl, name);
-
-    cl.def("__bool__",
-        [](const Map &m) -> bool { return !m.empty(); },
-        "Check whether the map is nonempty"
-    );
-
-    cl.def("__iter__",
-           [](Map &m) { return make_key_iterator(m.begin(), m.end()); },
-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
-    );
-
-    cl.def("items",
-           [](Map &m) { return make_iterator(m.begin(), m.end()); },
-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
-    );
-
-    cl.def("__getitem__",
-        [](Map &m, const KeyType &k) -> MappedType & {
-            auto it = m.find(k);
-            if (it == m.end())
-              throw key_error();
-           return it->second;
-        },
-        return_value_policy::reference_internal // ref + keepalive
-    );
-
-    // Assignment provided only if the type is copyable
-    detail::map_assignment<Map, Class_>(cl);
-
-    cl.def("__delitem__",
-           [](Map &m, const KeyType &k) {
-               auto it = m.find(k);
-               if (it == m.end())
-                   throw key_error();
-               return m.erase(it);
-           }
-    );
-
-    cl.def("__len__", &Map::size);
-
-    return cl;
-}
-
-NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/tmap/lib/pybind11/pybind11/__init__.py b/tmap/lib/pybind11/pybind11/__init__.py
deleted file mode 100644
index a765692..0000000
--- a/tmap/lib/pybind11/pybind11/__init__.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from ._version import version_info, __version__  # noqa: F401 imported but unused
-
-
-def get_include(*args, **kwargs):
-    import os
-    try:
-        from pip import locations
-        return os.path.dirname(
-            locations.distutils_scheme('pybind11', *args, **kwargs)['headers'])
-    except ImportError:
-        return 'include'
diff --git a/tmap/lib/pybind11/pybind11/__main__.py b/tmap/lib/pybind11/pybind11/__main__.py
deleted file mode 100644
index 9ef8378..0000000
--- a/tmap/lib/pybind11/pybind11/__main__.py
+++ /dev/null
@@ -1,37 +0,0 @@
-from __future__ import print_function
-
-import argparse
-import sys
-import sysconfig
-
-from . import get_include
-
-
-def print_includes():
-    dirs = [sysconfig.get_path('include'),
-            sysconfig.get_path('platinclude'),
-            get_include(),
-            get_include(True)]
-
-    # Make unique but preserve order
-    unique_dirs = []
-    for d in dirs:
-        if d not in unique_dirs:
-            unique_dirs.append(d)
-
-    print(' '.join('-I' + d for d in unique_dirs))
-
-
-def main():
-    parser = argparse.ArgumentParser(prog='python -m pybind11')
-    parser.add_argument('--includes', action='store_true',
-                        help='Include flags for both pybind11 and Python headers.')
-    args = parser.parse_args()
-    if not sys.argv[1:]:
-        parser.print_help()
-    if args.includes:
-        print_includes()
-
-
-if __name__ == '__main__':
-    main()
diff --git a/tmap/lib/pybind11/pybind11/_version.py b/tmap/lib/pybind11/pybind11/_version.py
deleted file mode 100644
index ea7d461..0000000
--- a/tmap/lib/pybind11/pybind11/_version.py
+++ /dev/null
@@ -1,2 +0,0 @@
-version_info = (2, 2, 0)
-__version__ = '.'.join(map(str, version_info))
diff --git a/tmap/lib/pybind11/setup.cfg b/tmap/lib/pybind11/setup.cfg
deleted file mode 100644
index 9e5e88d..0000000
--- a/tmap/lib/pybind11/setup.cfg
+++ /dev/null
@@ -1,10 +0,0 @@
-[bdist_wheel]
-universal=1
-
-[flake8]
-max-line-length = 99
-show_source = True
-exclude = .git, __pycache__, build, dist, docs, tools, venv
-ignore =
-    # required for pretty matrix formating: multiple spaces after `,` and `[`
-    E201, E241
diff --git a/tmap/lib/pybind11/setup.py b/tmap/lib/pybind11/setup.py
deleted file mode 100644
index e24f34b..0000000
--- a/tmap/lib/pybind11/setup.py
+++ /dev/null
@@ -1,107 +0,0 @@
-#!/usr/bin/env python
-
-# Setup script for PyPI; use CMakeFile.txt to build extension modules
-
-from setuptools import setup
-from distutils.command.install_headers import install_headers
-from pybind11 import __version__
-import os
-
-# Prevent installation of pybind11 headers by setting
-# PYBIND11_USE_CMAKE.
-if os.environ.get('PYBIND11_USE_CMAKE'):
-    headers = []
-else:
-    headers = [
-        'include/pybind11/detail/class.h',
-        'include/pybind11/detail/common.h',
-        'include/pybind11/detail/descr.h',
-        'include/pybind11/detail/init.h',
-        'include/pybind11/detail/internals.h',
-        'include/pybind11/detail/typeid.h',
-        'include/pybind11/attr.h',
-        'include/pybind11/buffer_info.h',
-        'include/pybind11/cast.h',
-        'include/pybind11/chrono.h',
-        'include/pybind11/complex.h',
-        'include/pybind11/eigen.h',
-        'include/pybind11/embed.h',
-        'include/pybind11/eval.h',
-        'include/pybind11/functional.h',
-        'include/pybind11/iostream.h',
-        'include/pybind11/numpy.h',
-        'include/pybind11/operators.h',
-        'include/pybind11/options.h',
-        'include/pybind11/pybind11.h',
-        'include/pybind11/pytypes.h',
-        'include/pybind11/stl.h',
-        'include/pybind11/stl_bind.h',
-    ]
-
-
-class InstallHeaders(install_headers):
-    """Use custom header installer because the default one flattens subdirectories"""
-    def run(self):
-        if not self.distribution.headers:
-            return
-
-        for header in self.distribution.headers:
-            subdir = os.path.dirname(os.path.relpath(header, 'include/pybind11'))
-            install_dir = os.path.join(self.install_dir, subdir)
-            self.mkpath(install_dir)
-
-            (out, _) = self.copy_file(header, install_dir)
-            self.outfiles.append(out)
-
-
-setup(
-    name='pybind11',
-    version=__version__,
-    description='Seamless operability between C++11 and Python',
-    author='Wenzel Jakob',
-    author_email='wenzel.jakob@epfl.ch',
-    url='https://github.com/wjakob/pybind11',
-    download_url='https://github.com/wjakob/pybind11/tarball/v' + __version__,
-    packages=['pybind11'],
-    license='BSD',
-    headers=headers,
-    cmdclass=dict(install_headers=InstallHeaders),
-    classifiers=[
-        'Development Status :: 5 - Production/Stable',
-        'Intended Audience :: Developers',
-        'Topic :: Software Development :: Libraries :: Python Modules',
-        'Topic :: Utilities',
-        'Programming Language :: C++',
-        'Programming Language :: Python :: 2.7',
-        'Programming Language :: Python :: 3',
-        'Programming Language :: Python :: 3.2',
-        'Programming Language :: Python :: 3.3',
-        'Programming Language :: Python :: 3.4',
-        'Programming Language :: Python :: 3.5',
-        'Programming Language :: Python :: 3.6',
-        'License :: OSI Approved :: BSD License'
-    ],
-    keywords='C++11, Python bindings',
-    long_description="""pybind11 is a lightweight header-only library that
-exposes C++ types in Python and vice versa, mainly to create Python bindings of
-existing C++ code. Its goals and syntax are similar to the excellent
-Boost.Python by David Abrahams: to minimize boilerplate code in traditional
-extension modules by inferring type information using compile-time
-introspection.
-
-The main issue with Boost.Python-and the reason for creating such a similar
-project-is Boost. Boost is an enormously large and complex suite of utility
-libraries that works with almost every C++ compiler in existence. This
-compatibility has its cost: arcane template tricks and workarounds are
-necessary to support the oldest and buggiest of compiler specimens. Now that
-C++11-compatible compilers are widely available, this heavy machinery has
-become an excessively large and unnecessary dependency.
-
-Think of this library as a tiny self-contained version of Boost.Python with
-everything stripped away that isn't relevant for binding generation. Without
-comments, the core header files only require ~4K lines of code and depend on
-Python (2.7 or 3.x, or PyPy2.7 >= 5.7) and the C++ standard library. This
-compact implementation was possible thanks to some of the new C++11 language
-features (specifically: tuples, lambda functions and variadic templates). Since
-its creation, this library has grown beyond Boost.Python in many ways, leading
-to dramatically simpler binding code in many common situations.""")
diff --git a/tmap/lib/pybind11/tests/CMakeLists.txt b/tmap/lib/pybind11/tests/CMakeLists.txt
deleted file mode 100644
index 5232629..0000000
--- a/tmap/lib/pybind11/tests/CMakeLists.txt
+++ /dev/null
@@ -1,234 +0,0 @@
-# CMakeLists.txt -- Build system for the pybind11 test suite
-#
-# Copyright (c) 2015 Wenzel Jakob <wenzel@inf.ethz.ch>
-#
-# All rights reserved. Use of this source code is governed by a
-# BSD-style license that can be found in the LICENSE file.
-
-cmake_minimum_required(VERSION 2.8.12)
-
-option(PYBIND11_WERROR  "Report all warnings as errors"  OFF)
-
-if (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
-    # We're being loaded directly, i.e. not via add_subdirectory, so make this
-    # work as its own project and load the pybind11Config to get the tools we need
-    project(pybind11_tests CXX)
-
-    find_package(pybind11 REQUIRED CONFIG)
-endif()
-
-if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
-  message(STATUS "Setting tests build type to MinSizeRel as none was specified")
-  set(CMAKE_BUILD_TYPE MinSizeRel CACHE STRING "Choose the type of build." FORCE)
-  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release"
-    "MinSizeRel" "RelWithDebInfo")
-endif()
-
-# Full set of test files (you can override these; see below)
-set(PYBIND11_TEST_FILES
-  test_buffers.cpp
-  test_builtin_casters.cpp
-  test_call_policies.cpp
-  test_callbacks.cpp
-  test_chrono.cpp
-  test_class.cpp
-  test_constants_and_functions.cpp
-  test_copy_move.cpp
-  test_docstring_options.cpp
-  test_eigen.cpp
-  test_enum.cpp
-  test_eval.cpp
-  test_exceptions.cpp
-  test_factory_constructors.cpp
-  test_iostream.cpp
-  test_kwargs_and_defaults.cpp
-  test_local_bindings.cpp
-  test_methods_and_attributes.cpp
-  test_modules.cpp
-  test_multiple_inheritance.cpp
-  test_numpy_array.cpp
-  test_numpy_dtypes.cpp
-  test_numpy_vectorize.cpp
-  test_opaque_types.cpp
-  test_operator_overloading.cpp
-  test_pickling.cpp
-  test_pytypes.cpp
-  test_sequences_and_iterators.cpp
-  test_smart_ptr.cpp
-  test_stl.cpp
-  test_stl_binders.cpp
-  test_virtual_functions.cpp
-)
-
-# Invoking cmake with something like:
-#     cmake -DPYBIND11_TEST_OVERRIDE="test_callbacks.cpp;test_picking.cpp" ..
-# lets you override the tests that get compiled and run.  You can restore to all tests with:
-#     cmake -DPYBIND11_TEST_OVERRIDE= ..
-if (PYBIND11_TEST_OVERRIDE)
-  set(PYBIND11_TEST_FILES ${PYBIND11_TEST_OVERRIDE})
-endif()
-
-string(REPLACE ".cpp" ".py" PYBIND11_PYTEST_FILES "${PYBIND11_TEST_FILES}")
-
-# Contains the set of test files that require pybind11_cross_module_tests to be
-# built; if none of these are built (i.e. because TEST_OVERRIDE is used and
-# doesn't include them) the second module doesn't get built.
-set(PYBIND11_CROSS_MODULE_TESTS
-  test_exceptions.py
-  test_local_bindings.py
-)
-
-# Check if Eigen is available; if not, remove from PYBIND11_TEST_FILES (but
-# keep it in PYBIND11_PYTEST_FILES, so that we get the "eigen is not installed"
-# skip message).
-list(FIND PYBIND11_TEST_FILES test_eigen.cpp PYBIND11_TEST_FILES_EIGEN_I)
-if(PYBIND11_TEST_FILES_EIGEN_I GREATER -1)
-  # Try loading via newer Eigen's Eigen3Config first (bypassing tools/FindEigen3.cmake).
-  # Eigen 3.3.1+ exports a cmake 3.0+ target for handling dependency requirements, but also
-  # produces a fatal error if loaded from a pre-3.0 cmake.
-  if (NOT CMAKE_VERSION VERSION_LESS 3.0)
-    find_package(Eigen3 QUIET CONFIG)
-    if (EIGEN3_FOUND)
-      if (EIGEN3_VERSION_STRING AND NOT EIGEN3_VERSION_STRING VERSION_LESS 3.3.1)
-        set(PYBIND11_EIGEN_VIA_TARGET 1)
-      endif()
-    endif()
-  endif()
-  if (NOT EIGEN3_FOUND)
-    # Couldn't load via target, so fall back to allowing module mode finding, which will pick up
-    # tools/FindEigen3.cmake
-    find_package(Eigen3 QUIET)
-  endif()
-
-  if(EIGEN3_FOUND)
-    # Eigen 3.3.1+ cmake sets EIGEN3_VERSION_STRING (and hard codes the version when installed
-    # rather than looking it up in the cmake script); older versions, and the
-    # tools/FindEigen3.cmake, set EIGEN3_VERSION instead.
-    if(NOT EIGEN3_VERSION AND EIGEN3_VERSION_STRING)
-      set(EIGEN3_VERSION ${EIGEN3_VERSION_STRING})
-    endif()
-    message(STATUS "Building tests with Eigen v${EIGEN3_VERSION}")
-  else()
-    list(REMOVE_AT PYBIND11_TEST_FILES ${PYBIND11_TEST_FILES_EIGEN_I})
-    message(STATUS "Building tests WITHOUT Eigen")
-  endif()
-endif()
-
-# Optional dependency for some tests (boost::variant is only supported with version >= 1.56)
-find_package(Boost 1.56)
-
-# Compile with compiler warnings turned on
-function(pybind11_enable_warnings target_name)
-  if(MSVC)
-    target_compile_options(${target_name} PRIVATE /W4)
-  else()
-      target_compile_options(${target_name} PRIVATE -Wall -Wextra -Wconversion -Wcast-qual)
-  endif()
-
-  if(PYBIND11_WERROR)
-    if(MSVC)
-      target_compile_options(${target_name} PRIVATE /WX)
-    else()
-      target_compile_options(${target_name} PRIVATE -Werror)
-    endif()
-  endif()
-endfunction()
-
-set(test_targets pybind11_tests)
-
-# Build pybind11_cross_module_tests if any test_whatever.py are being built that require it
-foreach(t ${PYBIND11_CROSS_MODULE_TESTS})
-  list(FIND PYBIND11_PYTEST_FILES ${t} i)
-  if (i GREATER -1)
-    list(APPEND test_targets pybind11_cross_module_tests)
-    break()
-  endif()
-endforeach()
-
-set(testdir ${CMAKE_CURRENT_SOURCE_DIR})
-foreach(target ${test_targets})
-  set(test_files ${PYBIND11_TEST_FILES})
-  if(NOT target STREQUAL "pybind11_tests")
-    set(test_files "")
-  endif()
-
-  # Create the binding library
-  pybind11_add_module(${target} THIN_LTO ${target}.cpp ${test_files} ${PYBIND11_HEADERS})
-  pybind11_enable_warnings(${target})
-
-  if(MSVC)
-    target_compile_options(${target} PRIVATE /utf-8)
-  endif()
-
-  if(EIGEN3_FOUND)
-    if (PYBIND11_EIGEN_VIA_TARGET)
-      target_link_libraries(${target} PRIVATE Eigen3::Eigen)
-    else()
-      target_include_directories(${target} PRIVATE ${EIGEN3_INCLUDE_DIR})
-    endif()
-    target_compile_definitions(${target} PRIVATE -DPYBIND11_TEST_EIGEN)
-  endif()
-
-  if(Boost_FOUND)
-    target_include_directories(${target} PRIVATE ${Boost_INCLUDE_DIRS})
-    target_compile_definitions(${target} PRIVATE -DPYBIND11_TEST_BOOST)
-  endif()
-
-  # Always write the output file directly into the 'tests' directory (even on MSVC)
-  if(NOT CMAKE_LIBRARY_OUTPUT_DIRECTORY)
-    set_target_properties(${target} PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${testdir})
-    foreach(config ${CMAKE_CONFIGURATION_TYPES})
-      string(TOUPPER ${config} config)
-      set_target_properties(${target} PROPERTIES LIBRARY_OUTPUT_DIRECTORY_${config} ${testdir})
-    endforeach()
-  endif()
-endforeach()
-
-# Make sure pytest is found or produce a fatal error
-if(NOT PYBIND11_PYTEST_FOUND)
-  execute_process(COMMAND ${PYTHON_EXECUTABLE} -c "import pytest; print(pytest.__version__)"
-                  RESULT_VARIABLE pytest_not_found OUTPUT_VARIABLE pytest_version ERROR_QUIET)
-  if(pytest_not_found)
-    message(FATAL_ERROR "Running the tests requires pytest. Please install it manually"
-                        " (try: ${PYTHON_EXECUTABLE} -m pip install pytest)")
-  elseif(pytest_version VERSION_LESS 3.0)
-    message(FATAL_ERROR "Running the tests requires pytest >= 3.0. Found: ${pytest_version}"
-                        "Please update it (try: ${PYTHON_EXECUTABLE} -m pip install -U pytest)")
-  endif()
-  set(PYBIND11_PYTEST_FOUND TRUE CACHE INTERNAL "")
-endif()
-
-if(CMAKE_VERSION VERSION_LESS 3.2)
-  set(PYBIND11_USES_TERMINAL "")
-else()
-  set(PYBIND11_USES_TERMINAL "USES_TERMINAL")
-endif()
-
-# A single command to compile and run the tests
-add_custom_target(pytest COMMAND ${PYTHON_EXECUTABLE} -m pytest ${PYBIND11_PYTEST_FILES}
-                  DEPENDS ${test_targets} WORKING_DIRECTORY ${testdir} ${PYBIND11_USES_TERMINAL})
-
-if(PYBIND11_TEST_OVERRIDE)
-  add_custom_command(TARGET pytest POST_BUILD
-    COMMAND ${CMAKE_COMMAND} -E echo "Note: not all tests run: -DPYBIND11_TEST_OVERRIDE is in effect")
-endif()
-
-# Add a check target to run all the tests, starting with pytest (we add dependencies to this below)
-add_custom_target(check DEPENDS pytest)
-
-# The remaining tests only apply when being built as part of the pybind11 project, but not if the
-# tests are being built independently.
-if (NOT PROJECT_NAME STREQUAL "pybind11")
-  return()
-endif()
-
-# Add a post-build comment to show the primary test suite .so size and, if a previous size, compare it:
-add_custom_command(TARGET pybind11_tests POST_BUILD
-  COMMAND ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/tools/libsize.py
-  $<TARGET_FILE:pybind11_tests> ${CMAKE_CURRENT_BINARY_DIR}/sosize-$<TARGET_FILE_NAME:pybind11_tests>.txt)
-
-# Test embedding the interpreter. Provides the `cpptest` target.
-add_subdirectory(test_embed)
-
-# Test CMake build using functions and targets from subdirectory or installed location
-add_subdirectory(test_cmake_build)
diff --git a/tmap/lib/pybind11/tests/conftest.py b/tmap/lib/pybind11/tests/conftest.py
deleted file mode 100644
index f4c2282..0000000
--- a/tmap/lib/pybind11/tests/conftest.py
+++ /dev/null
@@ -1,241 +0,0 @@
-"""pytest configuration
-
-Extends output capture as needed by pybind11: ignore constructors, optional unordered lines.
-Adds docstring and exceptions message sanitizers: ignore Python 2 vs 3 differences.
-"""
-
-import pytest
-import textwrap
-import difflib
-import re
-import sys
-import contextlib
-import platform
-import gc
-
-_unicode_marker = re.compile(r'u(\'[^\']*\')')
-_long_marker = re.compile(r'([0-9])L')
-_hexadecimal = re.compile(r'0x[0-9a-fA-F]+')
-
-
-def _strip_and_dedent(s):
-    """For triple-quote strings"""
-    return textwrap.dedent(s.lstrip('\n').rstrip())
-
-
-def _split_and_sort(s):
-    """For output which does not require specific line order"""
-    return sorted(_strip_and_dedent(s).splitlines())
-
-
-def _make_explanation(a, b):
-    """Explanation for a failed assert -- the a and b arguments are List[str]"""
-    return ["--- actual / +++ expected"] + [line.strip('\n') for line in difflib.ndiff(a, b)]
-
-
-class Output(object):
-    """Basic output post-processing and comparison"""
-    def __init__(self, string):
-        self.string = string
-        self.explanation = []
-
-    def __str__(self):
-        return self.string
-
-    def __eq__(self, other):
-        # Ignore constructor/destructor output which is prefixed with "###"
-        a = [line for line in self.string.strip().splitlines() if not line.startswith("###")]
-        b = _strip_and_dedent(other).splitlines()
-        if a == b:
-            return True
-        else:
-            self.explanation = _make_explanation(a, b)
-            return False
-
-
-class Unordered(Output):
-    """Custom comparison for output without strict line ordering"""
-    def __eq__(self, other):
-        a = _split_and_sort(self.string)
-        b = _split_and_sort(other)
-        if a == b:
-            return True
-        else:
-            self.explanation = _make_explanation(a, b)
-            return False
-
-
-class Capture(object):
-    def __init__(self, capfd):
-        self.capfd = capfd
-        self.out = ""
-        self.err = ""
-
-    def __enter__(self):
-        self.capfd.readouterr()
-        return self
-
-    def __exit__(self, *_):
-        self.out, self.err = self.capfd.readouterr()
-
-    def __eq__(self, other):
-        a = Output(self.out)
-        b = other
-        if a == b:
-            return True
-        else:
-            self.explanation = a.explanation
-            return False
-
-    def __str__(self):
-        return self.out
-
-    def __contains__(self, item):
-        return item in self.out
-
-    @property
-    def unordered(self):
-        return Unordered(self.out)
-
-    @property
-    def stderr(self):
-        return Output(self.err)
-
-
-@pytest.fixture
-def capture(capsys):
-    """Extended `capsys` with context manager and custom equality operators"""
-    return Capture(capsys)
-
-
-class SanitizedString(object):
-    def __init__(self, sanitizer):
-        self.sanitizer = sanitizer
-        self.string = ""
-        self.explanation = []
-
-    def __call__(self, thing):
-        self.string = self.sanitizer(thing)
-        return self
-
-    def __eq__(self, other):
-        a = self.string
-        b = _strip_and_dedent(other)
-        if a == b:
-            return True
-        else:
-            self.explanation = _make_explanation(a.splitlines(), b.splitlines())
-            return False
-
-
-def _sanitize_general(s):
-    s = s.strip()
-    s = s.replace("pybind11_tests.", "m.")
-    s = s.replace("unicode", "str")
-    s = _long_marker.sub(r"\1", s)
-    s = _unicode_marker.sub(r"\1", s)
-    return s
-
-
-def _sanitize_docstring(thing):
-    s = thing.__doc__
-    s = _sanitize_general(s)
-    return s
-
-
-@pytest.fixture
-def doc():
-    """Sanitize docstrings and add custom failure explanation"""
-    return SanitizedString(_sanitize_docstring)
-
-
-def _sanitize_message(thing):
-    s = str(thing)
-    s = _sanitize_general(s)
-    s = _hexadecimal.sub("0", s)
-    return s
-
-
-@pytest.fixture
-def msg():
-    """Sanitize messages and add custom failure explanation"""
-    return SanitizedString(_sanitize_message)
-
-
-# noinspection PyUnusedLocal
-def pytest_assertrepr_compare(op, left, right):
-    """Hook to insert custom failure explanation"""
-    if hasattr(left, 'explanation'):
-        return left.explanation
-
-
-@contextlib.contextmanager
-def suppress(exception):
-    """Suppress the desired exception"""
-    try:
-        yield
-    except exception:
-        pass
-
-
-def gc_collect():
-    ''' Run the garbage collector twice (needed when running
-    reference counting tests with PyPy) '''
-    gc.collect()
-    gc.collect()
-
-
-def pytest_namespace():
-    """Add import suppression and test requirements to `pytest` namespace"""
-    try:
-        import numpy as np
-    except ImportError:
-        np = None
-    try:
-        import scipy
-    except ImportError:
-        scipy = None
-    try:
-        from pybind11_tests.eigen import have_eigen
-    except ImportError:
-        have_eigen = False
-    pypy = platform.python_implementation() == "PyPy"
-
-    skipif = pytest.mark.skipif
-    return {
-        'suppress': suppress,
-        'requires_numpy': skipif(not np, reason="numpy is not installed"),
-        'requires_scipy': skipif(not np, reason="scipy is not installed"),
-        'requires_eigen_and_numpy': skipif(not have_eigen or not np,
-                                           reason="eigen and/or numpy are not installed"),
-        'requires_eigen_and_scipy': skipif(not have_eigen or not scipy,
-                                           reason="eigen and/or scipy are not installed"),
-        'unsupported_on_pypy': skipif(pypy, reason="unsupported on PyPy"),
-        'unsupported_on_py2': skipif(sys.version_info.major < 3,
-                                     reason="unsupported on Python 2.x"),
-        'gc_collect': gc_collect
-    }
-
-
-def _test_import_pybind11():
-    """Early diagnostic for test module initialization errors
-
-    When there is an error during initialization, the first import will report the
-    real error while all subsequent imports will report nonsense. This import test
-    is done early (in the pytest configuration file, before any tests) in order to
-    avoid the noise of having all tests fail with identical error messages.
-
-    Any possible exception is caught here and reported manually *without* the stack
-    trace. This further reduces noise since the trace would only show pytest internals
-    which are not useful for debugging pybind11 module issues.
-    """
-    # noinspection PyBroadException
-    try:
-        import pybind11_tests  # noqa: F401 imported but unused
-    except Exception as e:
-        print("Failed to import pybind11_tests from pytest:")
-        print("  {}: {}".format(type(e).__name__, e))
-        sys.exit(1)
-
-
-_test_import_pybind11()
diff --git a/tmap/lib/pybind11/tests/constructor_stats.h b/tmap/lib/pybind11/tests/constructor_stats.h
deleted file mode 100644
index babded0..0000000
--- a/tmap/lib/pybind11/tests/constructor_stats.h
+++ /dev/null
@@ -1,276 +0,0 @@
-#pragma once
-/*
-    tests/constructor_stats.h -- framework for printing and tracking object
-    instance lifetimes in example/test code.
-
-    Copyright (c) 2016 Jason Rhinelander <jason@imaginary.ca>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-
-This header provides a few useful tools for writing examples or tests that want to check and/or
-display object instance lifetimes.  It requires that you include this header and add the following
-function calls to constructors:
-
-    class MyClass {
-        MyClass() { ...; print_default_created(this); }
-        ~MyClass() { ...; print_destroyed(this); }
-        MyClass(const MyClass &c) { ...; print_copy_created(this); }
-        MyClass(MyClass &&c) { ...; print_move_created(this); }
-        MyClass(int a, int b) { ...; print_created(this, a, b); }
-        MyClass &operator=(const MyClass &c) { ...; print_copy_assigned(this); }
-        MyClass &operator=(MyClass &&c) { ...; print_move_assigned(this); }
-
-        ...
-    }
-
-You can find various examples of these in several of the existing testing .cpp files.  (Of course
-you don't need to add any of the above constructors/operators that you don't actually have, except
-for the destructor).
-
-Each of these will print an appropriate message such as:
-
-    ### MyClass @ 0x2801910 created via default constructor
-    ### MyClass @ 0x27fa780 created 100 200
-    ### MyClass @ 0x2801910 destroyed
-    ### MyClass @ 0x27fa780 destroyed
-
-You can also include extra arguments (such as the 100, 200 in the output above, coming from the
-value constructor) for all of the above methods which will be included in the output.
-
-For testing, each of these also keeps track the created instances and allows you to check how many
-of the various constructors have been invoked from the Python side via code such as:
-
-    from pybind11_tests import ConstructorStats
-    cstats = ConstructorStats.get(MyClass)
-    print(cstats.alive())
-    print(cstats.default_constructions)
-
-Note that `.alive()` should usually be the first thing you call as it invokes Python's garbage
-collector to actually destroy objects that aren't yet referenced.
-
-For everything except copy and move constructors and destructors, any extra values given to the
-print_...() function is stored in a class-specific values list which you can retrieve and inspect
-from the ConstructorStats instance `.values()` method.
-
-In some cases, when you need to track instances of a C++ class not registered with pybind11, you
-need to add a function returning the ConstructorStats for the C++ class; this can be done with:
-
-    m.def("get_special_cstats", &ConstructorStats::get<SpecialClass>, py::return_value_policy::reference)
-
-Finally, you can suppress the output messages, but keep the constructor tracking (for
-inspection/testing in python) by using the functions with `print_` replaced with `track_` (e.g.
-`track_copy_created(this)`).
-
-*/
-
-#include "pybind11_tests.h"
-#include <unordered_map>
-#include <list>
-#include <typeindex>
-#include <sstream>
-
-class ConstructorStats {
-protected:
-    std::unordered_map<void*, int> _instances; // Need a map rather than set because members can shared address with parents
-    std::list<std::string> _values; // Used to track values (e.g. of value constructors)
-public:
-    int default_constructions = 0;
-    int copy_constructions = 0;
-    int move_constructions = 0;
-    int copy_assignments = 0;
-    int move_assignments = 0;
-
-    void copy_created(void *inst) {
-        created(inst);
-        copy_constructions++;
-    }
-
-    void move_created(void *inst) {
-        created(inst);
-        move_constructions++;
-    }
-
-    void default_created(void *inst) {
-        created(inst);
-        default_constructions++;
-    }
-
-    void created(void *inst) {
-        ++_instances[inst];
-    }
-
-    void destroyed(void *inst) {
-        if (--_instances[inst] < 0)
-            throw std::runtime_error("cstats.destroyed() called with unknown "
-                                     "instance; potential double-destruction "
-                                     "or a missing cstats.created()");
-    }
-
-    static void gc() {
-        // Force garbage collection to ensure any pending destructors are invoked:
-#if defined(PYPY_VERSION)
-        PyObject *globals = PyEval_GetGlobals();
-        PyObject *result = PyRun_String(
-            "import gc\n"
-            "for i in range(2):"
-            "    gc.collect()\n",
-            Py_file_input, globals, globals);
-        if (result == nullptr)
-            throw py::error_already_set();
-        Py_DECREF(result);
-#else
-        py::module::import("gc").attr("collect")();
-#endif
-    }
-
-    int alive() {
-        gc();
-        int total = 0;
-        for (const auto &p : _instances)
-            if (p.second > 0)
-                total += p.second;
-        return total;
-    }
-
-    void value() {} // Recursion terminator
-    // Takes one or more values, converts them to strings, then stores them.
-    template <typename T, typename... Tmore> void value(const T &v, Tmore &&...args) {
-        std::ostringstream oss;
-        oss << v;
-        _values.push_back(oss.str());
-        value(std::forward<Tmore>(args)...);
-    }
-
-    // Move out stored values
-    py::list values() {
-        py::list l;
-        for (const auto &v : _values) l.append(py::cast(v));
-        _values.clear();
-        return l;
-    }
-
-    // Gets constructor stats from a C++ type index
-    static ConstructorStats& get(std::type_index type) {
-        static std::unordered_map<std::type_index, ConstructorStats> all_cstats;
-        return all_cstats[type];
-    }
-
-    // Gets constructor stats from a C++ type
-    template <typename T> static ConstructorStats& get() {
-#if defined(PYPY_VERSION)
-        gc();
-#endif
-        return get(typeid(T));
-    }
-
-    // Gets constructor stats from a Python class
-    static ConstructorStats& get(py::object class_) {
-        auto &internals = py::detail::get_internals();
-        const std::type_index *t1 = nullptr, *t2 = nullptr;
-        try {
-            auto *type_info = internals.registered_types_py.at((PyTypeObject *) class_.ptr()).at(0);
-            for (auto &p : internals.registered_types_cpp) {
-                if (p.second == type_info) {
-                    if (t1) {
-                        t2 = &p.first;
-                        break;
-                    }
-                    t1 = &p.first;
-                }
-            }
-        }
-        catch (std::out_of_range) {}
-        if (!t1) throw std::runtime_error("Unknown class passed to ConstructorStats::get()");
-        auto &cs1 = get(*t1);
-        // If we have both a t1 and t2 match, one is probably the trampoline class; return whichever
-        // has more constructions (typically one or the other will be 0)
-        if (t2) {
-            auto &cs2 = get(*t2);
-            int cs1_total = cs1.default_constructions + cs1.copy_constructions + cs1.move_constructions + (int) cs1._values.size();
-            int cs2_total = cs2.default_constructions + cs2.copy_constructions + cs2.move_constructions + (int) cs2._values.size();
-            if (cs2_total > cs1_total) return cs2;
-        }
-        return cs1;
-    }
-};
-
-// To track construction/destruction, you need to call these methods from the various
-// constructors/operators.  The ones that take extra values record the given values in the
-// constructor stats values for later inspection.
-template <class T> void track_copy_created(T *inst) { ConstructorStats::get<T>().copy_created(inst); }
-template <class T> void track_move_created(T *inst) { ConstructorStats::get<T>().move_created(inst); }
-template <class T, typename... Values> void track_copy_assigned(T *, Values &&...values) {
-    auto &cst = ConstructorStats::get<T>();
-    cst.copy_assignments++;
-    cst.value(std::forward<Values>(values)...);
-}
-template <class T, typename... Values> void track_move_assigned(T *, Values &&...values) {
-    auto &cst = ConstructorStats::get<T>();
-    cst.move_assignments++;
-    cst.value(std::forward<Values>(values)...);
-}
-template <class T, typename... Values> void track_default_created(T *inst, Values &&...values) {
-    auto &cst = ConstructorStats::get<T>();
-    cst.default_created(inst);
-    cst.value(std::forward<Values>(values)...);
-}
-template <class T, typename... Values> void track_created(T *inst, Values &&...values) {
-    auto &cst = ConstructorStats::get<T>();
-    cst.created(inst);
-    cst.value(std::forward<Values>(values)...);
-}
-template <class T, typename... Values> void track_destroyed(T *inst) {
-    ConstructorStats::get<T>().destroyed(inst);
-}
-template <class T, typename... Values> void track_values(T *, Values &&...values) {
-    ConstructorStats::get<T>().value(std::forward<Values>(values)...);
-}
-
-/// Don't cast pointers to Python, print them as strings
-inline const char *format_ptrs(const char *p) { return p; }
-template <typename T>
-py::str format_ptrs(T *p) { return "{:#x}"_s.format(reinterpret_cast<std::uintptr_t>(p)); }
-template <typename T>
-auto format_ptrs(T &&x) -> decltype(std::forward<T>(x)) { return std::forward<T>(x); }
-
-template <class T, typename... Output>
-void print_constr_details(T *inst, const std::string &action, Output &&...output) {
-    py::print("###", py::type_id<T>(), "@", format_ptrs(inst), action,
-              format_ptrs(std::forward<Output>(output))...);
-}
-
-// Verbose versions of the above:
-template <class T, typename... Values> void print_copy_created(T *inst, Values &&...values) { // NB: this prints, but doesn't store, given values
-    print_constr_details(inst, "created via copy constructor", values...);
-    track_copy_created(inst);
-}
-template <class T, typename... Values> void print_move_created(T *inst, Values &&...values) { // NB: this prints, but doesn't store, given values
-    print_constr_details(inst, "created via move constructor", values...);
-    track_move_created(inst);
-}
-template <class T, typename... Values> void print_copy_assigned(T *inst, Values &&...values) {
-    print_constr_details(inst, "assigned via copy assignment", values...);
-    track_copy_assigned(inst, values...);
-}
-template <class T, typename... Values> void print_move_assigned(T *inst, Values &&...values) {
-    print_constr_details(inst, "assigned via move assignment", values...);
-    track_move_assigned(inst, values...);
-}
-template <class T, typename... Values> void print_default_created(T *inst, Values &&...values) {
-    print_constr_details(inst, "created via default constructor", values...);
-    track_default_created(inst, values...);
-}
-template <class T, typename... Values> void print_created(T *inst, Values &&...values) {
-    print_constr_details(inst, "created", values...);
-    track_created(inst, values...);
-}
-template <class T, typename... Values> void print_destroyed(T *inst, Values &&...values) { // Prints but doesn't store given values
-    print_constr_details(inst, "destroyed", values...);
-    track_destroyed(inst);
-}
-template <class T, typename... Values> void print_values(T *inst, Values &&...values) {
-    print_constr_details(inst, ":", values...);
-    track_values(inst, values...);
-}
-
diff --git a/tmap/lib/pybind11/tests/local_bindings.h b/tmap/lib/pybind11/tests/local_bindings.h
deleted file mode 100644
index 8f48ed9..0000000
--- a/tmap/lib/pybind11/tests/local_bindings.h
+++ /dev/null
@@ -1,60 +0,0 @@
-#pragma once
-#include "pybind11_tests.h"
-
-/// Simple class used to test py::local:
-template <int> class LocalBase {
-public:
-    LocalBase(int i) : i(i) { }
-    int i = -1;
-};
-
-/// Registered with py::local in both main and secondary modules:
-using LocalType = LocalBase<0>;
-/// Registered without py::local in both modules:
-using NonLocalType = LocalBase<1>;
-/// A second non-local type (for stl_bind tests):
-using NonLocal2 = LocalBase<2>;
-/// Tests within-module, different-compilation-unit local definition conflict:
-using LocalExternal = LocalBase<3>;
-/// Mixed: registered local first, then global
-using MixedLocalGlobal = LocalBase<4>;
-/// Mixed: global first, then local
-using MixedGlobalLocal = LocalBase<5>;
-
-using LocalVec = std::vector<LocalType>;
-using LocalVec2 = std::vector<NonLocal2>;
-using LocalMap = std::unordered_map<std::string, LocalType>;
-using NonLocalVec = std::vector<NonLocalType>;
-using NonLocalVec2 = std::vector<NonLocal2>;
-using NonLocalMap = std::unordered_map<std::string, NonLocalType>;
-using NonLocalMap2 = std::unordered_map<std::string, uint8_t>;
-
-PYBIND11_MAKE_OPAQUE(LocalVec);
-PYBIND11_MAKE_OPAQUE(LocalVec2);
-PYBIND11_MAKE_OPAQUE(LocalMap);
-PYBIND11_MAKE_OPAQUE(NonLocalVec);
-//PYBIND11_MAKE_OPAQUE(NonLocalVec2); // same type as LocalVec2
-PYBIND11_MAKE_OPAQUE(NonLocalMap);
-PYBIND11_MAKE_OPAQUE(NonLocalMap2);
-
-
-// Simple bindings (used with the above):
-template <typename T, int Adjust, typename... Args>
-py::class_<T> bind_local(Args && ...args) {
-    return py::class_<T>(std::forward<Args>(args)...)
-        .def(py::init<int>())
-        .def("get", [](T &i) { return i.i + Adjust; });
-};
-
-// Simulate a foreign library base class (to match the example in the docs):
-namespace pets {
-class Pet {
-public:
-    Pet(std::string name) : name_(name) {}
-    std::string name_;
-    const std::string &name() { return name_; }
-};
-}
-
-struct MixGL { int i; MixGL(int i) : i{i} {} };
-struct MixGL2 { int i; MixGL2(int i) : i{i} {} };
diff --git a/tmap/lib/pybind11/tests/object.h b/tmap/lib/pybind11/tests/object.h
deleted file mode 100644
index 9235f19..0000000
--- a/tmap/lib/pybind11/tests/object.h
+++ /dev/null
@@ -1,175 +0,0 @@
-#if !defined(__OBJECT_H)
-#define __OBJECT_H
-
-#include <atomic>
-#include "constructor_stats.h"
-
-/// Reference counted object base class
-class Object {
-public:
-    /// Default constructor
-    Object() { print_default_created(this); }
-
-    /// Copy constructor
-    Object(const Object &) : m_refCount(0) { print_copy_created(this); }
-
-    /// Return the current reference count
-    int getRefCount() const { return m_refCount; };
-
-    /// Increase the object's reference count by one
-    void incRef() const { ++m_refCount; }
-
-    /** \brief Decrease the reference count of
-     * the object and possibly deallocate it.
-     *
-     * The object will automatically be deallocated once
-     * the reference count reaches zero.
-     */
-    void decRef(bool dealloc = true) const {
-        --m_refCount;
-        if (m_refCount == 0 && dealloc)
-            delete this;
-        else if (m_refCount < 0)
-            throw std::runtime_error("Internal error: reference count < 0!");
-    }
-
-    virtual std::string toString() const = 0;
-protected:
-    /** \brief Virtual protected deconstructor.
-     * (Will only be called by \ref ref)
-     */
-    virtual ~Object() { print_destroyed(this); }
-private:
-    mutable std::atomic<int> m_refCount { 0 };
-};
-
-// Tag class used to track constructions of ref objects.  When we track constructors, below, we
-// track and print out the actual class (e.g. ref<MyObject>), and *also* add a fake tracker for
-// ref_tag.  This lets us check that the total number of ref<Anything> constructors/destructors is
-// correct without having to check each individual ref<Whatever> type individually.
-class ref_tag {};
-
-/**
- * \brief Reference counting helper
- *
- * The \a ref refeference template is a simple wrapper to store a
- * pointer to an object. It takes care of increasing and decreasing
- * the reference count of the object. When the last reference goes
- * out of scope, the associated object will be deallocated.
- *
- * \ingroup libcore
- */
-template <typename T> class ref {
-public:
-    /// Create a nullptr reference
-    ref() : m_ptr(nullptr) { print_default_created(this); track_default_created((ref_tag*) this); }
-
-    /// Construct a reference from a pointer
-    ref(T *ptr) : m_ptr(ptr) {
-        if (m_ptr) ((Object *) m_ptr)->incRef();
-
-        print_created(this, "from pointer", m_ptr); track_created((ref_tag*) this, "from pointer");
-
-    }
-
-    /// Copy constructor
-    ref(const ref &r) : m_ptr(r.m_ptr) {
-        if (m_ptr)
-            ((Object *) m_ptr)->incRef();
-
-        print_copy_created(this, "with pointer", m_ptr); track_copy_created((ref_tag*) this);
-    }
-
-    /// Move constructor
-    ref(ref &&r) : m_ptr(r.m_ptr) {
-        r.m_ptr = nullptr;
-
-        print_move_created(this, "with pointer", m_ptr); track_move_created((ref_tag*) this);
-    }
-
-    /// Destroy this reference
-    ~ref() {
-        if (m_ptr)
-            ((Object *) m_ptr)->decRef();
-
-        print_destroyed(this); track_destroyed((ref_tag*) this);
-    }
-
-    /// Move another reference into the current one
-    ref& operator=(ref&& r) {
-        print_move_assigned(this, "pointer", r.m_ptr); track_move_assigned((ref_tag*) this);
-
-        if (*this == r)
-            return *this;
-        if (m_ptr)
-            ((Object *) m_ptr)->decRef();
-        m_ptr = r.m_ptr;
-        r.m_ptr = nullptr;
-        return *this;
-    }
-
-    /// Overwrite this reference with another reference
-    ref& operator=(const ref& r) {
-        print_copy_assigned(this, "pointer", r.m_ptr); track_copy_assigned((ref_tag*) this);
-
-        if (m_ptr == r.m_ptr)
-            return *this;
-        if (m_ptr)
-            ((Object *) m_ptr)->decRef();
-        m_ptr = r.m_ptr;
-        if (m_ptr)
-            ((Object *) m_ptr)->incRef();
-        return *this;
-    }
-
-    /// Overwrite this reference with a pointer to another object
-    ref& operator=(T *ptr) {
-        print_values(this, "assigned pointer"); track_values((ref_tag*) this, "assigned pointer");
-
-        if (m_ptr == ptr)
-            return *this;
-        if (m_ptr)
-            ((Object *) m_ptr)->decRef();
-        m_ptr = ptr;
-        if (m_ptr)
-            ((Object *) m_ptr)->incRef();
-        return *this;
-    }
-
-    /// Compare this reference with another reference
-    bool operator==(const ref &r) const { return m_ptr == r.m_ptr; }
-
-    /// Compare this reference with another reference
-    bool operator!=(const ref &r) const { return m_ptr != r.m_ptr; }
-
-    /// Compare this reference with a pointer
-    bool operator==(const T* ptr) const { return m_ptr == ptr; }
-
-    /// Compare this reference with a pointer
-    bool operator!=(const T* ptr) const { return m_ptr != ptr; }
-
-    /// Access the object referenced by this reference
-    T* operator->() { return m_ptr; }
-
-    /// Access the object referenced by this reference
-    const T* operator->() const { return m_ptr; }
-
-    /// Return a C++ reference to the referenced object
-    T& operator*() { return *m_ptr; }
-
-    /// Return a const C++ reference to the referenced object
-    const T& operator*() const { return *m_ptr; }
-
-    /// Return a pointer to the referenced object
-    operator T* () { return m_ptr; }
-
-    /// Return a const pointer to the referenced object
-    T* get_ptr() { return m_ptr; }
-
-    /// Return a pointer to the referenced object
-    const T* get_ptr() const { return m_ptr; }
-private:
-    T *m_ptr;
-};
-
-#endif /* __OBJECT_H */
diff --git a/tmap/lib/pybind11/tests/pybind11_cross_module_tests.cpp b/tmap/lib/pybind11/tests/pybind11_cross_module_tests.cpp
deleted file mode 100644
index 2091624..0000000
--- a/tmap/lib/pybind11/tests/pybind11_cross_module_tests.cpp
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
-    tests/pybind11_cross_module_tests.cpp -- contains tests that require multiple modules
-
-    Copyright (c) 2017 Jason Rhinelander <jason@imaginary.ca>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "local_bindings.h"
-#include <pybind11/stl_bind.h>
-#include <numeric>
-
-PYBIND11_MODULE(pybind11_cross_module_tests, m) {
-    m.doc() = "pybind11 cross-module test module";
-
-    // test_local_bindings.py tests:
-    //
-    // Definitions here are tested by importing both this module and the
-    // relevant pybind11_tests submodule from a test_whatever.py
-
-    // test_exceptions.py
-    m.def("raise_runtime_error", []() { PyErr_SetString(PyExc_RuntimeError, "My runtime error"); throw py::error_already_set(); });
-    m.def("raise_value_error", []() { PyErr_SetString(PyExc_ValueError, "My value error"); throw py::error_already_set(); });
-    m.def("throw_pybind_value_error", []() { throw py::value_error("pybind11 value error"); });
-    m.def("throw_pybind_type_error", []() { throw py::type_error("pybind11 type error"); });
-    m.def("throw_stop_iteration", []() { throw py::stop_iteration(); });
-
-    // test_local_bindings.py
-    // Local to both:
-    bind_local<LocalType, 1>(m, "LocalType", py::module_local())
-        .def("get2", [](LocalType &t) { return t.i + 2; })
-        ;
-
-    // Can only be called with our python type:
-    m.def("local_value", [](LocalType &l) { return l.i; });
-
-    // test_nonlocal_failure
-    // This registration will fail (global registration when LocalFail is already registered
-    // globally in the main test module):
-    m.def("register_nonlocal", [m]() {
-        bind_local<NonLocalType, 0>(m, "NonLocalType");
-    });
-
-    // test_stl_bind_local
-    // stl_bind.h binders defaults to py::module_local if the types are local or converting:
-    py::bind_vector<LocalVec>(m, "LocalVec");
-    py::bind_map<LocalMap>(m, "LocalMap");
-
-    // test_stl_bind_global
-    // and global if the type (or one of the types, for the map) is global (so these will fail,
-    // assuming pybind11_tests is already loaded):
-    m.def("register_nonlocal_vec", [m]() {
-        py::bind_vector<NonLocalVec>(m, "NonLocalVec");
-    });
-    m.def("register_nonlocal_map", [m]() {
-        py::bind_map<NonLocalMap>(m, "NonLocalMap");
-    });
-    // The default can, however, be overridden to global using `py::module_local()` or
-    // `py::module_local(false)`.
-    // Explicitly made local:
-    py::bind_vector<NonLocalVec2>(m, "NonLocalVec2", py::module_local());
-    // Explicitly made global (and so will fail to bind):
-    m.def("register_nonlocal_map2", [m]() {
-        py::bind_map<NonLocalMap2>(m, "NonLocalMap2", py::module_local(false));
-    });
-
-    // test_mixed_local_global
-    // We try this both with the global type registered first and vice versa (the order shouldn't
-    // matter).
-    m.def("register_mixed_global_local", [m]() {
-        bind_local<MixedGlobalLocal, 200>(m, "MixedGlobalLocal", py::module_local());
-    });
-    m.def("register_mixed_local_global", [m]() {
-        bind_local<MixedLocalGlobal, 2000>(m, "MixedLocalGlobal", py::module_local(false));
-    });
-    m.def("get_mixed_gl", [](int i) { return MixedGlobalLocal(i); });
-    m.def("get_mixed_lg", [](int i) { return MixedLocalGlobal(i); });
-
-    // test_internal_locals_differ
-    m.def("local_cpp_types_addr", []() { return (uintptr_t) &py::detail::registered_local_types_cpp(); });
-
-    // test_stl_caster_vs_stl_bind
-    py::bind_vector<std::vector<int>>(m, "VectorInt");
-
-    m.def("load_vector_via_binding", [](std::vector<int> &v) {
-        return std::accumulate(v.begin(), v.end(), 0);
-    });
-
-    // test_cross_module_calls
-    m.def("return_self", [](LocalVec *v) { return v; });
-    m.def("return_copy", [](const LocalVec &v) { return LocalVec(v); });
-
-    class Dog : public pets::Pet { public: Dog(std::string name) : Pet(name) {}; };
-    py::class_<pets::Pet>(m, "Pet", py::module_local())
-        .def("name", &pets::Pet::name);
-    // Binding for local extending class:
-    py::class_<Dog, pets::Pet>(m, "Dog")
-        .def(py::init<std::string>());
-    m.def("pet_name", [](pets::Pet &p) { return p.name(); });
-
-    py::class_<MixGL>(m, "MixGL", py::module_local()).def(py::init<int>());
-    m.def("get_gl_value", [](MixGL &o) { return o.i + 100; });
-
-    py::class_<MixGL2>(m, "MixGL2", py::module_local()).def(py::init<int>());
-}
diff --git a/tmap/lib/pybind11/tests/pybind11_tests.cpp b/tmap/lib/pybind11/tests/pybind11_tests.cpp
deleted file mode 100644
index bc7d2c3..0000000
--- a/tmap/lib/pybind11/tests/pybind11_tests.cpp
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
-    tests/pybind11_tests.cpp -- pybind example plugin
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "constructor_stats.h"
-
-#include <functional>
-#include <list>
-
-/*
-For testing purposes, we define a static global variable here in a function that each individual
-test .cpp calls with its initialization lambda.  It's convenient here because we can just not
-compile some test files to disable/ignore some of the test code.
-
-It is NOT recommended as a way to use pybind11 in practice, however: the initialization order will
-be essentially random, which is okay for our test scripts (there are no dependencies between the
-individual pybind11 test .cpp files), but most likely not what you want when using pybind11
-productively.
-
-Instead, see the "How can I reduce the build time?" question in the "Frequently asked questions"
-section of the documentation for good practice on splitting binding code over multiple files.
-*/
-std::list<std::function<void(py::module &)>> &initializers() {
-    static std::list<std::function<void(py::module &)>> inits;
-    return inits;
-}
-
-test_initializer::test_initializer(Initializer init) {
-    initializers().push_back(init);
-}
-
-test_initializer::test_initializer(const char *submodule_name, Initializer init) {
-    initializers().push_back([=](py::module &parent) {
-        auto m = parent.def_submodule(submodule_name);
-        init(m);
-    });
-}
-
-void bind_ConstructorStats(py::module &m) {
-    py::class_<ConstructorStats>(m, "ConstructorStats")
-        .def("alive", &ConstructorStats::alive)
-        .def("values", &ConstructorStats::values)
-        .def_readwrite("default_constructions", &ConstructorStats::default_constructions)
-        .def_readwrite("copy_assignments", &ConstructorStats::copy_assignments)
-        .def_readwrite("move_assignments", &ConstructorStats::move_assignments)
-        .def_readwrite("copy_constructions", &ConstructorStats::copy_constructions)
-        .def_readwrite("move_constructions", &ConstructorStats::move_constructions)
-        .def_static("get", (ConstructorStats &(*)(py::object)) &ConstructorStats::get, py::return_value_policy::reference_internal)
-
-        // Not exactly ConstructorStats, but related: expose the internal pybind number of registered instances
-        // to allow instance cleanup checks (invokes a GC first)
-        .def_static("detail_reg_inst", []() {
-            ConstructorStats::gc();
-            return py::detail::get_internals().registered_instances.size();
-        })
-        ;
-}
-
-PYBIND11_MODULE(pybind11_tests, m) {
-    m.doc() = "pybind11 test module";
-
-    bind_ConstructorStats(m);
-
-#if !defined(NDEBUG)
-    m.attr("debug_enabled") = true;
-#else
-    m.attr("debug_enabled") = false;
-#endif
-
-    py::class_<UserType>(m, "UserType", "A `py::class_` type for testing")
-        .def(py::init<>())
-        .def(py::init<int>())
-        .def("get_value", &UserType::value, "Get value using a method")
-        .def("set_value", &UserType::set, "Set value using a method")
-        .def_property("value", &UserType::value, &UserType::set, "Get/set value using a property")
-        .def("__repr__", [](const UserType& u) { return "UserType({})"_s.format(u.value()); });
-
-    py::class_<IncType, UserType>(m, "IncType")
-        .def(py::init<>())
-        .def(py::init<int>())
-        .def("__repr__", [](const IncType& u) { return "IncType({})"_s.format(u.value()); });
-
-    for (const auto &initializer : initializers())
-        initializer(m);
-
-    if (!py::hasattr(m, "have_eigen")) m.attr("have_eigen") = false;
-}
diff --git a/tmap/lib/pybind11/tests/pybind11_tests.h b/tmap/lib/pybind11/tests/pybind11_tests.h
deleted file mode 100644
index 90963a5..0000000
--- a/tmap/lib/pybind11/tests/pybind11_tests.h
+++ /dev/null
@@ -1,65 +0,0 @@
-#pragma once
-#include <pybind11/pybind11.h>
-
-#if defined(_MSC_VER) && _MSC_VER < 1910
-// We get some really long type names here which causes MSVC 2015 to emit warnings
-#  pragma warning(disable: 4503) // warning C4503: decorated name length exceeded, name was truncated
-#endif
-
-namespace py = pybind11;
-using namespace pybind11::literals;
-
-class test_initializer {
-    using Initializer = void (*)(py::module &);
-
-public:
-    test_initializer(Initializer init);
-    test_initializer(const char *submodule_name, Initializer init);
-};
-
-#define TEST_SUBMODULE(name, variable)                   \
-    void test_submodule_##name(py::module &);            \
-    test_initializer name(#name, test_submodule_##name); \
-    void test_submodule_##name(py::module &variable)
-
-
-/// Dummy type which is not exported anywhere -- something to trigger a conversion error
-struct UnregisteredType { };
-
-/// A user-defined type which is exported and can be used by any test
-class UserType {
-public:
-    UserType() = default;
-    UserType(int i) : i(i) { }
-
-    int value() const { return i; }
-    void set(int set) { i = set; }
-
-private:
-    int i = -1;
-};
-
-/// Like UserType, but increments `value` on copy for quick reference vs. copy tests
-class IncType : public UserType {
-public:
-    using UserType::UserType;
-    IncType() = default;
-    IncType(const IncType &other) : IncType(other.value() + 1) { }
-    IncType(IncType &&) = delete;
-    IncType &operator=(const IncType &) = delete;
-    IncType &operator=(IncType &&) = delete;
-};
-
-/// Custom cast-only type that casts to a string "rvalue" or "lvalue" depending on the cast context.
-/// Used to test recursive casters (e.g. std::tuple, stl containers).
-struct RValueCaster {};
-NAMESPACE_BEGIN(pybind11)
-NAMESPACE_BEGIN(detail)
-template<> class type_caster<RValueCaster> {
-public:
-    PYBIND11_TYPE_CASTER(RValueCaster, _("RValueCaster"));
-    static handle cast(RValueCaster &&, return_value_policy, handle) { return py::str("rvalue").release(); }
-    static handle cast(const RValueCaster &, return_value_policy, handle) { return py::str("lvalue").release(); }
-};
-NAMESPACE_END(detail)
-NAMESPACE_END(pybind11)
diff --git a/tmap/lib/pybind11/tests/pytest.ini b/tmap/lib/pybind11/tests/pytest.ini
deleted file mode 100644
index 1e44f0a..0000000
--- a/tmap/lib/pybind11/tests/pytest.ini
+++ /dev/null
@@ -1,15 +0,0 @@
-[pytest]
-minversion = 3.0
-norecursedirs = test_cmake_build test_embed
-addopts =
-    # show summary of skipped tests
-    -rs
-    # capture only Python print and C++ py::print, but not C output (low-level Python errors)
-    --capture=sys
-filterwarnings =
-    # make warnings into errors but ignore certain third-party extension issues
-    error
-    # importing scipy submodules on some version of Python
-    ignore::ImportWarning
-    # bogus numpy ABI warning (see numpy/#432)
-    ignore:.*numpy.dtype size changed.*:RuntimeWarning
diff --git a/tmap/lib/pybind11/tests/test_buffers.cpp b/tmap/lib/pybind11/tests/test_buffers.cpp
deleted file mode 100644
index 5be7177..0000000
--- a/tmap/lib/pybind11/tests/test_buffers.cpp
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
-    tests/test_buffers.cpp -- supporting Pythons' buffer protocol
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "constructor_stats.h"
-
-TEST_SUBMODULE(buffers, m) {
-    // test_from_python / test_to_python:
-    class Matrix {
-    public:
-        Matrix(ssize_t rows, ssize_t cols) : m_rows(rows), m_cols(cols) {
-            print_created(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
-            m_data = new float[(size_t) (rows*cols)];
-            memset(m_data, 0, sizeof(float) * (size_t) (rows * cols));
-        }
-
-        Matrix(const Matrix &s) : m_rows(s.m_rows), m_cols(s.m_cols) {
-            print_copy_created(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
-            m_data = new float[(size_t) (m_rows * m_cols)];
-            memcpy(m_data, s.m_data, sizeof(float) * (size_t) (m_rows * m_cols));
-        }
-
-        Matrix(Matrix &&s) : m_rows(s.m_rows), m_cols(s.m_cols), m_data(s.m_data) {
-            print_move_created(this);
-            s.m_rows = 0;
-            s.m_cols = 0;
-            s.m_data = nullptr;
-        }
-
-        ~Matrix() {
-            print_destroyed(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
-            delete[] m_data;
-        }
-
-        Matrix &operator=(const Matrix &s) {
-            print_copy_assigned(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
-            delete[] m_data;
-            m_rows = s.m_rows;
-            m_cols = s.m_cols;
-            m_data = new float[(size_t) (m_rows * m_cols)];
-            memcpy(m_data, s.m_data, sizeof(float) * (size_t) (m_rows * m_cols));
-            return *this;
-        }
-
-        Matrix &operator=(Matrix &&s) {
-            print_move_assigned(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
-            if (&s != this) {
-                delete[] m_data;
-                m_rows = s.m_rows; m_cols = s.m_cols; m_data = s.m_data;
-                s.m_rows = 0; s.m_cols = 0; s.m_data = nullptr;
-            }
-            return *this;
-        }
-
-        float operator()(ssize_t i, ssize_t j) const {
-            return m_data[(size_t) (i*m_cols + j)];
-        }
-
-        float &operator()(ssize_t i, ssize_t j) {
-            return m_data[(size_t) (i*m_cols + j)];
-        }
-
-        float *data() { return m_data; }
-
-        ssize_t rows() const { return m_rows; }
-        ssize_t cols() const { return m_cols; }
-    private:
-        ssize_t m_rows;
-        ssize_t m_cols;
-        float *m_data;
-    };
-    py::class_<Matrix>(m, "Matrix", py::buffer_protocol())
-        .def(py::init<ssize_t, ssize_t>())
-        /// Construct from a buffer
-        .def(py::init([](py::buffer b) {
-            py::buffer_info info = b.request();
-            if (info.format != py::format_descriptor<float>::format() || info.ndim != 2)
-                throw std::runtime_error("Incompatible buffer format!");
-
-            auto v = new Matrix(info.shape[0], info.shape[1]);
-            memcpy(v->data(), info.ptr, sizeof(float) * (size_t) (v->rows() * v->cols()));
-            return v;
-        }))
-
-       .def("rows", &Matrix::rows)
-       .def("cols", &Matrix::cols)
-
-        /// Bare bones interface
-       .def("__getitem__", [](const Matrix &m, std::pair<ssize_t, ssize_t> i) {
-            if (i.first >= m.rows() || i.second >= m.cols())
-                throw py::index_error();
-            return m(i.first, i.second);
-        })
-       .def("__setitem__", [](Matrix &m, std::pair<ssize_t, ssize_t> i, float v) {
-            if (i.first >= m.rows() || i.second >= m.cols())
-                throw py::index_error();
-            m(i.first, i.second) = v;
-        })
-       /// Provide buffer access
-       .def_buffer([](Matrix &m) -> py::buffer_info {
-            return py::buffer_info(
-                m.data(),                               /* Pointer to buffer */
-                { m.rows(), m.cols() },                 /* Buffer dimensions */
-                { sizeof(float) * size_t(m.rows()),     /* Strides (in bytes) for each index */
-                  sizeof(float) }
-            );
-        })
-        ;
-
-
-    // test_inherited_protocol
-    class SquareMatrix : public Matrix {
-    public:
-        SquareMatrix(ssize_t n) : Matrix(n, n) { }
-    };
-    // Derived classes inherit the buffer protocol and the buffer access function
-    py::class_<SquareMatrix, Matrix>(m, "SquareMatrix")
-        .def(py::init<ssize_t>());
-
-
-    // test_pointer_to_member_fn
-    // Tests that passing a pointer to member to the base class works in
-    // the derived class.
-    struct Buffer {
-        int32_t value = 0;
-
-        py::buffer_info get_buffer_info() {
-            return py::buffer_info(&value, sizeof(value),
-                                   py::format_descriptor<int32_t>::format(), 1);
-        }
-    };
-    py::class_<Buffer>(m, "Buffer", py::buffer_protocol())
-        .def(py::init<>())
-        .def_readwrite("value", &Buffer::value)
-        .def_buffer(&Buffer::get_buffer_info);
-
-
-    class ConstBuffer {
-        std::unique_ptr<int32_t> value;
-
-    public:
-        int32_t get_value() const { return *value; }
-        void set_value(int32_t v) { *value = v; }
-
-        py::buffer_info get_buffer_info() const {
-            return py::buffer_info(value.get(), sizeof(*value),
-                                   py::format_descriptor<int32_t>::format(), 1);
-        }
-
-        ConstBuffer() : value(new int32_t{0}) { };
-    };
-    py::class_<ConstBuffer>(m, "ConstBuffer", py::buffer_protocol())
-        .def(py::init<>())
-        .def_property("value", &ConstBuffer::get_value, &ConstBuffer::set_value)
-        .def_buffer(&ConstBuffer::get_buffer_info);
-
-    struct DerivedBuffer : public Buffer { };
-    py::class_<DerivedBuffer>(m, "DerivedBuffer", py::buffer_protocol())
-        .def(py::init<>())
-        .def_readwrite("value", (int32_t DerivedBuffer::*) &DerivedBuffer::value)
-        .def_buffer(&DerivedBuffer::get_buffer_info);
-
-}
diff --git a/tmap/lib/pybind11/tests/test_buffers.py b/tmap/lib/pybind11/tests/test_buffers.py
deleted file mode 100644
index c348be5..0000000
--- a/tmap/lib/pybind11/tests/test_buffers.py
+++ /dev/null
@@ -1,83 +0,0 @@
-import struct
-import pytest
-from pybind11_tests import buffers as m
-from pybind11_tests import ConstructorStats
-
-pytestmark = pytest.requires_numpy
-
-with pytest.suppress(ImportError):
-    import numpy as np
-
-
-def test_from_python():
-    with pytest.raises(RuntimeError) as excinfo:
-        m.Matrix(np.array([1, 2, 3]))  # trying to assign a 1D array
-    assert str(excinfo.value) == "Incompatible buffer format!"
-
-    m3 = np.array([[1, 2, 3], [4, 5, 6]]).astype(np.float32)
-    m4 = m.Matrix(m3)
-
-    for i in range(m4.rows()):
-        for j in range(m4.cols()):
-            assert m3[i, j] == m4[i, j]
-
-    cstats = ConstructorStats.get(m.Matrix)
-    assert cstats.alive() == 1
-    del m3, m4
-    assert cstats.alive() == 0
-    assert cstats.values() == ["2x3 matrix"]
-    assert cstats.copy_constructions == 0
-    # assert cstats.move_constructions >= 0  # Don't invoke any
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-
-# PyPy: Memory leak in the "np.array(m, copy=False)" call
-# https://bitbucket.org/pypy/pypy/issues/2444
-@pytest.unsupported_on_pypy
-def test_to_python():
-    mat = m.Matrix(5, 5)
-    assert memoryview(mat).shape == (5, 5)
-
-    assert mat[2, 3] == 0
-    mat[2, 3] = 4
-    assert mat[2, 3] == 4
-
-    mat2 = np.array(mat, copy=False)
-    assert mat2.shape == (5, 5)
-    assert abs(mat2).sum() == 4
-    assert mat2[2, 3] == 4
-    mat2[2, 3] = 5
-    assert mat2[2, 3] == 5
-
-    cstats = ConstructorStats.get(m.Matrix)
-    assert cstats.alive() == 1
-    del mat
-    pytest.gc_collect()
-    assert cstats.alive() == 1
-    del mat2  # holds a mat reference
-    pytest.gc_collect()
-    assert cstats.alive() == 0
-    assert cstats.values() == ["5x5 matrix"]
-    assert cstats.copy_constructions == 0
-    # assert cstats.move_constructions >= 0  # Don't invoke any
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-
-@pytest.unsupported_on_pypy
-def test_inherited_protocol():
-    """SquareMatrix is derived from Matrix and inherits the buffer protocol"""
-
-    matrix = m.SquareMatrix(5)
-    assert memoryview(matrix).shape == (5, 5)
-    assert np.asarray(matrix).shape == (5, 5)
-
-
-@pytest.unsupported_on_pypy
-def test_pointer_to_member_fn():
-    for cls in [m.Buffer, m.ConstBuffer, m.DerivedBuffer]:
-        buf = cls()
-        buf.value = 0x12345678
-        value = struct.unpack('i', bytearray(buf))[0]
-        assert value == 0x12345678
diff --git a/tmap/lib/pybind11/tests/test_builtin_casters.cpp b/tmap/lib/pybind11/tests/test_builtin_casters.cpp
deleted file mode 100644
index b73e96e..0000000
--- a/tmap/lib/pybind11/tests/test_builtin_casters.cpp
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
-    tests/test_builtin_casters.cpp -- Casters available without any additional headers
-
-    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include <pybind11/complex.h>
-
-#if defined(_MSC_VER)
-#  pragma warning(push)
-#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#endif
-
-TEST_SUBMODULE(builtin_casters, m) {
-    // test_simple_string
-    m.def("string_roundtrip", [](const char *s) { return s; });
-
-    // test_unicode_conversion
-    // Some test characters in utf16 and utf32 encodings.  The last one (the 𝐀) contains a null byte
-    char32_t a32 = 0x61 /*a*/, z32 = 0x7a /*z*/, ib32 = 0x203d /*‽*/, cake32 = 0x1f382 /*🎂*/,              mathbfA32 = 0x1d400 /*𝐀*/;
-    char16_t b16 = 0x62 /*b*/, z16 = 0x7a,       ib16 = 0x203d,       cake16_1 = 0xd83c, cake16_2 = 0xdf82, mathbfA16_1 = 0xd835, mathbfA16_2 = 0xdc00;
-    std::wstring wstr;
-    wstr.push_back(0x61); // a
-    wstr.push_back(0x2e18); // ⸘
-    if (sizeof(wchar_t) == 2) { wstr.push_back(mathbfA16_1); wstr.push_back(mathbfA16_2); } // 𝐀, utf16
-    else { wstr.push_back((wchar_t) mathbfA32); } // 𝐀, utf32
-    wstr.push_back(0x7a); // z
-
-    m.def("good_utf8_string", []() { return std::string(u8"Say utf8\u203d \U0001f382 \U0001d400"); }); // Say utf8‽ 🎂 𝐀
-    m.def("good_utf16_string", [=]() { return std::u16string({ b16, ib16, cake16_1, cake16_2, mathbfA16_1, mathbfA16_2, z16 }); }); // b‽🎂𝐀z
-    m.def("good_utf32_string", [=]() { return std::u32string({ a32, mathbfA32, cake32, ib32, z32 }); }); // a𝐀🎂‽z
-    m.def("good_wchar_string", [=]() { return wstr; }); // a‽𝐀z
-    m.def("bad_utf8_string", []()  { return std::string("abc\xd0" "def"); });
-    m.def("bad_utf16_string", [=]() { return std::u16string({ b16, char16_t(0xd800), z16 }); });
-    // Under Python 2.7, invalid unicode UTF-32 characters don't appear to trigger UnicodeDecodeError
-    if (PY_MAJOR_VERSION >= 3)
-        m.def("bad_utf32_string", [=]() { return std::u32string({ a32, char32_t(0xd800), z32 }); });
-    if (PY_MAJOR_VERSION >= 3 || sizeof(wchar_t) == 2)
-        m.def("bad_wchar_string", [=]() { return std::wstring({ wchar_t(0x61), wchar_t(0xd800) }); });
-    m.def("u8_Z", []() -> char { return 'Z'; });
-    m.def("u8_eacute", []() -> char { return '\xe9'; });
-    m.def("u16_ibang", [=]() -> char16_t { return ib16; });
-    m.def("u32_mathbfA", [=]() -> char32_t { return mathbfA32; });
-    m.def("wchar_heart", []() -> wchar_t { return 0x2665; });
-
-    // test_single_char_arguments
-    m.attr("wchar_size") = py::cast(sizeof(wchar_t));
-    m.def("ord_char", [](char c) -> int { return static_cast<unsigned char>(c); });
-    m.def("ord_char16", [](char16_t c) -> uint16_t { return c; });
-    m.def("ord_char32", [](char32_t c) -> uint32_t { return c; });
-    m.def("ord_wchar", [](wchar_t c) -> int { return c; });
-
-    // test_bytes_to_string
-    m.def("strlen", [](char *s) { return strlen(s); });
-    m.def("string_length", [](std::string s) { return s.length(); });
-
-    // test_string_view
-#ifdef PYBIND11_HAS_STRING_VIEW
-    m.attr("has_string_view") = true;
-    m.def("string_view_print",   [](std::string_view s)    { py::print(s, s.size()); });
-    m.def("string_view16_print", [](std::u16string_view s) { py::print(s, s.size()); });
-    m.def("string_view32_print", [](std::u32string_view s) { py::print(s, s.size()); });
-    m.def("string_view_chars",   [](std::string_view s)    { py::list l; for (auto c : s) l.append((std::uint8_t) c); return l; });
-    m.def("string_view16_chars", [](std::u16string_view s) { py::list l; for (auto c : s) l.append((int) c); return l; });
-    m.def("string_view32_chars", [](std::u32string_view s) { py::list l; for (auto c : s) l.append((int) c); return l; });
-    m.def("string_view_return",   []() { return std::string_view(u8"utf8 secret \U0001f382"); });
-    m.def("string_view16_return", []() { return std::u16string_view(u"utf16 secret \U0001f382"); });
-    m.def("string_view32_return", []() { return std::u32string_view(U"utf32 secret \U0001f382"); });
-#endif
-
-    // test_integer_casting
-    m.def("i32_str", [](std::int32_t v) { return std::to_string(v); });
-    m.def("u32_str", [](std::uint32_t v) { return std::to_string(v); });
-    m.def("i64_str", [](std::int64_t v) { return std::to_string(v); });
-    m.def("u64_str", [](std::uint64_t v) { return std::to_string(v); });
-
-    // test_tuple
-    m.def("pair_passthrough", [](std::pair<bool, std::string> input) {
-        return std::make_pair(input.second, input.first);
-    }, "Return a pair in reversed order");
-    m.def("tuple_passthrough", [](std::tuple<bool, std::string, int> input) {
-        return std::make_tuple(std::get<2>(input), std::get<1>(input), std::get<0>(input));
-    }, "Return a triple in reversed order");
-    m.def("empty_tuple", []() { return std::tuple<>(); });
-    static std::pair<RValueCaster, RValueCaster> lvpair;
-    static std::tuple<RValueCaster, RValueCaster, RValueCaster> lvtuple;
-    static std::pair<RValueCaster, std::tuple<RValueCaster, std::pair<RValueCaster, RValueCaster>>> lvnested;
-    m.def("rvalue_pair", []() { return std::make_pair(RValueCaster{}, RValueCaster{}); });
-    m.def("lvalue_pair", []() -> const decltype(lvpair) & { return lvpair; });
-    m.def("rvalue_tuple", []() { return std::make_tuple(RValueCaster{}, RValueCaster{}, RValueCaster{}); });
-    m.def("lvalue_tuple", []() -> const decltype(lvtuple) & { return lvtuple; });
-    m.def("rvalue_nested", []() {
-        return std::make_pair(RValueCaster{}, std::make_tuple(RValueCaster{}, std::make_pair(RValueCaster{}, RValueCaster{}))); });
-    m.def("lvalue_nested", []() -> const decltype(lvnested) & { return lvnested; });
-
-    // test_builtins_cast_return_none
-    m.def("return_none_string", []() -> std::string * { return nullptr; });
-    m.def("return_none_char",   []() -> const char *  { return nullptr; });
-    m.def("return_none_bool",   []() -> bool *        { return nullptr; });
-    m.def("return_none_int",    []() -> int *         { return nullptr; });
-    m.def("return_none_float",  []() -> float *       { return nullptr; });
-
-    // test_none_deferred
-    m.def("defer_none_cstring", [](char *) { return false; });
-    m.def("defer_none_cstring", [](py::none) { return true; });
-    m.def("defer_none_custom", [](UserType *) { return false; });
-    m.def("defer_none_custom", [](py::none) { return true; });
-    m.def("nodefer_none_void", [](void *) { return true; });
-    m.def("nodefer_none_void", [](py::none) { return false; });
-
-    // test_void_caster
-    m.def("load_nullptr_t", [](std::nullptr_t) {}); // not useful, but it should still compile
-    m.def("cast_nullptr_t", []() { return std::nullptr_t{}; });
-
-    // test_bool_caster
-    m.def("bool_passthrough", [](bool arg) { return arg; });
-    m.def("bool_passthrough_noconvert", [](bool arg) { return arg; }, py::arg().noconvert());
-
-    // test_reference_wrapper
-    m.def("refwrap_builtin", [](std::reference_wrapper<int> p) { return 10 * p.get(); });
-    m.def("refwrap_usertype", [](std::reference_wrapper<UserType> p) { return p.get().value(); });
-    // Not currently supported (std::pair caster has return-by-value cast operator);
-    // triggers static_assert failure.
-    //m.def("refwrap_pair", [](std::reference_wrapper<std::pair<int, int>>) { });
-
-    m.def("refwrap_list", [](bool copy) {
-        static IncType x1(1), x2(2);
-        py::list l;
-        for (auto &f : {std::ref(x1), std::ref(x2)}) {
-            l.append(py::cast(f, copy ? py::return_value_policy::copy
-                                      : py::return_value_policy::reference));
-        }
-        return l;
-    }, "copy"_a);
-
-    m.def("refwrap_iiw", [](const IncType &w) { return w.value(); });
-    m.def("refwrap_call_iiw", [](IncType &w, py::function f) {
-        py::list l;
-        l.append(f(std::ref(w)));
-        l.append(f(std::cref(w)));
-        IncType x(w.value());
-        l.append(f(std::ref(x)));
-        IncType y(w.value());
-        auto r3 = std::ref(y);
-        l.append(f(r3));
-        return l;
-    });
-
-    // test_complex
-    m.def("complex_cast", [](float x) { return "{}"_s.format(x); });
-    m.def("complex_cast", [](std::complex<float> x) { return "({}, {})"_s.format(x.real(), x.imag()); });
-}
diff --git a/tmap/lib/pybind11/tests/test_builtin_casters.py b/tmap/lib/pybind11/tests/test_builtin_casters.py
deleted file mode 100644
index bc094a3..0000000
--- a/tmap/lib/pybind11/tests/test_builtin_casters.py
+++ /dev/null
@@ -1,322 +0,0 @@
-# Python < 3 needs this: coding=utf-8
-import pytest
-
-from pybind11_tests import builtin_casters as m
-from pybind11_tests import UserType, IncType
-
-
-def test_simple_string():
-    assert m.string_roundtrip("const char *") == "const char *"
-
-
-def test_unicode_conversion():
-    """Tests unicode conversion and error reporting."""
-    assert m.good_utf8_string() == u"Say utf8‽ 🎂 𝐀"
-    assert m.good_utf16_string() == u"b‽🎂𝐀z"
-    assert m.good_utf32_string() == u"a𝐀🎂‽z"
-    assert m.good_wchar_string() == u"a⸘𝐀z"
-
-    with pytest.raises(UnicodeDecodeError):
-        m.bad_utf8_string()
-
-    with pytest.raises(UnicodeDecodeError):
-        m.bad_utf16_string()
-
-    # These are provided only if they actually fail (they don't when 32-bit and under Python 2.7)
-    if hasattr(m, "bad_utf32_string"):
-        with pytest.raises(UnicodeDecodeError):
-            m.bad_utf32_string()
-    if hasattr(m, "bad_wchar_string"):
-        with pytest.raises(UnicodeDecodeError):
-            m.bad_wchar_string()
-
-    assert m.u8_Z() == 'Z'
-    assert m.u8_eacute() == u'é'
-    assert m.u16_ibang() == u'‽'
-    assert m.u32_mathbfA() == u'𝐀'
-    assert m.wchar_heart() == u'♥'
-
-
-def test_single_char_arguments():
-    """Tests failures for passing invalid inputs to char-accepting functions"""
-    def toobig_message(r):
-        return "Character code point not in range({0:#x})".format(r)
-    toolong_message = "Expected a character, but multi-character string found"
-
-    assert m.ord_char(u'a') == 0x61  # simple ASCII
-    assert m.ord_char(u'é') == 0xE9  # requires 2 bytes in utf-8, but can be stuffed in a char
-    with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char(u'Ā') == 0x100  # requires 2 bytes, doesn't fit in a char
-    assert str(excinfo.value) == toobig_message(0x100)
-    with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char(u'ab')
-    assert str(excinfo.value) == toolong_message
-
-    assert m.ord_char16(u'a') == 0x61
-    assert m.ord_char16(u'é') == 0xE9
-    assert m.ord_char16(u'Ā') == 0x100
-    assert m.ord_char16(u'‽') == 0x203d
-    assert m.ord_char16(u'♥') == 0x2665
-    with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char16(u'🎂') == 0x1F382  # requires surrogate pair
-    assert str(excinfo.value) == toobig_message(0x10000)
-    with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char16(u'aa')
-    assert str(excinfo.value) == toolong_message
-
-    assert m.ord_char32(u'a') == 0x61
-    assert m.ord_char32(u'é') == 0xE9
-    assert m.ord_char32(u'Ā') == 0x100
-    assert m.ord_char32(u'‽') == 0x203d
-    assert m.ord_char32(u'♥') == 0x2665
-    assert m.ord_char32(u'🎂') == 0x1F382
-    with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char32(u'aa')
-    assert str(excinfo.value) == toolong_message
-
-    assert m.ord_wchar(u'a') == 0x61
-    assert m.ord_wchar(u'é') == 0xE9
-    assert m.ord_wchar(u'Ā') == 0x100
-    assert m.ord_wchar(u'‽') == 0x203d
-    assert m.ord_wchar(u'♥') == 0x2665
-    if m.wchar_size == 2:
-        with pytest.raises(ValueError) as excinfo:
-            assert m.ord_wchar(u'🎂') == 0x1F382  # requires surrogate pair
-        assert str(excinfo.value) == toobig_message(0x10000)
-    else:
-        assert m.ord_wchar(u'🎂') == 0x1F382
-    with pytest.raises(ValueError) as excinfo:
-        assert m.ord_wchar(u'aa')
-    assert str(excinfo.value) == toolong_message
-
-
-def test_bytes_to_string():
-    """Tests the ability to pass bytes to C++ string-accepting functions.  Note that this is
-    one-way: the only way to return bytes to Python is via the pybind11::bytes class."""
-    # Issue #816
-    import sys
-    byte = bytes if sys.version_info[0] < 3 else str
-
-    assert m.strlen(byte("hi")) == 2
-    assert m.string_length(byte("world")) == 5
-    assert m.string_length(byte("a\x00b")) == 3
-    assert m.strlen(byte("a\x00b")) == 1  # C-string limitation
-
-    # passing in a utf8 encoded string should work
-    assert m.string_length(u'💩'.encode("utf8")) == 4
-
-
-@pytest.mark.skipif(not hasattr(m, "has_string_view"), reason="no <string_view>")
-def test_string_view(capture):
-    """Tests support for C++17 string_view arguments and return values"""
-    assert m.string_view_chars("Hi") == [72, 105]
-    assert m.string_view_chars("Hi 🎂") == [72, 105, 32, 0xf0, 0x9f, 0x8e, 0x82]
-    assert m.string_view16_chars("Hi 🎂") == [72, 105, 32, 0xd83c, 0xdf82]
-    assert m.string_view32_chars("Hi 🎂") == [72, 105, 32, 127874]
-
-    assert m.string_view_return() == "utf8 secret 🎂"
-    assert m.string_view16_return() == "utf16 secret 🎂"
-    assert m.string_view32_return() == "utf32 secret 🎂"
-
-    with capture:
-        m.string_view_print("Hi")
-        m.string_view_print("utf8 🎂")
-        m.string_view16_print("utf16 🎂")
-        m.string_view32_print("utf32 🎂")
-    assert capture == """
-        Hi 2
-        utf8 🎂 9
-        utf16 🎂 8
-        utf32 🎂 7
-    """
-
-    with capture:
-        m.string_view_print("Hi, ascii")
-        m.string_view_print("Hi, utf8 🎂")
-        m.string_view16_print("Hi, utf16 🎂")
-        m.string_view32_print("Hi, utf32 🎂")
-    assert capture == """
-        Hi, ascii 9
-        Hi, utf8 🎂 13
-        Hi, utf16 🎂 12
-        Hi, utf32 🎂 11
-    """
-
-
-def test_integer_casting():
-    """Issue #929 - out-of-range integer values shouldn't be accepted"""
-    import sys
-    assert m.i32_str(-1) == "-1"
-    assert m.i64_str(-1) == "-1"
-    assert m.i32_str(2000000000) == "2000000000"
-    assert m.u32_str(2000000000) == "2000000000"
-    if sys.version_info < (3,):
-        assert m.i32_str(long(-1)) == "-1"  # noqa: F821 undefined name 'long'
-        assert m.i64_str(long(-1)) == "-1"  # noqa: F821 undefined name 'long'
-        assert m.i64_str(long(-999999999999)) == "-999999999999"  # noqa: F821 undefined name
-        assert m.u64_str(long(999999999999)) == "999999999999"  # noqa: F821 undefined name 'long'
-    else:
-        assert m.i64_str(-999999999999) == "-999999999999"
-        assert m.u64_str(999999999999) == "999999999999"
-
-    with pytest.raises(TypeError) as excinfo:
-        m.u32_str(-1)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.u64_str(-1)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.i32_str(-3000000000)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.i32_str(3000000000)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    if sys.version_info < (3,):
-        with pytest.raises(TypeError) as excinfo:
-            m.u32_str(long(-1))  # noqa: F821 undefined name 'long'
-        assert "incompatible function arguments" in str(excinfo.value)
-        with pytest.raises(TypeError) as excinfo:
-            m.u64_str(long(-1))  # noqa: F821 undefined name 'long'
-        assert "incompatible function arguments" in str(excinfo.value)
-
-
-def test_tuple(doc):
-    """std::pair <-> tuple & std::tuple <-> tuple"""
-    assert m.pair_passthrough((True, "test")) == ("test", True)
-    assert m.tuple_passthrough((True, "test", 5)) == (5, "test", True)
-    # Any sequence can be cast to a std::pair or std::tuple
-    assert m.pair_passthrough([True, "test"]) == ("test", True)
-    assert m.tuple_passthrough([True, "test", 5]) == (5, "test", True)
-    assert m.empty_tuple() == ()
-
-    assert doc(m.pair_passthrough) == """
-        pair_passthrough(arg0: Tuple[bool, str]) -> Tuple[str, bool]
-
-        Return a pair in reversed order
-    """
-    assert doc(m.tuple_passthrough) == """
-        tuple_passthrough(arg0: Tuple[bool, str, int]) -> Tuple[int, str, bool]
-
-        Return a triple in reversed order
-    """
-
-    assert m.rvalue_pair() == ("rvalue", "rvalue")
-    assert m.lvalue_pair() == ("lvalue", "lvalue")
-    assert m.rvalue_tuple() == ("rvalue", "rvalue", "rvalue")
-    assert m.lvalue_tuple() == ("lvalue", "lvalue", "lvalue")
-    assert m.rvalue_nested() == ("rvalue", ("rvalue", ("rvalue", "rvalue")))
-    assert m.lvalue_nested() == ("lvalue", ("lvalue", ("lvalue", "lvalue")))
-
-
-def test_builtins_cast_return_none():
-    """Casters produced with PYBIND11_TYPE_CASTER() should convert nullptr to None"""
-    assert m.return_none_string() is None
-    assert m.return_none_char() is None
-    assert m.return_none_bool() is None
-    assert m.return_none_int() is None
-    assert m.return_none_float() is None
-
-
-def test_none_deferred():
-    """None passed as various argument types should defer to other overloads"""
-    assert not m.defer_none_cstring("abc")
-    assert m.defer_none_cstring(None)
-    assert not m.defer_none_custom(UserType())
-    assert m.defer_none_custom(None)
-    assert m.nodefer_none_void(None)
-
-
-def test_void_caster():
-    assert m.load_nullptr_t(None) is None
-    assert m.cast_nullptr_t() is None
-
-
-def test_reference_wrapper():
-    """std::reference_wrapper for builtin and user types"""
-    assert m.refwrap_builtin(42) == 420
-    assert m.refwrap_usertype(UserType(42)) == 42
-
-    with pytest.raises(TypeError) as excinfo:
-        m.refwrap_builtin(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    with pytest.raises(TypeError) as excinfo:
-        m.refwrap_usertype(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    a1 = m.refwrap_list(copy=True)
-    a2 = m.refwrap_list(copy=True)
-    assert [x.value for x in a1] == [2, 3]
-    assert [x.value for x in a2] == [2, 3]
-    assert not a1[0] is a2[0] and not a1[1] is a2[1]
-
-    b1 = m.refwrap_list(copy=False)
-    b2 = m.refwrap_list(copy=False)
-    assert [x.value for x in b1] == [1, 2]
-    assert [x.value for x in b2] == [1, 2]
-    assert b1[0] is b2[0] and b1[1] is b2[1]
-
-    assert m.refwrap_iiw(IncType(5)) == 5
-    assert m.refwrap_call_iiw(IncType(10), m.refwrap_iiw) == [10, 10, 10, 10]
-
-
-def test_complex_cast():
-    """std::complex casts"""
-    assert m.complex_cast(1) == "1.0"
-    assert m.complex_cast(2j) == "(0.0, 2.0)"
-
-
-def test_bool_caster():
-    """Test bool caster implicit conversions."""
-    convert, noconvert = m.bool_passthrough, m.bool_passthrough_noconvert
-
-    def require_implicit(v):
-        pytest.raises(TypeError, noconvert, v)
-
-    def cant_convert(v):
-        pytest.raises(TypeError, convert, v)
-
-    # straight up bool
-    assert convert(True) is True
-    assert convert(False) is False
-    assert noconvert(True) is True
-    assert noconvert(False) is False
-
-    # None requires implicit conversion
-    require_implicit(None)
-    assert convert(None) is False
-
-    class A(object):
-        def __init__(self, x):
-            self.x = x
-
-        def __nonzero__(self):
-            return self.x
-
-        def __bool__(self):
-            return self.x
-
-    class B(object):
-        pass
-
-    # Arbitrary objects are not accepted
-    cant_convert(object())
-    cant_convert(B())
-
-    # Objects with __nonzero__ / __bool__ defined can be converted
-    require_implicit(A(True))
-    assert convert(A(True)) is True
-    assert convert(A(False)) is False
-
-
-@pytest.requires_numpy
-def test_numpy_bool():
-    import numpy as np
-    convert, noconvert = m.bool_passthrough, m.bool_passthrough_noconvert
-
-    # np.bool_ is not considered implicit
-    assert convert(np.bool_(True)) is True
-    assert convert(np.bool_(False)) is False
-    assert noconvert(np.bool_(True)) is True
-    assert noconvert(np.bool_(False)) is False
diff --git a/tmap/lib/pybind11/tests/test_call_policies.cpp b/tmap/lib/pybind11/tests/test_call_policies.cpp
deleted file mode 100644
index 65e54a0..0000000
--- a/tmap/lib/pybind11/tests/test_call_policies.cpp
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
-    tests/test_call_policies.cpp -- keep_alive and call_guard
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-
-struct CustomGuard {
-    static bool enabled;
-
-    CustomGuard() { enabled = true; }
-    ~CustomGuard() { enabled = false; }
-
-    static const char *report_status() { return enabled ? "guarded" : "unguarded"; }
-};
-bool CustomGuard::enabled = false;
-
-struct DependentGuard {
-    static bool enabled;
-
-    DependentGuard() { enabled = CustomGuard::enabled; }
-    ~DependentGuard() { enabled = false; }
-
-    static const char *report_status() { return enabled ? "guarded" : "unguarded"; }
-};
-bool DependentGuard::enabled = false;
-
-TEST_SUBMODULE(call_policies, m) {
-    // Parent/Child are used in:
-    // test_keep_alive_argument, test_keep_alive_return_value, test_alive_gc_derived,
-    // test_alive_gc_multi_derived, test_return_none
-    class Child {
-    public:
-        Child() { py::print("Allocating child."); }
-        ~Child() { py::print("Releasing child."); }
-    };
-    py::class_<Child>(m, "Child")
-        .def(py::init<>());
-
-    class Parent {
-    public:
-        Parent() { py::print("Allocating parent."); }
-        ~Parent() { py::print("Releasing parent."); }
-        void addChild(Child *) { }
-        Child *returnChild() { return new Child(); }
-        Child *returnNullChild() { return nullptr; }
-    };
-    py::class_<Parent>(m, "Parent")
-        .def(py::init<>())
-        .def("addChild", &Parent::addChild)
-        .def("addChildKeepAlive", &Parent::addChild, py::keep_alive<1, 2>())
-        .def("returnChild", &Parent::returnChild)
-        .def("returnChildKeepAlive", &Parent::returnChild, py::keep_alive<1, 0>())
-        .def("returnNullChildKeepAliveChild", &Parent::returnNullChild, py::keep_alive<1, 0>())
-        .def("returnNullChildKeepAliveParent", &Parent::returnNullChild, py::keep_alive<0, 1>());
-
-#if !defined(PYPY_VERSION)
-    // test_alive_gc
-    class ParentGC : public Parent {
-    public:
-        using Parent::Parent;
-    };
-    py::class_<ParentGC, Parent>(m, "ParentGC", py::dynamic_attr())
-        .def(py::init<>());
-#endif
-
-    // test_call_guard
-    m.def("unguarded_call", &CustomGuard::report_status);
-    m.def("guarded_call", &CustomGuard::report_status, py::call_guard<CustomGuard>());
-
-    m.def("multiple_guards_correct_order", []() {
-        return CustomGuard::report_status() + std::string(" & ") + DependentGuard::report_status();
-    }, py::call_guard<CustomGuard, DependentGuard>());
-
-    m.def("multiple_guards_wrong_order", []() {
-        return DependentGuard::report_status() + std::string(" & ") + CustomGuard::report_status();
-    }, py::call_guard<DependentGuard, CustomGuard>());
-
-#if defined(WITH_THREAD) && !defined(PYPY_VERSION)
-    // `py::call_guard<py::gil_scoped_release>()` should work in PyPy as well,
-    // but it's unclear how to test it without `PyGILState_GetThisThreadState`.
-    auto report_gil_status = []() {
-        auto is_gil_held = false;
-        if (auto tstate = py::detail::get_thread_state_unchecked())
-            is_gil_held = (tstate == PyGILState_GetThisThreadState());
-
-        return is_gil_held ? "GIL held" : "GIL released";
-    };
-
-    m.def("with_gil", report_gil_status);
-    m.def("without_gil", report_gil_status, py::call_guard<py::gil_scoped_release>());
-#endif
-}
diff --git a/tmap/lib/pybind11/tests/test_call_policies.py b/tmap/lib/pybind11/tests/test_call_policies.py
deleted file mode 100644
index 6c60f81..0000000
--- a/tmap/lib/pybind11/tests/test_call_policies.py
+++ /dev/null
@@ -1,168 +0,0 @@
-import pytest
-from pybind11_tests import call_policies as m
-from pybind11_tests import ConstructorStats
-
-
-def test_keep_alive_argument(capture):
-    n_inst = ConstructorStats.detail_reg_inst()
-    with capture:
-        p = m.Parent()
-    assert capture == "Allocating parent."
-    with capture:
-        p.addChild(m.Child())
-        assert ConstructorStats.detail_reg_inst() == n_inst + 1
-    assert capture == """
-        Allocating child.
-        Releasing child.
-    """
-    with capture:
-        del p
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert capture == "Releasing parent."
-
-    with capture:
-        p = m.Parent()
-    assert capture == "Allocating parent."
-    with capture:
-        p.addChildKeepAlive(m.Child())
-        assert ConstructorStats.detail_reg_inst() == n_inst + 2
-    assert capture == "Allocating child."
-    with capture:
-        del p
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert capture == """
-        Releasing parent.
-        Releasing child.
-    """
-
-
-def test_keep_alive_return_value(capture):
-    n_inst = ConstructorStats.detail_reg_inst()
-    with capture:
-        p = m.Parent()
-    assert capture == "Allocating parent."
-    with capture:
-        p.returnChild()
-        assert ConstructorStats.detail_reg_inst() == n_inst + 1
-    assert capture == """
-        Allocating child.
-        Releasing child.
-    """
-    with capture:
-        del p
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert capture == "Releasing parent."
-
-    with capture:
-        p = m.Parent()
-    assert capture == "Allocating parent."
-    with capture:
-        p.returnChildKeepAlive()
-        assert ConstructorStats.detail_reg_inst() == n_inst + 2
-    assert capture == "Allocating child."
-    with capture:
-        del p
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert capture == """
-        Releasing parent.
-        Releasing child.
-    """
-
-
-# https://bitbucket.org/pypy/pypy/issues/2447
-@pytest.unsupported_on_pypy
-def test_alive_gc(capture):
-    n_inst = ConstructorStats.detail_reg_inst()
-    p = m.ParentGC()
-    p.addChildKeepAlive(m.Child())
-    assert ConstructorStats.detail_reg_inst() == n_inst + 2
-    lst = [p]
-    lst.append(lst)   # creates a circular reference
-    with capture:
-        del p, lst
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert capture == """
-        Releasing parent.
-        Releasing child.
-    """
-
-
-def test_alive_gc_derived(capture):
-    class Derived(m.Parent):
-        pass
-
-    n_inst = ConstructorStats.detail_reg_inst()
-    p = Derived()
-    p.addChildKeepAlive(m.Child())
-    assert ConstructorStats.detail_reg_inst() == n_inst + 2
-    lst = [p]
-    lst.append(lst)   # creates a circular reference
-    with capture:
-        del p, lst
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert capture == """
-        Releasing parent.
-        Releasing child.
-    """
-
-
-def test_alive_gc_multi_derived(capture):
-    class Derived(m.Parent, m.Child):
-        def __init__(self):
-            m.Parent.__init__(self)
-            m.Child.__init__(self)
-
-    n_inst = ConstructorStats.detail_reg_inst()
-    p = Derived()
-    p.addChildKeepAlive(m.Child())
-    # +3 rather than +2 because Derived corresponds to two registered instances
-    assert ConstructorStats.detail_reg_inst() == n_inst + 3
-    lst = [p]
-    lst.append(lst)   # creates a circular reference
-    with capture:
-        del p, lst
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert capture == """
-        Releasing parent.
-        Releasing child.
-        Releasing child.
-    """
-
-
-def test_return_none(capture):
-    n_inst = ConstructorStats.detail_reg_inst()
-    with capture:
-        p = m.Parent()
-    assert capture == "Allocating parent."
-    with capture:
-        p.returnNullChildKeepAliveChild()
-        assert ConstructorStats.detail_reg_inst() == n_inst + 1
-    assert capture == ""
-    with capture:
-        del p
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert capture == "Releasing parent."
-
-    with capture:
-        p = m.Parent()
-    assert capture == "Allocating parent."
-    with capture:
-        p.returnNullChildKeepAliveParent()
-        assert ConstructorStats.detail_reg_inst() == n_inst + 1
-    assert capture == ""
-    with capture:
-        del p
-        assert ConstructorStats.detail_reg_inst() == n_inst
-    assert capture == "Releasing parent."
-
-
-def test_call_guard():
-    assert m.unguarded_call() == "unguarded"
-    assert m.guarded_call() == "guarded"
-
-    assert m.multiple_guards_correct_order() == "guarded & guarded"
-    assert m.multiple_guards_wrong_order() == "unguarded & guarded"
-
-    if hasattr(m, "with_gil"):
-        assert m.with_gil() == "GIL held"
-        assert m.without_gil() == "GIL released"
diff --git a/tmap/lib/pybind11/tests/test_callbacks.cpp b/tmap/lib/pybind11/tests/test_callbacks.cpp
deleted file mode 100644
index 273eacc..0000000
--- a/tmap/lib/pybind11/tests/test_callbacks.cpp
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
-    tests/test_callbacks.cpp -- callbacks
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "constructor_stats.h"
-#include <pybind11/functional.h>
-
-
-int dummy_function(int i) { return i + 1; }
-
-TEST_SUBMODULE(callbacks, m) {
-    // test_callbacks, test_function_signatures
-    m.def("test_callback1", [](py::object func) { return func(); });
-    m.def("test_callback2", [](py::object func) { return func("Hello", 'x', true, 5); });
-    m.def("test_callback3", [](const std::function<int(int)> &func) {
-        return "func(43) = " + std::to_string(func(43)); });
-    m.def("test_callback4", []() -> std::function<int(int)> { return [](int i) { return i+1; }; });
-    m.def("test_callback5", []() {
-        return py::cpp_function([](int i) { return i+1; }, py::arg("number"));
-    });
-
-    // test_keyword_args_and_generalized_unpacking
-    m.def("test_tuple_unpacking", [](py::function f) {
-        auto t1 = py::make_tuple(2, 3);
-        auto t2 = py::make_tuple(5, 6);
-        return f("positional", 1, *t1, 4, *t2);
-    });
-
-    m.def("test_dict_unpacking", [](py::function f) {
-        auto d1 = py::dict("key"_a="value", "a"_a=1);
-        auto d2 = py::dict();
-        auto d3 = py::dict("b"_a=2);
-        return f("positional", 1, **d1, **d2, **d3);
-    });
-
-    m.def("test_keyword_args", [](py::function f) {
-        return f("x"_a=10, "y"_a=20);
-    });
-
-    m.def("test_unpacking_and_keywords1", [](py::function f) {
-        auto args = py::make_tuple(2);
-        auto kwargs = py::dict("d"_a=4);
-        return f(1, *args, "c"_a=3, **kwargs);
-    });
-
-    m.def("test_unpacking_and_keywords2", [](py::function f) {
-        auto kwargs1 = py::dict("a"_a=1);
-        auto kwargs2 = py::dict("c"_a=3, "d"_a=4);
-        return f("positional", *py::make_tuple(1), 2, *py::make_tuple(3, 4), 5,
-                 "key"_a="value", **kwargs1, "b"_a=2, **kwargs2, "e"_a=5);
-    });
-
-    m.def("test_unpacking_error1", [](py::function f) {
-        auto kwargs = py::dict("x"_a=3);
-        return f("x"_a=1, "y"_a=2, **kwargs); // duplicate ** after keyword
-    });
-
-    m.def("test_unpacking_error2", [](py::function f) {
-        auto kwargs = py::dict("x"_a=3);
-        return f(**kwargs, "x"_a=1); // duplicate keyword after **
-    });
-
-    m.def("test_arg_conversion_error1", [](py::function f) {
-        f(234, UnregisteredType(), "kw"_a=567);
-    });
-
-    m.def("test_arg_conversion_error2", [](py::function f) {
-        f(234, "expected_name"_a=UnregisteredType(), "kw"_a=567);
-    });
-
-    // test_lambda_closure_cleanup
-    struct Payload {
-        Payload() { print_default_created(this); }
-        ~Payload() { print_destroyed(this); }
-        Payload(const Payload &) { print_copy_created(this); }
-        Payload(Payload &&) { print_move_created(this); }
-    };
-    // Export the payload constructor statistics for testing purposes:
-    m.def("payload_cstats", &ConstructorStats::get<Payload>);
-    /* Test cleanup of lambda closure */
-    m.def("test_cleanup", []() -> std::function<void(void)> {
-        Payload p;
-
-        return [p]() {
-            /* p should be cleaned up when the returned function is garbage collected */
-            (void) p;
-        };
-    });
-
-    // test_cpp_function_roundtrip
-    /* Test if passing a function pointer from C++ -> Python -> C++ yields the original pointer */
-    m.def("dummy_function", &dummy_function);
-    m.def("dummy_function2", [](int i, int j) { return i + j; });
-    m.def("roundtrip", [](std::function<int(int)> f, bool expect_none = false) {
-        if (expect_none && f)
-            throw std::runtime_error("Expected None to be converted to empty std::function");
-        return f;
-    }, py::arg("f"), py::arg("expect_none")=false);
-    m.def("test_dummy_function", [](const std::function<int(int)> &f) -> std::string {
-        using fn_type = int (*)(int);
-        auto result = f.target<fn_type>();
-        if (!result) {
-            auto r = f(1);
-            return "can't convert to function pointer: eval(1) = " + std::to_string(r);
-        } else if (*result == dummy_function) {
-            auto r = (*result)(1);
-            return "matches dummy_function: eval(1) = " + std::to_string(r);
-        } else {
-            return "argument does NOT match dummy_function. This should never happen!";
-        }
-    });
-
-    class AbstractBase { public: virtual unsigned int func() = 0; };
-    m.def("func_accepting_func_accepting_base", [](std::function<double(AbstractBase&)>) { });
-
-    struct MovableObject {
-        bool valid = true;
-
-        MovableObject() = default;
-        MovableObject(const MovableObject &) = default;
-        MovableObject &operator=(const MovableObject &) = default;
-        MovableObject(MovableObject &&o) : valid(o.valid) { o.valid = false; }
-        MovableObject &operator=(MovableObject &&o) {
-            valid = o.valid;
-            o.valid = false;
-            return *this;
-        }
-    };
-    py::class_<MovableObject>(m, "MovableObject");
-
-    // test_movable_object
-    m.def("callback_with_movable", [](std::function<void(MovableObject &)> f) {
-        auto x = MovableObject();
-        f(x); // lvalue reference shouldn't move out object
-        return x.valid; // must still return `true`
-    });
-
-    // test_bound_method_callback
-    struct CppBoundMethodTest {};
-    py::class_<CppBoundMethodTest>(m, "CppBoundMethodTest")
-        .def(py::init<>())
-        .def("triple", [](CppBoundMethodTest &, int val) { return 3 * val; });
-}
diff --git a/tmap/lib/pybind11/tests/test_callbacks.py b/tmap/lib/pybind11/tests/test_callbacks.py
deleted file mode 100644
index 93c42c2..0000000
--- a/tmap/lib/pybind11/tests/test_callbacks.py
+++ /dev/null
@@ -1,107 +0,0 @@
-import pytest
-from pybind11_tests import callbacks as m
-
-
-def test_callbacks():
-    from functools import partial
-
-    def func1():
-        return "func1"
-
-    def func2(a, b, c, d):
-        return "func2", a, b, c, d
-
-    def func3(a):
-        return "func3({})".format(a)
-
-    assert m.test_callback1(func1) == "func1"
-    assert m.test_callback2(func2) == ("func2", "Hello", "x", True, 5)
-    assert m.test_callback1(partial(func2, 1, 2, 3, 4)) == ("func2", 1, 2, 3, 4)
-    assert m.test_callback1(partial(func3, "partial")) == "func3(partial)"
-    assert m.test_callback3(lambda i: i + 1) == "func(43) = 44"
-
-    f = m.test_callback4()
-    assert f(43) == 44
-    f = m.test_callback5()
-    assert f(number=43) == 44
-
-
-def test_bound_method_callback():
-    # Bound Python method:
-    class MyClass:
-        def double(self, val):
-            return 2 * val
-
-    z = MyClass()
-    assert m.test_callback3(z.double) == "func(43) = 86"
-
-    z = m.CppBoundMethodTest()
-    assert m.test_callback3(z.triple) == "func(43) = 129"
-
-
-def test_keyword_args_and_generalized_unpacking():
-
-    def f(*args, **kwargs):
-        return args, kwargs
-
-    assert m.test_tuple_unpacking(f) == (("positional", 1, 2, 3, 4, 5, 6), {})
-    assert m.test_dict_unpacking(f) == (("positional", 1), {"key": "value", "a": 1, "b": 2})
-    assert m.test_keyword_args(f) == ((), {"x": 10, "y": 20})
-    assert m.test_unpacking_and_keywords1(f) == ((1, 2), {"c": 3, "d": 4})
-    assert m.test_unpacking_and_keywords2(f) == (
-        ("positional", 1, 2, 3, 4, 5),
-        {"key": "value", "a": 1, "b": 2, "c": 3, "d": 4, "e": 5}
-    )
-
-    with pytest.raises(TypeError) as excinfo:
-        m.test_unpacking_error1(f)
-    assert "Got multiple values for keyword argument" in str(excinfo.value)
-
-    with pytest.raises(TypeError) as excinfo:
-        m.test_unpacking_error2(f)
-    assert "Got multiple values for keyword argument" in str(excinfo.value)
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.test_arg_conversion_error1(f)
-    assert "Unable to convert call argument" in str(excinfo.value)
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.test_arg_conversion_error2(f)
-    assert "Unable to convert call argument" in str(excinfo.value)
-
-
-def test_lambda_closure_cleanup():
-    m.test_cleanup()
-    cstats = m.payload_cstats()
-    assert cstats.alive() == 0
-    assert cstats.copy_constructions == 1
-    assert cstats.move_constructions >= 1
-
-
-def test_cpp_function_roundtrip():
-    """Test if passing a function pointer from C++ -> Python -> C++ yields the original pointer"""
-
-    assert m.test_dummy_function(m.dummy_function) == "matches dummy_function: eval(1) = 2"
-    assert (m.test_dummy_function(m.roundtrip(m.dummy_function)) ==
-            "matches dummy_function: eval(1) = 2")
-    assert m.roundtrip(None, expect_none=True) is None
-    assert (m.test_dummy_function(lambda x: x + 2) ==
-            "can't convert to function pointer: eval(1) = 3")
-
-    with pytest.raises(TypeError) as excinfo:
-        m.test_dummy_function(m.dummy_function2)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    with pytest.raises(TypeError) as excinfo:
-        m.test_dummy_function(lambda x, y: x + y)
-    assert any(s in str(excinfo.value) for s in ("missing 1 required positional argument",
-                                                 "takes exactly 2 arguments"))
-
-
-def test_function_signatures(doc):
-    assert doc(m.test_callback3) == "test_callback3(arg0: Callable[[int], int]) -> str"
-    assert doc(m.test_callback4) == "test_callback4() -> Callable[[int], int]"
-
-
-def test_movable_object():
-    assert m.callback_with_movable(lambda _: None) is True
diff --git a/tmap/lib/pybind11/tests/test_chrono.cpp b/tmap/lib/pybind11/tests/test_chrono.cpp
deleted file mode 100644
index 195a93b..0000000
--- a/tmap/lib/pybind11/tests/test_chrono.cpp
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
-    tests/test_chrono.cpp -- test conversions to/from std::chrono types
-
-    Copyright (c) 2016 Trent Houliston <trent@houliston.me> and
-                       Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include <pybind11/chrono.h>
-
-TEST_SUBMODULE(chrono, m) {
-    using system_time = std::chrono::system_clock::time_point;
-    using steady_time = std::chrono::steady_clock::time_point;
-    // test_chrono_system_clock
-    // Return the current time off the wall clock
-    m.def("test_chrono1", []() { return std::chrono::system_clock::now(); });
-
-    // test_chrono_system_clock_roundtrip
-    // Round trip the passed in system clock time
-    m.def("test_chrono2", [](system_time t) { return t; });
-
-    // test_chrono_duration_roundtrip
-    // Round trip the passed in duration
-    m.def("test_chrono3", [](std::chrono::system_clock::duration d) { return d; });
-
-    // test_chrono_duration_subtraction_equivalence
-    // Difference between two passed in time_points
-    m.def("test_chrono4", [](system_time a, system_time b) { return a - b; });
-
-    // test_chrono_steady_clock
-    // Return the current time off the steady_clock
-    m.def("test_chrono5", []() { return std::chrono::steady_clock::now(); });
-
-    // test_chrono_steady_clock_roundtrip
-    // Round trip a steady clock timepoint
-    m.def("test_chrono6", [](steady_time t) { return t; });
-
-    // test_floating_point_duration
-    // Roundtrip a duration in microseconds from a float argument
-    m.def("test_chrono7", [](std::chrono::microseconds t) { return t; });
-    // Float durations (issue #719)
-    m.def("test_chrono_float_diff", [](std::chrono::duration<float> a, std::chrono::duration<float> b) {
-        return a - b; });
-}
diff --git a/tmap/lib/pybind11/tests/test_chrono.py b/tmap/lib/pybind11/tests/test_chrono.py
deleted file mode 100644
index 2b75bd1..0000000
--- a/tmap/lib/pybind11/tests/test_chrono.py
+++ /dev/null
@@ -1,101 +0,0 @@
-from pybind11_tests import chrono as m
-import datetime
-
-
-def test_chrono_system_clock():
-
-    # Get the time from both c++ and datetime
-    date1 = m.test_chrono1()
-    date2 = datetime.datetime.today()
-
-    # The returned value should be a datetime
-    assert isinstance(date1, datetime.datetime)
-
-    # The numbers should vary by a very small amount (time it took to execute)
-    diff = abs(date1 - date2)
-
-    # There should never be a days/seconds difference
-    assert diff.days == 0
-    assert diff.seconds == 0
-
-    # We test that no more than about 0.5 seconds passes here
-    # This makes sure that the dates created are very close to the same
-    # but if the testing system is incredibly overloaded this should still pass
-    assert diff.microseconds < 500000
-
-
-def test_chrono_system_clock_roundtrip():
-    date1 = datetime.datetime.today()
-
-    # Roundtrip the time
-    date2 = m.test_chrono2(date1)
-
-    # The returned value should be a datetime
-    assert isinstance(date2, datetime.datetime)
-
-    # They should be identical (no information lost on roundtrip)
-    diff = abs(date1 - date2)
-    assert diff.days == 0
-    assert diff.seconds == 0
-    assert diff.microseconds == 0
-
-
-def test_chrono_duration_roundtrip():
-
-    # Get the difference between two times (a timedelta)
-    date1 = datetime.datetime.today()
-    date2 = datetime.datetime.today()
-    diff = date2 - date1
-
-    # Make sure this is a timedelta
-    assert isinstance(diff, datetime.timedelta)
-
-    cpp_diff = m.test_chrono3(diff)
-
-    assert cpp_diff.days == diff.days
-    assert cpp_diff.seconds == diff.seconds
-    assert cpp_diff.microseconds == diff.microseconds
-
-
-def test_chrono_duration_subtraction_equivalence():
-
-    date1 = datetime.datetime.today()
-    date2 = datetime.datetime.today()
-
-    diff = date2 - date1
-    cpp_diff = m.test_chrono4(date2, date1)
-
-    assert cpp_diff.days == diff.days
-    assert cpp_diff.seconds == diff.seconds
-    assert cpp_diff.microseconds == diff.microseconds
-
-
-def test_chrono_steady_clock():
-    time1 = m.test_chrono5()
-    assert isinstance(time1, datetime.timedelta)
-
-
-def test_chrono_steady_clock_roundtrip():
-    time1 = datetime.timedelta(days=10, seconds=10, microseconds=100)
-    time2 = m.test_chrono6(time1)
-
-    assert isinstance(time2, datetime.timedelta)
-
-    # They should be identical (no information lost on roundtrip)
-    assert time1.days == time2.days
-    assert time1.seconds == time2.seconds
-    assert time1.microseconds == time2.microseconds
-
-
-def test_floating_point_duration():
-    # Test using a floating point number in seconds
-    time = m.test_chrono7(35.525123)
-
-    assert isinstance(time, datetime.timedelta)
-
-    assert time.seconds == 35
-    assert 525122 <= time.microseconds <= 525123
-
-    diff = m.test_chrono_float_diff(43.789012, 1.123456)
-    assert diff.seconds == 42
-    assert 665556 <= diff.microseconds <= 665557
diff --git a/tmap/lib/pybind11/tests/test_class.cpp b/tmap/lib/pybind11/tests/test_class.cpp
deleted file mode 100644
index 2221906..0000000
--- a/tmap/lib/pybind11/tests/test_class.cpp
+++ /dev/null
@@ -1,357 +0,0 @@
-/*
-    tests/test_class.cpp -- test py::class_ definitions and basic functionality
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "constructor_stats.h"
-#include "local_bindings.h"
-
-TEST_SUBMODULE(class_, m) {
-    // test_instance
-    struct NoConstructor {
-        static NoConstructor *new_instance() {
-            auto *ptr = new NoConstructor();
-            print_created(ptr, "via new_instance");
-            return ptr;
-        }
-        ~NoConstructor() { print_destroyed(this); }
-    };
-
-    py::class_<NoConstructor>(m, "NoConstructor")
-        .def_static("new_instance", &NoConstructor::new_instance, "Return an instance");
-
-    // test_inheritance
-    class Pet {
-    public:
-        Pet(const std::string &name, const std::string &species)
-            : m_name(name), m_species(species) {}
-        std::string name() const { return m_name; }
-        std::string species() const { return m_species; }
-    private:
-        std::string m_name;
-        std::string m_species;
-    };
-
-    class Dog : public Pet {
-    public:
-        Dog(const std::string &name) : Pet(name, "dog") {}
-        std::string bark() const { return "Woof!"; }
-    };
-
-    class Rabbit : public Pet {
-    public:
-        Rabbit(const std::string &name) : Pet(name, "parrot") {}
-    };
-
-    class Hamster : public Pet {
-    public:
-        Hamster(const std::string &name) : Pet(name, "rodent") {}
-    };
-
-    class Chimera : public Pet {
-        Chimera() : Pet("Kimmy", "chimera") {}
-    };
-
-    py::class_<Pet> pet_class(m, "Pet");
-    pet_class
-        .def(py::init<std::string, std::string>())
-        .def("name", &Pet::name)
-        .def("species", &Pet::species);
-
-    /* One way of declaring a subclass relationship: reference parent's class_ object */
-    py::class_<Dog>(m, "Dog", pet_class)
-        .def(py::init<std::string>());
-
-    /* Another way of declaring a subclass relationship: reference parent's C++ type */
-    py::class_<Rabbit, Pet>(m, "Rabbit")
-        .def(py::init<std::string>());
-
-    /* And another: list parent in class template arguments */
-    py::class_<Hamster, Pet>(m, "Hamster")
-        .def(py::init<std::string>());
-
-    /* Constructors are not inherited by default */
-    py::class_<Chimera, Pet>(m, "Chimera");
-
-    m.def("pet_name_species", [](const Pet &pet) { return pet.name() + " is a " + pet.species(); });
-    m.def("dog_bark", [](const Dog &dog) { return dog.bark(); });
-
-    // test_automatic_upcasting
-    struct BaseClass { virtual ~BaseClass() {} };
-    struct DerivedClass1 : BaseClass { };
-    struct DerivedClass2 : BaseClass { };
-
-    py::class_<BaseClass>(m, "BaseClass").def(py::init<>());
-    py::class_<DerivedClass1>(m, "DerivedClass1").def(py::init<>());
-    py::class_<DerivedClass2>(m, "DerivedClass2").def(py::init<>());
-
-    m.def("return_class_1", []() -> BaseClass* { return new DerivedClass1(); });
-    m.def("return_class_2", []() -> BaseClass* { return new DerivedClass2(); });
-    m.def("return_class_n", [](int n) -> BaseClass* {
-        if (n == 1) return new DerivedClass1();
-        if (n == 2) return new DerivedClass2();
-        return new BaseClass();
-    });
-    m.def("return_none", []() -> BaseClass* { return nullptr; });
-
-    // test_isinstance
-    m.def("check_instances", [](py::list l) {
-        return py::make_tuple(
-            py::isinstance<py::tuple>(l[0]),
-            py::isinstance<py::dict>(l[1]),
-            py::isinstance<Pet>(l[2]),
-            py::isinstance<Pet>(l[3]),
-            py::isinstance<Dog>(l[4]),
-            py::isinstance<Rabbit>(l[5]),
-            py::isinstance<UnregisteredType>(l[6])
-        );
-    });
-
-    // test_mismatched_holder
-    struct MismatchBase1 { };
-    struct MismatchDerived1 : MismatchBase1 { };
-
-    struct MismatchBase2 { };
-    struct MismatchDerived2 : MismatchBase2 { };
-
-    m.def("mismatched_holder_1", []() {
-        auto mod = py::module::import("__main__");
-        py::class_<MismatchBase1, std::shared_ptr<MismatchBase1>>(mod, "MismatchBase1");
-        py::class_<MismatchDerived1, MismatchBase1>(mod, "MismatchDerived1");
-    });
-    m.def("mismatched_holder_2", []() {
-        auto mod = py::module::import("__main__");
-        py::class_<MismatchBase2>(mod, "MismatchBase2");
-        py::class_<MismatchDerived2, std::shared_ptr<MismatchDerived2>,
-                   MismatchBase2>(mod, "MismatchDerived2");
-    });
-
-    // test_override_static
-    // #511: problem with inheritance + overwritten def_static
-    struct MyBase {
-        static std::unique_ptr<MyBase> make() {
-            return std::unique_ptr<MyBase>(new MyBase());
-        }
-    };
-
-    struct MyDerived : MyBase {
-        static std::unique_ptr<MyDerived> make() {
-            return std::unique_ptr<MyDerived>(new MyDerived());
-        }
-    };
-
-    py::class_<MyBase>(m, "MyBase")
-        .def_static("make", &MyBase::make);
-
-    py::class_<MyDerived, MyBase>(m, "MyDerived")
-        .def_static("make", &MyDerived::make)
-        .def_static("make2", &MyDerived::make);
-
-    // test_implicit_conversion_life_support
-    struct ConvertibleFromUserType {
-        int i;
-
-        ConvertibleFromUserType(UserType u) : i(u.value()) { }
-    };
-
-    py::class_<ConvertibleFromUserType>(m, "AcceptsUserType")
-        .def(py::init<UserType>());
-    py::implicitly_convertible<UserType, ConvertibleFromUserType>();
-
-    m.def("implicitly_convert_argument", [](const ConvertibleFromUserType &r) { return r.i; });
-    m.def("implicitly_convert_variable", [](py::object o) {
-        // `o` is `UserType` and `r` is a reference to a temporary created by implicit
-        // conversion. This is valid when called inside a bound function because the temp
-        // object is attached to the same life support system as the arguments.
-        const auto &r = o.cast<const ConvertibleFromUserType &>();
-        return r.i;
-    });
-    m.add_object("implicitly_convert_variable_fail", [&] {
-        auto f = [](PyObject *, PyObject *args) -> PyObject * {
-            auto o = py::reinterpret_borrow<py::tuple>(args)[0];
-            try { // It should fail here because there is no life support.
-                o.cast<const ConvertibleFromUserType &>();
-            } catch (const py::cast_error &e) {
-                return py::str(e.what()).release().ptr();
-            }
-            return py::str().release().ptr();
-        };
-
-        auto def = new PyMethodDef{"f", f, METH_VARARGS, nullptr};
-        return py::reinterpret_steal<py::object>(PyCFunction_NewEx(def, nullptr, m.ptr()));
-    }());
-
-    // test_operator_new_delete
-    struct HasOpNewDel {
-        std::uint64_t i;
-        static void *operator new(size_t s) { py::print("A new", s); return ::operator new(s); }
-        static void *operator new(size_t s, void *ptr) { py::print("A placement-new", s); return ptr; }
-        static void operator delete(void *p) { py::print("A delete"); return ::operator delete(p); }
-    };
-    struct HasOpNewDelSize {
-        std::uint32_t i;
-        static void *operator new(size_t s) { py::print("B new", s); return ::operator new(s); }
-        static void *operator new(size_t s, void *ptr) { py::print("B placement-new", s); return ptr; }
-        static void operator delete(void *p, size_t s) { py::print("B delete", s); return ::operator delete(p); }
-    };
-    struct AliasedHasOpNewDelSize {
-        std::uint64_t i;
-        static void *operator new(size_t s) { py::print("C new", s); return ::operator new(s); }
-        static void *operator new(size_t s, void *ptr) { py::print("C placement-new", s); return ptr; }
-        static void operator delete(void *p, size_t s) { py::print("C delete", s); return ::operator delete(p); }
-        virtual ~AliasedHasOpNewDelSize() = default;
-    };
-    struct PyAliasedHasOpNewDelSize : AliasedHasOpNewDelSize {
-        PyAliasedHasOpNewDelSize() = default;
-        PyAliasedHasOpNewDelSize(int) { }
-        std::uint64_t j;
-    };
-    struct HasOpNewDelBoth {
-        std::uint32_t i[8];
-        static void *operator new(size_t s) { py::print("D new", s); return ::operator new(s); }
-        static void *operator new(size_t s, void *ptr) { py::print("D placement-new", s); return ptr; }
-        static void operator delete(void *p) { py::print("D delete"); return ::operator delete(p); }
-        static void operator delete(void *p, size_t s) { py::print("D wrong delete", s); return ::operator delete(p); }
-    };
-    py::class_<HasOpNewDel>(m, "HasOpNewDel").def(py::init<>());
-    py::class_<HasOpNewDelSize>(m, "HasOpNewDelSize").def(py::init<>());
-    py::class_<HasOpNewDelBoth>(m, "HasOpNewDelBoth").def(py::init<>());
-    py::class_<AliasedHasOpNewDelSize, PyAliasedHasOpNewDelSize> aliased(m, "AliasedHasOpNewDelSize");
-    aliased.def(py::init<>());
-    aliased.attr("size_noalias") = py::int_(sizeof(AliasedHasOpNewDelSize));
-    aliased.attr("size_alias") = py::int_(sizeof(PyAliasedHasOpNewDelSize));
-
-    // This test is actually part of test_local_bindings (test_duplicate_local), but we need a
-    // definition in a different compilation unit within the same module:
-    bind_local<LocalExternal, 17>(m, "LocalExternal", py::module_local());
-
-    // test_bind_protected_functions
-    class ProtectedA {
-    protected:
-        int foo() const { return value; }
-
-    private:
-        int value = 42;
-    };
-
-    class PublicistA : public ProtectedA {
-    public:
-        using ProtectedA::foo;
-    };
-
-    py::class_<ProtectedA>(m, "ProtectedA")
-        .def(py::init<>())
-#if !defined(_MSC_VER) || _MSC_VER >= 1910
-        .def("foo", &PublicistA::foo);
-#else
-        .def("foo", static_cast<int (ProtectedA::*)() const>(&PublicistA::foo));
-#endif
-
-    class ProtectedB {
-    public:
-        virtual ~ProtectedB() = default;
-
-    protected:
-        virtual int foo() const { return value; }
-
-    private:
-        int value = 42;
-    };
-
-    class TrampolineB : public ProtectedB {
-    public:
-        int foo() const override { PYBIND11_OVERLOAD(int, ProtectedB, foo, ); }
-    };
-
-    class PublicistB : public ProtectedB {
-    public:
-        using ProtectedB::foo;
-    };
-
-    py::class_<ProtectedB, TrampolineB>(m, "ProtectedB")
-        .def(py::init<>())
-#if !defined(_MSC_VER) || _MSC_VER >= 1910
-        .def("foo", &PublicistB::foo);
-#else
-        .def("foo", static_cast<int (ProtectedB::*)() const>(&PublicistB::foo));
-#endif
-
-    // test_brace_initialization
-    struct BraceInitialization {
-        int field1;
-        std::string field2;
-    };
-
-    py::class_<BraceInitialization>(m, "BraceInitialization")
-        .def(py::init<int, const std::string &>())
-        .def_readwrite("field1", &BraceInitialization::field1)
-        .def_readwrite("field2", &BraceInitialization::field2);
-
-    // test_reentrant_implicit_conversion_failure
-    // #1035: issue with runaway reentrant implicit conversion
-    struct BogusImplicitConversion {
-        BogusImplicitConversion(const BogusImplicitConversion &) { }
-    };
-
-    py::class_<BogusImplicitConversion>(m, "BogusImplicitConversion")
-        .def(py::init<const BogusImplicitConversion &>());
-
-    py::implicitly_convertible<int, BogusImplicitConversion>();
-}
-
-template <int N> class BreaksBase { public: virtual ~BreaksBase() = default; };
-template <int N> class BreaksTramp : public BreaksBase<N> {};
-// These should all compile just fine:
-typedef py::class_<BreaksBase<1>, std::unique_ptr<BreaksBase<1>>, BreaksTramp<1>> DoesntBreak1;
-typedef py::class_<BreaksBase<2>, BreaksTramp<2>, std::unique_ptr<BreaksBase<2>>> DoesntBreak2;
-typedef py::class_<BreaksBase<3>, std::unique_ptr<BreaksBase<3>>> DoesntBreak3;
-typedef py::class_<BreaksBase<4>, BreaksTramp<4>> DoesntBreak4;
-typedef py::class_<BreaksBase<5>> DoesntBreak5;
-typedef py::class_<BreaksBase<6>, std::shared_ptr<BreaksBase<6>>, BreaksTramp<6>> DoesntBreak6;
-typedef py::class_<BreaksBase<7>, BreaksTramp<7>, std::shared_ptr<BreaksBase<7>>> DoesntBreak7;
-typedef py::class_<BreaksBase<8>, std::shared_ptr<BreaksBase<8>>> DoesntBreak8;
-#define CHECK_BASE(N) static_assert(std::is_same<typename DoesntBreak##N::type, BreaksBase<N>>::value, \
-        "DoesntBreak" #N " has wrong type!")
-CHECK_BASE(1); CHECK_BASE(2); CHECK_BASE(3); CHECK_BASE(4); CHECK_BASE(5); CHECK_BASE(6); CHECK_BASE(7); CHECK_BASE(8);
-#define CHECK_ALIAS(N) static_assert(DoesntBreak##N::has_alias && std::is_same<typename DoesntBreak##N::type_alias, BreaksTramp<N>>::value, \
-        "DoesntBreak" #N " has wrong type_alias!")
-#define CHECK_NOALIAS(N) static_assert(!DoesntBreak##N::has_alias && std::is_void<typename DoesntBreak##N::type_alias>::value, \
-        "DoesntBreak" #N " has type alias, but shouldn't!")
-CHECK_ALIAS(1); CHECK_ALIAS(2); CHECK_NOALIAS(3); CHECK_ALIAS(4); CHECK_NOALIAS(5); CHECK_ALIAS(6); CHECK_ALIAS(7); CHECK_NOALIAS(8);
-#define CHECK_HOLDER(N, TYPE) static_assert(std::is_same<typename DoesntBreak##N::holder_type, std::TYPE##_ptr<BreaksBase<N>>>::value, \
-        "DoesntBreak" #N " has wrong holder_type!")
-CHECK_HOLDER(1, unique); CHECK_HOLDER(2, unique); CHECK_HOLDER(3, unique); CHECK_HOLDER(4, unique); CHECK_HOLDER(5, unique);
-CHECK_HOLDER(6, shared); CHECK_HOLDER(7, shared); CHECK_HOLDER(8, shared);
-
-// There's no nice way to test that these fail because they fail to compile; leave them here,
-// though, so that they can be manually tested by uncommenting them (and seeing that compilation
-// failures occurs).
-
-// We have to actually look into the type: the typedef alone isn't enough to instantiate the type:
-#define CHECK_BROKEN(N) static_assert(std::is_same<typename Breaks##N::type, BreaksBase<-N>>::value, \
-        "Breaks1 has wrong type!");
-
-//// Two holder classes:
-//typedef py::class_<BreaksBase<-1>, std::unique_ptr<BreaksBase<-1>>, std::unique_ptr<BreaksBase<-1>>> Breaks1;
-//CHECK_BROKEN(1);
-//// Two aliases:
-//typedef py::class_<BreaksBase<-2>, BreaksTramp<-2>, BreaksTramp<-2>> Breaks2;
-//CHECK_BROKEN(2);
-//// Holder + 2 aliases
-//typedef py::class_<BreaksBase<-3>, std::unique_ptr<BreaksBase<-3>>, BreaksTramp<-3>, BreaksTramp<-3>> Breaks3;
-//CHECK_BROKEN(3);
-//// Alias + 2 holders
-//typedef py::class_<BreaksBase<-4>, std::unique_ptr<BreaksBase<-4>>, BreaksTramp<-4>, std::shared_ptr<BreaksBase<-4>>> Breaks4;
-//CHECK_BROKEN(4);
-//// Invalid option (not a subclass or holder)
-//typedef py::class_<BreaksBase<-5>, BreaksTramp<-4>> Breaks5;
-//CHECK_BROKEN(5);
-//// Invalid option: multiple inheritance not supported:
-//template <> struct BreaksBase<-8> : BreaksBase<-6>, BreaksBase<-7> {};
-//typedef py::class_<BreaksBase<-8>, BreaksBase<-6>, BreaksBase<-7>> Breaks8;
-//CHECK_BROKEN(8);
diff --git a/tmap/lib/pybind11/tests/test_class.py b/tmap/lib/pybind11/tests/test_class.py
deleted file mode 100644
index 412d679..0000000
--- a/tmap/lib/pybind11/tests/test_class.py
+++ /dev/null
@@ -1,235 +0,0 @@
-import pytest
-
-from pybind11_tests import class_ as m
-from pybind11_tests import UserType, ConstructorStats
-
-
-def test_repr():
-    # In Python 3.3+, repr() accesses __qualname__
-    assert "pybind11_type" in repr(type(UserType))
-    assert "UserType" in repr(UserType)
-
-
-def test_instance(msg):
-    with pytest.raises(TypeError) as excinfo:
-        m.NoConstructor()
-    assert msg(excinfo.value) == "m.class_.NoConstructor: No constructor defined!"
-
-    instance = m.NoConstructor.new_instance()
-
-    cstats = ConstructorStats.get(m.NoConstructor)
-    assert cstats.alive() == 1
-    del instance
-    assert cstats.alive() == 0
-
-
-def test_docstrings(doc):
-    assert doc(UserType) == "A `py::class_` type for testing"
-    assert UserType.__name__ == "UserType"
-    assert UserType.__module__ == "pybind11_tests"
-    assert UserType.get_value.__name__ == "get_value"
-    assert UserType.get_value.__module__ == "pybind11_tests"
-
-    assert doc(UserType.get_value) == """
-        get_value(self: m.UserType) -> int
-
-        Get value using a method
-    """
-    assert doc(UserType.value) == "Get/set value using a property"
-
-    assert doc(m.NoConstructor.new_instance) == """
-        new_instance() -> m.class_.NoConstructor
-
-        Return an instance
-    """
-
-
-def test_inheritance(msg):
-    roger = m.Rabbit('Rabbit')
-    assert roger.name() + " is a " + roger.species() == "Rabbit is a parrot"
-    assert m.pet_name_species(roger) == "Rabbit is a parrot"
-
-    polly = m.Pet('Polly', 'parrot')
-    assert polly.name() + " is a " + polly.species() == "Polly is a parrot"
-    assert m.pet_name_species(polly) == "Polly is a parrot"
-
-    molly = m.Dog('Molly')
-    assert molly.name() + " is a " + molly.species() == "Molly is a dog"
-    assert m.pet_name_species(molly) == "Molly is a dog"
-
-    fred = m.Hamster('Fred')
-    assert fred.name() + " is a " + fred.species() == "Fred is a rodent"
-
-    assert m.dog_bark(molly) == "Woof!"
-
-    with pytest.raises(TypeError) as excinfo:
-        m.dog_bark(polly)
-    assert msg(excinfo.value) == """
-        dog_bark(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: m.class_.Dog) -> str
-
-        Invoked with: <m.class_.Pet object at 0>
-    """
-
-    with pytest.raises(TypeError) as excinfo:
-        m.Chimera("lion", "goat")
-    assert "No constructor defined!" in str(excinfo.value)
-
-
-def test_automatic_upcasting():
-    assert type(m.return_class_1()).__name__ == "DerivedClass1"
-    assert type(m.return_class_2()).__name__ == "DerivedClass2"
-    assert type(m.return_none()).__name__ == "NoneType"
-    # Repeat these a few times in a random order to ensure no invalid caching is applied
-    assert type(m.return_class_n(1)).__name__ == "DerivedClass1"
-    assert type(m.return_class_n(2)).__name__ == "DerivedClass2"
-    assert type(m.return_class_n(0)).__name__ == "BaseClass"
-    assert type(m.return_class_n(2)).__name__ == "DerivedClass2"
-    assert type(m.return_class_n(2)).__name__ == "DerivedClass2"
-    assert type(m.return_class_n(0)).__name__ == "BaseClass"
-    assert type(m.return_class_n(1)).__name__ == "DerivedClass1"
-
-
-def test_isinstance():
-    objects = [tuple(), dict(), m.Pet("Polly", "parrot")] + [m.Dog("Molly")] * 4
-    expected = (True, True, True, True, True, False, False)
-    assert m.check_instances(objects) == expected
-
-
-def test_mismatched_holder():
-    import re
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.mismatched_holder_1()
-    assert re.match('generic_type: type ".*MismatchDerived1" does not have a non-default '
-                    'holder type while its base ".*MismatchBase1" does', str(excinfo.value))
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.mismatched_holder_2()
-    assert re.match('generic_type: type ".*MismatchDerived2" has a non-default holder type '
-                    'while its base ".*MismatchBase2" does not', str(excinfo.value))
-
-
-def test_override_static():
-    """#511: problem with inheritance + overwritten def_static"""
-    b = m.MyBase.make()
-    d1 = m.MyDerived.make2()
-    d2 = m.MyDerived.make()
-
-    assert isinstance(b, m.MyBase)
-    assert isinstance(d1, m.MyDerived)
-    assert isinstance(d2, m.MyDerived)
-
-
-def test_implicit_conversion_life_support():
-    """Ensure the lifetime of temporary objects created for implicit conversions"""
-    assert m.implicitly_convert_argument(UserType(5)) == 5
-    assert m.implicitly_convert_variable(UserType(5)) == 5
-
-    assert "outside a bound function" in m.implicitly_convert_variable_fail(UserType(5))
-
-
-def test_operator_new_delete(capture):
-    """Tests that class-specific operator new/delete functions are invoked"""
-
-    class SubAliased(m.AliasedHasOpNewDelSize):
-        pass
-
-    with capture:
-        a = m.HasOpNewDel()
-        b = m.HasOpNewDelSize()
-        d = m.HasOpNewDelBoth()
-    assert capture == """
-        A new 8
-        B new 4
-        D new 32
-    """
-    sz_alias = str(m.AliasedHasOpNewDelSize.size_alias)
-    sz_noalias = str(m.AliasedHasOpNewDelSize.size_noalias)
-    with capture:
-        c = m.AliasedHasOpNewDelSize()
-        c2 = SubAliased()
-    assert capture == (
-        "C new " + sz_noalias + "\n" +
-        "C new " + sz_alias + "\n"
-    )
-
-    with capture:
-        del a
-        pytest.gc_collect()
-        del b
-        pytest.gc_collect()
-        del d
-        pytest.gc_collect()
-    assert capture == """
-        A delete
-        B delete 4
-        D delete
-    """
-
-    with capture:
-        del c
-        pytest.gc_collect()
-        del c2
-        pytest.gc_collect()
-    assert capture == (
-        "C delete " + sz_noalias + "\n" +
-        "C delete " + sz_alias + "\n"
-    )
-
-
-def test_bind_protected_functions():
-    """Expose protected member functions to Python using a helper class"""
-    a = m.ProtectedA()
-    assert a.foo() == 42
-
-    b = m.ProtectedB()
-    assert b.foo() == 42
-
-    class C(m.ProtectedB):
-        def __init__(self):
-            m.ProtectedB.__init__(self)
-
-        def foo(self):
-            return 0
-
-    c = C()
-    assert c.foo() == 0
-
-
-def test_brace_initialization():
-    """ Tests that simple POD classes can be constructed using C++11 brace initialization """
-    a = m.BraceInitialization(123, "test")
-    assert a.field1 == 123
-    assert a.field2 == "test"
-
-
-@pytest.unsupported_on_pypy
-def test_class_refcount():
-    """Instances must correctly increase/decrease the reference count of their types (#1029)"""
-    from sys import getrefcount
-
-    class PyDog(m.Dog):
-        pass
-
-    for cls in m.Dog, PyDog:
-        refcount_1 = getrefcount(cls)
-        molly = [cls("Molly") for _ in range(10)]
-        refcount_2 = getrefcount(cls)
-
-        del molly
-        pytest.gc_collect()
-        refcount_3 = getrefcount(cls)
-
-        assert refcount_1 == refcount_3
-        assert refcount_2 > refcount_1
-
-
-def test_reentrant_implicit_conversion_failure(msg):
-    # ensure that there is no runaway reentrant implicit conversion (#1035)
-    with pytest.raises(TypeError) as excinfo:
-        m.BogusImplicitConversion(0)
-    assert msg(excinfo.value) == '''__init__(): incompatible constructor arguments. The following argument types are supported:
-    1. m.class_.BogusImplicitConversion(arg0: m.class_.BogusImplicitConversion)
-
-Invoked with: 0'''
diff --git a/tmap/lib/pybind11/tests/test_cmake_build/CMakeLists.txt b/tmap/lib/pybind11/tests/test_cmake_build/CMakeLists.txt
deleted file mode 100644
index c9b5fcb..0000000
--- a/tmap/lib/pybind11/tests/test_cmake_build/CMakeLists.txt
+++ /dev/null
@@ -1,58 +0,0 @@
-add_custom_target(test_cmake_build)
-
-if(CMAKE_VERSION VERSION_LESS 3.1)
-  # 3.0 needed for interface library for subdirectory_target/installed_target
-  # 3.1 needed for cmake -E env for testing
-  return()
-endif()
-
-include(CMakeParseArguments)
-function(pybind11_add_build_test name)
-  cmake_parse_arguments(ARG "INSTALL" "" "" ${ARGN})
-
-  set(build_options "-DCMAKE_PREFIX_PATH=${PROJECT_BINARY_DIR}/mock_install"
-                    "-DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}"
-                    "-DPYTHON_EXECUTABLE:FILEPATH=${PYTHON_EXECUTABLE}"
-                    "-DPYBIND11_CPP_STANDARD=${PYBIND11_CPP_STANDARD}")
-  if(NOT ARG_INSTALL)
-    list(APPEND build_options "-DPYBIND11_PROJECT_DIR=${PROJECT_SOURCE_DIR}")
-  endif()
-
-  add_custom_target(test_${name} ${CMAKE_CTEST_COMMAND}
-    --quiet --output-log ${name}.log
-    --build-and-test "${CMAKE_CURRENT_SOURCE_DIR}/${name}"
-                     "${CMAKE_CURRENT_BINARY_DIR}/${name}"
-    --build-config Release
-    --build-noclean
-    --build-generator ${CMAKE_GENERATOR}
-    $<$<BOOL:${CMAKE_GENERATOR_PLATFORM}>:--build-generator-platform> ${CMAKE_GENERATOR_PLATFORM}
-    --build-makeprogram ${CMAKE_MAKE_PROGRAM}
-    --build-target check
-    --build-options ${build_options}
-  )
-  if(ARG_INSTALL)
-    add_dependencies(test_${name} mock_install)
-  endif()
-  add_dependencies(test_cmake_build test_${name})
-endfunction()
-
-pybind11_add_build_test(subdirectory_function)
-pybind11_add_build_test(subdirectory_target)
-if(NOT ${PYTHON_MODULE_EXTENSION} MATCHES "pypy")
-  pybind11_add_build_test(subdirectory_embed)
-endif()
-
-if(PYBIND11_INSTALL)
-  add_custom_target(mock_install ${CMAKE_COMMAND}
-    "-DCMAKE_INSTALL_PREFIX=${PROJECT_BINARY_DIR}/mock_install"
-    -P "${PROJECT_BINARY_DIR}/cmake_install.cmake"
-  )
-
-  pybind11_add_build_test(installed_function INSTALL)
-  pybind11_add_build_test(installed_target INSTALL)
-  if(NOT ${PYTHON_MODULE_EXTENSION} MATCHES "pypy")
-    pybind11_add_build_test(installed_embed INSTALL)
-  endif()
-endif()
-
-add_dependencies(check test_cmake_build)
diff --git a/tmap/lib/pybind11/tests/test_cmake_build/embed.cpp b/tmap/lib/pybind11/tests/test_cmake_build/embed.cpp
deleted file mode 100644
index b9581d2..0000000
--- a/tmap/lib/pybind11/tests/test_cmake_build/embed.cpp
+++ /dev/null
@@ -1,21 +0,0 @@
-#include <pybind11/embed.h>
-namespace py = pybind11;
-
-PYBIND11_EMBEDDED_MODULE(test_cmake_build, m) {
-    m.def("add", [](int i, int j) { return i + j; });
-}
-
-int main(int argc, char *argv[]) {
-    if (argc != 2)
-        throw std::runtime_error("Expected test.py file as the first argument");
-    auto test_py_file = argv[1];
-
-    py::scoped_interpreter guard{};
-
-    auto m = py::module::import("test_cmake_build");
-    if (m.attr("add")(1, 2).cast<int>() != 3)
-        throw std::runtime_error("embed.cpp failed");
-
-    py::module::import("sys").attr("argv") = py::make_tuple("test.py", "embed.cpp");
-    py::eval_file(test_py_file, py::globals());
-}
diff --git a/tmap/lib/pybind11/tests/test_cmake_build/installed_embed/CMakeLists.txt b/tmap/lib/pybind11/tests/test_cmake_build/installed_embed/CMakeLists.txt
deleted file mode 100644
index f7fc09c..0000000
--- a/tmap/lib/pybind11/tests/test_cmake_build/installed_embed/CMakeLists.txt
+++ /dev/null
@@ -1,15 +0,0 @@
-cmake_minimum_required(VERSION 3.0)
-project(test_installed_embed CXX)
-
-set(CMAKE_MODULE_PATH "")
-find_package(pybind11 CONFIG REQUIRED)
-message(STATUS "Found pybind11 v${pybind11_VERSION}: ${pybind11_INCLUDE_DIRS}")
-
-add_executable(test_cmake_build ../embed.cpp)
-target_link_libraries(test_cmake_build PRIVATE pybind11::embed)
-
-# Do not treat includes from IMPORTED target as SYSTEM (Python headers in pybind11::embed).
-# This may be needed to resolve header conflicts, e.g. between Python release and debug headers.
-set_target_properties(test_cmake_build PROPERTIES NO_SYSTEM_FROM_IMPORTED ON)
-
-add_custom_target(check $<TARGET_FILE:test_cmake_build> ${PROJECT_SOURCE_DIR}/../test.py)
diff --git a/tmap/lib/pybind11/tests/test_cmake_build/installed_function/CMakeLists.txt b/tmap/lib/pybind11/tests/test_cmake_build/installed_function/CMakeLists.txt
deleted file mode 100644
index e0c20a8..0000000
--- a/tmap/lib/pybind11/tests/test_cmake_build/installed_function/CMakeLists.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-cmake_minimum_required(VERSION 2.8.12)
-project(test_installed_module CXX)
-
-set(CMAKE_MODULE_PATH "")
-
-find_package(pybind11 CONFIG REQUIRED)
-message(STATUS "Found pybind11 v${pybind11_VERSION}: ${pybind11_INCLUDE_DIRS}")
-
-pybind11_add_module(test_cmake_build SHARED NO_EXTRAS ../main.cpp)
-
-add_custom_target(check ${CMAKE_COMMAND} -E env PYTHONPATH=$<TARGET_FILE_DIR:test_cmake_build>
-                  ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/../test.py ${PROJECT_NAME})
diff --git a/tmap/lib/pybind11/tests/test_cmake_build/installed_target/CMakeLists.txt b/tmap/lib/pybind11/tests/test_cmake_build/installed_target/CMakeLists.txt
deleted file mode 100644
index cd3ae6f..0000000
--- a/tmap/lib/pybind11/tests/test_cmake_build/installed_target/CMakeLists.txt
+++ /dev/null
@@ -1,22 +0,0 @@
-cmake_minimum_required(VERSION 3.0)
-project(test_installed_target CXX)
-
-set(CMAKE_MODULE_PATH "")
-
-find_package(pybind11 CONFIG REQUIRED)
-message(STATUS "Found pybind11 v${pybind11_VERSION}: ${pybind11_INCLUDE_DIRS}")
-
-add_library(test_cmake_build MODULE ../main.cpp)
-
-target_link_libraries(test_cmake_build PRIVATE pybind11::module)
-
-# make sure result is, for example, test_installed_target.so, not libtest_installed_target.dylib
-set_target_properties(test_cmake_build PROPERTIES PREFIX "${PYTHON_MODULE_PREFIX}"
-                                                  SUFFIX "${PYTHON_MODULE_EXTENSION}")
-
-# Do not treat includes from IMPORTED target as SYSTEM (Python headers in pybind11::module).
-# This may be needed to resolve header conflicts, e.g. between Python release and debug headers.
-set_target_properties(test_cmake_build PROPERTIES NO_SYSTEM_FROM_IMPORTED ON)
-
-add_custom_target(check ${CMAKE_COMMAND} -E env PYTHONPATH=$<TARGET_FILE_DIR:test_cmake_build>
-                  ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/../test.py ${PROJECT_NAME})
diff --git a/tmap/lib/pybind11/tests/test_cmake_build/main.cpp b/tmap/lib/pybind11/tests/test_cmake_build/main.cpp
deleted file mode 100644
index e30f2c4..0000000
--- a/tmap/lib/pybind11/tests/test_cmake_build/main.cpp
+++ /dev/null
@@ -1,6 +0,0 @@
-#include <pybind11/pybind11.h>
-namespace py = pybind11;
-
-PYBIND11_MODULE(test_cmake_build, m) {
-    m.def("add", [](int i, int j) { return i + j; });
-}
diff --git a/tmap/lib/pybind11/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt b/tmap/lib/pybind11/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt
deleted file mode 100644
index 88ba60d..0000000
--- a/tmap/lib/pybind11/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt
+++ /dev/null
@@ -1,25 +0,0 @@
-cmake_minimum_required(VERSION 3.0)
-project(test_subdirectory_embed CXX)
-
-set(PYBIND11_INSTALL ON CACHE BOOL "")
-set(PYBIND11_EXPORT_NAME test_export)
-
-add_subdirectory(${PYBIND11_PROJECT_DIR} pybind11)
-
-# Test basic target functionality
-add_executable(test_cmake_build ../embed.cpp)
-target_link_libraries(test_cmake_build PRIVATE pybind11::embed)
-
-add_custom_target(check $<TARGET_FILE:test_cmake_build> ${PROJECT_SOURCE_DIR}/../test.py)
-
-# Test custom export group -- PYBIND11_EXPORT_NAME
-add_library(test_embed_lib ../embed.cpp)
-target_link_libraries(test_embed_lib PRIVATE pybind11::embed)
-
-install(TARGETS test_embed_lib
-        EXPORT  test_export
-        ARCHIVE DESTINATION bin
-        LIBRARY DESTINATION lib
-        RUNTIME DESTINATION lib)
-install(EXPORT      test_export
-        DESTINATION lib/cmake/test_export/test_export-Targets.cmake)
diff --git a/tmap/lib/pybind11/tests/test_cmake_build/subdirectory_function/CMakeLists.txt b/tmap/lib/pybind11/tests/test_cmake_build/subdirectory_function/CMakeLists.txt
deleted file mode 100644
index 278007a..0000000
--- a/tmap/lib/pybind11/tests/test_cmake_build/subdirectory_function/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-cmake_minimum_required(VERSION 2.8.12)
-project(test_subdirectory_module CXX)
-
-add_subdirectory(${PYBIND11_PROJECT_DIR} pybind11)
-pybind11_add_module(test_cmake_build THIN_LTO ../main.cpp)
-
-add_custom_target(check ${CMAKE_COMMAND} -E env PYTHONPATH=$<TARGET_FILE_DIR:test_cmake_build>
-                  ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/../test.py ${PROJECT_NAME})
diff --git a/tmap/lib/pybind11/tests/test_cmake_build/subdirectory_target/CMakeLists.txt b/tmap/lib/pybind11/tests/test_cmake_build/subdirectory_target/CMakeLists.txt
deleted file mode 100644
index 6b142d6..0000000
--- a/tmap/lib/pybind11/tests/test_cmake_build/subdirectory_target/CMakeLists.txt
+++ /dev/null
@@ -1,15 +0,0 @@
-cmake_minimum_required(VERSION 3.0)
-project(test_subdirectory_target CXX)
-
-add_subdirectory(${PYBIND11_PROJECT_DIR} pybind11)
-
-add_library(test_cmake_build MODULE ../main.cpp)
-
-target_link_libraries(test_cmake_build PRIVATE pybind11::module)
-
-# make sure result is, for example, test_installed_target.so, not libtest_installed_target.dylib
-set_target_properties(test_cmake_build PROPERTIES PREFIX "${PYTHON_MODULE_PREFIX}"
-                                                  SUFFIX "${PYTHON_MODULE_EXTENSION}")
-
-add_custom_target(check ${CMAKE_COMMAND} -E env PYTHONPATH=$<TARGET_FILE_DIR:test_cmake_build>
-                  ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/../test.py ${PROJECT_NAME})
diff --git a/tmap/lib/pybind11/tests/test_cmake_build/test.py b/tmap/lib/pybind11/tests/test_cmake_build/test.py
deleted file mode 100644
index 1467a61..0000000
--- a/tmap/lib/pybind11/tests/test_cmake_build/test.py
+++ /dev/null
@@ -1,5 +0,0 @@
-import sys
-import test_cmake_build
-
-assert test_cmake_build.add(1, 2) == 3
-print("{} imports, runs, and adds: 1 + 2 = 3".format(sys.argv[1]))
diff --git a/tmap/lib/pybind11/tests/test_constants_and_functions.cpp b/tmap/lib/pybind11/tests/test_constants_and_functions.cpp
deleted file mode 100644
index 8c9ef7f..0000000
--- a/tmap/lib/pybind11/tests/test_constants_and_functions.cpp
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
-    tests/test_constants_and_functions.cpp -- global constants and functions, enumerations, raw byte strings
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-
-enum MyEnum { EFirstEntry = 1, ESecondEntry };
-
-std::string test_function1() {
-    return "test_function()";
-}
-
-std::string test_function2(MyEnum k) {
-    return "test_function(enum=" + std::to_string(k) + ")";
-}
-
-std::string test_function3(int i) {
-    return "test_function(" + std::to_string(i) + ")";
-}
-
-py::str test_function4()           { return "test_function()"; }
-py::str test_function4(char *)     { return "test_function(char *)"; }
-py::str test_function4(int, float) { return "test_function(int, float)"; }
-py::str test_function4(float, int) { return "test_function(float, int)"; }
-
-py::bytes return_bytes() {
-    const char *data = "\x01\x00\x02\x00";
-    return std::string(data, 4);
-}
-
-std::string print_bytes(py::bytes bytes) {
-    std::string ret = "bytes[";
-    const auto value = static_cast<std::string>(bytes);
-    for (size_t i = 0; i < value.length(); ++i) {
-        ret += std::to_string(static_cast<int>(value[i])) + " ";
-    }
-    ret.back() = ']';
-    return ret;
-}
-
-// Test that we properly handle C++17 exception specifiers (which are part of the function signature
-// in C++17).  These should all still work before C++17, but don't affect the function signature.
-namespace test_exc_sp {
-int f1(int x) noexcept { return x+1; }
-int f2(int x) noexcept(true) { return x+2; }
-int f3(int x) noexcept(false) { return x+3; }
-int f4(int x) throw() { return x+4; } // Deprecated equivalent to noexcept(true)
-struct C {
-    int m1(int x) noexcept { return x-1; }
-    int m2(int x) const noexcept { return x-2; }
-    int m3(int x) noexcept(true) { return x-3; }
-    int m4(int x) const noexcept(true) { return x-4; }
-    int m5(int x) noexcept(false) { return x-5; }
-    int m6(int x) const noexcept(false) { return x-6; }
-    int m7(int x) throw() { return x-7; }
-    int m8(int x) const throw() { return x-8; }
-};
-}
-
-
-TEST_SUBMODULE(constants_and_functions, m) {
-    // test_constants
-    m.attr("some_constant") = py::int_(14);
-
-    // test_function_overloading
-    m.def("test_function", &test_function1);
-    m.def("test_function", &test_function2);
-    m.def("test_function", &test_function3);
-
-#if defined(PYBIND11_OVERLOAD_CAST)
-    m.def("test_function", py::overload_cast<>(&test_function4));
-    m.def("test_function", py::overload_cast<char *>(&test_function4));
-    m.def("test_function", py::overload_cast<int, float>(&test_function4));
-    m.def("test_function", py::overload_cast<float, int>(&test_function4));
-#else
-    m.def("test_function", static_cast<py::str (*)()>(&test_function4));
-    m.def("test_function", static_cast<py::str (*)(char *)>(&test_function4));
-    m.def("test_function", static_cast<py::str (*)(int, float)>(&test_function4));
-    m.def("test_function", static_cast<py::str (*)(float, int)>(&test_function4));
-#endif
-
-    py::enum_<MyEnum>(m, "MyEnum")
-        .value("EFirstEntry", EFirstEntry)
-        .value("ESecondEntry", ESecondEntry)
-        .export_values();
-
-    // test_bytes
-    m.def("return_bytes", &return_bytes);
-    m.def("print_bytes", &print_bytes);
-
-    // test_exception_specifiers
-    using namespace test_exc_sp;
-    py::class_<C>(m, "C")
-        .def(py::init<>())
-        .def("m1", &C::m1)
-        .def("m2", &C::m2)
-        .def("m3", &C::m3)
-        .def("m4", &C::m4)
-        .def("m5", &C::m5)
-        .def("m6", &C::m6)
-        .def("m7", &C::m7)
-        .def("m8", &C::m8)
-        ;
-    m.def("f1", f1);
-    m.def("f2", f2);
-    m.def("f3", f3);
-    m.def("f4", f4);
-}
diff --git a/tmap/lib/pybind11/tests/test_constants_and_functions.py b/tmap/lib/pybind11/tests/test_constants_and_functions.py
deleted file mode 100644
index 472682d..0000000
--- a/tmap/lib/pybind11/tests/test_constants_and_functions.py
+++ /dev/null
@@ -1,39 +0,0 @@
-from pybind11_tests import constants_and_functions as m
-
-
-def test_constants():
-    assert m.some_constant == 14
-
-
-def test_function_overloading():
-    assert m.test_function() == "test_function()"
-    assert m.test_function(7) == "test_function(7)"
-    assert m.test_function(m.MyEnum.EFirstEntry) == "test_function(enum=1)"
-    assert m.test_function(m.MyEnum.ESecondEntry) == "test_function(enum=2)"
-
-    assert m.test_function() == "test_function()"
-    assert m.test_function("abcd") == "test_function(char *)"
-    assert m.test_function(1, 1.0) == "test_function(int, float)"
-    assert m.test_function(1, 1.0) == "test_function(int, float)"
-    assert m.test_function(2.0, 2) == "test_function(float, int)"
-
-
-def test_bytes():
-    assert m.print_bytes(m.return_bytes()) == "bytes[1 0 2 0]"
-
-
-def test_exception_specifiers():
-    c = m.C()
-    assert c.m1(2) == 1
-    assert c.m2(3) == 1
-    assert c.m3(5) == 2
-    assert c.m4(7) == 3
-    assert c.m5(10) == 5
-    assert c.m6(14) == 8
-    assert c.m7(20) == 13
-    assert c.m8(29) == 21
-
-    assert m.f1(33) == 34
-    assert m.f2(53) == 55
-    assert m.f3(86) == 89
-    assert m.f4(140) == 144
diff --git a/tmap/lib/pybind11/tests/test_copy_move.cpp b/tmap/lib/pybind11/tests/test_copy_move.cpp
deleted file mode 100644
index 94113e3..0000000
--- a/tmap/lib/pybind11/tests/test_copy_move.cpp
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
-    tests/test_copy_move_policies.cpp -- 'copy' and 'move' return value policies
-                                         and related tests
-
-    Copyright (c) 2016 Ben North <ben@redfrontdoor.org>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "constructor_stats.h"
-#include <pybind11/stl.h>
-
-template <typename derived>
-struct empty {
-    static const derived& get_one() { return instance_; }
-    static derived instance_;
-};
-
-struct lacking_copy_ctor : public empty<lacking_copy_ctor> {
-    lacking_copy_ctor() {}
-    lacking_copy_ctor(const lacking_copy_ctor& other) = delete;
-};
-
-template <> lacking_copy_ctor empty<lacking_copy_ctor>::instance_ = {};
-
-struct lacking_move_ctor : public empty<lacking_move_ctor> {
-    lacking_move_ctor() {}
-    lacking_move_ctor(const lacking_move_ctor& other) = delete;
-    lacking_move_ctor(lacking_move_ctor&& other) = delete;
-};
-
-template <> lacking_move_ctor empty<lacking_move_ctor>::instance_ = {};
-
-/* Custom type caster move/copy test classes */
-class MoveOnlyInt {
-public:
-    MoveOnlyInt() { print_default_created(this); }
-    MoveOnlyInt(int v) : value{std::move(v)} { print_created(this, value); }
-    MoveOnlyInt(MoveOnlyInt &&m) { print_move_created(this, m.value); std::swap(value, m.value); }
-    MoveOnlyInt &operator=(MoveOnlyInt &&m) { print_move_assigned(this, m.value); std::swap(value, m.value); return *this; }
-    MoveOnlyInt(const MoveOnlyInt &) = delete;
-    MoveOnlyInt &operator=(const MoveOnlyInt &) = delete;
-    ~MoveOnlyInt() { print_destroyed(this); }
-
-    int value;
-};
-class MoveOrCopyInt {
-public:
-    MoveOrCopyInt() { print_default_created(this); }
-    MoveOrCopyInt(int v) : value{std::move(v)} { print_created(this, value); }
-    MoveOrCopyInt(MoveOrCopyInt &&m) { print_move_created(this, m.value); std::swap(value, m.value); }
-    MoveOrCopyInt &operator=(MoveOrCopyInt &&m) { print_move_assigned(this, m.value); std::swap(value, m.value); return *this; }
-    MoveOrCopyInt(const MoveOrCopyInt &c) { print_copy_created(this, c.value); value = c.value; }
-    MoveOrCopyInt &operator=(const MoveOrCopyInt &c) { print_copy_assigned(this, c.value); value = c.value; return *this; }
-    ~MoveOrCopyInt() { print_destroyed(this); }
-
-    int value;
-};
-class CopyOnlyInt {
-public:
-    CopyOnlyInt() { print_default_created(this); }
-    CopyOnlyInt(int v) : value{std::move(v)} { print_created(this, value); }
-    CopyOnlyInt(const CopyOnlyInt &c) { print_copy_created(this, c.value); value = c.value; }
-    CopyOnlyInt &operator=(const CopyOnlyInt &c) { print_copy_assigned(this, c.value); value = c.value; return *this; }
-    ~CopyOnlyInt() { print_destroyed(this); }
-
-    int value;
-};
-NAMESPACE_BEGIN(pybind11)
-NAMESPACE_BEGIN(detail)
-template <> struct type_caster<MoveOnlyInt> {
-    PYBIND11_TYPE_CASTER(MoveOnlyInt, _("MoveOnlyInt"));
-    bool load(handle src, bool) { value = MoveOnlyInt(src.cast<int>()); return true; }
-    static handle cast(const MoveOnlyInt &m, return_value_policy r, handle p) { return pybind11::cast(m.value, r, p); }
-};
-
-template <> struct type_caster<MoveOrCopyInt> {
-    PYBIND11_TYPE_CASTER(MoveOrCopyInt, _("MoveOrCopyInt"));
-    bool load(handle src, bool) { value = MoveOrCopyInt(src.cast<int>()); return true; }
-    static handle cast(const MoveOrCopyInt &m, return_value_policy r, handle p) { return pybind11::cast(m.value, r, p); }
-};
-
-template <> struct type_caster<CopyOnlyInt> {
-protected:
-    CopyOnlyInt value;
-public:
-    static PYBIND11_DESCR name() { return _("CopyOnlyInt"); }
-    bool load(handle src, bool) { value = CopyOnlyInt(src.cast<int>()); return true; }
-    static handle cast(const CopyOnlyInt &m, return_value_policy r, handle p) { return pybind11::cast(m.value, r, p); }
-    static handle cast(const CopyOnlyInt *src, return_value_policy policy, handle parent) {
-        if (!src) return none().release();
-        return cast(*src, policy, parent);
-    }
-    operator CopyOnlyInt*() { return &value; }
-    operator CopyOnlyInt&() { return value; }
-    template <typename T> using cast_op_type = pybind11::detail::cast_op_type<T>;
-};
-NAMESPACE_END(detail)
-NAMESPACE_END(pybind11)
-
-TEST_SUBMODULE(copy_move_policies, m) {
-    // test_lacking_copy_ctor
-    py::class_<lacking_copy_ctor>(m, "lacking_copy_ctor")
-        .def_static("get_one", &lacking_copy_ctor::get_one,
-                    py::return_value_policy::copy);
-    // test_lacking_move_ctor
-    py::class_<lacking_move_ctor>(m, "lacking_move_ctor")
-        .def_static("get_one", &lacking_move_ctor::get_one,
-                    py::return_value_policy::move);
-
-    // test_move_and_copy_casts
-    m.def("move_and_copy_casts", [](py::object o) {
-        int r = 0;
-        r += py::cast<MoveOrCopyInt>(o).value; /* moves */
-        r += py::cast<MoveOnlyInt>(o).value; /* moves */
-        r += py::cast<CopyOnlyInt>(o).value; /* copies */
-        MoveOrCopyInt m1(py::cast<MoveOrCopyInt>(o)); /* moves */
-        MoveOnlyInt m2(py::cast<MoveOnlyInt>(o)); /* moves */
-        CopyOnlyInt m3(py::cast<CopyOnlyInt>(o)); /* copies */
-        r += m1.value + m2.value + m3.value;
-
-        return r;
-    });
-
-    // test_move_and_copy_loads
-    m.def("move_only", [](MoveOnlyInt m) { return m.value; });
-    m.def("move_or_copy", [](MoveOrCopyInt m) { return m.value; });
-    m.def("copy_only", [](CopyOnlyInt m) { return m.value; });
-    m.def("move_pair", [](std::pair<MoveOnlyInt, MoveOrCopyInt> p) {
-        return p.first.value + p.second.value;
-    });
-    m.def("move_tuple", [](std::tuple<MoveOnlyInt, MoveOrCopyInt, MoveOnlyInt> t) {
-        return std::get<0>(t).value + std::get<1>(t).value + std::get<2>(t).value;
-    });
-    m.def("copy_tuple", [](std::tuple<CopyOnlyInt, CopyOnlyInt> t) {
-        return std::get<0>(t).value + std::get<1>(t).value;
-    });
-    m.def("move_copy_nested", [](std::pair<MoveOnlyInt, std::pair<std::tuple<MoveOrCopyInt, CopyOnlyInt, std::tuple<MoveOnlyInt>>, MoveOrCopyInt>> x) {
-        return x.first.value + std::get<0>(x.second.first).value + std::get<1>(x.second.first).value +
-            std::get<0>(std::get<2>(x.second.first)).value + x.second.second.value;
-    });
-    m.def("move_and_copy_cstats", []() {
-        ConstructorStats::gc();
-        // Reset counts to 0 so that previous tests don't affect later ones:
-        auto &mc = ConstructorStats::get<MoveOrCopyInt>();
-        mc.move_assignments = mc.move_constructions = mc.copy_assignments = mc.copy_constructions = 0;
-        auto &mo = ConstructorStats::get<MoveOnlyInt>();
-        mo.move_assignments = mo.move_constructions = mo.copy_assignments = mo.copy_constructions = 0;
-        auto &co = ConstructorStats::get<CopyOnlyInt>();
-        co.move_assignments = co.move_constructions = co.copy_assignments = co.copy_constructions = 0;
-        py::dict d;
-        d["MoveOrCopyInt"] = py::cast(mc, py::return_value_policy::reference);
-        d["MoveOnlyInt"] = py::cast(mo, py::return_value_policy::reference);
-        d["CopyOnlyInt"] = py::cast(co, py::return_value_policy::reference);
-        return d;
-    });
-#ifdef PYBIND11_HAS_OPTIONAL
-    // test_move_and_copy_load_optional
-    m.attr("has_optional") = true;
-    m.def("move_optional", [](std::optional<MoveOnlyInt> o) {
-        return o->value;
-    });
-    m.def("move_or_copy_optional", [](std::optional<MoveOrCopyInt> o) {
-        return o->value;
-    });
-    m.def("copy_optional", [](std::optional<CopyOnlyInt> o) {
-        return o->value;
-    });
-    m.def("move_optional_tuple", [](std::optional<std::tuple<MoveOrCopyInt, MoveOnlyInt, CopyOnlyInt>> x) {
-        return std::get<0>(*x).value + std::get<1>(*x).value + std::get<2>(*x).value;
-    });
-#else
-    m.attr("has_optional") = false;
-#endif
-
-    // #70 compilation issue if operator new is not public
-    struct PrivateOpNew {
-        int value = 1;
-    private:
-#if defined(_MSC_VER)
-#  pragma warning(disable: 4822) // warning C4822: local class member function does not have a body
-#endif
-        void *operator new(size_t bytes);
-    };
-    py::class_<PrivateOpNew>(m, "PrivateOpNew").def_readonly("value", &PrivateOpNew::value);
-    m.def("private_op_new_value", []() { return PrivateOpNew(); });
-    m.def("private_op_new_reference", []() -> const PrivateOpNew & {
-        static PrivateOpNew x{};
-        return x;
-    }, py::return_value_policy::reference);
-
-    // test_move_fallback
-    // #389: rvp::move should fall-through to copy on non-movable objects
-    struct MoveIssue1 {
-        int v;
-        MoveIssue1(int v) : v{v} {}
-        MoveIssue1(const MoveIssue1 &c) = default;
-        MoveIssue1(MoveIssue1 &&) = delete;
-    };
-    py::class_<MoveIssue1>(m, "MoveIssue1").def(py::init<int>()).def_readwrite("value", &MoveIssue1::v);
-
-    struct MoveIssue2 {
-        int v;
-        MoveIssue2(int v) : v{v} {}
-        MoveIssue2(MoveIssue2 &&) = default;
-    };
-    py::class_<MoveIssue2>(m, "MoveIssue2").def(py::init<int>()).def_readwrite("value", &MoveIssue2::v);
-
-    m.def("get_moveissue1", [](int i) { return new MoveIssue1(i); }, py::return_value_policy::move);
-    m.def("get_moveissue2", [](int i) { return MoveIssue2(i); }, py::return_value_policy::move);
-}
diff --git a/tmap/lib/pybind11/tests/test_copy_move.py b/tmap/lib/pybind11/tests/test_copy_move.py
deleted file mode 100644
index aff2d99..0000000
--- a/tmap/lib/pybind11/tests/test_copy_move.py
+++ /dev/null
@@ -1,112 +0,0 @@
-import pytest
-from pybind11_tests import copy_move_policies as m
-
-
-def test_lacking_copy_ctor():
-    with pytest.raises(RuntimeError) as excinfo:
-        m.lacking_copy_ctor.get_one()
-    assert "the object is non-copyable!" in str(excinfo.value)
-
-
-def test_lacking_move_ctor():
-    with pytest.raises(RuntimeError) as excinfo:
-        m.lacking_move_ctor.get_one()
-    assert "the object is neither movable nor copyable!" in str(excinfo.value)
-
-
-def test_move_and_copy_casts():
-    """Cast some values in C++ via custom type casters and count the number of moves/copies."""
-
-    cstats = m.move_and_copy_cstats()
-    c_m, c_mc, c_c = cstats["MoveOnlyInt"], cstats["MoveOrCopyInt"], cstats["CopyOnlyInt"]
-
-    # The type move constructions/assignments below each get incremented: the move assignment comes
-    # from the type_caster load; the move construction happens when extracting that via a cast or
-    # loading into an argument.
-    assert m.move_and_copy_casts(3) == 18
-    assert c_m.copy_assignments + c_m.copy_constructions == 0
-    assert c_m.move_assignments == 2
-    assert c_m.move_constructions >= 2
-    assert c_mc.alive() == 0
-    assert c_mc.copy_assignments + c_mc.copy_constructions == 0
-    assert c_mc.move_assignments == 2
-    assert c_mc.move_constructions >= 2
-    assert c_c.alive() == 0
-    assert c_c.copy_assignments == 2
-    assert c_c.copy_constructions >= 2
-    assert c_m.alive() + c_mc.alive() + c_c.alive() == 0
-
-
-def test_move_and_copy_loads():
-    """Call some functions that load arguments via custom type casters and count the number of
-    moves/copies."""
-
-    cstats = m.move_and_copy_cstats()
-    c_m, c_mc, c_c = cstats["MoveOnlyInt"], cstats["MoveOrCopyInt"], cstats["CopyOnlyInt"]
-
-    assert m.move_only(10) == 10  # 1 move, c_m
-    assert m.move_or_copy(11) == 11  # 1 move, c_mc
-    assert m.copy_only(12) == 12  # 1 copy, c_c
-    assert m.move_pair((13, 14)) == 27  # 1 c_m move, 1 c_mc move
-    assert m.move_tuple((15, 16, 17)) == 48  # 2 c_m moves, 1 c_mc move
-    assert m.copy_tuple((18, 19)) == 37  # 2 c_c copies
-    # Direct constructions: 2 c_m moves, 2 c_mc moves, 1 c_c copy
-    # Extra moves/copies when moving pairs/tuples: 3 c_m, 3 c_mc, 2 c_c
-    assert m.move_copy_nested((1, ((2, 3, (4,)), 5))) == 15
-
-    assert c_m.copy_assignments + c_m.copy_constructions == 0
-    assert c_m.move_assignments == 6
-    assert c_m.move_constructions == 9
-    assert c_mc.copy_assignments + c_mc.copy_constructions == 0
-    assert c_mc.move_assignments == 5
-    assert c_mc.move_constructions == 8
-    assert c_c.copy_assignments == 4
-    assert c_c.copy_constructions == 6
-    assert c_m.alive() + c_mc.alive() + c_c.alive() == 0
-
-
-@pytest.mark.skipif(not m.has_optional, reason='no <optional>')
-def test_move_and_copy_load_optional():
-    """Tests move/copy loads of std::optional arguments"""
-
-    cstats = m.move_and_copy_cstats()
-    c_m, c_mc, c_c = cstats["MoveOnlyInt"], cstats["MoveOrCopyInt"], cstats["CopyOnlyInt"]
-
-    # The extra move/copy constructions below come from the std::optional move (which has to move
-    # its arguments):
-    assert m.move_optional(10) == 10  # c_m: 1 move assign, 2 move construct
-    assert m.move_or_copy_optional(11) == 11  # c_mc: 1 move assign, 2 move construct
-    assert m.copy_optional(12) == 12  # c_c: 1 copy assign, 2 copy construct
-    # 1 move assign + move construct moves each of c_m, c_mc, 1 c_c copy
-    # +1 move/copy construct each from moving the tuple
-    # +1 move/copy construct each from moving the optional (which moves the tuple again)
-    assert m.move_optional_tuple((3, 4, 5)) == 12
-
-    assert c_m.copy_assignments + c_m.copy_constructions == 0
-    assert c_m.move_assignments == 2
-    assert c_m.move_constructions == 5
-    assert c_mc.copy_assignments + c_mc.copy_constructions == 0
-    assert c_mc.move_assignments == 2
-    assert c_mc.move_constructions == 5
-    assert c_c.copy_assignments == 2
-    assert c_c.copy_constructions == 5
-    assert c_m.alive() + c_mc.alive() + c_c.alive() == 0
-
-
-def test_private_op_new():
-    """An object with a private `operator new` cannot be returned by value"""
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.private_op_new_value()
-    assert "the object is neither movable nor copyable" in str(excinfo.value)
-
-    assert m.private_op_new_reference().value == 1
-
-
-def test_move_fallback():
-    """#389: rvp::move should fall-through to copy on non-movable objects"""
-
-    m2 = m.get_moveissue2(2)
-    assert m2.value == 2
-    m1 = m.get_moveissue1(1)
-    assert m1.value == 1
diff --git a/tmap/lib/pybind11/tests/test_docstring_options.cpp b/tmap/lib/pybind11/tests/test_docstring_options.cpp
deleted file mode 100644
index 8c8f79f..0000000
--- a/tmap/lib/pybind11/tests/test_docstring_options.cpp
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
-    tests/test_docstring_options.cpp -- generation of docstrings and signatures
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-
-TEST_SUBMODULE(docstring_options, m) {
-    // test_docstring_options
-    {
-        py::options options;
-        options.disable_function_signatures();
-
-        m.def("test_function1", [](int, int) {}, py::arg("a"), py::arg("b"));
-        m.def("test_function2", [](int, int) {}, py::arg("a"), py::arg("b"), "A custom docstring");
-
-        m.def("test_overloaded1", [](int) {}, py::arg("i"), "Overload docstring");
-        m.def("test_overloaded1", [](double) {}, py::arg("d"));
-
-        m.def("test_overloaded2", [](int) {}, py::arg("i"), "overload docstring 1");
-        m.def("test_overloaded2", [](double) {}, py::arg("d"), "overload docstring 2");
-
-        m.def("test_overloaded3", [](int) {}, py::arg("i"));
-        m.def("test_overloaded3", [](double) {}, py::arg("d"), "Overload docstr");
-
-        options.enable_function_signatures();
-
-        m.def("test_function3", [](int, int) {}, py::arg("a"), py::arg("b"));
-        m.def("test_function4", [](int, int) {}, py::arg("a"), py::arg("b"), "A custom docstring");
-
-        options.disable_function_signatures().disable_user_defined_docstrings();
-
-        m.def("test_function5", [](int, int) {}, py::arg("a"), py::arg("b"), "A custom docstring");
-
-        {
-            py::options nested_options;
-            nested_options.enable_user_defined_docstrings();
-            m.def("test_function6", [](int, int) {}, py::arg("a"), py::arg("b"), "A custom docstring");
-        }
-    }
-
-    m.def("test_function7", [](int, int) {}, py::arg("a"), py::arg("b"), "A custom docstring");
-
-    {
-        py::options options;
-        options.disable_user_defined_docstrings();
-
-        struct DocstringTestFoo {
-            int value;
-            void setValue(int v) { value = v; }
-            int getValue() const { return value; }
-        };
-        py::class_<DocstringTestFoo>(m, "DocstringTestFoo", "This is a class docstring")
-            .def_property("value_prop", &DocstringTestFoo::getValue, &DocstringTestFoo::setValue, "This is a property docstring")
-        ;
-    }
-}
diff --git a/tmap/lib/pybind11/tests/test_docstring_options.py b/tmap/lib/pybind11/tests/test_docstring_options.py
deleted file mode 100644
index 0dbca60..0000000
--- a/tmap/lib/pybind11/tests/test_docstring_options.py
+++ /dev/null
@@ -1,38 +0,0 @@
-from pybind11_tests import docstring_options as m
-
-
-def test_docstring_options():
-    # options.disable_function_signatures()
-    assert not m.test_function1.__doc__
-
-    assert m.test_function2.__doc__ == "A custom docstring"
-
-    # docstring specified on just the first overload definition:
-    assert m.test_overloaded1.__doc__ == "Overload docstring"
-
-    # docstring on both overloads:
-    assert m.test_overloaded2.__doc__ == "overload docstring 1\noverload docstring 2"
-
-    # docstring on only second overload:
-    assert m.test_overloaded3.__doc__ == "Overload docstr"
-
-    # options.enable_function_signatures()
-    assert m.test_function3.__doc__ .startswith("test_function3(a: int, b: int) -> None")
-
-    assert m.test_function4.__doc__ .startswith("test_function4(a: int, b: int) -> None")
-    assert m.test_function4.__doc__ .endswith("A custom docstring\n")
-
-    # options.disable_function_signatures()
-    # options.disable_user_defined_docstrings()
-    assert not m.test_function5.__doc__
-
-    # nested options.enable_user_defined_docstrings()
-    assert m.test_function6.__doc__ == "A custom docstring"
-
-    # RAII destructor
-    assert m.test_function7.__doc__ .startswith("test_function7(a: int, b: int) -> None")
-    assert m.test_function7.__doc__ .endswith("A custom docstring\n")
-
-    # Suppression of user-defined docstrings for non-function objects
-    assert not m.DocstringTestFoo.__doc__
-    assert not m.DocstringTestFoo.value_prop.__doc__
diff --git a/tmap/lib/pybind11/tests/test_eigen.cpp b/tmap/lib/pybind11/tests/test_eigen.cpp
deleted file mode 100644
index 17b156c..0000000
--- a/tmap/lib/pybind11/tests/test_eigen.cpp
+++ /dev/null
@@ -1,317 +0,0 @@
-/*
-    tests/eigen.cpp -- automatic conversion of Eigen types
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "constructor_stats.h"
-#include <pybind11/eigen.h>
-#include <pybind11/stl.h>
-#include <Eigen/Cholesky>
-
-using MatrixXdR = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;
-
-
-
-// Sets/resets a testing reference matrix to have values of 10*r + c, where r and c are the
-// (1-based) row/column number.
-template <typename M> void reset_ref(M &x) {
-    for (int i = 0; i < x.rows(); i++) for (int j = 0; j < x.cols(); j++)
-        x(i, j) = 11 + 10*i + j;
-}
-
-// Returns a static, column-major matrix
-Eigen::MatrixXd &get_cm() {
-    static Eigen::MatrixXd *x;
-    if (!x) {
-        x = new Eigen::MatrixXd(3, 3);
-        reset_ref(*x);
-    }
-    return *x;
-}
-// Likewise, but row-major
-MatrixXdR &get_rm() {
-    static MatrixXdR *x;
-    if (!x) {
-        x = new MatrixXdR(3, 3);
-        reset_ref(*x);
-    }
-    return *x;
-}
-// Resets the values of the static matrices returned by get_cm()/get_rm()
-void reset_refs() {
-    reset_ref(get_cm());
-    reset_ref(get_rm());
-}
-
-// Returns element 2,1 from a matrix (used to test copy/nocopy)
-double get_elem(Eigen::Ref<const Eigen::MatrixXd> m) { return m(2, 1); };
-
-
-// Returns a matrix with 10*r + 100*c added to each matrix element (to help test that the matrix
-// reference is referencing rows/columns correctly).
-template <typename MatrixArgType> Eigen::MatrixXd adjust_matrix(MatrixArgType m) {
-    Eigen::MatrixXd ret(m);
-    for (int c = 0; c < m.cols(); c++) for (int r = 0; r < m.rows(); r++)
-        ret(r, c) += 10*r + 100*c;
-    return ret;
-}
-
-struct CustomOperatorNew {
-    CustomOperatorNew() = default;
-
-    Eigen::Matrix4d a = Eigen::Matrix4d::Zero();
-    Eigen::Matrix4d b = Eigen::Matrix4d::Identity();
-
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-};
-
-TEST_SUBMODULE(eigen, m) {
-    using FixedMatrixR = Eigen::Matrix<float, 5, 6, Eigen::RowMajor>;
-    using FixedMatrixC = Eigen::Matrix<float, 5, 6>;
-    using DenseMatrixR = Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;
-    using DenseMatrixC = Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic>;
-    using FourRowMatrixC = Eigen::Matrix<float, 4, Eigen::Dynamic>;
-    using FourColMatrixC = Eigen::Matrix<float, Eigen::Dynamic, 4>;
-    using FourRowMatrixR = Eigen::Matrix<float, 4, Eigen::Dynamic>;
-    using FourColMatrixR = Eigen::Matrix<float, Eigen::Dynamic, 4>;
-    using SparseMatrixR = Eigen::SparseMatrix<float, Eigen::RowMajor>;
-    using SparseMatrixC = Eigen::SparseMatrix<float>;
-
-    m.attr("have_eigen") = true;
-
-    // various tests
-    m.def("double_col", [](const Eigen::VectorXf &x) -> Eigen::VectorXf { return 2.0f * x; });
-    m.def("double_row", [](const Eigen::RowVectorXf &x) -> Eigen::RowVectorXf { return 2.0f * x; });
-    m.def("double_complex", [](const Eigen::VectorXcf &x) -> Eigen::VectorXcf { return 2.0f * x; });
-    m.def("double_threec", [](py::EigenDRef<Eigen::Vector3f> x) { x *= 2; });
-    m.def("double_threer", [](py::EigenDRef<Eigen::RowVector3f> x) { x *= 2; });
-    m.def("double_mat_cm", [](Eigen::MatrixXf x) -> Eigen::MatrixXf { return 2.0f * x; });
-    m.def("double_mat_rm", [](DenseMatrixR x) -> DenseMatrixR { return 2.0f * x; });
-
-    // test_eigen_ref_to_python
-    // Different ways of passing via Eigen::Ref; the first and second are the Eigen-recommended
-    m.def("cholesky1", [](Eigen::Ref<MatrixXdR> x) -> Eigen::MatrixXd { return x.llt().matrixL(); });
-    m.def("cholesky2", [](const Eigen::Ref<const MatrixXdR> &x) -> Eigen::MatrixXd { return x.llt().matrixL(); });
-    m.def("cholesky3", [](const Eigen::Ref<MatrixXdR> &x) -> Eigen::MatrixXd { return x.llt().matrixL(); });
-    m.def("cholesky4", [](Eigen::Ref<const MatrixXdR> x) -> Eigen::MatrixXd { return x.llt().matrixL(); });
-
-    // test_eigen_ref_mutators
-    // Mutators: these add some value to the given element using Eigen, but Eigen should be mapping into
-    // the numpy array data and so the result should show up there.  There are three versions: one that
-    // works on a contiguous-row matrix (numpy's default), one for a contiguous-column matrix, and one
-    // for any matrix.
-    auto add_rm = [](Eigen::Ref<MatrixXdR> x, int r, int c, double v) { x(r,c) += v; };
-    auto add_cm = [](Eigen::Ref<Eigen::MatrixXd> x, int r, int c, double v) { x(r,c) += v; };
-
-    // Mutators (Eigen maps into numpy variables):
-    m.def("add_rm", add_rm); // Only takes row-contiguous
-    m.def("add_cm", add_cm); // Only takes column-contiguous
-    // Overloaded versions that will accept either row or column contiguous:
-    m.def("add1", add_rm);
-    m.def("add1", add_cm);
-    m.def("add2", add_cm);
-    m.def("add2", add_rm);
-    // This one accepts a matrix of any stride:
-    m.def("add_any", [](py::EigenDRef<Eigen::MatrixXd> x, int r, int c, double v) { x(r,c) += v; });
-
-    // Return mutable references (numpy maps into eigen varibles)
-    m.def("get_cm_ref", []() { return Eigen::Ref<Eigen::MatrixXd>(get_cm()); });
-    m.def("get_rm_ref", []() { return Eigen::Ref<MatrixXdR>(get_rm()); });
-    // The same references, but non-mutable (numpy maps into eigen variables, but is !writeable)
-    m.def("get_cm_const_ref", []() { return Eigen::Ref<const Eigen::MatrixXd>(get_cm()); });
-    m.def("get_rm_const_ref", []() { return Eigen::Ref<const MatrixXdR>(get_rm()); });
-
-    m.def("reset_refs", reset_refs); // Restores get_{cm,rm}_ref to original values
-
-    // Increments and returns ref to (same) matrix
-    m.def("incr_matrix", [](Eigen::Ref<Eigen::MatrixXd> m, double v) {
-        m += Eigen::MatrixXd::Constant(m.rows(), m.cols(), v);
-        return m;
-    }, py::return_value_policy::reference);
-
-    // Same, but accepts a matrix of any strides
-    m.def("incr_matrix_any", [](py::EigenDRef<Eigen::MatrixXd> m, double v) {
-        m += Eigen::MatrixXd::Constant(m.rows(), m.cols(), v);
-        return m;
-    }, py::return_value_policy::reference);
-
-    // Returns an eigen slice of even rows
-    m.def("even_rows", [](py::EigenDRef<Eigen::MatrixXd> m) {
-        return py::EigenDMap<Eigen::MatrixXd>(
-                m.data(), (m.rows() + 1) / 2, m.cols(),
-                py::EigenDStride(m.outerStride(), 2 * m.innerStride()));
-    }, py::return_value_policy::reference);
-
-    // Returns an eigen slice of even columns
-    m.def("even_cols", [](py::EigenDRef<Eigen::MatrixXd> m) {
-        return py::EigenDMap<Eigen::MatrixXd>(
-                m.data(), m.rows(), (m.cols() + 1) / 2,
-                py::EigenDStride(2 * m.outerStride(), m.innerStride()));
-    }, py::return_value_policy::reference);
-
-    // Returns diagonals: a vector-like object with an inner stride != 1
-    m.def("diagonal", [](const Eigen::Ref<const Eigen::MatrixXd> &x) { return x.diagonal(); });
-    m.def("diagonal_1", [](const Eigen::Ref<const Eigen::MatrixXd> &x) { return x.diagonal<1>(); });
-    m.def("diagonal_n", [](const Eigen::Ref<const Eigen::MatrixXd> &x, int index) { return x.diagonal(index); });
-
-    // Return a block of a matrix (gives non-standard strides)
-    m.def("block", [](const Eigen::Ref<const Eigen::MatrixXd> &x, int start_row, int start_col, int block_rows, int block_cols) {
-        return x.block(start_row, start_col, block_rows, block_cols);
-    });
-
-    // test_eigen_return_references, test_eigen_keepalive
-    // return value referencing/copying tests:
-    class ReturnTester {
-        Eigen::MatrixXd mat = create();
-    public:
-        ReturnTester() { print_created(this); }
-        ~ReturnTester() { print_destroyed(this); }
-        static Eigen::MatrixXd create() { return Eigen::MatrixXd::Ones(10, 10); }
-        static const Eigen::MatrixXd createConst() { return Eigen::MatrixXd::Ones(10, 10); }
-        Eigen::MatrixXd &get() { return mat; }
-        Eigen::MatrixXd *getPtr() { return &mat; }
-        const Eigen::MatrixXd &view() { return mat; }
-        const Eigen::MatrixXd *viewPtr() { return &mat; }
-        Eigen::Ref<Eigen::MatrixXd> ref() { return mat; }
-        Eigen::Ref<const Eigen::MatrixXd> refConst() { return mat; }
-        Eigen::Block<Eigen::MatrixXd> block(int r, int c, int nrow, int ncol) { return mat.block(r, c, nrow, ncol); }
-        Eigen::Block<const Eigen::MatrixXd> blockConst(int r, int c, int nrow, int ncol) const { return mat.block(r, c, nrow, ncol); }
-        py::EigenDMap<Eigen::Matrix2d> corners() { return py::EigenDMap<Eigen::Matrix2d>(mat.data(),
-                    py::EigenDStride(mat.outerStride() * (mat.outerSize()-1), mat.innerStride() * (mat.innerSize()-1))); }
-        py::EigenDMap<const Eigen::Matrix2d> cornersConst() const { return py::EigenDMap<const Eigen::Matrix2d>(mat.data(),
-                    py::EigenDStride(mat.outerStride() * (mat.outerSize()-1), mat.innerStride() * (mat.innerSize()-1))); }
-    };
-    using rvp = py::return_value_policy;
-    py::class_<ReturnTester>(m, "ReturnTester")
-        .def(py::init<>())
-        .def_static("create", &ReturnTester::create)
-        .def_static("create_const", &ReturnTester::createConst)
-        .def("get", &ReturnTester::get, rvp::reference_internal)
-        .def("get_ptr", &ReturnTester::getPtr, rvp::reference_internal)
-        .def("view", &ReturnTester::view, rvp::reference_internal)
-        .def("view_ptr", &ReturnTester::view, rvp::reference_internal)
-        .def("copy_get", &ReturnTester::get)   // Default rvp: copy
-        .def("copy_view", &ReturnTester::view) //         "
-        .def("ref", &ReturnTester::ref) // Default for Ref is to reference
-        .def("ref_const", &ReturnTester::refConst) // Likewise, but const
-        .def("ref_safe", &ReturnTester::ref, rvp::reference_internal)
-        .def("ref_const_safe", &ReturnTester::refConst, rvp::reference_internal)
-        .def("copy_ref", &ReturnTester::ref, rvp::copy)
-        .def("copy_ref_const", &ReturnTester::refConst, rvp::copy)
-        .def("block", &ReturnTester::block)
-        .def("block_safe", &ReturnTester::block, rvp::reference_internal)
-        .def("block_const", &ReturnTester::blockConst, rvp::reference_internal)
-        .def("copy_block", &ReturnTester::block, rvp::copy)
-        .def("corners", &ReturnTester::corners, rvp::reference_internal)
-        .def("corners_const", &ReturnTester::cornersConst, rvp::reference_internal)
-        ;
-
-    // test_special_matrix_objects
-    // Returns a DiagonalMatrix with diagonal (1,2,3,...)
-    m.def("incr_diag", [](int k) {
-        Eigen::DiagonalMatrix<int, Eigen::Dynamic> m(k);
-        for (int i = 0; i < k; i++) m.diagonal()[i] = i+1;
-        return m;
-    });
-
-    // Returns a SelfAdjointView referencing the lower triangle of m
-    m.def("symmetric_lower", [](const Eigen::MatrixXi &m) {
-            return m.selfadjointView<Eigen::Lower>();
-    });
-    // Returns a SelfAdjointView referencing the lower triangle of m
-    m.def("symmetric_upper", [](const Eigen::MatrixXi &m) {
-            return m.selfadjointView<Eigen::Upper>();
-    });
-
-    // Test matrix for various functions below.
-    Eigen::MatrixXf mat(5, 6);
-    mat << 0,  3,  0,  0,  0, 11,
-           22, 0,  0,  0, 17, 11,
-           7,  5,  0,  1,  0, 11,
-           0,  0,  0,  0,  0, 11,
-           0,  0, 14,  0,  8, 11;
-
-    // test_fixed, and various other tests
-    m.def("fixed_r", [mat]() -> FixedMatrixR { return FixedMatrixR(mat); });
-    m.def("fixed_r_const", [mat]() -> const FixedMatrixR { return FixedMatrixR(mat); });
-    m.def("fixed_c", [mat]() -> FixedMatrixC { return FixedMatrixC(mat); });
-    m.def("fixed_copy_r", [](const FixedMatrixR &m) -> FixedMatrixR { return m; });
-    m.def("fixed_copy_c", [](const FixedMatrixC &m) -> FixedMatrixC { return m; });
-    // test_mutator_descriptors
-    m.def("fixed_mutator_r", [](Eigen::Ref<FixedMatrixR>) {});
-    m.def("fixed_mutator_c", [](Eigen::Ref<FixedMatrixC>) {});
-    m.def("fixed_mutator_a", [](py::EigenDRef<FixedMatrixC>) {});
-    // test_dense
-    m.def("dense_r", [mat]() -> DenseMatrixR { return DenseMatrixR(mat); });
-    m.def("dense_c", [mat]() -> DenseMatrixC { return DenseMatrixC(mat); });
-    m.def("dense_copy_r", [](const DenseMatrixR &m) -> DenseMatrixR { return m; });
-    m.def("dense_copy_c", [](const DenseMatrixC &m) -> DenseMatrixC { return m; });
-    // test_sparse, test_sparse_signature
-    m.def("sparse_r", [mat]() -> SparseMatrixR { return Eigen::SparseView<Eigen::MatrixXf>(mat); });
-    m.def("sparse_c", [mat]() -> SparseMatrixC { return Eigen::SparseView<Eigen::MatrixXf>(mat); });
-    m.def("sparse_copy_r", [](const SparseMatrixR &m) -> SparseMatrixR { return m; });
-    m.def("sparse_copy_c", [](const SparseMatrixC &m) -> SparseMatrixC { return m; });
-    // test_partially_fixed
-    m.def("partial_copy_four_rm_r", [](const FourRowMatrixR &m) -> FourRowMatrixR { return m; });
-    m.def("partial_copy_four_rm_c", [](const FourColMatrixR &m) -> FourColMatrixR { return m; });
-    m.def("partial_copy_four_cm_r", [](const FourRowMatrixC &m) -> FourRowMatrixC { return m; });
-    m.def("partial_copy_four_cm_c", [](const FourColMatrixC &m) -> FourColMatrixC { return m; });
-
-    // test_cpp_casting
-    // Test that we can cast a numpy object to a Eigen::MatrixXd explicitly
-    m.def("cpp_copy", [](py::handle m) { return m.cast<Eigen::MatrixXd>()(1, 0); });
-    m.def("cpp_ref_c", [](py::handle m) { return m.cast<Eigen::Ref<Eigen::MatrixXd>>()(1, 0); });
-    m.def("cpp_ref_r", [](py::handle m) { return m.cast<Eigen::Ref<MatrixXdR>>()(1, 0); });
-    m.def("cpp_ref_any", [](py::handle m) { return m.cast<py::EigenDRef<Eigen::MatrixXd>>()(1, 0); });
-
-
-    // test_nocopy_wrapper
-    // Test that we can prevent copying into an argument that would normally copy: First a version
-    // that would allow copying (if types or strides don't match) for comparison:
-    m.def("get_elem", &get_elem);
-    // Now this alternative that calls the tells pybind to fail rather than copy:
-    m.def("get_elem_nocopy", [](Eigen::Ref<const Eigen::MatrixXd> m) -> double { return get_elem(m); },
-            py::arg().noconvert());
-    // Also test a row-major-only no-copy const ref:
-    m.def("get_elem_rm_nocopy", [](Eigen::Ref<const Eigen::Matrix<long, -1, -1, Eigen::RowMajor>> &m) -> long { return m(2, 1); },
-            py::arg().noconvert());
-
-    // test_issue738
-    // Issue #738: 1xN or Nx1 2D matrices were neither accepted nor properly copied with an
-    // incompatible stride value on the length-1 dimension--but that should be allowed (without
-    // requiring a copy!) because the stride value can be safely ignored on a size-1 dimension.
-    m.def("iss738_f1", &adjust_matrix<const Eigen::Ref<const Eigen::MatrixXd> &>, py::arg().noconvert());
-    m.def("iss738_f2", &adjust_matrix<const Eigen::Ref<const Eigen::Matrix<double, -1, -1, Eigen::RowMajor>> &>, py::arg().noconvert());
-
-    // test_named_arguments
-    // Make sure named arguments are working properly:
-    m.def("matrix_multiply", [](const py::EigenDRef<const Eigen::MatrixXd> A, const py::EigenDRef<const Eigen::MatrixXd> B)
-            -> Eigen::MatrixXd {
-        if (A.cols() != B.rows()) throw std::domain_error("Nonconformable matrices!");
-        return A * B;
-    }, py::arg("A"), py::arg("B"));
-
-    // test_custom_operator_new
-    py::class_<CustomOperatorNew>(m, "CustomOperatorNew")
-        .def(py::init<>())
-        .def_readonly("a", &CustomOperatorNew::a)
-        .def_readonly("b", &CustomOperatorNew::b);
-
-    // test_eigen_ref_life_support
-    // In case of a failure (the caster's temp array does not live long enough), creating
-    // a new array (np.ones(10)) increases the chances that the temp array will be garbage
-    // collected and/or that its memory will be overridden with different values.
-    m.def("get_elem_direct", [](Eigen::Ref<const Eigen::VectorXd> v) {
-        py::module::import("numpy").attr("ones")(10);
-        return v(5);
-    });
-    m.def("get_elem_indirect", [](std::vector<Eigen::Ref<const Eigen::VectorXd>> v) {
-        py::module::import("numpy").attr("ones")(10);
-        return v[0](5);
-    });
-}
diff --git a/tmap/lib/pybind11/tests/test_eigen.py b/tmap/lib/pybind11/tests/test_eigen.py
deleted file mode 100644
index 4ac8cbf..0000000
--- a/tmap/lib/pybind11/tests/test_eigen.py
+++ /dev/null
@@ -1,681 +0,0 @@
-import pytest
-from pybind11_tests import ConstructorStats
-
-pytestmark = pytest.requires_eigen_and_numpy
-
-with pytest.suppress(ImportError):
-    from pybind11_tests import eigen as m
-    import numpy as np
-
-    ref = np.array([[ 0.,  3,  0,  0,  0, 11],
-                    [22,  0,  0,  0, 17, 11],
-                    [ 7,  5,  0,  1,  0, 11],
-                    [ 0,  0,  0,  0,  0, 11],
-                    [ 0,  0, 14,  0,  8, 11]])
-
-
-def assert_equal_ref(mat):
-    np.testing.assert_array_equal(mat, ref)
-
-
-def assert_sparse_equal_ref(sparse_mat):
-    assert_equal_ref(sparse_mat.todense())
-
-
-def test_fixed():
-    assert_equal_ref(m.fixed_c())
-    assert_equal_ref(m.fixed_r())
-    assert_equal_ref(m.fixed_copy_r(m.fixed_r()))
-    assert_equal_ref(m.fixed_copy_c(m.fixed_c()))
-    assert_equal_ref(m.fixed_copy_r(m.fixed_c()))
-    assert_equal_ref(m.fixed_copy_c(m.fixed_r()))
-
-
-def test_dense():
-    assert_equal_ref(m.dense_r())
-    assert_equal_ref(m.dense_c())
-    assert_equal_ref(m.dense_copy_r(m.dense_r()))
-    assert_equal_ref(m.dense_copy_c(m.dense_c()))
-    assert_equal_ref(m.dense_copy_r(m.dense_c()))
-    assert_equal_ref(m.dense_copy_c(m.dense_r()))
-
-
-def test_partially_fixed():
-    ref2 = np.array([[0., 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]])
-    np.testing.assert_array_equal(m.partial_copy_four_rm_r(ref2), ref2)
-    np.testing.assert_array_equal(m.partial_copy_four_rm_c(ref2), ref2)
-    np.testing.assert_array_equal(m.partial_copy_four_rm_r(ref2[:, 1]), ref2[:, [1]])
-    np.testing.assert_array_equal(m.partial_copy_four_rm_c(ref2[0, :]), ref2[[0], :])
-    np.testing.assert_array_equal(m.partial_copy_four_rm_r(ref2[:, (0, 2)]), ref2[:, (0, 2)])
-    np.testing.assert_array_equal(
-        m.partial_copy_four_rm_c(ref2[(3, 1, 2), :]), ref2[(3, 1, 2), :])
-
-    np.testing.assert_array_equal(m.partial_copy_four_cm_r(ref2), ref2)
-    np.testing.assert_array_equal(m.partial_copy_four_cm_c(ref2), ref2)
-    np.testing.assert_array_equal(m.partial_copy_four_cm_r(ref2[:, 1]), ref2[:, [1]])
-    np.testing.assert_array_equal(m.partial_copy_four_cm_c(ref2[0, :]), ref2[[0], :])
-    np.testing.assert_array_equal(m.partial_copy_four_cm_r(ref2[:, (0, 2)]), ref2[:, (0, 2)])
-    np.testing.assert_array_equal(
-        m.partial_copy_four_cm_c(ref2[(3, 1, 2), :]), ref2[(3, 1, 2), :])
-
-    # TypeError should be raise for a shape mismatch
-    functions = [m.partial_copy_four_rm_r, m.partial_copy_four_rm_c,
-                 m.partial_copy_four_cm_r, m.partial_copy_four_cm_c]
-    matrix_with_wrong_shape = [[1, 2],
-                               [3, 4]]
-    for f in functions:
-        with pytest.raises(TypeError) as excinfo:
-            f(matrix_with_wrong_shape)
-        assert "incompatible function arguments" in str(excinfo.value)
-
-
-def test_mutator_descriptors():
-    zr = np.arange(30, dtype='float32').reshape(5, 6)  # row-major
-    zc = zr.reshape(6, 5).transpose()  # column-major
-
-    m.fixed_mutator_r(zr)
-    m.fixed_mutator_c(zc)
-    m.fixed_mutator_a(zr)
-    m.fixed_mutator_a(zc)
-    with pytest.raises(TypeError) as excinfo:
-        m.fixed_mutator_r(zc)
-    assert ('(arg0: numpy.ndarray[float32[5, 6], flags.writeable, flags.c_contiguous]) -> None'
-            in str(excinfo.value))
-    with pytest.raises(TypeError) as excinfo:
-        m.fixed_mutator_c(zr)
-    assert ('(arg0: numpy.ndarray[float32[5, 6], flags.writeable, flags.f_contiguous]) -> None'
-            in str(excinfo.value))
-    with pytest.raises(TypeError) as excinfo:
-        m.fixed_mutator_a(np.array([[1, 2], [3, 4]], dtype='float32'))
-    assert ('(arg0: numpy.ndarray[float32[5, 6], flags.writeable]) -> None'
-            in str(excinfo.value))
-    zr.flags.writeable = False
-    with pytest.raises(TypeError):
-        m.fixed_mutator_r(zr)
-    with pytest.raises(TypeError):
-        m.fixed_mutator_a(zr)
-
-
-def test_cpp_casting():
-    assert m.cpp_copy(m.fixed_r()) == 22.
-    assert m.cpp_copy(m.fixed_c()) == 22.
-    z = np.array([[5., 6], [7, 8]])
-    assert m.cpp_copy(z) == 7.
-    assert m.cpp_copy(m.get_cm_ref()) == 21.
-    assert m.cpp_copy(m.get_rm_ref()) == 21.
-    assert m.cpp_ref_c(m.get_cm_ref()) == 21.
-    assert m.cpp_ref_r(m.get_rm_ref()) == 21.
-    with pytest.raises(RuntimeError) as excinfo:
-        # Can't reference m.fixed_c: it contains floats, m.cpp_ref_any wants doubles
-        m.cpp_ref_any(m.fixed_c())
-    assert 'Unable to cast Python instance' in str(excinfo.value)
-    with pytest.raises(RuntimeError) as excinfo:
-        # Can't reference m.fixed_r: it contains floats, m.cpp_ref_any wants doubles
-        m.cpp_ref_any(m.fixed_r())
-    assert 'Unable to cast Python instance' in str(excinfo.value)
-    assert m.cpp_ref_any(m.ReturnTester.create()) == 1.
-
-    assert m.cpp_ref_any(m.get_cm_ref()) == 21.
-    assert m.cpp_ref_any(m.get_cm_ref()) == 21.
-
-
-def test_pass_readonly_array():
-    z = np.full((5, 6), 42.0)
-    z.flags.writeable = False
-    np.testing.assert_array_equal(z, m.fixed_copy_r(z))
-    np.testing.assert_array_equal(m.fixed_r_const(), m.fixed_r())
-    assert not m.fixed_r_const().flags.writeable
-    np.testing.assert_array_equal(m.fixed_copy_r(m.fixed_r_const()), m.fixed_r_const())
-
-
-def test_nonunit_stride_from_python():
-    counting_mat = np.arange(9.0, dtype=np.float32).reshape((3, 3))
-    second_row = counting_mat[1, :]
-    second_col = counting_mat[:, 1]
-    np.testing.assert_array_equal(m.double_row(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(m.double_col(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(m.double_complex(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(m.double_row(second_col), 2.0 * second_col)
-    np.testing.assert_array_equal(m.double_col(second_col), 2.0 * second_col)
-    np.testing.assert_array_equal(m.double_complex(second_col), 2.0 * second_col)
-
-    counting_3d = np.arange(27.0, dtype=np.float32).reshape((3, 3, 3))
-    slices = [counting_3d[0, :, :], counting_3d[:, 0, :], counting_3d[:, :, 0]]
-    for slice_idx, ref_mat in enumerate(slices):
-        np.testing.assert_array_equal(m.double_mat_cm(ref_mat), 2.0 * ref_mat)
-        np.testing.assert_array_equal(m.double_mat_rm(ref_mat), 2.0 * ref_mat)
-
-    # Mutator:
-    m.double_threer(second_row)
-    m.double_threec(second_col)
-    np.testing.assert_array_equal(counting_mat, [[0., 2, 2], [6, 16, 10], [6, 14, 8]])
-
-
-def test_negative_stride_from_python(msg):
-    """Eigen doesn't support (as of yet) negative strides. When a function takes an Eigen matrix by
-    copy or const reference, we can pass a numpy array that has negative strides.  Otherwise, an
-    exception will be thrown as Eigen will not be able to map the numpy array."""
-
-    counting_mat = np.arange(9.0, dtype=np.float32).reshape((3, 3))
-    counting_mat = counting_mat[::-1, ::-1]
-    second_row = counting_mat[1, :]
-    second_col = counting_mat[:, 1]
-    np.testing.assert_array_equal(m.double_row(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(m.double_col(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(m.double_complex(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(m.double_row(second_col), 2.0 * second_col)
-    np.testing.assert_array_equal(m.double_col(second_col), 2.0 * second_col)
-    np.testing.assert_array_equal(m.double_complex(second_col), 2.0 * second_col)
-
-    counting_3d = np.arange(27.0, dtype=np.float32).reshape((3, 3, 3))
-    counting_3d = counting_3d[::-1, ::-1, ::-1]
-    slices = [counting_3d[0, :, :], counting_3d[:, 0, :], counting_3d[:, :, 0]]
-    for slice_idx, ref_mat in enumerate(slices):
-        np.testing.assert_array_equal(m.double_mat_cm(ref_mat), 2.0 * ref_mat)
-        np.testing.assert_array_equal(m.double_mat_rm(ref_mat), 2.0 * ref_mat)
-
-    # Mutator:
-    with pytest.raises(TypeError) as excinfo:
-        m.double_threer(second_row)
-    assert msg(excinfo.value) == """
-        double_threer(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: numpy.ndarray[float32[1, 3], flags.writeable]) -> None
-
-        Invoked with: array([ 5.,  4.,  3.], dtype=float32)
-    """  # noqa: E501 line too long
-
-    with pytest.raises(TypeError) as excinfo:
-        m.double_threec(second_col)
-    assert msg(excinfo.value) == """
-        double_threec(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: numpy.ndarray[float32[3, 1], flags.writeable]) -> None
-
-        Invoked with: array([ 7.,  4.,  1.], dtype=float32)
-    """  # noqa: E501 line too long
-
-
-def test_nonunit_stride_to_python():
-    assert np.all(m.diagonal(ref) == ref.diagonal())
-    assert np.all(m.diagonal_1(ref) == ref.diagonal(1))
-    for i in range(-5, 7):
-        assert np.all(m.diagonal_n(ref, i) == ref.diagonal(i)), "m.diagonal_n({})".format(i)
-
-    assert np.all(m.block(ref, 2, 1, 3, 3) == ref[2:5, 1:4])
-    assert np.all(m.block(ref, 1, 4, 4, 2) == ref[1:, 4:])
-    assert np.all(m.block(ref, 1, 4, 3, 2) == ref[1:4, 4:])
-
-
-def test_eigen_ref_to_python():
-    chols = [m.cholesky1, m.cholesky2, m.cholesky3, m.cholesky4]
-    for i, chol in enumerate(chols, start=1):
-        mymat = chol(np.array([[1., 2, 4], [2, 13, 23], [4, 23, 77]]))
-        assert np.all(mymat == np.array([[1, 0, 0], [2, 3, 0], [4, 5, 6]])), "cholesky{}".format(i)
-
-
-def assign_both(a1, a2, r, c, v):
-    a1[r, c] = v
-    a2[r, c] = v
-
-
-def array_copy_but_one(a, r, c, v):
-    z = np.array(a, copy=True)
-    z[r, c] = v
-    return z
-
-
-def test_eigen_return_references():
-    """Tests various ways of returning references and non-referencing copies"""
-
-    master = np.ones((10, 10))
-    a = m.ReturnTester()
-    a_get1 = a.get()
-    assert not a_get1.flags.owndata and a_get1.flags.writeable
-    assign_both(a_get1, master, 3, 3, 5)
-    a_get2 = a.get_ptr()
-    assert not a_get2.flags.owndata and a_get2.flags.writeable
-    assign_both(a_get1, master, 2, 3, 6)
-
-    a_view1 = a.view()
-    assert not a_view1.flags.owndata and not a_view1.flags.writeable
-    with pytest.raises(ValueError):
-        a_view1[2, 3] = 4
-    a_view2 = a.view_ptr()
-    assert not a_view2.flags.owndata and not a_view2.flags.writeable
-    with pytest.raises(ValueError):
-        a_view2[2, 3] = 4
-
-    a_copy1 = a.copy_get()
-    assert a_copy1.flags.owndata and a_copy1.flags.writeable
-    np.testing.assert_array_equal(a_copy1, master)
-    a_copy1[7, 7] = -44  # Shouldn't affect anything else
-    c1want = array_copy_but_one(master, 7, 7, -44)
-    a_copy2 = a.copy_view()
-    assert a_copy2.flags.owndata and a_copy2.flags.writeable
-    np.testing.assert_array_equal(a_copy2, master)
-    a_copy2[4, 4] = -22  # Shouldn't affect anything else
-    c2want = array_copy_but_one(master, 4, 4, -22)
-
-    a_ref1 = a.ref()
-    assert not a_ref1.flags.owndata and a_ref1.flags.writeable
-    assign_both(a_ref1, master, 1, 1, 15)
-    a_ref2 = a.ref_const()
-    assert not a_ref2.flags.owndata and not a_ref2.flags.writeable
-    with pytest.raises(ValueError):
-        a_ref2[5, 5] = 33
-    a_ref3 = a.ref_safe()
-    assert not a_ref3.flags.owndata and a_ref3.flags.writeable
-    assign_both(a_ref3, master, 0, 7, 99)
-    a_ref4 = a.ref_const_safe()
-    assert not a_ref4.flags.owndata and not a_ref4.flags.writeable
-    with pytest.raises(ValueError):
-        a_ref4[7, 0] = 987654321
-
-    a_copy3 = a.copy_ref()
-    assert a_copy3.flags.owndata and a_copy3.flags.writeable
-    np.testing.assert_array_equal(a_copy3, master)
-    a_copy3[8, 1] = 11
-    c3want = array_copy_but_one(master, 8, 1, 11)
-    a_copy4 = a.copy_ref_const()
-    assert a_copy4.flags.owndata and a_copy4.flags.writeable
-    np.testing.assert_array_equal(a_copy4, master)
-    a_copy4[8, 4] = 88
-    c4want = array_copy_but_one(master, 8, 4, 88)
-
-    a_block1 = a.block(3, 3, 2, 2)
-    assert not a_block1.flags.owndata and a_block1.flags.writeable
-    a_block1[0, 0] = 55
-    master[3, 3] = 55
-    a_block2 = a.block_safe(2, 2, 3, 2)
-    assert not a_block2.flags.owndata and a_block2.flags.writeable
-    a_block2[2, 1] = -123
-    master[4, 3] = -123
-    a_block3 = a.block_const(6, 7, 4, 3)
-    assert not a_block3.flags.owndata and not a_block3.flags.writeable
-    with pytest.raises(ValueError):
-        a_block3[2, 2] = -44444
-
-    a_copy5 = a.copy_block(2, 2, 2, 3)
-    assert a_copy5.flags.owndata and a_copy5.flags.writeable
-    np.testing.assert_array_equal(a_copy5, master[2:4, 2:5])
-    a_copy5[1, 1] = 777
-    c5want = array_copy_but_one(master[2:4, 2:5], 1, 1, 777)
-
-    a_corn1 = a.corners()
-    assert not a_corn1.flags.owndata and a_corn1.flags.writeable
-    a_corn1 *= 50
-    a_corn1[1, 1] = 999
-    master[0, 0] = 50
-    master[0, 9] = 50
-    master[9, 0] = 50
-    master[9, 9] = 999
-    a_corn2 = a.corners_const()
-    assert not a_corn2.flags.owndata and not a_corn2.flags.writeable
-    with pytest.raises(ValueError):
-        a_corn2[1, 0] = 51
-
-    # All of the changes made all the way along should be visible everywhere
-    # now (except for the copies, of course)
-    np.testing.assert_array_equal(a_get1, master)
-    np.testing.assert_array_equal(a_get2, master)
-    np.testing.assert_array_equal(a_view1, master)
-    np.testing.assert_array_equal(a_view2, master)
-    np.testing.assert_array_equal(a_ref1, master)
-    np.testing.assert_array_equal(a_ref2, master)
-    np.testing.assert_array_equal(a_ref3, master)
-    np.testing.assert_array_equal(a_ref4, master)
-    np.testing.assert_array_equal(a_block1, master[3:5, 3:5])
-    np.testing.assert_array_equal(a_block2, master[2:5, 2:4])
-    np.testing.assert_array_equal(a_block3, master[6:10, 7:10])
-    np.testing.assert_array_equal(a_corn1, master[0::master.shape[0] - 1, 0::master.shape[1] - 1])
-    np.testing.assert_array_equal(a_corn2, master[0::master.shape[0] - 1, 0::master.shape[1] - 1])
-
-    np.testing.assert_array_equal(a_copy1, c1want)
-    np.testing.assert_array_equal(a_copy2, c2want)
-    np.testing.assert_array_equal(a_copy3, c3want)
-    np.testing.assert_array_equal(a_copy4, c4want)
-    np.testing.assert_array_equal(a_copy5, c5want)
-
-
-def assert_keeps_alive(cl, method, *args):
-    cstats = ConstructorStats.get(cl)
-    start_with = cstats.alive()
-    a = cl()
-    assert cstats.alive() == start_with + 1
-    z = method(a, *args)
-    assert cstats.alive() == start_with + 1
-    del a
-    # Here's the keep alive in action:
-    assert cstats.alive() == start_with + 1
-    del z
-    # Keep alive should have expired:
-    assert cstats.alive() == start_with
-
-
-def test_eigen_keepalive():
-    a = m.ReturnTester()
-    cstats = ConstructorStats.get(m.ReturnTester)
-    assert cstats.alive() == 1
-    unsafe = [a.ref(), a.ref_const(), a.block(1, 2, 3, 4)]
-    copies = [a.copy_get(), a.copy_view(), a.copy_ref(), a.copy_ref_const(),
-              a.copy_block(4, 3, 2, 1)]
-    del a
-    assert cstats.alive() == 0
-    del unsafe
-    del copies
-
-    for meth in [m.ReturnTester.get, m.ReturnTester.get_ptr, m.ReturnTester.view,
-                 m.ReturnTester.view_ptr, m.ReturnTester.ref_safe, m.ReturnTester.ref_const_safe,
-                 m.ReturnTester.corners, m.ReturnTester.corners_const]:
-        assert_keeps_alive(m.ReturnTester, meth)
-
-    for meth in [m.ReturnTester.block_safe, m.ReturnTester.block_const]:
-        assert_keeps_alive(m.ReturnTester, meth, 4, 3, 2, 1)
-
-
-def test_eigen_ref_mutators():
-    """Tests Eigen's ability to mutate numpy values"""
-
-    orig = np.array([[1., 2, 3], [4, 5, 6], [7, 8, 9]])
-    zr = np.array(orig)
-    zc = np.array(orig, order='F')
-    m.add_rm(zr, 1, 0, 100)
-    assert np.all(zr == np.array([[1., 2, 3], [104, 5, 6], [7, 8, 9]]))
-    m.add_cm(zc, 1, 0, 200)
-    assert np.all(zc == np.array([[1., 2, 3], [204, 5, 6], [7, 8, 9]]))
-
-    m.add_any(zr, 1, 0, 20)
-    assert np.all(zr == np.array([[1., 2, 3], [124, 5, 6], [7, 8, 9]]))
-    m.add_any(zc, 1, 0, 10)
-    assert np.all(zc == np.array([[1., 2, 3], [214, 5, 6], [7, 8, 9]]))
-
-    # Can't reference a col-major array with a row-major Ref, and vice versa:
-    with pytest.raises(TypeError):
-        m.add_rm(zc, 1, 0, 1)
-    with pytest.raises(TypeError):
-        m.add_cm(zr, 1, 0, 1)
-
-    # Overloads:
-    m.add1(zr, 1, 0, -100)
-    m.add2(zr, 1, 0, -20)
-    assert np.all(zr == orig)
-    m.add1(zc, 1, 0, -200)
-    m.add2(zc, 1, 0, -10)
-    assert np.all(zc == orig)
-
-    # a non-contiguous slice (this won't work on either the row- or
-    # column-contiguous refs, but should work for the any)
-    cornersr = zr[0::2, 0::2]
-    cornersc = zc[0::2, 0::2]
-
-    assert np.all(cornersr == np.array([[1., 3], [7, 9]]))
-    assert np.all(cornersc == np.array([[1., 3], [7, 9]]))
-
-    with pytest.raises(TypeError):
-        m.add_rm(cornersr, 0, 1, 25)
-    with pytest.raises(TypeError):
-        m.add_cm(cornersr, 0, 1, 25)
-    with pytest.raises(TypeError):
-        m.add_rm(cornersc, 0, 1, 25)
-    with pytest.raises(TypeError):
-        m.add_cm(cornersc, 0, 1, 25)
-    m.add_any(cornersr, 0, 1, 25)
-    m.add_any(cornersc, 0, 1, 44)
-    assert np.all(zr == np.array([[1., 2, 28], [4, 5, 6], [7, 8, 9]]))
-    assert np.all(zc == np.array([[1., 2, 47], [4, 5, 6], [7, 8, 9]]))
-
-    # You shouldn't be allowed to pass a non-writeable array to a mutating Eigen method:
-    zro = zr[0:4, 0:4]
-    zro.flags.writeable = False
-    with pytest.raises(TypeError):
-        m.add_rm(zro, 0, 0, 0)
-    with pytest.raises(TypeError):
-        m.add_any(zro, 0, 0, 0)
-    with pytest.raises(TypeError):
-        m.add1(zro, 0, 0, 0)
-    with pytest.raises(TypeError):
-        m.add2(zro, 0, 0, 0)
-
-    # integer array shouldn't be passable to a double-matrix-accepting mutating func:
-    zi = np.array([[1, 2], [3, 4]])
-    with pytest.raises(TypeError):
-        m.add_rm(zi)
-
-
-def test_numpy_ref_mutators():
-    """Tests numpy mutating Eigen matrices (for returned Eigen::Ref<...>s)"""
-
-    m.reset_refs()  # In case another test already changed it
-
-    zc = m.get_cm_ref()
-    zcro = m.get_cm_const_ref()
-    zr = m.get_rm_ref()
-    zrro = m.get_rm_const_ref()
-
-    assert [zc[1, 2], zcro[1, 2], zr[1, 2], zrro[1, 2]] == [23] * 4
-
-    assert not zc.flags.owndata and zc.flags.writeable
-    assert not zr.flags.owndata and zr.flags.writeable
-    assert not zcro.flags.owndata and not zcro.flags.writeable
-    assert not zrro.flags.owndata and not zrro.flags.writeable
-
-    zc[1, 2] = 99
-    expect = np.array([[11., 12, 13], [21, 22, 99], [31, 32, 33]])
-    # We should have just changed zc, of course, but also zcro and the original eigen matrix
-    assert np.all(zc == expect)
-    assert np.all(zcro == expect)
-    assert np.all(m.get_cm_ref() == expect)
-
-    zr[1, 2] = 99
-    assert np.all(zr == expect)
-    assert np.all(zrro == expect)
-    assert np.all(m.get_rm_ref() == expect)
-
-    # Make sure the readonly ones are numpy-readonly:
-    with pytest.raises(ValueError):
-        zcro[1, 2] = 6
-    with pytest.raises(ValueError):
-        zrro[1, 2] = 6
-
-    # We should be able to explicitly copy like this (and since we're copying,
-    # the const should drop away)
-    y1 = np.array(m.get_cm_const_ref())
-
-    assert y1.flags.owndata and y1.flags.writeable
-    # We should get copies of the eigen data, which was modified above:
-    assert y1[1, 2] == 99
-    y1[1, 2] += 12
-    assert y1[1, 2] == 111
-    assert zc[1, 2] == 99  # Make sure we aren't referencing the original
-
-
-def test_both_ref_mutators():
-    """Tests a complex chain of nested eigen/numpy references"""
-
-    m.reset_refs()  # In case another test already changed it
-
-    z = m.get_cm_ref()  # numpy -> eigen
-    z[0, 2] -= 3
-    z2 = m.incr_matrix(z, 1)  # numpy -> eigen -> numpy -> eigen
-    z2[1, 1] += 6
-    z3 = m.incr_matrix(z, 2)  # (numpy -> eigen)^3
-    z3[2, 2] += -5
-    z4 = m.incr_matrix(z, 3)  # (numpy -> eigen)^4
-    z4[1, 1] -= 1
-    z5 = m.incr_matrix(z, 4)  # (numpy -> eigen)^5
-    z5[0, 0] = 0
-    assert np.all(z == z2)
-    assert np.all(z == z3)
-    assert np.all(z == z4)
-    assert np.all(z == z5)
-    expect = np.array([[0., 22, 20], [31, 37, 33], [41, 42, 38]])
-    assert np.all(z == expect)
-
-    y = np.array(range(100), dtype='float64').reshape(10, 10)
-    y2 = m.incr_matrix_any(y, 10)  # np -> eigen -> np
-    y3 = m.incr_matrix_any(y2[0::2, 0::2], -33)  # np -> eigen -> np slice -> np -> eigen -> np
-    y4 = m.even_rows(y3)  # numpy -> eigen slice -> (... y3)
-    y5 = m.even_cols(y4)  # numpy -> eigen slice -> (... y4)
-    y6 = m.incr_matrix_any(y5, 1000)  # numpy -> eigen -> (... y5)
-
-    # Apply same mutations using just numpy:
-    yexpect = np.array(range(100), dtype='float64').reshape(10, 10)
-    yexpect += 10
-    yexpect[0::2, 0::2] -= 33
-    yexpect[0::4, 0::4] += 1000
-    assert np.all(y6 == yexpect[0::4, 0::4])
-    assert np.all(y5 == yexpect[0::4, 0::4])
-    assert np.all(y4 == yexpect[0::4, 0::2])
-    assert np.all(y3 == yexpect[0::2, 0::2])
-    assert np.all(y2 == yexpect)
-    assert np.all(y == yexpect)
-
-
-def test_nocopy_wrapper():
-    # get_elem requires a column-contiguous matrix reference, but should be
-    # callable with other types of matrix (via copying):
-    int_matrix_colmajor = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], order='F')
-    dbl_matrix_colmajor = np.array(int_matrix_colmajor, dtype='double', order='F', copy=True)
-    int_matrix_rowmajor = np.array(int_matrix_colmajor, order='C', copy=True)
-    dbl_matrix_rowmajor = np.array(int_matrix_rowmajor, dtype='double', order='C', copy=True)
-
-    # All should be callable via get_elem:
-    assert m.get_elem(int_matrix_colmajor) == 8
-    assert m.get_elem(dbl_matrix_colmajor) == 8
-    assert m.get_elem(int_matrix_rowmajor) == 8
-    assert m.get_elem(dbl_matrix_rowmajor) == 8
-
-    # All but the second should fail with m.get_elem_nocopy:
-    with pytest.raises(TypeError) as excinfo:
-        m.get_elem_nocopy(int_matrix_colmajor)
-    assert ('get_elem_nocopy(): incompatible function arguments.' in str(excinfo.value) and
-            ', flags.f_contiguous' in str(excinfo.value))
-    assert m.get_elem_nocopy(dbl_matrix_colmajor) == 8
-    with pytest.raises(TypeError) as excinfo:
-        m.get_elem_nocopy(int_matrix_rowmajor)
-    assert ('get_elem_nocopy(): incompatible function arguments.' in str(excinfo.value) and
-            ', flags.f_contiguous' in str(excinfo.value))
-    with pytest.raises(TypeError) as excinfo:
-        m.get_elem_nocopy(dbl_matrix_rowmajor)
-    assert ('get_elem_nocopy(): incompatible function arguments.' in str(excinfo.value) and
-            ', flags.f_contiguous' in str(excinfo.value))
-
-    # For the row-major test, we take a long matrix in row-major, so only the third is allowed:
-    with pytest.raises(TypeError) as excinfo:
-        m.get_elem_rm_nocopy(int_matrix_colmajor)
-    assert ('get_elem_rm_nocopy(): incompatible function arguments.' in str(excinfo.value) and
-            ', flags.c_contiguous' in str(excinfo.value))
-    with pytest.raises(TypeError) as excinfo:
-        m.get_elem_rm_nocopy(dbl_matrix_colmajor)
-    assert ('get_elem_rm_nocopy(): incompatible function arguments.' in str(excinfo.value) and
-            ', flags.c_contiguous' in str(excinfo.value))
-    assert m.get_elem_rm_nocopy(int_matrix_rowmajor) == 8
-    with pytest.raises(TypeError) as excinfo:
-        m.get_elem_rm_nocopy(dbl_matrix_rowmajor)
-    assert ('get_elem_rm_nocopy(): incompatible function arguments.' in str(excinfo.value) and
-            ', flags.c_contiguous' in str(excinfo.value))
-
-
-def test_eigen_ref_life_support():
-    """Ensure the lifetime of temporary arrays created by the `Ref` caster
-
-    The `Ref` caster sometimes creates a copy which needs to stay alive. This needs to
-    happen both for directs casts (just the array) or indirectly (e.g. list of arrays).
-    """
-
-    a = np.full(shape=10, fill_value=8, dtype=np.int8)
-    assert m.get_elem_direct(a) == 8
-
-    list_of_a = [a]
-    assert m.get_elem_indirect(list_of_a) == 8
-
-
-def test_special_matrix_objects():
-    assert np.all(m.incr_diag(7) == np.diag([1., 2, 3, 4, 5, 6, 7]))
-
-    asymm = np.array([[ 1.,  2,  3,  4],
-                      [ 5,  6,  7,  8],
-                      [ 9, 10, 11, 12],
-                      [13, 14, 15, 16]])
-    symm_lower = np.array(asymm)
-    symm_upper = np.array(asymm)
-    for i in range(4):
-        for j in range(i + 1, 4):
-            symm_lower[i, j] = symm_lower[j, i]
-            symm_upper[j, i] = symm_upper[i, j]
-
-    assert np.all(m.symmetric_lower(asymm) == symm_lower)
-    assert np.all(m.symmetric_upper(asymm) == symm_upper)
-
-
-def test_dense_signature(doc):
-    assert doc(m.double_col) == """
-        double_col(arg0: numpy.ndarray[float32[m, 1]]) -> numpy.ndarray[float32[m, 1]]
-    """
-    assert doc(m.double_row) == """
-        double_row(arg0: numpy.ndarray[float32[1, n]]) -> numpy.ndarray[float32[1, n]]
-    """
-    assert doc(m.double_complex) == """
-        double_complex(arg0: numpy.ndarray[complex64[m, 1]]) -> numpy.ndarray[complex64[m, 1]]
-    """
-    assert doc(m.double_mat_rm) == """
-        double_mat_rm(arg0: numpy.ndarray[float32[m, n]]) -> numpy.ndarray[float32[m, n]]
-    """
-
-
-def test_named_arguments():
-    a = np.array([[1.0, 2], [3, 4], [5, 6]])
-    b = np.ones((2, 1))
-
-    assert np.all(m.matrix_multiply(a, b) == np.array([[3.], [7], [11]]))
-    assert np.all(m.matrix_multiply(A=a, B=b) == np.array([[3.], [7], [11]]))
-    assert np.all(m.matrix_multiply(B=b, A=a) == np.array([[3.], [7], [11]]))
-
-    with pytest.raises(ValueError) as excinfo:
-        m.matrix_multiply(b, a)
-    assert str(excinfo.value) == 'Nonconformable matrices!'
-
-    with pytest.raises(ValueError) as excinfo:
-        m.matrix_multiply(A=b, B=a)
-    assert str(excinfo.value) == 'Nonconformable matrices!'
-
-    with pytest.raises(ValueError) as excinfo:
-        m.matrix_multiply(B=a, A=b)
-    assert str(excinfo.value) == 'Nonconformable matrices!'
-
-
-@pytest.requires_eigen_and_scipy
-def test_sparse():
-    assert_sparse_equal_ref(m.sparse_r())
-    assert_sparse_equal_ref(m.sparse_c())
-    assert_sparse_equal_ref(m.sparse_copy_r(m.sparse_r()))
-    assert_sparse_equal_ref(m.sparse_copy_c(m.sparse_c()))
-    assert_sparse_equal_ref(m.sparse_copy_r(m.sparse_c()))
-    assert_sparse_equal_ref(m.sparse_copy_c(m.sparse_r()))
-
-
-@pytest.requires_eigen_and_scipy
-def test_sparse_signature(doc):
-    assert doc(m.sparse_copy_r) == """
-        sparse_copy_r(arg0: scipy.sparse.csr_matrix[float32]) -> scipy.sparse.csr_matrix[float32]
-    """  # noqa: E501 line too long
-    assert doc(m.sparse_copy_c) == """
-        sparse_copy_c(arg0: scipy.sparse.csc_matrix[float32]) -> scipy.sparse.csc_matrix[float32]
-    """  # noqa: E501 line too long
-
-
-def test_issue738():
-    """Ignore strides on a length-1 dimension (even if they would be incompatible length > 1)"""
-    assert np.all(m.iss738_f1(np.array([[1., 2, 3]])) == np.array([[1., 102, 203]]))
-    assert np.all(m.iss738_f1(np.array([[1.], [2], [3]])) == np.array([[1.], [12], [23]]))
-
-    assert np.all(m.iss738_f2(np.array([[1., 2, 3]])) == np.array([[1., 102, 203]]))
-    assert np.all(m.iss738_f2(np.array([[1.], [2], [3]])) == np.array([[1.], [12], [23]]))
-
-
-def test_custom_operator_new():
-    """Using Eigen types as member variables requires a class-specific
-    operator new with proper alignment"""
-
-    o = m.CustomOperatorNew()
-    np.testing.assert_allclose(o.a, 0.0)
-    np.testing.assert_allclose(o.b.diagonal(), 1.0)
diff --git a/tmap/lib/pybind11/tests/test_embed/CMakeLists.txt b/tmap/lib/pybind11/tests/test_embed/CMakeLists.txt
deleted file mode 100644
index 0a43e0e..0000000
--- a/tmap/lib/pybind11/tests/test_embed/CMakeLists.txt
+++ /dev/null
@@ -1,34 +0,0 @@
-if(${PYTHON_MODULE_EXTENSION} MATCHES "pypy")
-  add_custom_target(cpptest)  # Dummy target on PyPy. Embedding is not supported.
-  set(_suppress_unused_variable_warning "${DOWNLOAD_CATCH}")
-  return()
-endif()
-
-find_package(Catch 1.9.3)
-if(NOT CATCH_FOUND)
-  message(STATUS "Catch not detected. Interpreter tests will be skipped. Install Catch headers"
-                 " manually or use `cmake -DDOWNLOAD_CATCH=1` to fetch them automatically.")
-  return()
-endif()
-
-add_executable(test_embed
-  catch.cpp
-  test_interpreter.cpp
-)
-target_include_directories(test_embed PRIVATE ${CATCH_INCLUDE_DIR})
-pybind11_enable_warnings(test_embed)
-
-if(NOT CMAKE_VERSION VERSION_LESS 3.0)
-  target_link_libraries(test_embed PRIVATE pybind11::embed)
-else()
-  target_include_directories(test_embed PRIVATE ${PYBIND11_INCLUDE_DIR} ${PYTHON_INCLUDE_DIRS})
-  target_compile_options(test_embed PRIVATE ${PYBIND11_CPP_STANDARD})
-  target_link_libraries(test_embed PRIVATE ${PYTHON_LIBRARIES})
-endif()
-
-find_package(Threads REQUIRED)
-target_link_libraries(test_embed PUBLIC ${CMAKE_THREAD_LIBS_INIT})
-
-add_custom_target(cpptest COMMAND $<TARGET_FILE:test_embed>
-                  WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
-add_dependencies(check cpptest)
diff --git a/tmap/lib/pybind11/tests/test_embed/catch.cpp b/tmap/lib/pybind11/tests/test_embed/catch.cpp
deleted file mode 100644
index cface48..0000000
--- a/tmap/lib/pybind11/tests/test_embed/catch.cpp
+++ /dev/null
@@ -1,16 +0,0 @@
-// The Catch implementation is compiled here. This is a standalone
-// translation unit to avoid recompiling it for every test change.
-
-#include <pybind11/embed.h>
-
-#define CATCH_CONFIG_RUNNER
-#include <catch.hpp>
-
-namespace py = pybind11;
-
-int main(int argc, const char *argv[]) {
-    py::scoped_interpreter guard{};
-    auto result = Catch::Session().run(argc, argv);
-
-    return result < 0xff ? result : 0xff;
-}
diff --git a/tmap/lib/pybind11/tests/test_embed/test_interpreter.cpp b/tmap/lib/pybind11/tests/test_embed/test_interpreter.cpp
deleted file mode 100644
index acbad6b..0000000
--- a/tmap/lib/pybind11/tests/test_embed/test_interpreter.cpp
+++ /dev/null
@@ -1,218 +0,0 @@
-#include <pybind11/embed.h>
-#include <catch.hpp>
-
-#include <thread>
-
-namespace py = pybind11;
-using namespace py::literals;
-
-class Widget {
-public:
-    Widget(std::string message) : message(message) { }
-    virtual ~Widget() = default;
-
-    std::string the_message() const { return message; }
-    virtual int the_answer() const = 0;
-
-private:
-    std::string message;
-};
-
-class PyWidget final : public Widget {
-    using Widget::Widget;
-
-    int the_answer() const override { PYBIND11_OVERLOAD_PURE(int, Widget, the_answer); }
-};
-
-PYBIND11_EMBEDDED_MODULE(widget_module, m) {
-    py::class_<Widget, PyWidget>(m, "Widget")
-        .def(py::init<std::string>())
-        .def_property_readonly("the_message", &Widget::the_message);
-
-    m.def("add", [](int i, int j) { return i + j; });
-}
-
-PYBIND11_EMBEDDED_MODULE(throw_exception, ) {
-    throw std::runtime_error("C++ Error");
-}
-
-PYBIND11_EMBEDDED_MODULE(throw_error_already_set, ) {
-    auto d = py::dict();
-    d["missing"].cast<py::object>();
-}
-
-TEST_CASE("Pass classes and data between modules defined in C++ and Python") {
-    auto module = py::module::import("test_interpreter");
-    REQUIRE(py::hasattr(module, "DerivedWidget"));
-
-    auto locals = py::dict("hello"_a="Hello, World!", "x"_a=5, **module.attr("__dict__"));
-    py::exec(R"(
-        widget = DerivedWidget("{} - {}".format(hello, x))
-        message = widget.the_message
-    )", py::globals(), locals);
-    REQUIRE(locals["message"].cast<std::string>() == "Hello, World! - 5");
-
-    auto py_widget = module.attr("DerivedWidget")("The question");
-    auto message = py_widget.attr("the_message");
-    REQUIRE(message.cast<std::string>() == "The question");
-
-    const auto &cpp_widget = py_widget.cast<const Widget &>();
-    REQUIRE(cpp_widget.the_answer() == 42);
-}
-
-TEST_CASE("Import error handling") {
-    REQUIRE_NOTHROW(py::module::import("widget_module"));
-    REQUIRE_THROWS_WITH(py::module::import("throw_exception"),
-                        "ImportError: C++ Error");
-    REQUIRE_THROWS_WITH(py::module::import("throw_error_already_set"),
-                        Catch::Contains("ImportError: KeyError"));
-}
-
-TEST_CASE("There can be only one interpreter") {
-    static_assert(std::is_move_constructible<py::scoped_interpreter>::value, "");
-    static_assert(!std::is_move_assignable<py::scoped_interpreter>::value, "");
-    static_assert(!std::is_copy_constructible<py::scoped_interpreter>::value, "");
-    static_assert(!std::is_copy_assignable<py::scoped_interpreter>::value, "");
-
-    REQUIRE_THROWS_WITH(py::initialize_interpreter(), "The interpreter is already running");
-    REQUIRE_THROWS_WITH(py::scoped_interpreter(), "The interpreter is already running");
-
-    py::finalize_interpreter();
-    REQUIRE_NOTHROW(py::scoped_interpreter());
-    {
-        auto pyi1 = py::scoped_interpreter();
-        auto pyi2 = std::move(pyi1);
-    }
-    py::initialize_interpreter();
-}
-
-bool has_pybind11_internals_builtin() {
-    auto builtins = py::handle(PyEval_GetBuiltins());
-    return builtins.contains(PYBIND11_INTERNALS_ID);
-};
-
-bool has_pybind11_internals_static() {
-    return py::detail::get_internals_ptr() != nullptr;
-}
-
-TEST_CASE("Restart the interpreter") {
-    // Verify pre-restart state.
-    REQUIRE(py::module::import("widget_module").attr("add")(1, 2).cast<int>() == 3);
-    REQUIRE(has_pybind11_internals_builtin());
-    REQUIRE(has_pybind11_internals_static());
-
-    // Restart the interpreter.
-    py::finalize_interpreter();
-    REQUIRE(Py_IsInitialized() == 0);
-
-    py::initialize_interpreter();
-    REQUIRE(Py_IsInitialized() == 1);
-
-    // Internals are deleted after a restart.
-    REQUIRE_FALSE(has_pybind11_internals_builtin());
-    REQUIRE_FALSE(has_pybind11_internals_static());
-    pybind11::detail::get_internals();
-    REQUIRE(has_pybind11_internals_builtin());
-    REQUIRE(has_pybind11_internals_static());
-
-    // Make sure that an interpreter with no get_internals() created until finalize still gets the
-    // internals destroyed
-    py::finalize_interpreter();
-    py::initialize_interpreter();
-    bool ran = false;
-    py::module::import("__main__").attr("internals_destroy_test") =
-        py::capsule(&ran, [](void *ran) { py::detail::get_internals(); *static_cast<bool *>(ran) = true; });
-    REQUIRE_FALSE(has_pybind11_internals_builtin());
-    REQUIRE_FALSE(has_pybind11_internals_static());
-    REQUIRE_FALSE(ran);
-    py::finalize_interpreter();
-    REQUIRE(ran);
-    py::initialize_interpreter();
-    REQUIRE_FALSE(has_pybind11_internals_builtin());
-    REQUIRE_FALSE(has_pybind11_internals_static());
-
-    // C++ modules can be reloaded.
-    auto cpp_module = py::module::import("widget_module");
-    REQUIRE(cpp_module.attr("add")(1, 2).cast<int>() == 3);
-
-    // C++ type information is reloaded and can be used in python modules.
-    auto py_module = py::module::import("test_interpreter");
-    auto py_widget = py_module.attr("DerivedWidget")("Hello after restart");
-    REQUIRE(py_widget.attr("the_message").cast<std::string>() == "Hello after restart");
-}
-
-TEST_CASE("Subinterpreter") {
-    // Add tags to the modules in the main interpreter and test the basics.
-    py::module::import("__main__").attr("main_tag") = "main interpreter";
-    {
-        auto m = py::module::import("widget_module");
-        m.attr("extension_module_tag") = "added to module in main interpreter";
-
-        REQUIRE(m.attr("add")(1, 2).cast<int>() == 3);
-    }
-    REQUIRE(has_pybind11_internals_builtin());
-    REQUIRE(has_pybind11_internals_static());
-
-    /// Create and switch to a subinterpreter.
-    auto main_tstate = PyThreadState_Get();
-    auto sub_tstate = Py_NewInterpreter();
-
-    // Subinterpreters get their own copy of builtins. detail::get_internals() still
-    // works by returning from the static variable, i.e. all interpreters share a single
-    // global pybind11::internals;
-    REQUIRE_FALSE(has_pybind11_internals_builtin());
-    REQUIRE(has_pybind11_internals_static());
-
-    // Modules tags should be gone.
-    REQUIRE_FALSE(py::hasattr(py::module::import("__main__"), "tag"));
-    {
-        auto m = py::module::import("widget_module");
-        REQUIRE_FALSE(py::hasattr(m, "extension_module_tag"));
-
-        // Function bindings should still work.
-        REQUIRE(m.attr("add")(1, 2).cast<int>() == 3);
-    }
-
-    // Restore main interpreter.
-    Py_EndInterpreter(sub_tstate);
-    PyThreadState_Swap(main_tstate);
-
-    REQUIRE(py::hasattr(py::module::import("__main__"), "main_tag"));
-    REQUIRE(py::hasattr(py::module::import("widget_module"), "extension_module_tag"));
-}
-
-TEST_CASE("Execution frame") {
-    // When the interpreter is embedded, there is no execution frame, but `py::exec`
-    // should still function by using reasonable globals: `__main__.__dict__`.
-    py::exec("var = dict(number=42)");
-    REQUIRE(py::globals()["var"]["number"].cast<int>() == 42);
-}
-
-TEST_CASE("Threads") {
-    // Restart interpreter to ensure threads are not initialized
-    py::finalize_interpreter();
-    py::initialize_interpreter();
-    REQUIRE_FALSE(has_pybind11_internals_static());
-
-    constexpr auto num_threads = 10;
-    auto locals = py::dict("count"_a=0);
-
-    {
-        py::gil_scoped_release gil_release{};
-        REQUIRE(has_pybind11_internals_static());
-
-        auto threads = std::vector<std::thread>();
-        for (auto i = 0; i < num_threads; ++i) {
-            threads.emplace_back([&]() {
-                py::gil_scoped_acquire gil{};
-                locals["count"] = locals["count"].cast<int>() + 1;
-            });
-        }
-
-        for (auto &thread : threads) {
-            thread.join();
-        }
-    }
-
-    REQUIRE(locals["count"].cast<int>() == num_threads);
-}
diff --git a/tmap/lib/pybind11/tests/test_embed/test_interpreter.py b/tmap/lib/pybind11/tests/test_embed/test_interpreter.py
deleted file mode 100644
index 26a0479..0000000
--- a/tmap/lib/pybind11/tests/test_embed/test_interpreter.py
+++ /dev/null
@@ -1,9 +0,0 @@
-from widget_module import Widget
-
-
-class DerivedWidget(Widget):
-    def __init__(self, message):
-        super(DerivedWidget, self).__init__(message)
-
-    def the_answer(self):
-        return 42
diff --git a/tmap/lib/pybind11/tests/test_enum.cpp b/tmap/lib/pybind11/tests/test_enum.cpp
deleted file mode 100644
index 49f31ba..0000000
--- a/tmap/lib/pybind11/tests/test_enum.cpp
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
-    tests/test_enums.cpp -- enumerations
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-
-TEST_SUBMODULE(enums, m) {
-    // test_unscoped_enum
-    enum UnscopedEnum {
-        EOne = 1,
-        ETwo
-    };
-    py::enum_<UnscopedEnum>(m, "UnscopedEnum", py::arithmetic())
-        .value("EOne", EOne)
-        .value("ETwo", ETwo)
-        .export_values();
-
-    // test_scoped_enum
-    enum class ScopedEnum {
-        Two = 2,
-        Three
-    };
-    py::enum_<ScopedEnum>(m, "ScopedEnum", py::arithmetic())
-        .value("Two", ScopedEnum::Two)
-        .value("Three", ScopedEnum::Three);
-
-    m.def("test_scoped_enum", [](ScopedEnum z) {
-        return "ScopedEnum::" + std::string(z == ScopedEnum::Two ? "Two" : "Three");
-    });
-
-    // test_binary_operators
-    enum Flags {
-        Read = 4,
-        Write = 2,
-        Execute = 1
-    };
-    py::enum_<Flags>(m, "Flags", py::arithmetic())
-        .value("Read", Flags::Read)
-        .value("Write", Flags::Write)
-        .value("Execute", Flags::Execute)
-        .export_values();
-
-    // test_implicit_conversion
-    class ClassWithUnscopedEnum {
-    public:
-        enum EMode {
-            EFirstMode = 1,
-            ESecondMode
-        };
-
-        static EMode test_function(EMode mode) {
-            return mode;
-        }
-    };
-    py::class_<ClassWithUnscopedEnum> exenum_class(m, "ClassWithUnscopedEnum");
-    exenum_class.def_static("test_function", &ClassWithUnscopedEnum::test_function);
-    py::enum_<ClassWithUnscopedEnum::EMode>(exenum_class, "EMode")
-        .value("EFirstMode", ClassWithUnscopedEnum::EFirstMode)
-        .value("ESecondMode", ClassWithUnscopedEnum::ESecondMode)
-        .export_values();
-
-    // test_enum_to_int
-    m.def("test_enum_to_int", [](int) { });
-    m.def("test_enum_to_uint", [](uint32_t) { });
-    m.def("test_enum_to_long_long", [](long long) { });
-}
diff --git a/tmap/lib/pybind11/tests/test_enum.py b/tmap/lib/pybind11/tests/test_enum.py
deleted file mode 100644
index d8eff52..0000000
--- a/tmap/lib/pybind11/tests/test_enum.py
+++ /dev/null
@@ -1,121 +0,0 @@
-import pytest
-from pybind11_tests import enums as m
-
-
-def test_unscoped_enum():
-    assert str(m.UnscopedEnum.EOne) == "UnscopedEnum.EOne"
-    assert str(m.UnscopedEnum.ETwo) == "UnscopedEnum.ETwo"
-    assert str(m.EOne) == "UnscopedEnum.EOne"
-    # __members__ property
-    assert m.UnscopedEnum.__members__ == \
-        {"EOne": m.UnscopedEnum.EOne, "ETwo": m.UnscopedEnum.ETwo}
-    # __members__ readonly
-    with pytest.raises(AttributeError):
-        m.UnscopedEnum.__members__ = {}
-    # __members__ returns a copy
-    foo = m.UnscopedEnum.__members__
-    foo["bar"] = "baz"
-    assert m.UnscopedEnum.__members__ == \
-        {"EOne": m.UnscopedEnum.EOne, "ETwo": m.UnscopedEnum.ETwo}
-
-    # no TypeError exception for unscoped enum ==/!= int comparisons
-    y = m.UnscopedEnum.ETwo
-    assert y == 2
-    assert y != 3
-
-    assert int(m.UnscopedEnum.ETwo) == 2
-    assert str(m.UnscopedEnum(2)) == "UnscopedEnum.ETwo"
-
-    # order
-    assert m.UnscopedEnum.EOne < m.UnscopedEnum.ETwo
-    assert m.UnscopedEnum.EOne < 2
-    assert m.UnscopedEnum.ETwo > m.UnscopedEnum.EOne
-    assert m.UnscopedEnum.ETwo > 1
-    assert m.UnscopedEnum.ETwo <= 2
-    assert m.UnscopedEnum.ETwo >= 2
-    assert m.UnscopedEnum.EOne <= m.UnscopedEnum.ETwo
-    assert m.UnscopedEnum.EOne <= 2
-    assert m.UnscopedEnum.ETwo >= m.UnscopedEnum.EOne
-    assert m.UnscopedEnum.ETwo >= 1
-    assert not (m.UnscopedEnum.ETwo < m.UnscopedEnum.EOne)
-    assert not (2 < m.UnscopedEnum.EOne)
-
-
-def test_scoped_enum():
-    assert m.test_scoped_enum(m.ScopedEnum.Three) == "ScopedEnum::Three"
-    z = m.ScopedEnum.Two
-    assert m.test_scoped_enum(z) == "ScopedEnum::Two"
-
-    # expected TypeError exceptions for scoped enum ==/!= int comparisons
-    with pytest.raises(TypeError):
-        assert z == 2
-    with pytest.raises(TypeError):
-        assert z != 3
-
-    # order
-    assert m.ScopedEnum.Two < m.ScopedEnum.Three
-    assert m.ScopedEnum.Three > m.ScopedEnum.Two
-    assert m.ScopedEnum.Two <= m.ScopedEnum.Three
-    assert m.ScopedEnum.Two <= m.ScopedEnum.Two
-    assert m.ScopedEnum.Two >= m.ScopedEnum.Two
-    assert m.ScopedEnum.Three >= m.ScopedEnum.Two
-
-
-def test_implicit_conversion():
-    assert str(m.ClassWithUnscopedEnum.EMode.EFirstMode) == "EMode.EFirstMode"
-    assert str(m.ClassWithUnscopedEnum.EFirstMode) == "EMode.EFirstMode"
-
-    f = m.ClassWithUnscopedEnum.test_function
-    first = m.ClassWithUnscopedEnum.EFirstMode
-    second = m.ClassWithUnscopedEnum.ESecondMode
-
-    assert f(first) == 1
-
-    assert f(first) == f(first)
-    assert not f(first) != f(first)
-
-    assert f(first) != f(second)
-    assert not f(first) == f(second)
-
-    assert f(first) == int(f(first))
-    assert not f(first) != int(f(first))
-
-    assert f(first) != int(f(second))
-    assert not f(first) == int(f(second))
-
-    # noinspection PyDictCreation
-    x = {f(first): 1, f(second): 2}
-    x[f(first)] = 3
-    x[f(second)] = 4
-    # Hashing test
-    assert str(x) == "{EMode.EFirstMode: 3, EMode.ESecondMode: 4}"
-
-
-def test_binary_operators():
-    assert int(m.Flags.Read) == 4
-    assert int(m.Flags.Write) == 2
-    assert int(m.Flags.Execute) == 1
-    assert int(m.Flags.Read | m.Flags.Write | m.Flags.Execute) == 7
-    assert int(m.Flags.Read | m.Flags.Write) == 6
-    assert int(m.Flags.Read | m.Flags.Execute) == 5
-    assert int(m.Flags.Write | m.Flags.Execute) == 3
-    assert int(m.Flags.Write | 1) == 3
-
-    state = m.Flags.Read | m.Flags.Write
-    assert (state & m.Flags.Read) != 0
-    assert (state & m.Flags.Write) != 0
-    assert (state & m.Flags.Execute) == 0
-    assert (state & 1) == 0
-
-    state2 = ~state
-    assert state2 == -7
-    assert int(state ^ state2) == -1
-
-
-def test_enum_to_int():
-    m.test_enum_to_int(m.Flags.Read)
-    m.test_enum_to_int(m.ClassWithUnscopedEnum.EMode.EFirstMode)
-    m.test_enum_to_uint(m.Flags.Read)
-    m.test_enum_to_uint(m.ClassWithUnscopedEnum.EMode.EFirstMode)
-    m.test_enum_to_long_long(m.Flags.Read)
-    m.test_enum_to_long_long(m.ClassWithUnscopedEnum.EMode.EFirstMode)
diff --git a/tmap/lib/pybind11/tests/test_eval.cpp b/tmap/lib/pybind11/tests/test_eval.cpp
deleted file mode 100644
index e094821..0000000
--- a/tmap/lib/pybind11/tests/test_eval.cpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
-    tests/test_eval.cpp -- Usage of eval() and eval_file()
-
-    Copyright (c) 2016 Klemens D. Morgenstern
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-
-#include <pybind11/eval.h>
-#include "pybind11_tests.h"
-
-TEST_SUBMODULE(eval_, m) {
-    // test_evals
-
-    auto global = py::dict(py::module::import("__main__").attr("__dict__"));
-
-    m.def("test_eval_statements", [global]() {
-        auto local = py::dict();
-        local["call_test"] = py::cpp_function([&]() -> int {
-            return 42;
-        });
-
-        // Regular string literal
-        py::exec(
-            "message = 'Hello World!'\n"
-            "x = call_test()",
-            global, local
-        );
-
-        // Multi-line raw string literal
-        py::exec(R"(
-            if x == 42:
-                print(message)
-            else:
-                raise RuntimeError
-            )", global, local
-        );
-        auto x = local["x"].cast<int>();
-
-        return x == 42;
-    });
-
-    m.def("test_eval", [global]() {
-        auto local = py::dict();
-        local["x"] = py::int_(42);
-        auto x = py::eval("x", global, local);
-        return x.cast<int>() == 42;
-    });
-
-    m.def("test_eval_single_statement", []() {
-        auto local = py::dict();
-        local["call_test"] = py::cpp_function([&]() -> int {
-            return 42;
-        });
-
-        auto result = py::eval<py::eval_single_statement>("x = call_test()", py::dict(), local);
-        auto x = local["x"].cast<int>();
-        return result.is_none() && x == 42;
-    });
-
-    m.def("test_eval_file", [global](py::str filename) {
-        auto local = py::dict();
-        local["y"] = py::int_(43);
-
-        int val_out;
-        local["call_test2"] = py::cpp_function([&](int value) { val_out = value; });
-
-        auto result = py::eval_file(filename, global, local);
-        return val_out == 43 && result.is_none();
-    });
-
-    m.def("test_eval_failure", []() {
-        try {
-            py::eval("nonsense code ...");
-        } catch (py::error_already_set &) {
-            return true;
-        }
-        return false;
-    });
-
-    m.def("test_eval_file_failure", []() {
-        try {
-            py::eval_file("non-existing file");
-        } catch (std::exception &) {
-            return true;
-        }
-        return false;
-    });
-}
diff --git a/tmap/lib/pybind11/tests/test_eval.py b/tmap/lib/pybind11/tests/test_eval.py
deleted file mode 100644
index bda4ef6..0000000
--- a/tmap/lib/pybind11/tests/test_eval.py
+++ /dev/null
@@ -1,17 +0,0 @@
-import os
-from pybind11_tests import eval_ as m
-
-
-def test_evals(capture):
-    with capture:
-        assert m.test_eval_statements()
-    assert capture == "Hello World!"
-
-    assert m.test_eval()
-    assert m.test_eval_single_statement()
-
-    filename = os.path.join(os.path.dirname(__file__), "test_eval_call.py")
-    assert m.test_eval_file(filename)
-
-    assert m.test_eval_failure()
-    assert m.test_eval_file_failure()
diff --git a/tmap/lib/pybind11/tests/test_eval_call.py b/tmap/lib/pybind11/tests/test_eval_call.py
deleted file mode 100644
index 53c7e72..0000000
--- a/tmap/lib/pybind11/tests/test_eval_call.py
+++ /dev/null
@@ -1,4 +0,0 @@
-# This file is called from 'test_eval.py'
-
-if 'call_test2' in locals():
-    call_test2(y)  # noqa: F821 undefined name
diff --git a/tmap/lib/pybind11/tests/test_exceptions.cpp b/tmap/lib/pybind11/tests/test_exceptions.cpp
deleted file mode 100644
index ae28abb..0000000
--- a/tmap/lib/pybind11/tests/test_exceptions.cpp
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
-    tests/test_custom-exceptions.cpp -- exception translation
-
-    Copyright (c) 2016 Pim Schellart <P.Schellart@princeton.edu>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-
-// A type that should be raised as an exeption in Python
-class MyException : public std::exception {
-public:
-    explicit MyException(const char * m) : message{m} {}
-    virtual const char * what() const noexcept override {return message.c_str();}
-private:
-    std::string message = "";
-};
-
-// A type that should be translated to a standard Python exception
-class MyException2 : public std::exception {
-public:
-    explicit MyException2(const char * m) : message{m} {}
-    virtual const char * what() const noexcept override {return message.c_str();}
-private:
-    std::string message = "";
-};
-
-// A type that is not derived from std::exception (and is thus unknown)
-class MyException3 {
-public:
-    explicit MyException3(const char * m) : message{m} {}
-    virtual const char * what() const noexcept {return message.c_str();}
-private:
-    std::string message = "";
-};
-
-// A type that should be translated to MyException
-// and delegated to its exception translator
-class MyException4 : public std::exception {
-public:
-    explicit MyException4(const char * m) : message{m} {}
-    virtual const char * what() const noexcept override {return message.c_str();}
-private:
-    std::string message = "";
-};
-
-
-// Like the above, but declared via the helper function
-class MyException5 : public std::logic_error {
-public:
-    explicit MyException5(const std::string &what) : std::logic_error(what) {}
-};
-
-// Inherits from MyException5
-class MyException5_1 : public MyException5 {
-    using MyException5::MyException5;
-};
-
-struct PythonCallInDestructor {
-    PythonCallInDestructor(const py::dict &d) : d(d) {}
-    ~PythonCallInDestructor() { d["good"] = true; }
-
-    py::dict d;
-};
-
-TEST_SUBMODULE(exceptions, m) {
-    m.def("throw_std_exception", []() {
-        throw std::runtime_error("This exception was intentionally thrown.");
-    });
-
-    // make a new custom exception and use it as a translation target
-    static py::exception<MyException> ex(m, "MyException");
-    py::register_exception_translator([](std::exception_ptr p) {
-        try {
-            if (p) std::rethrow_exception(p);
-        } catch (const MyException &e) {
-            // Set MyException as the active python error
-            ex(e.what());
-        }
-    });
-
-    // register new translator for MyException2
-    // no need to store anything here because this type will
-    // never by visible from Python
-    py::register_exception_translator([](std::exception_ptr p) {
-        try {
-            if (p) std::rethrow_exception(p);
-        } catch (const MyException2 &e) {
-            // Translate this exception to a standard RuntimeError
-            PyErr_SetString(PyExc_RuntimeError, e.what());
-        }
-    });
-
-    // register new translator for MyException4
-    // which will catch it and delegate to the previously registered
-    // translator for MyException by throwing a new exception
-    py::register_exception_translator([](std::exception_ptr p) {
-        try {
-            if (p) std::rethrow_exception(p);
-        } catch (const MyException4 &e) {
-            throw MyException(e.what());
-        }
-    });
-
-    // A simple exception translation:
-    auto ex5 = py::register_exception<MyException5>(m, "MyException5");
-    // A slightly more complicated one that declares MyException5_1 as a subclass of MyException5
-    py::register_exception<MyException5_1>(m, "MyException5_1", ex5.ptr());
-
-    m.def("throws1", []() { throw MyException("this error should go to a custom type"); });
-    m.def("throws2", []() { throw MyException2("this error should go to a standard Python exception"); });
-    m.def("throws3", []() { throw MyException3("this error cannot be translated"); });
-    m.def("throws4", []() { throw MyException4("this error is rethrown"); });
-    m.def("throws5", []() { throw MyException5("this is a helper-defined translated exception"); });
-    m.def("throws5_1", []() { throw MyException5_1("MyException5 subclass"); });
-    m.def("throws_logic_error", []() { throw std::logic_error("this error should fall through to the standard handler"); });
-    m.def("exception_matches", []() {
-        py::dict foo;
-        try { foo["bar"]; }
-        catch (py::error_already_set& ex) {
-            if (!ex.matches(PyExc_KeyError)) throw;
-        }
-    });
-
-    m.def("throw_already_set", [](bool err) {
-        if (err)
-            PyErr_SetString(PyExc_ValueError, "foo");
-        try {
-            throw py::error_already_set();
-        } catch (const std::runtime_error& e) {
-            if ((err && e.what() != std::string("ValueError: foo")) ||
-                (!err && e.what() != std::string("Unknown internal error occurred")))
-            {
-                PyErr_Clear();
-                throw std::runtime_error("error message mismatch");
-            }
-        }
-        PyErr_Clear();
-        if (err)
-            PyErr_SetString(PyExc_ValueError, "foo");
-        throw py::error_already_set();
-    });
-
-    m.def("python_call_in_destructor", [](py::dict d) {
-        try {
-            PythonCallInDestructor set_dict_in_destructor(d);
-            PyErr_SetString(PyExc_ValueError, "foo");
-            throw py::error_already_set();
-        } catch (const py::error_already_set&) {
-            return true;
-        }
-        return false;
-    });
-
-    // test_nested_throws
-    m.def("try_catch", [m](py::object exc_type, py::function f, py::args args) {
-        try { f(*args); }
-        catch (py::error_already_set &ex) {
-            if (ex.matches(exc_type))
-                py::print(ex.what());
-            else
-                throw;
-        }
-    });
-
-}
diff --git a/tmap/lib/pybind11/tests/test_exceptions.py b/tmap/lib/pybind11/tests/test_exceptions.py
deleted file mode 100644
index 8d37c09..0000000
--- a/tmap/lib/pybind11/tests/test_exceptions.py
+++ /dev/null
@@ -1,144 +0,0 @@
-import pytest
-
-from pybind11_tests import exceptions as m
-import pybind11_cross_module_tests as cm
-
-
-def test_std_exception(msg):
-    with pytest.raises(RuntimeError) as excinfo:
-        m.throw_std_exception()
-    assert msg(excinfo.value) == "This exception was intentionally thrown."
-
-
-def test_error_already_set(msg):
-    with pytest.raises(RuntimeError) as excinfo:
-        m.throw_already_set(False)
-    assert msg(excinfo.value) == "Unknown internal error occurred"
-
-    with pytest.raises(ValueError) as excinfo:
-        m.throw_already_set(True)
-    assert msg(excinfo.value) == "foo"
-
-
-def test_cross_module_exceptions():
-    with pytest.raises(RuntimeError) as excinfo:
-        cm.raise_runtime_error()
-    assert str(excinfo.value) == "My runtime error"
-
-    with pytest.raises(ValueError) as excinfo:
-        cm.raise_value_error()
-    assert str(excinfo.value) == "My value error"
-
-    with pytest.raises(ValueError) as excinfo:
-        cm.throw_pybind_value_error()
-    assert str(excinfo.value) == "pybind11 value error"
-
-    with pytest.raises(TypeError) as excinfo:
-        cm.throw_pybind_type_error()
-    assert str(excinfo.value) == "pybind11 type error"
-
-    with pytest.raises(StopIteration) as excinfo:
-        cm.throw_stop_iteration()
-
-
-def test_python_call_in_catch():
-    d = {}
-    assert m.python_call_in_destructor(d) is True
-    assert d["good"] is True
-
-
-def test_exception_matches():
-    m.exception_matches()
-
-
-def test_custom(msg):
-    # Can we catch a MyException?
-    with pytest.raises(m.MyException) as excinfo:
-        m.throws1()
-    assert msg(excinfo.value) == "this error should go to a custom type"
-
-    # Can we translate to standard Python exceptions?
-    with pytest.raises(RuntimeError) as excinfo:
-        m.throws2()
-    assert msg(excinfo.value) == "this error should go to a standard Python exception"
-
-    # Can we handle unknown exceptions?
-    with pytest.raises(RuntimeError) as excinfo:
-        m.throws3()
-    assert msg(excinfo.value) == "Caught an unknown exception!"
-
-    # Can we delegate to another handler by rethrowing?
-    with pytest.raises(m.MyException) as excinfo:
-        m.throws4()
-    assert msg(excinfo.value) == "this error is rethrown"
-
-    # Can we fall-through to the default handler?
-    with pytest.raises(RuntimeError) as excinfo:
-        m.throws_logic_error()
-    assert msg(excinfo.value) == "this error should fall through to the standard handler"
-
-    # Can we handle a helper-declared exception?
-    with pytest.raises(m.MyException5) as excinfo:
-        m.throws5()
-    assert msg(excinfo.value) == "this is a helper-defined translated exception"
-
-    # Exception subclassing:
-    with pytest.raises(m.MyException5) as excinfo:
-        m.throws5_1()
-    assert msg(excinfo.value) == "MyException5 subclass"
-    assert isinstance(excinfo.value, m.MyException5_1)
-
-    with pytest.raises(m.MyException5_1) as excinfo:
-        m.throws5_1()
-    assert msg(excinfo.value) == "MyException5 subclass"
-
-    with pytest.raises(m.MyException5) as excinfo:
-        try:
-            m.throws5()
-        except m.MyException5_1:
-            raise RuntimeError("Exception error: caught child from parent")
-    assert msg(excinfo.value) == "this is a helper-defined translated exception"
-
-
-def test_nested_throws(capture):
-    """Tests nested (e.g. C++ -> Python -> C++) exception handling"""
-
-    def throw_myex():
-        raise m.MyException("nested error")
-
-    def throw_myex5():
-        raise m.MyException5("nested error 5")
-
-    # In the comments below, the exception is caught in the first step, thrown in the last step
-
-    # C++ -> Python
-    with capture:
-        m.try_catch(m.MyException5, throw_myex5)
-    assert str(capture).startswith("MyException5: nested error 5")
-
-    # Python -> C++ -> Python
-    with pytest.raises(m.MyException) as excinfo:
-        m.try_catch(m.MyException5, throw_myex)
-    assert str(excinfo.value) == "nested error"
-
-    def pycatch(exctype, f, *args):
-        try:
-            f(*args)
-        except m.MyException as e:
-            print(e)
-
-    # C++ -> Python -> C++ -> Python
-    with capture:
-        m.try_catch(
-            m.MyException5, pycatch, m.MyException, m.try_catch, m.MyException, throw_myex5)
-    assert str(capture).startswith("MyException5: nested error 5")
-
-    # C++ -> Python -> C++
-    with capture:
-        m.try_catch(m.MyException, pycatch, m.MyException5, m.throws4)
-    assert capture == "this error is rethrown"
-
-    # Python -> C++ -> Python -> C++
-    with pytest.raises(m.MyException5) as excinfo:
-        m.try_catch(m.MyException, pycatch, m.MyException, m.throws5)
-    assert str(excinfo.value) == "this is a helper-defined translated exception"
diff --git a/tmap/lib/pybind11/tests/test_factory_constructors.cpp b/tmap/lib/pybind11/tests/test_factory_constructors.cpp
deleted file mode 100644
index fb33377..0000000
--- a/tmap/lib/pybind11/tests/test_factory_constructors.cpp
+++ /dev/null
@@ -1,337 +0,0 @@
-/*
-    tests/test_factory_constructors.cpp -- tests construction from a factory function
-                                           via py::init_factory()
-
-    Copyright (c) 2017 Jason Rhinelander <jason@imaginary.ca>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "constructor_stats.h"
-#include <cmath>
-
-// Classes for testing python construction via C++ factory function:
-// Not publically constructible, copyable, or movable:
-class TestFactory1 {
-    friend class TestFactoryHelper;
-    TestFactory1() : value("(empty)") { print_default_created(this); }
-    TestFactory1(int v) : value(std::to_string(v)) { print_created(this, value); }
-    TestFactory1(std::string v) : value(std::move(v)) { print_created(this, value); }
-    TestFactory1(TestFactory1 &&) = delete;
-    TestFactory1(const TestFactory1 &) = delete;
-    TestFactory1 &operator=(TestFactory1 &&) = delete;
-    TestFactory1 &operator=(const TestFactory1 &) = delete;
-public:
-    std::string value;
-    ~TestFactory1() { print_destroyed(this); }
-};
-// Non-public construction, but moveable:
-class TestFactory2 {
-    friend class TestFactoryHelper;
-    TestFactory2() : value("(empty2)") { print_default_created(this); }
-    TestFactory2(int v) : value(std::to_string(v)) { print_created(this, value); }
-    TestFactory2(std::string v) : value(std::move(v)) { print_created(this, value); }
-public:
-    TestFactory2(TestFactory2 &&m) { value = std::move(m.value); print_move_created(this); }
-    TestFactory2 &operator=(TestFactory2 &&m) { value = std::move(m.value); print_move_assigned(this); return *this; }
-    std::string value;
-    ~TestFactory2() { print_destroyed(this); }
-};
-// Mixed direct/factory construction:
-class TestFactory3 {
-protected:
-    friend class TestFactoryHelper;
-    TestFactory3() : value("(empty3)") { print_default_created(this); }
-    TestFactory3(int v) : value(std::to_string(v)) { print_created(this, value); }
-public:
-    TestFactory3(std::string v) : value(std::move(v)) { print_created(this, value); }
-    TestFactory3(TestFactory3 &&m) { value = std::move(m.value); print_move_created(this); }
-    TestFactory3 &operator=(TestFactory3 &&m) { value = std::move(m.value); print_move_assigned(this); return *this; }
-    std::string value;
-    virtual ~TestFactory3() { print_destroyed(this); }
-};
-// Inheritance test
-class TestFactory4 : public TestFactory3 {
-public:
-    TestFactory4() : TestFactory3() { print_default_created(this); }
-    TestFactory4(int v) : TestFactory3(v) { print_created(this, v); }
-    virtual ~TestFactory4() { print_destroyed(this); }
-};
-// Another class for an invalid downcast test
-class TestFactory5 : public TestFactory3 {
-public:
-    TestFactory5(int i) : TestFactory3(i) { print_created(this, i); }
-    virtual ~TestFactory5() { print_destroyed(this); }
-};
-
-class TestFactory6 {
-protected:
-    int value;
-    bool alias = false;
-public:
-    TestFactory6(int i) : value{i} { print_created(this, i); }
-    TestFactory6(TestFactory6 &&f) { print_move_created(this); value = f.value; alias = f.alias; }
-    TestFactory6(const TestFactory6 &f) { print_copy_created(this); value = f.value; alias = f.alias; }
-    virtual ~TestFactory6() { print_destroyed(this); }
-    virtual int get() { return value; }
-    bool has_alias() { return alias; }
-};
-class PyTF6 : public TestFactory6 {
-public:
-    // Special constructor that allows the factory to construct a PyTF6 from a TestFactory6 only
-    // when an alias is needed:
-    PyTF6(TestFactory6 &&base) : TestFactory6(std::move(base)) { alias = true; print_created(this, "move", value); }
-    PyTF6(int i) : TestFactory6(i) { alias = true; print_created(this, i); }
-    PyTF6(PyTF6 &&f) : TestFactory6(std::move(f)) { print_move_created(this); }
-    PyTF6(const PyTF6 &f) : TestFactory6(f) { print_copy_created(this); }
-    PyTF6(std::string s) : TestFactory6((int) s.size()) { alias = true; print_created(this, s); }
-    virtual ~PyTF6() { print_destroyed(this); }
-    int get() override { PYBIND11_OVERLOAD(int, TestFactory6, get, /*no args*/); }
-};
-
-class TestFactory7 {
-protected:
-    int value;
-    bool alias = false;
-public:
-    TestFactory7(int i) : value{i} { print_created(this, i); }
-    TestFactory7(TestFactory7 &&f) { print_move_created(this); value = f.value; alias = f.alias; }
-    TestFactory7(const TestFactory7 &f) { print_copy_created(this); value = f.value; alias = f.alias; }
-    virtual ~TestFactory7() { print_destroyed(this); }
-    virtual int get() { return value; }
-    bool has_alias() { return alias; }
-};
-class PyTF7 : public TestFactory7 {
-public:
-    PyTF7(int i) : TestFactory7(i) { alias = true; print_created(this, i); }
-    PyTF7(PyTF7 &&f) : TestFactory7(std::move(f)) { print_move_created(this); }
-    PyTF7(const PyTF7 &f) : TestFactory7(f) { print_copy_created(this); }
-    virtual ~PyTF7() { print_destroyed(this); }
-    int get() override { PYBIND11_OVERLOAD(int, TestFactory7, get, /*no args*/); }
-};
-
-
-class TestFactoryHelper {
-public:
-    // Non-movable, non-copyable type:
-    // Return via pointer:
-    static TestFactory1 *construct1() { return new TestFactory1(); }
-    // Holder:
-    static std::unique_ptr<TestFactory1> construct1(int a) { return std::unique_ptr<TestFactory1>(new TestFactory1(a)); }
-    // pointer again
-    static TestFactory1 *construct1_string(std::string a) { return new TestFactory1(a); }
-
-    // Moveable type:
-    // pointer:
-    static TestFactory2 *construct2() { return new TestFactory2(); }
-    // holder:
-    static std::unique_ptr<TestFactory2> construct2(int a) { return std::unique_ptr<TestFactory2>(new TestFactory2(a)); }
-    // by value moving:
-    static TestFactory2 construct2(std::string a) { return TestFactory2(a); }
-
-    // shared_ptr holder type:
-    // pointer:
-    static TestFactory3 *construct3() { return new TestFactory3(); }
-    // holder:
-    static std::shared_ptr<TestFactory3> construct3(int a) { return std::shared_ptr<TestFactory3>(new TestFactory3(a)); }
-};
-
-TEST_SUBMODULE(factory_constructors, m) {
-
-    // Define various trivial types to allow simpler overload resolution:
-    py::module m_tag = m.def_submodule("tag");
-#define MAKE_TAG_TYPE(Name) \
-    struct Name##_tag {}; \
-    py::class_<Name##_tag>(m_tag, #Name "_tag").def(py::init<>()); \
-    m_tag.attr(#Name) = py::cast(Name##_tag{})
-    MAKE_TAG_TYPE(pointer);
-    MAKE_TAG_TYPE(unique_ptr);
-    MAKE_TAG_TYPE(move);
-    MAKE_TAG_TYPE(shared_ptr);
-    MAKE_TAG_TYPE(derived);
-    MAKE_TAG_TYPE(TF4);
-    MAKE_TAG_TYPE(TF5);
-    MAKE_TAG_TYPE(null_ptr);
-    MAKE_TAG_TYPE(base);
-    MAKE_TAG_TYPE(invalid_base);
-    MAKE_TAG_TYPE(alias);
-    MAKE_TAG_TYPE(unaliasable);
-    MAKE_TAG_TYPE(mixed);
-
-    // test_init_factory_basic, test_bad_type
-    py::class_<TestFactory1>(m, "TestFactory1")
-        .def(py::init([](unique_ptr_tag, int v) { return TestFactoryHelper::construct1(v); }))
-        .def(py::init(&TestFactoryHelper::construct1_string)) // raw function pointer
-        .def(py::init([](pointer_tag) { return TestFactoryHelper::construct1(); }))
-        .def(py::init([](py::handle, int v, py::handle) { return TestFactoryHelper::construct1(v); }))
-        .def_readwrite("value", &TestFactory1::value)
-        ;
-    py::class_<TestFactory2>(m, "TestFactory2")
-        .def(py::init([](pointer_tag, int v) { return TestFactoryHelper::construct2(v); }))
-        .def(py::init([](unique_ptr_tag, std::string v) { return TestFactoryHelper::construct2(v); }))
-        .def(py::init([](move_tag) { return TestFactoryHelper::construct2(); }))
-        .def_readwrite("value", &TestFactory2::value)
-        ;
-
-    // Stateful & reused:
-    int c = 1;
-    auto c4a = [c](pointer_tag, TF4_tag, int a) { (void) c; return new TestFactory4(a);};
-
-    // test_init_factory_basic, test_init_factory_casting
-    py::class_<TestFactory3, std::shared_ptr<TestFactory3>>(m, "TestFactory3")
-        .def(py::init([](pointer_tag, int v) { return TestFactoryHelper::construct3(v); }))
-        .def(py::init([](shared_ptr_tag) { return TestFactoryHelper::construct3(); }))
-        .def("__init__", [](TestFactory3 &self, std::string v) { new (&self) TestFactory3(v); }) // placement-new ctor
-
-        // factories returning a derived type:
-        .def(py::init(c4a)) // derived ptr
-        .def(py::init([](pointer_tag, TF5_tag, int a) { return new TestFactory5(a); }))
-        // derived shared ptr:
-        .def(py::init([](shared_ptr_tag, TF4_tag, int a) { return std::make_shared<TestFactory4>(a); }))
-        .def(py::init([](shared_ptr_tag, TF5_tag, int a) { return std::make_shared<TestFactory5>(a); }))
-
-        // Returns nullptr:
-        .def(py::init([](null_ptr_tag) { return (TestFactory3 *) nullptr; }))
-
-        .def_readwrite("value", &TestFactory3::value)
-        ;
-
-    // test_init_factory_casting
-    py::class_<TestFactory4, TestFactory3, std::shared_ptr<TestFactory4>>(m, "TestFactory4")
-        .def(py::init(c4a)) // pointer
-        ;
-
-    // Doesn't need to be registered, but registering makes getting ConstructorStats easier:
-    py::class_<TestFactory5, TestFactory3, std::shared_ptr<TestFactory5>>(m, "TestFactory5");
-
-    // test_init_factory_alias
-    // Alias testing
-    py::class_<TestFactory6, PyTF6>(m, "TestFactory6")
-        .def(py::init([](base_tag, int i) { return TestFactory6(i); }))
-        .def(py::init([](alias_tag, int i) { return PyTF6(i); }))
-        .def(py::init([](alias_tag, std::string s) { return PyTF6(s); }))
-        .def(py::init([](alias_tag, pointer_tag, int i) { return new PyTF6(i); }))
-        .def(py::init([](base_tag, pointer_tag, int i) { return new TestFactory6(i); }))
-        .def(py::init([](base_tag, alias_tag, pointer_tag, int i) { return (TestFactory6 *) new PyTF6(i); }))
-
-        .def("get", &TestFactory6::get)
-        .def("has_alias", &TestFactory6::has_alias)
-
-        .def_static("get_cstats", &ConstructorStats::get<TestFactory6>, py::return_value_policy::reference)
-        .def_static("get_alias_cstats", &ConstructorStats::get<PyTF6>, py::return_value_policy::reference)
-        ;
-
-    // test_init_factory_dual
-    // Separate alias constructor testing
-    py::class_<TestFactory7, PyTF7, std::shared_ptr<TestFactory7>>(m, "TestFactory7")
-        .def(py::init(
-            [](int i) { return TestFactory7(i); },
-            [](int i) { return PyTF7(i); }))
-        .def(py::init(
-            [](pointer_tag, int i) { return new TestFactory7(i); },
-            [](pointer_tag, int i) { return new PyTF7(i); }))
-        .def(py::init(
-            [](mixed_tag, int i) { return new TestFactory7(i); },
-            [](mixed_tag, int i) { return PyTF7(i); }))
-        .def(py::init(
-            [](mixed_tag, std::string s) { return TestFactory7((int) s.size()); },
-            [](mixed_tag, std::string s) { return new PyTF7((int) s.size()); }))
-        .def(py::init(
-            [](base_tag, pointer_tag, int i) { return new TestFactory7(i); },
-            [](base_tag, pointer_tag, int i) { return (TestFactory7 *) new PyTF7(i); }))
-        .def(py::init(
-            [](alias_tag, pointer_tag, int i) { return new PyTF7(i); },
-            [](alias_tag, pointer_tag, int i) { return new PyTF7(10*i); }))
-        .def(py::init(
-            [](shared_ptr_tag, base_tag, int i) { return std::make_shared<TestFactory7>(i); },
-            [](shared_ptr_tag, base_tag, int i) { auto *p = new PyTF7(i); return std::shared_ptr<TestFactory7>(p); }))
-        .def(py::init(
-            [](shared_ptr_tag, invalid_base_tag, int i) { return std::make_shared<TestFactory7>(i); },
-            [](shared_ptr_tag, invalid_base_tag, int i) { return std::make_shared<TestFactory7>(i); })) // <-- invalid alias factory
-
-        .def("get", &TestFactory7::get)
-        .def("has_alias", &TestFactory7::has_alias)
-
-        .def_static("get_cstats", &ConstructorStats::get<TestFactory7>, py::return_value_policy::reference)
-        .def_static("get_alias_cstats", &ConstructorStats::get<PyTF7>, py::return_value_policy::reference)
-        ;
-
-    // test_placement_new_alternative
-    // Class with a custom new operator but *without* a placement new operator (issue #948)
-    class NoPlacementNew {
-    public:
-        NoPlacementNew(int i) : i(i) { }
-        static void *operator new(std::size_t s) {
-            auto *p = ::operator new(s);
-            py::print("operator new called, returning", reinterpret_cast<uintptr_t>(p));
-            return p;
-        }
-        static void operator delete(void *p) {
-            py::print("operator delete called on", reinterpret_cast<uintptr_t>(p));
-            ::operator delete(p);
-        }
-        int i;
-    };
-    // As of 2.2, `py::init<args>` no longer requires placement new
-    py::class_<NoPlacementNew>(m, "NoPlacementNew")
-        .def(py::init<int>())
-        .def(py::init([]() { return new NoPlacementNew(100); }))
-        .def_readwrite("i", &NoPlacementNew::i)
-        ;
-
-
-    // test_reallocations
-    // Class that has verbose operator_new/operator_delete calls
-    struct NoisyAlloc {
-        NoisyAlloc(int i) { py::print(py::str("NoisyAlloc(int {})").format(i)); }
-        NoisyAlloc(double d) { py::print(py::str("NoisyAlloc(double {})").format(d)); }
-        ~NoisyAlloc() { py::print("~NoisyAlloc()"); }
-
-        static void *operator new(size_t s) { py::print("noisy new"); return ::operator new(s); }
-        static void *operator new(size_t, void *p) { py::print("noisy placement new"); return p; }
-        static void operator delete(void *p, size_t) { py::print("noisy delete"); ::operator delete(p); }
-        static void operator delete(void *, void *) { py::print("noisy placement delete"); }
-#if defined(_MSC_VER) && _MSC_VER < 1910
-        // MSVC 2015 bug: the above "noisy delete" isn't invoked (fixed in MSVC 2017)
-        static void operator delete(void *p) { py::print("noisy delete"); ::operator delete(p); }
-#endif
-    };
-    py::class_<NoisyAlloc>(m, "NoisyAlloc")
-        // Since these overloads have the same number of arguments, the dispatcher will try each of
-        // them until the arguments convert.  Thus we can get a pre-allocation here when passing a
-        // single non-integer:
-        .def("__init__", [](NoisyAlloc *a, int i) { new (a) NoisyAlloc(i); }) // Regular constructor, runs first, requires preallocation
-        .def(py::init([](double d) { return new NoisyAlloc(d); }))
-
-        // The two-argument version: first the factory pointer overload.
-        .def(py::init([](int i, int) { return new NoisyAlloc(i); }))
-        // Return-by-value:
-        .def(py::init([](double d, int) { return NoisyAlloc(d); }))
-        // Old-style placement new init; requires preallocation
-        .def("__init__", [](NoisyAlloc &a, double d, double) { new (&a) NoisyAlloc(d); })
-        // Requires deallocation of previous overload preallocated value:
-        .def(py::init([](int i, double) { return new NoisyAlloc(i); }))
-        // Regular again: requires yet another preallocation
-        .def("__init__", [](NoisyAlloc &a, int i, std::string) { new (&a) NoisyAlloc(i); })
-        ;
-
-
-
-
-    // static_assert testing (the following def's should all fail with appropriate compilation errors):
-#if 0
-    struct BadF1Base {};
-    struct BadF1 : BadF1Base {};
-    struct PyBadF1 : BadF1 {};
-    py::class_<BadF1, PyBadF1, std::shared_ptr<BadF1>> bf1(m, "BadF1");
-    // wrapped factory function must return a compatible pointer, holder, or value
-    bf1.def(py::init([]() { return 3; }));
-    // incompatible factory function pointer return type
-    bf1.def(py::init([]() { static int three = 3; return &three; }));
-    // incompatible factory function std::shared_ptr<T> return type: cannot convert shared_ptr<T> to holder
-    // (non-polymorphic base)
-    bf1.def(py::init([]() { return std::shared_ptr<BadF1Base>(new BadF1()); }));
-#endif
-}
diff --git a/tmap/lib/pybind11/tests/test_factory_constructors.py b/tmap/lib/pybind11/tests/test_factory_constructors.py
deleted file mode 100644
index 78a3910..0000000
--- a/tmap/lib/pybind11/tests/test_factory_constructors.py
+++ /dev/null
@@ -1,459 +0,0 @@
-import pytest
-import re
-
-from pybind11_tests import factory_constructors as m
-from pybind11_tests.factory_constructors import tag
-from pybind11_tests import ConstructorStats
-
-
-def test_init_factory_basic():
-    """Tests py::init_factory() wrapper around various ways of returning the object"""
-
-    cstats = [ConstructorStats.get(c) for c in [m.TestFactory1, m.TestFactory2, m.TestFactory3]]
-    cstats[0].alive()  # force gc
-    n_inst = ConstructorStats.detail_reg_inst()
-
-    x1 = m.TestFactory1(tag.unique_ptr, 3)
-    assert x1.value == "3"
-    y1 = m.TestFactory1(tag.pointer)
-    assert y1.value == "(empty)"
-    z1 = m.TestFactory1("hi!")
-    assert z1.value == "hi!"
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 3
-
-    x2 = m.TestFactory2(tag.move)
-    assert x2.value == "(empty2)"
-    y2 = m.TestFactory2(tag.pointer, 7)
-    assert y2.value == "7"
-    z2 = m.TestFactory2(tag.unique_ptr, "hi again")
-    assert z2.value == "hi again"
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 6
-
-    x3 = m.TestFactory3(tag.shared_ptr)
-    assert x3.value == "(empty3)"
-    y3 = m.TestFactory3(tag.pointer, 42)
-    assert y3.value == "42"
-    z3 = m.TestFactory3("bye")
-    assert z3.value == "bye"
-
-    with pytest.raises(TypeError) as excinfo:
-        m.TestFactory3(tag.null_ptr)
-    assert str(excinfo.value) == "pybind11::init(): factory function returned nullptr"
-
-    assert [i.alive() for i in cstats] == [3, 3, 3]
-    assert ConstructorStats.detail_reg_inst() == n_inst + 9
-
-    del x1, y2, y3, z3
-    assert [i.alive() for i in cstats] == [2, 2, 1]
-    assert ConstructorStats.detail_reg_inst() == n_inst + 5
-    del x2, x3, y1, z1, z2
-    assert [i.alive() for i in cstats] == [0, 0, 0]
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-    assert [i.values() for i in cstats] == [
-        ["3", "hi!"],
-        ["7", "hi again"],
-        ["42", "bye"]
-    ]
-    assert [i.default_constructions for i in cstats] == [1, 1, 1]
-
-
-def test_init_factory_signature(msg):
-    with pytest.raises(TypeError) as excinfo:
-        m.TestFactory1("invalid", "constructor", "arguments")
-    assert msg(excinfo.value) == """
-        __init__(): incompatible constructor arguments. The following argument types are supported:
-            1. m.factory_constructors.TestFactory1(arg0: m.factory_constructors.tag.unique_ptr_tag, arg1: int)
-            2. m.factory_constructors.TestFactory1(arg0: str)
-            3. m.factory_constructors.TestFactory1(arg0: m.factory_constructors.tag.pointer_tag)
-            4. m.factory_constructors.TestFactory1(arg0: handle, arg1: int, arg2: handle)
-
-        Invoked with: 'invalid', 'constructor', 'arguments'
-    """  # noqa: E501 line too long
-
-    assert msg(m.TestFactory1.__init__.__doc__) == """
-        __init__(*args, **kwargs)
-        Overloaded function.
-
-        1. __init__(self: m.factory_constructors.TestFactory1, arg0: m.factory_constructors.tag.unique_ptr_tag, arg1: int) -> None
-
-        2. __init__(self: m.factory_constructors.TestFactory1, arg0: str) -> None
-
-        3. __init__(self: m.factory_constructors.TestFactory1, arg0: m.factory_constructors.tag.pointer_tag) -> None
-
-        4. __init__(self: m.factory_constructors.TestFactory1, arg0: handle, arg1: int, arg2: handle) -> None
-    """  # noqa: E501 line too long
-
-
-def test_init_factory_casting():
-    """Tests py::init_factory() wrapper with various upcasting and downcasting returns"""
-
-    cstats = [ConstructorStats.get(c) for c in [m.TestFactory3, m.TestFactory4, m.TestFactory5]]
-    cstats[0].alive()  # force gc
-    n_inst = ConstructorStats.detail_reg_inst()
-
-    # Construction from derived references:
-    a = m.TestFactory3(tag.pointer, tag.TF4, 4)
-    assert a.value == "4"
-    b = m.TestFactory3(tag.shared_ptr, tag.TF4, 5)
-    assert b.value == "5"
-    c = m.TestFactory3(tag.pointer, tag.TF5, 6)
-    assert c.value == "6"
-    d = m.TestFactory3(tag.shared_ptr, tag.TF5, 7)
-    assert d.value == "7"
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 4
-
-    # Shared a lambda with TF3:
-    e = m.TestFactory4(tag.pointer, tag.TF4, 8)
-    assert e.value == "8"
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 5
-    assert [i.alive() for i in cstats] == [5, 3, 2]
-
-    del a
-    assert [i.alive() for i in cstats] == [4, 2, 2]
-    assert ConstructorStats.detail_reg_inst() == n_inst + 4
-
-    del b, c, e
-    assert [i.alive() for i in cstats] == [1, 0, 1]
-    assert ConstructorStats.detail_reg_inst() == n_inst + 1
-
-    del d
-    assert [i.alive() for i in cstats] == [0, 0, 0]
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-    assert [i.values() for i in cstats] == [
-        ["4", "5", "6", "7", "8"],
-        ["4", "5", "8"],
-        ["6", "7"]
-    ]
-
-
-def test_init_factory_alias():
-    """Tests py::init_factory() wrapper with value conversions and alias types"""
-
-    cstats = [m.TestFactory6.get_cstats(), m.TestFactory6.get_alias_cstats()]
-    cstats[0].alive()  # force gc
-    n_inst = ConstructorStats.detail_reg_inst()
-
-    a = m.TestFactory6(tag.base, 1)
-    assert a.get() == 1
-    assert not a.has_alias()
-    b = m.TestFactory6(tag.alias, "hi there")
-    assert b.get() == 8
-    assert b.has_alias()
-    c = m.TestFactory6(tag.alias, 3)
-    assert c.get() == 3
-    assert c.has_alias()
-    d = m.TestFactory6(tag.alias, tag.pointer, 4)
-    assert d.get() == 4
-    assert d.has_alias()
-    e = m.TestFactory6(tag.base, tag.pointer, 5)
-    assert e.get() == 5
-    assert not e.has_alias()
-    f = m.TestFactory6(tag.base, tag.alias, tag.pointer, 6)
-    assert f.get() == 6
-    assert f.has_alias()
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 6
-    assert [i.alive() for i in cstats] == [6, 4]
-
-    del a, b, e
-    assert [i.alive() for i in cstats] == [3, 3]
-    assert ConstructorStats.detail_reg_inst() == n_inst + 3
-    del f, c, d
-    assert [i.alive() for i in cstats] == [0, 0]
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-    class MyTest(m.TestFactory6):
-        def __init__(self, *args):
-            m.TestFactory6.__init__(self, *args)
-
-        def get(self):
-            return -5 + m.TestFactory6.get(self)
-
-    # Return Class by value, moved into new alias:
-    z = MyTest(tag.base, 123)
-    assert z.get() == 118
-    assert z.has_alias()
-
-    # Return alias by value, moved into new alias:
-    y = MyTest(tag.alias, "why hello!")
-    assert y.get() == 5
-    assert y.has_alias()
-
-    # Return Class by pointer, moved into new alias then original destroyed:
-    x = MyTest(tag.base, tag.pointer, 47)
-    assert x.get() == 42
-    assert x.has_alias()
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 3
-    assert [i.alive() for i in cstats] == [3, 3]
-    del x, y, z
-    assert [i.alive() for i in cstats] == [0, 0]
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-    assert [i.values() for i in cstats] == [
-        ["1", "8", "3", "4", "5", "6", "123", "10", "47"],
-        ["hi there", "3", "4", "6", "move", "123", "why hello!", "move", "47"]
-    ]
-
-
-def test_init_factory_dual():
-    """Tests init factory functions with dual main/alias factory functions"""
-    from pybind11_tests.factory_constructors import TestFactory7
-
-    cstats = [TestFactory7.get_cstats(), TestFactory7.get_alias_cstats()]
-    cstats[0].alive()  # force gc
-    n_inst = ConstructorStats.detail_reg_inst()
-
-    class PythFactory7(TestFactory7):
-        def get(self):
-            return 100 + TestFactory7.get(self)
-
-    a1 = TestFactory7(1)
-    a2 = PythFactory7(2)
-    assert a1.get() == 1
-    assert a2.get() == 102
-    assert not a1.has_alias()
-    assert a2.has_alias()
-
-    b1 = TestFactory7(tag.pointer, 3)
-    b2 = PythFactory7(tag.pointer, 4)
-    assert b1.get() == 3
-    assert b2.get() == 104
-    assert not b1.has_alias()
-    assert b2.has_alias()
-
-    c1 = TestFactory7(tag.mixed, 5)
-    c2 = PythFactory7(tag.mixed, 6)
-    assert c1.get() == 5
-    assert c2.get() == 106
-    assert not c1.has_alias()
-    assert c2.has_alias()
-
-    d1 = TestFactory7(tag.base, tag.pointer, 7)
-    d2 = PythFactory7(tag.base, tag.pointer, 8)
-    assert d1.get() == 7
-    assert d2.get() == 108
-    assert not d1.has_alias()
-    assert d2.has_alias()
-
-    # Both return an alias; the second multiplies the value by 10:
-    e1 = TestFactory7(tag.alias, tag.pointer, 9)
-    e2 = PythFactory7(tag.alias, tag.pointer, 10)
-    assert e1.get() == 9
-    assert e2.get() == 200
-    assert e1.has_alias()
-    assert e2.has_alias()
-
-    f1 = TestFactory7(tag.shared_ptr, tag.base, 11)
-    f2 = PythFactory7(tag.shared_ptr, tag.base, 12)
-    assert f1.get() == 11
-    assert f2.get() == 112
-    assert not f1.has_alias()
-    assert f2.has_alias()
-
-    g1 = TestFactory7(tag.shared_ptr, tag.invalid_base, 13)
-    assert g1.get() == 13
-    assert not g1.has_alias()
-    with pytest.raises(TypeError) as excinfo:
-        PythFactory7(tag.shared_ptr, tag.invalid_base, 14)
-    assert (str(excinfo.value) ==
-            "pybind11::init(): construction failed: returned holder-wrapped instance is not an "
-            "alias instance")
-
-    assert [i.alive() for i in cstats] == [13, 7]
-    assert ConstructorStats.detail_reg_inst() == n_inst + 13
-
-    del a1, a2, b1, d1, e1, e2
-    assert [i.alive() for i in cstats] == [7, 4]
-    assert ConstructorStats.detail_reg_inst() == n_inst + 7
-    del b2, c1, c2, d2, f1, f2, g1
-    assert [i.alive() for i in cstats] == [0, 0]
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-    assert [i.values() for i in cstats] == [
-        ["1", "2", "3", "4", "5", "6", "7", "8", "9", "100", "11", "12", "13", "14"],
-        ["2", "4", "6", "8", "9", "100", "12"]
-    ]
-
-
-def test_no_placement_new(capture):
-    """Prior to 2.2, `py::init<...>` relied on the type supporting placement
-    new; this tests a class without placement new support."""
-    with capture:
-        a = m.NoPlacementNew(123)
-
-    found = re.search(r'^operator new called, returning (\d+)\n$', str(capture))
-    assert found
-    assert a.i == 123
-    with capture:
-        del a
-        pytest.gc_collect()
-    assert capture == "operator delete called on " + found.group(1)
-
-    with capture:
-        b = m.NoPlacementNew()
-
-    found = re.search(r'^operator new called, returning (\d+)\n$', str(capture))
-    assert found
-    assert b.i == 100
-    with capture:
-        del b
-        pytest.gc_collect()
-    assert capture == "operator delete called on " + found.group(1)
-
-
-def test_multiple_inheritance():
-    class MITest(m.TestFactory1, m.TestFactory2):
-        def __init__(self):
-            m.TestFactory1.__init__(self, tag.unique_ptr, 33)
-            m.TestFactory2.__init__(self, tag.move)
-
-    a = MITest()
-    assert m.TestFactory1.value.fget(a) == "33"
-    assert m.TestFactory2.value.fget(a) == "(empty2)"
-
-
-def create_and_destroy(*args):
-    a = m.NoisyAlloc(*args)
-    print("---")
-    del a
-    pytest.gc_collect()
-
-
-def strip_comments(s):
-    return re.sub(r'\s+#.*', '', s)
-
-
-def test_reallocations(capture, msg):
-    """When the constructor is overloaded, previous overloads can require a preallocated value.
-    This test makes sure that such preallocated values only happen when they might be necessary,
-    and that they are deallocated properly"""
-
-    pytest.gc_collect()
-
-    with capture:
-        create_and_destroy(1)
-    assert msg(capture) == """
-        noisy new
-        noisy placement new
-        NoisyAlloc(int 1)
-        ---
-        ~NoisyAlloc()
-        noisy delete
-    """
-    with capture:
-        create_and_destroy(1.5)
-    assert msg(capture) == strip_comments("""
-        noisy new               # allocation required to attempt first overload
-        noisy delete            # have to dealloc before considering factory init overload
-        noisy new               # pointer factory calling "new", part 1: allocation
-        NoisyAlloc(double 1.5)  # ... part two, invoking constructor
-        ---
-        ~NoisyAlloc()  # Destructor
-        noisy delete   # operator delete
-    """)
-
-    with capture:
-        create_and_destroy(2, 3)
-    assert msg(capture) == strip_comments("""
-        noisy new          # pointer factory calling "new", allocation
-        NoisyAlloc(int 2)  # constructor
-        ---
-        ~NoisyAlloc()  # Destructor
-        noisy delete   # operator delete
-    """)
-
-    with capture:
-        create_and_destroy(2.5, 3)
-    assert msg(capture) == strip_comments("""
-        NoisyAlloc(double 2.5)  # construction (local func variable: operator_new not called)
-        noisy new               # return-by-value "new" part 1: allocation
-        ~NoisyAlloc()           # moved-away local func variable destruction
-        ---
-        ~NoisyAlloc()  # Destructor
-        noisy delete   # operator delete
-    """)
-
-    with capture:
-        create_and_destroy(3.5, 4.5)
-    assert msg(capture) == strip_comments("""
-        noisy new               # preallocation needed before invoking placement-new overload
-        noisy placement new     # Placement new
-        NoisyAlloc(double 3.5)  # construction
-        ---
-        ~NoisyAlloc()  # Destructor
-        noisy delete   # operator delete
-    """)
-
-    with capture:
-        create_and_destroy(4, 0.5)
-    assert msg(capture) == strip_comments("""
-        noisy new          # preallocation needed before invoking placement-new overload
-        noisy delete       # deallocation of preallocated storage
-        noisy new          # Factory pointer allocation
-        NoisyAlloc(int 4)  # factory pointer construction
-        ---
-        ~NoisyAlloc()  # Destructor
-        noisy delete   # operator delete
-    """)
-
-    with capture:
-        create_and_destroy(5, "hi")
-    assert msg(capture) == strip_comments("""
-        noisy new            # preallocation needed before invoking first placement new
-        noisy delete         # delete before considering new-style constructor
-        noisy new            # preallocation for second placement new
-        noisy placement new  # Placement new in the second placement new overload
-        NoisyAlloc(int 5)    # construction
-        ---
-        ~NoisyAlloc()  # Destructor
-        noisy delete   # operator delete
-    """)
-
-
-@pytest.unsupported_on_py2
-def test_invalid_self():
-    """Tests invocation of the pybind-registered base class with an invalid `self` argument.  You
-    can only actually do this on Python 3: Python 2 raises an exception itself if you try."""
-    class NotPybindDerived(object):
-        pass
-
-    # Attempts to initialize with an invalid type passed as `self`:
-    class BrokenTF1(m.TestFactory1):
-        def __init__(self, bad):
-            if bad == 1:
-                a = m.TestFactory2(tag.pointer, 1)
-                m.TestFactory1.__init__(a, tag.pointer)
-            elif bad == 2:
-                a = NotPybindDerived()
-                m.TestFactory1.__init__(a, tag.pointer)
-
-    # Same as above, but for a class with an alias:
-    class BrokenTF6(m.TestFactory6):
-        def __init__(self, bad):
-            if bad == 1:
-                a = m.TestFactory2(tag.pointer, 1)
-                m.TestFactory6.__init__(a, tag.base, 1)
-            elif bad == 2:
-                a = m.TestFactory2(tag.pointer, 1)
-                m.TestFactory6.__init__(a, tag.alias, 1)
-            elif bad == 3:
-                m.TestFactory6.__init__(NotPybindDerived.__new__(NotPybindDerived), tag.base, 1)
-            elif bad == 4:
-                m.TestFactory6.__init__(NotPybindDerived.__new__(NotPybindDerived), tag.alias, 1)
-
-    for arg in (1, 2):
-        with pytest.raises(TypeError) as excinfo:
-            BrokenTF1(arg)
-        assert str(excinfo.value) == "__init__(self, ...) called with invalid `self` argument"
-
-    for arg in (1, 2, 3, 4):
-        with pytest.raises(TypeError) as excinfo:
-            BrokenTF6(arg)
-        assert str(excinfo.value) == "__init__(self, ...) called with invalid `self` argument"
diff --git a/tmap/lib/pybind11/tests/test_iostream.cpp b/tmap/lib/pybind11/tests/test_iostream.cpp
deleted file mode 100644
index e67f88a..0000000
--- a/tmap/lib/pybind11/tests/test_iostream.cpp
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
-    tests/test_iostream.cpp -- Usage of scoped_output_redirect
-
-    Copyright (c) 2017 Henry F. Schreiner
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-
-#include <pybind11/iostream.h>
-#include "pybind11_tests.h"
-#include <iostream>
-
-
-void noisy_function(std::string msg, bool flush) {
-
-    std::cout << msg;
-    if (flush)
-        std::cout << std::flush;
-}
-
-void noisy_funct_dual(std::string msg, std::string emsg) {
-    std::cout << msg;
-    std::cerr << emsg;
-}
-
-TEST_SUBMODULE(iostream, m) {
-
-    add_ostream_redirect(m);
-
-    // test_evals
-
-    m.def("captured_output_default", [](std::string msg) {
-        py::scoped_ostream_redirect redir;
-        std::cout << msg << std::flush;
-    });
-
-    m.def("captured_output", [](std::string msg) {
-        py::scoped_ostream_redirect redir(std::cout, py::module::import("sys").attr("stdout"));
-        std::cout << msg << std::flush;
-    });
-
-    m.def("guard_output", &noisy_function,
-            py::call_guard<py::scoped_ostream_redirect>(),
-            py::arg("msg"), py::arg("flush")=true);
-
-    m.def("captured_err", [](std::string msg) {
-        py::scoped_ostream_redirect redir(std::cerr, py::module::import("sys").attr("stderr"));
-        std::cerr << msg << std::flush;
-    });
-
-    m.def("noisy_function", &noisy_function, py::arg("msg"), py::arg("flush") = true);
-
-    m.def("dual_guard", &noisy_funct_dual,
-            py::call_guard<py::scoped_ostream_redirect, py::scoped_estream_redirect>(),
-            py::arg("msg"), py::arg("emsg"));
-
-    m.def("raw_output", [](std::string msg) {
-        std::cout << msg << std::flush;
-    });
-
-    m.def("raw_err", [](std::string msg) {
-        std::cerr << msg << std::flush;
-    });
-
-    m.def("captured_dual", [](std::string msg, std::string emsg) {
-        py::scoped_ostream_redirect redirout(std::cout, py::module::import("sys").attr("stdout"));
-        py::scoped_ostream_redirect redirerr(std::cerr, py::module::import("sys").attr("stderr"));
-        std::cout << msg << std::flush;
-        std::cerr << emsg << std::flush;
-    });
-}
diff --git a/tmap/lib/pybind11/tests/test_iostream.py b/tmap/lib/pybind11/tests/test_iostream.py
deleted file mode 100644
index 3364849..0000000
--- a/tmap/lib/pybind11/tests/test_iostream.py
+++ /dev/null
@@ -1,203 +0,0 @@
-from pybind11_tests import iostream as m
-import sys
-
-from contextlib import contextmanager
-
-try:
-    # Python 3
-    from io import StringIO
-except ImportError:
-    # Python 2
-    try:
-        from cStringIO import StringIO
-    except ImportError:
-        from StringIO import StringIO
-
-try:
-    # Python 3.4
-    from contextlib import redirect_stdout
-except ImportError:
-    @contextmanager
-    def redirect_stdout(target):
-        original = sys.stdout
-        sys.stdout = target
-        yield
-        sys.stdout = original
-
-try:
-    # Python 3.5
-    from contextlib import redirect_stderr
-except ImportError:
-    @contextmanager
-    def redirect_stderr(target):
-        original = sys.stderr
-        sys.stderr = target
-        yield
-        sys.stderr = original
-
-
-def test_captured(capsys):
-    msg = "I've been redirected to Python, I hope!"
-    m.captured_output(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ''
-
-    m.captured_output_default(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ''
-
-    m.captured_err(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == ''
-    assert stderr == msg
-
-
-def test_guard_capture(capsys):
-    msg = "I've been redirected to Python, I hope!"
-    m.guard_output(msg)
-    stdout, stderr = capsys.readouterr()
-    assert stdout == msg
-    assert stderr == ''
-
-
-def test_series_captured(capture):
-    with capture:
-        m.captured_output("a")
-        m.captured_output("b")
-    assert capture == "ab"
-
-
-def test_flush(capfd):
-    msg = "(not flushed)"
-    msg2 = "(flushed)"
-
-    with m.ostream_redirect():
-        m.noisy_function(msg, flush=False)
-        stdout, stderr = capfd.readouterr()
-        assert stdout == ''
-
-        m.noisy_function(msg2, flush=True)
-        stdout, stderr = capfd.readouterr()
-        assert stdout == msg + msg2
-
-        m.noisy_function(msg, flush=False)
-
-    stdout, stderr = capfd.readouterr()
-    assert stdout == msg
-
-
-def test_not_captured(capfd):
-    msg = "Something that should not show up in log"
-    stream = StringIO()
-    with redirect_stdout(stream):
-        m.raw_output(msg)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == msg
-    assert stderr == ''
-    assert stream.getvalue() == ''
-
-    stream = StringIO()
-    with redirect_stdout(stream):
-        m.captured_output(msg)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == ''
-    assert stderr == ''
-    assert stream.getvalue() == msg
-
-
-def test_err(capfd):
-    msg = "Something that should not show up in log"
-    stream = StringIO()
-    with redirect_stderr(stream):
-        m.raw_err(msg)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == ''
-    assert stderr == msg
-    assert stream.getvalue() == ''
-
-    stream = StringIO()
-    with redirect_stderr(stream):
-        m.captured_err(msg)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == ''
-    assert stderr == ''
-    assert stream.getvalue() == msg
-
-
-def test_multi_captured(capfd):
-    stream = StringIO()
-    with redirect_stdout(stream):
-        m.captured_output("a")
-        m.raw_output("b")
-        m.captured_output("c")
-        m.raw_output("d")
-    stdout, stderr = capfd.readouterr()
-    assert stdout == 'bd'
-    assert stream.getvalue() == 'ac'
-
-
-def test_dual(capsys):
-    m.captured_dual("a", "b")
-    stdout, stderr = capsys.readouterr()
-    assert stdout == "a"
-    assert stderr == "b"
-
-
-def test_redirect(capfd):
-    msg = "Should not be in log!"
-    stream = StringIO()
-    with redirect_stdout(stream):
-        m.raw_output(msg)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == msg
-    assert stream.getvalue() == ''
-
-    stream = StringIO()
-    with redirect_stdout(stream):
-        with m.ostream_redirect():
-            m.raw_output(msg)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == ''
-    assert stream.getvalue() == msg
-
-    stream = StringIO()
-    with redirect_stdout(stream):
-        m.raw_output(msg)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == msg
-    assert stream.getvalue() == ''
-
-
-def test_redirect_err(capfd):
-    msg = "StdOut"
-    msg2 = "StdErr"
-
-    stream = StringIO()
-    with redirect_stderr(stream):
-        with m.ostream_redirect(stdout=False):
-            m.raw_output(msg)
-            m.raw_err(msg2)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == msg
-    assert stderr == ''
-    assert stream.getvalue() == msg2
-
-
-def test_redirect_both(capfd):
-    msg = "StdOut"
-    msg2 = "StdErr"
-
-    stream = StringIO()
-    stream2 = StringIO()
-    with redirect_stdout(stream):
-        with redirect_stderr(stream2):
-            with m.ostream_redirect():
-                m.raw_output(msg)
-                m.raw_err(msg2)
-    stdout, stderr = capfd.readouterr()
-    assert stdout == ''
-    assert stderr == ''
-    assert stream.getvalue() == msg
-    assert stream2.getvalue() == msg2
diff --git a/tmap/lib/pybind11/tests/test_kwargs_and_defaults.cpp b/tmap/lib/pybind11/tests/test_kwargs_and_defaults.cpp
deleted file mode 100644
index 165f801..0000000
--- a/tmap/lib/pybind11/tests/test_kwargs_and_defaults.cpp
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
-    tests/test_kwargs_and_defaults.cpp -- keyword arguments and default values
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include <pybind11/stl.h>
-
-TEST_SUBMODULE(kwargs_and_defaults, m) {
-    auto kw_func = [](int x, int y) { return "x=" + std::to_string(x) + ", y=" + std::to_string(y); };
-
-    // test_named_arguments
-    m.def("kw_func0", kw_func);
-    m.def("kw_func1", kw_func, py::arg("x"), py::arg("y"));
-    m.def("kw_func2", kw_func, py::arg("x") = 100, py::arg("y") = 200);
-    m.def("kw_func3", [](const char *) { }, py::arg("data") = std::string("Hello world!"));
-
-    /* A fancier default argument */
-    std::vector<int> list{{13, 17}};
-    m.def("kw_func4", [](const std::vector<int> &entries) {
-        std::string ret = "{";
-        for (int i : entries)
-            ret += std::to_string(i) + " ";
-        ret.back() = '}';
-        return ret;
-    }, py::arg("myList") = list);
-
-    m.def("kw_func_udl", kw_func, "x"_a, "y"_a=300);
-    m.def("kw_func_udl_z", kw_func, "x"_a, "y"_a=0);
-
-    // test_args_and_kwargs
-    m.def("args_function", [](py::args args) -> py::tuple { return args; });
-    m.def("args_kwargs_function", [](py::args args, py::kwargs kwargs) {
-        return py::make_tuple(args, kwargs);
-    });
-
-    // test_mixed_args_and_kwargs
-    m.def("mixed_plus_args", [](int i, double j, py::args args) {
-        return py::make_tuple(i, j, args);
-    });
-    m.def("mixed_plus_kwargs", [](int i, double j, py::kwargs kwargs) {
-        return py::make_tuple(i, j, kwargs);
-    });
-    auto mixed_plus_both = [](int i, double j, py::args args, py::kwargs kwargs) {
-        return py::make_tuple(i, j, args, kwargs);
-    };
-    m.def("mixed_plus_args_kwargs", mixed_plus_both);
-
-    m.def("mixed_plus_args_kwargs_defaults", mixed_plus_both,
-            py::arg("i") = 1, py::arg("j") = 3.14159);
-
-    // pybind11 won't allow these to be bound: args and kwargs, if present, must be at the end.
-    // Uncomment these to test that the static_assert is indeed working:
-//    m.def("bad_args1", [](py::args, int) {});
-//    m.def("bad_args2", [](py::kwargs, int) {});
-//    m.def("bad_args3", [](py::kwargs, py::args) {});
-//    m.def("bad_args4", [](py::args, int, py::kwargs) {});
-//    m.def("bad_args5", [](py::args, py::kwargs, int) {});
-//    m.def("bad_args6", [](py::args, py::args) {});
-//    m.def("bad_args7", [](py::kwargs, py::kwargs) {});
-
-    // test_function_signatures (along with most of the above)
-    struct KWClass { void foo(int, float) {} };
-    py::class_<KWClass>(m, "KWClass")
-        .def("foo0", &KWClass::foo)
-        .def("foo1", &KWClass::foo, "x"_a, "y"_a);
-}
diff --git a/tmap/lib/pybind11/tests/test_kwargs_and_defaults.py b/tmap/lib/pybind11/tests/test_kwargs_and_defaults.py
deleted file mode 100644
index 733fe85..0000000
--- a/tmap/lib/pybind11/tests/test_kwargs_and_defaults.py
+++ /dev/null
@@ -1,107 +0,0 @@
-import pytest
-from pybind11_tests import kwargs_and_defaults as m
-
-
-def test_function_signatures(doc):
-    assert doc(m.kw_func0) == "kw_func0(arg0: int, arg1: int) -> str"
-    assert doc(m.kw_func1) == "kw_func1(x: int, y: int) -> str"
-    assert doc(m.kw_func2) == "kw_func2(x: int=100, y: int=200) -> str"
-    assert doc(m.kw_func3) == "kw_func3(data: str='Hello world!') -> None"
-    assert doc(m.kw_func4) == "kw_func4(myList: List[int]=[13, 17]) -> str"
-    assert doc(m.kw_func_udl) == "kw_func_udl(x: int, y: int=300) -> str"
-    assert doc(m.kw_func_udl_z) == "kw_func_udl_z(x: int, y: int=0) -> str"
-    assert doc(m.args_function) == "args_function(*args) -> tuple"
-    assert doc(m.args_kwargs_function) == "args_kwargs_function(*args, **kwargs) -> tuple"
-    assert doc(m.KWClass.foo0) == \
-        "foo0(self: m.kwargs_and_defaults.KWClass, arg0: int, arg1: float) -> None"
-    assert doc(m.KWClass.foo1) == \
-        "foo1(self: m.kwargs_and_defaults.KWClass, x: int, y: float) -> None"
-
-
-def test_named_arguments(msg):
-    assert m.kw_func0(5, 10) == "x=5, y=10"
-
-    assert m.kw_func1(5, 10) == "x=5, y=10"
-    assert m.kw_func1(5, y=10) == "x=5, y=10"
-    assert m.kw_func1(y=10, x=5) == "x=5, y=10"
-
-    assert m.kw_func2() == "x=100, y=200"
-    assert m.kw_func2(5) == "x=5, y=200"
-    assert m.kw_func2(x=5) == "x=5, y=200"
-    assert m.kw_func2(y=10) == "x=100, y=10"
-    assert m.kw_func2(5, 10) == "x=5, y=10"
-    assert m.kw_func2(x=5, y=10) == "x=5, y=10"
-
-    with pytest.raises(TypeError) as excinfo:
-        # noinspection PyArgumentList
-        m.kw_func2(x=5, y=10, z=12)
-    assert excinfo.match(
-        r'(?s)^kw_func2\(\): incompatible.*Invoked with: kwargs: ((x=5|y=10|z=12)(, |$))' + '{3}$')
-
-    assert m.kw_func4() == "{13 17}"
-    assert m.kw_func4(myList=[1, 2, 3]) == "{1 2 3}"
-
-    assert m.kw_func_udl(x=5, y=10) == "x=5, y=10"
-    assert m.kw_func_udl_z(x=5) == "x=5, y=0"
-
-
-def test_arg_and_kwargs():
-    args = 'arg1_value', 'arg2_value', 3
-    assert m.args_function(*args) == args
-
-    args = 'a1', 'a2'
-    kwargs = dict(arg3='a3', arg4=4)
-    assert m.args_kwargs_function(*args, **kwargs) == (args, kwargs)
-
-
-def test_mixed_args_and_kwargs(msg):
-    mpa = m.mixed_plus_args
-    mpk = m.mixed_plus_kwargs
-    mpak = m.mixed_plus_args_kwargs
-    mpakd = m.mixed_plus_args_kwargs_defaults
-
-    assert mpa(1, 2.5, 4, 99.5, None) == (1, 2.5, (4, 99.5, None))
-    assert mpa(1, 2.5) == (1, 2.5, ())
-    with pytest.raises(TypeError) as excinfo:
-        assert mpa(1)
-    assert msg(excinfo.value) == """
-        mixed_plus_args(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: int, arg1: float, *args) -> tuple
-
-        Invoked with: 1
-    """  # noqa: E501 line too long
-    with pytest.raises(TypeError) as excinfo:
-        assert mpa()
-    assert msg(excinfo.value) == """
-        mixed_plus_args(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: int, arg1: float, *args) -> tuple
-
-        Invoked with:
-    """  # noqa: E501 line too long
-
-    assert mpk(-2, 3.5, pi=3.14159, e=2.71828) == (-2, 3.5, {'e': 2.71828, 'pi': 3.14159})
-    assert mpak(7, 7.7, 7.77, 7.777, 7.7777, minusseven=-7) == (
-        7, 7.7, (7.77, 7.777, 7.7777), {'minusseven': -7})
-    assert mpakd() == (1, 3.14159, (), {})
-    assert mpakd(3) == (3, 3.14159, (), {})
-    assert mpakd(j=2.71828) == (1, 2.71828, (), {})
-    assert mpakd(k=42) == (1, 3.14159, (), {'k': 42})
-    assert mpakd(1, 1, 2, 3, 5, 8, then=13, followedby=21) == (
-        1, 1, (2, 3, 5, 8), {'then': 13, 'followedby': 21})
-    # Arguments specified both positionally and via kwargs should fail:
-    with pytest.raises(TypeError) as excinfo:
-        assert mpakd(1, i=1)
-    assert msg(excinfo.value) == """
-        mixed_plus_args_kwargs_defaults(): incompatible function arguments. The following argument types are supported:
-            1. (i: int=1, j: float=3.14159, *args, **kwargs) -> tuple
-
-        Invoked with: 1; kwargs: i=1
-    """  # noqa: E501 line too long
-    with pytest.raises(TypeError) as excinfo:
-        assert mpakd(1, 2, j=1)
-    assert msg(excinfo.value) == """
-        mixed_plus_args_kwargs_defaults(): incompatible function arguments. The following argument types are supported:
-            1. (i: int=1, j: float=3.14159, *args, **kwargs) -> tuple
-
-        Invoked with: 1, 2; kwargs: j=1
-    """  # noqa: E501 line too long
diff --git a/tmap/lib/pybind11/tests/test_local_bindings.cpp b/tmap/lib/pybind11/tests/test_local_bindings.cpp
deleted file mode 100644
index 359d6c6..0000000
--- a/tmap/lib/pybind11/tests/test_local_bindings.cpp
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
-    tests/test_local_bindings.cpp -- tests the py::module_local class feature which makes a class
-                                     binding local to the module in which it is defined.
-
-    Copyright (c) 2017 Jason Rhinelander <jason@imaginary.ca>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "local_bindings.h"
-#include <pybind11/stl.h>
-#include <pybind11/stl_bind.h>
-#include <numeric>
-
-TEST_SUBMODULE(local_bindings, m) {
-    // test_local_bindings
-    // Register a class with py::module_local:
-    bind_local<LocalType, -1>(m, "LocalType", py::module_local())
-        .def("get3", [](LocalType &t) { return t.i + 3; })
-        ;
-
-    m.def("local_value", [](LocalType &l) { return l.i; });
-
-    // test_nonlocal_failure
-    // The main pybind11 test module is loaded first, so this registration will succeed (the second
-    // one, in pybind11_cross_module_tests.cpp, is designed to fail):
-    bind_local<NonLocalType, 0>(m, "NonLocalType")
-        .def(py::init<int>())
-        .def("get", [](LocalType &i) { return i.i; })
-        ;
-
-    // test_duplicate_local
-    // py::module_local declarations should be visible across compilation units that get linked together;
-    // this tries to register a duplicate local.  It depends on a definition in test_class.cpp and
-    // should raise a runtime error from the duplicate definition attempt.  If test_class isn't
-    // available it *also* throws a runtime error (with "test_class not enabled" as value).
-    m.def("register_local_external", [m]() {
-        auto main = py::module::import("pybind11_tests");
-        if (py::hasattr(main, "class_")) {
-            bind_local<LocalExternal, 7>(m, "LocalExternal", py::module_local());
-        }
-        else throw std::runtime_error("test_class not enabled");
-    });
-
-    // test_stl_bind_local
-    // stl_bind.h binders defaults to py::module_local if the types are local or converting:
-    py::bind_vector<LocalVec>(m, "LocalVec");
-    py::bind_map<LocalMap>(m, "LocalMap");
-    // and global if the type (or one of the types, for the map) is global:
-    py::bind_vector<NonLocalVec>(m, "NonLocalVec");
-    py::bind_map<NonLocalMap>(m, "NonLocalMap");
-
-    // test_stl_bind_global
-    // They can, however, be overridden to global using `py::module_local(false)`:
-    bind_local<NonLocal2, 10>(m, "NonLocal2");
-    py::bind_vector<LocalVec2>(m, "LocalVec2", py::module_local());
-    py::bind_map<NonLocalMap2>(m, "NonLocalMap2", py::module_local(false));
-
-    // test_mixed_local_global
-    // We try this both with the global type registered first and vice versa (the order shouldn't
-    // matter).
-    m.def("register_mixed_global", [m]() {
-        bind_local<MixedGlobalLocal, 100>(m, "MixedGlobalLocal", py::module_local(false));
-    });
-    m.def("register_mixed_local", [m]() {
-        bind_local<MixedLocalGlobal, 1000>(m, "MixedLocalGlobal", py::module_local());
-    });
-    m.def("get_mixed_gl", [](int i) { return MixedGlobalLocal(i); });
-    m.def("get_mixed_lg", [](int i) { return MixedLocalGlobal(i); });
-
-    // test_internal_locals_differ
-    m.def("local_cpp_types_addr", []() { return (uintptr_t) &py::detail::registered_local_types_cpp(); });
-
-    // test_stl_caster_vs_stl_bind
-    m.def("load_vector_via_caster", [](std::vector<int> v) {
-        return std::accumulate(v.begin(), v.end(), 0);
-    });
-
-    // test_cross_module_calls
-    m.def("return_self", [](LocalVec *v) { return v; });
-    m.def("return_copy", [](const LocalVec &v) { return LocalVec(v); });
-
-    class Cat : public pets::Pet { public: Cat(std::string name) : Pet(name) {}; };
-    py::class_<pets::Pet>(m, "Pet", py::module_local())
-        .def("get_name", &pets::Pet::name);
-    // Binding for local extending class:
-    py::class_<Cat, pets::Pet>(m, "Cat")
-        .def(py::init<std::string>());
-    m.def("pet_name", [](pets::Pet &p) { return p.name(); });
-
-    py::class_<MixGL>(m, "MixGL").def(py::init<int>());
-    m.def("get_gl_value", [](MixGL &o) { return o.i + 10; });
-
-    py::class_<MixGL2>(m, "MixGL2").def(py::init<int>());
-}
diff --git a/tmap/lib/pybind11/tests/test_local_bindings.py b/tmap/lib/pybind11/tests/test_local_bindings.py
deleted file mode 100644
index e9a63ca..0000000
--- a/tmap/lib/pybind11/tests/test_local_bindings.py
+++ /dev/null
@@ -1,210 +0,0 @@
-import pytest
-
-from pybind11_tests import local_bindings as m
-
-
-def test_local_bindings():
-    """Tests that duplicate `py::module_local` class bindings work across modules"""
-
-    # Make sure we can load the second module with the conflicting (but local) definition:
-    import pybind11_cross_module_tests as cm
-
-    i1 = m.LocalType(5)
-    assert i1.get() == 4
-    assert i1.get3() == 8
-
-    i2 = cm.LocalType(10)
-    assert i2.get() == 11
-    assert i2.get2() == 12
-
-    assert not hasattr(i1, 'get2')
-    assert not hasattr(i2, 'get3')
-
-    # Loading within the local module
-    assert m.local_value(i1) == 5
-    assert cm.local_value(i2) == 10
-
-    # Cross-module loading works as well (on failure, the type loader looks for
-    # external module-local converters):
-    assert m.local_value(i2) == 10
-    assert cm.local_value(i1) == 5
-
-
-def test_nonlocal_failure():
-    """Tests that attempting to register a non-local type in multiple modules fails"""
-    import pybind11_cross_module_tests as cm
-
-    with pytest.raises(RuntimeError) as excinfo:
-        cm.register_nonlocal()
-    assert str(excinfo.value) == 'generic_type: type "NonLocalType" is already registered!'
-
-
-def test_duplicate_local():
-    """Tests expected failure when registering a class twice with py::local in the same module"""
-    with pytest.raises(RuntimeError) as excinfo:
-        m.register_local_external()
-    import pybind11_tests
-    assert str(excinfo.value) == (
-        'generic_type: type "LocalExternal" is already registered!'
-        if hasattr(pybind11_tests, 'class_') else 'test_class not enabled')
-
-
-def test_stl_bind_local():
-    import pybind11_cross_module_tests as cm
-
-    v1, v2 = m.LocalVec(), cm.LocalVec()
-    v1.append(m.LocalType(1))
-    v1.append(m.LocalType(2))
-    v2.append(cm.LocalType(1))
-    v2.append(cm.LocalType(2))
-
-    # Cross module value loading:
-    v1.append(cm.LocalType(3))
-    v2.append(m.LocalType(3))
-
-    assert [i.get() for i in v1] == [0, 1, 2]
-    assert [i.get() for i in v2] == [2, 3, 4]
-
-    v3, v4 = m.NonLocalVec(), cm.NonLocalVec2()
-    v3.append(m.NonLocalType(1))
-    v3.append(m.NonLocalType(2))
-    v4.append(m.NonLocal2(3))
-    v4.append(m.NonLocal2(4))
-
-    assert [i.get() for i in v3] == [1, 2]
-    assert [i.get() for i in v4] == [13, 14]
-
-    d1, d2 = m.LocalMap(), cm.LocalMap()
-    d1["a"] = v1[0]
-    d1["b"] = v1[1]
-    d2["c"] = v2[0]
-    d2["d"] = v2[1]
-    assert {i: d1[i].get() for i in d1} == {'a': 0, 'b': 1}
-    assert {i: d2[i].get() for i in d2} == {'c': 2, 'd': 3}
-
-
-def test_stl_bind_global():
-    import pybind11_cross_module_tests as cm
-
-    with pytest.raises(RuntimeError) as excinfo:
-        cm.register_nonlocal_map()
-    assert str(excinfo.value) == 'generic_type: type "NonLocalMap" is already registered!'
-
-    with pytest.raises(RuntimeError) as excinfo:
-        cm.register_nonlocal_vec()
-    assert str(excinfo.value) == 'generic_type: type "NonLocalVec" is already registered!'
-
-    with pytest.raises(RuntimeError) as excinfo:
-        cm.register_nonlocal_map2()
-    assert str(excinfo.value) == 'generic_type: type "NonLocalMap2" is already registered!'
-
-
-def test_mixed_local_global():
-    """Local types take precedence over globally registered types: a module with a `module_local`
-    type can be registered even if the type is already registered globally.  With the module,
-    casting will go to the local type; outside the module casting goes to the global type."""
-    import pybind11_cross_module_tests as cm
-    m.register_mixed_global()
-    m.register_mixed_local()
-
-    a = []
-    a.append(m.MixedGlobalLocal(1))
-    a.append(m.MixedLocalGlobal(2))
-    a.append(m.get_mixed_gl(3))
-    a.append(m.get_mixed_lg(4))
-
-    assert [x.get() for x in a] == [101, 1002, 103, 1004]
-
-    cm.register_mixed_global_local()
-    cm.register_mixed_local_global()
-    a.append(m.MixedGlobalLocal(5))
-    a.append(m.MixedLocalGlobal(6))
-    a.append(cm.MixedGlobalLocal(7))
-    a.append(cm.MixedLocalGlobal(8))
-    a.append(m.get_mixed_gl(9))
-    a.append(m.get_mixed_lg(10))
-    a.append(cm.get_mixed_gl(11))
-    a.append(cm.get_mixed_lg(12))
-
-    assert [x.get() for x in a] == \
-        [101, 1002, 103, 1004, 105, 1006, 207, 2008, 109, 1010, 211, 2012]
-
-
-def test_internal_locals_differ():
-    """Makes sure the internal local type map differs across the two modules"""
-    import pybind11_cross_module_tests as cm
-    assert m.local_cpp_types_addr() != cm.local_cpp_types_addr()
-
-
-def test_stl_caster_vs_stl_bind(msg):
-    """One module uses a generic vector caster from `<pybind11/stl.h>` while the other
-    exports `std::vector<int>` via `py:bind_vector` and `py::module_local`"""
-    import pybind11_cross_module_tests as cm
-
-    v1 = cm.VectorInt([1, 2, 3])
-    assert m.load_vector_via_caster(v1) == 6
-    assert cm.load_vector_via_binding(v1) == 6
-
-    v2 = [1, 2, 3]
-    assert m.load_vector_via_caster(v2) == 6
-    with pytest.raises(TypeError) as excinfo:
-        cm.load_vector_via_binding(v2) == 6
-    assert msg(excinfo.value) == """
-    load_vector_via_binding(): incompatible function arguments. The following argument types are supported:
-        1. (arg0: pybind11_cross_module_tests.VectorInt) -> int
-
-    Invoked with: [1, 2, 3]
-    """  # noqa: E501 line too long
-
-
-def test_cross_module_calls():
-    import pybind11_cross_module_tests as cm
-
-    v1 = m.LocalVec()
-    v1.append(m.LocalType(1))
-    v2 = cm.LocalVec()
-    v2.append(cm.LocalType(2))
-
-    # Returning the self pointer should get picked up as returning an existing
-    # instance (even when that instance is of a foreign, non-local type).
-    assert m.return_self(v1) is v1
-    assert cm.return_self(v2) is v2
-    assert m.return_self(v2) is v2
-    assert cm.return_self(v1) is v1
-
-    assert m.LocalVec is not cm.LocalVec
-    # Returning a copy, on the other hand, always goes to the local type,
-    # regardless of where the source type came from.
-    assert type(m.return_copy(v1)) is m.LocalVec
-    assert type(m.return_copy(v2)) is m.LocalVec
-    assert type(cm.return_copy(v1)) is cm.LocalVec
-    assert type(cm.return_copy(v2)) is cm.LocalVec
-
-    # Test the example given in the documentation (which also tests inheritance casting):
-    mycat = m.Cat("Fluffy")
-    mydog = cm.Dog("Rover")
-    assert mycat.get_name() == "Fluffy"
-    assert mydog.name() == "Rover"
-    assert m.Cat.__base__.__name__ == "Pet"
-    assert cm.Dog.__base__.__name__ == "Pet"
-    assert m.Cat.__base__ is not cm.Dog.__base__
-    assert m.pet_name(mycat) == "Fluffy"
-    assert m.pet_name(mydog) == "Rover"
-    assert cm.pet_name(mycat) == "Fluffy"
-    assert cm.pet_name(mydog) == "Rover"
-
-    assert m.MixGL is not cm.MixGL
-    a = m.MixGL(1)
-    b = cm.MixGL(2)
-    assert m.get_gl_value(a) == 11
-    assert m.get_gl_value(b) == 12
-    assert cm.get_gl_value(a) == 101
-    assert cm.get_gl_value(b) == 102
-
-    c, d = m.MixGL2(3), cm.MixGL2(4)
-    with pytest.raises(TypeError) as excinfo:
-        m.get_gl_value(c)
-    assert "incompatible function arguments" in str(excinfo)
-    with pytest.raises(TypeError) as excinfo:
-        m.get_gl_value(d)
-    assert "incompatible function arguments" in str(excinfo)
diff --git a/tmap/lib/pybind11/tests/test_methods_and_attributes.cpp b/tmap/lib/pybind11/tests/test_methods_and_attributes.cpp
deleted file mode 100644
index cd15869..0000000
--- a/tmap/lib/pybind11/tests/test_methods_and_attributes.cpp
+++ /dev/null
@@ -1,446 +0,0 @@
-/*
-    tests/test_methods_and_attributes.cpp -- constructors, deconstructors, attribute access,
-    __str__, argument and return value conventions
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "constructor_stats.h"
-
-class ExampleMandA {
-public:
-    ExampleMandA() { print_default_created(this); }
-    ExampleMandA(int value) : value(value) { print_created(this, value); }
-    ExampleMandA(const ExampleMandA &e) : value(e.value) { print_copy_created(this); }
-    ExampleMandA(ExampleMandA &&e) : value(e.value) { print_move_created(this); }
-    ~ExampleMandA() { print_destroyed(this); }
-
-    std::string toString() {
-        return "ExampleMandA[value=" + std::to_string(value) + "]";
-    }
-
-    void operator=(const ExampleMandA &e) { print_copy_assigned(this); value = e.value; }
-    void operator=(ExampleMandA &&e) { print_move_assigned(this); value = e.value; }
-
-    void add1(ExampleMandA other) { value += other.value; }         // passing by value
-    void add2(ExampleMandA &other) { value += other.value; }        // passing by reference
-    void add3(const ExampleMandA &other) { value += other.value; }  // passing by const reference
-    void add4(ExampleMandA *other) { value += other->value; }       // passing by pointer
-    void add5(const ExampleMandA *other) { value += other->value; } // passing by const pointer
-
-    void add6(int other) { value += other; }                        // passing by value
-    void add7(int &other) { value += other; }                       // passing by reference
-    void add8(const int &other) { value += other; }                 // passing by const reference
-    void add9(int *other) { value += *other; }                      // passing by pointer
-    void add10(const int *other) { value += *other; }               // passing by const pointer
-
-    ExampleMandA self1() { return *this; }                          // return by value
-    ExampleMandA &self2() { return *this; }                         // return by reference
-    const ExampleMandA &self3() { return *this; }                   // return by const reference
-    ExampleMandA *self4() { return this; }                          // return by pointer
-    const ExampleMandA *self5() { return this; }                    // return by const pointer
-
-    int internal1() { return value; }                               // return by value
-    int &internal2() { return value; }                              // return by reference
-    const int &internal3() { return value; }                        // return by const reference
-    int *internal4() { return &value; }                             // return by pointer
-    const int *internal5() { return &value; }                       // return by const pointer
-
-    py::str overloaded()             { return "()"; }
-    py::str overloaded(int)          { return "(int)"; }
-    py::str overloaded(int, float)   { return "(int, float)"; }
-    py::str overloaded(float, int)   { return "(float, int)"; }
-    py::str overloaded(int, int)     { return "(int, int)"; }
-    py::str overloaded(float, float) { return "(float, float)"; }
-    py::str overloaded(int)          const { return "(int) const"; }
-    py::str overloaded(int, float)   const { return "(int, float) const"; }
-    py::str overloaded(float, int)   const { return "(float, int) const"; }
-    py::str overloaded(int, int)     const { return "(int, int) const"; }
-    py::str overloaded(float, float) const { return "(float, float) const"; }
-
-    static py::str overloaded(float) { return "static float"; }
-
-    int value = 0;
-};
-
-struct TestProperties {
-    int value = 1;
-    static int static_value;
-
-    int get() const { return value; }
-    void set(int v) { value = v; }
-
-    static int static_get() { return static_value; }
-    static void static_set(int v) { static_value = v; }
-};
-int TestProperties::static_value = 1;
-
-struct TestPropertiesOverride : TestProperties {
-    int value = 99;
-    static int static_value;
-};
-int TestPropertiesOverride::static_value = 99;
-
-struct TestPropRVP {
-    UserType v1{1};
-    UserType v2{1};
-    static UserType sv1;
-    static UserType sv2;
-
-    const UserType &get1() const { return v1; }
-    const UserType &get2() const { return v2; }
-    UserType get_rvalue() const { return v2; }
-    void set1(int v) { v1.set(v); }
-    void set2(int v) { v2.set(v); }
-};
-UserType TestPropRVP::sv1(1);
-UserType TestPropRVP::sv2(1);
-
-// py::arg/py::arg_v testing: these arguments just record their argument when invoked
-class ArgInspector1 { public: std::string arg = "(default arg inspector 1)"; };
-class ArgInspector2 { public: std::string arg = "(default arg inspector 2)"; };
-class ArgAlwaysConverts { };
-namespace pybind11 { namespace detail {
-template <> struct type_caster<ArgInspector1> {
-public:
-    PYBIND11_TYPE_CASTER(ArgInspector1, _("ArgInspector1"));
-
-    bool load(handle src, bool convert) {
-        value.arg = "loading ArgInspector1 argument " +
-            std::string(convert ? "WITH" : "WITHOUT") + " conversion allowed.  "
-            "Argument value = " + (std::string) str(src);
-        return true;
-    }
-
-    static handle cast(const ArgInspector1 &src, return_value_policy, handle) {
-        return str(src.arg).release();
-    }
-};
-template <> struct type_caster<ArgInspector2> {
-public:
-    PYBIND11_TYPE_CASTER(ArgInspector2, _("ArgInspector2"));
-
-    bool load(handle src, bool convert) {
-        value.arg = "loading ArgInspector2 argument " +
-            std::string(convert ? "WITH" : "WITHOUT") + " conversion allowed.  "
-            "Argument value = " + (std::string) str(src);
-        return true;
-    }
-
-    static handle cast(const ArgInspector2 &src, return_value_policy, handle) {
-        return str(src.arg).release();
-    }
-};
-template <> struct type_caster<ArgAlwaysConverts> {
-public:
-    PYBIND11_TYPE_CASTER(ArgAlwaysConverts, _("ArgAlwaysConverts"));
-
-    bool load(handle, bool convert) {
-        return convert;
-    }
-
-    static handle cast(const ArgAlwaysConverts &, return_value_policy, handle) {
-        return py::none().release();
-    }
-};
-}}
-
-// test_custom_caster_destruction
-class DestructionTester {
-public:
-    DestructionTester() { print_default_created(this); }
-    ~DestructionTester() { print_destroyed(this); }
-    DestructionTester(const DestructionTester &) { print_copy_created(this); }
-    DestructionTester(DestructionTester &&) { print_move_created(this); }
-    DestructionTester &operator=(const DestructionTester &) { print_copy_assigned(this); return *this; }
-    DestructionTester &operator=(DestructionTester &&) { print_move_assigned(this); return *this; }
-};
-namespace pybind11 { namespace detail {
-template <> struct type_caster<DestructionTester> {
-    PYBIND11_TYPE_CASTER(DestructionTester, _("DestructionTester"));
-    bool load(handle, bool) { return true; }
-
-    static handle cast(const DestructionTester &, return_value_policy, handle) {
-        return py::bool_(true).release();
-    }
-};
-}}
-
-// Test None-allowed py::arg argument policy
-class NoneTester { public: int answer = 42; };
-int none1(const NoneTester &obj) { return obj.answer; }
-int none2(NoneTester *obj) { return obj ? obj->answer : -1; }
-int none3(std::shared_ptr<NoneTester> &obj) { return obj ? obj->answer : -1; }
-int none4(std::shared_ptr<NoneTester> *obj) { return obj && *obj ? (*obj)->answer : -1; }
-int none5(std::shared_ptr<NoneTester> obj) { return obj ? obj->answer : -1; }
-
-struct StrIssue {
-    int val = -1;
-
-    StrIssue() = default;
-    StrIssue(int i) : val{i} {}
-};
-
-// Issues #854, #910: incompatible function args when member function/pointer is in unregistered base class
-class UnregisteredBase {
-public:
-    void do_nothing() const {}
-    void increase_value() { rw_value++; ro_value += 0.25; }
-    void set_int(int v) { rw_value = v; }
-    int get_int() const { return rw_value; }
-    double get_double() const { return ro_value; }
-    int rw_value = 42;
-    double ro_value = 1.25;
-};
-class RegisteredDerived : public UnregisteredBase {
-public:
-    using UnregisteredBase::UnregisteredBase;
-    double sum() const { return rw_value + ro_value; }
-};
-
-TEST_SUBMODULE(methods_and_attributes, m) {
-    // test_methods_and_attributes
-    py::class_<ExampleMandA> emna(m, "ExampleMandA");
-    emna.def(py::init<>())
-        .def(py::init<int>())
-        .def(py::init<const ExampleMandA&>())
-        .def("add1", &ExampleMandA::add1)
-        .def("add2", &ExampleMandA::add2)
-        .def("add3", &ExampleMandA::add3)
-        .def("add4", &ExampleMandA::add4)
-        .def("add5", &ExampleMandA::add5)
-        .def("add6", &ExampleMandA::add6)
-        .def("add7", &ExampleMandA::add7)
-        .def("add8", &ExampleMandA::add8)
-        .def("add9", &ExampleMandA::add9)
-        .def("add10", &ExampleMandA::add10)
-        .def("self1", &ExampleMandA::self1)
-        .def("self2", &ExampleMandA::self2)
-        .def("self3", &ExampleMandA::self3)
-        .def("self4", &ExampleMandA::self4)
-        .def("self5", &ExampleMandA::self5)
-        .def("internal1", &ExampleMandA::internal1)
-        .def("internal2", &ExampleMandA::internal2)
-        .def("internal3", &ExampleMandA::internal3)
-        .def("internal4", &ExampleMandA::internal4)
-        .def("internal5", &ExampleMandA::internal5)
-#if defined(PYBIND11_OVERLOAD_CAST)
-        .def("overloaded", py::overload_cast<>(&ExampleMandA::overloaded))
-        .def("overloaded", py::overload_cast<int>(&ExampleMandA::overloaded))
-        .def("overloaded", py::overload_cast<int,   float>(&ExampleMandA::overloaded))
-        .def("overloaded", py::overload_cast<float,   int>(&ExampleMandA::overloaded))
-        .def("overloaded", py::overload_cast<int,     int>(&ExampleMandA::overloaded))
-        .def("overloaded", py::overload_cast<float, float>(&ExampleMandA::overloaded))
-        .def("overloaded_float", py::overload_cast<float, float>(&ExampleMandA::overloaded))
-        .def("overloaded_const", py::overload_cast<int         >(&ExampleMandA::overloaded, py::const_))
-        .def("overloaded_const", py::overload_cast<int,   float>(&ExampleMandA::overloaded, py::const_))
-        .def("overloaded_const", py::overload_cast<float,   int>(&ExampleMandA::overloaded, py::const_))
-        .def("overloaded_const", py::overload_cast<int,     int>(&ExampleMandA::overloaded, py::const_))
-        .def("overloaded_const", py::overload_cast<float, float>(&ExampleMandA::overloaded, py::const_))
-#else
-        .def("overloaded", static_cast<py::str (ExampleMandA::*)()>(&ExampleMandA::overloaded))
-        .def("overloaded", static_cast<py::str (ExampleMandA::*)(int)>(&ExampleMandA::overloaded))
-        .def("overloaded", static_cast<py::str (ExampleMandA::*)(int,   float)>(&ExampleMandA::overloaded))
-        .def("overloaded", static_cast<py::str (ExampleMandA::*)(float,   int)>(&ExampleMandA::overloaded))
-        .def("overloaded", static_cast<py::str (ExampleMandA::*)(int,     int)>(&ExampleMandA::overloaded))
-        .def("overloaded", static_cast<py::str (ExampleMandA::*)(float, float)>(&ExampleMandA::overloaded))
-        .def("overloaded_float", static_cast<py::str (ExampleMandA::*)(float, float)>(&ExampleMandA::overloaded))
-        .def("overloaded_const", static_cast<py::str (ExampleMandA::*)(int         ) const>(&ExampleMandA::overloaded))
-        .def("overloaded_const", static_cast<py::str (ExampleMandA::*)(int,   float) const>(&ExampleMandA::overloaded))
-        .def("overloaded_const", static_cast<py::str (ExampleMandA::*)(float,   int) const>(&ExampleMandA::overloaded))
-        .def("overloaded_const", static_cast<py::str (ExampleMandA::*)(int,     int) const>(&ExampleMandA::overloaded))
-        .def("overloaded_const", static_cast<py::str (ExampleMandA::*)(float, float) const>(&ExampleMandA::overloaded))
-#endif
-        // test_no_mixed_overloads
-        // Raise error if trying to mix static/non-static overloads on the same name:
-        .def_static("add_mixed_overloads1", []() {
-            auto emna = py::reinterpret_borrow<py::class_<ExampleMandA>>(py::module::import("pybind11_tests.methods_and_attributes").attr("ExampleMandA"));
-            emna.def       ("overload_mixed1", static_cast<py::str (ExampleMandA::*)(int, int)>(&ExampleMandA::overloaded))
-                .def_static("overload_mixed1", static_cast<py::str (              *)(float   )>(&ExampleMandA::overloaded));
-        })
-        .def_static("add_mixed_overloads2", []() {
-            auto emna = py::reinterpret_borrow<py::class_<ExampleMandA>>(py::module::import("pybind11_tests.methods_and_attributes").attr("ExampleMandA"));
-            emna.def_static("overload_mixed2", static_cast<py::str (              *)(float   )>(&ExampleMandA::overloaded))
-                .def       ("overload_mixed2", static_cast<py::str (ExampleMandA::*)(int, int)>(&ExampleMandA::overloaded));
-        })
-        .def("__str__", &ExampleMandA::toString)
-        .def_readwrite("value", &ExampleMandA::value);
-
-    // test_copy_method
-    // Issue #443: can't call copied methods in Python 3
-    emna.attr("add2b") = emna.attr("add2");
-
-    // test_properties, test_static_properties, test_static_cls
-    py::class_<TestProperties>(m, "TestProperties")
-        .def(py::init<>())
-        .def_readonly("def_readonly", &TestProperties::value)
-        .def_readwrite("def_readwrite", &TestProperties::value)
-        .def_property_readonly("def_property_readonly", &TestProperties::get)
-        .def_property("def_property", &TestProperties::get, &TestProperties::set)
-        .def_readonly_static("def_readonly_static", &TestProperties::static_value)
-        .def_readwrite_static("def_readwrite_static", &TestProperties::static_value)
-        .def_property_readonly_static("def_property_readonly_static",
-                                      [](py::object) { return TestProperties::static_get(); })
-        .def_property_static("def_property_static",
-                             [](py::object) { return TestProperties::static_get(); },
-                             [](py::object, int v) { TestProperties::static_set(v); })
-        .def_property_static("static_cls",
-                             [](py::object cls) { return cls; },
-                             [](py::object cls, py::function f) { f(cls); });
-
-    py::class_<TestPropertiesOverride, TestProperties>(m, "TestPropertiesOverride")
-        .def(py::init<>())
-        .def_readonly("def_readonly", &TestPropertiesOverride::value)
-        .def_readonly_static("def_readonly_static", &TestPropertiesOverride::static_value);
-
-    auto static_get1 = [](py::object) -> const UserType & { return TestPropRVP::sv1; };
-    auto static_get2 = [](py::object) -> const UserType & { return TestPropRVP::sv2; };
-    auto static_set1 = [](py::object, int v) { TestPropRVP::sv1.set(v); };
-    auto static_set2 = [](py::object, int v) { TestPropRVP::sv2.set(v); };
-    auto rvp_copy = py::return_value_policy::copy;
-
-    // test_property_return_value_policies
-    py::class_<TestPropRVP>(m, "TestPropRVP")
-        .def(py::init<>())
-        .def_property_readonly("ro_ref", &TestPropRVP::get1)
-        .def_property_readonly("ro_copy", &TestPropRVP::get2, rvp_copy)
-        .def_property_readonly("ro_func", py::cpp_function(&TestPropRVP::get2, rvp_copy))
-        .def_property("rw_ref", &TestPropRVP::get1, &TestPropRVP::set1)
-        .def_property("rw_copy", &TestPropRVP::get2, &TestPropRVP::set2, rvp_copy)
-        .def_property("rw_func", py::cpp_function(&TestPropRVP::get2, rvp_copy), &TestPropRVP::set2)
-        .def_property_readonly_static("static_ro_ref", static_get1)
-        .def_property_readonly_static("static_ro_copy", static_get2, rvp_copy)
-        .def_property_readonly_static("static_ro_func", py::cpp_function(static_get2, rvp_copy))
-        .def_property_static("static_rw_ref", static_get1, static_set1)
-        .def_property_static("static_rw_copy", static_get2, static_set2, rvp_copy)
-        .def_property_static("static_rw_func", py::cpp_function(static_get2, rvp_copy), static_set2)
-        // test_property_rvalue_policy
-        .def_property_readonly("rvalue", &TestPropRVP::get_rvalue)
-        .def_property_readonly_static("static_rvalue", [](py::object) { return UserType(1); });
-
-    // test_metaclass_override
-    struct MetaclassOverride { };
-    py::class_<MetaclassOverride>(m, "MetaclassOverride", py::metaclass((PyObject *) &PyType_Type))
-        .def_property_readonly_static("readonly", [](py::object) { return 1; });
-
-#if !defined(PYPY_VERSION)
-    // test_dynamic_attributes
-    class DynamicClass {
-    public:
-        DynamicClass() { print_default_created(this); }
-        ~DynamicClass() { print_destroyed(this); }
-    };
-    py::class_<DynamicClass>(m, "DynamicClass", py::dynamic_attr())
-        .def(py::init());
-
-    class CppDerivedDynamicClass : public DynamicClass { };
-    py::class_<CppDerivedDynamicClass, DynamicClass>(m, "CppDerivedDynamicClass")
-        .def(py::init());
-#endif
-
-    // test_noconvert_args
-    //
-    // Test converting.  The ArgAlwaysConverts is just there to make the first no-conversion pass
-    // fail so that our call always ends up happening via the second dispatch (the one that allows
-    // some conversion).
-    class ArgInspector {
-    public:
-        ArgInspector1 f(ArgInspector1 a, ArgAlwaysConverts) { return a; }
-        std::string g(ArgInspector1 a, const ArgInspector1 &b, int c, ArgInspector2 *d, ArgAlwaysConverts) {
-            return a.arg + "\n" + b.arg + "\n" + std::to_string(c) + "\n" + d->arg;
-        }
-        static ArgInspector2 h(ArgInspector2 a, ArgAlwaysConverts) { return a; }
-    };
-    py::class_<ArgInspector>(m, "ArgInspector")
-        .def(py::init<>())
-        .def("f", &ArgInspector::f, py::arg(), py::arg() = ArgAlwaysConverts())
-        .def("g", &ArgInspector::g, "a"_a.noconvert(), "b"_a, "c"_a.noconvert()=13, "d"_a=ArgInspector2(), py::arg() = ArgAlwaysConverts())
-        .def_static("h", &ArgInspector::h, py::arg().noconvert(), py::arg() = ArgAlwaysConverts())
-        ;
-    m.def("arg_inspect_func", [](ArgInspector2 a, ArgInspector1 b, ArgAlwaysConverts) { return a.arg + "\n" + b.arg; },
-            py::arg().noconvert(false), py::arg_v(nullptr, ArgInspector1()).noconvert(true), py::arg() = ArgAlwaysConverts());
-
-    m.def("floats_preferred", [](double f) { return 0.5 * f; }, py::arg("f"));
-    m.def("floats_only", [](double f) { return 0.5 * f; }, py::arg("f").noconvert());
-    m.def("ints_preferred", [](int i) { return i / 2; }, py::arg("i"));
-    m.def("ints_only", [](int i) { return i / 2; }, py::arg("i").noconvert());
-
-    // test_bad_arg_default
-    // Issue/PR #648: bad arg default debugging output
-#if !defined(NDEBUG)
-    m.attr("debug_enabled") = true;
-#else
-    m.attr("debug_enabled") = false;
-#endif
-    m.def("bad_arg_def_named", []{
-        auto m = py::module::import("pybind11_tests");
-        m.def("should_fail", [](int, UnregisteredType) {}, py::arg(), py::arg("a") = UnregisteredType());
-    });
-    m.def("bad_arg_def_unnamed", []{
-        auto m = py::module::import("pybind11_tests");
-        m.def("should_fail", [](int, UnregisteredType) {}, py::arg(), py::arg() = UnregisteredType());
-    });
-
-    // test_accepts_none
-    py::class_<NoneTester, std::shared_ptr<NoneTester>>(m, "NoneTester")
-        .def(py::init<>());
-    m.def("no_none1", &none1, py::arg().none(false));
-    m.def("no_none2", &none2, py::arg().none(false));
-    m.def("no_none3", &none3, py::arg().none(false));
-    m.def("no_none4", &none4, py::arg().none(false));
-    m.def("no_none5", &none5, py::arg().none(false));
-    m.def("ok_none1", &none1);
-    m.def("ok_none2", &none2, py::arg().none(true));
-    m.def("ok_none3", &none3);
-    m.def("ok_none4", &none4, py::arg().none(true));
-    m.def("ok_none5", &none5);
-
-    // test_str_issue
-    // Issue #283: __str__ called on uninitialized instance when constructor arguments invalid
-    py::class_<StrIssue>(m, "StrIssue")
-        .def(py::init<int>())
-        .def(py::init<>())
-        .def("__str__", [](const StrIssue &si) {
-            return "StrIssue[" + std::to_string(si.val) + "]"; }
-        );
-
-    // test_unregistered_base_implementations
-    //
-    // Issues #854/910: incompatible function args when member function/pointer is in unregistered
-    // base class The methods and member pointers below actually resolve to members/pointers in
-    // UnregisteredBase; before this test/fix they would be registered via lambda with a first
-    // argument of an unregistered type, and thus uncallable.
-    py::class_<RegisteredDerived>(m, "RegisteredDerived")
-        .def(py::init<>())
-        .def("do_nothing", &RegisteredDerived::do_nothing)
-        .def("increase_value", &RegisteredDerived::increase_value)
-        .def_readwrite("rw_value", &RegisteredDerived::rw_value)
-        .def_readonly("ro_value", &RegisteredDerived::ro_value)
-        // These should trigger a static_assert if uncommented
-        //.def_readwrite("fails", &UserType::value) // should trigger a static_assert if uncommented
-        //.def_readonly("fails", &UserType::value) // should trigger a static_assert if uncommented
-        .def_property("rw_value_prop", &RegisteredDerived::get_int, &RegisteredDerived::set_int)
-        .def_property_readonly("ro_value_prop", &RegisteredDerived::get_double)
-        // This one is in the registered class:
-        .def("sum", &RegisteredDerived::sum)
-        ;
-
-    using Adapted = decltype(py::method_adaptor<RegisteredDerived>(&RegisteredDerived::do_nothing));
-    static_assert(std::is_same<Adapted, void (RegisteredDerived::*)() const>::value, "");
-
-    // test_custom_caster_destruction
-    // Test that `take_ownership` works on types with a custom type caster when given a pointer
-
-    // default policy: don't take ownership:
-    m.def("custom_caster_no_destroy", []() { static auto *dt = new DestructionTester(); return dt; });
-
-    m.def("custom_caster_destroy", []() { return new DestructionTester(); },
-            py::return_value_policy::take_ownership); // Takes ownership: destroy when finished
-    m.def("custom_caster_destroy_const", []() -> const DestructionTester * { return new DestructionTester(); },
-            py::return_value_policy::take_ownership); // Likewise (const doesn't inhibit destruction)
-    m.def("destruction_tester_cstats", &ConstructorStats::get<DestructionTester>, py::return_value_policy::reference);
-}
diff --git a/tmap/lib/pybind11/tests/test_methods_and_attributes.py b/tmap/lib/pybind11/tests/test_methods_and_attributes.py
deleted file mode 100644
index 9fd9cb7..0000000
--- a/tmap/lib/pybind11/tests/test_methods_and_attributes.py
+++ /dev/null
@@ -1,476 +0,0 @@
-import pytest
-from pybind11_tests import methods_and_attributes as m
-from pybind11_tests import ConstructorStats
-
-
-def test_methods_and_attributes():
-    instance1 = m.ExampleMandA()
-    instance2 = m.ExampleMandA(32)
-
-    instance1.add1(instance2)
-    instance1.add2(instance2)
-    instance1.add3(instance2)
-    instance1.add4(instance2)
-    instance1.add5(instance2)
-    instance1.add6(32)
-    instance1.add7(32)
-    instance1.add8(32)
-    instance1.add9(32)
-    instance1.add10(32)
-
-    assert str(instance1) == "ExampleMandA[value=320]"
-    assert str(instance2) == "ExampleMandA[value=32]"
-    assert str(instance1.self1()) == "ExampleMandA[value=320]"
-    assert str(instance1.self2()) == "ExampleMandA[value=320]"
-    assert str(instance1.self3()) == "ExampleMandA[value=320]"
-    assert str(instance1.self4()) == "ExampleMandA[value=320]"
-    assert str(instance1.self5()) == "ExampleMandA[value=320]"
-
-    assert instance1.internal1() == 320
-    assert instance1.internal2() == 320
-    assert instance1.internal3() == 320
-    assert instance1.internal4() == 320
-    assert instance1.internal5() == 320
-
-    assert instance1.overloaded() == "()"
-    assert instance1.overloaded(0) == "(int)"
-    assert instance1.overloaded(1, 1.0) == "(int, float)"
-    assert instance1.overloaded(2.0, 2) == "(float, int)"
-    assert instance1.overloaded(3,   3) == "(int, int)"
-    assert instance1.overloaded(4., 4.) == "(float, float)"
-    assert instance1.overloaded_const(-3) == "(int) const"
-    assert instance1.overloaded_const(5, 5.0) == "(int, float) const"
-    assert instance1.overloaded_const(6.0, 6) == "(float, int) const"
-    assert instance1.overloaded_const(7,   7) == "(int, int) const"
-    assert instance1.overloaded_const(8., 8.) == "(float, float) const"
-    assert instance1.overloaded_float(1, 1) == "(float, float)"
-    assert instance1.overloaded_float(1, 1.) == "(float, float)"
-    assert instance1.overloaded_float(1., 1) == "(float, float)"
-    assert instance1.overloaded_float(1., 1.) == "(float, float)"
-
-    assert instance1.value == 320
-    instance1.value = 100
-    assert str(instance1) == "ExampleMandA[value=100]"
-
-    cstats = ConstructorStats.get(m.ExampleMandA)
-    assert cstats.alive() == 2
-    del instance1, instance2
-    assert cstats.alive() == 0
-    assert cstats.values() == ["32"]
-    assert cstats.default_constructions == 1
-    assert cstats.copy_constructions == 3
-    assert cstats.move_constructions >= 1
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-
-def test_copy_method():
-    """Issue #443: calling copied methods fails in Python 3"""
-
-    m.ExampleMandA.add2c = m.ExampleMandA.add2
-    m.ExampleMandA.add2d = m.ExampleMandA.add2b
-    a = m.ExampleMandA(123)
-    assert a.value == 123
-    a.add2(m.ExampleMandA(-100))
-    assert a.value == 23
-    a.add2b(m.ExampleMandA(20))
-    assert a.value == 43
-    a.add2c(m.ExampleMandA(6))
-    assert a.value == 49
-    a.add2d(m.ExampleMandA(-7))
-    assert a.value == 42
-
-
-def test_properties():
-    instance = m.TestProperties()
-
-    assert instance.def_readonly == 1
-    with pytest.raises(AttributeError):
-        instance.def_readonly = 2
-
-    instance.def_readwrite = 2
-    assert instance.def_readwrite == 2
-
-    assert instance.def_property_readonly == 2
-    with pytest.raises(AttributeError):
-        instance.def_property_readonly = 3
-
-    instance.def_property = 3
-    assert instance.def_property == 3
-
-
-def test_static_properties():
-    assert m.TestProperties.def_readonly_static == 1
-    with pytest.raises(AttributeError) as excinfo:
-        m.TestProperties.def_readonly_static = 2
-    assert "can't set attribute" in str(excinfo)
-
-    m.TestProperties.def_readwrite_static = 2
-    assert m.TestProperties.def_readwrite_static == 2
-
-    assert m.TestProperties.def_property_readonly_static == 2
-    with pytest.raises(AttributeError) as excinfo:
-        m.TestProperties.def_property_readonly_static = 3
-    assert "can't set attribute" in str(excinfo)
-
-    m.TestProperties.def_property_static = 3
-    assert m.TestProperties.def_property_static == 3
-
-    # Static property read and write via instance
-    instance = m.TestProperties()
-
-    m.TestProperties.def_readwrite_static = 0
-    assert m.TestProperties.def_readwrite_static == 0
-    assert instance.def_readwrite_static == 0
-
-    instance.def_readwrite_static = 2
-    assert m.TestProperties.def_readwrite_static == 2
-    assert instance.def_readwrite_static == 2
-
-    # It should be possible to override properties in derived classes
-    assert m.TestPropertiesOverride().def_readonly == 99
-    assert m.TestPropertiesOverride.def_readonly_static == 99
-
-
-def test_static_cls():
-    """Static property getter and setters expect the type object as the their only argument"""
-
-    instance = m.TestProperties()
-    assert m.TestProperties.static_cls is m.TestProperties
-    assert instance.static_cls is m.TestProperties
-
-    def check_self(self):
-        assert self is m.TestProperties
-
-    m.TestProperties.static_cls = check_self
-    instance.static_cls = check_self
-
-
-def test_metaclass_override():
-    """Overriding pybind11's default metaclass changes the behavior of `static_property`"""
-
-    assert type(m.ExampleMandA).__name__ == "pybind11_type"
-    assert type(m.MetaclassOverride).__name__ == "type"
-
-    assert m.MetaclassOverride.readonly == 1
-    assert type(m.MetaclassOverride.__dict__["readonly"]).__name__ == "pybind11_static_property"
-
-    # Regular `type` replaces the property instead of calling `__set__()`
-    m.MetaclassOverride.readonly = 2
-    assert m.MetaclassOverride.readonly == 2
-    assert isinstance(m.MetaclassOverride.__dict__["readonly"], int)
-
-
-def test_no_mixed_overloads():
-    from pybind11_tests import debug_enabled
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.ExampleMandA.add_mixed_overloads1()
-    assert (str(excinfo.value) ==
-            "overloading a method with both static and instance methods is not supported; " +
-            ("compile in debug mode for more details" if not debug_enabled else
-             "error while attempting to bind static method ExampleMandA.overload_mixed1"
-             "(arg0: float) -> str")
-            )
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.ExampleMandA.add_mixed_overloads2()
-    assert (str(excinfo.value) ==
-            "overloading a method with both static and instance methods is not supported; " +
-            ("compile in debug mode for more details" if not debug_enabled else
-             "error while attempting to bind instance method ExampleMandA.overload_mixed2"
-             "(self: pybind11_tests.methods_and_attributes.ExampleMandA, arg0: int, arg1: int)"
-             " -> str")
-            )
-
-
-@pytest.mark.parametrize("access", ["ro", "rw", "static_ro", "static_rw"])
-def test_property_return_value_policies(access):
-    if not access.startswith("static"):
-        obj = m.TestPropRVP()
-    else:
-        obj = m.TestPropRVP
-
-    ref = getattr(obj, access + "_ref")
-    assert ref.value == 1
-    ref.value = 2
-    assert getattr(obj, access + "_ref").value == 2
-    ref.value = 1  # restore original value for static properties
-
-    copy = getattr(obj, access + "_copy")
-    assert copy.value == 1
-    copy.value = 2
-    assert getattr(obj, access + "_copy").value == 1
-
-    copy = getattr(obj, access + "_func")
-    assert copy.value == 1
-    copy.value = 2
-    assert getattr(obj, access + "_func").value == 1
-
-
-def test_property_rvalue_policy():
-    """When returning an rvalue, the return value policy is automatically changed from
-    `reference(_internal)` to `move`. The following would not work otherwise."""
-
-    instance = m.TestPropRVP()
-    o = instance.rvalue
-    assert o.value == 1
-
-    os = m.TestPropRVP.static_rvalue
-    assert os.value == 1
-
-
-# https://bitbucket.org/pypy/pypy/issues/2447
-@pytest.unsupported_on_pypy
-def test_dynamic_attributes():
-    instance = m.DynamicClass()
-    assert not hasattr(instance, "foo")
-    assert "foo" not in dir(instance)
-
-    # Dynamically add attribute
-    instance.foo = 42
-    assert hasattr(instance, "foo")
-    assert instance.foo == 42
-    assert "foo" in dir(instance)
-
-    # __dict__ should be accessible and replaceable
-    assert "foo" in instance.__dict__
-    instance.__dict__ = {"bar": True}
-    assert not hasattr(instance, "foo")
-    assert hasattr(instance, "bar")
-
-    with pytest.raises(TypeError) as excinfo:
-        instance.__dict__ = []
-    assert str(excinfo.value) == "__dict__ must be set to a dictionary, not a 'list'"
-
-    cstats = ConstructorStats.get(m.DynamicClass)
-    assert cstats.alive() == 1
-    del instance
-    assert cstats.alive() == 0
-
-    # Derived classes should work as well
-    class PythonDerivedDynamicClass(m.DynamicClass):
-        pass
-
-    for cls in m.CppDerivedDynamicClass, PythonDerivedDynamicClass:
-        derived = cls()
-        derived.foobar = 100
-        assert derived.foobar == 100
-
-        assert cstats.alive() == 1
-        del derived
-        assert cstats.alive() == 0
-
-
-# https://bitbucket.org/pypy/pypy/issues/2447
-@pytest.unsupported_on_pypy
-def test_cyclic_gc():
-    # One object references itself
-    instance = m.DynamicClass()
-    instance.circular_reference = instance
-
-    cstats = ConstructorStats.get(m.DynamicClass)
-    assert cstats.alive() == 1
-    del instance
-    assert cstats.alive() == 0
-
-    # Two object reference each other
-    i1 = m.DynamicClass()
-    i2 = m.DynamicClass()
-    i1.cycle = i2
-    i2.cycle = i1
-
-    assert cstats.alive() == 2
-    del i1, i2
-    assert cstats.alive() == 0
-
-
-def test_noconvert_args(msg):
-    a = m.ArgInspector()
-    assert msg(a.f("hi")) == """
-        loading ArgInspector1 argument WITH conversion allowed.  Argument value = hi
-    """
-    assert msg(a.g("this is a", "this is b")) == """
-        loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = this is a
-        loading ArgInspector1 argument WITH conversion allowed.  Argument value = this is b
-        13
-        loading ArgInspector2 argument WITH conversion allowed.  Argument value = (default arg inspector 2)
-    """  # noqa: E501 line too long
-    assert msg(a.g("this is a", "this is b", 42)) == """
-        loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = this is a
-        loading ArgInspector1 argument WITH conversion allowed.  Argument value = this is b
-        42
-        loading ArgInspector2 argument WITH conversion allowed.  Argument value = (default arg inspector 2)
-    """  # noqa: E501 line too long
-    assert msg(a.g("this is a", "this is b", 42, "this is d")) == """
-        loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = this is a
-        loading ArgInspector1 argument WITH conversion allowed.  Argument value = this is b
-        42
-        loading ArgInspector2 argument WITH conversion allowed.  Argument value = this is d
-    """
-    assert (a.h("arg 1") ==
-            "loading ArgInspector2 argument WITHOUT conversion allowed.  Argument value = arg 1")
-    assert msg(m.arg_inspect_func("A1", "A2")) == """
-        loading ArgInspector2 argument WITH conversion allowed.  Argument value = A1
-        loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = A2
-    """
-
-    assert m.floats_preferred(4) == 2.0
-    assert m.floats_only(4.0) == 2.0
-    with pytest.raises(TypeError) as excinfo:
-        m.floats_only(4)
-    assert msg(excinfo.value) == """
-        floats_only(): incompatible function arguments. The following argument types are supported:
-            1. (f: float) -> float
-
-        Invoked with: 4
-    """
-
-    assert m.ints_preferred(4) == 2
-    assert m.ints_preferred(True) == 0
-    with pytest.raises(TypeError) as excinfo:
-        m.ints_preferred(4.0)
-    assert msg(excinfo.value) == """
-        ints_preferred(): incompatible function arguments. The following argument types are supported:
-            1. (i: int) -> int
-
-        Invoked with: 4.0
-    """  # noqa: E501 line too long
-
-    assert m.ints_only(4) == 2
-    with pytest.raises(TypeError) as excinfo:
-        m.ints_only(4.0)
-    assert msg(excinfo.value) == """
-        ints_only(): incompatible function arguments. The following argument types are supported:
-            1. (i: int) -> int
-
-        Invoked with: 4.0
-    """
-
-
-def test_bad_arg_default(msg):
-    from pybind11_tests import debug_enabled
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.bad_arg_def_named()
-    assert msg(excinfo.value) == (
-        "arg(): could not convert default argument 'a: UnregisteredType' in function "
-        "'should_fail' into a Python object (type not registered yet?)"
-        if debug_enabled else
-        "arg(): could not convert default argument into a Python object (type not registered "
-        "yet?). Compile in debug mode for more information."
-    )
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.bad_arg_def_unnamed()
-    assert msg(excinfo.value) == (
-        "arg(): could not convert default argument 'UnregisteredType' in function "
-        "'should_fail' into a Python object (type not registered yet?)"
-        if debug_enabled else
-        "arg(): could not convert default argument into a Python object (type not registered "
-        "yet?). Compile in debug mode for more information."
-    )
-
-
-def test_accepts_none(msg):
-    a = m.NoneTester()
-    assert m.no_none1(a) == 42
-    assert m.no_none2(a) == 42
-    assert m.no_none3(a) == 42
-    assert m.no_none4(a) == 42
-    assert m.no_none5(a) == 42
-    assert m.ok_none1(a) == 42
-    assert m.ok_none2(a) == 42
-    assert m.ok_none3(a) == 42
-    assert m.ok_none4(a) == 42
-    assert m.ok_none5(a) == 42
-
-    with pytest.raises(TypeError) as excinfo:
-        m.no_none1(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.no_none2(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.no_none3(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.no_none4(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-    with pytest.raises(TypeError) as excinfo:
-        m.no_none5(None)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    # The first one still raises because you can't pass None as a lvalue reference arg:
-    with pytest.raises(TypeError) as excinfo:
-        assert m.ok_none1(None) == -1
-    assert msg(excinfo.value) == """
-        ok_none1(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: m.methods_and_attributes.NoneTester) -> int
-
-        Invoked with: None
-    """
-
-    # The rest take the argument as pointer or holder, and accept None:
-    assert m.ok_none2(None) == -1
-    assert m.ok_none3(None) == -1
-    assert m.ok_none4(None) == -1
-    assert m.ok_none5(None) == -1
-
-
-def test_str_issue(msg):
-    """#283: __str__ called on uninitialized instance when constructor arguments invalid"""
-
-    assert str(m.StrIssue(3)) == "StrIssue[3]"
-
-    with pytest.raises(TypeError) as excinfo:
-        str(m.StrIssue("no", "such", "constructor"))
-    assert msg(excinfo.value) == """
-        __init__(): incompatible constructor arguments. The following argument types are supported:
-            1. m.methods_and_attributes.StrIssue(arg0: int)
-            2. m.methods_and_attributes.StrIssue()
-
-        Invoked with: 'no', 'such', 'constructor'
-    """
-
-
-def test_unregistered_base_implementations():
-    a = m.RegisteredDerived()
-    a.do_nothing()
-    assert a.rw_value == 42
-    assert a.ro_value == 1.25
-    a.rw_value += 5
-    assert a.sum() == 48.25
-    a.increase_value()
-    assert a.rw_value == 48
-    assert a.ro_value == 1.5
-    assert a.sum() == 49.5
-    assert a.rw_value_prop == 48
-    a.rw_value_prop += 1
-    assert a.rw_value_prop == 49
-    a.increase_value()
-    assert a.ro_value_prop == 1.75
-
-
-def test_custom_caster_destruction():
-    """Tests that returning a pointer to a type that gets converted with a custom type caster gets
-    destroyed when the function has py::return_value_policy::take_ownership policy applied."""
-
-    cstats = m.destruction_tester_cstats()
-    # This one *doesn't* have take_ownership: the pointer should be used but not destroyed:
-    z = m.custom_caster_no_destroy()
-    assert cstats.alive() == 1 and cstats.default_constructions == 1
-    assert z
-
-    # take_ownership applied: this constructs a new object, casts it, then destroys it:
-    z = m.custom_caster_destroy()
-    assert z
-    assert cstats.default_constructions == 2
-
-    # Same, but with a const pointer return (which should *not* inhibit destruction):
-    z = m.custom_caster_destroy_const()
-    assert z
-    assert cstats.default_constructions == 3
-
-    # Make sure we still only have the original object (from ..._no_destroy()) alive:
-    assert cstats.alive() == 1
diff --git a/tmap/lib/pybind11/tests/test_modules.cpp b/tmap/lib/pybind11/tests/test_modules.cpp
deleted file mode 100644
index c1475fa..0000000
--- a/tmap/lib/pybind11/tests/test_modules.cpp
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
-    tests/test_modules.cpp -- nested modules, importing modules, and
-                            internal references
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "constructor_stats.h"
-
-TEST_SUBMODULE(modules, m) {
-    // test_nested_modules
-    py::module m_sub = m.def_submodule("subsubmodule");
-    m_sub.def("submodule_func", []() { return "submodule_func()"; });
-
-    // test_reference_internal
-    class A {
-    public:
-        A(int v) : v(v) { print_created(this, v); }
-        ~A() { print_destroyed(this); }
-        A(const A&) { print_copy_created(this); }
-        A& operator=(const A &copy) { print_copy_assigned(this); v = copy.v; return *this; }
-        std::string toString() { return "A[" + std::to_string(v) + "]"; }
-    private:
-        int v;
-    };
-    py::class_<A>(m_sub, "A")
-        .def(py::init<int>())
-        .def("__repr__", &A::toString);
-
-    class B {
-    public:
-        B() { print_default_created(this); }
-        ~B() { print_destroyed(this); }
-        B(const B&) { print_copy_created(this); }
-        B& operator=(const B &copy) { print_copy_assigned(this); a1 = copy.a1; a2 = copy.a2; return *this; }
-        A &get_a1() { return a1; }
-        A &get_a2() { return a2; }
-
-        A a1{1};
-        A a2{2};
-    };
-    py::class_<B>(m_sub, "B")
-        .def(py::init<>())
-        .def("get_a1", &B::get_a1, "Return the internal A 1", py::return_value_policy::reference_internal)
-        .def("get_a2", &B::get_a2, "Return the internal A 2", py::return_value_policy::reference_internal)
-        .def_readwrite("a1", &B::a1)  // def_readonly uses an internal reference return policy by default
-        .def_readwrite("a2", &B::a2);
-
-    m.attr("OD") = py::module::import("collections").attr("OrderedDict");
-
-    // test_duplicate_registration
-    // Registering two things with the same name
-    m.def("duplicate_registration", []() {
-        class Dupe1 { };
-        class Dupe2 { };
-        class Dupe3 { };
-        class DupeException { };
-
-        auto dm = py::module("dummy");
-        auto failures = py::list();
-
-        py::class_<Dupe1>(dm, "Dupe1");
-        py::class_<Dupe2>(dm, "Dupe2");
-        dm.def("dupe1_factory", []() { return Dupe1(); });
-        py::exception<DupeException>(dm, "DupeException");
-
-        try {
-            py::class_<Dupe1>(dm, "Dupe1");
-            failures.append("Dupe1 class");
-        } catch (std::runtime_error &) {}
-        try {
-            dm.def("Dupe1", []() { return Dupe1(); });
-            failures.append("Dupe1 function");
-        } catch (std::runtime_error &) {}
-        try {
-            py::class_<Dupe3>(dm, "dupe1_factory");
-            failures.append("dupe1_factory");
-        } catch (std::runtime_error &) {}
-        try {
-            py::exception<Dupe3>(dm, "Dupe2");
-            failures.append("Dupe2");
-        } catch (std::runtime_error &) {}
-        try {
-            dm.def("DupeException", []() { return 30; });
-            failures.append("DupeException1");
-        } catch (std::runtime_error &) {}
-        try {
-            py::class_<DupeException>(dm, "DupeException");
-            failures.append("DupeException2");
-        } catch (std::runtime_error &) {}
-
-        return failures;
-    });
-}
diff --git a/tmap/lib/pybind11/tests/test_modules.py b/tmap/lib/pybind11/tests/test_modules.py
deleted file mode 100644
index 2552838..0000000
--- a/tmap/lib/pybind11/tests/test_modules.py
+++ /dev/null
@@ -1,72 +0,0 @@
-from pybind11_tests import modules as m
-from pybind11_tests.modules import subsubmodule as ms
-from pybind11_tests import ConstructorStats
-
-
-def test_nested_modules():
-    import pybind11_tests
-    assert pybind11_tests.__name__ == "pybind11_tests"
-    assert pybind11_tests.modules.__name__ == "pybind11_tests.modules"
-    assert pybind11_tests.modules.subsubmodule.__name__ == "pybind11_tests.modules.subsubmodule"
-    assert m.__name__ == "pybind11_tests.modules"
-    assert ms.__name__ == "pybind11_tests.modules.subsubmodule"
-
-    assert ms.submodule_func() == "submodule_func()"
-
-
-def test_reference_internal():
-    b = ms.B()
-    assert str(b.get_a1()) == "A[1]"
-    assert str(b.a1) == "A[1]"
-    assert str(b.get_a2()) == "A[2]"
-    assert str(b.a2) == "A[2]"
-
-    b.a1 = ms.A(42)
-    b.a2 = ms.A(43)
-    assert str(b.get_a1()) == "A[42]"
-    assert str(b.a1) == "A[42]"
-    assert str(b.get_a2()) == "A[43]"
-    assert str(b.a2) == "A[43]"
-
-    astats, bstats = ConstructorStats.get(ms.A), ConstructorStats.get(ms.B)
-    assert astats.alive() == 2
-    assert bstats.alive() == 1
-    del b
-    assert astats.alive() == 0
-    assert bstats.alive() == 0
-    assert astats.values() == ['1', '2', '42', '43']
-    assert bstats.values() == []
-    assert astats.default_constructions == 0
-    assert bstats.default_constructions == 1
-    assert astats.copy_constructions == 0
-    assert bstats.copy_constructions == 0
-    # assert astats.move_constructions >= 0  # Don't invoke any
-    # assert bstats.move_constructions >= 0  # Don't invoke any
-    assert astats.copy_assignments == 2
-    assert bstats.copy_assignments == 0
-    assert astats.move_assignments == 0
-    assert bstats.move_assignments == 0
-
-
-def test_importing():
-    from pybind11_tests.modules import OD
-    from collections import OrderedDict
-
-    assert OD is OrderedDict
-    assert str(OD([(1, 'a'), (2, 'b')])) == "OrderedDict([(1, 'a'), (2, 'b')])"
-
-
-def test_pydoc():
-    """Pydoc needs to be able to provide help() for everything inside a pybind11 module"""
-    import pybind11_tests
-    import pydoc
-
-    assert pybind11_tests.__name__ == "pybind11_tests"
-    assert pybind11_tests.__doc__ == "pybind11 test module"
-    assert pydoc.text.docmodule(pybind11_tests)
-
-
-def test_duplicate_registration():
-    """Registering two things with the same name"""
-
-    assert m.duplicate_registration() == []
diff --git a/tmap/lib/pybind11/tests/test_multiple_inheritance.cpp b/tmap/lib/pybind11/tests/test_multiple_inheritance.cpp
deleted file mode 100644
index 35f9d9c..0000000
--- a/tmap/lib/pybind11/tests/test_multiple_inheritance.cpp
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
-    tests/test_multiple_inheritance.cpp -- multiple inheritance,
-    implicit MI casts
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "constructor_stats.h"
-
-// Many bases for testing that multiple inheritance from many classes (i.e. requiring extra
-// space for holder constructed flags) works.
-template <int N> struct BaseN {
-    BaseN(int i) : i(i) { }
-    int i;
-};
-
-// test_mi_static_properties
-struct Vanilla {
-    std::string vanilla() { return "Vanilla"; };
-};
-struct WithStatic1 {
-    static std::string static_func1() { return "WithStatic1"; };
-    static int static_value1;
-};
-struct WithStatic2 {
-    static std::string static_func2() { return "WithStatic2"; };
-    static int static_value2;
-};
-struct VanillaStaticMix1 : Vanilla, WithStatic1, WithStatic2 {
-    static std::string static_func() { return "VanillaStaticMix1"; }
-    static int static_value;
-};
-struct VanillaStaticMix2 : WithStatic1, Vanilla, WithStatic2 {
-    static std::string static_func() { return "VanillaStaticMix2"; }
-    static int static_value;
-};
-int WithStatic1::static_value1 = 1;
-int WithStatic2::static_value2 = 2;
-int VanillaStaticMix1::static_value = 12;
-int VanillaStaticMix2::static_value = 12;
-
-TEST_SUBMODULE(multiple_inheritance, m) {
-
-    // test_multiple_inheritance_mix1
-    // test_multiple_inheritance_mix2
-    struct Base1 {
-        Base1(int i) : i(i) { }
-        int foo() { return i; }
-        int i;
-    };
-    py::class_<Base1> b1(m, "Base1");
-    b1.def(py::init<int>())
-      .def("foo", &Base1::foo);
-
-    struct Base2 {
-        Base2(int i) : i(i) { }
-        int bar() { return i; }
-        int i;
-    };
-    py::class_<Base2> b2(m, "Base2");
-    b2.def(py::init<int>())
-      .def("bar", &Base2::bar);
-
-
-    // test_multiple_inheritance_cpp
-    struct Base12 : Base1, Base2 {
-        Base12(int i, int j) : Base1(i), Base2(j) { }
-    };
-    struct MIType : Base12 {
-        MIType(int i, int j) : Base12(i, j) { }
-    };
-    py::class_<Base12, Base1, Base2>(m, "Base12");
-    py::class_<MIType, Base12>(m, "MIType")
-        .def(py::init<int, int>());
-
-
-    // test_multiple_inheritance_python_many_bases
-    #define PYBIND11_BASEN(N) py::class_<BaseN<N>>(m, "BaseN" #N).def(py::init<int>()).def("f" #N, [](BaseN<N> &b) { return b.i + N; })
-    PYBIND11_BASEN( 1); PYBIND11_BASEN( 2); PYBIND11_BASEN( 3); PYBIND11_BASEN( 4);
-    PYBIND11_BASEN( 5); PYBIND11_BASEN( 6); PYBIND11_BASEN( 7); PYBIND11_BASEN( 8);
-    PYBIND11_BASEN( 9); PYBIND11_BASEN(10); PYBIND11_BASEN(11); PYBIND11_BASEN(12);
-    PYBIND11_BASEN(13); PYBIND11_BASEN(14); PYBIND11_BASEN(15); PYBIND11_BASEN(16);
-    PYBIND11_BASEN(17);
-
-    // Uncommenting this should result in a compile time failure (MI can only be specified via
-    // template parameters because pybind has to know the types involved; see discussion in #742 for
-    // details).
-//    struct Base12v2 : Base1, Base2 {
-//        Base12v2(int i, int j) : Base1(i), Base2(j) { }
-//    };
-//    py::class_<Base12v2>(m, "Base12v2", b1, b2)
-//        .def(py::init<int, int>());
-
-
-    // test_multiple_inheritance_virtbase
-    // Test the case where not all base classes are specified, and where pybind11 requires the
-    // py::multiple_inheritance flag to perform proper casting between types.
-    struct Base1a {
-        Base1a(int i) : i(i) { }
-        int foo() { return i; }
-        int i;
-    };
-    py::class_<Base1a, std::shared_ptr<Base1a>>(m, "Base1a")
-        .def(py::init<int>())
-        .def("foo", &Base1a::foo);
-
-    struct Base2a {
-        Base2a(int i) : i(i) { }
-        int bar() { return i; }
-        int i;
-    };
-    py::class_<Base2a, std::shared_ptr<Base2a>>(m, "Base2a")
-        .def(py::init<int>())
-        .def("bar", &Base2a::bar);
-
-    struct Base12a : Base1a, Base2a {
-        Base12a(int i, int j) : Base1a(i), Base2a(j) { }
-    };
-    py::class_<Base12a, /* Base1 missing */ Base2a,
-               std::shared_ptr<Base12a>>(m, "Base12a", py::multiple_inheritance())
-        .def(py::init<int, int>());
-
-    m.def("bar_base2a", [](Base2a *b) { return b->bar(); });
-    m.def("bar_base2a_sharedptr", [](std::shared_ptr<Base2a> b) { return b->bar(); });
-
-    // test_mi_unaligned_base
-    // test_mi_base_return
-    // Issue #801: invalid casting to derived type with MI bases
-    struct I801B1 { int a = 1; virtual ~I801B1() = default; };
-    struct I801B2 { int b = 2; virtual ~I801B2() = default; };
-    struct I801C : I801B1, I801B2 {};
-    struct I801D : I801C {}; // Indirect MI
-    // Unregistered classes:
-    struct I801B3 { int c = 3; virtual ~I801B3() = default; };
-    struct I801E : I801B3, I801D {};
-
-    py::class_<I801B1, std::shared_ptr<I801B1>>(m, "I801B1").def(py::init<>()).def_readonly("a", &I801B1::a);
-    py::class_<I801B2, std::shared_ptr<I801B2>>(m, "I801B2").def(py::init<>()).def_readonly("b", &I801B2::b);
-    py::class_<I801C, I801B1, I801B2, std::shared_ptr<I801C>>(m, "I801C").def(py::init<>());
-    py::class_<I801D, I801C, std::shared_ptr<I801D>>(m, "I801D").def(py::init<>());
-
-    // Two separate issues here: first, we want to recognize a pointer to a base type as being a
-    // known instance even when the pointer value is unequal (i.e. due to a non-first
-    // multiple-inheritance base class):
-    m.def("i801b1_c", [](I801C *c) { return static_cast<I801B1 *>(c); });
-    m.def("i801b2_c", [](I801C *c) { return static_cast<I801B2 *>(c); });
-    m.def("i801b1_d", [](I801D *d) { return static_cast<I801B1 *>(d); });
-    m.def("i801b2_d", [](I801D *d) { return static_cast<I801B2 *>(d); });
-
-    // Second, when returned a base class pointer to a derived instance, we cannot assume that the
-    // pointer is `reinterpret_cast`able to the derived pointer because, like above, the base class
-    // pointer could be offset.
-    m.def("i801c_b1", []() -> I801B1 * { return new I801C(); });
-    m.def("i801c_b2", []() -> I801B2 * { return new I801C(); });
-    m.def("i801d_b1", []() -> I801B1 * { return new I801D(); });
-    m.def("i801d_b2", []() -> I801B2 * { return new I801D(); });
-
-    // Return a base class pointer to a pybind-registered type when the actual derived type
-    // isn't pybind-registered (and uses multiple-inheritance to offset the pybind base)
-    m.def("i801e_c", []() -> I801C * { return new I801E(); });
-    m.def("i801e_b2", []() -> I801B2 * { return new I801E(); });
-
-
-    // test_mi_static_properties
-    py::class_<Vanilla>(m, "Vanilla")
-        .def(py::init<>())
-        .def("vanilla", &Vanilla::vanilla);
-
-    py::class_<WithStatic1>(m, "WithStatic1")
-        .def(py::init<>())
-        .def_static("static_func1", &WithStatic1::static_func1)
-        .def_readwrite_static("static_value1", &WithStatic1::static_value1);
-
-    py::class_<WithStatic2>(m, "WithStatic2")
-        .def(py::init<>())
-        .def_static("static_func2", &WithStatic2::static_func2)
-        .def_readwrite_static("static_value2", &WithStatic2::static_value2);
-
-    py::class_<VanillaStaticMix1, Vanilla, WithStatic1, WithStatic2>(
-        m, "VanillaStaticMix1")
-        .def(py::init<>())
-        .def_static("static_func", &VanillaStaticMix1::static_func)
-        .def_readwrite_static("static_value", &VanillaStaticMix1::static_value);
-
-    py::class_<VanillaStaticMix2, WithStatic1, Vanilla, WithStatic2>(
-        m, "VanillaStaticMix2")
-        .def(py::init<>())
-        .def_static("static_func", &VanillaStaticMix2::static_func)
-        .def_readwrite_static("static_value", &VanillaStaticMix2::static_value);
-
-
-#if !defined(PYPY_VERSION)
-    struct WithDict { };
-    struct VanillaDictMix1 : Vanilla, WithDict { };
-    struct VanillaDictMix2 : WithDict, Vanilla { };
-    py::class_<WithDict>(m, "WithDict", py::dynamic_attr()).def(py::init<>());
-    py::class_<VanillaDictMix1, Vanilla, WithDict>(m, "VanillaDictMix1").def(py::init<>());
-    py::class_<VanillaDictMix2, WithDict, Vanilla>(m, "VanillaDictMix2").def(py::init<>());
-#endif
-
-    // test_diamond_inheritance
-    // Issue #959: segfault when constructing diamond inheritance instance
-    // All of these have int members so that there will be various unequal pointers involved.
-    struct B { int b; virtual ~B() = default; };
-    struct C0 : public virtual B { int c0; };
-    struct C1 : public virtual B { int c1; };
-    struct D : public C0, public C1 { int d; };
-    py::class_<B>(m, "B")
-        .def("b", [](B *self) { return self; });
-    py::class_<C0, B>(m, "C0")
-        .def("c0", [](C0 *self) { return self; });
-    py::class_<C1, B>(m, "C1")
-        .def("c1", [](C1 *self) { return self; });
-    py::class_<D, C0, C1>(m, "D")
-        .def(py::init<>());
-}
diff --git a/tmap/lib/pybind11/tests/test_multiple_inheritance.py b/tmap/lib/pybind11/tests/test_multiple_inheritance.py
deleted file mode 100644
index 475dd3b..0000000
--- a/tmap/lib/pybind11/tests/test_multiple_inheritance.py
+++ /dev/null
@@ -1,349 +0,0 @@
-import pytest
-from pybind11_tests import ConstructorStats
-from pybind11_tests import multiple_inheritance as m
-
-
-def test_multiple_inheritance_cpp():
-    mt = m.MIType(3, 4)
-
-    assert mt.foo() == 3
-    assert mt.bar() == 4
-
-
-def test_multiple_inheritance_mix1():
-    class Base1:
-        def __init__(self, i):
-            self.i = i
-
-        def foo(self):
-            return self.i
-
-    class MITypePy(Base1, m.Base2):
-        def __init__(self, i, j):
-            Base1.__init__(self, i)
-            m.Base2.__init__(self, j)
-
-    mt = MITypePy(3, 4)
-
-    assert mt.foo() == 3
-    assert mt.bar() == 4
-
-
-def test_multiple_inheritance_mix2():
-
-    class Base2:
-        def __init__(self, i):
-            self.i = i
-
-        def bar(self):
-            return self.i
-
-    class MITypePy(m.Base1, Base2):
-        def __init__(self, i, j):
-            m.Base1.__init__(self, i)
-            Base2.__init__(self, j)
-
-    mt = MITypePy(3, 4)
-
-    assert mt.foo() == 3
-    assert mt.bar() == 4
-
-
-def test_multiple_inheritance_python():
-
-    class MI1(m.Base1, m.Base2):
-        def __init__(self, i, j):
-            m.Base1.__init__(self, i)
-            m.Base2.__init__(self, j)
-
-    class B1(object):
-        def v(self):
-            return 1
-
-    class MI2(B1, m.Base1, m.Base2):
-        def __init__(self, i, j):
-            B1.__init__(self)
-            m.Base1.__init__(self, i)
-            m.Base2.__init__(self, j)
-
-    class MI3(MI2):
-        def __init__(self, i, j):
-            MI2.__init__(self, i, j)
-
-    class MI4(MI3, m.Base2):
-        def __init__(self, i, j):
-            MI3.__init__(self, i, j)
-            # This should be ignored (Base2 is already initialized via MI2):
-            m.Base2.__init__(self, i + 100)
-
-    class MI5(m.Base2, B1, m.Base1):
-        def __init__(self, i, j):
-            B1.__init__(self)
-            m.Base1.__init__(self, i)
-            m.Base2.__init__(self, j)
-
-    class MI6(m.Base2, B1):
-        def __init__(self, i):
-            m.Base2.__init__(self, i)
-            B1.__init__(self)
-
-    class B2(B1):
-        def v(self):
-            return 2
-
-    class B3(object):
-        def v(self):
-            return 3
-
-    class B4(B3, B2):
-        def v(self):
-            return 4
-
-    class MI7(B4, MI6):
-        def __init__(self, i):
-            B4.__init__(self)
-            MI6.__init__(self, i)
-
-    class MI8(MI6, B3):
-        def __init__(self, i):
-            MI6.__init__(self, i)
-            B3.__init__(self)
-
-    class MI8b(B3, MI6):
-        def __init__(self, i):
-            B3.__init__(self)
-            MI6.__init__(self, i)
-
-    mi1 = MI1(1, 2)
-    assert mi1.foo() == 1
-    assert mi1.bar() == 2
-
-    mi2 = MI2(3, 4)
-    assert mi2.v() == 1
-    assert mi2.foo() == 3
-    assert mi2.bar() == 4
-
-    mi3 = MI3(5, 6)
-    assert mi3.v() == 1
-    assert mi3.foo() == 5
-    assert mi3.bar() == 6
-
-    mi4 = MI4(7, 8)
-    assert mi4.v() == 1
-    assert mi4.foo() == 7
-    assert mi4.bar() == 8
-
-    mi5 = MI5(10, 11)
-    assert mi5.v() == 1
-    assert mi5.foo() == 10
-    assert mi5.bar() == 11
-
-    mi6 = MI6(12)
-    assert mi6.v() == 1
-    assert mi6.bar() == 12
-
-    mi7 = MI7(13)
-    assert mi7.v() == 4
-    assert mi7.bar() == 13
-
-    mi8 = MI8(14)
-    assert mi8.v() == 1
-    assert mi8.bar() == 14
-
-    mi8b = MI8b(15)
-    assert mi8b.v() == 3
-    assert mi8b.bar() == 15
-
-
-def test_multiple_inheritance_python_many_bases():
-
-    class MIMany14(m.BaseN1, m.BaseN2, m.BaseN3, m.BaseN4):
-        def __init__(self):
-            m.BaseN1.__init__(self, 1)
-            m.BaseN2.__init__(self, 2)
-            m.BaseN3.__init__(self, 3)
-            m.BaseN4.__init__(self, 4)
-
-    class MIMany58(m.BaseN5, m.BaseN6, m.BaseN7, m.BaseN8):
-        def __init__(self):
-            m.BaseN5.__init__(self, 5)
-            m.BaseN6.__init__(self, 6)
-            m.BaseN7.__init__(self, 7)
-            m.BaseN8.__init__(self, 8)
-
-    class MIMany916(m.BaseN9, m.BaseN10, m.BaseN11, m.BaseN12, m.BaseN13, m.BaseN14, m.BaseN15,
-                    m.BaseN16):
-        def __init__(self):
-            m.BaseN9.__init__(self, 9)
-            m.BaseN10.__init__(self, 10)
-            m.BaseN11.__init__(self, 11)
-            m.BaseN12.__init__(self, 12)
-            m.BaseN13.__init__(self, 13)
-            m.BaseN14.__init__(self, 14)
-            m.BaseN15.__init__(self, 15)
-            m.BaseN16.__init__(self, 16)
-
-    class MIMany19(MIMany14, MIMany58, m.BaseN9):
-        def __init__(self):
-            MIMany14.__init__(self)
-            MIMany58.__init__(self)
-            m.BaseN9.__init__(self, 9)
-
-    class MIMany117(MIMany14, MIMany58, MIMany916, m.BaseN17):
-        def __init__(self):
-            MIMany14.__init__(self)
-            MIMany58.__init__(self)
-            MIMany916.__init__(self)
-            m.BaseN17.__init__(self, 17)
-
-    # Inherits from 4 registered C++ classes: can fit in one pointer on any modern arch:
-    a = MIMany14()
-    for i in range(1, 4):
-        assert getattr(a, "f" + str(i))() == 2 * i
-
-    # Inherits from 8: requires 1/2 pointers worth of holder flags on 32/64-bit arch:
-    b = MIMany916()
-    for i in range(9, 16):
-        assert getattr(b, "f" + str(i))() == 2 * i
-
-    # Inherits from 9: requires >= 2 pointers worth of holder flags
-    c = MIMany19()
-    for i in range(1, 9):
-        assert getattr(c, "f" + str(i))() == 2 * i
-
-    # Inherits from 17: requires >= 3 pointers worth of holder flags
-    d = MIMany117()
-    for i in range(1, 17):
-        assert getattr(d, "f" + str(i))() == 2 * i
-
-
-def test_multiple_inheritance_virtbase():
-
-    class MITypePy(m.Base12a):
-        def __init__(self, i, j):
-            m.Base12a.__init__(self, i, j)
-
-    mt = MITypePy(3, 4)
-    assert mt.bar() == 4
-    assert m.bar_base2a(mt) == 4
-    assert m.bar_base2a_sharedptr(mt) == 4
-
-
-def test_mi_static_properties():
-    """Mixing bases with and without static properties should be possible
-     and the result should be independent of base definition order"""
-
-    for d in (m.VanillaStaticMix1(), m.VanillaStaticMix2()):
-        assert d.vanilla() == "Vanilla"
-        assert d.static_func1() == "WithStatic1"
-        assert d.static_func2() == "WithStatic2"
-        assert d.static_func() == d.__class__.__name__
-
-        m.WithStatic1.static_value1 = 1
-        m.WithStatic2.static_value2 = 2
-        assert d.static_value1 == 1
-        assert d.static_value2 == 2
-        assert d.static_value == 12
-
-        d.static_value1 = 0
-        assert d.static_value1 == 0
-        d.static_value2 = 0
-        assert d.static_value2 == 0
-        d.static_value = 0
-        assert d.static_value == 0
-
-
-@pytest.unsupported_on_pypy
-def test_mi_dynamic_attributes():
-    """Mixing bases with and without dynamic attribute support"""
-
-    for d in (m.VanillaDictMix1(), m.VanillaDictMix2()):
-        d.dynamic = 1
-        assert d.dynamic == 1
-
-
-def test_mi_unaligned_base():
-    """Returning an offset (non-first MI) base class pointer should recognize the instance"""
-
-    n_inst = ConstructorStats.detail_reg_inst()
-
-    c = m.I801C()
-    d = m.I801D()
-    # + 4 below because we have the two instances, and each instance has offset base I801B2
-    assert ConstructorStats.detail_reg_inst() == n_inst + 4
-    b1c = m.i801b1_c(c)
-    assert b1c is c
-    b2c = m.i801b2_c(c)
-    assert b2c is c
-    b1d = m.i801b1_d(d)
-    assert b1d is d
-    b2d = m.i801b2_d(d)
-    assert b2d is d
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 4  # no extra instances
-    del c, b1c, b2c
-    assert ConstructorStats.detail_reg_inst() == n_inst + 2
-    del d, b1d, b2d
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-
-def test_mi_base_return():
-    """Tests returning an offset (non-first MI) base class pointer to a derived instance"""
-
-    n_inst = ConstructorStats.detail_reg_inst()
-
-    c1 = m.i801c_b1()
-    assert type(c1) is m.I801C
-    assert c1.a == 1
-    assert c1.b == 2
-
-    d1 = m.i801d_b1()
-    assert type(d1) is m.I801D
-    assert d1.a == 1
-    assert d1.b == 2
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 4
-
-    c2 = m.i801c_b2()
-    assert type(c2) is m.I801C
-    assert c2.a == 1
-    assert c2.b == 2
-
-    d2 = m.i801d_b2()
-    assert type(d2) is m.I801D
-    assert d2.a == 1
-    assert d2.b == 2
-
-    assert ConstructorStats.detail_reg_inst() == n_inst + 8
-
-    del c2
-    assert ConstructorStats.detail_reg_inst() == n_inst + 6
-    del c1, d1, d2
-    assert ConstructorStats.detail_reg_inst() == n_inst
-
-    # Returning an unregistered derived type with a registered base; we won't
-    # pick up the derived type, obviously, but should still work (as an object
-    # of whatever type was returned).
-    e1 = m.i801e_c()
-    assert type(e1) is m.I801C
-    assert e1.a == 1
-    assert e1.b == 2
-
-    e2 = m.i801e_b2()
-    assert type(e2) is m.I801B2
-    assert e2.b == 2
-
-
-def test_diamond_inheritance():
-    """Tests that diamond inheritance works as expected (issue #959)"""
-
-    # Issue #959: this shouldn't segfault:
-    d = m.D()
-
-    # Make sure all the various distinct pointers are all recognized as registered instances:
-    assert d is d.c0()
-    assert d is d.c1()
-    assert d is d.b()
-    assert d is d.c0().b()
-    assert d is d.c1().b()
-    assert d is d.c0().c1().b().c0().b()
diff --git a/tmap/lib/pybind11/tests/test_numpy_array.cpp b/tmap/lib/pybind11/tests/test_numpy_array.cpp
deleted file mode 100644
index 2046c0e..0000000
--- a/tmap/lib/pybind11/tests/test_numpy_array.cpp
+++ /dev/null
@@ -1,295 +0,0 @@
-/*
-    tests/test_numpy_array.cpp -- test core array functionality
-
-    Copyright (c) 2016 Ivan Smirnov <i.s.smirnov@gmail.com>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-
-#include <pybind11/numpy.h>
-#include <pybind11/stl.h>
-
-#include <cstdint>
-
-using arr = py::array;
-using arr_t = py::array_t<uint16_t, 0>;
-static_assert(std::is_same<arr_t::value_type, uint16_t>::value, "");
-
-template<typename... Ix> arr data(const arr& a, Ix... index) {
-    return arr(a.nbytes() - a.offset_at(index...), (const uint8_t *) a.data(index...));
-}
-
-template<typename... Ix> arr data_t(const arr_t& a, Ix... index) {
-    return arr(a.size() - a.index_at(index...), a.data(index...));
-}
-
-template<typename... Ix> arr& mutate_data(arr& a, Ix... index) {
-    auto ptr = (uint8_t *) a.mutable_data(index...);
-    for (ssize_t i = 0; i < a.nbytes() - a.offset_at(index...); i++)
-        ptr[i] = (uint8_t) (ptr[i] * 2);
-    return a;
-}
-
-template<typename... Ix> arr_t& mutate_data_t(arr_t& a, Ix... index) {
-    auto ptr = a.mutable_data(index...);
-    for (ssize_t i = 0; i < a.size() - a.index_at(index...); i++)
-        ptr[i]++;
-    return a;
-}
-
-template<typename... Ix> ssize_t index_at(const arr& a, Ix... idx) { return a.index_at(idx...); }
-template<typename... Ix> ssize_t index_at_t(const arr_t& a, Ix... idx) { return a.index_at(idx...); }
-template<typename... Ix> ssize_t offset_at(const arr& a, Ix... idx) { return a.offset_at(idx...); }
-template<typename... Ix> ssize_t offset_at_t(const arr_t& a, Ix... idx) { return a.offset_at(idx...); }
-template<typename... Ix> ssize_t at_t(const arr_t& a, Ix... idx) { return a.at(idx...); }
-template<typename... Ix> arr_t& mutate_at_t(arr_t& a, Ix... idx) { a.mutable_at(idx...)++; return a; }
-
-#define def_index_fn(name, type) \
-    sm.def(#name, [](type a) { return name(a); }); \
-    sm.def(#name, [](type a, int i) { return name(a, i); }); \
-    sm.def(#name, [](type a, int i, int j) { return name(a, i, j); }); \
-    sm.def(#name, [](type a, int i, int j, int k) { return name(a, i, j, k); });
-
-template <typename T, typename T2> py::handle auxiliaries(T &&r, T2 &&r2) {
-    if (r.ndim() != 2) throw std::domain_error("error: ndim != 2");
-    py::list l;
-    l.append(*r.data(0, 0));
-    l.append(*r2.mutable_data(0, 0));
-    l.append(r.data(0, 1) == r2.mutable_data(0, 1));
-    l.append(r.ndim());
-    l.append(r.itemsize());
-    l.append(r.shape(0));
-    l.append(r.shape(1));
-    l.append(r.size());
-    l.append(r.nbytes());
-    return l.release();
-}
-
-TEST_SUBMODULE(numpy_array, sm) {
-    try { py::module::import("numpy"); }
-    catch (...) { return; }
-
-    // test_array_attributes
-    sm.def("ndim", [](const arr& a) { return a.ndim(); });
-    sm.def("shape", [](const arr& a) { return arr(a.ndim(), a.shape()); });
-    sm.def("shape", [](const arr& a, ssize_t dim) { return a.shape(dim); });
-    sm.def("strides", [](const arr& a) { return arr(a.ndim(), a.strides()); });
-    sm.def("strides", [](const arr& a, ssize_t dim) { return a.strides(dim); });
-    sm.def("writeable", [](const arr& a) { return a.writeable(); });
-    sm.def("size", [](const arr& a) { return a.size(); });
-    sm.def("itemsize", [](const arr& a) { return a.itemsize(); });
-    sm.def("nbytes", [](const arr& a) { return a.nbytes(); });
-    sm.def("owndata", [](const arr& a) { return a.owndata(); });
-
-    // test_index_offset
-    def_index_fn(index_at, const arr&);
-    def_index_fn(index_at_t, const arr_t&);
-    def_index_fn(offset_at, const arr&);
-    def_index_fn(offset_at_t, const arr_t&);
-    // test_data
-    def_index_fn(data, const arr&);
-    def_index_fn(data_t, const arr_t&);
-    // test_mutate_data, test_mutate_readonly
-    def_index_fn(mutate_data, arr&);
-    def_index_fn(mutate_data_t, arr_t&);
-    def_index_fn(at_t, const arr_t&);
-    def_index_fn(mutate_at_t, arr_t&);
-
-    // test_make_c_f_array
-    sm.def("make_f_array", [] { return py::array_t<float>({ 2, 2 }, { 4, 8 }); });
-    sm.def("make_c_array", [] { return py::array_t<float>({ 2, 2 }, { 8, 4 }); });
-
-    // test_wrap
-    sm.def("wrap", [](py::array a) {
-        return py::array(
-            a.dtype(),
-            {a.shape(), a.shape() + a.ndim()},
-            {a.strides(), a.strides() + a.ndim()},
-            a.data(),
-            a
-        );
-    });
-
-    // test_numpy_view
-    struct ArrayClass {
-        int data[2] = { 1, 2 };
-        ArrayClass() { py::print("ArrayClass()"); }
-        ~ArrayClass() { py::print("~ArrayClass()"); }
-    };
-    py::class_<ArrayClass>(sm, "ArrayClass")
-        .def(py::init<>())
-        .def("numpy_view", [](py::object &obj) {
-            py::print("ArrayClass::numpy_view()");
-            ArrayClass &a = obj.cast<ArrayClass&>();
-            return py::array_t<int>({2}, {4}, a.data, obj);
-        }
-    );
-
-    // test_cast_numpy_int64_to_uint64
-    sm.def("function_taking_uint64", [](uint64_t) { });
-
-    // test_isinstance
-    sm.def("isinstance_untyped", [](py::object yes, py::object no) {
-        return py::isinstance<py::array>(yes) && !py::isinstance<py::array>(no);
-    });
-    sm.def("isinstance_typed", [](py::object o) {
-        return py::isinstance<py::array_t<double>>(o) && !py::isinstance<py::array_t<int>>(o);
-    });
-
-    // test_constructors
-    sm.def("default_constructors", []() {
-        return py::dict(
-            "array"_a=py::array(),
-            "array_t<int32>"_a=py::array_t<std::int32_t>(),
-            "array_t<double>"_a=py::array_t<double>()
-        );
-    });
-    sm.def("converting_constructors", [](py::object o) {
-        return py::dict(
-            "array"_a=py::array(o),
-            "array_t<int32>"_a=py::array_t<std::int32_t>(o),
-            "array_t<double>"_a=py::array_t<double>(o)
-        );
-    });
-
-    // test_overload_resolution
-    sm.def("overloaded", [](py::array_t<double>) { return "double"; });
-    sm.def("overloaded", [](py::array_t<float>) { return "float"; });
-    sm.def("overloaded", [](py::array_t<int>) { return "int"; });
-    sm.def("overloaded", [](py::array_t<unsigned short>) { return "unsigned short"; });
-    sm.def("overloaded", [](py::array_t<long long>) { return "long long"; });
-    sm.def("overloaded", [](py::array_t<std::complex<double>>) { return "double complex"; });
-    sm.def("overloaded", [](py::array_t<std::complex<float>>) { return "float complex"; });
-
-    sm.def("overloaded2", [](py::array_t<std::complex<double>>) { return "double complex"; });
-    sm.def("overloaded2", [](py::array_t<double>) { return "double"; });
-    sm.def("overloaded2", [](py::array_t<std::complex<float>>) { return "float complex"; });
-    sm.def("overloaded2", [](py::array_t<float>) { return "float"; });
-
-    // Only accept the exact types:
-    sm.def("overloaded3", [](py::array_t<int>) { return "int"; }, py::arg().noconvert());
-    sm.def("overloaded3", [](py::array_t<double>) { return "double"; }, py::arg().noconvert());
-
-    // Make sure we don't do unsafe coercion (e.g. float to int) when not using forcecast, but
-    // rather that float gets converted via the safe (conversion to double) overload:
-    sm.def("overloaded4", [](py::array_t<long long, 0>) { return "long long"; });
-    sm.def("overloaded4", [](py::array_t<double, 0>) { return "double"; });
-
-    // But we do allow conversion to int if forcecast is enabled (but only if no overload matches
-    // without conversion)
-    sm.def("overloaded5", [](py::array_t<unsigned int>) { return "unsigned int"; });
-    sm.def("overloaded5", [](py::array_t<double>) { return "double"; });
-
-    // test_greedy_string_overload
-    // Issue 685: ndarray shouldn't go to std::string overload
-    sm.def("issue685", [](std::string) { return "string"; });
-    sm.def("issue685", [](py::array) { return "array"; });
-    sm.def("issue685", [](py::object) { return "other"; });
-
-    // test_array_unchecked_fixed_dims
-    sm.def("proxy_add2", [](py::array_t<double> a, double v) {
-        auto r = a.mutable_unchecked<2>();
-        for (ssize_t i = 0; i < r.shape(0); i++)
-            for (ssize_t j = 0; j < r.shape(1); j++)
-                r(i, j) += v;
-    }, py::arg().noconvert(), py::arg());
-
-    sm.def("proxy_init3", [](double start) {
-        py::array_t<double, py::array::c_style> a({ 3, 3, 3 });
-        auto r = a.mutable_unchecked<3>();
-        for (ssize_t i = 0; i < r.shape(0); i++)
-        for (ssize_t j = 0; j < r.shape(1); j++)
-        for (ssize_t k = 0; k < r.shape(2); k++)
-            r(i, j, k) = start++;
-        return a;
-    });
-    sm.def("proxy_init3F", [](double start) {
-        py::array_t<double, py::array::f_style> a({ 3, 3, 3 });
-        auto r = a.mutable_unchecked<3>();
-        for (ssize_t k = 0; k < r.shape(2); k++)
-        for (ssize_t j = 0; j < r.shape(1); j++)
-        for (ssize_t i = 0; i < r.shape(0); i++)
-            r(i, j, k) = start++;
-        return a;
-    });
-    sm.def("proxy_squared_L2_norm", [](py::array_t<double> a) {
-        auto r = a.unchecked<1>();
-        double sumsq = 0;
-        for (ssize_t i = 0; i < r.shape(0); i++)
-            sumsq += r[i] * r(i); // Either notation works for a 1D array
-        return sumsq;
-    });
-
-    sm.def("proxy_auxiliaries2", [](py::array_t<double> a) {
-        auto r = a.unchecked<2>();
-        auto r2 = a.mutable_unchecked<2>();
-        return auxiliaries(r, r2);
-    });
-
-    // test_array_unchecked_dyn_dims
-    // Same as the above, but without a compile-time dimensions specification:
-    sm.def("proxy_add2_dyn", [](py::array_t<double> a, double v) {
-        auto r = a.mutable_unchecked();
-        if (r.ndim() != 2) throw std::domain_error("error: ndim != 2");
-        for (ssize_t i = 0; i < r.shape(0); i++)
-            for (ssize_t j = 0; j < r.shape(1); j++)
-                r(i, j) += v;
-    }, py::arg().noconvert(), py::arg());
-    sm.def("proxy_init3_dyn", [](double start) {
-        py::array_t<double, py::array::c_style> a({ 3, 3, 3 });
-        auto r = a.mutable_unchecked();
-        if (r.ndim() != 3) throw std::domain_error("error: ndim != 3");
-        for (ssize_t i = 0; i < r.shape(0); i++)
-        for (ssize_t j = 0; j < r.shape(1); j++)
-        for (ssize_t k = 0; k < r.shape(2); k++)
-            r(i, j, k) = start++;
-        return a;
-    });
-    sm.def("proxy_auxiliaries2_dyn", [](py::array_t<double> a) {
-        return auxiliaries(a.unchecked(), a.mutable_unchecked());
-    });
-
-    sm.def("array_auxiliaries2", [](py::array_t<double> a) {
-        return auxiliaries(a, a);
-    });
-
-    // test_array_failures
-    // Issue #785: Uninformative "Unknown internal error" exception when constructing array from empty object:
-    sm.def("array_fail_test", []() { return py::array(py::object()); });
-    sm.def("array_t_fail_test", []() { return py::array_t<double>(py::object()); });
-    // Make sure the error from numpy is being passed through:
-    sm.def("array_fail_test_negative_size", []() { int c = 0; return py::array(-1, &c); });
-
-    // test_initializer_list
-    // Issue (unnumbered; reported in #788): regression: initializer lists can be ambiguous
-    sm.def("array_initializer_list1", []() { return py::array_t<float>(1); }); // { 1 } also works, but clang warns about it
-    sm.def("array_initializer_list2", []() { return py::array_t<float>({ 1, 2 }); });
-    sm.def("array_initializer_list3", []() { return py::array_t<float>({ 1, 2, 3 }); });
-    sm.def("array_initializer_list4", []() { return py::array_t<float>({ 1, 2, 3, 4 }); });
-
-    // test_array_resize
-    // reshape array to 2D without changing size
-    sm.def("array_reshape2", [](py::array_t<double> a) {
-        const ssize_t dim_sz = (ssize_t)std::sqrt(a.size());
-        if (dim_sz * dim_sz != a.size())
-            throw std::domain_error("array_reshape2: input array total size is not a squared integer");
-        a.resize({dim_sz, dim_sz});
-    });
-
-    // resize to 3D array with each dimension = N
-    sm.def("array_resize3", [](py::array_t<double> a, size_t N, bool refcheck) {
-        a.resize({N, N, N}, refcheck);
-    });
-
-    // test_array_create_and_resize
-    // return 2D array with Nrows = Ncols = N
-    sm.def("create_and_resize", [](size_t N) {
-        py::array_t<double> a;
-        a.resize({N, N});
-        std::fill(a.mutable_data(), a.mutable_data() + a.size(), 42.);
-        return a;
-    });
-}
diff --git a/tmap/lib/pybind11/tests/test_numpy_array.py b/tmap/lib/pybind11/tests/test_numpy_array.py
deleted file mode 100644
index 2743393..0000000
--- a/tmap/lib/pybind11/tests/test_numpy_array.py
+++ /dev/null
@@ -1,402 +0,0 @@
-import pytest
-from pybind11_tests import numpy_array as m
-
-pytestmark = pytest.requires_numpy
-
-with pytest.suppress(ImportError):
-    import numpy as np
-
-
-@pytest.fixture(scope='function')
-def arr():
-    return np.array([[1, 2, 3], [4, 5, 6]], '=u2')
-
-
-def test_array_attributes():
-    a = np.array(0, 'f8')
-    assert m.ndim(a) == 0
-    assert all(m.shape(a) == [])
-    assert all(m.strides(a) == [])
-    with pytest.raises(IndexError) as excinfo:
-        m.shape(a, 0)
-    assert str(excinfo.value) == 'invalid axis: 0 (ndim = 0)'
-    with pytest.raises(IndexError) as excinfo:
-        m.strides(a, 0)
-    assert str(excinfo.value) == 'invalid axis: 0 (ndim = 0)'
-    assert m.writeable(a)
-    assert m.size(a) == 1
-    assert m.itemsize(a) == 8
-    assert m.nbytes(a) == 8
-    assert m.owndata(a)
-
-    a = np.array([[1, 2, 3], [4, 5, 6]], 'u2').view()
-    a.flags.writeable = False
-    assert m.ndim(a) == 2
-    assert all(m.shape(a) == [2, 3])
-    assert m.shape(a, 0) == 2
-    assert m.shape(a, 1) == 3
-    assert all(m.strides(a) == [6, 2])
-    assert m.strides(a, 0) == 6
-    assert m.strides(a, 1) == 2
-    with pytest.raises(IndexError) as excinfo:
-        m.shape(a, 2)
-    assert str(excinfo.value) == 'invalid axis: 2 (ndim = 2)'
-    with pytest.raises(IndexError) as excinfo:
-        m.strides(a, 2)
-    assert str(excinfo.value) == 'invalid axis: 2 (ndim = 2)'
-    assert not m.writeable(a)
-    assert m.size(a) == 6
-    assert m.itemsize(a) == 2
-    assert m.nbytes(a) == 12
-    assert not m.owndata(a)
-
-
-@pytest.mark.parametrize('args, ret', [([], 0), ([0], 0), ([1], 3), ([0, 1], 1), ([1, 2], 5)])
-def test_index_offset(arr, args, ret):
-    assert m.index_at(arr, *args) == ret
-    assert m.index_at_t(arr, *args) == ret
-    assert m.offset_at(arr, *args) == ret * arr.dtype.itemsize
-    assert m.offset_at_t(arr, *args) == ret * arr.dtype.itemsize
-
-
-def test_dim_check_fail(arr):
-    for func in (m.index_at, m.index_at_t, m.offset_at, m.offset_at_t, m.data, m.data_t,
-                 m.mutate_data, m.mutate_data_t):
-        with pytest.raises(IndexError) as excinfo:
-            func(arr, 1, 2, 3)
-        assert str(excinfo.value) == 'too many indices for an array: 3 (ndim = 2)'
-
-
-@pytest.mark.parametrize('args, ret',
-                         [([], [1, 2, 3, 4, 5, 6]),
-                          ([1], [4, 5, 6]),
-                          ([0, 1], [2, 3, 4, 5, 6]),
-                          ([1, 2], [6])])
-def test_data(arr, args, ret):
-    from sys import byteorder
-    assert all(m.data_t(arr, *args) == ret)
-    assert all(m.data(arr, *args)[(0 if byteorder == 'little' else 1)::2] == ret)
-    assert all(m.data(arr, *args)[(1 if byteorder == 'little' else 0)::2] == 0)
-
-
-@pytest.mark.parametrize('dim', [0, 1, 3])
-def test_at_fail(arr, dim):
-    for func in m.at_t, m.mutate_at_t:
-        with pytest.raises(IndexError) as excinfo:
-            func(arr, *([0] * dim))
-        assert str(excinfo.value) == 'index dimension mismatch: {} (ndim = 2)'.format(dim)
-
-
-def test_at(arr):
-    assert m.at_t(arr, 0, 2) == 3
-    assert m.at_t(arr, 1, 0) == 4
-
-    assert all(m.mutate_at_t(arr, 0, 2).ravel() == [1, 2, 4, 4, 5, 6])
-    assert all(m.mutate_at_t(arr, 1, 0).ravel() == [1, 2, 4, 5, 5, 6])
-
-
-def test_mutate_readonly(arr):
-    arr.flags.writeable = False
-    for func, args in (m.mutate_data, ()), (m.mutate_data_t, ()), (m.mutate_at_t, (0, 0)):
-        with pytest.raises(ValueError) as excinfo:
-            func(arr, *args)
-        assert str(excinfo.value) == 'array is not writeable'
-
-
-def test_mutate_data(arr):
-    assert all(m.mutate_data(arr).ravel() == [2, 4, 6, 8, 10, 12])
-    assert all(m.mutate_data(arr).ravel() == [4, 8, 12, 16, 20, 24])
-    assert all(m.mutate_data(arr, 1).ravel() == [4, 8, 12, 32, 40, 48])
-    assert all(m.mutate_data(arr, 0, 1).ravel() == [4, 16, 24, 64, 80, 96])
-    assert all(m.mutate_data(arr, 1, 2).ravel() == [4, 16, 24, 64, 80, 192])
-
-    assert all(m.mutate_data_t(arr).ravel() == [5, 17, 25, 65, 81, 193])
-    assert all(m.mutate_data_t(arr).ravel() == [6, 18, 26, 66, 82, 194])
-    assert all(m.mutate_data_t(arr, 1).ravel() == [6, 18, 26, 67, 83, 195])
-    assert all(m.mutate_data_t(arr, 0, 1).ravel() == [6, 19, 27, 68, 84, 196])
-    assert all(m.mutate_data_t(arr, 1, 2).ravel() == [6, 19, 27, 68, 84, 197])
-
-
-def test_bounds_check(arr):
-    for func in (m.index_at, m.index_at_t, m.data, m.data_t,
-                 m.mutate_data, m.mutate_data_t, m.at_t, m.mutate_at_t):
-        with pytest.raises(IndexError) as excinfo:
-            func(arr, 2, 0)
-        assert str(excinfo.value) == 'index 2 is out of bounds for axis 0 with size 2'
-        with pytest.raises(IndexError) as excinfo:
-            func(arr, 0, 4)
-        assert str(excinfo.value) == 'index 4 is out of bounds for axis 1 with size 3'
-
-
-def test_make_c_f_array():
-    assert m.make_c_array().flags.c_contiguous
-    assert not m.make_c_array().flags.f_contiguous
-    assert m.make_f_array().flags.f_contiguous
-    assert not m.make_f_array().flags.c_contiguous
-
-
-def test_wrap():
-    def assert_references(a, b, base=None):
-        if base is None:
-            base = a
-        assert a is not b
-        assert a.__array_interface__['data'][0] == b.__array_interface__['data'][0]
-        assert a.shape == b.shape
-        assert a.strides == b.strides
-        assert a.flags.c_contiguous == b.flags.c_contiguous
-        assert a.flags.f_contiguous == b.flags.f_contiguous
-        assert a.flags.writeable == b.flags.writeable
-        assert a.flags.aligned == b.flags.aligned
-        assert a.flags.updateifcopy == b.flags.updateifcopy
-        assert np.all(a == b)
-        assert not b.flags.owndata
-        assert b.base is base
-        if a.flags.writeable and a.ndim == 2:
-            a[0, 0] = 1234
-            assert b[0, 0] == 1234
-
-    a1 = np.array([1, 2], dtype=np.int16)
-    assert a1.flags.owndata and a1.base is None
-    a2 = m.wrap(a1)
-    assert_references(a1, a2)
-
-    a1 = np.array([[1, 2], [3, 4]], dtype=np.float32, order='F')
-    assert a1.flags.owndata and a1.base is None
-    a2 = m.wrap(a1)
-    assert_references(a1, a2)
-
-    a1 = np.array([[1, 2], [3, 4]], dtype=np.float32, order='C')
-    a1.flags.writeable = False
-    a2 = m.wrap(a1)
-    assert_references(a1, a2)
-
-    a1 = np.random.random((4, 4, 4))
-    a2 = m.wrap(a1)
-    assert_references(a1, a2)
-
-    a1t = a1.transpose()
-    a2 = m.wrap(a1t)
-    assert_references(a1t, a2, a1)
-
-    a1d = a1.diagonal()
-    a2 = m.wrap(a1d)
-    assert_references(a1d, a2, a1)
-
-    a1m = a1[::-1, ::-1, ::-1]
-    a2 = m.wrap(a1m)
-    assert_references(a1m, a2, a1)
-
-
-def test_numpy_view(capture):
-    with capture:
-        ac = m.ArrayClass()
-        ac_view_1 = ac.numpy_view()
-        ac_view_2 = ac.numpy_view()
-        assert np.all(ac_view_1 == np.array([1, 2], dtype=np.int32))
-        del ac
-        pytest.gc_collect()
-    assert capture == """
-        ArrayClass()
-        ArrayClass::numpy_view()
-        ArrayClass::numpy_view()
-    """
-    ac_view_1[0] = 4
-    ac_view_1[1] = 3
-    assert ac_view_2[0] == 4
-    assert ac_view_2[1] == 3
-    with capture:
-        del ac_view_1
-        del ac_view_2
-        pytest.gc_collect()
-        pytest.gc_collect()
-    assert capture == """
-        ~ArrayClass()
-    """
-
-
-@pytest.unsupported_on_pypy
-def test_cast_numpy_int64_to_uint64():
-    m.function_taking_uint64(123)
-    m.function_taking_uint64(np.uint64(123))
-
-
-def test_isinstance():
-    assert m.isinstance_untyped(np.array([1, 2, 3]), "not an array")
-    assert m.isinstance_typed(np.array([1.0, 2.0, 3.0]))
-
-
-def test_constructors():
-    defaults = m.default_constructors()
-    for a in defaults.values():
-        assert a.size == 0
-    assert defaults["array"].dtype == np.array([]).dtype
-    assert defaults["array_t<int32>"].dtype == np.int32
-    assert defaults["array_t<double>"].dtype == np.float64
-
-    results = m.converting_constructors([1, 2, 3])
-    for a in results.values():
-        np.testing.assert_array_equal(a, [1, 2, 3])
-    assert results["array"].dtype == np.int_
-    assert results["array_t<int32>"].dtype == np.int32
-    assert results["array_t<double>"].dtype == np.float64
-
-
-def test_overload_resolution(msg):
-    # Exact overload matches:
-    assert m.overloaded(np.array([1], dtype='float64')) == 'double'
-    assert m.overloaded(np.array([1], dtype='float32')) == 'float'
-    assert m.overloaded(np.array([1], dtype='ushort')) == 'unsigned short'
-    assert m.overloaded(np.array([1], dtype='intc')) == 'int'
-    assert m.overloaded(np.array([1], dtype='longlong')) == 'long long'
-    assert m.overloaded(np.array([1], dtype='complex')) == 'double complex'
-    assert m.overloaded(np.array([1], dtype='csingle')) == 'float complex'
-
-    # No exact match, should call first convertible version:
-    assert m.overloaded(np.array([1], dtype='uint8')) == 'double'
-
-    with pytest.raises(TypeError) as excinfo:
-        m.overloaded("not an array")
-    assert msg(excinfo.value) == """
-        overloaded(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: numpy.ndarray[float64]) -> str
-            2. (arg0: numpy.ndarray[float32]) -> str
-            3. (arg0: numpy.ndarray[int32]) -> str
-            4. (arg0: numpy.ndarray[uint16]) -> str
-            5. (arg0: numpy.ndarray[int64]) -> str
-            6. (arg0: numpy.ndarray[complex128]) -> str
-            7. (arg0: numpy.ndarray[complex64]) -> str
-
-        Invoked with: 'not an array'
-    """
-
-    assert m.overloaded2(np.array([1], dtype='float64')) == 'double'
-    assert m.overloaded2(np.array([1], dtype='float32')) == 'float'
-    assert m.overloaded2(np.array([1], dtype='complex64')) == 'float complex'
-    assert m.overloaded2(np.array([1], dtype='complex128')) == 'double complex'
-    assert m.overloaded2(np.array([1], dtype='float32')) == 'float'
-
-    assert m.overloaded3(np.array([1], dtype='float64')) == 'double'
-    assert m.overloaded3(np.array([1], dtype='intc')) == 'int'
-    expected_exc = """
-        overloaded3(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: numpy.ndarray[int32]) -> str
-            2. (arg0: numpy.ndarray[float64]) -> str
-
-        Invoked with:"""
-
-    with pytest.raises(TypeError) as excinfo:
-        m.overloaded3(np.array([1], dtype='uintc'))
-    assert msg(excinfo.value) == expected_exc + " array([1], dtype=uint32)"
-    with pytest.raises(TypeError) as excinfo:
-        m.overloaded3(np.array([1], dtype='float32'))
-    assert msg(excinfo.value) == expected_exc + " array([ 1.], dtype=float32)"
-    with pytest.raises(TypeError) as excinfo:
-        m.overloaded3(np.array([1], dtype='complex'))
-    assert msg(excinfo.value) == expected_exc + " array([ 1.+0.j])"
-
-    # Exact matches:
-    assert m.overloaded4(np.array([1], dtype='double')) == 'double'
-    assert m.overloaded4(np.array([1], dtype='longlong')) == 'long long'
-    # Non-exact matches requiring conversion.  Since float to integer isn't a
-    # save conversion, it should go to the double overload, but short can go to
-    # either (and so should end up on the first-registered, the long long).
-    assert m.overloaded4(np.array([1], dtype='float32')) == 'double'
-    assert m.overloaded4(np.array([1], dtype='short')) == 'long long'
-
-    assert m.overloaded5(np.array([1], dtype='double')) == 'double'
-    assert m.overloaded5(np.array([1], dtype='uintc')) == 'unsigned int'
-    assert m.overloaded5(np.array([1], dtype='float32')) == 'unsigned int'
-
-
-def test_greedy_string_overload():
-    """Tests fix for #685 - ndarray shouldn't go to std::string overload"""
-
-    assert m.issue685("abc") == "string"
-    assert m.issue685(np.array([97, 98, 99], dtype='b')) == "array"
-    assert m.issue685(123) == "other"
-
-
-def test_array_unchecked_fixed_dims(msg):
-    z1 = np.array([[1, 2], [3, 4]], dtype='float64')
-    m.proxy_add2(z1, 10)
-    assert np.all(z1 == [[11, 12], [13, 14]])
-
-    with pytest.raises(ValueError) as excinfo:
-        m.proxy_add2(np.array([1., 2, 3]), 5.0)
-    assert msg(excinfo.value) == "array has incorrect number of dimensions: 1; expected 2"
-
-    expect_c = np.ndarray(shape=(3, 3, 3), buffer=np.array(range(3, 30)), dtype='int')
-    assert np.all(m.proxy_init3(3.0) == expect_c)
-    expect_f = np.transpose(expect_c)
-    assert np.all(m.proxy_init3F(3.0) == expect_f)
-
-    assert m.proxy_squared_L2_norm(np.array(range(6))) == 55
-    assert m.proxy_squared_L2_norm(np.array(range(6), dtype="float64")) == 55
-
-    assert m.proxy_auxiliaries2(z1) == [11, 11, True, 2, 8, 2, 2, 4, 32]
-    assert m.proxy_auxiliaries2(z1) == m.array_auxiliaries2(z1)
-
-
-def test_array_unchecked_dyn_dims(msg):
-    z1 = np.array([[1, 2], [3, 4]], dtype='float64')
-    m.proxy_add2_dyn(z1, 10)
-    assert np.all(z1 == [[11, 12], [13, 14]])
-
-    expect_c = np.ndarray(shape=(3, 3, 3), buffer=np.array(range(3, 30)), dtype='int')
-    assert np.all(m.proxy_init3_dyn(3.0) == expect_c)
-
-    assert m.proxy_auxiliaries2_dyn(z1) == [11, 11, True, 2, 8, 2, 2, 4, 32]
-    assert m.proxy_auxiliaries2_dyn(z1) == m.array_auxiliaries2(z1)
-
-
-def test_array_failure():
-    with pytest.raises(ValueError) as excinfo:
-        m.array_fail_test()
-    assert str(excinfo.value) == 'cannot create a pybind11::array from a nullptr'
-
-    with pytest.raises(ValueError) as excinfo:
-        m.array_t_fail_test()
-    assert str(excinfo.value) == 'cannot create a pybind11::array_t from a nullptr'
-
-    with pytest.raises(ValueError) as excinfo:
-        m.array_fail_test_negative_size()
-    assert str(excinfo.value) == 'negative dimensions are not allowed'
-
-
-def test_initializer_list():
-    assert m.array_initializer_list1().shape == (1,)
-    assert m.array_initializer_list2().shape == (1, 2)
-    assert m.array_initializer_list3().shape == (1, 2, 3)
-    assert m.array_initializer_list4().shape == (1, 2, 3, 4)
-
-
-def test_array_resize(msg):
-    a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype='float64')
-    m.array_reshape2(a)
-    assert(a.size == 9)
-    assert(np.all(a == [[1, 2, 3], [4, 5, 6], [7, 8, 9]]))
-
-    # total size change should succced with refcheck off
-    m.array_resize3(a, 4, False)
-    assert(a.size == 64)
-    # ... and fail with refcheck on
-    try:
-        m.array_resize3(a, 3, True)
-    except ValueError as e:
-        assert(str(e).startswith("cannot resize an array"))
-    # transposed array doesn't own data
-    b = a.transpose()
-    try:
-        m.array_resize3(b, 3, False)
-    except ValueError as e:
-        assert(str(e).startswith("cannot resize this array: it does not own its data"))
-    # ... but reshape should be fine
-    m.array_reshape2(b)
-    assert(b.shape == (8, 8))
-
-
-@pytest.unsupported_on_pypy
-def test_array_create_and_resize(msg):
-    a = m.create_and_resize(2)
-    assert(a.size == 4)
-    assert(np.all(a == 42.))
diff --git a/tmap/lib/pybind11/tests/test_numpy_dtypes.cpp b/tmap/lib/pybind11/tests/test_numpy_dtypes.cpp
deleted file mode 100644
index ddec851..0000000
--- a/tmap/lib/pybind11/tests/test_numpy_dtypes.cpp
+++ /dev/null
@@ -1,451 +0,0 @@
-/*
-  tests/test_numpy_dtypes.cpp -- Structured and compound NumPy dtypes
-
-  Copyright (c) 2016 Ivan Smirnov
-
-  All rights reserved. Use of this source code is governed by a
-  BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include <pybind11/numpy.h>
-
-#ifdef __GNUC__
-#define PYBIND11_PACKED(cls) cls __attribute__((__packed__))
-#else
-#define PYBIND11_PACKED(cls) __pragma(pack(push, 1)) cls __pragma(pack(pop))
-#endif
-
-namespace py = pybind11;
-
-struct SimpleStruct {
-    bool bool_;
-    uint32_t uint_;
-    float float_;
-    long double ldbl_;
-};
-
-std::ostream& operator<<(std::ostream& os, const SimpleStruct& v) {
-    return os << "s:" << v.bool_ << "," << v.uint_ << "," << v.float_ << "," << v.ldbl_;
-}
-
-PYBIND11_PACKED(struct PackedStruct {
-    bool bool_;
-    uint32_t uint_;
-    float float_;
-    long double ldbl_;
-});
-
-std::ostream& operator<<(std::ostream& os, const PackedStruct& v) {
-    return os << "p:" << v.bool_ << "," << v.uint_ << "," << v.float_ << "," << v.ldbl_;
-}
-
-PYBIND11_PACKED(struct NestedStruct {
-    SimpleStruct a;
-    PackedStruct b;
-});
-
-std::ostream& operator<<(std::ostream& os, const NestedStruct& v) {
-    return os << "n:a=" << v.a << ";b=" << v.b;
-}
-
-struct PartialStruct {
-    bool bool_;
-    uint32_t uint_;
-    float float_;
-    uint64_t dummy2;
-    long double ldbl_;
-};
-
-struct PartialNestedStruct {
-    uint64_t dummy1;
-    PartialStruct a;
-    uint64_t dummy2;
-};
-
-struct UnboundStruct { };
-
-struct StringStruct {
-    char a[3];
-    std::array<char, 3> b;
-};
-
-struct ComplexStruct {
-    std::complex<float> cflt;
-    std::complex<double> cdbl;
-};
-
-std::ostream& operator<<(std::ostream& os, const ComplexStruct& v) {
-    return os << "c:" << v.cflt << "," << v.cdbl;
-}
-
-struct ArrayStruct {
-    char a[3][4];
-    int32_t b[2];
-    std::array<uint8_t, 3> c;
-    std::array<float, 2> d[4];
-};
-
-PYBIND11_PACKED(struct StructWithUglyNames {
-    int8_t __x__;
-    uint64_t __y__;
-});
-
-enum class E1 : int64_t { A = -1, B = 1 };
-enum E2 : uint8_t { X = 1, Y = 2 };
-
-PYBIND11_PACKED(struct EnumStruct {
-    E1 e1;
-    E2 e2;
-});
-
-std::ostream& operator<<(std::ostream& os, const StringStruct& v) {
-    os << "a='";
-    for (size_t i = 0; i < 3 && v.a[i]; i++) os << v.a[i];
-    os << "',b='";
-    for (size_t i = 0; i < 3 && v.b[i]; i++) os << v.b[i];
-    return os << "'";
-}
-
-std::ostream& operator<<(std::ostream& os, const ArrayStruct& v) {
-    os << "a={";
-    for (int i = 0; i < 3; i++) {
-        if (i > 0)
-            os << ',';
-        os << '{';
-        for (int j = 0; j < 3; j++)
-            os << v.a[i][j] << ',';
-        os << v.a[i][3] << '}';
-    }
-    os << "},b={" << v.b[0] << ',' << v.b[1];
-    os << "},c={" << int(v.c[0]) << ',' << int(v.c[1]) << ',' << int(v.c[2]);
-    os << "},d={";
-    for (int i = 0; i < 4; i++) {
-        if (i > 0)
-            os << ',';
-        os << '{' << v.d[i][0] << ',' << v.d[i][1] << '}';
-    }
-    return os << '}';
-}
-
-std::ostream& operator<<(std::ostream& os, const EnumStruct& v) {
-    return os << "e1=" << (v.e1 == E1::A ? "A" : "B") << ",e2=" << (v.e2 == E2::X ? "X" : "Y");
-}
-
-template <typename T>
-py::array mkarray_via_buffer(size_t n) {
-    return py::array(py::buffer_info(nullptr, sizeof(T),
-                                     py::format_descriptor<T>::format(),
-                                     1, { n }, { sizeof(T) }));
-}
-
-#define SET_TEST_VALS(s, i) do { \
-    s.bool_ = (i) % 2 != 0; \
-    s.uint_ = (uint32_t) (i); \
-    s.float_ = (float) (i) * 1.5f; \
-    s.ldbl_ = (long double) (i) * -2.5L; } while (0)
-
-template <typename S>
-py::array_t<S, 0> create_recarray(size_t n) {
-    auto arr = mkarray_via_buffer<S>(n);
-    auto req = arr.request();
-    auto ptr = static_cast<S*>(req.ptr);
-    for (size_t i = 0; i < n; i++) {
-        SET_TEST_VALS(ptr[i], i);
-    }
-    return arr;
-}
-
-template <typename S>
-py::list print_recarray(py::array_t<S, 0> arr) {
-    const auto req = arr.request();
-    const auto ptr = static_cast<S*>(req.ptr);
-    auto l = py::list();
-    for (ssize_t i = 0; i < req.size; i++) {
-        std::stringstream ss;
-        ss << ptr[i];
-        l.append(py::str(ss.str()));
-    }
-    return l;
-}
-
-py::array_t<int32_t, 0> test_array_ctors(int i) {
-    using arr_t = py::array_t<int32_t, 0>;
-
-    std::vector<int32_t> data { 1, 2, 3, 4, 5, 6 };
-    std::vector<ssize_t> shape { 3, 2 };
-    std::vector<ssize_t> strides { 8, 4 };
-
-    auto ptr = data.data();
-    auto vptr = (void *) ptr;
-    auto dtype = py::dtype("int32");
-
-    py::buffer_info buf_ndim1(vptr, 4, "i", 6);
-    py::buffer_info buf_ndim1_null(nullptr, 4, "i", 6);
-    py::buffer_info buf_ndim2(vptr, 4, "i", 2, shape, strides);
-    py::buffer_info buf_ndim2_null(nullptr, 4, "i", 2, shape, strides);
-
-    auto fill = [](py::array arr) {
-        auto req = arr.request();
-        for (int i = 0; i < 6; i++) ((int32_t *) req.ptr)[i] = i + 1;
-        return arr;
-    };
-
-    switch (i) {
-    // shape: (3, 2)
-    case 10: return arr_t(shape, strides, ptr);
-    case 11: return py::array(shape, strides, ptr);
-    case 12: return py::array(dtype, shape, strides, vptr);
-    case 13: return arr_t(shape, ptr);
-    case 14: return py::array(shape, ptr);
-    case 15: return py::array(dtype, shape, vptr);
-    case 16: return arr_t(buf_ndim2);
-    case 17: return py::array(buf_ndim2);
-    // shape: (3, 2) - post-fill
-    case 20: return fill(arr_t(shape, strides));
-    case 21: return py::array(shape, strides, ptr); // can't have nullptr due to templated ctor
-    case 22: return fill(py::array(dtype, shape, strides));
-    case 23: return fill(arr_t(shape));
-    case 24: return py::array(shape, ptr); // can't have nullptr due to templated ctor
-    case 25: return fill(py::array(dtype, shape));
-    case 26: return fill(arr_t(buf_ndim2_null));
-    case 27: return fill(py::array(buf_ndim2_null));
-    // shape: (6, )
-    case 30: return arr_t(6, ptr);
-    case 31: return py::array(6, ptr);
-    case 32: return py::array(dtype, 6, vptr);
-    case 33: return arr_t(buf_ndim1);
-    case 34: return py::array(buf_ndim1);
-    // shape: (6, )
-    case 40: return fill(arr_t(6));
-    case 41: return py::array(6, ptr);  // can't have nullptr due to templated ctor
-    case 42: return fill(py::array(dtype, 6));
-    case 43: return fill(arr_t(buf_ndim1_null));
-    case 44: return fill(py::array(buf_ndim1_null));
-    }
-    return arr_t();
-}
-
-py::list test_dtype_ctors() {
-    py::list list;
-    list.append(py::dtype("int32"));
-    list.append(py::dtype(std::string("float64")));
-    list.append(py::dtype::from_args(py::str("bool")));
-    py::list names, offsets, formats;
-    py::dict dict;
-    names.append(py::str("a")); names.append(py::str("b")); dict["names"] = names;
-    offsets.append(py::int_(1)); offsets.append(py::int_(10)); dict["offsets"] = offsets;
-    formats.append(py::dtype("int32")); formats.append(py::dtype("float64")); dict["formats"] = formats;
-    dict["itemsize"] = py::int_(20);
-    list.append(py::dtype::from_args(dict));
-    list.append(py::dtype(names, formats, offsets, 20));
-    list.append(py::dtype(py::buffer_info((void *) 0, sizeof(unsigned int), "I", 1)));
-    list.append(py::dtype(py::buffer_info((void *) 0, 0, "T{i:a:f:b:}", 1)));
-    return list;
-}
-
-TEST_SUBMODULE(numpy_dtypes, m) {
-    try { py::module::import("numpy"); }
-    catch (...) { return; }
-
-    // typeinfo may be registered before the dtype descriptor for scalar casts to work...
-    py::class_<SimpleStruct>(m, "SimpleStruct");
-
-    PYBIND11_NUMPY_DTYPE(SimpleStruct, bool_, uint_, float_, ldbl_);
-    PYBIND11_NUMPY_DTYPE(PackedStruct, bool_, uint_, float_, ldbl_);
-    PYBIND11_NUMPY_DTYPE(NestedStruct, a, b);
-    PYBIND11_NUMPY_DTYPE(PartialStruct, bool_, uint_, float_, ldbl_);
-    PYBIND11_NUMPY_DTYPE(PartialNestedStruct, a);
-    PYBIND11_NUMPY_DTYPE(StringStruct, a, b);
-    PYBIND11_NUMPY_DTYPE(ArrayStruct, a, b, c, d);
-    PYBIND11_NUMPY_DTYPE(EnumStruct, e1, e2);
-    PYBIND11_NUMPY_DTYPE(ComplexStruct, cflt, cdbl);
-
-    // ... or after
-    py::class_<PackedStruct>(m, "PackedStruct");
-
-    PYBIND11_NUMPY_DTYPE_EX(StructWithUglyNames, __x__, "x", __y__, "y");
-
-    // If uncommented, this should produce a static_assert failure telling the user that the struct
-    // is not a POD type
-//    struct NotPOD { std::string v; NotPOD() : v("hi") {}; };
-//    PYBIND11_NUMPY_DTYPE(NotPOD, v);
-
-    // test_recarray, test_scalar_conversion
-    m.def("create_rec_simple", &create_recarray<SimpleStruct>);
-    m.def("create_rec_packed", &create_recarray<PackedStruct>);
-    m.def("create_rec_nested", [](size_t n) { // test_signature
-        py::array_t<NestedStruct, 0> arr = mkarray_via_buffer<NestedStruct>(n);
-        auto req = arr.request();
-        auto ptr = static_cast<NestedStruct*>(req.ptr);
-        for (size_t i = 0; i < n; i++) {
-            SET_TEST_VALS(ptr[i].a, i);
-            SET_TEST_VALS(ptr[i].b, i + 1);
-        }
-        return arr;
-    });
-    m.def("create_rec_partial", &create_recarray<PartialStruct>);
-    m.def("create_rec_partial_nested", [](size_t n) {
-        py::array_t<PartialNestedStruct, 0> arr = mkarray_via_buffer<PartialNestedStruct>(n);
-        auto req = arr.request();
-        auto ptr = static_cast<PartialNestedStruct*>(req.ptr);
-        for (size_t i = 0; i < n; i++) {
-            SET_TEST_VALS(ptr[i].a, i);
-        }
-        return arr;
-    });
-    m.def("print_rec_simple", &print_recarray<SimpleStruct>);
-    m.def("print_rec_packed", &print_recarray<PackedStruct>);
-    m.def("print_rec_nested", &print_recarray<NestedStruct>);
-
-    // test_format_descriptors
-    m.def("get_format_unbound", []() { return py::format_descriptor<UnboundStruct>::format(); });
-    m.def("print_format_descriptors", []() {
-        py::list l;
-        for (const auto &fmt : {
-            py::format_descriptor<SimpleStruct>::format(),
-            py::format_descriptor<PackedStruct>::format(),
-            py::format_descriptor<NestedStruct>::format(),
-            py::format_descriptor<PartialStruct>::format(),
-            py::format_descriptor<PartialNestedStruct>::format(),
-            py::format_descriptor<StringStruct>::format(),
-            py::format_descriptor<ArrayStruct>::format(),
-            py::format_descriptor<EnumStruct>::format(),
-            py::format_descriptor<ComplexStruct>::format()
-        }) {
-            l.append(py::cast(fmt));
-        }
-        return l;
-    });
-
-    // test_dtype
-    m.def("print_dtypes", []() {
-        py::list l;
-        for (const py::handle &d : {
-            py::dtype::of<SimpleStruct>(),
-            py::dtype::of<PackedStruct>(),
-            py::dtype::of<NestedStruct>(),
-            py::dtype::of<PartialStruct>(),
-            py::dtype::of<PartialNestedStruct>(),
-            py::dtype::of<StringStruct>(),
-            py::dtype::of<ArrayStruct>(),
-            py::dtype::of<EnumStruct>(),
-            py::dtype::of<StructWithUglyNames>(),
-            py::dtype::of<ComplexStruct>()
-        })
-            l.append(py::str(d));
-        return l;
-    });
-    m.def("test_dtype_ctors", &test_dtype_ctors);
-    m.def("test_dtype_methods", []() {
-        py::list list;
-        auto dt1 = py::dtype::of<int32_t>();
-        auto dt2 = py::dtype::of<SimpleStruct>();
-        list.append(dt1); list.append(dt2);
-        list.append(py::bool_(dt1.has_fields())); list.append(py::bool_(dt2.has_fields()));
-        list.append(py::int_(dt1.itemsize())); list.append(py::int_(dt2.itemsize()));
-        return list;
-    });
-    struct TrailingPaddingStruct {
-        int32_t a;
-        char b;
-    };
-    PYBIND11_NUMPY_DTYPE(TrailingPaddingStruct, a, b);
-    m.def("trailing_padding_dtype", []() { return py::dtype::of<TrailingPaddingStruct>(); });
-
-    // test_string_array
-    m.def("create_string_array", [](bool non_empty) {
-        py::array_t<StringStruct, 0> arr = mkarray_via_buffer<StringStruct>(non_empty ? 4 : 0);
-        if (non_empty) {
-            auto req = arr.request();
-            auto ptr = static_cast<StringStruct*>(req.ptr);
-            for (ssize_t i = 0; i < req.size * req.itemsize; i++)
-                static_cast<char*>(req.ptr)[i] = 0;
-            ptr[1].a[0] = 'a'; ptr[1].b[0] = 'a';
-            ptr[2].a[0] = 'a'; ptr[2].b[0] = 'a';
-            ptr[3].a[0] = 'a'; ptr[3].b[0] = 'a';
-
-            ptr[2].a[1] = 'b'; ptr[2].b[1] = 'b';
-            ptr[3].a[1] = 'b'; ptr[3].b[1] = 'b';
-
-            ptr[3].a[2] = 'c'; ptr[3].b[2] = 'c';
-        }
-        return arr;
-    });
-    m.def("print_string_array", &print_recarray<StringStruct>);
-
-    // test_array_array
-    m.def("create_array_array", [](size_t n) {
-        py::array_t<ArrayStruct, 0> arr = mkarray_via_buffer<ArrayStruct>(n);
-        auto ptr = (ArrayStruct *) arr.mutable_data();
-        for (size_t i = 0; i < n; i++) {
-            for (size_t j = 0; j < 3; j++)
-                for (size_t k = 0; k < 4; k++)
-                    ptr[i].a[j][k] = char('A' + (i * 100 + j * 10 + k) % 26);
-            for (size_t j = 0; j < 2; j++)
-                ptr[i].b[j] = int32_t(i * 1000 + j);
-            for (size_t j = 0; j < 3; j++)
-                ptr[i].c[j] = uint8_t(i * 10 + j);
-            for (size_t j = 0; j < 4; j++)
-                for (size_t k = 0; k < 2; k++)
-                    ptr[i].d[j][k] = float(i) * 100.0f + float(j) * 10.0f + float(k);
-        }
-        return arr;
-    });
-    m.def("print_array_array", &print_recarray<ArrayStruct>);
-
-    // test_enum_array
-    m.def("create_enum_array", [](size_t n) {
-        py::array_t<EnumStruct, 0> arr = mkarray_via_buffer<EnumStruct>(n);
-        auto ptr = (EnumStruct *) arr.mutable_data();
-        for (size_t i = 0; i < n; i++) {
-            ptr[i].e1 = static_cast<E1>(-1 + ((int) i % 2) * 2);
-            ptr[i].e2 = static_cast<E2>(1 + (i % 2));
-        }
-        return arr;
-    });
-    m.def("print_enum_array", &print_recarray<EnumStruct>);
-
-    // test_complex_array
-    m.def("create_complex_array", [](size_t n) {
-        py::array_t<ComplexStruct, 0> arr = mkarray_via_buffer<ComplexStruct>(n);
-        auto ptr = (ComplexStruct *) arr.mutable_data();
-        for (size_t i = 0; i < n; i++) {
-            ptr[i].cflt.real(float(i));
-            ptr[i].cflt.imag(float(i) + 0.25f);
-            ptr[i].cdbl.real(double(i) + 0.5);
-            ptr[i].cdbl.imag(double(i) + 0.75);
-        }
-        return arr;
-    });
-    m.def("print_complex_array", &print_recarray<ComplexStruct>);
-
-    // test_array_constructors
-    m.def("test_array_ctors", &test_array_ctors);
-
-    // test_compare_buffer_info
-    struct CompareStruct {
-        bool x;
-        uint32_t y;
-        float z;
-    };
-    PYBIND11_NUMPY_DTYPE(CompareStruct, x, y, z);
-    m.def("compare_buffer_info", []() {
-        py::list list;
-        list.append(py::bool_(py::detail::compare_buffer_info<float>::compare(py::buffer_info(nullptr, sizeof(float), "f", 1))));
-        list.append(py::bool_(py::detail::compare_buffer_info<unsigned>::compare(py::buffer_info(nullptr, sizeof(int), "I", 1))));
-        list.append(py::bool_(py::detail::compare_buffer_info<long>::compare(py::buffer_info(nullptr, sizeof(long), "l", 1))));
-        list.append(py::bool_(py::detail::compare_buffer_info<long>::compare(py::buffer_info(nullptr, sizeof(long), sizeof(long) == sizeof(int) ? "i" : "q", 1))));
-        list.append(py::bool_(py::detail::compare_buffer_info<CompareStruct>::compare(py::buffer_info(nullptr, sizeof(CompareStruct), "T{?:x:3xI:y:f:z:}", 1))));
-        return list;
-    });
-    m.def("buffer_to_dtype", [](py::buffer& buf) { return py::dtype(buf.request()); });
-
-    // test_scalar_conversion
-    m.def("f_simple", [](SimpleStruct s) { return s.uint_ * 10; });
-    m.def("f_packed", [](PackedStruct s) { return s.uint_ * 10; });
-    m.def("f_nested", [](NestedStruct s) { return s.a.uint_ * 10; });
-
-    // test_register_dtype
-    m.def("register_dtype", []() { PYBIND11_NUMPY_DTYPE(SimpleStruct, bool_, uint_, float_, ldbl_); });
-}
diff --git a/tmap/lib/pybind11/tests/test_numpy_dtypes.py b/tmap/lib/pybind11/tests/test_numpy_dtypes.py
deleted file mode 100644
index 5f9a954..0000000
--- a/tmap/lib/pybind11/tests/test_numpy_dtypes.py
+++ /dev/null
@@ -1,298 +0,0 @@
-import re
-import pytest
-from pybind11_tests import numpy_dtypes as m
-
-pytestmark = pytest.requires_numpy
-
-with pytest.suppress(ImportError):
-    import numpy as np
-
-
-@pytest.fixture(scope='module')
-def simple_dtype():
-    ld = np.dtype('longdouble')
-    return np.dtype({'names': ['bool_', 'uint_', 'float_', 'ldbl_'],
-                     'formats': ['?', 'u4', 'f4', 'f{}'.format(ld.itemsize)],
-                     'offsets': [0, 4, 8, (16 if ld.alignment > 4 else 12)]})
-
-
-@pytest.fixture(scope='module')
-def packed_dtype():
-    return np.dtype([('bool_', '?'), ('uint_', 'u4'), ('float_', 'f4'), ('ldbl_', 'g')])
-
-
-def dt_fmt():
-    from sys import byteorder
-    e = '<' if byteorder == 'little' else '>'
-    return ("{{'names':['bool_','uint_','float_','ldbl_'],"
-            " 'formats':['?','" + e + "u4','" + e + "f4','" + e + "f{}'],"
-            " 'offsets':[0,4,8,{}], 'itemsize':{}}}")
-
-
-def simple_dtype_fmt():
-    ld = np.dtype('longdouble')
-    simple_ld_off = 12 + 4 * (ld.alignment > 4)
-    return dt_fmt().format(ld.itemsize, simple_ld_off, simple_ld_off + ld.itemsize)
-
-
-def packed_dtype_fmt():
-    from sys import byteorder
-    return "[('bool_', '?'), ('uint_', '{e}u4'), ('float_', '{e}f4'), ('ldbl_', '{e}f{}')]".format(
-        np.dtype('longdouble').itemsize, e='<' if byteorder == 'little' else '>')
-
-
-def partial_ld_offset():
-    return 12 + 4 * (np.dtype('uint64').alignment > 4) + 8 + 8 * (
-        np.dtype('longdouble').alignment > 8)
-
-
-def partial_dtype_fmt():
-    ld = np.dtype('longdouble')
-    partial_ld_off = partial_ld_offset()
-    return dt_fmt().format(ld.itemsize, partial_ld_off, partial_ld_off + ld.itemsize)
-
-
-def partial_nested_fmt():
-    ld = np.dtype('longdouble')
-    partial_nested_off = 8 + 8 * (ld.alignment > 8)
-    partial_ld_off = partial_ld_offset()
-    partial_nested_size = partial_nested_off * 2 + partial_ld_off + ld.itemsize
-    return "{{'names':['a'], 'formats':[{}], 'offsets':[{}], 'itemsize':{}}}".format(
-        partial_dtype_fmt(), partial_nested_off, partial_nested_size)
-
-
-def assert_equal(actual, expected_data, expected_dtype):
-    np.testing.assert_equal(actual, np.array(expected_data, dtype=expected_dtype))
-
-
-def test_format_descriptors():
-    with pytest.raises(RuntimeError) as excinfo:
-        m.get_format_unbound()
-    assert re.match('^NumPy type info missing for .*UnboundStruct.*$', str(excinfo.value))
-
-    ld = np.dtype('longdouble')
-    ldbl_fmt = ('4x' if ld.alignment > 4 else '') + ld.char
-    ss_fmt = "^T{?:bool_:3xI:uint_:f:float_:" + ldbl_fmt + ":ldbl_:}"
-    dbl = np.dtype('double')
-    partial_fmt = ("^T{?:bool_:3xI:uint_:f:float_:" +
-                   str(4 * (dbl.alignment > 4) + dbl.itemsize + 8 * (ld.alignment > 8)) +
-                   "xg:ldbl_:}")
-    nested_extra = str(max(8, ld.alignment))
-    assert m.print_format_descriptors() == [
-        ss_fmt,
-        "^T{?:bool_:I:uint_:f:float_:g:ldbl_:}",
-        "^T{" + ss_fmt + ":a:^T{?:bool_:I:uint_:f:float_:g:ldbl_:}:b:}",
-        partial_fmt,
-        "^T{" + nested_extra + "x" + partial_fmt + ":a:" + nested_extra + "x}",
-        "^T{3s:a:3s:b:}",
-        "^T{(3)4s:a:(2)i:b:(3)B:c:1x(4, 2)f:d:}",
-        '^T{q:e1:B:e2:}',
-        '^T{Zf:cflt:Zd:cdbl:}'
-    ]
-
-
-def test_dtype(simple_dtype):
-    from sys import byteorder
-    e = '<' if byteorder == 'little' else '>'
-
-    assert m.print_dtypes() == [
-        simple_dtype_fmt(),
-        packed_dtype_fmt(),
-        "[('a', {}), ('b', {})]".format(simple_dtype_fmt(), packed_dtype_fmt()),
-        partial_dtype_fmt(),
-        partial_nested_fmt(),
-        "[('a', 'S3'), ('b', 'S3')]",
-        ("{{'names':['a','b','c','d'], " +
-         "'formats':[('S4', (3,)),('<i4', (2,)),('u1', (3,)),('<f4', (4, 2))], " +
-         "'offsets':[0,12,20,24], 'itemsize':56}}").format(e=e),
-        "[('e1', '" + e + "i8'), ('e2', 'u1')]",
-        "[('x', 'i1'), ('y', '" + e + "u8')]",
-        "[('cflt', '" + e + "c8'), ('cdbl', '" + e + "c16')]"
-    ]
-
-    d1 = np.dtype({'names': ['a', 'b'], 'formats': ['int32', 'float64'],
-                   'offsets': [1, 10], 'itemsize': 20})
-    d2 = np.dtype([('a', 'i4'), ('b', 'f4')])
-    assert m.test_dtype_ctors() == [np.dtype('int32'), np.dtype('float64'),
-                                    np.dtype('bool'), d1, d1, np.dtype('uint32'), d2]
-
-    assert m.test_dtype_methods() == [np.dtype('int32'), simple_dtype, False, True,
-                                      np.dtype('int32').itemsize, simple_dtype.itemsize]
-
-    assert m.trailing_padding_dtype() == m.buffer_to_dtype(np.zeros(1, m.trailing_padding_dtype()))
-
-
-def test_recarray(simple_dtype, packed_dtype):
-    elements = [(False, 0, 0.0, -0.0), (True, 1, 1.5, -2.5), (False, 2, 3.0, -5.0)]
-
-    for func, dtype in [(m.create_rec_simple, simple_dtype), (m.create_rec_packed, packed_dtype)]:
-        arr = func(0)
-        assert arr.dtype == dtype
-        assert_equal(arr, [], simple_dtype)
-        assert_equal(arr, [], packed_dtype)
-
-        arr = func(3)
-        assert arr.dtype == dtype
-        assert_equal(arr, elements, simple_dtype)
-        assert_equal(arr, elements, packed_dtype)
-
-        if dtype == simple_dtype:
-            assert m.print_rec_simple(arr) == [
-                "s:0,0,0,-0",
-                "s:1,1,1.5,-2.5",
-                "s:0,2,3,-5"
-            ]
-        else:
-            assert m.print_rec_packed(arr) == [
-                "p:0,0,0,-0",
-                "p:1,1,1.5,-2.5",
-                "p:0,2,3,-5"
-            ]
-
-    nested_dtype = np.dtype([('a', simple_dtype), ('b', packed_dtype)])
-
-    arr = m.create_rec_nested(0)
-    assert arr.dtype == nested_dtype
-    assert_equal(arr, [], nested_dtype)
-
-    arr = m.create_rec_nested(3)
-    assert arr.dtype == nested_dtype
-    assert_equal(arr, [((False, 0, 0.0, -0.0), (True, 1, 1.5, -2.5)),
-                       ((True, 1, 1.5, -2.5), (False, 2, 3.0, -5.0)),
-                       ((False, 2, 3.0, -5.0), (True, 3, 4.5, -7.5))], nested_dtype)
-    assert m.print_rec_nested(arr) == [
-        "n:a=s:0,0,0,-0;b=p:1,1,1.5,-2.5",
-        "n:a=s:1,1,1.5,-2.5;b=p:0,2,3,-5",
-        "n:a=s:0,2,3,-5;b=p:1,3,4.5,-7.5"
-    ]
-
-    arr = m.create_rec_partial(3)
-    assert str(arr.dtype) == partial_dtype_fmt()
-    partial_dtype = arr.dtype
-    assert '' not in arr.dtype.fields
-    assert partial_dtype.itemsize > simple_dtype.itemsize
-    assert_equal(arr, elements, simple_dtype)
-    assert_equal(arr, elements, packed_dtype)
-
-    arr = m.create_rec_partial_nested(3)
-    assert str(arr.dtype) == partial_nested_fmt()
-    assert '' not in arr.dtype.fields
-    assert '' not in arr.dtype.fields['a'][0].fields
-    assert arr.dtype.itemsize > partial_dtype.itemsize
-    np.testing.assert_equal(arr['a'], m.create_rec_partial(3))
-
-
-def test_array_constructors():
-    data = np.arange(1, 7, dtype='int32')
-    for i in range(8):
-        np.testing.assert_array_equal(m.test_array_ctors(10 + i), data.reshape((3, 2)))
-        np.testing.assert_array_equal(m.test_array_ctors(20 + i), data.reshape((3, 2)))
-    for i in range(5):
-        np.testing.assert_array_equal(m.test_array_ctors(30 + i), data)
-        np.testing.assert_array_equal(m.test_array_ctors(40 + i), data)
-
-
-def test_string_array():
-    arr = m.create_string_array(True)
-    assert str(arr.dtype) == "[('a', 'S3'), ('b', 'S3')]"
-    assert m.print_string_array(arr) == [
-        "a='',b=''",
-        "a='a',b='a'",
-        "a='ab',b='ab'",
-        "a='abc',b='abc'"
-    ]
-    dtype = arr.dtype
-    assert arr['a'].tolist() == [b'', b'a', b'ab', b'abc']
-    assert arr['b'].tolist() == [b'', b'a', b'ab', b'abc']
-    arr = m.create_string_array(False)
-    assert dtype == arr.dtype
-
-
-def test_array_array():
-    from sys import byteorder
-    e = '<' if byteorder == 'little' else '>'
-
-    arr = m.create_array_array(3)
-    assert str(arr.dtype) == (
-        "{{'names':['a','b','c','d'], " +
-        "'formats':[('S4', (3,)),('<i4', (2,)),('u1', (3,)),('{e}f4', (4, 2))], " +
-        "'offsets':[0,12,20,24], 'itemsize':56}}").format(e=e)
-    assert m.print_array_array(arr) == [
-        "a={{A,B,C,D},{K,L,M,N},{U,V,W,X}},b={0,1}," +
-        "c={0,1,2},d={{0,1},{10,11},{20,21},{30,31}}",
-        "a={{W,X,Y,Z},{G,H,I,J},{Q,R,S,T}},b={1000,1001}," +
-        "c={10,11,12},d={{100,101},{110,111},{120,121},{130,131}}",
-        "a={{S,T,U,V},{C,D,E,F},{M,N,O,P}},b={2000,2001}," +
-        "c={20,21,22},d={{200,201},{210,211},{220,221},{230,231}}",
-    ]
-    assert arr['a'].tolist() == [[b'ABCD', b'KLMN', b'UVWX'],
-                                 [b'WXYZ', b'GHIJ', b'QRST'],
-                                 [b'STUV', b'CDEF', b'MNOP']]
-    assert arr['b'].tolist() == [[0, 1], [1000, 1001], [2000, 2001]]
-    assert m.create_array_array(0).dtype == arr.dtype
-
-
-def test_enum_array():
-    from sys import byteorder
-    e = '<' if byteorder == 'little' else '>'
-
-    arr = m.create_enum_array(3)
-    dtype = arr.dtype
-    assert dtype == np.dtype([('e1', e + 'i8'), ('e2', 'u1')])
-    assert m.print_enum_array(arr) == [
-        "e1=A,e2=X",
-        "e1=B,e2=Y",
-        "e1=A,e2=X"
-    ]
-    assert arr['e1'].tolist() == [-1, 1, -1]
-    assert arr['e2'].tolist() == [1, 2, 1]
-    assert m.create_enum_array(0).dtype == dtype
-
-
-def test_complex_array():
-    from sys import byteorder
-    e = '<' if byteorder == 'little' else '>'
-
-    arr = m.create_complex_array(3)
-    dtype = arr.dtype
-    assert dtype == np.dtype([('cflt', e + 'c8'), ('cdbl', e + 'c16')])
-    assert m.print_complex_array(arr) == [
-        "c:(0,0.25),(0.5,0.75)",
-        "c:(1,1.25),(1.5,1.75)",
-        "c:(2,2.25),(2.5,2.75)"
-    ]
-    assert arr['cflt'].tolist() == [0.0 + 0.25j, 1.0 + 1.25j, 2.0 + 2.25j]
-    assert arr['cdbl'].tolist() == [0.5 + 0.75j, 1.5 + 1.75j, 2.5 + 2.75j]
-    assert m.create_complex_array(0).dtype == dtype
-
-
-def test_signature(doc):
-    assert doc(m.create_rec_nested) == \
-        "create_rec_nested(arg0: int) -> numpy.ndarray[NestedStruct]"
-
-
-def test_scalar_conversion():
-    n = 3
-    arrays = [m.create_rec_simple(n), m.create_rec_packed(n),
-              m.create_rec_nested(n), m.create_enum_array(n)]
-    funcs = [m.f_simple, m.f_packed, m.f_nested]
-
-    for i, func in enumerate(funcs):
-        for j, arr in enumerate(arrays):
-            if i == j and i < 2:
-                assert [func(arr[k]) for k in range(n)] == [k * 10 for k in range(n)]
-            else:
-                with pytest.raises(TypeError) as excinfo:
-                    func(arr[0])
-                assert 'incompatible function arguments' in str(excinfo.value)
-
-
-def test_register_dtype():
-    with pytest.raises(RuntimeError) as excinfo:
-        m.register_dtype()
-    assert 'dtype is already registered' in str(excinfo.value)
-
-
-@pytest.requires_numpy
-def test_compare_buffer_info():
-    assert all(m.compare_buffer_info())
diff --git a/tmap/lib/pybind11/tests/test_numpy_vectorize.cpp b/tmap/lib/pybind11/tests/test_numpy_vectorize.cpp
deleted file mode 100644
index a875a74..0000000
--- a/tmap/lib/pybind11/tests/test_numpy_vectorize.cpp
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
-    tests/test_numpy_vectorize.cpp -- auto-vectorize functions over NumPy array
-    arguments
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include <pybind11/numpy.h>
-
-double my_func(int x, float y, double z) {
-    py::print("my_func(x:int={}, y:float={:.0f}, z:float={:.0f})"_s.format(x, y, z));
-    return (float) x*y*z;
-}
-
-TEST_SUBMODULE(numpy_vectorize, m) {
-    try { py::module::import("numpy"); }
-    catch (...) { return; }
-
-    // test_vectorize, test_docs, test_array_collapse
-    // Vectorize all arguments of a function (though non-vector arguments are also allowed)
-    m.def("vectorized_func", py::vectorize(my_func));
-
-    // Vectorize a lambda function with a capture object (e.g. to exclude some arguments from the vectorization)
-    m.def("vectorized_func2",
-        [](py::array_t<int> x, py::array_t<float> y, float z) {
-            return py::vectorize([z](int x, float y) { return my_func(x, y, z); })(x, y);
-        }
-    );
-
-    // Vectorize a complex-valued function
-    m.def("vectorized_func3", py::vectorize(
-        [](std::complex<double> c) { return c * std::complex<double>(2.f); }
-    ));
-
-    // test_type_selection
-    // Numpy function which only accepts specific data types
-    m.def("selective_func", [](py::array_t<int, py::array::c_style>) { return "Int branch taken."; });
-    m.def("selective_func", [](py::array_t<float, py::array::c_style>) { return "Float branch taken."; });
-    m.def("selective_func", [](py::array_t<std::complex<float>, py::array::c_style>) { return "Complex float branch taken."; });
-
-
-    // test_passthrough_arguments
-    // Passthrough test: references and non-pod types should be automatically passed through (in the
-    // function definition below, only `b`, `d`, and `g` are vectorized):
-    struct NonPODClass {
-        NonPODClass(int v) : value{v} {}
-        int value;
-    };
-    py::class_<NonPODClass>(m, "NonPODClass").def(py::init<int>());
-    m.def("vec_passthrough", py::vectorize(
-        [](double *a, double b, py::array_t<double> c, const int &d, int &e, NonPODClass f, const double g) {
-            return *a + b + c.at(0) + d + e + f.value + g;
-        }
-    ));
-
-    // test_method_vectorization
-    struct VectorizeTestClass {
-        VectorizeTestClass(int v) : value{v} {};
-        float method(int x, float y) { return y + (float) (x + value); }
-        int value = 0;
-    };
-    py::class_<VectorizeTestClass> vtc(m, "VectorizeTestClass");
-    vtc .def(py::init<int>())
-        .def_readwrite("value", &VectorizeTestClass::value);
-
-    // Automatic vectorizing of methods
-    vtc.def("method", py::vectorize(&VectorizeTestClass::method));
-
-    // test_trivial_broadcasting
-    // Internal optimization test for whether the input is trivially broadcastable:
-    py::enum_<py::detail::broadcast_trivial>(m, "trivial")
-        .value("f_trivial", py::detail::broadcast_trivial::f_trivial)
-        .value("c_trivial", py::detail::broadcast_trivial::c_trivial)
-        .value("non_trivial", py::detail::broadcast_trivial::non_trivial);
-    m.def("vectorized_is_trivial", [](
-                py::array_t<int, py::array::forcecast> arg1,
-                py::array_t<float, py::array::forcecast> arg2,
-                py::array_t<double, py::array::forcecast> arg3
-                ) {
-        ssize_t ndim;
-        std::vector<ssize_t> shape;
-        std::array<py::buffer_info, 3> buffers {{ arg1.request(), arg2.request(), arg3.request() }};
-        return py::detail::broadcast(buffers, ndim, shape);
-    });
-}
diff --git a/tmap/lib/pybind11/tests/test_numpy_vectorize.py b/tmap/lib/pybind11/tests/test_numpy_vectorize.py
deleted file mode 100644
index 0e9c883..0000000
--- a/tmap/lib/pybind11/tests/test_numpy_vectorize.py
+++ /dev/null
@@ -1,196 +0,0 @@
-import pytest
-from pybind11_tests import numpy_vectorize as m
-
-pytestmark = pytest.requires_numpy
-
-with pytest.suppress(ImportError):
-    import numpy as np
-
-
-def test_vectorize(capture):
-    assert np.isclose(m.vectorized_func3(np.array(3 + 7j)), [6 + 14j])
-
-    for f in [m.vectorized_func, m.vectorized_func2]:
-        with capture:
-            assert np.isclose(f(1, 2, 3), 6)
-        assert capture == "my_func(x:int=1, y:float=2, z:float=3)"
-        with capture:
-            assert np.isclose(f(np.array(1), np.array(2), 3), 6)
-        assert capture == "my_func(x:int=1, y:float=2, z:float=3)"
-        with capture:
-            assert np.allclose(f(np.array([1, 3]), np.array([2, 4]), 3), [6, 36])
-        assert capture == """
-            my_func(x:int=1, y:float=2, z:float=3)
-            my_func(x:int=3, y:float=4, z:float=3)
-        """
-        with capture:
-            a = np.array([[1, 2], [3, 4]], order='F')
-            b = np.array([[10, 20], [30, 40]], order='F')
-            c = 3
-            result = f(a, b, c)
-            assert np.allclose(result, a * b * c)
-            assert result.flags.f_contiguous
-        # All inputs are F order and full or singletons, so we the result is in col-major order:
-        assert capture == """
-            my_func(x:int=1, y:float=10, z:float=3)
-            my_func(x:int=3, y:float=30, z:float=3)
-            my_func(x:int=2, y:float=20, z:float=3)
-            my_func(x:int=4, y:float=40, z:float=3)
-        """
-        with capture:
-            a, b, c = np.array([[1, 3, 5], [7, 9, 11]]), np.array([[2, 4, 6], [8, 10, 12]]), 3
-            assert np.allclose(f(a, b, c), a * b * c)
-        assert capture == """
-            my_func(x:int=1, y:float=2, z:float=3)
-            my_func(x:int=3, y:float=4, z:float=3)
-            my_func(x:int=5, y:float=6, z:float=3)
-            my_func(x:int=7, y:float=8, z:float=3)
-            my_func(x:int=9, y:float=10, z:float=3)
-            my_func(x:int=11, y:float=12, z:float=3)
-        """
-        with capture:
-            a, b, c = np.array([[1, 2, 3], [4, 5, 6]]), np.array([2, 3, 4]), 2
-            assert np.allclose(f(a, b, c), a * b * c)
-        assert capture == """
-            my_func(x:int=1, y:float=2, z:float=2)
-            my_func(x:int=2, y:float=3, z:float=2)
-            my_func(x:int=3, y:float=4, z:float=2)
-            my_func(x:int=4, y:float=2, z:float=2)
-            my_func(x:int=5, y:float=3, z:float=2)
-            my_func(x:int=6, y:float=4, z:float=2)
-        """
-        with capture:
-            a, b, c = np.array([[1, 2, 3], [4, 5, 6]]), np.array([[2], [3]]), 2
-            assert np.allclose(f(a, b, c), a * b * c)
-        assert capture == """
-            my_func(x:int=1, y:float=2, z:float=2)
-            my_func(x:int=2, y:float=2, z:float=2)
-            my_func(x:int=3, y:float=2, z:float=2)
-            my_func(x:int=4, y:float=3, z:float=2)
-            my_func(x:int=5, y:float=3, z:float=2)
-            my_func(x:int=6, y:float=3, z:float=2)
-        """
-        with capture:
-            a, b, c = np.array([[1, 2, 3], [4, 5, 6]], order='F'), np.array([[2], [3]]), 2
-            assert np.allclose(f(a, b, c), a * b * c)
-        assert capture == """
-            my_func(x:int=1, y:float=2, z:float=2)
-            my_func(x:int=2, y:float=2, z:float=2)
-            my_func(x:int=3, y:float=2, z:float=2)
-            my_func(x:int=4, y:float=3, z:float=2)
-            my_func(x:int=5, y:float=3, z:float=2)
-            my_func(x:int=6, y:float=3, z:float=2)
-        """
-        with capture:
-            a, b, c = np.array([[1, 2, 3], [4, 5, 6]])[::, ::2], np.array([[2], [3]]), 2
-            assert np.allclose(f(a, b, c), a * b * c)
-        assert capture == """
-            my_func(x:int=1, y:float=2, z:float=2)
-            my_func(x:int=3, y:float=2, z:float=2)
-            my_func(x:int=4, y:float=3, z:float=2)
-            my_func(x:int=6, y:float=3, z:float=2)
-        """
-        with capture:
-            a, b, c = np.array([[1, 2, 3], [4, 5, 6]], order='F')[::, ::2], np.array([[2], [3]]), 2
-            assert np.allclose(f(a, b, c), a * b * c)
-        assert capture == """
-            my_func(x:int=1, y:float=2, z:float=2)
-            my_func(x:int=3, y:float=2, z:float=2)
-            my_func(x:int=4, y:float=3, z:float=2)
-            my_func(x:int=6, y:float=3, z:float=2)
-        """
-
-
-def test_type_selection():
-    assert m.selective_func(np.array([1], dtype=np.int32)) == "Int branch taken."
-    assert m.selective_func(np.array([1.0], dtype=np.float32)) == "Float branch taken."
-    assert m.selective_func(np.array([1.0j], dtype=np.complex64)) == "Complex float branch taken."
-
-
-def test_docs(doc):
-    assert doc(m.vectorized_func) == """
-        vectorized_func(arg0: numpy.ndarray[int32], arg1: numpy.ndarray[float32], arg2: numpy.ndarray[float64]) -> object
-    """  # noqa: E501 line too long
-
-
-def test_trivial_broadcasting():
-    trivial, vectorized_is_trivial = m.trivial, m.vectorized_is_trivial
-
-    assert vectorized_is_trivial(1, 2, 3) == trivial.c_trivial
-    assert vectorized_is_trivial(np.array(1), np.array(2), 3) == trivial.c_trivial
-    assert vectorized_is_trivial(np.array([1, 3]), np.array([2, 4]), 3) == trivial.c_trivial
-    assert trivial.c_trivial == vectorized_is_trivial(
-        np.array([[1, 3, 5], [7, 9, 11]]), np.array([[2, 4, 6], [8, 10, 12]]), 3)
-    assert vectorized_is_trivial(
-        np.array([[1, 2, 3], [4, 5, 6]]), np.array([2, 3, 4]), 2) == trivial.non_trivial
-    assert vectorized_is_trivial(
-        np.array([[1, 2, 3], [4, 5, 6]]), np.array([[2], [3]]), 2) == trivial.non_trivial
-    z1 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]], dtype='int32')
-    z2 = np.array(z1, dtype='float32')
-    z3 = np.array(z1, dtype='float64')
-    assert vectorized_is_trivial(z1, z2, z3) == trivial.c_trivial
-    assert vectorized_is_trivial(1, z2, z3) == trivial.c_trivial
-    assert vectorized_is_trivial(z1, 1, z3) == trivial.c_trivial
-    assert vectorized_is_trivial(z1, z2, 1) == trivial.c_trivial
-    assert vectorized_is_trivial(z1[::2, ::2], 1, 1) == trivial.non_trivial
-    assert vectorized_is_trivial(1, 1, z1[::2, ::2]) == trivial.c_trivial
-    assert vectorized_is_trivial(1, 1, z3[::2, ::2]) == trivial.non_trivial
-    assert vectorized_is_trivial(z1, 1, z3[1::4, 1::4]) == trivial.c_trivial
-
-    y1 = np.array(z1, order='F')
-    y2 = np.array(y1)
-    y3 = np.array(y1)
-    assert vectorized_is_trivial(y1, y2, y3) == trivial.f_trivial
-    assert vectorized_is_trivial(y1, 1, 1) == trivial.f_trivial
-    assert vectorized_is_trivial(1, y2, 1) == trivial.f_trivial
-    assert vectorized_is_trivial(1, 1, y3) == trivial.f_trivial
-    assert vectorized_is_trivial(y1, z2, 1) == trivial.non_trivial
-    assert vectorized_is_trivial(z1[1::4, 1::4], y2, 1) == trivial.f_trivial
-    assert vectorized_is_trivial(y1[1::4, 1::4], z2, 1) == trivial.c_trivial
-
-    assert m.vectorized_func(z1, z2, z3).flags.c_contiguous
-    assert m.vectorized_func(y1, y2, y3).flags.f_contiguous
-    assert m.vectorized_func(z1, 1, 1).flags.c_contiguous
-    assert m.vectorized_func(1, y2, 1).flags.f_contiguous
-    assert m.vectorized_func(z1[1::4, 1::4], y2, 1).flags.f_contiguous
-    assert m.vectorized_func(y1[1::4, 1::4], z2, 1).flags.c_contiguous
-
-
-def test_passthrough_arguments(doc):
-    assert doc(m.vec_passthrough) == (
-        "vec_passthrough(" + ", ".join([
-            "arg0: float",
-            "arg1: numpy.ndarray[float64]",
-            "arg2: numpy.ndarray[float64]",
-            "arg3: numpy.ndarray[int32]",
-            "arg4: int",
-            "arg5: m.numpy_vectorize.NonPODClass",
-            "arg6: numpy.ndarray[float64]"]) + ") -> object")
-
-    b = np.array([[10, 20, 30]], dtype='float64')
-    c = np.array([100, 200])  # NOT a vectorized argument
-    d = np.array([[1000], [2000], [3000]], dtype='int')
-    g = np.array([[1000000, 2000000, 3000000]], dtype='int')  # requires casting
-    assert np.all(
-        m.vec_passthrough(1, b, c, d, 10000, m.NonPODClass(100000), g) ==
-        np.array([[1111111, 2111121, 3111131],
-                  [1112111, 2112121, 3112131],
-                  [1113111, 2113121, 3113131]]))
-
-
-def test_method_vectorization():
-    o = m.VectorizeTestClass(3)
-    x = np.array([1, 2], dtype='int')
-    y = np.array([[10], [20]], dtype='float32')
-    assert np.all(o.method(x, y) == [[14, 15], [24, 25]])
-
-
-def test_array_collapse():
-    assert not isinstance(m.vectorized_func(1, 2, 3), np.ndarray)
-    assert not isinstance(m.vectorized_func(np.array(1), 2, 3), np.ndarray)
-    z = m.vectorized_func([1], 2, 3)
-    assert isinstance(z, np.ndarray)
-    assert z.shape == (1, )
-    z = m.vectorized_func(1, [[[2]]], 3)
-    assert isinstance(z, np.ndarray)
-    assert z.shape == (1, 1, 1)
diff --git a/tmap/lib/pybind11/tests/test_opaque_types.cpp b/tmap/lib/pybind11/tests/test_opaque_types.cpp
deleted file mode 100644
index 5e83df0..0000000
--- a/tmap/lib/pybind11/tests/test_opaque_types.cpp
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
-    tests/test_opaque_types.cpp -- opaque types, passing void pointers
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include <pybind11/stl.h>
-#include <vector>
-
-using StringList = std::vector<std::string>;
-
-/* IMPORTANT: Disable internal pybind11 translation mechanisms for STL data structures */
-PYBIND11_MAKE_OPAQUE(StringList);
-
-TEST_SUBMODULE(opaque_types, m) {
-    // test_string_list
-    py::class_<StringList>(m, "StringList")
-        .def(py::init<>())
-        .def("pop_back", &StringList::pop_back)
-        /* There are multiple versions of push_back(), etc. Select the right ones. */
-        .def("push_back", (void (StringList::*)(const std::string &)) &StringList::push_back)
-        .def("back", (std::string &(StringList::*)()) &StringList::back)
-        .def("__len__", [](const StringList &v) { return v.size(); })
-        .def("__iter__", [](StringList &v) {
-           return py::make_iterator(v.begin(), v.end());
-        }, py::keep_alive<0, 1>());
-
-    class ClassWithSTLVecProperty {
-    public:
-        StringList stringList;
-    };
-    py::class_<ClassWithSTLVecProperty>(m, "ClassWithSTLVecProperty")
-        .def(py::init<>())
-        .def_readwrite("stringList", &ClassWithSTLVecProperty::stringList);
-
-    m.def("print_opaque_list", [](const StringList &l) {
-        std::string ret = "Opaque list: [";
-        bool first = true;
-        for (auto entry : l) {
-            if (!first)
-                ret += ", ";
-            ret += entry;
-            first = false;
-        }
-        return ret + "]";
-    });
-
-    // test_pointers
-    m.def("return_void_ptr", []() { return (void *) 0x1234; });
-    m.def("get_void_ptr_value", [](void *ptr) { return reinterpret_cast<std::intptr_t>(ptr); });
-    m.def("return_null_str", []() { return (char *) nullptr; });
-    m.def("get_null_str_value", [](char *ptr) { return reinterpret_cast<std::intptr_t>(ptr); });
-
-    m.def("return_unique_ptr", []() -> std::unique_ptr<StringList> {
-        StringList *result = new StringList();
-        result->push_back("some value");
-        return std::unique_ptr<StringList>(result);
-    });
-}
diff --git a/tmap/lib/pybind11/tests/test_opaque_types.py b/tmap/lib/pybind11/tests/test_opaque_types.py
deleted file mode 100644
index 2d3aef5..0000000
--- a/tmap/lib/pybind11/tests/test_opaque_types.py
+++ /dev/null
@@ -1,46 +0,0 @@
-import pytest
-from pybind11_tests import opaque_types as m
-from pybind11_tests import ConstructorStats, UserType
-
-
-def test_string_list():
-    l = m.StringList()
-    l.push_back("Element 1")
-    l.push_back("Element 2")
-    assert m.print_opaque_list(l) == "Opaque list: [Element 1, Element 2]"
-    assert l.back() == "Element 2"
-
-    for i, k in enumerate(l, start=1):
-        assert k == "Element {}".format(i)
-    l.pop_back()
-    assert m.print_opaque_list(l) == "Opaque list: [Element 1]"
-
-    cvp = m.ClassWithSTLVecProperty()
-    assert m.print_opaque_list(cvp.stringList) == "Opaque list: []"
-
-    cvp.stringList = l
-    cvp.stringList.push_back("Element 3")
-    assert m.print_opaque_list(cvp.stringList) == "Opaque list: [Element 1, Element 3]"
-
-
-def test_pointers(msg):
-    living_before = ConstructorStats.get(UserType).alive()
-    assert m.get_void_ptr_value(m.return_void_ptr()) == 0x1234
-    assert m.get_void_ptr_value(UserType())  # Should also work for other C++ types
-    assert ConstructorStats.get(UserType).alive() == living_before
-
-    with pytest.raises(TypeError) as excinfo:
-        m.get_void_ptr_value([1, 2, 3])  # This should not work
-    assert msg(excinfo.value) == """
-        get_void_ptr_value(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: capsule) -> int
-
-        Invoked with: [1, 2, 3]
-    """  # noqa: E501 line too long
-
-    assert m.return_null_str() is None
-    assert m.get_null_str_value(m.return_null_str()) is not None
-
-    ptr = m.return_unique_ptr()
-    assert "StringList" in repr(ptr)
-    assert m.print_opaque_list(ptr) == "Opaque list: [some value]"
diff --git a/tmap/lib/pybind11/tests/test_operator_overloading.cpp b/tmap/lib/pybind11/tests/test_operator_overloading.cpp
deleted file mode 100644
index 4ad34d1..0000000
--- a/tmap/lib/pybind11/tests/test_operator_overloading.cpp
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
-    tests/test_operator_overloading.cpp -- operator overloading
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "constructor_stats.h"
-#include <pybind11/operators.h>
-#include <functional>
-
-class Vector2 {
-public:
-    Vector2(float x, float y) : x(x), y(y) { print_created(this, toString()); }
-    Vector2(const Vector2 &v) : x(v.x), y(v.y) { print_copy_created(this); }
-    Vector2(Vector2 &&v) : x(v.x), y(v.y) { print_move_created(this); v.x = v.y = 0; }
-    Vector2 &operator=(const Vector2 &v) { x = v.x; y = v.y; print_copy_assigned(this); return *this; }
-    Vector2 &operator=(Vector2 &&v) { x = v.x; y = v.y; v.x = v.y = 0; print_move_assigned(this); return *this; }
-    ~Vector2() { print_destroyed(this); }
-
-    std::string toString() const { return "[" + std::to_string(x) + ", " + std::to_string(y) + "]"; }
-
-    Vector2 operator+(const Vector2 &v) const { return Vector2(x + v.x, y + v.y); }
-    Vector2 operator-(const Vector2 &v) const { return Vector2(x - v.x, y - v.y); }
-    Vector2 operator-(float value) const { return Vector2(x - value, y - value); }
-    Vector2 operator+(float value) const { return Vector2(x + value, y + value); }
-    Vector2 operator*(float value) const { return Vector2(x * value, y * value); }
-    Vector2 operator/(float value) const { return Vector2(x / value, y / value); }
-    Vector2 operator*(const Vector2 &v) const { return Vector2(x * v.x, y * v.y); }
-    Vector2 operator/(const Vector2 &v) const { return Vector2(x / v.x, y / v.y); }
-    Vector2& operator+=(const Vector2 &v) { x += v.x; y += v.y; return *this; }
-    Vector2& operator-=(const Vector2 &v) { x -= v.x; y -= v.y; return *this; }
-    Vector2& operator*=(float v) { x *= v; y *= v; return *this; }
-    Vector2& operator/=(float v) { x /= v; y /= v; return *this; }
-    Vector2& operator*=(const Vector2 &v) { x *= v.x; y *= v.y; return *this; }
-    Vector2& operator/=(const Vector2 &v) { x /= v.x; y /= v.y; return *this; }
-
-    friend Vector2 operator+(float f, const Vector2 &v) { return Vector2(f + v.x, f + v.y); }
-    friend Vector2 operator-(float f, const Vector2 &v) { return Vector2(f - v.x, f - v.y); }
-    friend Vector2 operator*(float f, const Vector2 &v) { return Vector2(f * v.x, f * v.y); }
-    friend Vector2 operator/(float f, const Vector2 &v) { return Vector2(f / v.x, f / v.y); }
-private:
-    float x, y;
-};
-
-class C1 { };
-class C2 { };
-
-int operator+(const C1 &, const C1 &) { return 11; }
-int operator+(const C2 &, const C2 &) { return 22; }
-int operator+(const C2 &, const C1 &) { return 21; }
-int operator+(const C1 &, const C2 &) { return 12; }
-
-namespace std {
-    template<>
-    struct hash<Vector2> {
-        // Not a good hash function, but easy to test
-        size_t operator()(const Vector2 &) { return 4; }
-    };
-}
-
-TEST_SUBMODULE(operators, m) {
-
-    // test_operator_overloading
-    py::class_<Vector2>(m, "Vector2")
-        .def(py::init<float, float>())
-        .def(py::self + py::self)
-        .def(py::self + float())
-        .def(py::self - py::self)
-        .def(py::self - float())
-        .def(py::self * float())
-        .def(py::self / float())
-        .def(py::self * py::self)
-        .def(py::self / py::self)
-        .def(py::self += py::self)
-        .def(py::self -= py::self)
-        .def(py::self *= float())
-        .def(py::self /= float())
-        .def(py::self *= py::self)
-        .def(py::self /= py::self)
-        .def(float() + py::self)
-        .def(float() - py::self)
-        .def(float() * py::self)
-        .def(float() / py::self)
-        .def("__str__", &Vector2::toString)
-        .def(hash(py::self))
-        ;
-
-    m.attr("Vector") = m.attr("Vector2");
-
-    // test_operators_notimplemented
-    // #393: need to return NotSupported to ensure correct arithmetic operator behavior
-    py::class_<C1>(m, "C1")
-        .def(py::init<>())
-        .def(py::self + py::self);
-
-    py::class_<C2>(m, "C2")
-        .def(py::init<>())
-        .def(py::self + py::self)
-        .def("__add__", [](const C2& c2, const C1& c1) { return c2 + c1; })
-        .def("__radd__", [](const C2& c2, const C1& c1) { return c1 + c2; });
-
-    // test_nested
-    // #328: first member in a class can't be used in operators
-    struct NestABase { int value = -2; };
-    py::class_<NestABase>(m, "NestABase")
-        .def(py::init<>())
-        .def_readwrite("value", &NestABase::value);
-
-    struct NestA : NestABase {
-        int value = 3;
-        NestA& operator+=(int i) { value += i; return *this; }
-    };
-    py::class_<NestA>(m, "NestA")
-        .def(py::init<>())
-        .def(py::self += int())
-        .def("as_base", [](NestA &a) -> NestABase& {
-            return (NestABase&) a;
-        }, py::return_value_policy::reference_internal);
-    m.def("get_NestA", [](const NestA &a) { return a.value; });
-
-    struct NestB {
-        NestA a;
-        int value = 4;
-        NestB& operator-=(int i) { value -= i; return *this; }
-    };
-    py::class_<NestB>(m, "NestB")
-        .def(py::init<>())
-        .def(py::self -= int())
-        .def_readwrite("a", &NestB::a);
-    m.def("get_NestB", [](const NestB &b) { return b.value; });
-
-    struct NestC {
-        NestB b;
-        int value = 5;
-        NestC& operator*=(int i) { value *= i; return *this; }
-    };
-    py::class_<NestC>(m, "NestC")
-        .def(py::init<>())
-        .def(py::self *= int())
-        .def_readwrite("b", &NestC::b);
-    m.def("get_NestC", [](const NestC &c) { return c.value; });
-}
diff --git a/tmap/lib/pybind11/tests/test_operator_overloading.py b/tmap/lib/pybind11/tests/test_operator_overloading.py
deleted file mode 100644
index 0d80e5e..0000000
--- a/tmap/lib/pybind11/tests/test_operator_overloading.py
+++ /dev/null
@@ -1,106 +0,0 @@
-import pytest
-from pybind11_tests import operators as m
-from pybind11_tests import ConstructorStats
-
-
-def test_operator_overloading():
-    v1 = m.Vector2(1, 2)
-    v2 = m.Vector(3, -1)
-    assert str(v1) == "[1.000000, 2.000000]"
-    assert str(v2) == "[3.000000, -1.000000]"
-
-    assert str(v1 + v2) == "[4.000000, 1.000000]"
-    assert str(v1 - v2) == "[-2.000000, 3.000000]"
-    assert str(v1 - 8) == "[-7.000000, -6.000000]"
-    assert str(v1 + 8) == "[9.000000, 10.000000]"
-    assert str(v1 * 8) == "[8.000000, 16.000000]"
-    assert str(v1 / 8) == "[0.125000, 0.250000]"
-    assert str(8 - v1) == "[7.000000, 6.000000]"
-    assert str(8 + v1) == "[9.000000, 10.000000]"
-    assert str(8 * v1) == "[8.000000, 16.000000]"
-    assert str(8 / v1) == "[8.000000, 4.000000]"
-    assert str(v1 * v2) == "[3.000000, -2.000000]"
-    assert str(v2 / v1) == "[3.000000, -0.500000]"
-
-    v1 += 2 * v2
-    assert str(v1) == "[7.000000, 0.000000]"
-    v1 -= v2
-    assert str(v1) == "[4.000000, 1.000000]"
-    v1 *= 2
-    assert str(v1) == "[8.000000, 2.000000]"
-    v1 /= 16
-    assert str(v1) == "[0.500000, 0.125000]"
-    v1 *= v2
-    assert str(v1) == "[1.500000, -0.125000]"
-    v2 /= v1
-    assert str(v2) == "[2.000000, 8.000000]"
-
-    assert hash(v1) == 4
-
-    cstats = ConstructorStats.get(m.Vector2)
-    assert cstats.alive() == 2
-    del v1
-    assert cstats.alive() == 1
-    del v2
-    assert cstats.alive() == 0
-    assert cstats.values() == ['[1.000000, 2.000000]', '[3.000000, -1.000000]',
-                               '[4.000000, 1.000000]', '[-2.000000, 3.000000]',
-                               '[-7.000000, -6.000000]', '[9.000000, 10.000000]',
-                               '[8.000000, 16.000000]', '[0.125000, 0.250000]',
-                               '[7.000000, 6.000000]', '[9.000000, 10.000000]',
-                               '[8.000000, 16.000000]', '[8.000000, 4.000000]',
-                               '[3.000000, -2.000000]', '[3.000000, -0.500000]',
-                               '[6.000000, -2.000000]']
-    assert cstats.default_constructions == 0
-    assert cstats.copy_constructions == 0
-    assert cstats.move_constructions >= 10
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-
-def test_operators_notimplemented():
-    """#393: need to return NotSupported to ensure correct arithmetic operator behavior"""
-
-    c1, c2 = m.C1(), m.C2()
-    assert c1 + c1 == 11
-    assert c2 + c2 == 22
-    assert c2 + c1 == 21
-    assert c1 + c2 == 12
-
-
-def test_nested():
-    """#328: first member in a class can't be used in operators"""
-
-    a = m.NestA()
-    b = m.NestB()
-    c = m.NestC()
-
-    a += 10
-    assert m.get_NestA(a) == 13
-    b.a += 100
-    assert m.get_NestA(b.a) == 103
-    c.b.a += 1000
-    assert m.get_NestA(c.b.a) == 1003
-    b -= 1
-    assert m.get_NestB(b) == 3
-    c.b -= 3
-    assert m.get_NestB(c.b) == 1
-    c *= 7
-    assert m.get_NestC(c) == 35
-
-    abase = a.as_base()
-    assert abase.value == -2
-    a.as_base().value += 44
-    assert abase.value == 42
-    assert c.b.a.as_base().value == -2
-    c.b.a.as_base().value += 44
-    assert c.b.a.as_base().value == 42
-
-    del c
-    pytest.gc_collect()
-    del a  # Should't delete while abase is still alive
-    pytest.gc_collect()
-
-    assert abase.value == 42
-    del abase, b
-    pytest.gc_collect()
diff --git a/tmap/lib/pybind11/tests/test_pickling.cpp b/tmap/lib/pybind11/tests/test_pickling.cpp
deleted file mode 100644
index 821462a..0000000
--- a/tmap/lib/pybind11/tests/test_pickling.cpp
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
-    tests/test_pickling.cpp -- pickle support
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-
-TEST_SUBMODULE(pickling, m) {
-    // test_roundtrip
-    class Pickleable {
-    public:
-        Pickleable(const std::string &value) : m_value(value) { }
-        const std::string &value() const { return m_value; }
-
-        void setExtra1(int extra1) { m_extra1 = extra1; }
-        void setExtra2(int extra2) { m_extra2 = extra2; }
-        int extra1() const { return m_extra1; }
-        int extra2() const { return m_extra2; }
-    private:
-        std::string m_value;
-        int m_extra1 = 0;
-        int m_extra2 = 0;
-    };
-
-    class PickleableNew : public Pickleable {
-    public:
-        using Pickleable::Pickleable;
-    };
-
-    py::class_<Pickleable>(m, "Pickleable")
-        .def(py::init<std::string>())
-        .def("value", &Pickleable::value)
-        .def("extra1", &Pickleable::extra1)
-        .def("extra2", &Pickleable::extra2)
-        .def("setExtra1", &Pickleable::setExtra1)
-        .def("setExtra2", &Pickleable::setExtra2)
-        // For details on the methods below, refer to
-        // http://docs.python.org/3/library/pickle.html#pickling-class-instances
-        .def("__getstate__", [](const Pickleable &p) {
-            /* Return a tuple that fully encodes the state of the object */
-            return py::make_tuple(p.value(), p.extra1(), p.extra2());
-        })
-        .def("__setstate__", [](Pickleable &p, py::tuple t) {
-            if (t.size() != 3)
-                throw std::runtime_error("Invalid state!");
-            /* Invoke the constructor (need to use in-place version) */
-            new (&p) Pickleable(t[0].cast<std::string>());
-
-            /* Assign any additional state */
-            p.setExtra1(t[1].cast<int>());
-            p.setExtra2(t[2].cast<int>());
-        });
-
-    py::class_<PickleableNew, Pickleable>(m, "PickleableNew")
-        .def(py::init<std::string>())
-        .def(py::pickle(
-            [](const PickleableNew &p) {
-                return py::make_tuple(p.value(), p.extra1(), p.extra2());
-            },
-            [](py::tuple t) {
-                if (t.size() != 3)
-                    throw std::runtime_error("Invalid state!");
-                auto p = PickleableNew(t[0].cast<std::string>());
-
-                p.setExtra1(t[1].cast<int>());
-                p.setExtra2(t[2].cast<int>());
-                return p;
-            }
-        ));
-
-#if !defined(PYPY_VERSION)
-    // test_roundtrip_with_dict
-    class PickleableWithDict {
-    public:
-        PickleableWithDict(const std::string &value) : value(value) { }
-
-        std::string value;
-        int extra;
-    };
-
-    class PickleableWithDictNew : public PickleableWithDict {
-    public:
-        using PickleableWithDict::PickleableWithDict;
-    };
-
-    py::class_<PickleableWithDict>(m, "PickleableWithDict", py::dynamic_attr())
-        .def(py::init<std::string>())
-        .def_readwrite("value", &PickleableWithDict::value)
-        .def_readwrite("extra", &PickleableWithDict::extra)
-        .def("__getstate__", [](py::object self) {
-            /* Also include __dict__ in state */
-            return py::make_tuple(self.attr("value"), self.attr("extra"), self.attr("__dict__"));
-        })
-        .def("__setstate__", [](py::object self, py::tuple t) {
-            if (t.size() != 3)
-                throw std::runtime_error("Invalid state!");
-            /* Cast and construct */
-            auto& p = self.cast<PickleableWithDict&>();
-            new (&p) PickleableWithDict(t[0].cast<std::string>());
-
-            /* Assign C++ state */
-            p.extra = t[1].cast<int>();
-
-            /* Assign Python state */
-            self.attr("__dict__") = t[2];
-        });
-
-    py::class_<PickleableWithDictNew, PickleableWithDict>(m, "PickleableWithDictNew")
-        .def(py::init<std::string>())
-        .def(py::pickle(
-            [](py::object self) {
-                return py::make_tuple(self.attr("value"), self.attr("extra"), self.attr("__dict__"));
-            },
-            [](py::tuple t) {
-                if (t.size() != 3)
-                    throw std::runtime_error("Invalid state!");
-
-                auto cpp_state = PickleableWithDictNew(t[0].cast<std::string>());
-                cpp_state.extra = t[1].cast<int>();
-
-                auto py_state = t[2].cast<py::dict>();
-                return std::make_pair(cpp_state, py_state);
-            }
-        ));
-#endif
-}
diff --git a/tmap/lib/pybind11/tests/test_pickling.py b/tmap/lib/pybind11/tests/test_pickling.py
deleted file mode 100644
index 707d347..0000000
--- a/tmap/lib/pybind11/tests/test_pickling.py
+++ /dev/null
@@ -1,36 +0,0 @@
-import pytest
-from pybind11_tests import pickling as m
-
-try:
-    import cPickle as pickle  # Use cPickle on Python 2.7
-except ImportError:
-    import pickle
-
-
-@pytest.mark.parametrize("cls_name", ["Pickleable", "PickleableNew"])
-def test_roundtrip(cls_name):
-    cls = getattr(m, cls_name)
-    p = cls("test_value")
-    p.setExtra1(15)
-    p.setExtra2(48)
-
-    data = pickle.dumps(p, 2)  # Must use pickle protocol >= 2
-    p2 = pickle.loads(data)
-    assert p2.value() == p.value()
-    assert p2.extra1() == p.extra1()
-    assert p2.extra2() == p.extra2()
-
-
-@pytest.unsupported_on_pypy
-@pytest.mark.parametrize("cls_name", ["PickleableWithDict", "PickleableWithDictNew"])
-def test_roundtrip_with_dict(cls_name):
-    cls = getattr(m, cls_name)
-    p = cls("test_value")
-    p.extra = 15
-    p.dynamic = "Attribute"
-
-    data = pickle.dumps(p, pickle.HIGHEST_PROTOCOL)
-    p2 = pickle.loads(data)
-    assert p2.value == p.value
-    assert p2.extra == p.extra
-    assert p2.dynamic == p.dynamic
diff --git a/tmap/lib/pybind11/tests/test_pytypes.cpp b/tmap/lib/pybind11/tests/test_pytypes.cpp
deleted file mode 100644
index 4742236..0000000
--- a/tmap/lib/pybind11/tests/test_pytypes.cpp
+++ /dev/null
@@ -1,266 +0,0 @@
-/*
-    tests/test_pytypes.cpp -- Python type casters
-
-    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-
-
-TEST_SUBMODULE(pytypes, m) {
-    // test_list
-    m.def("get_list", []() {
-        py::list list;
-        list.append("value");
-        py::print("Entry at position 0:", list[0]);
-        list[0] = py::str("overwritten");
-        return list;
-    });
-    m.def("print_list", [](py::list list) {
-        int index = 0;
-        for (auto item : list)
-            py::print("list item {}: {}"_s.format(index++, item));
-    });
-
-    // test_set
-    m.def("get_set", []() {
-        py::set set;
-        set.add(py::str("key1"));
-        set.add("key2");
-        set.add(std::string("key3"));
-        return set;
-    });
-    m.def("print_set", [](py::set set) {
-        for (auto item : set)
-            py::print("key:", item);
-    });
-
-    // test_dict
-    m.def("get_dict", []() { return py::dict("key"_a="value"); });
-    m.def("print_dict", [](py::dict dict) {
-        for (auto item : dict)
-            py::print("key: {}, value={}"_s.format(item.first, item.second));
-    });
-    m.def("dict_keyword_constructor", []() {
-        auto d1 = py::dict("x"_a=1, "y"_a=2);
-        auto d2 = py::dict("z"_a=3, **d1);
-        return d2;
-    });
-
-    // test_str
-    m.def("str_from_string", []() { return py::str(std::string("baz")); });
-    m.def("str_from_bytes", []() { return py::str(py::bytes("boo", 3)); });
-    m.def("str_from_object", [](const py::object& obj) { return py::str(obj); });
-    m.def("repr_from_object", [](const py::object& obj) { return py::repr(obj); });
-
-    m.def("str_format", []() {
-        auto s1 = "{} + {} = {}"_s.format(1, 2, 3);
-        auto s2 = "{a} + {b} = {c}"_s.format("a"_a=1, "b"_a=2, "c"_a=3);
-        return py::make_tuple(s1, s2);
-    });
-
-    // test_bytes
-    m.def("bytes_from_string", []() { return py::bytes(std::string("foo")); });
-    m.def("bytes_from_str", []() { return py::bytes(py::str("bar", 3)); });
-
-    // test_capsule
-    m.def("return_capsule_with_destructor", []() {
-        py::print("creating capsule");
-        return py::capsule([]() {
-            py::print("destructing capsule");
-        });
-    });
-
-    m.def("return_capsule_with_destructor_2", []() {
-        py::print("creating capsule");
-        return py::capsule((void *) 1234, [](void *ptr) {
-            py::print("destructing capsule: {}"_s.format((size_t) ptr));
-        });
-    });
-
-    m.def("return_capsule_with_name_and_destructor", []() {
-        auto capsule = py::capsule((void *) 1234, "pointer type description", [](PyObject *ptr) {
-            if (ptr) {
-                auto name = PyCapsule_GetName(ptr);
-                py::print("destructing capsule ({}, '{}')"_s.format(
-                    (size_t) PyCapsule_GetPointer(ptr, name), name
-                ));
-            }
-        });
-        void *contents = capsule;
-        py::print("created capsule ({}, '{}')"_s.format((size_t) contents, capsule.name()));
-        return capsule;
-    });
-
-    // test_accessors
-    m.def("accessor_api", [](py::object o) {
-        auto d = py::dict();
-
-        d["basic_attr"] = o.attr("basic_attr");
-
-        auto l = py::list();
-        for (const auto &item : o.attr("begin_end")) {
-            l.append(item);
-        }
-        d["begin_end"] = l;
-
-        d["operator[object]"] = o.attr("d")["operator[object]"_s];
-        d["operator[char *]"] = o.attr("d")["operator[char *]"];
-
-        d["attr(object)"] = o.attr("sub").attr("attr_obj");
-        d["attr(char *)"] = o.attr("sub").attr("attr_char");
-        try {
-            o.attr("sub").attr("missing").ptr();
-        } catch (const py::error_already_set &) {
-            d["missing_attr_ptr"] = "raised"_s;
-        }
-        try {
-            o.attr("missing").attr("doesn't matter");
-        } catch (const py::error_already_set &) {
-            d["missing_attr_chain"] = "raised"_s;
-        }
-
-        d["is_none"] = o.attr("basic_attr").is_none();
-
-        d["operator()"] = o.attr("func")(1);
-        d["operator*"] = o.attr("func")(*o.attr("begin_end"));
-
-        return d;
-    });
-
-    m.def("tuple_accessor", [](py::tuple existing_t) {
-        try {
-            existing_t[0] = 1;
-        } catch (const py::error_already_set &) {
-            // --> Python system error
-            // Only new tuples (refcount == 1) are mutable
-            auto new_t = py::tuple(3);
-            for (size_t i = 0; i < new_t.size(); ++i) {
-                new_t[i] = i;
-            }
-            return new_t;
-        }
-        return py::tuple();
-    });
-
-    m.def("accessor_assignment", []() {
-        auto l = py::list(1);
-        l[0] = 0;
-
-        auto d = py::dict();
-        d["get"] = l[0];
-        auto var = l[0];
-        d["deferred_get"] = var;
-        l[0] = 1;
-        d["set"] = l[0];
-        var = 99; // this assignment should not overwrite l[0]
-        d["deferred_set"] = l[0];
-        d["var"] = var;
-
-        return d;
-    });
-
-    // test_constructors
-    m.def("default_constructors", []() {
-        return py::dict(
-            "str"_a=py::str(),
-            "bool"_a=py::bool_(),
-            "int"_a=py::int_(),
-            "float"_a=py::float_(),
-            "tuple"_a=py::tuple(),
-            "list"_a=py::list(),
-            "dict"_a=py::dict(),
-            "set"_a=py::set()
-        );
-    });
-
-    m.def("converting_constructors", [](py::dict d) {
-        return py::dict(
-            "str"_a=py::str(d["str"]),
-            "bool"_a=py::bool_(d["bool"]),
-            "int"_a=py::int_(d["int"]),
-            "float"_a=py::float_(d["float"]),
-            "tuple"_a=py::tuple(d["tuple"]),
-            "list"_a=py::list(d["list"]),
-            "dict"_a=py::dict(d["dict"]),
-            "set"_a=py::set(d["set"]),
-            "memoryview"_a=py::memoryview(d["memoryview"])
-        );
-    });
-
-    m.def("cast_functions", [](py::dict d) {
-        // When converting between Python types, obj.cast<T>() should be the same as T(obj)
-        return py::dict(
-            "str"_a=d["str"].cast<py::str>(),
-            "bool"_a=d["bool"].cast<py::bool_>(),
-            "int"_a=d["int"].cast<py::int_>(),
-            "float"_a=d["float"].cast<py::float_>(),
-            "tuple"_a=d["tuple"].cast<py::tuple>(),
-            "list"_a=d["list"].cast<py::list>(),
-            "dict"_a=d["dict"].cast<py::dict>(),
-            "set"_a=d["set"].cast<py::set>(),
-            "memoryview"_a=d["memoryview"].cast<py::memoryview>()
-        );
-    });
-
-    m.def("get_implicit_casting", []() {
-        py::dict d;
-        d["char*_i1"] = "abc";
-        const char *c2 = "abc";
-        d["char*_i2"] = c2;
-        d["char*_e"] = py::cast(c2);
-        d["char*_p"] = py::str(c2);
-
-        d["int_i1"] = 42;
-        int i = 42;
-        d["int_i2"] = i;
-        i++;
-        d["int_e"] = py::cast(i);
-        i++;
-        d["int_p"] = py::int_(i);
-
-        d["str_i1"] = std::string("str");
-        std::string s2("str1");
-        d["str_i2"] = s2;
-        s2[3] = '2';
-        d["str_e"] = py::cast(s2);
-        s2[3] = '3';
-        d["str_p"] = py::str(s2);
-
-        py::list l(2);
-        l[0] = 3;
-        l[1] = py::cast(6);
-        l.append(9);
-        l.append(py::cast(12));
-        l.append(py::int_(15));
-
-        return py::dict(
-            "d"_a=d,
-            "l"_a=l
-        );
-    });
-
-    // test_print
-    m.def("print_function", []() {
-        py::print("Hello, World!");
-        py::print(1, 2.0, "three", true, std::string("-- multiple args"));
-        auto args = py::make_tuple("and", "a", "custom", "separator");
-        py::print("*args", *args, "sep"_a="-");
-        py::print("no new line here", "end"_a=" -- ");
-        py::print("next print");
-
-        auto py_stderr = py::module::import("sys").attr("stderr");
-        py::print("this goes to stderr", "file"_a=py_stderr);
-
-        py::print("flush", "flush"_a=true);
-
-        py::print("{a} + {b} = {c}"_s.format("a"_a="py::print", "b"_a="str.format", "c"_a="this"));
-    });
-
-    m.def("print_failure", []() { py::print(42, UnregisteredType()); });
-
-    m.def("hash_function", [](py::object obj) { return py::hash(obj); });
-}
diff --git a/tmap/lib/pybind11/tests/test_pytypes.py b/tmap/lib/pybind11/tests/test_pytypes.py
deleted file mode 100644
index 2487cf6..0000000
--- a/tmap/lib/pybind11/tests/test_pytypes.py
+++ /dev/null
@@ -1,238 +0,0 @@
-import pytest
-import sys
-
-from pybind11_tests import pytypes as m
-from pybind11_tests import debug_enabled
-
-
-def test_list(capture, doc):
-    with capture:
-        l = m.get_list()
-        assert l == ["overwritten"]
-
-        l.append("value2")
-        m.print_list(l)
-    assert capture.unordered == """
-        Entry at position 0: value
-        list item 0: overwritten
-        list item 1: value2
-    """
-
-    assert doc(m.get_list) == "get_list() -> list"
-    assert doc(m.print_list) == "print_list(arg0: list) -> None"
-
-
-def test_set(capture, doc):
-    s = m.get_set()
-    assert s == {"key1", "key2", "key3"}
-
-    with capture:
-        s.add("key4")
-        m.print_set(s)
-    assert capture.unordered == """
-        key: key1
-        key: key2
-        key: key3
-        key: key4
-    """
-
-    assert doc(m.get_list) == "get_list() -> list"
-    assert doc(m.print_list) == "print_list(arg0: list) -> None"
-
-
-def test_dict(capture, doc):
-    d = m.get_dict()
-    assert d == {"key": "value"}
-
-    with capture:
-        d["key2"] = "value2"
-        m.print_dict(d)
-    assert capture.unordered == """
-        key: key, value=value
-        key: key2, value=value2
-    """
-
-    assert doc(m.get_dict) == "get_dict() -> dict"
-    assert doc(m.print_dict) == "print_dict(arg0: dict) -> None"
-
-    assert m.dict_keyword_constructor() == {"x": 1, "y": 2, "z": 3}
-
-
-def test_str(doc):
-    assert m.str_from_string().encode().decode() == "baz"
-    assert m.str_from_bytes().encode().decode() == "boo"
-
-    assert doc(m.str_from_bytes) == "str_from_bytes() -> str"
-
-    class A(object):
-        def __str__(self):
-            return "this is a str"
-
-        def __repr__(self):
-            return "this is a repr"
-
-    assert m.str_from_object(A()) == "this is a str"
-    assert m.repr_from_object(A()) == "this is a repr"
-
-    s1, s2 = m.str_format()
-    assert s1 == "1 + 2 = 3"
-    assert s1 == s2
-
-
-def test_bytes(doc):
-    assert m.bytes_from_string().decode() == "foo"
-    assert m.bytes_from_str().decode() == "bar"
-
-    assert doc(m.bytes_from_str) == "bytes_from_str() -> {}".format(
-        "bytes" if sys.version_info[0] == 3 else "str"
-    )
-
-
-def test_capsule(capture):
-    pytest.gc_collect()
-    with capture:
-        a = m.return_capsule_with_destructor()
-        del a
-        pytest.gc_collect()
-    assert capture.unordered == """
-        creating capsule
-        destructing capsule
-    """
-
-    with capture:
-        a = m.return_capsule_with_destructor_2()
-        del a
-        pytest.gc_collect()
-    assert capture.unordered == """
-        creating capsule
-        destructing capsule: 1234
-    """
-
-    with capture:
-        a = m.return_capsule_with_name_and_destructor()
-        del a
-        pytest.gc_collect()
-    assert capture.unordered == """
-        created capsule (1234, 'pointer type description')
-        destructing capsule (1234, 'pointer type description')
-    """
-
-
-def test_accessors():
-    class SubTestObject:
-        attr_obj = 1
-        attr_char = 2
-
-    class TestObject:
-        basic_attr = 1
-        begin_end = [1, 2, 3]
-        d = {"operator[object]": 1, "operator[char *]": 2}
-        sub = SubTestObject()
-
-        def func(self, x, *args):
-            return self.basic_attr + x + sum(args)
-
-    d = m.accessor_api(TestObject())
-    assert d["basic_attr"] == 1
-    assert d["begin_end"] == [1, 2, 3]
-    assert d["operator[object]"] == 1
-    assert d["operator[char *]"] == 2
-    assert d["attr(object)"] == 1
-    assert d["attr(char *)"] == 2
-    assert d["missing_attr_ptr"] == "raised"
-    assert d["missing_attr_chain"] == "raised"
-    assert d["is_none"] is False
-    assert d["operator()"] == 2
-    assert d["operator*"] == 7
-
-    assert m.tuple_accessor(tuple()) == (0, 1, 2)
-
-    d = m.accessor_assignment()
-    assert d["get"] == 0
-    assert d["deferred_get"] == 0
-    assert d["set"] == 1
-    assert d["deferred_set"] == 1
-    assert d["var"] == 99
-
-
-def test_constructors():
-    """C++ default and converting constructors are equivalent to type calls in Python"""
-    types = [str, bool, int, float, tuple, list, dict, set]
-    expected = {t.__name__: t() for t in types}
-    assert m.default_constructors() == expected
-
-    data = {
-        str: 42,
-        bool: "Not empty",
-        int: "42",
-        float: "+1e3",
-        tuple: range(3),
-        list: range(3),
-        dict: [("two", 2), ("one", 1), ("three", 3)],
-        set: [4, 4, 5, 6, 6, 6],
-        memoryview: b'abc'
-    }
-    inputs = {k.__name__: v for k, v in data.items()}
-    expected = {k.__name__: k(v) for k, v in data.items()}
-
-    assert m.converting_constructors(inputs) == expected
-    assert m.cast_functions(inputs) == expected
-
-    # Converting constructors and cast functions should just reference rather
-    # than copy when no conversion is needed:
-    noconv1 = m.converting_constructors(expected)
-    for k in noconv1:
-        assert noconv1[k] is expected[k]
-
-    noconv2 = m.cast_functions(expected)
-    for k in noconv2:
-        assert noconv2[k] is expected[k]
-
-
-def test_implicit_casting():
-    """Tests implicit casting when assigning or appending to dicts and lists."""
-    z = m.get_implicit_casting()
-    assert z['d'] == {
-        'char*_i1': 'abc', 'char*_i2': 'abc', 'char*_e': 'abc', 'char*_p': 'abc',
-        'str_i1': 'str', 'str_i2': 'str1', 'str_e': 'str2', 'str_p': 'str3',
-        'int_i1': 42, 'int_i2': 42, 'int_e': 43, 'int_p': 44
-    }
-    assert z['l'] == [3, 6, 9, 12, 15]
-
-
-def test_print(capture):
-    with capture:
-        m.print_function()
-    assert capture == """
-        Hello, World!
-        1 2.0 three True -- multiple args
-        *args-and-a-custom-separator
-        no new line here -- next print
-        flush
-        py::print + str.format = this
-    """
-    assert capture.stderr == "this goes to stderr"
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.print_failure()
-    assert str(excinfo.value) == "make_tuple(): unable to convert " + (
-        "argument of type 'UnregisteredType' to Python object"
-        if debug_enabled else
-        "arguments to Python object (compile in debug mode for details)"
-    )
-
-
-def test_hash():
-    class Hashable(object):
-        def __init__(self, value):
-            self.value = value
-
-        def __hash__(self):
-            return self.value
-
-    class Unhashable(object):
-        __hash__ = None
-
-    assert m.hash_function(Hashable(42)) == 42
-    with pytest.raises(TypeError):
-        m.hash_function(Unhashable())
diff --git a/tmap/lib/pybind11/tests/test_sequences_and_iterators.cpp b/tmap/lib/pybind11/tests/test_sequences_and_iterators.cpp
deleted file mode 100644
index a455212..0000000
--- a/tmap/lib/pybind11/tests/test_sequences_and_iterators.cpp
+++ /dev/null
@@ -1,334 +0,0 @@
-/*
-    tests/test_sequences_and_iterators.cpp -- supporting Pythons' sequence protocol, iterators,
-    etc.
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "constructor_stats.h"
-#include <pybind11/operators.h>
-#include <pybind11/stl.h>
-
-template<typename T>
-class NonZeroIterator {
-    const T* ptr_;
-public:
-    NonZeroIterator(const T* ptr) : ptr_(ptr) {}
-    const T& operator*() const { return *ptr_; }
-    NonZeroIterator& operator++() { ++ptr_; return *this; }
-};
-
-class NonZeroSentinel {};
-
-template<typename A, typename B>
-bool operator==(const NonZeroIterator<std::pair<A, B>>& it, const NonZeroSentinel&) {
-    return !(*it).first || !(*it).second;
-}
-
-template <typename PythonType>
-py::list test_random_access_iterator(PythonType x) {
-    if (x.size() < 5)
-        throw py::value_error("Please provide at least 5 elements for testing.");
-
-    auto checks = py::list();
-    auto assert_equal = [&checks](py::handle a, py::handle b) {
-        auto result = PyObject_RichCompareBool(a.ptr(), b.ptr(), Py_EQ);
-        if (result == -1) { throw py::error_already_set(); }
-        checks.append(result != 0);
-    };
-
-    auto it = x.begin();
-    assert_equal(x[0], *it);
-    assert_equal(x[0], it[0]);
-    assert_equal(x[1], it[1]);
-
-    assert_equal(x[1], *(++it));
-    assert_equal(x[1], *(it++));
-    assert_equal(x[2], *it);
-    assert_equal(x[3], *(it += 1));
-    assert_equal(x[2], *(--it));
-    assert_equal(x[2], *(it--));
-    assert_equal(x[1], *it);
-    assert_equal(x[0], *(it -= 1));
-
-    assert_equal(it->attr("real"), x[0].attr("real"));
-    assert_equal((it + 1)->attr("real"), x[1].attr("real"));
-
-    assert_equal(x[1], *(it + 1));
-    assert_equal(x[1], *(1 + it));
-    it += 3;
-    assert_equal(x[1], *(it - 2));
-
-    checks.append(static_cast<std::size_t>(x.end() - x.begin()) == x.size());
-    checks.append((x.begin() + static_cast<std::ptrdiff_t>(x.size())) == x.end());
-    checks.append(x.begin() < x.end());
-
-    return checks;
-}
-
-TEST_SUBMODULE(sequences_and_iterators, m) {
-
-    // test_sequence
-    class Sequence {
-    public:
-        Sequence(size_t size) : m_size(size) {
-            print_created(this, "of size", m_size);
-            m_data = new float[size];
-            memset(m_data, 0, sizeof(float) * size);
-        }
-        Sequence(const std::vector<float> &value) : m_size(value.size()) {
-            print_created(this, "of size", m_size, "from std::vector");
-            m_data = new float[m_size];
-            memcpy(m_data, &value[0], sizeof(float) * m_size);
-        }
-        Sequence(const Sequence &s) : m_size(s.m_size) {
-            print_copy_created(this);
-            m_data = new float[m_size];
-            memcpy(m_data, s.m_data, sizeof(float)*m_size);
-        }
-        Sequence(Sequence &&s) : m_size(s.m_size), m_data(s.m_data) {
-            print_move_created(this);
-            s.m_size = 0;
-            s.m_data = nullptr;
-        }
-
-        ~Sequence() { print_destroyed(this); delete[] m_data; }
-
-        Sequence &operator=(const Sequence &s) {
-            if (&s != this) {
-                delete[] m_data;
-                m_size = s.m_size;
-                m_data = new float[m_size];
-                memcpy(m_data, s.m_data, sizeof(float)*m_size);
-            }
-            print_copy_assigned(this);
-            return *this;
-        }
-
-        Sequence &operator=(Sequence &&s) {
-            if (&s != this) {
-                delete[] m_data;
-                m_size = s.m_size;
-                m_data = s.m_data;
-                s.m_size = 0;
-                s.m_data = nullptr;
-            }
-            print_move_assigned(this);
-            return *this;
-        }
-
-        bool operator==(const Sequence &s) const {
-            if (m_size != s.size()) return false;
-            for (size_t i = 0; i < m_size; ++i)
-                if (m_data[i] != s[i])
-                    return false;
-            return true;
-        }
-        bool operator!=(const Sequence &s) const { return !operator==(s); }
-
-        float operator[](size_t index) const { return m_data[index]; }
-        float &operator[](size_t index) { return m_data[index]; }
-
-        bool contains(float v) const {
-            for (size_t i = 0; i < m_size; ++i)
-                if (v == m_data[i])
-                    return true;
-            return false;
-        }
-
-        Sequence reversed() const {
-            Sequence result(m_size);
-            for (size_t i = 0; i < m_size; ++i)
-                result[m_size - i - 1] = m_data[i];
-            return result;
-        }
-
-        size_t size() const { return m_size; }
-
-        const float *begin() const { return m_data; }
-        const float *end() const { return m_data+m_size; }
-
-    private:
-        size_t m_size;
-        float *m_data;
-    };
-    py::class_<Sequence>(m, "Sequence")
-        .def(py::init<size_t>())
-        .def(py::init<const std::vector<float>&>())
-        /// Bare bones interface
-        .def("__getitem__", [](const Sequence &s, size_t i) {
-            if (i >= s.size()) throw py::index_error();
-            return s[i];
-        })
-        .def("__setitem__", [](Sequence &s, size_t i, float v) {
-            if (i >= s.size()) throw py::index_error();
-            s[i] = v;
-        })
-        .def("__len__", &Sequence::size)
-        /// Optional sequence protocol operations
-        .def("__iter__", [](const Sequence &s) { return py::make_iterator(s.begin(), s.end()); },
-                         py::keep_alive<0, 1>() /* Essential: keep object alive while iterator exists */)
-        .def("__contains__", [](const Sequence &s, float v) { return s.contains(v); })
-        .def("__reversed__", [](const Sequence &s) -> Sequence { return s.reversed(); })
-        /// Slicing protocol (optional)
-        .def("__getitem__", [](const Sequence &s, py::slice slice) -> Sequence* {
-            size_t start, stop, step, slicelength;
-            if (!slice.compute(s.size(), &start, &stop, &step, &slicelength))
-                throw py::error_already_set();
-            Sequence *seq = new Sequence(slicelength);
-            for (size_t i = 0; i < slicelength; ++i) {
-                (*seq)[i] = s[start]; start += step;
-            }
-            return seq;
-        })
-        .def("__setitem__", [](Sequence &s, py::slice slice, const Sequence &value) {
-            size_t start, stop, step, slicelength;
-            if (!slice.compute(s.size(), &start, &stop, &step, &slicelength))
-                throw py::error_already_set();
-            if (slicelength != value.size())
-                throw std::runtime_error("Left and right hand size of slice assignment have different sizes!");
-            for (size_t i = 0; i < slicelength; ++i) {
-                s[start] = value[i]; start += step;
-            }
-        })
-        /// Comparisons
-        .def(py::self == py::self)
-        .def(py::self != py::self)
-        // Could also define py::self + py::self for concatenation, etc.
-        ;
-
-    // test_map_iterator
-    // Interface of a map-like object that isn't (directly) an unordered_map, but provides some basic
-    // map-like functionality.
-    class StringMap {
-    public:
-        StringMap() = default;
-        StringMap(std::unordered_map<std::string, std::string> init)
-            : map(std::move(init)) {}
-
-        void set(std::string key, std::string val) { map[key] = val; }
-        std::string get(std::string key) const { return map.at(key); }
-        size_t size() const { return map.size(); }
-    private:
-        std::unordered_map<std::string, std::string> map;
-    public:
-        decltype(map.cbegin()) begin() const { return map.cbegin(); }
-        decltype(map.cend()) end() const { return map.cend(); }
-    };
-    py::class_<StringMap>(m, "StringMap")
-        .def(py::init<>())
-        .def(py::init<std::unordered_map<std::string, std::string>>())
-        .def("__getitem__", [](const StringMap &map, std::string key) {
-                try { return map.get(key); }
-                catch (const std::out_of_range&) {
-                    throw py::key_error("key '" + key + "' does not exist");
-                }
-        })
-        .def("__setitem__", &StringMap::set)
-        .def("__len__", &StringMap::size)
-        .def("__iter__", [](const StringMap &map) { return py::make_key_iterator(map.begin(), map.end()); },
-                py::keep_alive<0, 1>())
-        .def("items", [](const StringMap &map) { return py::make_iterator(map.begin(), map.end()); },
-                py::keep_alive<0, 1>())
-        ;
-
-    // test_generalized_iterators
-    class IntPairs {
-    public:
-        IntPairs(std::vector<std::pair<int, int>> data) : data_(std::move(data)) {}
-        const std::pair<int, int>* begin() const { return data_.data(); }
-    private:
-        std::vector<std::pair<int, int>> data_;
-    };
-    py::class_<IntPairs>(m, "IntPairs")
-        .def(py::init<std::vector<std::pair<int, int>>>())
-        .def("nonzero", [](const IntPairs& s) {
-                return py::make_iterator(NonZeroIterator<std::pair<int, int>>(s.begin()), NonZeroSentinel());
-        }, py::keep_alive<0, 1>())
-        .def("nonzero_keys", [](const IntPairs& s) {
-            return py::make_key_iterator(NonZeroIterator<std::pair<int, int>>(s.begin()), NonZeroSentinel());
-        }, py::keep_alive<0, 1>())
-        ;
-
-
-#if 0
-    // Obsolete: special data structure for exposing custom iterator types to python
-    // kept here for illustrative purposes because there might be some use cases which
-    // are not covered by the much simpler py::make_iterator
-
-    struct PySequenceIterator {
-        PySequenceIterator(const Sequence &seq, py::object ref) : seq(seq), ref(ref) { }
-
-        float next() {
-            if (index == seq.size())
-                throw py::stop_iteration();
-            return seq[index++];
-        }
-
-        const Sequence &seq;
-        py::object ref; // keep a reference
-        size_t index = 0;
-    };
-
-    py::class_<PySequenceIterator>(seq, "Iterator")
-        .def("__iter__", [](PySequenceIterator &it) -> PySequenceIterator& { return it; })
-        .def("__next__", &PySequenceIterator::next);
-
-    On the actual Sequence object, the iterator would be constructed as follows:
-    .def("__iter__", [](py::object s) { return PySequenceIterator(s.cast<const Sequence &>(), s); })
-#endif
-
-    // test_python_iterator_in_cpp
-    m.def("object_to_list", [](py::object o) {
-        auto l = py::list();
-        for (auto item : o) {
-            l.append(item);
-        }
-        return l;
-    });
-
-    m.def("iterator_to_list", [](py::iterator it) {
-        auto l = py::list();
-        while (it != py::iterator::sentinel()) {
-            l.append(*it);
-            ++it;
-        }
-        return l;
-    });
-
-    // Make sure that py::iterator works with std algorithms
-    m.def("count_none", [](py::object o) {
-        return std::count_if(o.begin(), o.end(), [](py::handle h) { return h.is_none(); });
-    });
-
-    m.def("find_none", [](py::object o) {
-        auto it = std::find_if(o.begin(), o.end(), [](py::handle h) { return h.is_none(); });
-        return it->is_none();
-    });
-
-    m.def("count_nonzeros", [](py::dict d) {
-       return std::count_if(d.begin(), d.end(), [](std::pair<py::handle, py::handle> p) {
-           return p.second.cast<int>() != 0;
-       });
-    });
-
-    m.def("tuple_iterator", &test_random_access_iterator<py::tuple>);
-    m.def("list_iterator", &test_random_access_iterator<py::list>);
-    m.def("sequence_iterator", &test_random_access_iterator<py::sequence>);
-
-    // test_iterator_passthrough
-    // #181: iterator passthrough did not compile
-    m.def("iterator_passthrough", [](py::iterator s) -> py::iterator {
-        return py::make_iterator(std::begin(s), std::end(s));
-    });
-
-    // test_iterator_rvp
-    // #388: Can't make iterators via make_iterator() with different r/v policies
-    static std::vector<int> list = { 1, 2, 3 };
-    m.def("make_iterator_1", []() { return py::make_iterator<py::return_value_policy::copy>(list); });
-    m.def("make_iterator_2", []() { return py::make_iterator<py::return_value_policy::automatic>(list); });
-}
diff --git a/tmap/lib/pybind11/tests/test_sequences_and_iterators.py b/tmap/lib/pybind11/tests/test_sequences_and_iterators.py
deleted file mode 100644
index 640ca07..0000000
--- a/tmap/lib/pybind11/tests/test_sequences_and_iterators.py
+++ /dev/null
@@ -1,158 +0,0 @@
-import pytest
-from pybind11_tests import sequences_and_iterators as m
-from pybind11_tests import ConstructorStats
-
-
-def isclose(a, b, rel_tol=1e-05, abs_tol=0.0):
-    """Like math.isclose() from Python 3.5"""
-    return abs(a - b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)
-
-
-def allclose(a_list, b_list, rel_tol=1e-05, abs_tol=0.0):
-    return all(isclose(a, b, rel_tol=rel_tol, abs_tol=abs_tol) for a, b in zip(a_list, b_list))
-
-
-def test_generalized_iterators():
-    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero()) == [(1, 2), (3, 4)]
-    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero()) == [(1, 2)]
-    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero()) == []
-
-    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero_keys()) == [1, 3]
-    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero_keys()) == [1]
-    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero_keys()) == []
-
-    # __next__ must continue to raise StopIteration
-    it = m.IntPairs([(0, 0)]).nonzero()
-    for _ in range(3):
-        with pytest.raises(StopIteration):
-            next(it)
-
-    it = m.IntPairs([(0, 0)]).nonzero_keys()
-    for _ in range(3):
-        with pytest.raises(StopIteration):
-            next(it)
-
-
-def test_sequence():
-    cstats = ConstructorStats.get(m.Sequence)
-
-    s = m.Sequence(5)
-    assert cstats.values() == ['of size', '5']
-
-    assert "Sequence" in repr(s)
-    assert len(s) == 5
-    assert s[0] == 0 and s[3] == 0
-    assert 12.34 not in s
-    s[0], s[3] = 12.34, 56.78
-    assert 12.34 in s
-    assert isclose(s[0], 12.34) and isclose(s[3], 56.78)
-
-    rev = reversed(s)
-    assert cstats.values() == ['of size', '5']
-
-    rev2 = s[::-1]
-    assert cstats.values() == ['of size', '5']
-
-    it = iter(m.Sequence(0))
-    for _ in range(3):  # __next__ must continue to raise StopIteration
-        with pytest.raises(StopIteration):
-            next(it)
-    assert cstats.values() == ['of size', '0']
-
-    expected = [0, 56.78, 0, 0, 12.34]
-    assert allclose(rev, expected)
-    assert allclose(rev2, expected)
-    assert rev == rev2
-
-    rev[0::2] = m.Sequence([2.0, 2.0, 2.0])
-    assert cstats.values() == ['of size', '3', 'from std::vector']
-
-    assert allclose(rev, [2, 56.78, 2, 0, 2])
-
-    assert cstats.alive() == 4
-    del it
-    assert cstats.alive() == 3
-    del s
-    assert cstats.alive() == 2
-    del rev
-    assert cstats.alive() == 1
-    del rev2
-    assert cstats.alive() == 0
-
-    assert cstats.values() == []
-    assert cstats.default_constructions == 0
-    assert cstats.copy_constructions == 0
-    assert cstats.move_constructions >= 1
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-
-def test_map_iterator():
-    sm = m.StringMap({'hi': 'bye', 'black': 'white'})
-    assert sm['hi'] == 'bye'
-    assert len(sm) == 2
-    assert sm['black'] == 'white'
-
-    with pytest.raises(KeyError):
-        assert sm['orange']
-    sm['orange'] = 'banana'
-    assert sm['orange'] == 'banana'
-
-    expected = {'hi': 'bye', 'black': 'white', 'orange': 'banana'}
-    for k in sm:
-        assert sm[k] == expected[k]
-    for k, v in sm.items():
-        assert v == expected[k]
-
-    it = iter(m.StringMap({}))
-    for _ in range(3):  # __next__ must continue to raise StopIteration
-        with pytest.raises(StopIteration):
-            next(it)
-
-
-def test_python_iterator_in_cpp():
-    t = (1, 2, 3)
-    assert m.object_to_list(t) == [1, 2, 3]
-    assert m.object_to_list(iter(t)) == [1, 2, 3]
-    assert m.iterator_to_list(iter(t)) == [1, 2, 3]
-
-    with pytest.raises(TypeError) as excinfo:
-        m.object_to_list(1)
-    assert "object is not iterable" in str(excinfo.value)
-
-    with pytest.raises(TypeError) as excinfo:
-        m.iterator_to_list(1)
-    assert "incompatible function arguments" in str(excinfo.value)
-
-    def bad_next_call():
-        raise RuntimeError("py::iterator::advance() should propagate errors")
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.iterator_to_list(iter(bad_next_call, None))
-    assert str(excinfo.value) == "py::iterator::advance() should propagate errors"
-
-    l = [1, None, 0, None]
-    assert m.count_none(l) == 2
-    assert m.find_none(l) is True
-    assert m.count_nonzeros({"a": 0, "b": 1, "c": 2}) == 2
-
-    r = range(5)
-    assert all(m.tuple_iterator(tuple(r)))
-    assert all(m.list_iterator(list(r)))
-    assert all(m.sequence_iterator(r))
-
-
-def test_iterator_passthrough():
-    """#181: iterator passthrough did not compile"""
-    from pybind11_tests.sequences_and_iterators import iterator_passthrough
-
-    assert list(iterator_passthrough(iter([3, 5, 7, 9, 11, 13, 15]))) == [3, 5, 7, 9, 11, 13, 15]
-
-
-def test_iterator_rvp():
-    """#388: Can't make iterators via make_iterator() with different r/v policies """
-    import pybind11_tests.sequences_and_iterators as m
-
-    assert list(m.make_iterator_1()) == [1, 2, 3]
-    assert list(m.make_iterator_2()) == [1, 2, 3]
-    assert not isinstance(m.make_iterator_1(), type(m.make_iterator_2()))
diff --git a/tmap/lib/pybind11/tests/test_smart_ptr.cpp b/tmap/lib/pybind11/tests/test_smart_ptr.cpp
deleted file mode 100644
index dccb1e9..0000000
--- a/tmap/lib/pybind11/tests/test_smart_ptr.cpp
+++ /dev/null
@@ -1,270 +0,0 @@
-/*
-    tests/test_smart_ptr.cpp -- binding classes with custom reference counting,
-    implicit conversions between types
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#if defined(_MSC_VER) && _MSC_VER < 1910
-#  pragma warning(disable: 4702) // unreachable code in system header
-#endif
-
-#include "pybind11_tests.h"
-#include "object.h"
-
-// Make pybind aware of the ref-counted wrapper type (s):
-
-// ref<T> is a wrapper for 'Object' which uses intrusive reference counting
-// It is always possible to construct a ref<T> from an Object* pointer without
-// possible incosistencies, hence the 'true' argument at the end.
-PYBIND11_DECLARE_HOLDER_TYPE(T, ref<T>, true);
-// Make pybind11 aware of the non-standard getter member function
-namespace pybind11 { namespace detail {
-    template <typename T>
-    struct holder_helper<ref<T>> {
-        static const T *get(const ref<T> &p) { return p.get_ptr(); }
-    };
-}}
-
-// The following is not required anymore for std::shared_ptr, but it should compile without error:
-PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>);
-
-// This is just a wrapper around unique_ptr, but with extra fields to deliberately bloat up the
-// holder size to trigger the non-simple-layout internal instance layout for single inheritance with
-// large holder type:
-template <typename T> class huge_unique_ptr {
-    std::unique_ptr<T> ptr;
-    uint64_t padding[10];
-public:
-    huge_unique_ptr(T *p) : ptr(p) {};
-    T *get() { return ptr.get(); }
-};
-PYBIND11_DECLARE_HOLDER_TYPE(T, huge_unique_ptr<T>);
-
-// Simple custom holder that works like unique_ptr
-template <typename T>
-class custom_unique_ptr {
-    std::unique_ptr<T> impl;
-public:
-    custom_unique_ptr(T* p) : impl(p) { }
-    T* get() const { return impl.get(); }
-    T* release_ptr() { return impl.release(); }
-};
-PYBIND11_DECLARE_HOLDER_TYPE(T, custom_unique_ptr<T>);
-
-
-TEST_SUBMODULE(smart_ptr, m) {
-
-    // test_smart_ptr
-
-    // Object implementation in `object.h`
-    py::class_<Object, ref<Object>> obj(m, "Object");
-    obj.def("getRefCount", &Object::getRefCount);
-
-    // Custom object with builtin reference counting (see 'object.h' for the implementation)
-    class MyObject1 : public Object {
-    public:
-        MyObject1(int value) : value(value) { print_created(this, toString()); }
-        std::string toString() const { return "MyObject1[" + std::to_string(value) + "]"; }
-    protected:
-        virtual ~MyObject1() { print_destroyed(this); }
-    private:
-        int value;
-    };
-    py::class_<MyObject1, ref<MyObject1>>(m, "MyObject1", obj)
-        .def(py::init<int>());
-    py::implicitly_convertible<py::int_, MyObject1>();
-
-    m.def("make_object_1", []() -> Object * { return new MyObject1(1); });
-    m.def("make_object_2", []() -> ref<Object> { return new MyObject1(2); });
-    m.def("make_myobject1_1", []() -> MyObject1 * { return new MyObject1(4); });
-    m.def("make_myobject1_2", []() -> ref<MyObject1> { return new MyObject1(5); });
-    m.def("print_object_1", [](const Object *obj) { py::print(obj->toString()); });
-    m.def("print_object_2", [](ref<Object> obj) { py::print(obj->toString()); });
-    m.def("print_object_3", [](const ref<Object> &obj) { py::print(obj->toString()); });
-    m.def("print_object_4", [](const ref<Object> *obj) { py::print((*obj)->toString()); });
-    m.def("print_myobject1_1", [](const MyObject1 *obj) { py::print(obj->toString()); });
-    m.def("print_myobject1_2", [](ref<MyObject1> obj) { py::print(obj->toString()); });
-    m.def("print_myobject1_3", [](const ref<MyObject1> &obj) { py::print(obj->toString()); });
-    m.def("print_myobject1_4", [](const ref<MyObject1> *obj) { py::print((*obj)->toString()); });
-
-    // Expose constructor stats for the ref type
-    m.def("cstats_ref", &ConstructorStats::get<ref_tag>);
-
-
-    // Object managed by a std::shared_ptr<>
-    class MyObject2 {
-    public:
-        MyObject2(int value) : value(value) { print_created(this, toString()); }
-        std::string toString() const { return "MyObject2[" + std::to_string(value) + "]"; }
-        virtual ~MyObject2() { print_destroyed(this); }
-    private:
-        int value;
-    };
-    py::class_<MyObject2, std::shared_ptr<MyObject2>>(m, "MyObject2")
-        .def(py::init<int>());
-    m.def("make_myobject2_1", []() { return new MyObject2(6); });
-    m.def("make_myobject2_2", []() { return std::make_shared<MyObject2>(7); });
-    m.def("print_myobject2_1", [](const MyObject2 *obj) { py::print(obj->toString()); });
-    m.def("print_myobject2_2", [](std::shared_ptr<MyObject2> obj) { py::print(obj->toString()); });
-    m.def("print_myobject2_3", [](const std::shared_ptr<MyObject2> &obj) { py::print(obj->toString()); });
-    m.def("print_myobject2_4", [](const std::shared_ptr<MyObject2> *obj) { py::print((*obj)->toString()); });
-
-    // Object managed by a std::shared_ptr<>, additionally derives from std::enable_shared_from_this<>
-    class MyObject3 : public std::enable_shared_from_this<MyObject3> {
-    public:
-        MyObject3(int value) : value(value) { print_created(this, toString()); }
-        std::string toString() const { return "MyObject3[" + std::to_string(value) + "]"; }
-        virtual ~MyObject3() { print_destroyed(this); }
-    private:
-        int value;
-    };
-    py::class_<MyObject3, std::shared_ptr<MyObject3>>(m, "MyObject3")
-        .def(py::init<int>());
-    m.def("make_myobject3_1", []() { return new MyObject3(8); });
-    m.def("make_myobject3_2", []() { return std::make_shared<MyObject3>(9); });
-    m.def("print_myobject3_1", [](const MyObject3 *obj) { py::print(obj->toString()); });
-    m.def("print_myobject3_2", [](std::shared_ptr<MyObject3> obj) { py::print(obj->toString()); });
-    m.def("print_myobject3_3", [](const std::shared_ptr<MyObject3> &obj) { py::print(obj->toString()); });
-    m.def("print_myobject3_4", [](const std::shared_ptr<MyObject3> *obj) { py::print((*obj)->toString()); });
-
-    // test_smart_ptr_refcounting
-    m.def("test_object1_refcounting", []() {
-        ref<MyObject1> o = new MyObject1(0);
-        bool good = o->getRefCount() == 1;
-        py::object o2 = py::cast(o, py::return_value_policy::reference);
-        // always request (partial) ownership for objects with intrusive
-        // reference counting even when using the 'reference' RVP
-        good &= o->getRefCount() == 2;
-        return good;
-    });
-
-    // test_unique_nodelete
-    // Object with a private destructor
-    class MyObject4 {
-    public:
-        MyObject4(int value) : value{value} { print_created(this); }
-        int value;
-    private:
-        ~MyObject4() { print_destroyed(this); }
-    };
-    py::class_<MyObject4, std::unique_ptr<MyObject4, py::nodelete>>(m, "MyObject4")
-        .def(py::init<int>())
-        .def_readwrite("value", &MyObject4::value);
-
-    // test_large_holder
-    class MyObject5 { // managed by huge_unique_ptr
-    public:
-        MyObject5(int value) : value{value} { print_created(this); }
-        ~MyObject5() { print_destroyed(this); }
-        int value;
-    };
-    py::class_<MyObject5, huge_unique_ptr<MyObject5>>(m, "MyObject5")
-        .def(py::init<int>())
-        .def_readwrite("value", &MyObject5::value);
-
-    // test_shared_ptr_and_references
-    struct SharedPtrRef {
-        struct A {
-            A() { print_created(this); }
-            A(const A &) { print_copy_created(this); }
-            A(A &&) { print_move_created(this); }
-            ~A() { print_destroyed(this); }
-        };
-
-        A value = {};
-        std::shared_ptr<A> shared = std::make_shared<A>();
-    };
-    using A = SharedPtrRef::A;
-    py::class_<A, std::shared_ptr<A>>(m, "A");
-    py::class_<SharedPtrRef>(m, "SharedPtrRef")
-        .def(py::init<>())
-        .def_readonly("ref", &SharedPtrRef::value)
-        .def_property_readonly("copy", [](const SharedPtrRef &s) { return s.value; },
-                               py::return_value_policy::copy)
-        .def_readonly("holder_ref", &SharedPtrRef::shared)
-        .def_property_readonly("holder_copy", [](const SharedPtrRef &s) { return s.shared; },
-                               py::return_value_policy::copy)
-        .def("set_ref", [](SharedPtrRef &, const A &) { return true; })
-        .def("set_holder", [](SharedPtrRef &, std::shared_ptr<A>) { return true; });
-
-    // test_shared_ptr_from_this_and_references
-    struct SharedFromThisRef {
-        struct B : std::enable_shared_from_this<B> {
-            B() { print_created(this); }
-            B(const B &) : std::enable_shared_from_this<B>() { print_copy_created(this); }
-            B(B &&) : std::enable_shared_from_this<B>() { print_move_created(this); }
-            ~B() { print_destroyed(this); }
-        };
-
-        B value = {};
-        std::shared_ptr<B> shared = std::make_shared<B>();
-    };
-    using B = SharedFromThisRef::B;
-    py::class_<B, std::shared_ptr<B>>(m, "B");
-    py::class_<SharedFromThisRef>(m, "SharedFromThisRef")
-        .def(py::init<>())
-        .def_readonly("bad_wp", &SharedFromThisRef::value)
-        .def_property_readonly("ref", [](const SharedFromThisRef &s) -> const B & { return *s.shared; })
-        .def_property_readonly("copy", [](const SharedFromThisRef &s) { return s.value; },
-                               py::return_value_policy::copy)
-        .def_readonly("holder_ref", &SharedFromThisRef::shared)
-        .def_property_readonly("holder_copy", [](const SharedFromThisRef &s) { return s.shared; },
-                               py::return_value_policy::copy)
-        .def("set_ref", [](SharedFromThisRef &, const B &) { return true; })
-        .def("set_holder", [](SharedFromThisRef &, std::shared_ptr<B>) { return true; });
-
-    // Issue #865: shared_from_this doesn't work with virtual inheritance
-    struct SharedFromThisVBase : std::enable_shared_from_this<SharedFromThisVBase> {
-        virtual ~SharedFromThisVBase() = default;
-    };
-    struct SharedFromThisVirt : virtual SharedFromThisVBase {};
-    static std::shared_ptr<SharedFromThisVirt> sft(new SharedFromThisVirt());
-    py::class_<SharedFromThisVirt, std::shared_ptr<SharedFromThisVirt>>(m, "SharedFromThisVirt")
-        .def_static("get", []() { return sft.get(); });
-
-    // test_move_only_holder
-    struct C {
-        C() { print_created(this); }
-        ~C() { print_destroyed(this); }
-    };
-    py::class_<C, custom_unique_ptr<C>>(m, "TypeWithMoveOnlyHolder")
-        .def_static("make", []() { return custom_unique_ptr<C>(new C); });
-
-    // test_smart_ptr_from_default
-    struct HeldByDefaultHolder { };
-    py::class_<HeldByDefaultHolder>(m, "HeldByDefaultHolder")
-        .def(py::init<>())
-        .def_static("load_shared_ptr", [](std::shared_ptr<HeldByDefaultHolder>) {});
-
-    // test_shared_ptr_gc
-    // #187: issue involving std::shared_ptr<> return value policy & garbage collection
-    struct ElementBase { virtual void foo() { } /* Force creation of virtual table */ };
-    py::class_<ElementBase, std::shared_ptr<ElementBase>>(m, "ElementBase");
-
-    struct ElementA : ElementBase {
-        ElementA(int v) : v(v) { }
-        int value() { return v; }
-        int v;
-    };
-    py::class_<ElementA, ElementBase, std::shared_ptr<ElementA>>(m, "ElementA")
-        .def(py::init<int>())
-        .def("value", &ElementA::value);
-
-    struct ElementList {
-        void add(std::shared_ptr<ElementBase> e) { l.push_back(e); }
-        std::vector<std::shared_ptr<ElementBase>> l;
-    };
-    py::class_<ElementList, std::shared_ptr<ElementList>>(m, "ElementList")
-        .def(py::init<>())
-        .def("add", &ElementList::add)
-        .def("get", [](ElementList &el) {
-            py::list list;
-            for (auto &e : el.l)
-                list.append(py::cast(e));
-            return list;
-        });
-}
diff --git a/tmap/lib/pybind11/tests/test_smart_ptr.py b/tmap/lib/pybind11/tests/test_smart_ptr.py
deleted file mode 100644
index 4dfe003..0000000
--- a/tmap/lib/pybind11/tests/test_smart_ptr.py
+++ /dev/null
@@ -1,220 +0,0 @@
-import pytest
-from pybind11_tests import smart_ptr as m
-from pybind11_tests import ConstructorStats
-
-
-def test_smart_ptr(capture):
-    # Object1
-    for i, o in enumerate([m.make_object_1(), m.make_object_2(), m.MyObject1(3)], start=1):
-        assert o.getRefCount() == 1
-        with capture:
-            m.print_object_1(o)
-            m.print_object_2(o)
-            m.print_object_3(o)
-            m.print_object_4(o)
-        assert capture == "MyObject1[{i}]\n".format(i=i) * 4
-
-    for i, o in enumerate([m.make_myobject1_1(), m.make_myobject1_2(), m.MyObject1(6), 7],
-                          start=4):
-        print(o)
-        with capture:
-            if not isinstance(o, int):
-                m.print_object_1(o)
-                m.print_object_2(o)
-                m.print_object_3(o)
-                m.print_object_4(o)
-            m.print_myobject1_1(o)
-            m.print_myobject1_2(o)
-            m.print_myobject1_3(o)
-            m.print_myobject1_4(o)
-        assert capture == "MyObject1[{i}]\n".format(i=i) * (4 if isinstance(o, int) else 8)
-
-    cstats = ConstructorStats.get(m.MyObject1)
-    assert cstats.alive() == 0
-    expected_values = ['MyObject1[{}]'.format(i) for i in range(1, 7)] + ['MyObject1[7]'] * 4
-    assert cstats.values() == expected_values
-    assert cstats.default_constructions == 0
-    assert cstats.copy_constructions == 0
-    # assert cstats.move_constructions >= 0 # Doesn't invoke any
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-    # Object2
-    for i, o in zip([8, 6, 7], [m.MyObject2(8), m.make_myobject2_1(), m.make_myobject2_2()]):
-        print(o)
-        with capture:
-            m.print_myobject2_1(o)
-            m.print_myobject2_2(o)
-            m.print_myobject2_3(o)
-            m.print_myobject2_4(o)
-        assert capture == "MyObject2[{i}]\n".format(i=i) * 4
-
-    cstats = ConstructorStats.get(m.MyObject2)
-    assert cstats.alive() == 1
-    o = None
-    assert cstats.alive() == 0
-    assert cstats.values() == ['MyObject2[8]', 'MyObject2[6]', 'MyObject2[7]']
-    assert cstats.default_constructions == 0
-    assert cstats.copy_constructions == 0
-    # assert cstats.move_constructions >= 0 # Doesn't invoke any
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-    # Object3
-    for i, o in zip([9, 8, 9], [m.MyObject3(9), m.make_myobject3_1(), m.make_myobject3_2()]):
-        print(o)
-        with capture:
-            m.print_myobject3_1(o)
-            m.print_myobject3_2(o)
-            m.print_myobject3_3(o)
-            m.print_myobject3_4(o)
-        assert capture == "MyObject3[{i}]\n".format(i=i) * 4
-
-    cstats = ConstructorStats.get(m.MyObject3)
-    assert cstats.alive() == 1
-    o = None
-    assert cstats.alive() == 0
-    assert cstats.values() == ['MyObject3[9]', 'MyObject3[8]', 'MyObject3[9]']
-    assert cstats.default_constructions == 0
-    assert cstats.copy_constructions == 0
-    # assert cstats.move_constructions >= 0 # Doesn't invoke any
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-    # Object
-    cstats = ConstructorStats.get(m.Object)
-    assert cstats.alive() == 0
-    assert cstats.values() == []
-    assert cstats.default_constructions == 10
-    assert cstats.copy_constructions == 0
-    # assert cstats.move_constructions >= 0 # Doesn't invoke any
-    assert cstats.copy_assignments == 0
-    assert cstats.move_assignments == 0
-
-    # ref<>
-    cstats = m.cstats_ref()
-    assert cstats.alive() == 0
-    assert cstats.values() == ['from pointer'] * 10
-    assert cstats.default_constructions == 30
-    assert cstats.copy_constructions == 12
-    # assert cstats.move_constructions >= 0 # Doesn't invoke any
-    assert cstats.copy_assignments == 30
-    assert cstats.move_assignments == 0
-
-
-def test_smart_ptr_refcounting():
-    assert m.test_object1_refcounting()
-
-
-def test_unique_nodelete():
-    o = m.MyObject4(23)
-    assert o.value == 23
-    cstats = ConstructorStats.get(m.MyObject4)
-    assert cstats.alive() == 1
-    del o
-    assert cstats.alive() == 1  # Leak, but that's intentional
-
-
-def test_large_holder():
-    o = m.MyObject5(5)
-    assert o.value == 5
-    cstats = ConstructorStats.get(m.MyObject5)
-    assert cstats.alive() == 1
-    del o
-    assert cstats.alive() == 0
-
-
-def test_shared_ptr_and_references():
-    s = m.SharedPtrRef()
-    stats = ConstructorStats.get(m.A)
-    assert stats.alive() == 2
-
-    ref = s.ref  # init_holder_helper(holder_ptr=false, owned=false)
-    assert stats.alive() == 2
-    assert s.set_ref(ref)
-    with pytest.raises(RuntimeError) as excinfo:
-        assert s.set_holder(ref)
-    assert "Unable to cast from non-held to held instance" in str(excinfo.value)
-
-    copy = s.copy  # init_holder_helper(holder_ptr=false, owned=true)
-    assert stats.alive() == 3
-    assert s.set_ref(copy)
-    assert s.set_holder(copy)
-
-    holder_ref = s.holder_ref  # init_holder_helper(holder_ptr=true, owned=false)
-    assert stats.alive() == 3
-    assert s.set_ref(holder_ref)
-    assert s.set_holder(holder_ref)
-
-    holder_copy = s.holder_copy  # init_holder_helper(holder_ptr=true, owned=true)
-    assert stats.alive() == 3
-    assert s.set_ref(holder_copy)
-    assert s.set_holder(holder_copy)
-
-    del ref, copy, holder_ref, holder_copy, s
-    assert stats.alive() == 0
-
-
-def test_shared_ptr_from_this_and_references():
-    s = m.SharedFromThisRef()
-    stats = ConstructorStats.get(m.B)
-    assert stats.alive() == 2
-
-    ref = s.ref  # init_holder_helper(holder_ptr=false, owned=false, bad_wp=false)
-    assert stats.alive() == 2
-    assert s.set_ref(ref)
-    assert s.set_holder(ref)  # std::enable_shared_from_this can create a holder from a reference
-
-    bad_wp = s.bad_wp  # init_holder_helper(holder_ptr=false, owned=false, bad_wp=true)
-    assert stats.alive() == 2
-    assert s.set_ref(bad_wp)
-    with pytest.raises(RuntimeError) as excinfo:
-        assert s.set_holder(bad_wp)
-    assert "Unable to cast from non-held to held instance" in str(excinfo.value)
-
-    copy = s.copy  # init_holder_helper(holder_ptr=false, owned=true, bad_wp=false)
-    assert stats.alive() == 3
-    assert s.set_ref(copy)
-    assert s.set_holder(copy)
-
-    holder_ref = s.holder_ref  # init_holder_helper(holder_ptr=true, owned=false, bad_wp=false)
-    assert stats.alive() == 3
-    assert s.set_ref(holder_ref)
-    assert s.set_holder(holder_ref)
-
-    holder_copy = s.holder_copy  # init_holder_helper(holder_ptr=true, owned=true, bad_wp=false)
-    assert stats.alive() == 3
-    assert s.set_ref(holder_copy)
-    assert s.set_holder(holder_copy)
-
-    del ref, bad_wp, copy, holder_ref, holder_copy, s
-    assert stats.alive() == 0
-
-    z = m.SharedFromThisVirt.get()
-    y = m.SharedFromThisVirt.get()
-    assert y is z
-
-
-def test_move_only_holder():
-    a = m.TypeWithMoveOnlyHolder.make()
-    stats = ConstructorStats.get(m.TypeWithMoveOnlyHolder)
-    assert stats.alive() == 1
-    del a
-    assert stats.alive() == 0
-
-
-def test_smart_ptr_from_default():
-    instance = m.HeldByDefaultHolder()
-    with pytest.raises(RuntimeError) as excinfo:
-        m.HeldByDefaultHolder.load_shared_ptr(instance)
-    assert "Unable to load a custom holder type from a default-holder instance" in str(excinfo)
-
-
-def test_shared_ptr_gc():
-    """#187: issue involving std::shared_ptr<> return value policy & garbage collection"""
-    el = m.ElementList()
-    for i in range(10):
-        el.add(m.ElementA(i))
-    pytest.gc_collect()
-    for i, v in enumerate(el.get()):
-        assert i == v.value()
diff --git a/tmap/lib/pybind11/tests/test_stl.cpp b/tmap/lib/pybind11/tests/test_stl.cpp
deleted file mode 100644
index 0746fb4..0000000
--- a/tmap/lib/pybind11/tests/test_stl.cpp
+++ /dev/null
@@ -1,233 +0,0 @@
-/*
-    tests/test_stl.cpp -- STL type casters
-
-    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include <pybind11/stl.h>
-
-// Test with `std::variant` in C++17 mode, or with `boost::variant` in C++11/14
-#if PYBIND11_HAS_VARIANT
-using std::variant;
-#elif defined(PYBIND11_TEST_BOOST) && (!defined(_MSC_VER) || _MSC_VER >= 1910)
-#  include <boost/variant.hpp>
-#  define PYBIND11_HAS_VARIANT 1
-using boost::variant;
-
-namespace pybind11 { namespace detail {
-template <typename... Ts>
-struct type_caster<boost::variant<Ts...>> : variant_caster<boost::variant<Ts...>> {};
-
-template <>
-struct visit_helper<boost::variant> {
-    template <typename... Args>
-    static auto call(Args &&...args) -> decltype(boost::apply_visitor(args...)) {
-        return boost::apply_visitor(args...);
-    }
-};
-}} // namespace pybind11::detail
-#endif
-
-/// Issue #528: templated constructor
-struct TplCtorClass {
-    template <typename T> TplCtorClass(const T &) { }
-    bool operator==(const TplCtorClass &) const { return true; }
-};
-
-namespace std {
-    template <>
-    struct hash<TplCtorClass> { size_t operator()(const TplCtorClass &) const { return 0; } };
-}
-
-
-TEST_SUBMODULE(stl, m) {
-    // test_vector
-    m.def("cast_vector", []() { return std::vector<int>{1}; });
-    m.def("load_vector", [](const std::vector<int> &v) { return v.at(0) == 1 && v.at(1) == 2; });
-    // Unnumbered regression (caused by #936): pointers to stl containers aren't castable
-    static std::vector<RValueCaster> lvv{2};
-    m.def("cast_ptr_vector", []() { return &lvv; });
-
-    // test_array
-    m.def("cast_array", []() { return std::array<int, 2> {{1 , 2}}; });
-    m.def("load_array", [](const std::array<int, 2> &a) { return a[0] == 1 && a[1] == 2; });
-
-    // test_valarray
-    m.def("cast_valarray", []() { return std::valarray<int>{1, 4, 9}; });
-    m.def("load_valarray", [](const std::valarray<int>& v) {
-        return v.size() == 3 && v[0] == 1 && v[1] == 4 && v[2] == 9;
-    });
-
-    // test_map
-    m.def("cast_map", []() { return std::map<std::string, std::string>{{"key", "value"}}; });
-    m.def("load_map", [](const std::map<std::string, std::string> &map) {
-        return map.at("key") == "value" && map.at("key2") == "value2";
-    });
-
-    // test_set
-    m.def("cast_set", []() { return std::set<std::string>{"key1", "key2"}; });
-    m.def("load_set", [](const std::set<std::string> &set) {
-        return set.count("key1") && set.count("key2") && set.count("key3");
-    });
-
-    // test_recursive_casting
-    m.def("cast_rv_vector", []() { return std::vector<RValueCaster>{2}; });
-    m.def("cast_rv_array", []() { return std::array<RValueCaster, 3>(); });
-    // NB: map and set keys are `const`, so while we technically do move them (as `const Type &&`),
-    // casters don't typically do anything with that, which means they fall to the `const Type &`
-    // caster.
-    m.def("cast_rv_map", []() { return std::unordered_map<std::string, RValueCaster>{{"a", RValueCaster{}}}; });
-    m.def("cast_rv_nested", []() {
-        std::vector<std::array<std::list<std::unordered_map<std::string, RValueCaster>>, 2>> v;
-        v.emplace_back(); // add an array
-        v.back()[0].emplace_back(); // add a map to the array
-        v.back()[0].back().emplace("b", RValueCaster{});
-        v.back()[0].back().emplace("c", RValueCaster{});
-        v.back()[1].emplace_back(); // add a map to the array
-        v.back()[1].back().emplace("a", RValueCaster{});
-        return v;
-    });
-    static std::array<RValueCaster, 2> lva;
-    static std::unordered_map<std::string, RValueCaster> lvm{{"a", RValueCaster{}}, {"b", RValueCaster{}}};
-    static std::unordered_map<std::string, std::vector<std::list<std::array<RValueCaster, 2>>>> lvn;
-    lvn["a"].emplace_back(); // add a list
-    lvn["a"].back().emplace_back(); // add an array
-    lvn["a"].emplace_back(); // another list
-    lvn["a"].back().emplace_back(); // add an array
-    lvn["b"].emplace_back(); // add a list
-    lvn["b"].back().emplace_back(); // add an array
-    lvn["b"].back().emplace_back(); // add another array
-    m.def("cast_lv_vector", []() -> const decltype(lvv) & { return lvv; });
-    m.def("cast_lv_array", []() -> const decltype(lva) & { return lva; });
-    m.def("cast_lv_map", []() -> const decltype(lvm) & { return lvm; });
-    m.def("cast_lv_nested", []() -> const decltype(lvn) & { return lvn; });
-    // #853:
-    m.def("cast_unique_ptr_vector", []() {
-        std::vector<std::unique_ptr<UserType>> v;
-        v.emplace_back(new UserType{7});
-        v.emplace_back(new UserType{42});
-        return v;
-    });
-
-    // test_move_out_container
-    struct MoveOutContainer {
-        struct Value { int value; };
-        std::list<Value> move_list() const { return {{0}, {1}, {2}}; }
-    };
-    py::class_<MoveOutContainer::Value>(m, "MoveOutContainerValue")
-        .def_readonly("value", &MoveOutContainer::Value::value);
-    py::class_<MoveOutContainer>(m, "MoveOutContainer")
-        .def(py::init<>())
-        .def_property_readonly("move_list", &MoveOutContainer::move_list);
-
-    // Class that can be move- and copy-constructed, but not assigned
-    struct NoAssign {
-        int value;
-
-        explicit NoAssign(int value = 0) : value(value) { }
-        NoAssign(const NoAssign &) = default;
-        NoAssign(NoAssign &&) = default;
-
-        NoAssign &operator=(const NoAssign &) = delete;
-        NoAssign &operator=(NoAssign &&) = delete;
-    };
-    py::class_<NoAssign>(m, "NoAssign", "Class with no C++ assignment operators")
-        .def(py::init<>())
-        .def(py::init<int>());
-
-#ifdef PYBIND11_HAS_OPTIONAL
-    // test_optional
-    m.attr("has_optional") = true;
-
-    using opt_int = std::optional<int>;
-    using opt_no_assign = std::optional<NoAssign>;
-    m.def("double_or_zero", [](const opt_int& x) -> int {
-        return x.value_or(0) * 2;
-    });
-    m.def("half_or_none", [](int x) -> opt_int {
-        return x ? opt_int(x / 2) : opt_int();
-    });
-    m.def("test_nullopt", [](opt_int x) {
-        return x.value_or(42);
-    }, py::arg_v("x", std::nullopt, "None"));
-    m.def("test_no_assign", [](const opt_no_assign &x) {
-        return x ? x->value : 42;
-    }, py::arg_v("x", std::nullopt, "None"));
-
-    m.def("nodefer_none_optional", [](std::optional<int>) { return true; });
-    m.def("nodefer_none_optional", [](py::none) { return false; });
-#endif
-
-#ifdef PYBIND11_HAS_EXP_OPTIONAL
-    // test_exp_optional
-    m.attr("has_exp_optional") = true;
-
-    using exp_opt_int = std::experimental::optional<int>;
-    using exp_opt_no_assign = std::experimental::optional<NoAssign>;
-    m.def("double_or_zero_exp", [](const exp_opt_int& x) -> int {
-        return x.value_or(0) * 2;
-    });
-    m.def("half_or_none_exp", [](int x) -> exp_opt_int {
-        return x ? exp_opt_int(x / 2) : exp_opt_int();
-    });
-    m.def("test_nullopt_exp", [](exp_opt_int x) {
-        return x.value_or(42);
-    }, py::arg_v("x", std::experimental::nullopt, "None"));
-    m.def("test_no_assign_exp", [](const exp_opt_no_assign &x) {
-        return x ? x->value : 42;
-    }, py::arg_v("x", std::experimental::nullopt, "None"));
-#endif
-
-#ifdef PYBIND11_HAS_VARIANT
-    static_assert(std::is_same<py::detail::variant_caster_visitor::result_type, py::handle>::value,
-                  "visitor::result_type is required by boost::variant in C++11 mode");
-
-    struct visitor {
-        using result_type = const char *;
-
-        result_type operator()(int) { return "int"; }
-        result_type operator()(std::string) { return "std::string"; }
-        result_type operator()(double) { return "double"; }
-        result_type operator()(std::nullptr_t) { return "std::nullptr_t"; }
-    };
-
-    // test_variant
-    m.def("load_variant", [](variant<int, std::string, double, std::nullptr_t> v) {
-        return py::detail::visit_helper<variant>::call(visitor(), v);
-    });
-    m.def("load_variant_2pass", [](variant<double, int> v) {
-        return py::detail::visit_helper<variant>::call(visitor(), v);
-    });
-    m.def("cast_variant", []() {
-        using V = variant<int, std::string>;
-        return py::make_tuple(V(5), V("Hello"));
-    });
-#endif
-
-    // #528: templated constructor
-    // (no python tests: the test here is that this compiles)
-    m.def("tpl_ctor_vector", [](std::vector<TplCtorClass> &) {});
-    m.def("tpl_ctor_map", [](std::unordered_map<TplCtorClass, TplCtorClass> &) {});
-    m.def("tpl_ctor_set", [](std::unordered_set<TplCtorClass> &) {});
-#if defined(PYBIND11_HAS_OPTIONAL)
-    m.def("tpl_constr_optional", [](std::optional<TplCtorClass> &) {});
-#elif defined(PYBIND11_HAS_EXP_OPTIONAL)
-    m.def("tpl_constr_optional", [](std::experimental::optional<TplCtorClass> &) {});
-#endif
-
-    // test_vec_of_reference_wrapper
-    // #171: Can't return STL structures containing reference wrapper
-    m.def("return_vec_of_reference_wrapper", [](std::reference_wrapper<UserType> p4) {
-        static UserType p1{1}, p2{2}, p3{3};
-        return std::vector<std::reference_wrapper<UserType>> {
-            std::ref(p1), std::ref(p2), std::ref(p3), p4
-        };
-    });
-
-    // test_stl_pass_by_pointer
-    m.def("stl_pass_by_pointer", [](std::vector<int>* v) { return *v; }, "v"_a=nullptr);
-}
diff --git a/tmap/lib/pybind11/tests/test_stl.py b/tmap/lib/pybind11/tests/test_stl.py
deleted file mode 100644
index c2fa7db..0000000
--- a/tmap/lib/pybind11/tests/test_stl.py
+++ /dev/null
@@ -1,178 +0,0 @@
-import pytest
-
-from pybind11_tests import stl as m
-from pybind11_tests import UserType
-
-
-def test_vector(doc):
-    """std::vector <-> list"""
-    l = m.cast_vector()
-    assert l == [1]
-    l.append(2)
-    assert m.load_vector(l)
-    assert m.load_vector(tuple(l))
-
-    assert doc(m.cast_vector) == "cast_vector() -> List[int]"
-    assert doc(m.load_vector) == "load_vector(arg0: List[int]) -> bool"
-
-    # Test regression caused by 936: pointers to stl containers weren't castable
-    assert m.cast_ptr_vector() == ["lvalue", "lvalue"]
-
-
-def test_array(doc):
-    """std::array <-> list"""
-    l = m.cast_array()
-    assert l == [1, 2]
-    assert m.load_array(l)
-
-    assert doc(m.cast_array) == "cast_array() -> List[int[2]]"
-    assert doc(m.load_array) == "load_array(arg0: List[int[2]]) -> bool"
-
-
-def test_valarray(doc):
-    """std::valarray <-> list"""
-    l = m.cast_valarray()
-    assert l == [1, 4, 9]
-    assert m.load_valarray(l)
-
-    assert doc(m.cast_valarray) == "cast_valarray() -> List[int]"
-    assert doc(m.load_valarray) == "load_valarray(arg0: List[int]) -> bool"
-
-
-def test_map(doc):
-    """std::map <-> dict"""
-    d = m.cast_map()
-    assert d == {"key": "value"}
-    d["key2"] = "value2"
-    assert m.load_map(d)
-
-    assert doc(m.cast_map) == "cast_map() -> Dict[str, str]"
-    assert doc(m.load_map) == "load_map(arg0: Dict[str, str]) -> bool"
-
-
-def test_set(doc):
-    """std::set <-> set"""
-    s = m.cast_set()
-    assert s == {"key1", "key2"}
-    s.add("key3")
-    assert m.load_set(s)
-
-    assert doc(m.cast_set) == "cast_set() -> Set[str]"
-    assert doc(m.load_set) == "load_set(arg0: Set[str]) -> bool"
-
-
-def test_recursive_casting():
-    """Tests that stl casters preserve lvalue/rvalue context for container values"""
-    assert m.cast_rv_vector() == ["rvalue", "rvalue"]
-    assert m.cast_lv_vector() == ["lvalue", "lvalue"]
-    assert m.cast_rv_array() == ["rvalue", "rvalue", "rvalue"]
-    assert m.cast_lv_array() == ["lvalue", "lvalue"]
-    assert m.cast_rv_map() == {"a": "rvalue"}
-    assert m.cast_lv_map() == {"a": "lvalue", "b": "lvalue"}
-    assert m.cast_rv_nested() == [[[{"b": "rvalue", "c": "rvalue"}], [{"a": "rvalue"}]]]
-    assert m.cast_lv_nested() == {
-        "a": [[["lvalue", "lvalue"]], [["lvalue", "lvalue"]]],
-        "b": [[["lvalue", "lvalue"], ["lvalue", "lvalue"]]]
-    }
-
-    # Issue #853 test case:
-    z = m.cast_unique_ptr_vector()
-    assert z[0].value == 7 and z[1].value == 42
-
-
-def test_move_out_container():
-    """Properties use the `reference_internal` policy by default. If the underlying function
-    returns an rvalue, the policy is automatically changed to `move` to avoid referencing
-    a temporary. In case the return value is a container of user-defined types, the policy
-    also needs to be applied to the elements, not just the container."""
-    c = m.MoveOutContainer()
-    moved_out_list = c.move_list
-    assert [x.value for x in moved_out_list] == [0, 1, 2]
-
-
-@pytest.mark.skipif(not hasattr(m, "has_optional"), reason='no <optional>')
-def test_optional():
-    assert m.double_or_zero(None) == 0
-    assert m.double_or_zero(42) == 84
-    pytest.raises(TypeError, m.double_or_zero, 'foo')
-
-    assert m.half_or_none(0) is None
-    assert m.half_or_none(42) == 21
-    pytest.raises(TypeError, m.half_or_none, 'foo')
-
-    assert m.test_nullopt() == 42
-    assert m.test_nullopt(None) == 42
-    assert m.test_nullopt(42) == 42
-    assert m.test_nullopt(43) == 43
-
-    assert m.test_no_assign() == 42
-    assert m.test_no_assign(None) == 42
-    assert m.test_no_assign(m.NoAssign(43)) == 43
-    pytest.raises(TypeError, m.test_no_assign, 43)
-
-    assert m.nodefer_none_optional(None)
-
-
-@pytest.mark.skipif(not hasattr(m, "has_exp_optional"), reason='no <experimental/optional>')
-def test_exp_optional():
-    assert m.double_or_zero_exp(None) == 0
-    assert m.double_or_zero_exp(42) == 84
-    pytest.raises(TypeError, m.double_or_zero_exp, 'foo')
-
-    assert m.half_or_none_exp(0) is None
-    assert m.half_or_none_exp(42) == 21
-    pytest.raises(TypeError, m.half_or_none_exp, 'foo')
-
-    assert m.test_nullopt_exp() == 42
-    assert m.test_nullopt_exp(None) == 42
-    assert m.test_nullopt_exp(42) == 42
-    assert m.test_nullopt_exp(43) == 43
-
-    assert m.test_no_assign_exp() == 42
-    assert m.test_no_assign_exp(None) == 42
-    assert m.test_no_assign_exp(m.NoAssign(43)) == 43
-    pytest.raises(TypeError, m.test_no_assign_exp, 43)
-
-
-@pytest.mark.skipif(not hasattr(m, "load_variant"), reason='no <variant>')
-def test_variant(doc):
-    assert m.load_variant(1) == "int"
-    assert m.load_variant("1") == "std::string"
-    assert m.load_variant(1.0) == "double"
-    assert m.load_variant(None) == "std::nullptr_t"
-
-    assert m.load_variant_2pass(1) == "int"
-    assert m.load_variant_2pass(1.0) == "double"
-
-    assert m.cast_variant() == (5, "Hello")
-
-    assert doc(m.load_variant) == "load_variant(arg0: Union[int, str, float, None]) -> str"
-
-
-def test_vec_of_reference_wrapper():
-    """#171: Can't return reference wrappers (or STL structures containing them)"""
-    assert str(m.return_vec_of_reference_wrapper(UserType(4))) == \
-        "[UserType(1), UserType(2), UserType(3), UserType(4)]"
-
-
-def test_stl_pass_by_pointer(msg):
-    """Passing nullptr or None to an STL container pointer is not expected to work"""
-    with pytest.raises(TypeError) as excinfo:
-        m.stl_pass_by_pointer()  # default value is `nullptr`
-    assert msg(excinfo.value) == """
-        stl_pass_by_pointer(): incompatible function arguments. The following argument types are supported:
-            1. (v: List[int]=None) -> List[int]
-
-        Invoked with:
-    """  # noqa: E501 line too long
-
-    with pytest.raises(TypeError) as excinfo:
-        m.stl_pass_by_pointer(None)
-    assert msg(excinfo.value) == """
-        stl_pass_by_pointer(): incompatible function arguments. The following argument types are supported:
-            1. (v: List[int]=None) -> List[int]
-
-        Invoked with: None
-    """  # noqa: E501 line too long
-
-    assert m.stl_pass_by_pointer([1, 2, 3]) == [1, 2, 3]
diff --git a/tmap/lib/pybind11/tests/test_stl_binders.cpp b/tmap/lib/pybind11/tests/test_stl_binders.cpp
deleted file mode 100644
index 2df6ca0..0000000
--- a/tmap/lib/pybind11/tests/test_stl_binders.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
-    tests/test_stl_binders.cpp -- Usage of stl_binders functions
-
-    Copyright (c) 2016 Sergey Lyskov
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-
-#include <pybind11/stl_bind.h>
-#include <pybind11/numpy.h>
-#include <map>
-#include <deque>
-#include <unordered_map>
-
-class El {
-public:
-    El() = delete;
-    El(int v) : a(v) { }
-
-    int a;
-};
-
-std::ostream & operator<<(std::ostream &s, El const&v) {
-    s << "El{" << v.a << '}';
-    return s;
-}
-
-/// Issue #487: binding std::vector<E> with E non-copyable
-class E_nc {
-public:
-    explicit E_nc(int i) : value{i} {}
-    E_nc(const E_nc &) = delete;
-    E_nc &operator=(const E_nc &) = delete;
-    E_nc(E_nc &&) = default;
-    E_nc &operator=(E_nc &&) = default;
-
-    int value;
-};
-
-template <class Container> Container *one_to_n(int n) {
-    auto v = new Container();
-    for (int i = 1; i <= n; i++)
-        v->emplace_back(i);
-    return v;
-}
-
-template <class Map> Map *times_ten(int n) {
-    auto m = new Map();
-    for (int i = 1; i <= n; i++)
-        m->emplace(int(i), E_nc(10*i));
-    return m;
-}
-
-TEST_SUBMODULE(stl_binders, m) {
-
-    // test_vector_int
-    py::bind_vector<std::vector<unsigned int>>(m, "VectorInt", py::buffer_protocol());
-
-    // test_vector_bool
-    py::bind_vector<std::vector<bool>>(m, "VectorBool");
-
-    // test_vector_custom
-    py::class_<El>(m, "El")
-        .def(py::init<int>());
-    py::bind_vector<std::vector<El>>(m, "VectorEl");
-    py::bind_vector<std::vector<std::vector<El>>>(m, "VectorVectorEl");
-
-    // test_map_string_double
-    py::bind_map<std::map<std::string, double>>(m, "MapStringDouble");
-    py::bind_map<std::unordered_map<std::string, double>>(m, "UnorderedMapStringDouble");
-
-    // test_map_string_double_const
-    py::bind_map<std::map<std::string, double const>>(m, "MapStringDoubleConst");
-    py::bind_map<std::unordered_map<std::string, double const>>(m, "UnorderedMapStringDoubleConst");
-
-    py::class_<E_nc>(m, "ENC")
-        .def(py::init<int>())
-        .def_readwrite("value", &E_nc::value);
-
-    // test_noncopyable_containers
-    py::bind_vector<std::vector<E_nc>>(m, "VectorENC");
-    m.def("get_vnc", &one_to_n<std::vector<E_nc>>, py::return_value_policy::reference);
-    py::bind_vector<std::deque<E_nc>>(m, "DequeENC");
-    m.def("get_dnc", &one_to_n<std::deque<E_nc>>, py::return_value_policy::reference);
-    py::bind_map<std::map<int, E_nc>>(m, "MapENC");
-    m.def("get_mnc", &times_ten<std::map<int, E_nc>>, py::return_value_policy::reference);
-    py::bind_map<std::unordered_map<int, E_nc>>(m, "UmapENC");
-    m.def("get_umnc", &times_ten<std::unordered_map<int, E_nc>>, py::return_value_policy::reference);
-
-    // test_vector_buffer
-    py::bind_vector<std::vector<unsigned char>>(m, "VectorUChar", py::buffer_protocol());
-    // no dtype declared for this version:
-    struct VUndeclStruct { bool w; uint32_t x; double y; bool z; };
-    m.def("create_undeclstruct", [m] () mutable {
-        py::bind_vector<std::vector<VUndeclStruct>>(m, "VectorUndeclStruct", py::buffer_protocol());
-    });
-
-    // The rest depends on numpy:
-    try { py::module::import("numpy"); }
-    catch (...) { return; }
-
-    // test_vector_buffer_numpy
-    struct VStruct { bool w; uint32_t x; double y; bool z; };
-    PYBIND11_NUMPY_DTYPE(VStruct, w, x, y, z);
-    py::class_<VStruct>(m, "VStruct").def_readwrite("x", &VStruct::x);
-    py::bind_vector<std::vector<VStruct>>(m, "VectorStruct", py::buffer_protocol());
-    m.def("get_vectorstruct", [] {return std::vector<VStruct> {{0, 5, 3.0, 1}, {1, 30, -1e4, 0}};});
-}
diff --git a/tmap/lib/pybind11/tests/test_stl_binders.py b/tmap/lib/pybind11/tests/test_stl_binders.py
deleted file mode 100644
index 7496d05..0000000
--- a/tmap/lib/pybind11/tests/test_stl_binders.py
+++ /dev/null
@@ -1,181 +0,0 @@
-import pytest
-import sys
-from pybind11_tests import stl_binders as m
-
-with pytest.suppress(ImportError):
-    import numpy as np
-
-
-def test_vector_int():
-    v_int = m.VectorInt([0, 0])
-    assert len(v_int) == 2
-    assert bool(v_int) is True
-
-    v_int2 = m.VectorInt([0, 0])
-    assert v_int == v_int2
-    v_int2[1] = 1
-    assert v_int != v_int2
-
-    v_int2.append(2)
-    v_int2.insert(0, 1)
-    v_int2.insert(0, 2)
-    v_int2.insert(0, 3)
-    v_int2.insert(6, 3)
-    assert str(v_int2) == "VectorInt[3, 2, 1, 0, 1, 2, 3]"
-    with pytest.raises(IndexError):
-        v_int2.insert(8, 4)
-
-    v_int.append(99)
-    v_int2[2:-2] = v_int
-    assert v_int2 == m.VectorInt([3, 2, 0, 0, 99, 2, 3])
-    del v_int2[1:3]
-    assert v_int2 == m.VectorInt([3, 0, 99, 2, 3])
-    del v_int2[0]
-    assert v_int2 == m.VectorInt([0, 99, 2, 3])
-
-
-# related to the PyPy's buffer protocol.
-@pytest.unsupported_on_pypy
-def test_vector_buffer():
-    b = bytearray([1, 2, 3, 4])
-    v = m.VectorUChar(b)
-    assert v[1] == 2
-    v[2] = 5
-    mv = memoryview(v)  # We expose the buffer interface
-    if sys.version_info.major > 2:
-        assert mv[2] == 5
-        mv[2] = 6
-    else:
-        assert mv[2] == '\x05'
-        mv[2] = '\x06'
-    assert v[2] == 6
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.create_undeclstruct()  # Undeclared struct contents, no buffer interface
-    assert "NumPy type info missing for " in str(excinfo.value)
-
-
-@pytest.unsupported_on_pypy
-@pytest.requires_numpy
-def test_vector_buffer_numpy():
-    a = np.array([1, 2, 3, 4], dtype=np.int32)
-    with pytest.raises(TypeError):
-        m.VectorInt(a)
-
-    a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], dtype=np.uintc)
-    v = m.VectorInt(a[0, :])
-    assert len(v) == 4
-    assert v[2] == 3
-    ma = np.asarray(v)
-    ma[2] = 5
-    assert v[2] == 5
-
-    v = m.VectorInt(a[:, 1])
-    assert len(v) == 3
-    assert v[2] == 10
-
-    v = m.get_vectorstruct()
-    assert v[0].x == 5
-    ma = np.asarray(v)
-    ma[1]['x'] = 99
-    assert v[1].x == 99
-
-    v = m.VectorStruct(np.zeros(3, dtype=np.dtype([('w', 'bool'), ('x', 'I'),
-                                                   ('y', 'float64'), ('z', 'bool')], align=True)))
-    assert len(v) == 3
-
-
-def test_vector_bool():
-    vv_c = m.VectorBool()
-    for i in range(10):
-        vv_c.append(i % 2 == 0)
-    for i in range(10):
-        assert vv_c[i] == (i % 2 == 0)
-    assert str(vv_c) == "VectorBool[1, 0, 1, 0, 1, 0, 1, 0, 1, 0]"
-
-
-def test_vector_custom():
-    v_a = m.VectorEl()
-    v_a.append(m.El(1))
-    v_a.append(m.El(2))
-    assert str(v_a) == "VectorEl[El{1}, El{2}]"
-
-    vv_a = m.VectorVectorEl()
-    vv_a.append(v_a)
-    vv_b = vv_a[0]
-    assert str(vv_b) == "VectorEl[El{1}, El{2}]"
-
-
-def test_map_string_double():
-    mm = m.MapStringDouble()
-    mm['a'] = 1
-    mm['b'] = 2.5
-
-    assert list(mm) == ['a', 'b']
-    assert list(mm.items()) == [('a', 1), ('b', 2.5)]
-    assert str(mm) == "MapStringDouble{a: 1, b: 2.5}"
-
-    um = m.UnorderedMapStringDouble()
-    um['ua'] = 1.1
-    um['ub'] = 2.6
-
-    assert sorted(list(um)) == ['ua', 'ub']
-    assert sorted(list(um.items())) == [('ua', 1.1), ('ub', 2.6)]
-    assert "UnorderedMapStringDouble" in str(um)
-
-
-def test_map_string_double_const():
-    mc = m.MapStringDoubleConst()
-    mc['a'] = 10
-    mc['b'] = 20.5
-    assert str(mc) == "MapStringDoubleConst{a: 10, b: 20.5}"
-
-    umc = m.UnorderedMapStringDoubleConst()
-    umc['a'] = 11
-    umc['b'] = 21.5
-
-    str(umc)
-
-
-def test_noncopyable_containers():
-    # std::vector
-    vnc = m.get_vnc(5)
-    for i in range(0, 5):
-        assert vnc[i].value == i + 1
-
-    for i, j in enumerate(vnc, start=1):
-        assert j.value == i
-
-    # std::deque
-    dnc = m.get_dnc(5)
-    for i in range(0, 5):
-        assert dnc[i].value == i + 1
-
-    i = 1
-    for j in dnc:
-        assert(j.value == i)
-        i += 1
-
-    # std::map
-    mnc = m.get_mnc(5)
-    for i in range(1, 6):
-        assert mnc[i].value == 10 * i
-
-    vsum = 0
-    for k, v in mnc.items():
-        assert v.value == 10 * k
-        vsum += v.value
-
-    assert vsum == 150
-
-    # std::unordered_map
-    mnc = m.get_umnc(5)
-    for i in range(1, 6):
-        assert mnc[i].value == 10 * i
-
-    vsum = 0
-    for k, v in mnc.items():
-        assert v.value == 10 * k
-        vsum += v.value
-
-    assert vsum == 150
diff --git a/tmap/lib/pybind11/tests/test_virtual_functions.cpp b/tmap/lib/pybind11/tests/test_virtual_functions.cpp
deleted file mode 100644
index 953b390..0000000
--- a/tmap/lib/pybind11/tests/test_virtual_functions.cpp
+++ /dev/null
@@ -1,450 +0,0 @@
-/*
-    tests/test_virtual_functions.cpp -- overriding virtual functions from Python
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include "pybind11_tests.h"
-#include "constructor_stats.h"
-#include <pybind11/functional.h>
-
-/* This is an example class that we'll want to be able to extend from Python */
-class ExampleVirt  {
-public:
-    ExampleVirt(int state) : state(state) { print_created(this, state); }
-    ExampleVirt(const ExampleVirt &e) : state(e.state) { print_copy_created(this); }
-    ExampleVirt(ExampleVirt &&e) : state(e.state) { print_move_created(this); e.state = 0; }
-    ~ExampleVirt() { print_destroyed(this); }
-
-    virtual int run(int value) {
-        py::print("Original implementation of "
-                  "ExampleVirt::run(state={}, value={}, str1={}, str2={})"_s.format(state, value, get_string1(), *get_string2()));
-        return state + value;
-    }
-
-    virtual bool run_bool() = 0;
-    virtual void pure_virtual() = 0;
-
-    // Returning a reference/pointer to a type converted from python (numbers, strings, etc.) is a
-    // bit trickier, because the actual int& or std::string& or whatever only exists temporarily, so
-    // we have to handle it specially in the trampoline class (see below).
-    virtual const std::string &get_string1() { return str1; }
-    virtual const std::string *get_string2() { return &str2; }
-
-private:
-    int state;
-    const std::string str1{"default1"}, str2{"default2"};
-};
-
-/* This is a wrapper class that must be generated */
-class PyExampleVirt : public ExampleVirt {
-public:
-    using ExampleVirt::ExampleVirt; /* Inherit constructors */
-
-    int run(int value) override {
-        /* Generate wrapping code that enables native function overloading */
-        PYBIND11_OVERLOAD(
-            int,         /* Return type */
-            ExampleVirt, /* Parent class */
-            run,         /* Name of function */
-            value        /* Argument(s) */
-        );
-    }
-
-    bool run_bool() override {
-        PYBIND11_OVERLOAD_PURE(
-            bool,         /* Return type */
-            ExampleVirt,  /* Parent class */
-            run_bool,     /* Name of function */
-                          /* This function has no arguments. The trailing comma
-                             in the previous line is needed for some compilers */
-        );
-    }
-
-    void pure_virtual() override {
-        PYBIND11_OVERLOAD_PURE(
-            void,         /* Return type */
-            ExampleVirt,  /* Parent class */
-            pure_virtual, /* Name of function */
-                          /* This function has no arguments. The trailing comma
-                             in the previous line is needed for some compilers */
-        );
-    }
-
-    // We can return reference types for compatibility with C++ virtual interfaces that do so, but
-    // note they have some significant limitations (see the documentation).
-    const std::string &get_string1() override {
-        PYBIND11_OVERLOAD(
-            const std::string &, /* Return type */
-            ExampleVirt,         /* Parent class */
-            get_string1,         /* Name of function */
-                                 /* (no arguments) */
-        );
-    }
-
-    const std::string *get_string2() override {
-        PYBIND11_OVERLOAD(
-            const std::string *, /* Return type */
-            ExampleVirt,         /* Parent class */
-            get_string2,         /* Name of function */
-                                 /* (no arguments) */
-        );
-    }
-
-};
-
-class NonCopyable {
-public:
-    NonCopyable(int a, int b) : value{new int(a*b)} { print_created(this, a, b); }
-    NonCopyable(NonCopyable &&o) { value = std::move(o.value); print_move_created(this); }
-    NonCopyable(const NonCopyable &) = delete;
-    NonCopyable() = delete;
-    void operator=(const NonCopyable &) = delete;
-    void operator=(NonCopyable &&) = delete;
-    std::string get_value() const {
-        if (value) return std::to_string(*value); else return "(null)";
-    }
-    ~NonCopyable() { print_destroyed(this); }
-
-private:
-    std::unique_ptr<int> value;
-};
-
-// This is like the above, but is both copy and movable.  In effect this means it should get moved
-// when it is not referenced elsewhere, but copied if it is still referenced.
-class Movable {
-public:
-    Movable(int a, int b) : value{a+b} { print_created(this, a, b); }
-    Movable(const Movable &m) { value = m.value; print_copy_created(this); }
-    Movable(Movable &&m) { value = std::move(m.value); print_move_created(this); }
-    std::string get_value() const { return std::to_string(value); }
-    ~Movable() { print_destroyed(this); }
-private:
-    int value;
-};
-
-class NCVirt {
-public:
-    virtual NonCopyable get_noncopyable(int a, int b) { return NonCopyable(a, b); }
-    virtual Movable get_movable(int a, int b) = 0;
-
-    std::string print_nc(int a, int b) { return get_noncopyable(a, b).get_value(); }
-    std::string print_movable(int a, int b) { return get_movable(a, b).get_value(); }
-};
-class NCVirtTrampoline : public NCVirt {
-#if !defined(__INTEL_COMPILER)
-    NonCopyable get_noncopyable(int a, int b) override {
-        PYBIND11_OVERLOAD(NonCopyable, NCVirt, get_noncopyable, a, b);
-    }
-#endif
-    Movable get_movable(int a, int b) override {
-        PYBIND11_OVERLOAD_PURE(Movable, NCVirt, get_movable, a, b);
-    }
-};
-
-struct Base {
-    /* for some reason MSVC2015 can't compile this if the function is pure virtual */
-    virtual std::string dispatch() const { return {}; };
-    virtual ~Base() = default;
-};
-
-struct DispatchIssue : Base {
-    virtual std::string dispatch() const {
-        PYBIND11_OVERLOAD_PURE(std::string, Base, dispatch, /* no arguments */);
-    }
-};
-
-// Forward declaration (so that we can put the main tests here; the inherited virtual approaches are
-// rather long).
-void initialize_inherited_virtuals(py::module &m);
-
-TEST_SUBMODULE(virtual_functions, m) {
-    // test_override
-    py::class_<ExampleVirt, PyExampleVirt>(m, "ExampleVirt")
-        .def(py::init<int>())
-        /* Reference original class in function definitions */
-        .def("run", &ExampleVirt::run)
-        .def("run_bool", &ExampleVirt::run_bool)
-        .def("pure_virtual", &ExampleVirt::pure_virtual);
-
-    py::class_<NonCopyable>(m, "NonCopyable")
-        .def(py::init<int, int>());
-
-    py::class_<Movable>(m, "Movable")
-        .def(py::init<int, int>());
-
-    // test_move_support
-#if !defined(__INTEL_COMPILER)
-    py::class_<NCVirt, NCVirtTrampoline>(m, "NCVirt")
-        .def(py::init<>())
-        .def("get_noncopyable", &NCVirt::get_noncopyable)
-        .def("get_movable", &NCVirt::get_movable)
-        .def("print_nc", &NCVirt::print_nc)
-        .def("print_movable", &NCVirt::print_movable);
-#endif
-
-    m.def("runExampleVirt", [](ExampleVirt *ex, int value) { return ex->run(value); });
-    m.def("runExampleVirtBool", [](ExampleVirt* ex) { return ex->run_bool(); });
-    m.def("runExampleVirtVirtual", [](ExampleVirt *ex) { ex->pure_virtual(); });
-
-    m.def("cstats_debug", &ConstructorStats::get<ExampleVirt>);
-    initialize_inherited_virtuals(m);
-
-    // test_alias_delay_initialization1
-    // don't invoke Python dispatch classes by default when instantiating C++ classes
-    // that were not extended on the Python side
-    struct A {
-        virtual ~A() {}
-        virtual void f() { py::print("A.f()"); }
-    };
-
-    struct PyA : A {
-        PyA() { py::print("PyA.PyA()"); }
-        ~PyA() { py::print("PyA.~PyA()"); }
-
-        void f() override {
-            py::print("PyA.f()");
-            PYBIND11_OVERLOAD(void, A, f);
-        }
-    };
-
-    py::class_<A, PyA>(m, "A")
-        .def(py::init<>())
-        .def("f", &A::f);
-
-    m.def("call_f", [](A *a) { a->f(); });
-
-    // test_alias_delay_initialization2
-    // ... unless we explicitly request it, as in this example:
-    struct A2 {
-        virtual ~A2() {}
-        virtual void f() { py::print("A2.f()"); }
-    };
-
-    struct PyA2 : A2 {
-        PyA2() { py::print("PyA2.PyA2()"); }
-        ~PyA2() { py::print("PyA2.~PyA2()"); }
-        void f() override {
-            py::print("PyA2.f()");
-            PYBIND11_OVERLOAD(void, A2, f);
-        }
-    };
-
-    py::class_<A2, PyA2>(m, "A2")
-        .def(py::init_alias<>())
-        .def(py::init([](int) { return new PyA2(); }))
-        .def("f", &A2::f);
-
-    m.def("call_f", [](A2 *a2) { a2->f(); });
-
-    // test_dispatch_issue
-    // #159: virtual function dispatch has problems with similar-named functions
-    py::class_<Base, DispatchIssue>(m, "DispatchIssue")
-        .def(py::init<>())
-        .def("dispatch", &Base::dispatch);
-
-    m.def("dispatch_issue_go", [](const Base * b) { return b->dispatch(); });
-
-    // test_override_ref
-    // #392/397: overridding reference-returning functions
-    class OverrideTest {
-    public:
-        struct A { std::string value = "hi"; };
-        std::string v;
-        A a;
-        explicit OverrideTest(const std::string &v) : v{v} {}
-        virtual std::string str_value() { return v; }
-        virtual std::string &str_ref() { return v; }
-        virtual A A_value() { return a; }
-        virtual A &A_ref() { return a; }
-        virtual ~OverrideTest() = default;
-    };
-
-    class PyOverrideTest : public OverrideTest {
-    public:
-        using OverrideTest::OverrideTest;
-        std::string str_value() override { PYBIND11_OVERLOAD(std::string, OverrideTest, str_value); }
-        // Not allowed (uncommenting should hit a static_assert failure): we can't get a reference
-        // to a python numeric value, since we only copy values in the numeric type caster:
-//      std::string &str_ref() override { PYBIND11_OVERLOAD(std::string &, OverrideTest, str_ref); }
-        // But we can work around it like this:
-    private:
-        std::string _tmp;
-        std::string str_ref_helper() { PYBIND11_OVERLOAD(std::string, OverrideTest, str_ref); }
-    public:
-        std::string &str_ref() override { return _tmp = str_ref_helper(); }
-
-        A A_value() override { PYBIND11_OVERLOAD(A, OverrideTest, A_value); }
-        A &A_ref() override { PYBIND11_OVERLOAD(A &, OverrideTest, A_ref); }
-    };
-
-    py::class_<OverrideTest::A>(m, "OverrideTest_A")
-        .def_readwrite("value", &OverrideTest::A::value);
-    py::class_<OverrideTest, PyOverrideTest>(m, "OverrideTest")
-        .def(py::init<const std::string &>())
-        .def("str_value", &OverrideTest::str_value)
-//      .def("str_ref", &OverrideTest::str_ref)
-        .def("A_value", &OverrideTest::A_value)
-        .def("A_ref", &OverrideTest::A_ref);
-}
-
-
-// Inheriting virtual methods.  We do two versions here: the repeat-everything version and the
-// templated trampoline versions mentioned in docs/advanced.rst.
-//
-// These base classes are exactly the same, but we technically need distinct
-// classes for this example code because we need to be able to bind them
-// properly (pybind11, sensibly, doesn't allow us to bind the same C++ class to
-// multiple python classes).
-class A_Repeat {
-#define A_METHODS \
-public: \
-    virtual int unlucky_number() = 0; \
-    virtual std::string say_something(unsigned times) { \
-        std::string s = ""; \
-        for (unsigned i = 0; i < times; ++i) \
-            s += "hi"; \
-        return s; \
-    } \
-    std::string say_everything() { \
-        return say_something(1) + " " + std::to_string(unlucky_number()); \
-    }
-A_METHODS
-    virtual ~A_Repeat() = default;
-};
-class B_Repeat : public A_Repeat {
-#define B_METHODS \
-public: \
-    int unlucky_number() override { return 13; } \
-    std::string say_something(unsigned times) override { \
-        return "B says hi " + std::to_string(times) + " times"; \
-    } \
-    virtual double lucky_number() { return 7.0; }
-B_METHODS
-};
-class C_Repeat : public B_Repeat {
-#define C_METHODS \
-public: \
-    int unlucky_number() override { return 4444; } \
-    double lucky_number() override { return 888; }
-C_METHODS
-};
-class D_Repeat : public C_Repeat {
-#define D_METHODS // Nothing overridden.
-D_METHODS
-};
-
-// Base classes for templated inheritance trampolines.  Identical to the repeat-everything version:
-class A_Tpl { A_METHODS; virtual ~A_Tpl() = default; };
-class B_Tpl : public A_Tpl { B_METHODS };
-class C_Tpl : public B_Tpl { C_METHODS };
-class D_Tpl : public C_Tpl { D_METHODS };
-
-
-// Inheritance approach 1: each trampoline gets every virtual method (11 in total)
-class PyA_Repeat : public A_Repeat {
-public:
-    using A_Repeat::A_Repeat;
-    int unlucky_number() override { PYBIND11_OVERLOAD_PURE(int, A_Repeat, unlucky_number, ); }
-    std::string say_something(unsigned times) override { PYBIND11_OVERLOAD(std::string, A_Repeat, say_something, times); }
-};
-class PyB_Repeat : public B_Repeat {
-public:
-    using B_Repeat::B_Repeat;
-    int unlucky_number() override { PYBIND11_OVERLOAD(int, B_Repeat, unlucky_number, ); }
-    std::string say_something(unsigned times) override { PYBIND11_OVERLOAD(std::string, B_Repeat, say_something, times); }
-    double lucky_number() override { PYBIND11_OVERLOAD(double, B_Repeat, lucky_number, ); }
-};
-class PyC_Repeat : public C_Repeat {
-public:
-    using C_Repeat::C_Repeat;
-    int unlucky_number() override { PYBIND11_OVERLOAD(int, C_Repeat, unlucky_number, ); }
-    std::string say_something(unsigned times) override { PYBIND11_OVERLOAD(std::string, C_Repeat, say_something, times); }
-    double lucky_number() override { PYBIND11_OVERLOAD(double, C_Repeat, lucky_number, ); }
-};
-class PyD_Repeat : public D_Repeat {
-public:
-    using D_Repeat::D_Repeat;
-    int unlucky_number() override { PYBIND11_OVERLOAD(int, D_Repeat, unlucky_number, ); }
-    std::string say_something(unsigned times) override { PYBIND11_OVERLOAD(std::string, D_Repeat, say_something, times); }
-    double lucky_number() override { PYBIND11_OVERLOAD(double, D_Repeat, lucky_number, ); }
-};
-
-// Inheritance approach 2: templated trampoline classes.
-//
-// Advantages:
-// - we have only 2 (template) class and 4 method declarations (one per virtual method, plus one for
-//   any override of a pure virtual method), versus 4 classes and 6 methods (MI) or 4 classes and 11
-//   methods (repeat).
-// - Compared to MI, we also don't have to change the non-trampoline inheritance to virtual, and can
-//   properly inherit constructors.
-//
-// Disadvantage:
-// - the compiler must still generate and compile 14 different methods (more, even, than the 11
-//   required for the repeat approach) instead of the 6 required for MI.  (If there was no pure
-//   method (or no pure method override), the number would drop down to the same 11 as the repeat
-//   approach).
-template <class Base = A_Tpl>
-class PyA_Tpl : public Base {
-public:
-    using Base::Base; // Inherit constructors
-    int unlucky_number() override { PYBIND11_OVERLOAD_PURE(int, Base, unlucky_number, ); }
-    std::string say_something(unsigned times) override { PYBIND11_OVERLOAD(std::string, Base, say_something, times); }
-};
-template <class Base = B_Tpl>
-class PyB_Tpl : public PyA_Tpl<Base> {
-public:
-    using PyA_Tpl<Base>::PyA_Tpl; // Inherit constructors (via PyA_Tpl's inherited constructors)
-    int unlucky_number() override { PYBIND11_OVERLOAD(int, Base, unlucky_number, ); }
-    double lucky_number() override { PYBIND11_OVERLOAD(double, Base, lucky_number, ); }
-};
-// Since C_Tpl and D_Tpl don't declare any new virtual methods, we don't actually need these (we can
-// use PyB_Tpl<C_Tpl> and PyB_Tpl<D_Tpl> for the trampoline classes instead):
-/*
-template <class Base = C_Tpl> class PyC_Tpl : public PyB_Tpl<Base> {
-public:
-    using PyB_Tpl<Base>::PyB_Tpl;
-};
-template <class Base = D_Tpl> class PyD_Tpl : public PyC_Tpl<Base> {
-public:
-    using PyC_Tpl<Base>::PyC_Tpl;
-};
-*/
-
-
-void initialize_inherited_virtuals(py::module &m) {
-    // test_inherited_virtuals
-
-    // Method 1: repeat
-    py::class_<A_Repeat, PyA_Repeat>(m, "A_Repeat")
-        .def(py::init<>())
-        .def("unlucky_number", &A_Repeat::unlucky_number)
-        .def("say_something", &A_Repeat::say_something)
-        .def("say_everything", &A_Repeat::say_everything);
-    py::class_<B_Repeat, A_Repeat, PyB_Repeat>(m, "B_Repeat")
-        .def(py::init<>())
-        .def("lucky_number", &B_Repeat::lucky_number);
-    py::class_<C_Repeat, B_Repeat, PyC_Repeat>(m, "C_Repeat")
-        .def(py::init<>());
-    py::class_<D_Repeat, C_Repeat, PyD_Repeat>(m, "D_Repeat")
-        .def(py::init<>());
-
-    // test_
-    // Method 2: Templated trampolines
-    py::class_<A_Tpl, PyA_Tpl<>>(m, "A_Tpl")
-        .def(py::init<>())
-        .def("unlucky_number", &A_Tpl::unlucky_number)
-        .def("say_something", &A_Tpl::say_something)
-        .def("say_everything", &A_Tpl::say_everything);
-    py::class_<B_Tpl, A_Tpl, PyB_Tpl<>>(m, "B_Tpl")
-        .def(py::init<>())
-        .def("lucky_number", &B_Tpl::lucky_number);
-    py::class_<C_Tpl, B_Tpl, PyB_Tpl<C_Tpl>>(m, "C_Tpl")
-        .def(py::init<>());
-    py::class_<D_Tpl, C_Tpl, PyB_Tpl<D_Tpl>>(m, "D_Tpl")
-        .def(py::init<>());
-
-};
diff --git a/tmap/lib/pybind11/tests/test_virtual_functions.py b/tmap/lib/pybind11/tests/test_virtual_functions.py
deleted file mode 100644
index b91ebfa..0000000
--- a/tmap/lib/pybind11/tests/test_virtual_functions.py
+++ /dev/null
@@ -1,371 +0,0 @@
-import pytest
-
-from pybind11_tests import virtual_functions as m
-from pybind11_tests import ConstructorStats
-
-
-def test_override(capture, msg):
-    class ExtendedExampleVirt(m.ExampleVirt):
-        def __init__(self, state):
-            super(ExtendedExampleVirt, self).__init__(state + 1)
-            self.data = "Hello world"
-
-        def run(self, value):
-            print('ExtendedExampleVirt::run(%i), calling parent..' % value)
-            return super(ExtendedExampleVirt, self).run(value + 1)
-
-        def run_bool(self):
-            print('ExtendedExampleVirt::run_bool()')
-            return False
-
-        def get_string1(self):
-            return "override1"
-
-        def pure_virtual(self):
-            print('ExtendedExampleVirt::pure_virtual(): %s' % self.data)
-
-    class ExtendedExampleVirt2(ExtendedExampleVirt):
-        def __init__(self, state):
-            super(ExtendedExampleVirt2, self).__init__(state + 1)
-
-        def get_string2(self):
-            return "override2"
-
-    ex12 = m.ExampleVirt(10)
-    with capture:
-        assert m.runExampleVirt(ex12, 20) == 30
-    assert capture == """
-        Original implementation of ExampleVirt::run(state=10, value=20, str1=default1, str2=default2)
-    """  # noqa: E501 line too long
-
-    with pytest.raises(RuntimeError) as excinfo:
-        m.runExampleVirtVirtual(ex12)
-    assert msg(excinfo.value) == 'Tried to call pure virtual function "ExampleVirt::pure_virtual"'
-
-    ex12p = ExtendedExampleVirt(10)
-    with capture:
-        assert m.runExampleVirt(ex12p, 20) == 32
-    assert capture == """
-        ExtendedExampleVirt::run(20), calling parent..
-        Original implementation of ExampleVirt::run(state=11, value=21, str1=override1, str2=default2)
-    """  # noqa: E501 line too long
-    with capture:
-        assert m.runExampleVirtBool(ex12p) is False
-    assert capture == "ExtendedExampleVirt::run_bool()"
-    with capture:
-        m.runExampleVirtVirtual(ex12p)
-    assert capture == "ExtendedExampleVirt::pure_virtual(): Hello world"
-
-    ex12p2 = ExtendedExampleVirt2(15)
-    with capture:
-        assert m.runExampleVirt(ex12p2, 50) == 68
-    assert capture == """
-        ExtendedExampleVirt::run(50), calling parent..
-        Original implementation of ExampleVirt::run(state=17, value=51, str1=override1, str2=override2)
-    """  # noqa: E501 line too long
-
-    cstats = ConstructorStats.get(m.ExampleVirt)
-    assert cstats.alive() == 3
-    del ex12, ex12p, ex12p2
-    assert cstats.alive() == 0
-    assert cstats.values() == ['10', '11', '17']
-    assert cstats.copy_constructions == 0
-    assert cstats.move_constructions >= 0
-
-
-def test_alias_delay_initialization1(capture):
-    """`A` only initializes its trampoline class when we inherit from it
-
-    If we just create and use an A instance directly, the trampoline initialization is
-    bypassed and we only initialize an A() instead (for performance reasons).
-    """
-    class B(m.A):
-        def __init__(self):
-            super(B, self).__init__()
-
-        def f(self):
-            print("In python f()")
-
-    # C++ version
-    with capture:
-        a = m.A()
-        m.call_f(a)
-        del a
-        pytest.gc_collect()
-    assert capture == "A.f()"
-
-    # Python version
-    with capture:
-        b = B()
-        m.call_f(b)
-        del b
-        pytest.gc_collect()
-    assert capture == """
-        PyA.PyA()
-        PyA.f()
-        In python f()
-        PyA.~PyA()
-    """
-
-
-def test_alias_delay_initialization2(capture):
-    """`A2`, unlike the above, is configured to always initialize the alias
-
-    While the extra initialization and extra class layer has small virtual dispatch
-    performance penalty, it also allows us to do more things with the trampoline
-    class such as defining local variables and performing construction/destruction.
-    """
-    class B2(m.A2):
-        def __init__(self):
-            super(B2, self).__init__()
-
-        def f(self):
-            print("In python B2.f()")
-
-    # No python subclass version
-    with capture:
-        a2 = m.A2()
-        m.call_f(a2)
-        del a2
-        pytest.gc_collect()
-        a3 = m.A2(1)
-        m.call_f(a3)
-        del a3
-        pytest.gc_collect()
-    assert capture == """
-        PyA2.PyA2()
-        PyA2.f()
-        A2.f()
-        PyA2.~PyA2()
-        PyA2.PyA2()
-        PyA2.f()
-        A2.f()
-        PyA2.~PyA2()
-    """
-
-    # Python subclass version
-    with capture:
-        b2 = B2()
-        m.call_f(b2)
-        del b2
-        pytest.gc_collect()
-    assert capture == """
-        PyA2.PyA2()
-        PyA2.f()
-        In python B2.f()
-        PyA2.~PyA2()
-    """
-
-
-# PyPy: Reference count > 1 causes call with noncopyable instance
-# to fail in ncv1.print_nc()
-@pytest.unsupported_on_pypy
-@pytest.mark.skipif(not hasattr(m, "NCVirt"), reason="NCVirt test broken on ICPC")
-def test_move_support():
-    class NCVirtExt(m.NCVirt):
-        def get_noncopyable(self, a, b):
-            # Constructs and returns a new instance:
-            nc = m.NonCopyable(a * a, b * b)
-            return nc
-
-        def get_movable(self, a, b):
-            # Return a referenced copy
-            self.movable = m.Movable(a, b)
-            return self.movable
-
-    class NCVirtExt2(m.NCVirt):
-        def get_noncopyable(self, a, b):
-            # Keep a reference: this is going to throw an exception
-            self.nc = m.NonCopyable(a, b)
-            return self.nc
-
-        def get_movable(self, a, b):
-            # Return a new instance without storing it
-            return m.Movable(a, b)
-
-    ncv1 = NCVirtExt()
-    assert ncv1.print_nc(2, 3) == "36"
-    assert ncv1.print_movable(4, 5) == "9"
-    ncv2 = NCVirtExt2()
-    assert ncv2.print_movable(7, 7) == "14"
-    # Don't check the exception message here because it differs under debug/non-debug mode
-    with pytest.raises(RuntimeError):
-        ncv2.print_nc(9, 9)
-
-    nc_stats = ConstructorStats.get(m.NonCopyable)
-    mv_stats = ConstructorStats.get(m.Movable)
-    assert nc_stats.alive() == 1
-    assert mv_stats.alive() == 1
-    del ncv1, ncv2
-    assert nc_stats.alive() == 0
-    assert mv_stats.alive() == 0
-    assert nc_stats.values() == ['4', '9', '9', '9']
-    assert mv_stats.values() == ['4', '5', '7', '7']
-    assert nc_stats.copy_constructions == 0
-    assert mv_stats.copy_constructions == 1
-    assert nc_stats.move_constructions >= 0
-    assert mv_stats.move_constructions >= 0
-
-
-def test_dispatch_issue(msg):
-    """#159: virtual function dispatch has problems with similar-named functions"""
-    class PyClass1(m.DispatchIssue):
-        def dispatch(self):
-            return "Yay.."
-
-    class PyClass2(m.DispatchIssue):
-        def dispatch(self):
-            with pytest.raises(RuntimeError) as excinfo:
-                super(PyClass2, self).dispatch()
-            assert msg(excinfo.value) == 'Tried to call pure virtual function "Base::dispatch"'
-
-            p = PyClass1()
-            return m.dispatch_issue_go(p)
-
-    b = PyClass2()
-    assert m.dispatch_issue_go(b) == "Yay.."
-
-
-def test_override_ref():
-    """#392/397: overridding reference-returning functions"""
-    o = m.OverrideTest("asdf")
-
-    # Not allowed (see associated .cpp comment)
-    # i = o.str_ref()
-    # assert o.str_ref() == "asdf"
-    assert o.str_value() == "asdf"
-
-    assert o.A_value().value == "hi"
-    a = o.A_ref()
-    assert a.value == "hi"
-    a.value = "bye"
-    assert a.value == "bye"
-
-
-def test_inherited_virtuals():
-    class AR(m.A_Repeat):
-        def unlucky_number(self):
-            return 99
-
-    class AT(m.A_Tpl):
-        def unlucky_number(self):
-            return 999
-
-    obj = AR()
-    assert obj.say_something(3) == "hihihi"
-    assert obj.unlucky_number() == 99
-    assert obj.say_everything() == "hi 99"
-
-    obj = AT()
-    assert obj.say_something(3) == "hihihi"
-    assert obj.unlucky_number() == 999
-    assert obj.say_everything() == "hi 999"
-
-    for obj in [m.B_Repeat(), m.B_Tpl()]:
-        assert obj.say_something(3) == "B says hi 3 times"
-        assert obj.unlucky_number() == 13
-        assert obj.lucky_number() == 7.0
-        assert obj.say_everything() == "B says hi 1 times 13"
-
-    for obj in [m.C_Repeat(), m.C_Tpl()]:
-        assert obj.say_something(3) == "B says hi 3 times"
-        assert obj.unlucky_number() == 4444
-        assert obj.lucky_number() == 888.0
-        assert obj.say_everything() == "B says hi 1 times 4444"
-
-    class CR(m.C_Repeat):
-        def lucky_number(self):
-            return m.C_Repeat.lucky_number(self) + 1.25
-
-    obj = CR()
-    assert obj.say_something(3) == "B says hi 3 times"
-    assert obj.unlucky_number() == 4444
-    assert obj.lucky_number() == 889.25
-    assert obj.say_everything() == "B says hi 1 times 4444"
-
-    class CT(m.C_Tpl):
-        pass
-
-    obj = CT()
-    assert obj.say_something(3) == "B says hi 3 times"
-    assert obj.unlucky_number() == 4444
-    assert obj.lucky_number() == 888.0
-    assert obj.say_everything() == "B says hi 1 times 4444"
-
-    class CCR(CR):
-        def lucky_number(self):
-            return CR.lucky_number(self) * 10
-
-    obj = CCR()
-    assert obj.say_something(3) == "B says hi 3 times"
-    assert obj.unlucky_number() == 4444
-    assert obj.lucky_number() == 8892.5
-    assert obj.say_everything() == "B says hi 1 times 4444"
-
-    class CCT(CT):
-        def lucky_number(self):
-            return CT.lucky_number(self) * 1000
-
-    obj = CCT()
-    assert obj.say_something(3) == "B says hi 3 times"
-    assert obj.unlucky_number() == 4444
-    assert obj.lucky_number() == 888000.0
-    assert obj.say_everything() == "B says hi 1 times 4444"
-
-    class DR(m.D_Repeat):
-        def unlucky_number(self):
-            return 123
-
-        def lucky_number(self):
-            return 42.0
-
-    for obj in [m.D_Repeat(), m.D_Tpl()]:
-        assert obj.say_something(3) == "B says hi 3 times"
-        assert obj.unlucky_number() == 4444
-        assert obj.lucky_number() == 888.0
-        assert obj.say_everything() == "B says hi 1 times 4444"
-
-    obj = DR()
-    assert obj.say_something(3) == "B says hi 3 times"
-    assert obj.unlucky_number() == 123
-    assert obj.lucky_number() == 42.0
-    assert obj.say_everything() == "B says hi 1 times 123"
-
-    class DT(m.D_Tpl):
-        def say_something(self, times):
-            return "DT says:" + (' quack' * times)
-
-        def unlucky_number(self):
-            return 1234
-
-        def lucky_number(self):
-            return -4.25
-
-    obj = DT()
-    assert obj.say_something(3) == "DT says: quack quack quack"
-    assert obj.unlucky_number() == 1234
-    assert obj.lucky_number() == -4.25
-    assert obj.say_everything() == "DT says: quack 1234"
-
-    class DT2(DT):
-        def say_something(self, times):
-            return "DT2: " + ('QUACK' * times)
-
-        def unlucky_number(self):
-            return -3
-
-    class BT(m.B_Tpl):
-        def say_something(self, times):
-            return "BT" * times
-
-        def unlucky_number(self):
-            return -7
-
-        def lucky_number(self):
-            return -1.375
-
-    obj = BT()
-    assert obj.say_something(3) == "BTBTBT"
-    assert obj.unlucky_number() == -7
-    assert obj.lucky_number() == -1.375
-    assert obj.say_everything() == "BT -7"
diff --git a/tmap/lib/pybind11/tools/FindCatch.cmake b/tmap/lib/pybind11/tools/FindCatch.cmake
deleted file mode 100644
index 9d490c5..0000000
--- a/tmap/lib/pybind11/tools/FindCatch.cmake
+++ /dev/null
@@ -1,57 +0,0 @@
-# - Find the Catch test framework or download it (single header)
-#
-# This is a quick module for internal use. It assumes that Catch is
-# REQUIRED and that a minimum version is provided (not EXACT). If
-# a suitable version isn't found locally, the single header file
-# will be downloaded and placed in the build dir: PROJECT_BINARY_DIR.
-#
-# This code sets the following variables:
-#  CATCH_INCLUDE_DIR      - path to catch.hpp
-#  CATCH_VERSION          - version number
-
-if(NOT Catch_FIND_VERSION)
-  message(FATAL_ERROR "A version number must be specified.")
-elseif(Catch_FIND_REQUIRED)
-  message(FATAL_ERROR "This module assumes Catch is not required.")
-elseif(Catch_FIND_VERSION_EXACT)
-  message(FATAL_ERROR "Exact version numbers are not supported, only minimum.")
-endif()
-
-# Extract the version number from catch.hpp
-function(_get_catch_version)
-  file(STRINGS "${CATCH_INCLUDE_DIR}/catch.hpp" version_line REGEX "Catch v.*" LIMIT_COUNT 1)
-  if(version_line MATCHES "Catch v([0-9]+)\\.([0-9]+)\\.([0-9]+)")
-    set(CATCH_VERSION "${CMAKE_MATCH_1}.${CMAKE_MATCH_2}.${CMAKE_MATCH_3}" PARENT_SCOPE)
-  endif()
-endfunction()
-
-# Download the single-header version of Catch
-function(_download_catch version destination_dir)
-  message(STATUS "Downloading catch v${version}...")
-  set(url https://github.com/philsquared/Catch/releases/download/v${version}/catch.hpp)
-  file(DOWNLOAD ${url} "${destination_dir}/catch.hpp" STATUS status)
-  list(GET status 0 error)
-  if(error)
-    message(FATAL_ERROR "Could not download ${url}")
-  endif()
-  set(CATCH_INCLUDE_DIR "${destination_dir}" CACHE INTERNAL "")
-endfunction()
-
-# Look for catch locally
-find_path(CATCH_INCLUDE_DIR NAMES catch.hpp PATH_SUFFIXES catch)
-if(CATCH_INCLUDE_DIR)
-  _get_catch_version()
-endif()
-
-# Download the header if it wasn't found or if it's outdated
-if(NOT CATCH_VERSION OR CATCH_VERSION VERSION_LESS ${Catch_FIND_VERSION})
-  if(DOWNLOAD_CATCH)
-    _download_catch(${Catch_FIND_VERSION} "${PROJECT_BINARY_DIR}/catch/")
-    _get_catch_version()
-  else()
-    set(CATCH_FOUND FALSE)
-    return()
-  endif()
-endif()
-
-set(CATCH_FOUND TRUE)
diff --git a/tmap/lib/pybind11/tools/FindEigen3.cmake b/tmap/lib/pybind11/tools/FindEigen3.cmake
deleted file mode 100644
index 9c546a0..0000000
--- a/tmap/lib/pybind11/tools/FindEigen3.cmake
+++ /dev/null
@@ -1,81 +0,0 @@
-# - Try to find Eigen3 lib
-#
-# This module supports requiring a minimum version, e.g. you can do
-#   find_package(Eigen3 3.1.2)
-# to require version 3.1.2 or newer of Eigen3.
-#
-# Once done this will define
-#
-#  EIGEN3_FOUND - system has eigen lib with correct version
-#  EIGEN3_INCLUDE_DIR - the eigen include directory
-#  EIGEN3_VERSION - eigen version
-
-# Copyright (c) 2006, 2007 Montel Laurent, <montel@kde.org>
-# Copyright (c) 2008, 2009 Gael Guennebaud, <g.gael@free.fr>
-# Copyright (c) 2009 Benoit Jacob <jacob.benoit.1@gmail.com>
-# Redistribution and use is allowed according to the terms of the 2-clause BSD license.
-
-if(NOT Eigen3_FIND_VERSION)
-  if(NOT Eigen3_FIND_VERSION_MAJOR)
-    set(Eigen3_FIND_VERSION_MAJOR 2)
-  endif(NOT Eigen3_FIND_VERSION_MAJOR)
-  if(NOT Eigen3_FIND_VERSION_MINOR)
-    set(Eigen3_FIND_VERSION_MINOR 91)
-  endif(NOT Eigen3_FIND_VERSION_MINOR)
-  if(NOT Eigen3_FIND_VERSION_PATCH)
-    set(Eigen3_FIND_VERSION_PATCH 0)
-  endif(NOT Eigen3_FIND_VERSION_PATCH)
-
-  set(Eigen3_FIND_VERSION "${Eigen3_FIND_VERSION_MAJOR}.${Eigen3_FIND_VERSION_MINOR}.${Eigen3_FIND_VERSION_PATCH}")
-endif(NOT Eigen3_FIND_VERSION)
-
-macro(_eigen3_check_version)
-  file(READ "${EIGEN3_INCLUDE_DIR}/Eigen/src/Core/util/Macros.h" _eigen3_version_header)
-
-  string(REGEX MATCH "define[ \t]+EIGEN_WORLD_VERSION[ \t]+([0-9]+)" _eigen3_world_version_match "${_eigen3_version_header}")
-  set(EIGEN3_WORLD_VERSION "${CMAKE_MATCH_1}")
-  string(REGEX MATCH "define[ \t]+EIGEN_MAJOR_VERSION[ \t]+([0-9]+)" _eigen3_major_version_match "${_eigen3_version_header}")
-  set(EIGEN3_MAJOR_VERSION "${CMAKE_MATCH_1}")
-  string(REGEX MATCH "define[ \t]+EIGEN_MINOR_VERSION[ \t]+([0-9]+)" _eigen3_minor_version_match "${_eigen3_version_header}")
-  set(EIGEN3_MINOR_VERSION "${CMAKE_MATCH_1}")
-
-  set(EIGEN3_VERSION ${EIGEN3_WORLD_VERSION}.${EIGEN3_MAJOR_VERSION}.${EIGEN3_MINOR_VERSION})
-  if(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
-    set(EIGEN3_VERSION_OK FALSE)
-  else(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
-    set(EIGEN3_VERSION_OK TRUE)
-  endif(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
-
-  if(NOT EIGEN3_VERSION_OK)
-
-    message(STATUS "Eigen3 version ${EIGEN3_VERSION} found in ${EIGEN3_INCLUDE_DIR}, "
-                   "but at least version ${Eigen3_FIND_VERSION} is required")
-  endif(NOT EIGEN3_VERSION_OK)
-endmacro(_eigen3_check_version)
-
-if (EIGEN3_INCLUDE_DIR)
-
-  # in cache already
-  _eigen3_check_version()
-  set(EIGEN3_FOUND ${EIGEN3_VERSION_OK})
-
-else (EIGEN3_INCLUDE_DIR)
-
-  find_path(EIGEN3_INCLUDE_DIR NAMES signature_of_eigen3_matrix_library
-      PATHS
-      ${CMAKE_INSTALL_PREFIX}/include
-      ${KDE4_INCLUDE_DIR}
-      PATH_SUFFIXES eigen3 eigen
-    )
-
-  if(EIGEN3_INCLUDE_DIR)
-    _eigen3_check_version()
-  endif(EIGEN3_INCLUDE_DIR)
-
-  include(FindPackageHandleStandardArgs)
-  find_package_handle_standard_args(Eigen3 DEFAULT_MSG EIGEN3_INCLUDE_DIR EIGEN3_VERSION_OK)
-
-  mark_as_advanced(EIGEN3_INCLUDE_DIR)
-
-endif(EIGEN3_INCLUDE_DIR)
-
diff --git a/tmap/lib/pybind11/tools/FindPythonLibsNew.cmake b/tmap/lib/pybind11/tools/FindPythonLibsNew.cmake
deleted file mode 100644
index ad3ed48..0000000
--- a/tmap/lib/pybind11/tools/FindPythonLibsNew.cmake
+++ /dev/null
@@ -1,195 +0,0 @@
-# - Find python libraries
-# This module finds the libraries corresponding to the Python interpeter
-# FindPythonInterp provides.
-# This code sets the following variables:
-#
-#  PYTHONLIBS_FOUND           - have the Python libs been found
-#  PYTHON_PREFIX              - path to the Python installation
-#  PYTHON_LIBRARIES           - path to the python library
-#  PYTHON_INCLUDE_DIRS        - path to where Python.h is found
-#  PYTHON_MODULE_EXTENSION    - lib extension, e.g. '.so' or '.pyd'
-#  PYTHON_MODULE_PREFIX       - lib name prefix: usually an empty string
-#  PYTHON_SITE_PACKAGES       - path to installation site-packages
-#  PYTHON_IS_DEBUG            - whether the Python interpreter is a debug build
-#
-# Thanks to talljimbo for the patch adding the 'LDVERSION' config
-# variable usage.
-
-#=============================================================================
-# Copyright 2001-2009 Kitware, Inc.
-# Copyright 2012 Continuum Analytics, Inc.
-#
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions
-# are met:
-#
-# * Redistributions of source code must retain the above copyright
-# notice, this list of conditions and the following disclaimer.
-#
-# * Redistributions in binary form must reproduce the above copyright
-# notice, this list of conditions and the following disclaimer in the
-# documentation and/or other materials provided with the distribution.
-#
-# * Neither the names of Kitware, Inc., the Insight Software Consortium,
-# nor the names of their contributors may be used to endorse or promote
-# products derived from this software without specific prior written
-# permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-# # A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#=============================================================================
-
-# Checking for the extension makes sure that `LibsNew` was found and not just `Libs`.
-if(PYTHONLIBS_FOUND AND PYTHON_MODULE_EXTENSION)
-    return()
-endif()
-
-# Use the Python interpreter to find the libs.
-if(PythonLibsNew_FIND_REQUIRED)
-    find_package(PythonInterp ${PythonLibsNew_FIND_VERSION} REQUIRED)
-else()
-    find_package(PythonInterp ${PythonLibsNew_FIND_VERSION})
-endif()
-
-if(NOT PYTHONINTERP_FOUND)
-    set(PYTHONLIBS_FOUND FALSE)
-    return()
-endif()
-
-# According to http://stackoverflow.com/questions/646518/python-how-to-detect-debug-interpreter
-# testing whether sys has the gettotalrefcount function is a reliable, cross-platform
-# way to detect a CPython debug interpreter.
-#
-# The library suffix is from the config var LDVERSION sometimes, otherwise
-# VERSION. VERSION will typically be like "2.7" on unix, and "27" on windows.
-execute_process(COMMAND "${PYTHON_EXECUTABLE}" "-c"
-    "from distutils import sysconfig as s;import sys;import struct;
-print('.'.join(str(v) for v in sys.version_info));
-print(sys.prefix);
-print(s.get_python_inc(plat_specific=True));
-print(s.get_python_lib(plat_specific=True));
-print(s.get_config_var('SO'));
-print(hasattr(sys, 'gettotalrefcount')+0);
-print(struct.calcsize('@P'));
-print(s.get_config_var('LDVERSION') or s.get_config_var('VERSION'));
-print(s.get_config_var('LIBDIR') or '');
-print(s.get_config_var('MULTIARCH') or '');
-"
-    RESULT_VARIABLE _PYTHON_SUCCESS
-    OUTPUT_VARIABLE _PYTHON_VALUES
-    ERROR_VARIABLE _PYTHON_ERROR_VALUE)
-
-if(NOT _PYTHON_SUCCESS MATCHES 0)
-    if(PythonLibsNew_FIND_REQUIRED)
-        message(FATAL_ERROR
-            "Python config failure:\n${_PYTHON_ERROR_VALUE}")
-    endif()
-    set(PYTHONLIBS_FOUND FALSE)
-    return()
-endif()
-
-# Convert the process output into a list
-string(REGEX REPLACE ";" "\\\\;" _PYTHON_VALUES ${_PYTHON_VALUES})
-string(REGEX REPLACE "\n" ";" _PYTHON_VALUES ${_PYTHON_VALUES})
-list(GET _PYTHON_VALUES 0 _PYTHON_VERSION_LIST)
-list(GET _PYTHON_VALUES 1 PYTHON_PREFIX)
-list(GET _PYTHON_VALUES 2 PYTHON_INCLUDE_DIR)
-list(GET _PYTHON_VALUES 3 PYTHON_SITE_PACKAGES)
-list(GET _PYTHON_VALUES 4 PYTHON_MODULE_EXTENSION)
-list(GET _PYTHON_VALUES 5 PYTHON_IS_DEBUG)
-list(GET _PYTHON_VALUES 6 PYTHON_SIZEOF_VOID_P)
-list(GET _PYTHON_VALUES 7 PYTHON_LIBRARY_SUFFIX)
-list(GET _PYTHON_VALUES 8 PYTHON_LIBDIR)
-list(GET _PYTHON_VALUES 9 PYTHON_MULTIARCH)
-
-# Make sure the Python has the same pointer-size as the chosen compiler
-# Skip if CMAKE_SIZEOF_VOID_P is not defined
-if(CMAKE_SIZEOF_VOID_P AND (NOT "${PYTHON_SIZEOF_VOID_P}" STREQUAL "${CMAKE_SIZEOF_VOID_P}"))
-    if(PythonLibsNew_FIND_REQUIRED)
-        math(EXPR _PYTHON_BITS "${PYTHON_SIZEOF_VOID_P} * 8")
-        math(EXPR _CMAKE_BITS "${CMAKE_SIZEOF_VOID_P} * 8")
-        message(FATAL_ERROR
-            "Python config failure: Python is ${_PYTHON_BITS}-bit, "
-            "chosen compiler is  ${_CMAKE_BITS}-bit")
-    endif()
-    set(PYTHONLIBS_FOUND FALSE)
-    return()
-endif()
-
-# The built-in FindPython didn't always give the version numbers
-string(REGEX REPLACE "\\." ";" _PYTHON_VERSION_LIST ${_PYTHON_VERSION_LIST})
-list(GET _PYTHON_VERSION_LIST 0 PYTHON_VERSION_MAJOR)
-list(GET _PYTHON_VERSION_LIST 1 PYTHON_VERSION_MINOR)
-list(GET _PYTHON_VERSION_LIST 2 PYTHON_VERSION_PATCH)
-
-# Make sure all directory separators are '/'
-string(REGEX REPLACE "\\\\" "/" PYTHON_PREFIX ${PYTHON_PREFIX})
-string(REGEX REPLACE "\\\\" "/" PYTHON_INCLUDE_DIR ${PYTHON_INCLUDE_DIR})
-string(REGEX REPLACE "\\\\" "/" PYTHON_SITE_PACKAGES ${PYTHON_SITE_PACKAGES})
-
-if(CMAKE_HOST_WIN32)
-    set(PYTHON_LIBRARY
-        "${PYTHON_PREFIX}/libs/Python${PYTHON_LIBRARY_SUFFIX}.lib")
-
-    # when run in a venv, PYTHON_PREFIX points to it. But the libraries remain in the
-    # original python installation. They may be found relative to PYTHON_INCLUDE_DIR.
-    if(NOT EXISTS "${PYTHON_LIBRARY}")
-        get_filename_component(_PYTHON_ROOT ${PYTHON_INCLUDE_DIR} DIRECTORY)
-        set(PYTHON_LIBRARY
-            "${_PYTHON_ROOT}/libs/Python${PYTHON_LIBRARY_SUFFIX}.lib")
-    endif()
-
-    # raise an error if the python libs are still not found.
-    if(NOT EXISTS "${PYTHON_LIBRARY}")
-        message(FATAL_ERROR "Python libraries not found")
-    endif()
-
-else()
-    if(PYTHON_MULTIARCH)
-        set(_PYTHON_LIBS_SEARCH "${PYTHON_LIBDIR}/${PYTHON_MULTIARCH}" "${PYTHON_LIBDIR}")
-    else()
-        set(_PYTHON_LIBS_SEARCH "${PYTHON_LIBDIR}")
-    endif()
-    #message(STATUS "Searching for Python libs in ${_PYTHON_LIBS_SEARCH}")
-    # Probably this needs to be more involved. It would be nice if the config
-    # information the python interpreter itself gave us were more complete.
-    find_library(PYTHON_LIBRARY
-        NAMES "python${PYTHON_LIBRARY_SUFFIX}"
-        PATHS ${_PYTHON_LIBS_SEARCH}
-        NO_DEFAULT_PATH)
-
-    # If all else fails, just set the name/version and let the linker figure out the path.
-    if(NOT PYTHON_LIBRARY)
-        set(PYTHON_LIBRARY python${PYTHON_LIBRARY_SUFFIX})
-    endif()
-endif()
-
-MARK_AS_ADVANCED(
-  PYTHON_LIBRARY
-  PYTHON_INCLUDE_DIR
-)
-
-# We use PYTHON_INCLUDE_DIR, PYTHON_LIBRARY and PYTHON_DEBUG_LIBRARY for the
-# cache entries because they are meant to specify the location of a single
-# library. We now set the variables listed by the documentation for this
-# module.
-SET(PYTHON_INCLUDE_DIRS "${PYTHON_INCLUDE_DIR}")
-SET(PYTHON_LIBRARIES "${PYTHON_LIBRARY}")
-SET(PYTHON_DEBUG_LIBRARIES "${PYTHON_DEBUG_LIBRARY}")
-
-find_package_message(PYTHON
-    "Found PythonLibs: ${PYTHON_LIBRARY}"
-    "${PYTHON_EXECUTABLE}${PYTHON_VERSION}")
-
-set(PYTHONLIBS_FOUND TRUE)
diff --git a/tmap/lib/pybind11/tools/check-style.sh b/tmap/lib/pybind11/tools/check-style.sh
deleted file mode 100755
index 050482d..0000000
--- a/tmap/lib/pybind11/tools/check-style.sh
+++ /dev/null
@@ -1,82 +0,0 @@
-#!/bin/bash
-# 
-# Script to check include/test code for common pybind11 code style errors.
-# 
-# This script currently checks for
-#
-# 1. use of tabs instead of spaces
-# 2. MSDOS-style CRLF endings
-# 3. trailing spaces
-# 4. missing space between keyword and parenthesis, e.g.: for(, if(, while(
-# 5. Missing space between right parenthesis and brace, e.g. 'for (...){'
-# 6. opening brace on its own line. It should always be on the same line as the
-#    if/while/for/do statment.
-# 
-# Invoke as: tools/check-style.sh
-#
-
-errors=0
-IFS=$'\n'
-found=
-# The mt=41 sets a red background for matched tabs:
-GREP_COLORS='mt=41' GREP_COLOR='41' grep $'\t' include tests/*.{cpp,py,h} docs/*.rst -rn --color=always |
-        while read f; do
-    if [ -z "$found" ]; then
-        echo -e '\033[31m\033[01mError: found tabs instead of spaces in the following files:\033[0m'
-        found=1
-        errors=1
-    fi
-
-    echo "    $f"
-done
-
-found=
-grep -IUlr $'\r' include tests/*.{cpp,py,h} docs/*.rst --color=always |
-        while read f; do
-    if [ -z "$found" ]; then
-        echo -e '\033[31m\033[01mError: found CRLF characters in the following files:\033[0m'
-        found=1
-        errors=1
-    fi
-
-    echo "    $f"
-done
-
-found=
-# The mt=41 sets a red background for matched trailing spaces
-GREP_COLORS='mt=41' GREP_COLOR='41' grep '[[:blank:]]\+$' include tests/*.{cpp,py,h} docs/*.rst -rn --color=always |
-        while read f; do
-    if [ -z "$found" ]; then
-        echo -e '\033[31m\033[01mError: found trailing spaces in the following files:\033[0m'
-        found=1
-        errors=1
-    fi
-
-    echo "    $f"
-done
-
-found=
-grep '\<\(if\|for\|while\|catch\)(\|){' include tests/*.{cpp,py,h} -rn --color=always |
-        while read line; do
-    if [ -z "$found" ]; then
-        echo -e '\033[31m\033[01mError: found the following coding style problems:\033[0m'
-        found=1
-        errors=1
-    fi
-
-    echo "    $line"
-done
-
-found=
-GREP_COLORS='mt=41' GREP_COLOR='41' grep '^\s*{\s*$' include docs/*.rst -rn --color=always |
-        while read f; do
-    if [ -z "$found" ]; then
-        echo -e '\033[31m\033[01mError: braces should occur on the same line as the if/while/.. statement. Found issues in the following files: \033[0m'
-        found=1
-        errors=1
-    fi
-
-    echo "    $f"
-done
-
-exit $errors
diff --git a/tmap/lib/pybind11/tools/libsize.py b/tmap/lib/pybind11/tools/libsize.py
deleted file mode 100644
index 5dcb8b0..0000000
--- a/tmap/lib/pybind11/tools/libsize.py
+++ /dev/null
@@ -1,38 +0,0 @@
-from __future__ import print_function, division
-import os
-import sys
-
-# Internal build script for generating debugging test .so size.
-# Usage:
-#     python libsize.py file.so save.txt -- displays the size of file.so and, if save.txt exists, compares it to the
-#                                           size in it, then overwrites save.txt with the new size for future runs.
-
-if len(sys.argv) != 3:
-    sys.exit("Invalid arguments: usage: python libsize.py file.so save.txt")
-
-lib = sys.argv[1]
-save = sys.argv[2]
-
-if not os.path.exists(lib):
-    sys.exit("Error: requested file ({}) does not exist".format(lib))
-
-libsize = os.path.getsize(lib)
-
-print("------", os.path.basename(lib), "file size:", libsize, end='')
-
-if os.path.exists(save):
-    with open(save) as sf:
-        oldsize = int(sf.readline())
-
-    if oldsize > 0:
-        change = libsize - oldsize
-        if change == 0:
-            print(" (no change)")
-        else:
-            print(" (change of {:+} bytes = {:+.2%})".format(change, change / oldsize))
-else:
-    print()
-
-with open(save, 'w') as sf:
-    sf.write(str(libsize))
-
diff --git a/tmap/lib/pybind11/tools/mkdoc.py b/tmap/lib/pybind11/tools/mkdoc.py
deleted file mode 100644
index 0c26a07..0000000
--- a/tmap/lib/pybind11/tools/mkdoc.py
+++ /dev/null
@@ -1,302 +0,0 @@
-#!/usr/bin/env python3
-#
-#  Syntax: mkdoc.py [-I<path> ..] [.. a list of header files ..]
-#
-#  Extract documentation from C++ header files to use it in Python bindings
-#
-
-import os
-import sys
-import platform
-import re
-import textwrap
-
-from clang import cindex
-from clang.cindex import CursorKind
-from collections import OrderedDict
-from threading import Thread, Semaphore
-from multiprocessing import cpu_count
-
-RECURSE_LIST = [
-    CursorKind.TRANSLATION_UNIT,
-    CursorKind.NAMESPACE,
-    CursorKind.CLASS_DECL,
-    CursorKind.STRUCT_DECL,
-    CursorKind.ENUM_DECL,
-    CursorKind.CLASS_TEMPLATE
-]
-
-PRINT_LIST = [
-    CursorKind.CLASS_DECL,
-    CursorKind.STRUCT_DECL,
-    CursorKind.ENUM_DECL,
-    CursorKind.ENUM_CONSTANT_DECL,
-    CursorKind.CLASS_TEMPLATE,
-    CursorKind.FUNCTION_DECL,
-    CursorKind.FUNCTION_TEMPLATE,
-    CursorKind.CONVERSION_FUNCTION,
-    CursorKind.CXX_METHOD,
-    CursorKind.CONSTRUCTOR,
-    CursorKind.FIELD_DECL
-]
-
-CPP_OPERATORS = {
-    '<=': 'le', '>=': 'ge', '==': 'eq', '!=': 'ne', '[]': 'array',
-    '+=': 'iadd', '-=': 'isub', '*=': 'imul', '/=': 'idiv', '%=':
-    'imod', '&=': 'iand', '|=': 'ior', '^=': 'ixor', '<<=': 'ilshift',
-    '>>=': 'irshift', '++': 'inc', '--': 'dec', '<<': 'lshift', '>>':
-    'rshift', '&&': 'land', '||': 'lor', '!': 'lnot', '~': 'bnot',
-    '&': 'band', '|': 'bor', '+': 'add', '-': 'sub', '*': 'mul', '/':
-    'div', '%': 'mod', '<': 'lt', '>': 'gt', '=': 'assign', '()': 'call'
-}
-
-CPP_OPERATORS = OrderedDict(
-    sorted(CPP_OPERATORS.items(), key=lambda t: -len(t[0])))
-
-job_count = cpu_count()
-job_semaphore = Semaphore(job_count)
-
-output = []
-
-def d(s):
-    return s.decode('utf8')
-
-
-def sanitize_name(name):
-    name = re.sub(r'type-parameter-0-([0-9]+)', r'T\1', name)
-    for k, v in CPP_OPERATORS.items():
-        name = name.replace('operator%s' % k, 'operator_%s' % v)
-    name = re.sub('<.*>', '', name)
-    name = ''.join([ch if ch.isalnum() else '_' for ch in name])
-    name = re.sub('_$', '', re.sub('_+', '_', name))
-    return '__doc_' + name
-
-
-def process_comment(comment):
-    result = ''
-
-    # Remove C++ comment syntax
-    leading_spaces = float('inf')
-    for s in comment.expandtabs(tabsize=4).splitlines():
-        s = s.strip()
-        if s.startswith('/*'):
-            s = s[2:].lstrip('*')
-        elif s.endswith('*/'):
-            s = s[:-2].rstrip('*')
-        elif s.startswith('///'):
-            s = s[3:]
-        if s.startswith('*'):
-            s = s[1:]
-        if len(s) > 0:
-            leading_spaces = min(leading_spaces, len(s) - len(s.lstrip()))
-        result += s + '\n'
-
-    if leading_spaces != float('inf'):
-        result2 = ""
-        for s in result.splitlines():
-            result2 += s[leading_spaces:] + '\n'
-        result = result2
-
-    # Doxygen tags
-    cpp_group = '([\w:]+)'
-    param_group = '([\[\w:\]]+)'
-
-    s = result
-    s = re.sub(r'\\c\s+%s' % cpp_group, r'``\1``', s)
-    s = re.sub(r'\\a\s+%s' % cpp_group, r'*\1*', s)
-    s = re.sub(r'\\e\s+%s' % cpp_group, r'*\1*', s)
-    s = re.sub(r'\\em\s+%s' % cpp_group, r'*\1*', s)
-    s = re.sub(r'\\b\s+%s' % cpp_group, r'**\1**', s)
-    s = re.sub(r'\\ingroup\s+%s' % cpp_group, r'', s)
-    s = re.sub(r'\\param%s?\s+%s' % (param_group, cpp_group),
-               r'\n\n$Parameter ``\2``:\n\n', s)
-    s = re.sub(r'\\tparam%s?\s+%s' % (param_group, cpp_group),
-               r'\n\n$Template parameter ``\2``:\n\n', s)
-
-    for in_, out_ in {
-        'return': 'Returns',
-        'author': 'Author',
-        'authors': 'Authors',
-        'copyright': 'Copyright',
-        'date': 'Date',
-        'remark': 'Remark',
-        'sa': 'See also',
-        'see': 'See also',
-        'extends': 'Extends',
-        'throw': 'Throws',
-        'throws': 'Throws'
-    }.items():
-        s = re.sub(r'\\%s\s*' % in_, r'\n\n$%s:\n\n' % out_, s)
-
-    s = re.sub(r'\\details\s*', r'\n\n', s)
-    s = re.sub(r'\\brief\s*', r'', s)
-    s = re.sub(r'\\short\s*', r'', s)
-    s = re.sub(r'\\ref\s*', r'', s)
-
-    s = re.sub(r'\\code\s?(.*?)\s?\\endcode',
-               r"```\n\1\n```\n", s, flags=re.DOTALL)
-
-    # HTML/TeX tags
-    s = re.sub(r'<tt>(.*?)</tt>', r'``\1``', s, flags=re.DOTALL)
-    s = re.sub(r'<pre>(.*?)</pre>', r"```\n\1\n```\n", s, flags=re.DOTALL)
-    s = re.sub(r'<em>(.*?)</em>', r'*\1*', s, flags=re.DOTALL)
-    s = re.sub(r'<b>(.*?)</b>', r'**\1**', s, flags=re.DOTALL)
-    s = re.sub(r'\\f\$(.*?)\\f\$', r'$\1$', s, flags=re.DOTALL)
-    s = re.sub(r'<li>', r'\n\n* ', s)
-    s = re.sub(r'</?ul>', r'', s)
-    s = re.sub(r'</li>', r'\n\n', s)
-
-    s = s.replace('``true``', '``True``')
-    s = s.replace('``false``', '``False``')
-
-    # Re-flow text
-    wrapper = textwrap.TextWrapper()
-    wrapper.expand_tabs = True
-    wrapper.replace_whitespace = True
-    wrapper.drop_whitespace = True
-    wrapper.width = 70
-    wrapper.initial_indent = wrapper.subsequent_indent = ''
-
-    result = ''
-    in_code_segment = False
-    for x in re.split(r'(```)', s):
-        if x == '```':
-            if not in_code_segment:
-                result += '```\n'
-            else:
-                result += '\n```\n\n'
-            in_code_segment = not in_code_segment
-        elif in_code_segment:
-            result += x.strip()
-        else:
-            for y in re.split(r'(?: *\n *){2,}', x):
-                wrapped = wrapper.fill(re.sub(r'\s+', ' ', y).strip())
-                if len(wrapped) > 0 and wrapped[0] == '$':
-                    result += wrapped[1:] + '\n'
-                    wrapper.initial_indent = \
-                        wrapper.subsequent_indent = ' ' * 4
-                else:
-                    if len(wrapped) > 0:
-                        result += wrapped + '\n\n'
-                    wrapper.initial_indent = wrapper.subsequent_indent = ''
-    return result.rstrip().lstrip('\n')
-
-
-def extract(filename, node, prefix):
-    if not (node.location.file is None or
-            os.path.samefile(d(node.location.file.name), filename)):
-        return 0
-    if node.kind in RECURSE_LIST:
-        sub_prefix = prefix
-        if node.kind != CursorKind.TRANSLATION_UNIT:
-            if len(sub_prefix) > 0:
-                sub_prefix += '_'
-            sub_prefix += d(node.spelling)
-        for i in node.get_children():
-            extract(filename, i, sub_prefix)
-    if node.kind in PRINT_LIST:
-        comment = d(node.raw_comment) if node.raw_comment is not None else ''
-        comment = process_comment(comment)
-        sub_prefix = prefix
-        if len(sub_prefix) > 0:
-            sub_prefix += '_'
-        if len(node.spelling) > 0:
-            name = sanitize_name(sub_prefix + d(node.spelling))
-            global output
-            output.append((name, filename, comment))
-
-
-class ExtractionThread(Thread):
-    def __init__(self, filename, parameters):
-        Thread.__init__(self)
-        self.filename = filename
-        self.parameters = parameters
-        job_semaphore.acquire()
-
-    def run(self):
-        print('Processing "%s" ..' % self.filename, file=sys.stderr)
-        try:
-            index = cindex.Index(cindex.conf.lib.clang_createIndex(False, True))
-            tu = index.parse(self.filename, self.parameters)
-            extract(self.filename, tu.cursor, '')
-        finally:
-            job_semaphore.release()
-
-if __name__ == '__main__':
-    parameters = ['-x', 'c++', '-std=c++11']
-    filenames = []
-
-    if platform.system() == 'Darwin':
-        dev_path = '/Applications/Xcode.app/Contents/Developer/'
-        lib_dir = dev_path + 'Toolchains/XcodeDefault.xctoolchain/usr/lib/'
-        sdk_dir = dev_path + 'Platforms/MacOSX.platform/Developer/SDKs'
-        libclang = lib_dir + 'libclang.dylib'
-        if os.path.exists(libclang):
-            cindex.Config.set_library_path(os.path.dirname(libclang))
-
-        if os.path.exists(sdk_dir):
-            sysroot_dir = os.path.join(sdk_dir, next(os.walk(sdk_dir))[1][0])
-            parameters.append('-isysroot')
-            parameters.append(sysroot_dir)
-
-    for item in sys.argv[1:]:
-        if item.startswith('-'):
-            parameters.append(item)
-        else:
-            filenames.append(item)
-
-    if len(filenames) == 0:
-        print('Syntax: %s [.. a list of header files ..]' % sys.argv[0])
-        exit(-1)
-
-    print('''/*
-  This file contains docstrings for the Python bindings.
-  Do not edit! These were automatically extracted by mkdoc.py
- */
-
-#define __EXPAND(x)                                      x
-#define __COUNT(_1, _2, _3, _4, _5, _6, _7, COUNT, ...)  COUNT
-#define __VA_SIZE(...)                                   __EXPAND(__COUNT(__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1))
-#define __CAT1(a, b)                                     a ## b
-#define __CAT2(a, b)                                     __CAT1(a, b)
-#define __DOC1(n1)                                       __doc_##n1
-#define __DOC2(n1, n2)                                   __doc_##n1##_##n2
-#define __DOC3(n1, n2, n3)                               __doc_##n1##_##n2##_##n3
-#define __DOC4(n1, n2, n3, n4)                           __doc_##n1##_##n2##_##n3##_##n4
-#define __DOC5(n1, n2, n3, n4, n5)                       __doc_##n1##_##n2##_##n3##_##n4##_##n5
-#define __DOC6(n1, n2, n3, n4, n5, n6)                   __doc_##n1##_##n2##_##n3##_##n4##_##n5##_##n6
-#define __DOC7(n1, n2, n3, n4, n5, n6, n7)               __doc_##n1##_##n2##_##n3##_##n4##_##n5##_##n6##_##n7
-#define DOC(...)                                         __EXPAND(__EXPAND(__CAT2(__DOC, __VA_SIZE(__VA_ARGS__)))(__VA_ARGS__))
-
-#if defined(__GNUG__)
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wunused-variable"
-#endif
-''')
-
-    output.clear()
-    for filename in filenames:
-        thr = ExtractionThread(filename, parameters)
-        thr.start()
-
-    print('Waiting for jobs to finish ..', file=sys.stderr)
-    for i in range(job_count):
-        job_semaphore.acquire()
-
-    name_ctr = 1
-    name_prev = None
-    for name, _, comment in list(sorted(output, key=lambda x: (x[0], x[1]))):
-        if name == name_prev:
-            name_ctr += 1
-            name = name + "_%i" % name_ctr
-        else:
-            name_prev = name
-            name_ctr = 1
-        print('\nstatic const char *%s =%sR"doc(%s)doc";' %
-              (name, '\n' if '\n' in comment else ' ', comment))
-
-    print('''
-#if defined(__GNUG__)
-#pragma GCC diagnostic pop
-#endif
-''')
diff --git a/tmap/lib/pybind11/tools/pybind11Config.cmake.in b/tmap/lib/pybind11/tools/pybind11Config.cmake.in
deleted file mode 100644
index 3dd1b2c..0000000
--- a/tmap/lib/pybind11/tools/pybind11Config.cmake.in
+++ /dev/null
@@ -1,100 +0,0 @@
-# pybind11Config.cmake
-# --------------------
-#
-# PYBIND11 cmake module.
-# This module sets the following variables in your project::
-#
-#   pybind11_FOUND - true if pybind11 and all required components found on the system
-#   pybind11_VERSION - pybind11 version in format Major.Minor.Release
-#   pybind11_INCLUDE_DIRS - Directories where pybind11 and python headers are located.
-#   pybind11_INCLUDE_DIR - Directory where pybind11 headers are located.
-#   pybind11_DEFINITIONS - Definitions necessary to use pybind11, namely USING_pybind11.
-#   pybind11_LIBRARIES - compile flags and python libraries (as needed) to link against.
-#   pybind11_LIBRARY - empty.
-#   CMAKE_MODULE_PATH - appends location of accompanying FindPythonLibsNew.cmake and
-#                       pybind11Tools.cmake modules.
-#
-#
-# Available components: None
-#
-#
-# Exported targets::
-#
-# If pybind11 is found, this module defines the following :prop_tgt:`IMPORTED`
-# interface library targets::
-#
-#   pybind11::module - for extension modules
-#   pybind11::embed - for embedding the Python interpreter
-#
-# Python headers, libraries (as needed by platform), and the C++ standard
-# are attached to the target. Set PythonLibsNew variables to influence
-# python detection and PYBIND11_CPP_STANDARD (-std=c++11 or -std=c++14) to
-# influence standard setting. ::
-#
-#   find_package(pybind11 CONFIG REQUIRED)
-#   message(STATUS "Found pybind11 v${pybind11_VERSION}: ${pybind11_INCLUDE_DIRS}")
-#
-#   # Create an extension module
-#   add_library(mylib MODULE main.cpp)
-#   target_link_libraries(mylib pybind11::module)
-#
-#   # Or embed the Python interpreter into an executable
-#   add_executable(myexe main.cpp)
-#   target_link_libraries(myexe pybind11::embed)
-#
-# Suggested usage::
-#
-# find_package with version info is not recommended except for release versions. ::
-#
-#   find_package(pybind11 CONFIG)
-#   find_package(pybind11 2.0 EXACT CONFIG REQUIRED)
-#
-#
-# The following variables can be set to guide the search for this package::
-#
-#   pybind11_DIR - CMake variable, set to directory containing this Config file
-#   CMAKE_PREFIX_PATH - CMake variable, set to root directory of this package
-#   PATH - environment variable, set to bin directory of this package
-#   CMAKE_DISABLE_FIND_PACKAGE_pybind11 - CMake variable, disables
-#     find_package(pybind11) when not REQUIRED, perhaps to force internal build
-
-@PACKAGE_INIT@
-
-set(PN pybind11)
-
-# location of pybind11/pybind11.h
-set(${PN}_INCLUDE_DIR "${PACKAGE_PREFIX_DIR}/@CMAKE_INSTALL_INCLUDEDIR@")
-
-set(${PN}_LIBRARY "")
-set(${PN}_DEFINITIONS USING_${PN})
-
-check_required_components(${PN})
-
-# make detectable the FindPythonLibsNew.cmake module
-list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR})
-
-include(pybind11Tools)
-
-if(NOT (CMAKE_VERSION VERSION_LESS 3.0))
-#-----------------------------------------------------------------------------
-# Don't include targets if this file is being picked up by another
-# project which has already built this as a subproject
-#-----------------------------------------------------------------------------
-if(NOT TARGET ${PN}::pybind11)
-    include("${CMAKE_CURRENT_LIST_DIR}/${PN}Targets.cmake")
-
-    find_package(PythonLibsNew ${PYBIND11_PYTHON_VERSION} MODULE REQUIRED)
-    set_property(TARGET ${PN}::pybind11 APPEND PROPERTY INTERFACE_INCLUDE_DIRECTORIES ${PYTHON_INCLUDE_DIRS})
-    set_property(TARGET ${PN}::embed APPEND PROPERTY INTERFACE_LINK_LIBRARIES ${PYTHON_LIBRARIES})
-    if(WIN32 OR CYGWIN)
-      set_property(TARGET ${PN}::module APPEND PROPERTY INTERFACE_LINK_LIBRARIES ${PYTHON_LIBRARIES})
-    endif()
-
-    set_property(TARGET ${PN}::pybind11 APPEND PROPERTY INTERFACE_COMPILE_OPTIONS "${PYBIND11_CPP_STANDARD}")
-
-    get_property(_iid TARGET ${PN}::pybind11 PROPERTY INTERFACE_INCLUDE_DIRECTORIES)
-    get_property(_ill TARGET ${PN}::module PROPERTY INTERFACE_LINK_LIBRARIES)
-    set(${PN}_INCLUDE_DIRS ${_iid})
-    set(${PN}_LIBRARIES ${_ico} ${_ill})
-endif()
-endif()
diff --git a/tmap/lib/pybind11/tools/pybind11Tools.cmake b/tmap/lib/pybind11/tools/pybind11Tools.cmake
deleted file mode 100644
index a7c471a..0000000
--- a/tmap/lib/pybind11/tools/pybind11Tools.cmake
+++ /dev/null
@@ -1,202 +0,0 @@
-# tools/pybind11Tools.cmake -- Build system for the pybind11 modules
-#
-# Copyright (c) 2015 Wenzel Jakob <wenzel@inf.ethz.ch>
-#
-# All rights reserved. Use of this source code is governed by a
-# BSD-style license that can be found in the LICENSE file.
-
-cmake_minimum_required(VERSION 2.8.12)
-
-# Add a CMake parameter for choosing a desired Python version
-if(NOT PYBIND11_PYTHON_VERSION)
-  set(PYBIND11_PYTHON_VERSION "" CACHE STRING "Python version to use for compiling modules")
-endif()
-
-set(Python_ADDITIONAL_VERSIONS 3.7 3.6 3.5 3.4)
-find_package(PythonLibsNew ${PYBIND11_PYTHON_VERSION} REQUIRED)
-
-include(CheckCXXCompilerFlag)
-include(CMakeParseArguments)
-
-if(NOT PYBIND11_CPP_STANDARD AND NOT CMAKE_CXX_STANDARD)
-  if(NOT MSVC)
-    check_cxx_compiler_flag("-std=c++14" HAS_CPP14_FLAG)
-
-    if (HAS_CPP14_FLAG)
-      set(PYBIND11_CPP_STANDARD -std=c++14)
-    else()
-      check_cxx_compiler_flag("-std=c++11" HAS_CPP11_FLAG)
-      if (HAS_CPP11_FLAG)
-        set(PYBIND11_CPP_STANDARD -std=c++11)
-      else()
-        message(FATAL_ERROR "Unsupported compiler -- pybind11 requires C++11 support!")
-      endif()
-    endif()
-  elseif(MSVC)
-    set(PYBIND11_CPP_STANDARD /std:c++14)
-  endif()
-
-  set(PYBIND11_CPP_STANDARD ${PYBIND11_CPP_STANDARD} CACHE STRING
-      "C++ standard flag, e.g. -std=c++11, -std=c++14, /std:c++14.  Defaults to C++14 mode." FORCE)
-endif()
-
-# Checks whether the given CXX/linker flags can compile and link a cxx file.  cxxflags and
-# linkerflags are lists of flags to use.  The result variable is a unique variable name for each set
-# of flags: the compilation result will be cached base on the result variable.  If the flags work,
-# sets them in cxxflags_out/linkerflags_out internal cache variables (in addition to ${result}).
-function(_pybind11_return_if_cxx_and_linker_flags_work result cxxflags linkerflags cxxflags_out linkerflags_out)
-  set(CMAKE_REQUIRED_LIBRARIES ${linkerflags})
-  check_cxx_compiler_flag("${cxxflags}" ${result})
-  if (${result})
-    set(${cxxflags_out} "${cxxflags}" CACHE INTERNAL "" FORCE)
-    set(${linkerflags_out} "${linkerflags}" CACHE INTERNAL "" FORCE)
-  endif()
-endfunction()
-
-# Internal: find the appropriate link time optimization flags for this compiler
-function(_pybind11_add_lto_flags target_name prefer_thin_lto)
-  if (NOT DEFINED PYBIND11_LTO_CXX_FLAGS)
-    set(PYBIND11_LTO_CXX_FLAGS "" CACHE INTERNAL "")
-    set(PYBIND11_LTO_LINKER_FLAGS "" CACHE INTERNAL "")
-
-    if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
-      set(cxx_append "")
-      set(linker_append "")
-      if (CMAKE_CXX_COMPILER_ID MATCHES "Clang" AND NOT APPLE)
-        # Clang Gold plugin does not support -Os; append -O3 to MinSizeRel builds to override it
-        set(linker_append ";$<$<CONFIG:MinSizeRel>:-O3>")
-      elseif(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
-        set(cxx_append ";-fno-fat-lto-objects")
-      endif()
-
-      if (CMAKE_CXX_COMPILER_ID MATCHES "Clang" AND prefer_thin_lto)
-        _pybind11_return_if_cxx_and_linker_flags_work(HAS_FLTO_THIN
-          "-flto=thin${cxx_append}" "-flto=thin${linker_append}"
-          PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)
-      endif()
-
-      if (NOT HAS_FLTO_THIN)
-        _pybind11_return_if_cxx_and_linker_flags_work(HAS_FLTO
-          "-flto${cxx_append}" "-flto${linker_append}"
-          PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)
-      endif()
-    elseif (CMAKE_CXX_COMPILER_ID MATCHES "Intel")
-      # Intel equivalent to LTO is called IPO
-      _pybind11_return_if_cxx_and_linker_flags_work(HAS_INTEL_IPO
-      "-ipo" "-ipo" PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)
-    elseif(MSVC)
-      # cmake only interprets libraries as linker flags when they start with a - (otherwise it
-      # converts /LTCG to \LTCG as if it was a Windows path).  Luckily MSVC supports passing flags
-      # with - instead of /, even if it is a bit non-standard:
-      _pybind11_return_if_cxx_and_linker_flags_work(HAS_MSVC_GL_LTCG
-        "/GL" "-LTCG" PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)
-    endif()
-
-    if (PYBIND11_LTO_CXX_FLAGS)
-      message(STATUS "LTO enabled")
-    else()
-      message(STATUS "LTO disabled (not supported by the compiler and/or linker)")
-    endif()
-  endif()
-
-  # Enable LTO flags if found, except for Debug builds
-  if (PYBIND11_LTO_CXX_FLAGS)
-    target_compile_options(${target_name} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:${PYBIND11_LTO_CXX_FLAGS}>")
-  endif()
-  if (PYBIND11_LTO_LINKER_FLAGS)
-    target_link_libraries(${target_name} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:${PYBIND11_LTO_LINKER_FLAGS}>")
-  endif()
-endfunction()
-
-# Build a Python extension module:
-# pybind11_add_module(<name> [MODULE | SHARED] [EXCLUDE_FROM_ALL]
-#                     [NO_EXTRAS] [THIN_LTO] source1 [source2 ...])
-#
-function(pybind11_add_module target_name)
-  set(options MODULE SHARED EXCLUDE_FROM_ALL NO_EXTRAS THIN_LTO)
-  cmake_parse_arguments(ARG "${options}" "" "" ${ARGN})
-
-  if(ARG_MODULE AND ARG_SHARED)
-    message(FATAL_ERROR "Can't be both MODULE and SHARED")
-  elseif(ARG_SHARED)
-    set(lib_type SHARED)
-  else()
-    set(lib_type MODULE)
-  endif()
-
-  if(ARG_EXCLUDE_FROM_ALL)
-    set(exclude_from_all EXCLUDE_FROM_ALL)
-  endif()
-
-  add_library(${target_name} ${lib_type} ${exclude_from_all} ${ARG_UNPARSED_ARGUMENTS})
-
-  target_include_directories(${target_name}
-    PRIVATE ${PYBIND11_INCLUDE_DIR}  # from project CMakeLists.txt
-    PRIVATE ${pybind11_INCLUDE_DIR}  # from pybind11Config
-    PRIVATE ${PYTHON_INCLUDE_DIRS})
-
-  # The prefix and extension are provided by FindPythonLibsNew.cmake
-  set_target_properties(${target_name} PROPERTIES PREFIX "${PYTHON_MODULE_PREFIX}")
-  set_target_properties(${target_name} PROPERTIES SUFFIX "${PYTHON_MODULE_EXTENSION}")
-
-  # -fvisibility=hidden is required to allow multiple modules compiled against
-  # different pybind versions to work properly, and for some features (e.g.
-  # py::module_local).  We force it on everything inside the `pybind11`
-  # namespace; also turning it on for a pybind module compilation here avoids
-  # potential warnings or issues from having mixed hidden/non-hidden types.
-  set_target_properties(${target_name} PROPERTIES CXX_VISIBILITY_PRESET "hidden")
-
-  if(WIN32 OR CYGWIN)
-    # Link against the Python shared library on Windows
-    target_link_libraries(${target_name} PRIVATE ${PYTHON_LIBRARIES})
-  elseif(APPLE)
-    # It's quite common to have multiple copies of the same Python version
-    # installed on one's system. E.g.: one copy from the OS and another copy
-    # that's statically linked into an application like Blender or Maya.
-    # If we link our plugin library against the OS Python here and import it
-    # into Blender or Maya later on, this will cause segfaults when multiple
-    # conflicting Python instances are active at the same time (even when they
-    # are of the same version).
-
-    # Windows is not affected by this issue since it handles DLL imports
-    # differently. The solution for Linux and Mac OS is simple: we just don't
-    # link against the Python library. The resulting shared library will have
-    # missing symbols, but that's perfectly fine -- they will be resolved at
-    # import time.
-
-    target_link_libraries(${target_name} PRIVATE "-undefined dynamic_lookup")
-
-    if(ARG_SHARED)
-      # Suppress CMake >= 3.0 warning for shared libraries
-      set_target_properties(${target_name} PROPERTIES MACOSX_RPATH ON)
-    endif()
-  endif()
-
-  # Make sure C++11/14 are enabled
-  target_compile_options(${target_name} PUBLIC ${PYBIND11_CPP_STANDARD})
-
-  if(ARG_NO_EXTRAS)
-    return()
-  endif()
-
-  _pybind11_add_lto_flags(${target_name} ${ARG_THIN_LTO})
-
-  if (NOT MSVC AND NOT ${CMAKE_BUILD_TYPE} MATCHES Debug)
-    # Strip unnecessary sections of the binary on Linux/Mac OS
-    if(CMAKE_STRIP)
-      if(APPLE)
-        add_custom_command(TARGET ${target_name} POST_BUILD
-                           COMMAND ${CMAKE_STRIP} -x $<TARGET_FILE:${target_name}>)
-      else()
-        add_custom_command(TARGET ${target_name} POST_BUILD
-                           COMMAND ${CMAKE_STRIP} $<TARGET_FILE:${target_name}>)
-      endif()
-    endif()
-  endif()
-
-  if(MSVC)
-    # /MP enables multithreaded builds (relevant when there are many files), /bigobj is
-    # needed for bigger binding projects due to the limit to 64k addressable sections
-    target_compile_options(${target_name} PRIVATE /MP /bigobj)
-  endif()
-endfunction()
