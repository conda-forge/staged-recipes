diff --git a/pkg/eventchannel/BUILD b/pkg/eventchannel/BUILD
deleted file mode 100644
index bee28b6..0000000
--- a/pkg/eventchannel/BUILD
+++ /dev/null
@@ -1,37 +0,0 @@
-load("//tools:defs.bzl", "go_library", "go_test", "proto_library")
-
-package(licenses = ["notice"])
-
-go_library(
-    name = "eventchannel",
-    srcs = [
-        "event.go",
-        "rate.go",
-    ],
-    visibility = ["//:sandbox"],
-    deps = [
-        ":eventchannel_go_proto",
-        "//pkg/log",
-        "//pkg/sync",
-        "//pkg/unet",
-        "@com_github_golang_protobuf//proto:go_default_library",
-        "@com_github_golang_protobuf//ptypes:go_default_library_gen",
-        "@org_golang_x_time//rate:go_default_library",
-    ],
-)
-
-proto_library(
-    name = "eventchannel",
-    srcs = ["event.proto"],
-    visibility = ["//:sandbox"],
-)
-
-go_test(
-    name = "eventchannel_test",
-    srcs = ["event_test.go"],
-    library = ":eventchannel",
-    deps = [
-        "//pkg/sync",
-        "@com_github_golang_protobuf//proto:go_default_library",
-    ],
-)
diff --git a/pkg/eventchannel/event.proto b/pkg/eventchannel/event.proto
deleted file mode 100644
index 34468f0..0000000
--- a/pkg/eventchannel/event.proto
+++ /dev/null
@@ -1,27 +0,0 @@
-// Copyright 2018 The gVisor Authors.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-syntax = "proto3";
-
-package gvisor;
-
-// A debug event encapsulates any other event protobuf in text format. This is
-// useful because clients reading events emitted this way do not need to link
-// the event protobufs to display them in a human-readable format.
-message DebugEvent {
-  // Name of the inner message.
-  string name = 1;
-  // Text representation of the inner message content.
-  string text = 2;
-}
diff --git a/pkg/eventchannel/event_test.go b/pkg/eventchannel/event_test.go
deleted file mode 100644
index 7f41b4a..0000000
--- a/pkg/eventchannel/event_test.go
+++ /dev/null
@@ -1,146 +0,0 @@
-// Copyright 2019 The gVisor Authors.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package eventchannel
-
-import (
-	"fmt"
-	"testing"
-	"time"
-
-	"github.com/golang/protobuf/proto"
-	"gvisor.dev/gvisor/pkg/sync"
-)
-
-// testEmitter is an emitter that can be used in tests. It records all events
-// emitted, and whether it has been closed.
-type testEmitter struct {
-	// mu protects all fields below.
-	mu sync.Mutex
-
-	// events contains all emitted events.
-	events []proto.Message
-
-	// closed records whether Close() was called.
-	closed bool
-}
-
-// Emit implements Emitter.Emit.
-func (te *testEmitter) Emit(msg proto.Message) (bool, error) {
-	te.mu.Lock()
-	defer te.mu.Unlock()
-	te.events = append(te.events, msg)
-	return false, nil
-}
-
-// Close implements Emitter.Close.
-func (te *testEmitter) Close() error {
-	te.mu.Lock()
-	defer te.mu.Unlock()
-	if te.closed {
-		return fmt.Errorf("closed called twice")
-	}
-	te.closed = true
-	return nil
-}
-
-// testMessage implements proto.Message for testing.
-type testMessage struct {
-	proto.Message
-
-	// name is the name of the message, used by tests to compare messages.
-	name string
-}
-
-func TestMultiEmitter(t *testing.T) {
-	// Create three testEmitters, tied together in a multiEmitter.
-	me := &multiEmitter{}
-	var emitters []*testEmitter
-	for i := 0; i < 3; i++ {
-		te := &testEmitter{}
-		emitters = append(emitters, te)
-		me.AddEmitter(te)
-	}
-
-	// Emit three messages to multiEmitter.
-	names := []string{"foo", "bar", "baz"}
-	for _, name := range names {
-		m := testMessage{name: name}
-		if _, err := me.Emit(m); err != nil {
-			t.Fatal("me.Emit(%v) failed: %v", m, err)
-		}
-	}
-
-	// All three emitters should have all three events.
-	for _, te := range emitters {
-		if got, want := len(te.events), len(names); got != want {
-			t.Fatalf("emitter got %d events, want %d", got, want)
-		}
-		for i, name := range names {
-			if got := te.events[i].(testMessage).name; got != name {
-				t.Errorf("emitter got message with name %q, want %q", got, name)
-			}
-		}
-	}
-
-	// Close multiEmitter.
-	if err := me.Close(); err != nil {
-		t.Fatal("me.Close() failed: %v", err)
-	}
-
-	// All testEmitters should be closed.
-	for _, te := range emitters {
-		if !te.closed {
-			t.Errorf("te.closed got false, want true")
-		}
-	}
-}
-
-func TestRateLimitedEmitter(t *testing.T) {
-	// Create a RateLimittedEmitter that wraps a testEmitter.
-	te := &testEmitter{}
-	max := float64(5) // events per second
-	burst := 10       // events
-	rle := RateLimitedEmitterFrom(te, max, burst)
-
-	// Send 50 messages in one shot.
-	for i := 0; i < 50; i++ {
-		if _, err := rle.Emit(testMessage{}); err != nil {
-			t.Fatalf("rle.Emit failed: %v", err)
-		}
-	}
-
-	// We should have received only 10 messages.
-	if got, want := len(te.events), 10; got != want {
-		t.Errorf("got %d events, want %d", got, want)
-	}
-
-	// Sleep for a second and then send another 50.
-	time.Sleep(1 * time.Second)
-	for i := 0; i < 50; i++ {
-		if _, err := rle.Emit(testMessage{}); err != nil {
-			t.Fatalf("rle.Emit failed: %v", err)
-		}
-	}
-
-	// We should have at least 5 more message, plus maybe a few more if the
-	// test ran slowly.
-	got, wantAtLeast, wantAtMost := len(te.events), 15, 20
-	if got < wantAtLeast {
-		t.Errorf("got %d events, want at least  %d", got, wantAtLeast)
-	}
-	if got > wantAtMost {
-		t.Errorf("got %d events, want at most %d", got, wantAtMost)
-	}
-}
diff --git a/pkg/eventchannel/eventchannel_go_proto/event.pb.go b/pkg/eventchannel/eventchannel_go_proto/event.pb.go
new file mode 100755
index 0000000..bb71ed3
--- /dev/null
+++ b/pkg/eventchannel/eventchannel_go_proto/event.pb.go
@@ -0,0 +1,85 @@
+// Code generated by protoc-gen-go. DO NOT EDIT.
+// source: pkg/eventchannel/event.proto
+
+package gvisor
+
+import (
+	fmt "fmt"
+	proto "github.com/golang/protobuf/proto"
+	math "math"
+)
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = fmt.Errorf
+var _ = math.Inf
+
+// This is a compile-time assertion to ensure that this generated file
+// is compatible with the proto package it is being compiled against.
+// A compilation error at this line likely means your copy of the
+// proto package needs to be updated.
+const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package
+
+type DebugEvent struct {
+	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	Text                 string   `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *DebugEvent) Reset()         { *m = DebugEvent{} }
+func (m *DebugEvent) String() string { return proto.CompactTextString(m) }
+func (*DebugEvent) ProtoMessage()    {}
+func (*DebugEvent) Descriptor() ([]byte, []int) {
+	return fileDescriptor_fcfbd51abd9de962, []int{0}
+}
+
+func (m *DebugEvent) XXX_Unmarshal(b []byte) error {
+	return xxx_messageInfo_DebugEvent.Unmarshal(m, b)
+}
+func (m *DebugEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	return xxx_messageInfo_DebugEvent.Marshal(b, m, deterministic)
+}
+func (m *DebugEvent) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_DebugEvent.Merge(m, src)
+}
+func (m *DebugEvent) XXX_Size() int {
+	return xxx_messageInfo_DebugEvent.Size(m)
+}
+func (m *DebugEvent) XXX_DiscardUnknown() {
+	xxx_messageInfo_DebugEvent.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_DebugEvent proto.InternalMessageInfo
+
+func (m *DebugEvent) GetName() string {
+	if m != nil {
+		return m.Name
+	}
+	return ""
+}
+
+func (m *DebugEvent) GetText() string {
+	if m != nil {
+		return m.Text
+	}
+	return ""
+}
+
+func init() {
+	proto.RegisterType((*DebugEvent)(nil), "gvisor.DebugEvent")
+}
+
+func init() { proto.RegisterFile("pkg/eventchannel/event.proto", fileDescriptor_fcfbd51abd9de962) }
+
+var fileDescriptor_fcfbd51abd9de962 = []byte{
+	// 103 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0x29, 0xc8, 0x4e, 0xd7,
+	0x4f, 0x2d, 0x4b, 0xcd, 0x2b, 0x49, 0xce, 0x48, 0xcc, 0xcb, 0x4b, 0xcd, 0x81, 0x70, 0xf4, 0x0a,
+	0x8a, 0xf2, 0x4b, 0xf2, 0x85, 0xd8, 0xd2, 0xcb, 0x32, 0x8b, 0xf3, 0x8b, 0x94, 0x4c, 0xb8, 0xb8,
+	0x5c, 0x52, 0x93, 0x4a, 0xd3, 0x5d, 0x41, 0x72, 0x42, 0x42, 0x5c, 0x2c, 0x79, 0x89, 0xb9, 0xa9,
+	0x12, 0x8c, 0x0a, 0x8c, 0x1a, 0x9c, 0x41, 0x60, 0x36, 0x48, 0xac, 0x24, 0xb5, 0xa2, 0x44, 0x82,
+	0x09, 0x22, 0x06, 0x62, 0x27, 0xb1, 0x81, 0x0d, 0x31, 0x06, 0x04, 0x00, 0x00, 0xff, 0xff, 0x17,
+	0xee, 0x7f, 0xef, 0x64, 0x00, 0x00, 0x00,
+}
