diff --git a/OctreeRefinement/include/p4est.h b/OctreeRefinement/include/p4est.h
deleted file mode 100644
index 530ba4b..0000000
--- a/OctreeRefinement/include/p4est.h
+++ /dev/null
@@ -1,495 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p4est.h
- *
- * The top-level 2D p4est interface.
- *
- * \ingroup p4est
- */
-
-/** \defgroup p4est p4est
- *
- * The 2D version of the p4est library.
- */
-
-#ifndef P4EST_H
-#define P4EST_H
-
-#ifdef P4EST_TO_P8EST_H
-#error "The include files p4est.h and p4est_to_p8est.h cannot be combined"
-#endif
-
-/* p4est_connectivity.h includes p4est_base.h sc_containers.h */
-#include <p4est_connectivity.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** The finest level of the quadtree for representing nodes */
-#define P4EST_MAXLEVEL 30
-
-/** The finest level of the quadtree for representing quadrants */
-#define P4EST_QMAXLEVEL 29
-
-/** The length of a side of the root quadrant */
-#define P4EST_ROOT_LEN ((p4est_qcoord_t) 1 << P4EST_MAXLEVEL)
-
-/** The length of a quadrant of level l */
-#define P4EST_QUADRANT_LEN(l) ((p4est_qcoord_t) 1 << (P4EST_MAXLEVEL - (l)))
-
-/** The offset of the highest (farthest from the origin) quadrant at level l
- */
-#define P4EST_LAST_OFFSET(l) (P4EST_ROOT_LEN - P4EST_QUADRANT_LEN (l))
-
-/** The 2D quadrant datatype */
-typedef struct p4est_quadrant
-{
-  /*@{ */
-  p4est_qcoord_t      x, y;  /**< coordinates */
-  /*@} */
-  int8_t              level,    /**< level of refinement */
-                      pad8;     /**< padding */
-  int16_t             pad16;    /**< padding */
-  union p4est_quadrant_data
-  {
-    void               *user_data;      /**< never changed by p4est */
-    long                user_long;      /**< never changed by p4est */
-    int                 user_int;       /**< never changed by p4est */
-    p4est_topidx_t      which_tree;     /**< the tree containing the quadrant
-                                             (used in auxiliary octants such
-                                             as the ghost octants in
-                                             p4est_ghost_t) */
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      int                 owner_rank;
-    }
-    piggy1; /**< of ghost octants, store the tree and owner rank */
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_topidx_t      from_tree;
-    }
-    piggy2; /**< of transformed octants, store the original tree and the
-                 target tree */
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_locidx_t      local_num;
-    }
-    piggy3; /**< of ghost octants, store the tree and index in the owner's
-                 numbering */
-  }
-  p; /**< a union of additional data attached to a quadrant */
-}
-p4est_quadrant_t;
-
-/** The p4est tree datatype */
-typedef struct p4est_tree
-{
-  sc_array_t          quadrants;             /**< locally stored quadrants */
-  p4est_quadrant_t    first_desc,            /**< first local descendant */
-                      last_desc;             /**< last local descendant */
-  p4est_locidx_t      quadrants_offset;      /**< cumulative sum over earlier
-                                                  trees on this processor
-                                                  (locals only) */
-  p4est_locidx_t      quadrants_per_level[P4EST_MAXLEVEL + 1];
-                                             /**< locals only */
-  int8_t              maxlevel;              /**< highest local quadrant level */
-}
-p4est_tree_t;
-
-/** Data pertaining to selecting, inspecting, and profiling algorithms.
- * A pointer to this structure is hooked into the p4est main structure.
- * Declared in p4est_extended.h.  Used to profile important algorithms.
- */
-typedef struct p4est_inspect p4est_inspect_t;
-
-/** The p4est forest datatype */
-typedef struct p4est
-{
-  sc_MPI_Comm         mpicomm;          /**< MPI communicator */
-  int                 mpisize,          /**< number of MPI processes */
-                      mpirank;          /**< this process's MPI rank */
-  int                 mpicomm_owned;    /**< flag if communicator is owned */
-  size_t              data_size;        /**< size of per-quadrant p.user_data
-                     (see p4est_quadrant_t::p4est_quadrant_data::user_data) */
-  void               *user_pointer;     /**< convenience pointer for users,
-                                             never touched by p4est */
-
-  long                revision;         /**< Gets bumped on mesh change */
-  p4est_topidx_t      first_local_tree; /**< 0-based index of first local
-                                             tree, must be -1 for an empty
-                                             processor */
-  p4est_topidx_t      last_local_tree;  /**< 0-based index of last local
-                                             tree, must be -2 for an empty
-                                             processor */
-  p4est_locidx_t      local_num_quadrants;   /**< number of quadrants on all
-                                                  trees on this processor */
-  p4est_gloidx_t      global_num_quadrants;  /**< number of quadrants on all
-                                                  trees on all processors */
-  p4est_gloidx_t     *global_first_quadrant; /**< first global quadrant index
-                                                  for each process and 1
-                                                  beyond */
-  p4est_quadrant_t   *global_first_position; /**< first smallest possible quad
-                                                  for each process and 1
-                                                  beyond */
-  p4est_connectivity_t *connectivity; /**< connectivity structure, not owned */
-  sc_array_t         *trees;          /**< array of all trees */
-
-  sc_mempool_t       *user_data_pool; /**< memory allocator for user data */
-  /*   WARNING: This is NULL if data size
-     equals zero. */
-  sc_mempool_t       *quadrant_pool;  /**< memory allocator for temporary
-                                           quadrants */
-  p4est_inspect_t    *inspect;        /**< algorithmic switches */
-}
-p4est_t;
-
-/** Calculate local memory usage of a forest structure.
- * Not collective.  The memory used on the current rank is returned.
- * The connectivity structure is not counted since it is not owned;
- * use p4est_connectivity_memory_usage (p4est->connectivity).
- * \param [in] p4est    Valid forest structure.
- * \return              Memory used in bytes.
- */
-size_t              p4est_memory_used (p4est_t * p4est);
-
-/** Return the revision counter of the forest.
- * Not collective, even though the revision value is the same on all ranks.
- * A newly created forest starts with a revision counter of zero.
- * Every refine, coarsen, partition, and balance that actually changes the mesh
- * increases the counter by one.  Operations with no effect keep the old value.
- * \param [in] p8est    The forest must be valid.
- * \return              Non-negative number.
- */
-long                p4est_revision (p4est_t * p4est);
-
-/** Callback function prototype to initialize the quadrant's user data.
- * \param [in] p4est         the forest
- * \param [in] which_tree    the tree containing \a quadrant
- * \param [in,out] quadrant  the quadrant to be initialized: if data_size > 0,
- *                           the data to be initialized is at
- *                           \a quadrant->p.user_data; otherwise, the
- *                           non-pointer user data (such as
- *                           \a quadrant->p.user_int) can be initialized
- */
-typedef void        (*p4est_init_t) (p4est_t * p4est,
-                                     p4est_topidx_t which_tree,
-                                     p4est_quadrant_t * quadrant);
-
-/** Callback function prototype to decide for refinement.
- * \param [in] p4est       the forest
- * \param [in] which_tree  the tree containing \a quadrant
- * \param [in] quadrant    the quadrant that may be refined
- * \return nonzero if the quadrant shall be refined.
- */
-typedef int         (*p4est_refine_t) (p4est_t * p4est,
-                                       p4est_topidx_t which_tree,
-                                       p4est_quadrant_t * quadrant);
-
-/** Callback function prototype to decide for coarsening.
- * \param [in] p4est       the forest
- * \param [in] which_tree  the tree containing \a quadrant
- * \param [in] quadrants   Pointers to 4 siblings in Morton ordering.
- * \return nonzero if the quadrants shall be replaced with their parent.
- */
-typedef int         (*p4est_coarsen_t) (p4est_t * p4est,
-                                        p4est_topidx_t which_tree,
-                                        p4est_quadrant_t * quadrants[]);
-
-/** Callback function prototype to calculate weights for partitioning.
- * \param [in] p4est       the forest
- * \param [in] which_tree  the tree containing \a quadrant
- * \return a 32bit integer >= 0 as the quadrant weight.
- * \note    Global sum of weights must fit into a 64bit integer.
- */
-typedef int         (*p4est_weight_t) (p4est_t * p4est,
-                                       p4est_topidx_t which_tree,
-                                       p4est_quadrant_t * quadrant);
-
-extern void        *P4EST_DATA_UNINITIALIZED;
-
-/** set statically allocated quadrant to defined values */
-#define P4EST_QUADRANT_INIT(q) \
-  ((void) memset ((q), -1, sizeof (p4est_quadrant_t)))
-
-/** Transform a quadrant coordinate into the space spanned by tree vertices.
- * \param [in] connectivity     Connectivity must provide the vertices.
- * \param [in] treeid           Identify the tree that contains x, y.
- * \param [in] x, y             Quadrant coordinates relative to treeid.
- * \param [out] vxyz            Transformed coordinates in vertex space.
- */
-void                p4est_qcoord_to_vertex (p4est_connectivity_t *
-                                            connectivity,
-                                            p4est_topidx_t treeid,
-                                            p4est_qcoord_t x,
-                                            p4est_qcoord_t y, double vxyz[3]);
-
-/** Create a new forest.
- * The new forest consists of equi-partitioned root quadrants.
- * When there are more processors than trees, some processors are empty.
- *
- * \param [in] mpicomm       A valid MPI communicator.
- * \param [in] connectivity  This is the connectivity information that
- *                           the forest is built with.  Note the p4est
- *                           does not take ownership of the memory.
- * \param [in] data_size     This is the size of data for each quadrant which
- *                           can be zero.  Then user_data_pool is set to NULL.
- * \param [in] init_fn       Callback function to initialize the user_data
- *                           which is already allocated automatically.
- * \param [in] user_pointer  Assign to the user_pointer member of the p4est
- *                           before init_fn is called the first time.
- *
- * \return This returns a valid forest.
- *
- * \note The connectivity structure must not be destroyed
- *       during the lifetime of this forest.
- */
-p4est_t            *p4est_new (sc_MPI_Comm mpicomm,
-                               p4est_connectivity_t * connectivity,
-                               size_t data_size,
-                               p4est_init_t init_fn, void *user_pointer);
-
-/** Destroy a p4est.
- *
- * \note The connectivity structure is not destroyed with the p4est.
- */
-void                p4est_destroy (p4est_t * p4est);
-
-/** Make a deep copy of a p4est.
- * The connectivity is not duplicated.
- * Copying of quadrant user data is optional.
- * If old and new data sizes are 0, the user_data field is copied regardless.
- * The inspect member of the copy is set to NULL.
- * The revision counter of the copy is set to zero.
- *
- * \param [in]  copy_data  If true, data are copied.
- *                         If false, data_size is set to 0.
- * \return  Returns a valid p4est that does not depend on the input,
- *                         except for borrowing the same connectivity.
- *                         Its revision counter is 0.
- */
-p4est_t            *p4est_copy (p4est_t * input, int copy_data);
-
-/** Reset user pointer and element data.
- * When the data size is changed the quadrant data is freed and allocated.
- * The initialization callback is invoked on each quadrant.
- * Old user_data content is disregarded.
- *
- * \param [in] data_size     This is the size of data for each quadrant which
- *                           can be zero.  Then user_data_pool is set to NULL.
- * \param [in] init_fn       Callback function to initialize the user_data
- *                           which is already allocated automatically.
- *                           May be NULL.
- * \param [in] user_pointer  Assign to the user_pointer member of the p4est
- *                           before init_fn is called the first time.
- */
-void                p4est_reset_data (p4est_t * p4est, size_t data_size,
-                                      p4est_init_t init_fn,
-                                      void *user_pointer);
-
-/** Refine a forest.
- * \param [in,out] p4est The forest is changed in place.
- * \param [in] refine_recursive Boolean to decide on recursive refinement.
- * \param [in] refine_fn Callback function that must return true if a quadrant
- *                       shall be refined.  If refine_recursive is true,
- *                       refine_fn is called for every existing and newly
- *                       created quadrant.  Otherwise, it is called for every
- *                       existing quadrant.  It is possible that a refinement
- *                       request made by the callback is ignored.  To catch
- *                       this case, you can examine whether init_fn gets
- *                       called, or use p4est_refine_ext in p4est_extended.h
- *                       and examine whether replace_fn gets called.
- * \param [in] init_fn   Callback function to initialize the user_data of newly
- *                       created quadrants, which is already allocated.  This
- *                       function pointer may be NULL.
- */
-void                p4est_refine (p4est_t * p4est,
-                                  int refine_recursive,
-                                  p4est_refine_t refine_fn,
-                                  p4est_init_t init_fn);
-
-/** Coarsen a forest.
- * \param [in,out] p4est  The forest is changed in place.
- * \param [in] coarsen_recursive Boolean to decide on recursive coarsening.
- * \param [in] coarsen_fn Callback function that returns true if a
- *                        family of quadrants shall be coarsened
- * \param [in] init_fn    Callback function to initialize the user_data
- *                        which is already allocated automatically.
- */
-void                p4est_coarsen (p4est_t * p4est,
-                                   int coarsen_recursive,
-                                   p4est_coarsen_t coarsen_fn,
-                                   p4est_init_t init_fn);
-
-/** 2:1 balance the size differences of neighboring elements in a forest.
- * \param [in,out] p4est  The p4est to be worked on.
- * \param [in] btype      Balance type (face or corner/full).
- *                        Corner balance is almost never required when
- *                        discretizing a PDE; just causes smoother mesh grading.
- * \param [in] init_fn    Callback function to initialize the user_data
- *                        which is already allocated automatically.
- */
-void                p4est_balance (p4est_t * p4est,
-                                   p4est_connect_type_t btype,
-                                   p4est_init_t init_fn);
-
-/** Equally partition the forest.
- * The partition can be by element count or by a user-defined weight.
- *
- * The forest will be partitioned between processors such that they
- * have an approximately equal number of quadrants (or sum of weights).
- *
- * \param [in,out] p4est      The forest that will be partitioned.
- * \param [in]     allow_for_coarsening Slightly modify partition such that
- *                            quadrant families are not split between ranks.
- * \param [in]     weight_fn  A weighting function or NULL
- *                            for uniform partitioning.
- */
-void                p4est_partition (p4est_t * p4est,
-                                     int allow_for_coarsening,
-                                     p4est_weight_t weight_fn);
-
-/** Compute the checksum for a forest.
- * Based on quadrant arrays only. It is independent of partition and mpisize.
- * \return  Returns the checksum on processor 0 only. 0 on other processors.
- */
-unsigned            p4est_checksum (p4est_t * p4est);
-
-/** Save the complete connectivity/p4est data to disk.
- *
- * This is a collective operation that all MPI processes need to call.  All
- * processes write into the same file, so the filename given needs to be
- * identical over all parallel invocations.
- *
- * By default, we write the current processor count and partition into the file
- * header.  This makes the file depend on mpisize.  For changing this see
- * p4est_save_ext() in p4est_extended.h.
- *
- * The revision counter is not saved to the file, since that would make files
- * different that come from different revisions but store the same mesh.
- *
- * \param [in] filename    Name of the file to write.
- * \param [in] p4est       Valid forest structure.
- * \param [in] save_data   If true, the element data is saved.
- *                         Otherwise, a data size of 0 is saved.
- * \note            Aborts on file errors.
- * \note            If p4est is not configured to use MPI-IO, some processes
- *                  return from this function before the file is complete, in
- *                  which case immediate read-access to the file may require a
- *                  call to sc_MPI_Barrier.
- */
-void                p4est_save (const char *filename, p4est_t * p4est,
-                                int save_data);
-
-/** Load the complete connectivity/p4est structure from disk.
- *
- * This is a collective operation that all MPI processes need to call.  All
- * processes read from the same file, so the filename given needs to be
- * identical over all parallel invocations.
- *
- * By default, a file can only be loaded with the same number of processors
- * that it was stored with.  The defaults can be changed with p4est_load_ext()
- * in p4est_extended.h.
- *
- * The revision counter of the loaded p4est is set to zero.
- *
- * \param [in] filename         Name of the file to read.
- * \param [in] mpicomm          A valid MPI communicator.
- * \param [in] data_size        Size of data for each quadrant which can be
- *                              zero.  Then user_data_pool is set to NULL.
- *                              If data_size is zero, load_data is ignored.
- * \param [in] load_data        If true, the element data is loaded.  This is
- *                              only permitted if the saved data size matches.
- *                              If false, the stored data size is ignored.
- * \param [in] user_pointer     Assign to the user_pointer member of the p4est
- *                              before init_fn is called the first time.
- * \param [out] connectivity    Connectivity must be destroyed separately.
- * \return          Returns a valid forest structure. A pointer to a valid
- *                  connectivity structure is returned through the last
- *                  argument.
- * \note            Aborts on file errors or invalid file contents.
- */
-p4est_t            *p4est_load (const char *filename, sc_MPI_Comm mpicomm,
-                                size_t data_size, int load_data,
-                                void *user_pointer,
-                                p4est_connectivity_t ** connectivity);
-
-/** Return a pointer to an array element indexed by a p4est_topidx_t.
- * \param [in] index needs to be in [0]..[elem_count-1].
- */
-/*@unused@*/
-static inline p4est_tree_t *
-p4est_tree_array_index (sc_array_t * array, p4est_topidx_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p4est_tree_t));
-  P4EST_ASSERT (it >= 0 && (size_t) it < array->elem_count);
-
-  return (p4est_tree_t *) (array->array +
-                           sizeof (p4est_tree_t) * (size_t) it);
-}
-
-/** Return a pointer to a quadrant array element indexed by a size_t. */
-/*@unused@*/
-static inline p4est_quadrant_t *
-p4est_quadrant_array_index (sc_array_t * array, size_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p4est_quadrant_t));
-  P4EST_ASSERT (it < array->elem_count);
-
-  return (p4est_quadrant_t *) (array->array + sizeof (p4est_quadrant_t) * it);
-}
-
-/** Call sc_array_push for a quadrant array. */
-/*@unused@*/
-static inline p4est_quadrant_t *
-p4est_quadrant_array_push (sc_array_t * array)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p4est_quadrant_t));
-
-  return (p4est_quadrant_t *) sc_array_push (array);
-}
-
-/** Call sc_mempool_alloc for a mempool creating quadrants. */
-/*@unused@*/
-static inline p4est_quadrant_t *
-p4est_quadrant_mempool_alloc (sc_mempool_t * mempool)
-{
-  P4EST_ASSERT (mempool->elem_size == sizeof (p4est_quadrant_t));
-
-  return (p4est_quadrant_t *) sc_mempool_alloc (mempool);
-}
-
-/** Call sc_list pop for a quadrant array. */
-/*@unused@*/
-static inline p4est_quadrant_t *
-p4est_quadrant_list_pop (sc_list_t * list)
-{
-  return (p4est_quadrant_t *) sc_list_pop (list);
-}
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_H */
diff --git a/OctreeRefinement/include/p4est_algorithms.h b/OctreeRefinement/include/p4est_algorithms.h
deleted file mode 100644
index 0ac750a..0000000
--- a/OctreeRefinement/include/p4est_algorithms.h
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P4EST_ALGORITHMS_H
-#define P4EST_ALGORITHMS_H
-
-#include <p4est.h>
-#include <p4est_extended.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Alloc and initialize the user data of a valid quadrant.
- * \param [in]  which_tree 0-based index of this quadrant's tree.
- * \param [in,out]  quad       The quadrant to be initialized.
- * \param [in]  init_fn    User-supplied callback function to init data.
- */
-void                p4est_quadrant_init_data (p4est_t * p4est,
-                                              p4est_topidx_t which_tree,
-                                              p4est_quadrant_t * quad,
-                                              p4est_init_t init_fn);
-
-/** Free the user data of a valid quadrant.
- * \param [in,out]  quad The quadrant whose data shall be freed.
- */
-void                p4est_quadrant_free_data (p4est_t * p4est,
-                                              p4est_quadrant_t * quad);
-
-/** Computes a machine-independent checksum of a list of quadrants.
- * \param [in] quadrants       Array of quadrants.
- * \param [in,out] checkarray  Temporary array of elem_size 4.
- *                             Will be resized to quadrants->elem_count * 3.
- *                             If it is NULL, will be allocated internally.
- * \param [in] first_quadrant  Index of the quadrant to start with.
- *                             Can be between 0 and elem_count (inclusive).
- */
-unsigned            p4est_quadrant_checksum (sc_array_t * quadrants,
-                                             sc_array_t * checkarray,
-                                             size_t first_quadrant);
-
-/** Test if a tree is sorted in Morton ordering.
- * \return Returns true if sorted, false otherwise.
- * \note Duplicate quadrants are not allowed.
- */
-int                 p4est_tree_is_sorted (p4est_tree_t * tree);
-
-/** Test if a tree is sorted in Morton ordering and linear.
- * \return Returns true if linear, false otherwise.
- * \note Linear means that the tree has no overlaps.
- */
-int                 p4est_tree_is_linear (p4est_tree_t * tree);
-
-/** Test if a tree is sorted in Morton ordering and complete.
- * \return Returns true if complete, false otherwise.
- * \note Complete means that the tree has no holes and no overlaps.
- */
-int                 p4est_tree_is_complete (p4est_tree_t * tree);
-
-/** Check if a tree is sorted/linear except for diagonally outside corners.
- * \param [in]  check_linearity  Boolean for additional check for linearity.
- * \return Returns true if almost sorted/linear, false otherwise.
- */
-int                 p4est_tree_is_almost_sorted (p4est_tree_t * tree,
-                                                 int check_linearity);
-
-/** Print the quadrants in a tree.
- * Prints one line per quadrant with x, y, level and a string.
- * The string denotes the relation to the previous quadrant and can be:
- *   Fn  for the first quadrant in the tree with child id n
- *   I   for identical quadrants
- *   R   for a quadrant that with smaller Morton index
- *   Cn  for child id n
- *   Sn  for sibling with child id n
- *   D   for a descendant
- *   Nn   for a next quadrant in the tree with no holes in between and child id n
- *   qn  for a general quadrant whose child id is n
- * \param [in] tree        Any (possibly incomplete, unsorted) tree to be printed.
- */
-void                p4est_tree_print (int log_priority, p4est_tree_t * tree);
-
-/** Locally check forest/connectivity structures for equality.
- * \param [in] p4est1    The first forest to be compared.
- * \param [in] p4est2    The second forest to be compared.
- * \param [in] compare_data     Also check if quadrant data are identical.
- * \return          Returns true if forests and their connectivities are equal.
- */
-int                 p4est_is_equal (p4est_t * p4est1, p4est_t * p4est2,
-                                    int compare_data);
-
-/** Check a forest for validity and allreduce the result.
- * Some properties of a valid forest are:
- *    the quadrant counters are consistent
- *    all trees are complete
- *    all non-local trees are empty
- * This function is collective!
- * It is also relatively expensive, so its use in production should be limited.
- * \param [in] p4est    The forest to be tested.
- *                      Itself and its connectivity must be non-NULL.
- * \return              Returns true if valid, false otherwise.
- */
-int                 p4est_is_valid (p4est_t * p4est);
-
-/** Compute the overlap of a number of insulation layers with a tree.
- * Every quadrant out of the insulation layer of the quadrants in \a in
- * except the quadrant itself is checked for overlap of quadrants
- * from all trees that are smaller by at least two levels and thus
- * can cause a split. Those elements that cause a split (as determined by the
- * p4est_balance_*_test routines) create quadrants in \a out that will
- * reproduce those splits when \a in is balanced.
- * Note: Use this version if you are using less than full balance.
- *
- * \param [in] p4est    The p4est to work on.
- * \param [in] in       A piggy-sorted linear list of quadrants.
- *                      The piggy2->from_tree member must be set.
- * \param [in,out] out  A piggy-sorted subset of tree->quadrants.
- * \param [in] balance  The type of balance condition that should be enforced.
- * \param [in] borders  Array of arrays of tree border elements: if not NULL,
- *                      this will be used to fill \a out.
- * \param [in] inseeds  The seeds that \a in generates locally.
- */
-void                p4est_tree_compute_overlap (p4est_t * p4est,
-                                                sc_array_t * in,
-                                                sc_array_t * out,
-                                                p4est_connect_type_t balance,
-                                                sc_array_t * borders,
-                                                sc_array_t * inseeds);
-
-/** Gets the reduced representation of the overlap that results from using
- * p4est_tree_compute_overlap_new
- * \param [in,out] out  A piggy-sorted subset of tree->quadrants.
-  */
-void                p4est_tree_uniqify_overlap (sc_array_t * out);
-
-/** Removes quadrants that are outside the owned tree boundaries from a tree.
- * \param [in,out] p4est    The p4est to work on.
- * \param [in] which_tree   Index to a sorted owned tree in the p4est.
- * \return                  Returns the number of removed quadrants.
- */
-size_t              p4est_tree_remove_nonowned (p4est_t * p4est,
-                                                p4est_topidx_t which_tree);
-
-/** Constructs a minimal linear octree between two octants.
- *
- * This is alogorithm 2 from H. Sundar, R.S. Sampath and G. Biros
- * with the additional improvements that we do not require sorting
- * and the runtime is O(N).
- *
- * \pre \a q1 < \a q2 in the Morton ordering.
- *
- * \param [in]  p4est      Used for the memory pools and quadrant init.
- * \param [in]  q1         First input quadrant.  Data init'ed if included.
- * \param [in]  include_q1 Flag to specify whether q1 is included.
- * \param [in]  q2         Second input quadrant.  Data init'ed if included.
- * \param [in]  include_q2 Flag to specify whether q2 is included.
- * \param [out] tree       Initialized tree with zero elements.
- * \param [in]  which_tree The 0-based index of \a tree which is needed for
- *                         the \c p4est_quadrant_init_data routine.
- * \param [in]  init_fn    Callback function to initialize the user_data
- *                         which is already allocated automatically.
- */
-void                p4est_complete_region (p4est_t * p4est,
-                                           const p4est_quadrant_t * q1,
-                                           int include_q1,
-                                           const p4est_quadrant_t * q2,
-                                           int include_q2,
-                                           p4est_tree_t * tree,
-                                           p4est_topidx_t which_tree,
-                                           p4est_init_t init_fn);
-
-/** Completes a sorted tree within a p4est. It may have exterior quadrants.
- * The completed tree will have only owned quadrants and no overlap.
- * Note that the tree's counters (\a quadrants_per_level, \a maxlevel) must be
- * correct for the quadrants in the incoming tree.
- *
- * \param [in,out] p4est      The p4est to work on.
- * \param [in]     which_tree The 0-based index of the subtree to complete.
- * \param [in]     init_fn    Callback function to initialize the user_data
- *                            which is already allocated automatically.
- */
-void                p4est_complete_subtree (p4est_t * p4est,
-                                            p4est_topidx_t which_tree,
-                                            p4est_init_t init_fn);
-
-/** Balances a sorted tree within a p4est. It may have exterior quadrants.
- * The completed tree will have only owned quadrants and no overlap.
- * \param [in,out] p4est      The p4est to work on.
- * \param [in]     btype      The balance type (face or corner).
- * \param [in]     which_tree The 0-based index of the subtree to balance.
- * \param [in]     init_fn    Callback function to initialize the user_data
- *                            which is already allocated automatically.
- */
-void                p4est_balance_subtree (p4est_t * p4est,
-                                           p4est_connect_type_t btype,
-                                           p4est_topidx_t which_tree,
-                                           p4est_init_t init_fn);
-
-void                p4est_balance_border (p4est_t * p4est,
-                                          p4est_connect_type_t btype,
-                                          p4est_topidx_t which_tree,
-                                          p4est_init_t init_fn,
-                                          p4est_replace_t replace_fn,
-                                          sc_array_t * borders);
-
-/** Remove overlaps from a sorted list of quadrants.
- *
- * This is alogorithm 8 from H. Sundar, R.S. Sampath and G. Biros
- * with the additional improvement that it works in-place.
- *
- * \param [in]     p4est used for the memory pool and quadrant free.
- * \param [in,out] tree   A sorted tree to be linearized in-place.
- * \return                Returns the number of removed quadrants.
- */
-size_t              p4est_linearize_tree (p4est_t * p4est,
-                                          p4est_tree_t * tree);
-
-/** Compute correction of partition for a process.
- *
- * The correction denotes how many quadrants the process with id \a rank takes
- * from (if correction positive) or gives to (if correction negative) the
- * previous process with id \a rank-1 in order to assign a family of quadrants
- * to one process.
- * The process with the highest number of quadrants of a family gets all
- * quadrants belonging to this family from other processes. If this applies to
- * several processes, then the process with the lowest id gets the quadrants.
- * A process can give more quadrants than it owns, if it passes quadrants from
- * other processes.
- *
- * \param [in] partition       first global quadrant index for each process (+1)
- * \param [in] num_procs       number of processes
- * \param [in] rank            process id for which correction is computed
- * \param [in] min_quadrant_id minimal global quadrant index of family
- * \param [in] max_quadrant_id maximal global quadrant index of family
- * \return                     correction for process \a rank
- */
-p4est_locidx_t      p4est_partition_correction (p4est_gloidx_t *
-                                                partition,
-                                                int num_procs,
-                                                int rank,
-                                                p4est_gloidx_t
-                                                min_quadrant_id,
-                                                p4est_gloidx_t
-                                                max_quadrant_id);
-
-/** Correct partition counters to allow one level of coarsening.
- * No quadrants are actually shipped, just the desired number is updated.
- * This function guarantees that empty processors remain empty.
- * This function is collective and acts as a synchronization point.
- *
- * \param [in] p4est                     forest whose partition is corrected
- * \param [in,out] num_quadrants_in_proc partition that will be corrected
- * \return                               total absolute number of moved
- *                                       quadrants.  In practice, at most
- *                                       a small number per processor.
- */
-p4est_gloidx_t      p4est_partition_for_coarsening (p4est_t * p4est,
-                                                    p4est_locidx_t *
-                                                    num_quadrants_in_proc);
-
-/** Find next non-empty process.
- *
- * Finds the next process id >= \a rank which is not empty according to
- * \a num_quadrants_in_proc.
- *
- * \param [in] rank                  process id where search starts
- * \param [in] num_proc              number of processes
- * \param [in] num_quadrants_in_proc number of quadrants for each process
- * \return                           process id of a non empty process
- */
-int                 p4est_next_nonempty_process (int rank,
-                                                 int num_procs,
-                                                 p4est_locidx_t *
-                                                 num_quadrants_in_proc);
-
-/** Partition \a p4est given the number of quadrants per proc.
- *
- * Given the desired number of quadrants per proc \a num_quadrants_in_proc
- * the forest \a p4est is partitioned.
- *
- * \param [in,out] p4est the forest that is partitioned.
- * \param [in]     num_quadrants_in_proc  an integer array of the number of
- *                                        quadrants desired per processor.
- * \return  Returns the global count of shipped quadrants.
- */
-p4est_gloidx_t      p4est_partition_given (p4est_t * p4est,
-                                           const p4est_locidx_t *
-                                           num_quadrants_in_proc);
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_ALGORITHMS_H */
diff --git a/OctreeRefinement/include/p4est_balance.h b/OctreeRefinement/include/p4est_balance.h
deleted file mode 100644
index 1160033..0000000
--- a/OctreeRefinement/include/p4est_balance.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P4EST_BALANCE_H
-#define P4EST_BALANCE_H
-
-#include <p4est.h>
-
-/** Determines if quadrant \a q causes quadrant \a p to split under the given
- * \a balance condition.
- *
- * \param [in] q         Test quadrant.
- * \param [in] p         Trial quadrant.
- * \param [in] balance   Balance condition.
- * \param [out] seeds    optional array: if \a seeds is not NULL, then it will
- *                       be resized and filled with descendants of \a p such
- *                       that the coarsest balanced subtree rooted at \a p
- *                       that contains all of \a seeds is also the coarset
- *                       subtree rooted at \a p that is entirely balanced with
- *                       \a q.
- * \return               True if \a q causes \a p to split.
- */
-int                 p4est_balance_seeds (p4est_quadrant_t * q,
-                                         p4est_quadrant_t * p,
-                                         p4est_connect_type_t balance,
-                                         sc_array_t * seeds);
-
-/** Same as p4est_balance_seeds, optimized for the case when it is already
- * known that \a q is outside of a certain \a face of \a p.
- */
-int                 p4est_balance_seeds_face (p4est_quadrant_t * q,
-                                              p4est_quadrant_t * p,
-                                              int face, p4est_connect_type_t
-                                              balance, sc_array_t * seeds);
-
-/** Same as p4est_balance_seeds, optimized for the case when it is already
- * known that \a q is outside of a certain \a corner of \a p.
- */
-int                 p4est_balance_seeds_corner (p4est_quadrant_t * q,
-                                                p4est_quadrant_t * p,
-                                                int face, p4est_connect_type_t
-                                                balance, sc_array_t * seeds);
-
-#endif
diff --git a/OctreeRefinement/include/p4est_base.h b/OctreeRefinement/include/p4est_base.h
deleted file mode 100644
index 37c6e5b..0000000
--- a/OctreeRefinement/include/p4est_base.h
+++ /dev/null
@@ -1,482 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p4est_base.h
- *
- * General support types and functions
- */
-
-#ifndef P4EST_BASE_H
-#define P4EST_BASE_H
-
-/* include config headers */
-#include <p4est_config.h>
-#include <sc_config.h>
-#if \
-  (defined (P4EST_ENABLE_MPI) && !defined (SC_ENABLE_MPI)) || \
-  (!defined (P4EST_ENABLE_MPI) && defined (SC_ENABLE_MPI))
-#error "MPI configured differently in p4est and libsc"
-#endif
-#if \
-  (defined (P4EST_ENABLE_MPIIO) && !defined (SC_ENABLE_MPIIO)) || \
-  (!defined (P4EST_ENABLE_MPIIO) && defined (SC_ENABLE_MPIIO))
-#error "MPI I/O configured differently in p4est and libsc"
-#endif
-
-/* indirectly also include sc.h */
-#include <sc_containers.h>
-#define _p4est_const _sc_const
-
-SC_EXTERN_C_BEGIN;
-
-/** Typedef for quadrant coordinates. */
-typedef int32_t     p4est_qcoord_t;
-#define p4est_qcoord_compare sc_int32_compare
-#define P4EST_MPI_QCOORD sc_MPI_INT
-#define P4EST_VTK_QCOORD "Int32"
-#define P4EST_F90_QCOORD INTEGER(KIND=C_INT32_T)
-#define P4EST_QCOORD_MIN INT32_MIN
-#define P4EST_QCOORD_MAX INT32_MAX
-#define P4EST_QCOORD_1   ((p4est_qcoord_t) 1)
-#define P4EST_QCOORD_ABS(x) ((p4est_qcoord_t) labs ((long) (x)))
-
-/** Typedef for counting topological entities (trees, tree vertices). */
-typedef int32_t     p4est_topidx_t;
-#define p4est_topidx_compare sc_int32_compare
-#define P4EST_MPI_TOPIDX sc_MPI_INT
-#define P4EST_VTK_TOPIDX "Int32"
-#define P4EST_F90_TOPIDX INTEGER(KIND=C_INT32_T)
-#define P4EST_TOPIDX_MIN INT32_MIN
-#define P4EST_TOPIDX_MAX INT32_MAX
-#define P4EST_TOPIDX_FITS_32 1
-#define P4EST_TOPIDX_1   ((p4est_topidx_t) 1)
-#define P4EST_TOPIDX_ABS(x) ((p4est_topidx_t) labs ((long) (x)))
-
-/** Typedef for processor-local indexing of quadrants and nodes. */
-typedef int32_t     p4est_locidx_t;
-#define p4est_locidx_compare sc_int32_compare
-#define P4EST_MPI_LOCIDX sc_MPI_INT
-#define P4EST_VTK_LOCIDX "Int32"
-#define P4EST_F90_LOCIDX INTEGER(KIND=C_INT32_T)
-#define P4EST_LOCIDX_MIN INT32_MIN
-#define P4EST_LOCIDX_MAX INT32_MAX
-#define P4EST_LOCIDX_1   ((p4est_locidx_t) 1)
-#define P4EST_LOCIDX_ABS(x) ((p4est_locidx_t) labs ((long) (x)))
-
-/** Typedef for globally unique indexing of quadrants. */
-typedef int64_t     p4est_gloidx_t;
-#define p4est_gloidx_compare sc_int64_compare
-#define P4EST_MPI_GLOIDX sc_MPI_LONG_LONG_INT
-#define P4EST_VTK_GLOIDX "Int64"
-#define P4EST_F90_GLOIDX INTEGER(KIND=C_INT64_T)
-#define P4EST_GLOIDX_MIN INT64_MIN
-#define P4EST_GLOIDX_MAX INT64_MAX
-#define P4EST_GLOIDX_1   ((p4est_gloidx_t) 1)
-#define P4EST_GLOIDX_ABS(x) ((p4est_gloidx_t) llabs ((long long) (x)))
-
-/** Tags for MPI messages */
-typedef enum p4est_comm_tag
-{
-  P4EST_COMM_TAG_FIRST = SC_TAG_FIRST,
-  P4EST_COMM_COUNT_PERTREE = SC_TAG_LAST,
-  P4EST_COMM_BALANCE_FIRST_COUNT,
-  P4EST_COMM_BALANCE_FIRST_LOAD,
-  P4EST_COMM_BALANCE_SECOND_COUNT,
-  P4EST_COMM_BALANCE_SECOND_LOAD,
-  P4EST_COMM_PARTITION_GIVEN,
-  P4EST_COMM_PARTITION_WEIGHTED_LOW,
-  P4EST_COMM_PARTITION_WEIGHTED_HIGH,
-  P4EST_COMM_PARTITION_CORRECTION,
-  P4EST_COMM_GHOST_COUNT,
-  P4EST_COMM_GHOST_LOAD,
-  P4EST_COMM_GHOST_EXCHANGE,
-  P4EST_COMM_GHOST_EXPAND_COUNT,
-  P4EST_COMM_GHOST_EXPAND_LOAD,
-  P4EST_COMM_GHOST_SUPPORT_COUNT,
-  P4EST_COMM_GHOST_SUPPORT_LOAD,
-  P4EST_COMM_GHOST_CHECKSUM,
-  P4EST_COMM_NODES_QUERY,
-  P4EST_COMM_NODES_REPLY,
-  P4EST_COMM_SAVE,
-  P4EST_COMM_LNODES_TEST,
-  P4EST_COMM_LNODES_PASS,
-  P4EST_COMM_LNODES_OWNED,
-  P4EST_COMM_LNODES_ALL,
-  P4EST_COMM_TAG_LAST
-}
-p4est_comm_tag_t;
-
-/* some error checking possibly specific to p4est */
-#ifdef P4EST_ENABLE_DEBUG
-#define P4EST_ASSERT(c) SC_CHECK_ABORT ((c), "Assertion '" #c "'")
-#define P4EST_EXECUTE_ASSERT_FALSE(expression)                          \
-  do { int _p4est_i = (int) (expression);                               \
-       SC_CHECK_ABORT (!_p4est_i, "Expected false: '" #expression "'"); \
-  } while (0)
-#define P4EST_EXECUTE_ASSERT_TRUE(expression)                           \
-  do { int _p4est_i = (int) (expression);                               \
-       SC_CHECK_ABORT (_p4est_i, "Expected true: '" #expression "'");   \
-  } while (0)
-#define P4EST_DEBUG_EXECUTE(expression)                 \
-  do { (void) (expression); } while (0)
-#else
-#define P4EST_ASSERT(c) SC_NOOP ()
-#define P4EST_EXECUTE_ASSERT_FALSE(expression)          \
-  do { (void) (expression); } while (0)
-#define P4EST_EXECUTE_ASSERT_TRUE(expression)           \
-  do { (void) (expression); } while (0)
-#define P4EST_DEBUG_EXECUTE(expression) SC_NOOP ()
-#endif
-
-/* macros for memory allocation, will abort if out of memory */
-/** allocate a \a t-array with \a n elements */
-#define P4EST_ALLOC(t,n)          (t *) sc_malloc (p4est_package_id,    \
-                                                   (n) * sizeof(t))
-/** allocate a \a t-array with \a n elements and zero */
-#define P4EST_ALLOC_ZERO(t,n)     (t *) sc_calloc (p4est_package_id,    \
-                                                   (size_t) (n), sizeof(t))
-/** reallocate the \a t-array \a p with \a n elements */
-#define P4EST_REALLOC(p,t,n)      (t *) sc_realloc (p4est_package_id,   \
-                                                    (p), (n) * sizeof(t))
-/** duplicate a string */
-#define P4EST_STRDUP(s)                 sc_strdup (p4est_package_id, (s))
-/** free an allocated array */
-#define P4EST_FREE(p)                   sc_free (p4est_package_id, (p))
-
-/* log helper macros */
-#define P4EST_GLOBAL_LOG(p,s)                           \
-  SC_GEN_LOG (p4est_package_id, SC_LC_GLOBAL, (p), (s))
-#define P4EST_LOG(p,s)                                  \
-  SC_GEN_LOG (p4est_package_id, SC_LC_NORMAL, (p), (s))
-void                P4EST_GLOBAL_LOGF (int priority, const char *fmt, ...)
-  __attribute__ ((format (printf, 2, 3)));
-void                P4EST_LOGF (int priority, const char *fmt, ...)
-  __attribute__ ((format (printf, 2, 3)));
-#ifndef __cplusplus
-#define P4EST_GLOBAL_LOGF(p,f,...)                                      \
-  SC_GEN_LOGF (p4est_package_id, SC_LC_GLOBAL, (p), (f), __VA_ARGS__)
-#define P4EST_LOGF(p,f,...)                                             \
-  SC_GEN_LOGF (p4est_package_id, SC_LC_NORMAL, (p), (f), __VA_ARGS__)
-#endif
-
-/* convenience global log macros will only print if identifier <= 0 */
-#define P4EST_GLOBAL_TRACE(s) P4EST_GLOBAL_LOG (SC_LP_TRACE, (s))
-#define P4EST_GLOBAL_LDEBUG(s) P4EST_GLOBAL_LOG (SC_LP_DEBUG, (s))
-#define P4EST_GLOBAL_VERBOSE(s) P4EST_GLOBAL_LOG (SC_LP_VERBOSE, (s))
-#define P4EST_GLOBAL_INFO(s) P4EST_GLOBAL_LOG (SC_LP_INFO, (s))
-#define P4EST_GLOBAL_STATISTICS(s) P4EST_GLOBAL_LOG (SC_LP_STATISTICS, (s))
-#define P4EST_GLOBAL_PRODUCTION(s) P4EST_GLOBAL_LOG (SC_LP_PRODUCTION, (s))
-#define P4EST_GLOBAL_ESSENTIAL(s) P4EST_GLOBAL_LOG (SC_LP_ESSENTIAL, (s))
-#define P4EST_GLOBAL_LERROR(s) P4EST_GLOBAL_LOG (SC_LP_ERROR, (s))
-void                P4EST_GLOBAL_TRACEF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                P4EST_GLOBAL_LDEBUGF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                P4EST_GLOBAL_VERBOSEF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                P4EST_GLOBAL_INFOF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                P4EST_GLOBAL_STATISTICSF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                P4EST_GLOBAL_PRODUCTIONF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                P4EST_GLOBAL_ESSENTIALF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                P4EST_GLOBAL_LERRORF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-#ifndef __cplusplus
-#define P4EST_GLOBAL_TRACEF(f,...)                      \
-  P4EST_GLOBAL_LOGF (SC_LP_TRACE, (f), __VA_ARGS__)
-#define P4EST_GLOBAL_LDEBUGF(f,...)                     \
-  P4EST_GLOBAL_LOGF (SC_LP_DEBUG, (f), __VA_ARGS__)
-#define P4EST_GLOBAL_VERBOSEF(f,...)                    \
-  P4EST_GLOBAL_LOGF (SC_LP_VERBOSE, (f), __VA_ARGS__)
-#define P4EST_GLOBAL_INFOF(f,...)                       \
-  P4EST_GLOBAL_LOGF (SC_LP_INFO, (f), __VA_ARGS__)
-#define P4EST_GLOBAL_STATISTICSF(f,...)                         \
-  P4EST_GLOBAL_LOGF (SC_LP_STATISTICS, (f), __VA_ARGS__)
-#define P4EST_GLOBAL_PRODUCTIONF(f,...)                         \
-  P4EST_GLOBAL_LOGF (SC_LP_PRODUCTION, (f), __VA_ARGS__)
-#define P4EST_GLOBAL_ESSENTIALF(f,...)                          \
-  P4EST_GLOBAL_LOGF (SC_LP_ESSENTIAL, (f), __VA_ARGS__)
-#define P4EST_GLOBAL_LERRORF(f,...)                     \
-  P4EST_GLOBAL_LOGF (SC_LP_ERROR, (f), __VA_ARGS__)
-#endif
-#define P4EST_GLOBAL_NOTICE     P4EST_GLOBAL_STATISTICS
-#define P4EST_GLOBAL_NOTICEF    P4EST_GLOBAL_STATISTICSF
-
-/* convenience log macros that are active on every processor */
-#define P4EST_TRACE(s) P4EST_LOG (SC_LP_TRACE, (s))
-#define P4EST_LDEBUG(s) P4EST_LOG (SC_LP_DEBUG, (s))
-#define P4EST_VERBOSE(s) P4EST_LOG (SC_LP_VERBOSE, (s))
-#define P4EST_INFO(s) P4EST_LOG (SC_LP_INFO, (s))
-#define P4EST_STATISTICS(s) P4EST_LOG (SC_LP_STATISTICS, (s))
-#define P4EST_PRODUCTION(s) P4EST_LOG (SC_LP_PRODUCTION, (s))
-#define P4EST_ESSENTIAL(s) P4EST_LOG (SC_LP_ESSENTIAL, (s))
-#define P4EST_LERROR(s) P4EST_LOG (SC_LP_ERROR, (s))
-void                P4EST_TRACEF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                P4EST_LDEBUGF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                P4EST_VERBOSEF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                P4EST_INFOF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                P4EST_STATISTICSF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                P4EST_PRODUCTIONF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                P4EST_ESSENTIALF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                P4EST_LERRORF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-#ifndef __cplusplus
-#define P4EST_TRACEF(f,...)                     \
-  P4EST_LOGF (SC_LP_TRACE, (f), __VA_ARGS__)
-#define P4EST_LDEBUGF(f,...)                    \
-  P4EST_LOGF (SC_LP_DEBUG, (f), __VA_ARGS__)
-#define P4EST_VERBOSEF(f,...)                   \
-  P4EST_LOGF (SC_LP_VERBOSE, (f), __VA_ARGS__)
-#define P4EST_INFOF(f,...)                      \
-  P4EST_LOGF (SC_LP_INFO, (f), __VA_ARGS__)
-#define P4EST_STATISTICSF(f,...)                        \
-  P4EST_LOGF (SC_LP_STATISTICS, (f), __VA_ARGS__)
-#define P4EST_PRODUCTIONF(f,...)                        \
-  P4EST_LOGF (SC_LP_PRODUCTION, (f), __VA_ARGS__)
-#define P4EST_ESSENTIALF(f,...)                         \
-  P4EST_LOGF (SC_LP_ESSENTIAL, (f), __VA_ARGS__)
-#define P4EST_LERRORF(f,...)                    \
-  P4EST_LOGF (SC_LP_ERROR, (f), __VA_ARGS__)
-#endif
-#define P4EST_NOTICE            P4EST_STATISTICS
-#define P4EST_NOTICEF           P4EST_STATISTICSF
-
-/* extern declarations */
-/** the libsc package id for p4est (set in p4est_init()) */
-extern int          p4est_package_id;
-
-static inline void
-p4est_log_indent_push ()
-{
-  sc_log_indent_push_count (p4est_package_id, 1);
-}
-
-static inline void
-p4est_log_indent_pop ()
-{
-  sc_log_indent_pop_count (p4est_package_id, 1);
-}
-
-/** Registers p4est with the SC Library and sets the logging behavior.
- * This function is optional.
- * This function must only be called before additional threads are created.
- * If this function is not called or called with log_handler == NULL,
- * the default SC log handler will be used.
- * If this function is not called or called with log_threshold == SC_LP_DEFAULT,
- * the default SC log threshold will be used.
- * The default SC log settings can be changed with sc_set_log_defaults ().
- */
-void                p4est_init (sc_log_handler_t log_handler,
-                                int log_threshold);
-
-/** Compute hash value for two p4est_topidx_t integers.
- * \param [in] tt     Array of (at least) two values.
- * \return            An unsigned hash value.
- */
-/*@unused@*/
-static inline unsigned
-p4est_topidx_hash2 (const p4est_topidx_t * tt)
-{
-  uint32_t            a, b, c;
-
-#if (P4EST_TOPIDX_FITS_32)
-  a = (uint32_t) tt[0];
-  b = (uint32_t) tt[1];
-  c = 0;
-#else
-  a = (uint32_t) (tt[0] && 0xFFFFFFFF);
-  b = (uint32_t) (tt[0] >> 32);
-  c = (uint32_t) (tt[1] && 0xFFFFFFFF);
-  sc_hash_mix (a, b, c);
-  a += (uint32_t) (tt[1] >> 32);
-#endif
-  sc_hash_final (a, b, c);
-
-  return (unsigned) c;
-}
-
-/** Compute hash value for three p4est_topidx_t integers.
- * \param [in] tt     Array of (at least) three values.
- * \return            An unsigned hash value.
- */
-/*@unused@*/
-static inline unsigned
-p4est_topidx_hash3 (const p4est_topidx_t * tt)
-{
-  uint32_t            a, b, c;
-
-#if (P4EST_TOPIDX_FITS_32)
-  a = (uint32_t) tt[0];
-  b = (uint32_t) tt[1];
-  c = (uint32_t) tt[2];
-#else
-  a = (uint32_t) (tt[0] && 0xFFFFFFFF);
-  b = (uint32_t) (tt[0] >> 32);
-  c = (uint32_t) (tt[1] && 0xFFFFFFFF);
-  sc_hash_mix (a, b, c);
-  a += (uint32_t) (tt[1] >> 32);
-  b += (uint32_t) (tt[2] && 0xFFFFFFFF);
-  c += (uint32_t) (tt[2] >> 32);
-#endif
-  sc_hash_final (a, b, c);
-
-  return (unsigned) c;
-}
-
-/** Compute hash value for four p4est_topidx_t integers.
- * \param [in] tt     Array of (at least) four values.
- * \return            An unsigned hash value.
- */
-/*@unused@*/
-static inline unsigned
-p4est_topidx_hash4 (const p4est_topidx_t * tt)
-{
-  uint32_t            a, b, c;
-
-#if (P4EST_TOPIDX_FITS_32)
-  a = (uint32_t) tt[0];
-  b = (uint32_t) tt[1];
-  c = (uint32_t) tt[2];
-  sc_hash_mix (a, b, c);
-  a += (uint32_t) tt[3];
-#else
-  a = (uint32_t) (tt[0] && 0xFFFFFFFF);
-  b = (uint32_t) (tt[0] >> 32);
-  c = (uint32_t) (tt[1] && 0xFFFFFFFF);
-  sc_hash_mix (a, b, c);
-  a += (uint32_t) (tt[1] >> 32);
-  b += (uint32_t) (tt[2] && 0xFFFFFFFF);
-  c += (uint32_t) (tt[2] >> 32);
-  sc_hash_mix (a, b, c);
-  a += (uint32_t) (tt[3] && 0xFFFFFFFF);
-  b += (uint32_t) (tt[3] >> 32);
-#endif
-  sc_hash_final (a, b, c);
-
-  return (unsigned) c;
-}
-
-/*@unused@*/
-static inline int
-p4est_topidx_is_sorted (p4est_topidx_t * t, int length)
-{
-  int                 i;
-
-  for (i = 1; i < length; ++i) {
-    if (t[i - 1] > t[i]) {
-      return 0;
-    }
-  }
-  return 1;
-}
-
-/*@unused@*/
-static inline void
-p4est_topidx_bsort (p4est_topidx_t * t, int length)
-{
-  int                 i, j;
-  p4est_topidx_t      tswap;
-
-  /* go through all elements except the last */
-  for (i = length - 1; i > 0; --i) {
-    /* bubble up the first element until before position i */
-    for (j = 0; j < i; ++j) {
-      if (t[j] > t[j + 1]) {
-        tswap = t[j + 1];
-        t[j + 1] = t[j];
-        t[j] = tswap;
-      }
-    }
-  }
-  P4EST_ASSERT (p4est_topidx_is_sorted (t, length));
-}
-
-/*@unused@*/
-static inline       uint64_t
-p4est_partition_cut_uint64 (uint64_t global_num, int p, int num_procs)
-{
-  uint64_t            result;
-
-  /* In theory, a double * double product should never overflow
-     due to the 15-bit exponent used internally on x87 and above.
-     Also in theory, 80-bit floats should be used internally,
-     and multiply/divide associativity goes left-to-right.
-     Still checking for funny stuff just to be sure. */
-
-  P4EST_ASSERT (0 <= p && p <= num_procs);
-
-  if (p == num_procs) {
-    /* prevent roundoff error and division by zero */
-    return global_num;
-  }
-
-  result = (uint64_t)
-    (((long double) global_num * (double) p) / (double) num_procs);
-
-  P4EST_ASSERT (result <= global_num);
-
-  return result;
-}
-
-/*@unused@*/
-static inline       p4est_gloidx_t
-p4est_partition_cut_gloidx (p4est_gloidx_t global_num, int p, int num_procs)
-{
-  p4est_gloidx_t      result;
-
-  /* In theory, a double * double product should never overflow
-     due to the 15-bit exponent used internally on x87 and above.
-     Also in theory, 80-bit floats should be used internally,
-     and multiply/divide associativity goes left-to-right.
-     Still checking for funny stuff just to be sure. */
-
-  P4EST_ASSERT (global_num >= 0);
-  P4EST_ASSERT (0 <= p && p <= num_procs);
-
-  if (p == num_procs) {
-    /* prevent roundoff error and division by zero */
-    return global_num;
-  }
-
-  result = (p4est_gloidx_t)
-    (((long double) global_num * (double) p) / (double) num_procs);
-
-  P4EST_ASSERT (0 <= result && result <= global_num);
-
-  return result;
-}
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_BASE_H */
diff --git a/OctreeRefinement/include/p4est_bits.h b/OctreeRefinement/include/p4est_bits.h
deleted file mode 100644
index ea1923a..0000000
--- a/OctreeRefinement/include/p4est_bits.h
+++ /dev/null
@@ -1,614 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p4est_bits.h
- *
- * Routines for manipulating quadrants (neighbors, parents, children, etc.)
- *
- * \ingroup p4est
- */
-
-#ifndef P4EST_BITS_H
-#define P4EST_BITS_H
-
-#include <p4est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Prints one line with quadrant's x, y and level.
- * \param [in] log_priority  see \ref logpriorities in sc.h for the meanings
- *                           of numerical priority values
- * \param [in] q             quadrant to print
- */
-void                p4est_quadrant_print (int log_priority,
-                                          const p4est_quadrant_t * q);
-
-/** Test if two quadrants have equal Morton indices.
- * \return true if \a q1 describes the same quadrant as \a q2.
- */
-int                 p4est_quadrant_is_equal (const p4est_quadrant_t * q1,
-                                             const p4est_quadrant_t * q2);
-
-/** Test if two quadrants overlap.
- * \return true if \a q1 and \a q2 are equal or one is the ancestor of the
- * other.
- */
-int                 p4est_quadrant_overlaps (const p4est_quadrant_t * q1,
-                                             const p4est_quadrant_t * q2);
-
-/** Test if two quadrants have equal Morton indices and the same tree id.
- * \return          true if \a q1 describes the same quadrant as \a q2
- *                  and the p.which_tree fields are equal.
- */
-int                 p4est_quadrant_is_equal_piggy (const p4est_quadrant_t *
-                                                   q1,
-                                                   const p4est_quadrant_t *
-                                                   q2);
-
-/** Compare two quadrants in their Morton ordering.
- * Both quadrants must be valid.
- * \return Returns < 0 if \a v1 < \a v2,
- *                   0 if \a v1 == \a v2,
- *                 > 0 if \a v1 > \a v2
- */
-int                 p4est_quadrant_compare (const void *v1, const void *v2);
-
-/** Compare two quadrants in their Morton ordering, with equivalence if the
- * two quadrants overlap.
- * \return Returns < 0 if \a v1 < \a v2 and \a v1 and \a v2 do not overlap,
- *                   0 if \a v1 and \a v2 overlap,
- *                 > 0 if \a v1 > \a v2 and \a v1 and \a v2 do not overlap.
- */
-int                 p4est_quadrant_disjoint (const void *v1, const void *v2);
-
-/** Compare two quadrants in their Morton ordering and the which_tree member.
- * Both quadrants must be extended (superset of valid, see below).
- * \return Returns < 0 if \a v1 < \a v2,
- *                   0 if \a v1 == \a v2,
- *                 > 0 if \a v1 > \a v2
- */
-int                 p4est_quadrant_compare_piggy (const void *v1,
-                                                  const void *v2);
-
-/** Compare two quadrants with respect to their local_num in the piggy3 member.
- * \return Returns < 0 if \a v1 < \a v2,
- *                   0 if \a v1 == \a v2,
- *                 > 0 if \a v1 > \a v2
- */
-int                 p4est_quadrant_compare_local_num (const void *v1,
-                                                      const void *v2);
-
-/** Test if two quadrants have equal Morton indices, callback version.
- * \return true if \a v1 describes the same quadrant as \a v2.
- */
-int                 p4est_quadrant_equal_fn (const void *v1, const void *v2,
-                                             const void *u);
-
-/** Computes a hash value for a quadrant by the lookup3 method.
- */
-unsigned            p4est_quadrant_hash_fn (const void *v, const void *u);
-
-/** Test if two nodes are in the same tree and have equal Morton indices.
- * \param [in] v1   Pointer to a clamped or unclamped node, depending on u.
- * \param [in] v2   Pointer to a clamped or unclamped node, depending on u.
- * \param [in] u    User data, points to an int holding the clamped-flag.
- */
-int                 p4est_node_equal_piggy_fn (const void *v1,
-                                               const void *v2, const void *u);
-
-/** Compute hash value of a node based on its tree and Morton index.
- * \param [in] v    Pointer to a clamped or unclamped node, depending on u.
- * \param [in] u    User data, points to an int holding the clamped-flag.
- */
-unsigned            p4est_node_hash_piggy_fn (const void *v, const void *u);
-
-/** Clamp a node inside the unit tree if it sits on a high border.
- * \param [in] n    Node to be clamped. Must not yet be clamped.
- * \param [out] r   Existing node overwritten by the clamped result.
- */
-void                p4est_node_clamp_inside (const p4est_quadrant_t * n,
-                                             p4est_quadrant_t * r);
-
-/** Move a clamped node out on the border.
- * \param [in] n    Node to be unclamped in-place.
- */
-void                p4est_node_unclamp (p4est_quadrant_t * n);
-
-/** Find the enclosing quadrant of a given node at a given level.
- * \param [in] n        Clamped node.
- * \param [in] level    Level of the quadrant to be created.
- * \param [out] q       Output quadrant, n == q is permitted.
- */
-void                p4est_node_to_quadrant (const p4est_quadrant_t * n,
-                                            int level, p4est_quadrant_t * q);
-
-/** Decide if a node is completely contained within a quadrant.
- * \param [in] q        Valid quadrant.
- * \param [in] n        Clamped node.
- */
-int                 p4est_quadrant_contains_node (const p4est_quadrant_t * q,
-                                                  const p4est_quadrant_t * n);
-
-/** Compute the position of the ancestor of this child at level \a level within
- * its siblings.
- * \return Returns its child id in 0..3
- */
-int                 p4est_quadrant_ancestor_id (const p4est_quadrant_t * q,
-                                                int level);
-
-/** Compute the position of this child within its siblings.
- * \return Returns its child id in 0..3
- */
-int                 p4est_quadrant_child_id (const p4est_quadrant_t * q);
-
-/** Test if a quadrant is inside the unit tree.
- * \param [in] q Quadrant to be tested.
- * \return Returns true if \a q is inside the unit tree.
- */
-int                 p4est_quadrant_is_inside_root (const p4est_quadrant_t *
-                                                   q);
-
-/** Test if a quadrant is inside the 3x3 box around the root tree.
- * \param [in] q Quadrant to be tested.
- * \return Returns true if \a q is inside the unit tree.
- */
-int                 p4est_quadrant_is_inside_3x3 (const p4est_quadrant_t * q);
-
-/** Test if a quadrant is outside a tree face boundary (no corner).
- * \param [in] q Quadrant to be tested.
- * \return Returns true if \a q is outside across a unit tree face.
- */
-int                 p4est_quadrant_is_outside_face (const p4est_quadrant_t *
-                                                    q);
-
-/** Test if a quadrant is outside a tree corner boundary.
- * \param [in] q Quadrant to be tested.
- * \return Returns true if \a q is outside across a unit tree corner.
- */
-int                 p4est_quadrant_is_outside_corner (const p4est_quadrant_t *
-                                                      q);
-
-/** Test if a quadrant is used to represent a mesh node.
- * \param [in] q        Quadrant to be tested.
- * \param [in] inside   If true, boundary nodes must be clamped inside.
- *                      If false, nodes must align with the quadrant grid.
- * \return Returns true if \a q is a node.
- */
-int                 p4est_quadrant_is_node (const p4est_quadrant_t * q,
-                                            int inside);
-
-/** Test if a quadrant has valid Morton indices and is inside the unit tree.
- * \param [in] q Quadrant to be tested.
- * \return Returns true if \a q is valid.
- */
-int                 p4est_quadrant_is_valid (const p4est_quadrant_t * q);
-
-/** Test if a quadrant has valid Morton indices in the 3x3 box around root.
- * \param [in] q Quadrant to be tested.
- * \return Returns true if \a q is extended.
- */
-int                 p4est_quadrant_is_extended (const p4est_quadrant_t * q);
-
-/** Test if two quadrants are siblings.
- * \param [in] q1 First quadrant to be tested.
- * \param [in] q2 Second quadrant to be tested.
- * \return true if \a q1 is unequal to and a sibling of \a q2.
- */
-int                 p4est_quadrant_is_sibling (const p4est_quadrant_t * q1,
-                                               const p4est_quadrant_t * q2);
-
-/** Test if two quadrants are siblings.
- * Descriptive, slower version of \a p4est_quadrant_is_sibling.
- * For debugging and educational purposes only.
- */
-int                 p4est_quadrant_is_sibling_D (const p4est_quadrant_t * q1,
-                                                 const p4est_quadrant_t * q2);
-
-/** Test if 4 quadrants are siblings in Morton ordering.
- */
-int                 p4est_quadrant_is_family (const p4est_quadrant_t * q0,
-                                              const p4est_quadrant_t * q1,
-                                              const p4est_quadrant_t * q2,
-                                              const p4est_quadrant_t * q3);
-
-/** Test if 4 quadrants are siblings in Morton ordering, array version.
- * \param [in] q   Array of 4 quadrants.
- */
-int                 p4est_quadrant_is_familyv (const p4est_quadrant_t q[]);
-
-/** Test if 4 quadrants are siblings in Morton ordering, array version.
- * \param [in] q   Array of 4 pointers to quadrants.
- */
-int                 p4est_quadrant_is_familypv (p4est_quadrant_t * q[]);
-
-/** Test if a quadrant is the parent of another quadrant.
- * \param [in] q Quadrant to be tested.
- * \param [in] r Possible child quadrant.
- * \return true if \a q is the parent of \a r.
- */
-int                 p4est_quadrant_is_parent (const p4est_quadrant_t * q,
-                                              const p4est_quadrant_t * r);
-
-/** Test if a quadrant is the parent of another quadrant.
- * Descriptive, slower version of \a p4est_quadrant_is_parent.
- * For debugging and educational purposes only.
- */
-int                 p4est_quadrant_is_parent_D (const p4est_quadrant_t * q,
-                                                const p4est_quadrant_t * r);
-
-/** Test if a quadrant is an ancestor of another quadrant.
- * \param [in] q Quadrant to be tested.
- * \param [in] r Descendent quadrant.
- * \return true if \a q is unequal to and an ancestor of \a r.
- */
-int                 p4est_quadrant_is_ancestor (const p4est_quadrant_t * q,
-                                                const p4est_quadrant_t * r);
-
-/** Test if a quadrant is an ancestor of another quadrant.
- * Descriptive, slower version of \a p4est_quadrant_is_ancestor.
- * Contrary to \a p4est_quadrant_is_ancestor, it aborts for inter-tree q, r.
- * For debugging and educational purposes only.
- */
-int                 p4est_quadrant_is_ancestor_D (const p4est_quadrant_t * q,
-                                                  const p4est_quadrant_t * r);
-
-/** Test if two quadrants follow each other in the tree with no holes.
- * \param [in] q A quadrant
- * \param [in] r Another quadrant
- * \return true if \a q is immediately before \a r in the tree.
- * \note for every \a q there are between 0 and P4EST_MAXLEVEL+1 possible nexts.
- */
-int                 p4est_quadrant_is_next (const p4est_quadrant_t * q,
-                                            const p4est_quadrant_t * r);
-
-/** Test if two quadrants follow each other in the tree with no holes.
- * Descriptive, slower version of \a p4est_quadrant_is_next.
- * For debugging and educational purposes only.
- */
-int                 p4est_quadrant_is_next_D (const p4est_quadrant_t * q,
-                                              const p4est_quadrant_t * r);
-
-/** Test if a quadrant has at least partial overlap with a tree.
- */
-int                 p4est_quadrant_overlaps_tree (p4est_tree_t * tree,
-                                                  const p4est_quadrant_t * q);
-
-/** Test if a quadrant is completely contained within a tree.
- */
-int                 p4est_quadrant_is_inside_tree (p4est_tree_t * tree,
-                                                   const p4est_quadrant_t *
-                                                   q);
-
-/** Compute the ancestor of a quadrant at a given level.
- * \param [in]  q       Input quadrant.
- * \param [in]  level   A smaller level than q.
- * \param [in,out]  r   Existing quadrent whose Morton index will be filled
- *                      with the ancestor of q at the given level.
- * \note The quadrant q may point to the same quadrant as r.
- *       The user_data of r are never modified.
- */
-void                p4est_quadrant_ancestor (const p4est_quadrant_t * q,
-                                             int level, p4est_quadrant_t * r);
-
-/** Compute the parent of a quadrant.
- * \param [in]  q Input quadrant.
- * \param [in,out] r Existing quadrant whose Morton index will be filled
- *                   with the Morton index of the parent of \a q.
- *                   Its user_data will be untouched.
- * \note \a q may point to the same quadrant as \a r.
-         The user_data of \a r is never modified.
- */
-void                p4est_quadrant_parent (const p4est_quadrant_t * q,
-                                           p4est_quadrant_t * r);
-
-/** Compute a specific sibling of a quadrant.
- * \param [in]     q  Input quadrant.
- * \param [in,out] r  Existing quadrant whose Morton index will be filled
- *                    with the coordinates of sibling no. sibling_id of q.
- * \param [in]     sibling_id The id of the sibling computed, 0..3.
- */
-void                p4est_quadrant_sibling (const p4est_quadrant_t * q,
-                                            p4est_quadrant_t * r,
-                                            int sibling_id);
-
-/** Compute a specific child of a quadrant.
- * \param [in]     q    Input quadrant.
- * \param [in,out] r    Existing quadrant whose Morton index will be filled
- *                      with the coordinates of its child no. \b child_id.
- * \param [in] child_id The id of the child computed, 0..3.
- */
-void                p4est_quadrant_child (const p4est_quadrant_t * q,
-                                          p4est_quadrant_t * r, int child_id);
-
-/** Compute the face neighbor of a quadrant.
- * \param [in]     q      Input quadrant, must be valid.
- * \param [in]     face   The face across which to generate the neighbor.
- * \param [in,out] r      Existing quadrant whose Morton index will be filled.
- * \note \a q may point to the same quadrant as \a r.
- */
-void                p4est_quadrant_face_neighbor (const p4est_quadrant_t * q,
-                                                  int face,
-                                                  p4est_quadrant_t * r);
-
-/** Compute the face neighbor of a quadrant, transforming across tree
- * boundaries if necessary.
- * \param [in]     q      Input quadrant, must be valid.
- * \param [in]     t      Tree that contains \q.
- * \param [in]     face   The face across which to generate the neighbor.
- * \param [in,out] r      Existing quadrant whose Morton index will be filled.
- *                        By convention, if there is no tree across \face,
- *                        \r has the same Morton index as \q.
- * \param [in,out] nface  if not NULL, set to the face of \r that neighbors
- *                        \q.  nface is encoded with orientation information
- *                        in the same manner as the tree_to_face array in
- *                        the p4est_connectivity_t struct.
- * \param [in]     conn   The connectivity structure for the forest.
- * \return Returns the tree that contains \r.  By convention, if there is no
- * tree across \face, then -1 is returned.
- */
-p4est_topidx_t      p4est_quadrant_face_neighbor_extra (const p4est_quadrant_t
-                                                        * q, p4est_topidx_t t,
-                                                        int face,
-                                                        p4est_quadrant_t * r,
-                                                        int *nface,
-                                                        p4est_connectivity_t *
-                                                        conn);
-
-/** Get the smaller face neighbors of \a q.
- *
- * Gets the smaller face neighbors, which are half of the size assuming the
- * 2-1 constant.
- *
- * The order of the \a n[i] is given in the Morton ordering.
- *
- * \param [in]  q      The quadrant whose face neighbors will be constructed.
- * \param [in]  face   The face across which to generate the neighbors.
- * \param [out] n[0]..n[1] Filled with the four smaller face neighbors.
- * \param [out] nur[0]..nur[1] If not NULL, filled with smallest quadrants
- *                     that fit in the upper right corners of \a n.
- */
-void                p4est_quadrant_half_face_neighbors (const p4est_quadrant_t
-                                                        * q, int face,
-                                                        p4est_quadrant_t n[],
-                                                        p4est_quadrant_t
-                                                        nur[]);
-
-/** Create all possible face neighbors of \a q.
- *
- * Gets the face neighbors, possible assuming the 2-1 constraint.
- * If the larger or smaller quadrants do not exist than they are returned
- * as initialized by P4EST_QUADRANT_INIT.
- *
- * The order of \a n[0] through \a n[3] are given in Morton ordering.
- *
- * \param [in]  q      The quadrant whose face neighbors will be constructed.
- * \param [in]  face   The face across which to generate the neighbors.
- * \param [out] n[0]..n[1] Filled with the smaller possible face neighbors,
- *                     which are half of the size if they exist
- *                     or initialized to P4EST_QUADRANT_INIT.
- * \param [out] n[2]   Filled with the face neighbor, which is the same size.
- * \param [out] n[3]   Filled with the face neighbor, which is twice the size
- *                     if it exists or initialized to P4EST_QUADRANT_INIT.
- */
-void                p4est_quadrant_all_face_neighbors (const p4est_quadrant_t
-                                                       * q, int face,
-                                                       p4est_quadrant_t n[]);
-
-/** Compute the corner neighbor of a quadrant.
- * \param [in]     q      Input quadrant, must be valid.
- * \param [in]     corner The corner across which to generate the neighbor.
- * \param [in,out] r      Existing quadrant whose Morton index will be filled.
- * \note \a q may point to the same quadrant as \a r.
- */
-void                p4est_quadrant_corner_neighbor (const p4est_quadrant_t *
-                                                    q, int corner,
-                                                    p4est_quadrant_t * r);
-
-/** Compute the corner neighbors of a quadrant, transforming across tree
- * boundaries if necessary.  Only computes neighbors that are not face or edge
- * neighbors.
- * \param [in]     q      Input quadrant, must be valid.
- * \param [in]     t      Tree that contains \q.
- * \param [in]     corner The corner across which to generate the neighbor.
- * \param [in,out] quads  An initialized but empty array where the corner
- *                        neighbors will be placed.
- * \param [in,out] treeids An initialized but empty array where the ids of the
- *                        trees containing the corner neighbors will be placed.
- * \param [in,out] ncorners if not NULL, filled with the corners of \a quads
- *                          that neighbor \q.
- * \param [in]     conn   The connectivity structure for the forest.
- */
-void                p4est_quadrant_corner_neighbor_extra (const
-                                                          p4est_quadrant_t *
-                                                          q, p4est_locidx_t t,
-                                                          int corner,
-                                                          sc_array_t * quads,
-                                                          sc_array_t *
-                                                          treeids,
-                                                          sc_array_t *
-                                                          ncorners,
-                                                          p4est_connectivity_t
-                                                          * conn);
-
-/** Compute the half size corner neighbor of a quadrant.
- *
- * \param [in]  q       The quadrant whose corner neighbor will be constructed.
- * \param [in]  corner  The corner across which to generate the neighbor.
- * \param [out] r       Morton index filled with the half size corner neighbor.
- */
-void                p4est_quadrant_half_corner_neighbor (const
-                                                         p4est_quadrant_t * q,
-                                                         int corner,
-                                                         p4est_quadrant_t *
-                                                         r);
-
-/** Compute the corner node of a quadrant.
- * \param [in]     q      Input quadrant, must be valid.
- * \param [in]     corner The corner across which to generate the neighbor.
- * \param [in,out] r      Node that will not be clamped inside.
- * \note \a q may point to the same quadrant as \a r.
- */
-void                p4est_quadrant_corner_node (const p4est_quadrant_t * q,
-                                                int corner,
-                                                p4est_quadrant_t * r);
-
-/** Compute the 4 children of a quadrant.
- * \param [in]     q  Input quadrant.
- * \param [in,out] c0 First computed child.
- *                    \a q may point to the same quadrant as \a c0.
- * \note The user_data of \a c0, c1, c2, c3 is never modified.
- */
-void                p4est_quadrant_children (const p4est_quadrant_t * q,
-                                             p4est_quadrant_t * c0,
-                                             p4est_quadrant_t * c1,
-                                             p4est_quadrant_t * c2,
-                                             p4est_quadrant_t * c3);
-
-/** Compute the 4 children of a quadrant, array version.
- * \param [in]     q  Input quadrant.
- * \param [in,out] c  The 4 computed children in z-order.
- *                    q may point to the same quadrant as c[0].
- * \note The user_data of c[i] is never modified.
- */
-void                p4est_quadrant_childrenv (const p4est_quadrant_t * q,
-                                              p4est_quadrant_t c[]);
-
-/** Compute the 4 children of a quadrant, array version.
- * \param [in]     q  Input quadrant.
- * \param [in,out] c  Pointers to the 4 computed children in z-order.
- *                    q may point to the same quadrant as c[0].
- * \note The user_data of c[i] is never modified.
- */
-void                p4est_quadrant_childrenpv (const p4est_quadrant_t * q,
-                                               p4est_quadrant_t * c[]);
-
-/** Compute the first descendant of a quadrant on a given level.
- * \param [in]  q      Input quadrant.
- * \param [out] fd     First descendant of \a q on level \a level.
- * \param [in]  level  Level must be greater equal than q's level.
- */
-void                p4est_quadrant_first_descendant (const p4est_quadrant_t *
-                                                     q, p4est_quadrant_t * fd,
-                                                     int level);
-
-/** Compute the last descendant of a quadrant on a given level.
- * \param [in]  q      Input quadrant.
- * \param [out] ld     Last descendant of \a q on level \a level.
- * \param [in]  level  Level must be greater equal than q's level.
- */
-void                p4est_quadrant_last_descendant (const p4est_quadrant_t *
-                                                    q, p4est_quadrant_t * ld,
-                                                    int level);
-
-/** Compute the descendant of a quadrant touching a given corner.
- * \param [in]     q   Input quadrant.
- * \param [in,out] r   Existing quadrant whose Morton index will be filled.
- *                     Its user_data will be untouched.
- * \param [in]     c   The corner of \a q that \a r touches.
- * \param [in] level   The size of \a r.
- */
-void                p4est_quadrant_corner_descendant (const p4est_quadrant_t *
-                                                      q, p4est_quadrant_t * r,
-                                                      int c, int level);
-
-/** Computes the nearest common ancestor of two quadrants in the same tree.
- * \param [in]     q1 First input quadrant.
- * \param [in]     q2 Second input quadrant.
- * \param [in,out] r Existing quadrant whose Morton index will be filled.
- *                   Its user_data will be untouched.
- * \note \a q1, \a q2, \a r may point to the same quadrant.
- *       The user_data of \a r is never modified.
- */
-void                p4est_nearest_common_ancestor (const p4est_quadrant_t *
-                                                   q1,
-                                                   const p4est_quadrant_t *
-                                                   q2, p4est_quadrant_t * r);
-
-/** Computes the nearest common ancestor of two quadrants in the same tree.
- * Descriptive, slower version of \a p4est_nearest_common_ancestor.
- * For debugging and educationial purposes only.
- */
-void                p4est_nearest_common_ancestor_D (const p4est_quadrant_t *
-                                                     q1,
-                                                     const p4est_quadrant_t *
-                                                     q2,
-                                                     p4est_quadrant_t * r);
-
-/** Transforms a quadrant/node across a face between trees.
- * \param [in]     q        Input quadrant/non-clamped node.
- * \param [in,out] r        Quadrant/node whose Morton index will be filled.
- * \param [in] ftransform   This array holds 9 integers.
- *             [0,2]        The coordinate axis sequence of the origin face.
- *             [3,5]        The coordinate axis sequence of the target face.
- *             [6,8]        Edge reverse flag for axis 0; face code for 1.
- *             [1,4,7]      0 (unused for compatibility with 3D).
- * \note \a q and \q r may NOT point to the same quadrant structure.
- */
-void                p4est_quadrant_transform_face (const p4est_quadrant_t * q,
-                                                   p4est_quadrant_t * r,
-                                                   const int ftransform[]);
-
-/** Checks if a quadrant touches a corner (diagonally inside or outside).
- */
-int                 p4est_quadrant_touches_corner (const p4est_quadrant_t * q,
-                                                   int corner, int inside);
-
-/** Move a quadrant inside or diagonally outside a corner position.
- * \param [in,out] q        This quadrant only requires a valid level.
- * \param [in]     icorner  Number of the corner in 0..3.
- * \param [int]    inside   Boolean flag for inside or diagonally outside.
- */
-void                p4est_quadrant_transform_corner (p4est_quadrant_t * q,
-                                                     int icorner, int inside);
-
-/** Shifts a quadrant until it touches the specified corner from the inside.
- * \param [in]     q          Valid input quadrant.
- * \param [in,out] r          Quadrant whose Morton index will be filled.
- * \param [in]     corner     Corner index.
- */
-void                p4est_quadrant_shift_corner (const p4est_quadrant_t * q,
-                                                 p4est_quadrant_t * r,
-                                                 int corner);
-
-/** Computes the linear position of a quadrant in a uniform grid.
- * \param [in] quadrant  Quadrant whose id will be computed.
- * \return Returns the linear position of this quadrant on a grid.
- * \note This is the inverse operation of p4est_quadrant_set_morton.
- *       The user_data of \a quadrant is never modified.
- */
-uint64_t            p4est_quadrant_linear_id (const p4est_quadrant_t *
-                                              quadrant, int level);
-
-/** Set quadrant Morton indices based on linear position in uniform grid.
- * \param [in,out] quadrant  Quadrant whose Morton indices will be set.
- * \param [in]     id        The linear position of this quadrant on a grid.
- * \note This is the inverse operation of p4est_quadrant_linear_id.
- *       The user_data of \a quadrant is never modified.
- */
-void                p4est_quadrant_set_morton (p4est_quadrant_t * quadrant,
-                                               int level, uint64_t id);
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_BITS_H */
diff --git a/OctreeRefinement/include/p4est_communication.h b/OctreeRefinement/include/p4est_communication.h
deleted file mode 100644
index 60bf9ef..0000000
--- a/OctreeRefinement/include/p4est_communication.h
+++ /dev/null
@@ -1,412 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P4EST_COMMUNICATION_H
-#define P4EST_COMMUNICATION_H
-
-#include <p4est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Assign an MPI communicator to p4est; retrieve parallel environment.
- *
- * \param [in] mpicomm    A valid MPI communicator.
- *
- * \note The provided MPI communicator is not owned by p4est.
- */
-void                p4est_comm_parallel_env_assign (p4est_t * p4est,
-                                                    sc_MPI_Comm mpicomm);
-
-/** Duplicate MPI communicator and replace the current one by the duplicate.
- *
- * \note The duplicated MPI communicator is owned by p4est.
- */
-void                p4est_comm_parallel_env_duplicate (p4est_t * p4est);
-
-/** Release MPI communicator if it is owned by p4est.
- */
-void                p4est_comm_parallel_env_release (p4est_t * p4est);
-
-/** Replace the current MPI communicator by the one provided as input.
- *
- * \param [in] mpicomm    A valid MPI communicator.
- *
- * \note The provided MPI communicator is not owned by p4est.
- */
-void                p4est_comm_parallel_env_replace (p4est_t * p4est,
-                                                     sc_MPI_Comm mpicomm);
-
-/** Retrieve parallel environment information.
- */
-void                p4est_comm_parallel_env_get_info (p4est_t * p4est);
-
-/** Check if the MPI communicator is valid.
- *
- * \return True if communicator is not NULL communicator, false otherwise.
- */
-int                 p4est_comm_parallel_env_is_null (p4est_t * p4est);
-
-/** Reduce MPI communicator to non-empty ranks (i.e., nonzero quadrant counts).
- *
- * \param [in/out] p4est_supercomm  Object which communicator is reduced.
- *                                  Points to NULL if this p4est does not
- *                                  exists.
- *
- * \return True if p4est exists on this MPI rank after reduction.
- */
-int                 p4est_comm_parallel_env_reduce (p4est_t **
-                                                    p4est_supercomm);
-
-/** Reduce MPI communicator to non-empty ranks and add a group of ranks that
- * will remain in the reduced communicator regardless whether they are empty
- * or not.
- *
- * \param [in/out] p4est_supercomm  Object which communicator is reduced.
- *                                  Points to NULL if this p4est does not
- *                                  exists.
- * \param [in] group_add         Group of ranks that will remain in
- *                               communicator.
- * \param [in] add_to_beginning  If true, ranks will be added to the beginning
- *                               of the reduced communicator, otherwise to the
- *                               end.
- * \param[out] ranks_subcomm     If not null, array of size 'subcommsize' with
- *                               subcommrank->supercommrank map.
- *
- * \return True if p4est exists on this MPI rank after reduction.
- */
-int                 p4est_comm_parallel_env_reduce_ext (p4est_t **
-                                                        p4est_supercomm,
-                                                        sc_MPI_Group
-                                                        group_add,
-                                                        int add_to_beginning,
-                                                        int **ranks_subcomm);
-
-/** Caculate the number and partition of quadrents.
- * \param [in,out] p4est  Adds all \c p4est->local_num_quadrant counters and
- *                        puts cumulative sums in p4est->global_first_quadrant.
- */
-void                p4est_comm_count_quadrants (p4est_t * p4est);
-
-/** Distribute the global partition boundaries.
- * \param [in,out] p4est        Fills \c p4est->global_first_position.
- *                              p4est->first_local_tree must be set correctly.
- *                              If this processor is not empty and
- *                              first_quad is NULL, the first quadrant
- *                              of the first local tree must be set correctly.
- * \param [in] first_quad       If not NULL will be used as first quadrant.
- */
-void                p4est_comm_global_partition (p4est_t * p4est,
-                                                 p4est_quadrant_t *
-                                                 first_quad);
-
-/** Compute and distribute the cumulative number of quadrants per tree.
- * \param [in] p4est    This p4est needs to have correct values for
- *                      global_first_quadrant and global_first_position.
- * \param [in,out] pertree      On input, memory for num_trees + 1 numbers.
- *                              On output, the cumulative quadrant counts.
- */
-void                p4est_comm_count_pertree (p4est_t * p4est,
-                                              p4est_gloidx_t * pertree);
-
-/** Query whether a processor has no quadrants.
- * \param [in] p4est    This forests' global_first_position array must be valid.
- * \param [in] p        Valid processor id.
- * \return              True if and only if processor \p is empty.
- */
-int                 p4est_comm_is_empty (p4est_t * p4est, int p);
-
-/** Test whether a quadrant is fully contained in a rank's owned regien.
- * This function may return false when \ref p4est_comm_is_owner returns true.
- * \param [in] rank    Rank whose ownership is tested.
- *                     Assumes a forest with no overlaps.
- * \return true if rank is the owner of the whole area of the quadrant.
- */
-int                 p4est_comm_is_contained (p4est_t * p4est,
-                                             p4est_locidx_t which_tree,
-                                             const p4est_quadrant_t * q,
-                                             int rank);
-
-/** Test ownershop of a quadrant via p4est->global_first_position.
- * The quadrant is considered owned if its first descendant is owned.
- * This, a positive result occurs even if its last descendant overlaps
- * a higher process.
- * \param [in] rank    Rank whose ownership is tested.
- *                     Assumes a forest with no overlaps.
- * \return true if rank is the owner of the first descendant.
- */
-int                 p4est_comm_is_owner (p4est_t * p4est,
-                                         p4est_locidx_t which_tree,
-                                         const p4est_quadrant_t * q,
-                                         int rank);
-
-/** Searches the owner of a quadrant via p4est->global_first_position.
- * Assumes a tree with no overlaps.
- * \param [in] guess   Initial guess for the search.
- * \return Returns the processor id of the owner.
- */
-int                 p4est_comm_find_owner (p4est_t * p4est,
-                                           p4est_locidx_t which_tree,
-                                           const p4est_quadrant_t * q,
-                                           int guess);
-
-/** Computes information about a tree being fully owned.
- * This is determined separately for the beginning and end of the tree.
- * \param [in] p4est            The p4est to work on.
- * \param [in] which_tree       The tree in question must be partially owned.
- * \param [out] full_tree[2]    Full ownership of beginning and end of tree.
- * \param [out] tree_contact[4] True if there are neighbors across the face.
- * \param [out] firstq          Smallest possible first quadrant on this core.
- * \param [out] nextq           Smallest possible first quadrant on next core.
- *                          Any of tree_contact, firstq and nextq may be NULL.
- */
-void                p4est_comm_tree_info (p4est_t * p4est,
-                                          p4est_locidx_t which_tree,
-                                          int full_tree[],
-                                          int tree_contact[],
-                                          const p4est_quadrant_t ** firstq,
-                                          const p4est_quadrant_t ** nextq);
-
-/** Test if the 3x3 neighborhood of a quadrant is owned by this processor.
- * \param [in] p4est            The p4est to work on.
- * \param [in] which_tree       The tree index to work on.
- * \param [in] full_tree[2]     Flags as computed by p4est_comm_tree_info.
- * \param [in] tree_contact[4]  Flags as computed by p4est_comm_tree_info.
- * \param [in] q                The quadrant to be checked.
- * \return          Returns true iff this quadrant's 3x3 neighborhood is owned.
- */
-int                 p4est_comm_neighborhood_owned (p4est_t * p4est,
-                                                   p4est_locidx_t which_tree,
-                                                   int full_tree[],
-                                                   int tree_contact[],
-                                                   p4est_quadrant_t * q);
-
-/** Evaluates true/false of a flag among processors.
- * \param [in] p4est        The MPI communicator of this p4est will be used.
- * \param [in] flag         The variable to communicate.
- * \param [in] operation    Either sc_MPI_BAND or sc_MPI_BOR (not used bitwise).
- * \return          Returns the logical AND resp. OR of all processors' flags.
- */
-int                 p4est_comm_sync_flag (p4est_t * p4est,
-                                          int flag, sc_MPI_Op operation);
-
-/** Compute a parallel checksum out of local checksums.
- * \param [in] p4est       The MPI information of this p4est will be used.
- * \param [in] local_crc   Locally computed adler32 checksum.
- * \param [in] local_bytes Number of bytes used for local checksum.
- * \return                 Parallel checksum on rank 0, 0 otherwise.
- */
-unsigned            p4est_comm_checksum (p4est_t * p4est,
-                                         unsigned local_crc,
-                                         size_t local_bytes);
-
-/** Context data to allow for split begin/end data transfer. */
-typedef struct p4est_transfer_context
-{
-  int                 variable;
-  int                 num_senders;
-  int                 num_receivers;
-  sc_MPI_Request     *recv_req;
-  sc_MPI_Request     *send_req;
-}
-p4est_transfer_context_t;
-
-/** Transfer data associated with one forest partition to another.
- * In \ref p4est_partition, each quadrant's user data is transferred.
- * If the application maintains per-quadrant data outside of the p4est object,
- * this function can be used to transfer it, matching the call to partition.
- * This variant of the function assumes that the quadrant data size is fixed.
- * It sends point-to-point messages only and is blocking collective.
- * There is a split collective version; see the functions
- * \ref p4est_transfer_fixed_begin and \ref p4est_transfer_fixed_end.
- * \param [in] dest_gfq     The target partition encoded as a \b
- *                          p4est->global_first_quadrant array.  Has \b mpisize
- *                          + 1 members, must be non-decreasing and satisfy
- *                          gfq[0] == 0, gfq[mpisize] == global_num_quadrants.
- * \param [in] src_gfq      The original partition, analogous to \b dest_gfq.
- * \param [in] mpicomm      The communicator to use.
- *                          Its mpisize must match \b dest_gfq and \b src_gfq.
- * \param [in] tag          This tag is used in all messages.  The user must
- *                          guarantee that \b mpicomm and \b tag do not
- *                          conflict with other messages in transit.
- * \param [out] dest_data   User-allocated memory of size \b data_size * \b
- *                          dest->local_num_quadrants is received into.
- * \param [in] src_data     User-allocated memory of size \b data_size * \b
- *                          src->local_num_quadrants bytes is sent from.
- * \param [in] data_size    Fixed data size per quadrant.
- */
-void                p4est_transfer_fixed (const p4est_gloidx_t * dest_gfq,
-                                          const p4est_gloidx_t * src_gfq,
-                                          sc_MPI_Comm mpicomm, int tag,
-                                          void *dest_data,
-                                          const void *src_data,
-                                          size_t data_size);
-
-/** Initiate a fixed-size data transfer between partitions.
- * See \ref p4est_transfer_fixed for a full description.
- * Must be matched with \ref p4est_transfer_fixed_end for completion.
- * All parameters must stay alive until the completion has been called.
- * \param [in] dest_gfq     The target partition encoded as a \b
- *                          p4est->global_first_quadrant array.  Has \b mpisize
- *                          + 1 members, must be non-decreasing and satisfy
- *                          gfq[0] == 0, gfq[mpisize] == global_num_quadrants.
- * \param [in] src_gfq      The original partition, analogous to \b dest_gfq.
- * \param [in] mpicomm      The communicator to use.
- *                          Its mpisize must match \b dest_gfq and \b src_gfq.
- * \param [in] tag          This tag is used in all messages.  The user must
- *                          guarantee that \b mpicomm and \b tag do not
- *                          conflict with other messages in transit.
- * \param [out] dest_data   User-allocated memory of size \b data_size * \b
- *                          dest->local_num_quadrants bytes is received into.
- *                          It must not be accessed before completion with
- *                          \ref p4est_transfer_fixed_end.
- * \param [in] src_data     User-allocated memory of size \b data_size * \b
- *                          src->local_num_quadrants bytes is sent from.
- *                          It must not be accessed before completion with
- *                          \ref p4est_transfer_fixed_end.
- * \param [in] data_size    Fixed data size per quadrant.
- * \return                  The context object must be passed to the matching
- *                          call to \ref p4est_transfer_fixed_end.
- */
-p4est_transfer_context_t *p4est_transfer_fixed_begin (const p4est_gloidx_t *
-                                                      dest_gfq,
-                                                      const p4est_gloidx_t *
-                                                      src_gfq,
-                                                      sc_MPI_Comm mpicomm,
-                                                      int tag,
-                                                      void *dest_data,
-                                                      const void *src_data,
-                                                      size_t data_size);
-
-/** Complete a fixed-size data transfer between partitions.
- * \param [in] tc       Context data from \ref p4est_transfer_fixed_begin.
- *                      Is deallocated before this function returns.
- */
-void                p4est_transfer_fixed_end (p4est_transfer_context_t * tc);
-
-/** Transfer variable-size quadrant data between partitions.
- * (See \ref p4est_transfer_fixed that is optimized for fixed-size data.)
- * The destination process may not know the data size for the elements it
- * receives.  In this case the sizes need to be obtained separately in advance,
- * for example by calling \ref p4est_transfer_fixed with \b src_sizes as
- * payload data, or alternatively its split begin/end versions.
- * \param [in] dest_gfq     The target partition encoded as a \b
- *                          p4est->global_first_quadrant array.  Has \b mpisize
- *                          + 1 members, must be non-decreasing and satisfy
- *                          gfq[0] == 0, gfq[mpisize] == global_num_quadrants.
- * \param [in] src_gfq      The original partition, analogous to \b dest_gfq.
- * \param [in] mpicomm      The communicator to use.
- *                          Its mpisize must match \b dest_gfq and \b src_gfq.
- * \param [in] tag          This tag is used in all messages.  The user must
- *                          guarantee that \b mpicomm and \b tag do not
- *                          conflict with other messages in transit.
- * \param [out] dest_data   User-allocated memory of
- *                          sum_{i in \b dest->local_num_quadrants} \b
- *                          dest_sizes [i] many bytes is received into.
- *                          See below about how to choose its size.
- * \param [in] dest_sizes   User-allocated memory of one integer for each
- *                          quadrant, storing the data size to receive for it.
- *                          We understand that the sizes are often not known a
- *                          priori, in which case they can be obtained by a
- *                          prior call to \ref p4est_transfer_fixed.
- *                          Optionally the split begin/end versions can be used
- *                          for added flexibility and overlapping of messages.
- *                          We use the type int to minimize the message size,
- *                          and to conform to MPI that has no type for size_t.
- * \param [in] src_data     User-allocated memory of
- *                          sum_{i in \b src->local_num_quadrants} \b
- *                          src_sizes [i] many bytes is sent from.
- * \param [in] src_sizes    User-allocated memory of one integer for each
- *                          quadrant, storing the data size to send for it.
- *                          We use the type int to minimize the message size,
- *                          and to conform to MPI that has no type for size_t.
- */
-void                p4est_transfer_custom (const p4est_gloidx_t * dest_gfq,
-                                           const p4est_gloidx_t * src_gfq,
-                                           sc_MPI_Comm mpicomm, int tag,
-                                           void *dest_data,
-                                           const int *dest_sizes,
-                                           const void *src_data,
-                                           const int *src_sizes);
-
-/** Initiate a variable-size data transfer between partitions.
- * See \ref p4est_transfer_custom for a full description.
- * Must be matched with \ref p4est_transfer_custom_end for completion.
- * All parameters must stay alive until the completion has been called.
- * \param [in] dest_gfq     The target partition encoded as a \b
- *                          p4est->global_first_quadrant array.  Has \b mpisize
- *                          + 1 members, must be non-decreasing and satisfy
- *                          gfq[0] == 0, gfq[mpisize] == global_num_quadrants.
- * \param [in] src_gfq      The original partition, analogous to \b dest_gfq.
- * \param [in] mpicomm      The communicator to use.
- *                          Its mpisize must match \b dest_gfq and \b src_gfq.
- * \param [in] tag          This tag is used in all messages.  The user must
- *                          guarantee that \b mpicomm and \b tag do not
- *                          conflict with other messages in transit.
- * \param [out] dest_data   User-allocated memory of
- *                          sum_{i in \b dest->local_num_quadrants} \b
- *                          dest_sizes [i] many bytes is received into.
- *                          It must not be accessed before completion with
- *                          \ref p4est_transfer_custom_end.
- *                          See below about how to choose its size.
- * \param [in] dest_sizes   User-allocated memory of one integer for each
- *                          quadrant, storing the data size to receive for it.
- *                          We understand that the sizes are often not known a
- *                          priori, in which case they can be obtained by a
- *                          prior call to \ref p4est_transfer_fixed.
- *                          Optionally the split begin/end versions can be used
- *                          for added flexibility and overlapping of messages.
- *                          We use the type int to minimize the message size,
- *                          and to conform to MPI that has no type for size_t.
- * \param [in] src_data     User-allocated memory of
- *                          sum_{i in \b src->local_num_quadrants} \b
- *                          src_sizes [i] many bytes is sent from.
- *                          It must not be accessed before completion with
- *                          \ref p4est_transfer_custom_end.
- * \param [in] src_sizes    User-allocated memory of one integer for each
- *                          quadrant, storing the data size to send for it.
- *                          We use the type int to minimize the message size,
- *                          and to conform to MPI that has no type for size_t.
- * \return                  The context object must be passed to the matching
- *                          call to \ref p4est_transfer_custom_end.
- */
-p4est_transfer_context_t *p4est_transfer_custom_begin (const p4est_gloidx_t *
-                                                       dest_gfq,
-                                                       const p4est_gloidx_t *
-                                                       src_gfq,
-                                                       sc_MPI_Comm mpicomm,
-                                                       int tag,
-                                                       void *dest_data,
-                                                       const int *dest_sizes,
-                                                       const void *src_data,
-                                                       const int *src_sizes);
-
-/** Complete a variable-size data transfer between partitions.
- * \param [in] tc       Context data from \ref p4est_transfer_custom_begin.
- *                      Is deallocated before this function returns.
- */
-void                p4est_transfer_custom_end (p4est_transfer_context_t * tc);
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_COMMUNICATION_H */
diff --git a/OctreeRefinement/include/p4est_config.h b/OctreeRefinement/include/p4est_config.h
deleted file mode 100644
index 64ab289..0000000
--- a/OctreeRefinement/include/p4est_config.h
+++ /dev/null
@@ -1,386 +0,0 @@
-#ifndef _SRC_P_EST_CONFIG_H
-#define _SRC_P_EST_CONFIG_H 1
- 
-/* src/p4est_config.h. Generated automatically at end of configure. */
-/* src/pre_config.h.  Generated from pre_config.h.in by configure.  */
-/* src/pre_config.h.in.  Generated from configure.ac by autoheader.  */
-
-/* DEPRECATED (use P4EST_ENABLE_BUILD_2D instead) */
-#ifndef P4EST_BUILD_2D
-#define P4EST_BUILD_2D 1
-#endif
-
-/* DEPRECATED (use P4EST_ENABLE_BUILD_3D instead) */
-#ifndef P4EST_BUILD_3D
-#define P4EST_BUILD_3D 1
-#endif
-
-/* DEPRECATED (use P4EST_ENABLE_BUILD_P6EST instead) */
-#ifndef P4EST_BUILD_P6EST
-#define P4EST_BUILD_P6EST 1
-#endif
-
-/* C compiler */
-#ifndef P4EST_CC
-#define P4EST_CC "gcc"
-#endif
-
-/* C compiler flags */
-#ifndef P4EST_CFLAGS
-#define P4EST_CFLAGS "-g -O2"
-#endif
-
-/* C preprocessor */
-#ifndef P4EST_CPP
-#define P4EST_CPP "gcc -E"
-#endif
-
-/* C preprocessor flags */
-#ifndef P4EST_CPPFLAGS
-#define P4EST_CPPFLAGS ""
-#endif
-
-/* Define to 1 if your C++ compiler doesn't accept -c and -o together. */
-/* #undef CXX_NO_MINUS_C_MINUS_O */
-
-/* DEPRECATED (use P4EST_ENABLE_DEBUG instead) */
-/* #undef DEBUG */
-
-/* Undefine if: disable the 2D library */
-#ifndef P4EST_ENABLE_BUILD_2D
-#define P4EST_ENABLE_BUILD_2D 1
-#endif
-
-/* Undefine if: disable the 3D library */
-#ifndef P4EST_ENABLE_BUILD_3D
-#define P4EST_ENABLE_BUILD_3D 1
-#endif
-
-/* Undefine if: disable hybrid 2D+1D p6est library */
-#ifndef P4EST_ENABLE_BUILD_P6EST
-#define P4EST_ENABLE_BUILD_P6EST 1
-#endif
-
-/* enable debug mode (assertions and extra checks) */
-/* #undef ENABLE_DEBUG */
-
-/* Undefine if: use aligned malloc (optionally use --enable-memalign=<bytes>)
-   */
-#ifndef P4EST_ENABLE_MEMALIGN
-#define P4EST_ENABLE_MEMALIGN 1
-#endif
-
-/* Define to 1 if we are using MPI */
-/* #undef ENABLE_MPI */
-
-/* Define to 1 if we can use MPI_COMM_TYPE_SHARED */
-/* #undef ENABLE_MPICOMMSHARED */
-
-/* Define to 1 if we are using MPI I/O */
-/* #undef ENABLE_MPIIO */
-
-/* Define to 1 if we are using MPI_Init_thread */
-/* #undef ENABLE_MPITHREAD */
-
-/* Define to 1 if we can use MPI_Win_allocate_shared */
-/* #undef ENABLE_MPIWINSHARED */
-
-/* enable OpenMP (optionally use --enable-openmp=<OPENMP_CFLAGS>) */
-/* #undef ENABLE_OPENMP */
-
-/* enable POSIX threads (optionally use --enable-pthread=<PTHREAD_CFLAGS>) */
-/* #undef ENABLE_PTHREAD */
-
-/* Undefine if: write vtk ascii file data */
-/* #undef ENABLE_VTK_BINARY */
-
-/* Undefine if: disable zlib compression for vtk binary data */
-#ifndef P4EST_ENABLE_VTK_COMPRESSION
-#define P4EST_ENABLE_VTK_COMPRESSION 1
-#endif
-
-/* use doubles for vtk file data */
-/* #undef ENABLE_VTK_DOUBLES */
-
-/* Define to dummy `main' function (if any) required to link to the Fortran
-   libraries. */
-/* #undef F77_DUMMY_MAIN */
-
-/* Define to a macro mangling the given C identifier (in lower and upper
-   case), which must not contain underscores, for linking with Fortran. */
-#ifndef P4EST_F77_FUNC
-#define P4EST_F77_FUNC(name,NAME) name ## _
-#endif
-
-/* As F77_FUNC, but for C identifiers containing underscores. */
-#ifndef P4EST_F77_FUNC_
-#define P4EST_F77_FUNC_(name,NAME) name ## _
-#endif
-
-/* Define to 1 if your Fortran compiler doesn't accept -c and -o together. */
-/* #undef F77_NO_MINUS_C_MINUS_O */
-
-/* Define to dummy `main' function (if any) required to link to the Fortran
-   libraries. */
-/* #undef FC_DUMMY_MAIN */
-
-/* Define if F77 and FC dummy `main' functions are identical. */
-/* #undef FC_DUMMY_MAIN_EQ_F77 */
-
-/* Define to a macro mangling the given C identifier (in lower and upper
-   case), which must not contain underscores, for linking with Fortran. */
-#ifndef P4EST_FC_FUNC
-#define P4EST_FC_FUNC(name,NAME) name ## _
-#endif
-
-/* As FC_FUNC, but for C identifiers containing underscores. */
-#ifndef P4EST_FC_FUNC_
-#define P4EST_FC_FUNC_(name,NAME) name ## _
-#endif
-
-/* Define to 1 if your Fortran compiler doesn't accept -c and -o together. */
-/* #undef FC_NO_MINUS_C_MINUS_O */
-
-/* Define to 1 if you have the `aligned_alloc' function. */
-#ifndef P4EST_HAVE_ALIGNED_ALLOC
-#define P4EST_HAVE_ALIGNED_ALLOC 1
-#endif
-
-/* Define to 1 if you have the <arpa/inet.h> header file. */
-#ifndef P4EST_HAVE_ARPA_INET_H
-#define P4EST_HAVE_ARPA_INET_H 1
-#endif
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#ifndef P4EST_HAVE_DLFCN_H
-#define P4EST_HAVE_DLFCN_H 1
-#endif
-
-/* Define to 1 if you have the `fsync' function. */
-#ifndef P4EST_HAVE_FSYNC
-#define P4EST_HAVE_FSYNC 1
-#endif
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#ifndef P4EST_HAVE_INTTYPES_H
-#define P4EST_HAVE_INTTYPES_H 1
-#endif
-
-/* Have we found function pthread_create. */
-#ifndef P4EST_HAVE_LPTHREAD
-#define P4EST_HAVE_LPTHREAD 1
-#endif
-
-/* Have we found function lua_createtable. */
-/* #undef HAVE_LUA */
-
-/* Define to 1 if you have the <memory.h> header file. */
-#ifndef P4EST_HAVE_MEMORY_H
-#define P4EST_HAVE_MEMORY_H 1
-#endif
-
-/* Define to 1 if you have the <netinet/in.h> header file. */
-#ifndef P4EST_HAVE_NETINET_IN_H
-#define P4EST_HAVE_NETINET_IN_H 1
-#endif
-
-/* Have we found function omp_get_thread_num. */
-#ifndef P4EST_HAVE_OPENMP
-#define P4EST_HAVE_OPENMP 1
-#endif
-
-/* Define to 1 if you have the `posix_memalign' function. */
-#ifndef P4EST_HAVE_POSIX_MEMALIGN
-#define P4EST_HAVE_POSIX_MEMALIGN 1
-#endif
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#ifndef P4EST_HAVE_STDINT_H
-#define P4EST_HAVE_STDINT_H 1
-#endif
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#ifndef P4EST_HAVE_STDLIB_H
-#define P4EST_HAVE_STDLIB_H 1
-#endif
-
-/* Define to 1 if you have the <strings.h> header file. */
-#ifndef P4EST_HAVE_STRINGS_H
-#define P4EST_HAVE_STRINGS_H 1
-#endif
-
-/* Define to 1 if you have the <string.h> header file. */
-#ifndef P4EST_HAVE_STRING_H
-#define P4EST_HAVE_STRING_H 1
-#endif
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#ifndef P4EST_HAVE_SYS_STAT_H
-#define P4EST_HAVE_SYS_STAT_H 1
-#endif
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#ifndef P4EST_HAVE_SYS_TYPES_H
-#define P4EST_HAVE_SYS_TYPES_H 1
-#endif
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#ifndef P4EST_HAVE_UNISTD_H
-#define P4EST_HAVE_UNISTD_H 1
-#endif
-
-/* Have we found function adler32_combine. */
-#ifndef P4EST_HAVE_ZLIB
-#define P4EST_HAVE_ZLIB 1
-#endif
-
-/* Linker flags */
-#ifndef P4EST_LDFLAGS
-#define P4EST_LDFLAGS ""
-#endif
-
-/* Libraries */
-#ifndef P4EST_LIBS
-#define P4EST_LIBS "-lgomp   -lz   "
-#endif
-
-/* Define to the sub-directory where libtool stores uninstalled libraries. */
-#ifndef P4EST_LT_OBJDIR
-#define P4EST_LT_OBJDIR ".libs/"
-#endif
-
-/* DEPRECATED (use P4EST_ENABLE_MEMALIGN instead) */
-#ifndef P4EST_MEMALIGN
-#define P4EST_MEMALIGN 1
-#endif
-
-/* desired alignment of allocations in bytes */
-#ifndef P4EST_MEMALIGN_BYTES
-#define P4EST_MEMALIGN_BYTES (P4EST_SIZEOF_VOID_P)
-#endif
-
-/* DEPRECATED (use P4EST_WITH_METIS instead) */
-/* #undef METIS */
-
-/* DEPRECATED (use P4EST_ENABLE_MPI instead) */
-/* #undef MPI */
-
-/* DEPRECATED (use P4EST_ENABLE_MPIIO instead) */
-/* #undef MPIIO */
-
-/* Define to 1 if your C compiler doesn't accept -c and -o together. */
-/* #undef NO_MINUS_C_MINUS_O */
-
-/* DEPRECATED (use P4EST_ENABLE_OPENMP instead) */
-/* #undef OPENMP */
-
-/* Name of package */
-#ifndef P4EST_PACKAGE
-#define P4EST_PACKAGE "p4est"
-#endif
-
-/* Define to the address where bug reports for this package should be sent. */
-#ifndef P4EST_PACKAGE_BUGREPORT
-#define P4EST_PACKAGE_BUGREPORT "info@p4est.org"
-#endif
-
-/* Define to the full name of this package. */
-#ifndef P4EST_PACKAGE_NAME
-#define P4EST_PACKAGE_NAME "p4est"
-#endif
-
-/* Define to the full name and version of this package. */
-#ifndef P4EST_PACKAGE_STRING
-#define P4EST_PACKAGE_STRING "p4est UNKNOWN"
-#endif
-
-/* Define to the one symbol short name of this package. */
-#ifndef P4EST_PACKAGE_TARNAME
-#define P4EST_PACKAGE_TARNAME "p4est"
-#endif
-
-/* Define to the home page for this package. */
-#ifndef P4EST_PACKAGE_URL
-#define P4EST_PACKAGE_URL ""
-#endif
-
-/* Define to the version of this package. */
-#ifndef P4EST_PACKAGE_VERSION
-#define P4EST_PACKAGE_VERSION "UNKNOWN"
-#endif
-
-/* DEPRECATED (use P4EST_WITH_PETSC instead) */
-/* #undef PETSC */
-
-/* Use builtin getopt */
-/* #undef PROVIDE_GETOPT */
-
-/* Use builtin obstack */
-#ifndef P4EST_PROVIDE_OBSTACK
-#define P4EST_PROVIDE_OBSTACK 1
-#endif
-
-/* DEPRECATED (use P4EST_ENABLE_PTHREAD instead) */
-/* #undef PTHREAD */
-
-/* DEPRECATED (use P4EST_WITH_SC instead) */
-/* #undef SC */
-
-/* The size of `void *', as computed by sizeof. */
-#ifndef P4EST_SIZEOF_VOID_P
-#define P4EST_SIZEOF_VOID_P 8
-#endif
-
-/* Define to 1 if you have the ANSI C header files. */
-#ifndef P4EST_STDC_HEADERS
-#define P4EST_STDC_HEADERS 1
-#endif
-
-/* Version number of package */
-#ifndef P4EST_VERSION
-#define P4EST_VERSION "UNKNOWN"
-#endif
-
-/* Package major version */
-#ifndef P4EST_VERSION_MAJOR
-#define P4EST_VERSION_MAJOR UNKNOWN
-#endif
-
-/* Package minor version */
-#ifndef P4EST_VERSION_MINOR
-#define P4EST_VERSION_MINOR N
-#endif
-
-/* Package point version */
-#ifndef P4EST_VERSION_POINT
-#define P4EST_VERSION_POINT 
-#endif
-
-/* DEPRECATED (use P4EST_ENABLE_VTK_BINARY instead) */
-/* #undef VTK_BINARY */
-
-/* DEPRECATED (use P4EST_ENABLE_VTK_COMPRESSION instead) */
-#ifndef P4EST_VTK_COMPRESSION
-#define P4EST_VTK_COMPRESSION 1
-#endif
-
-/* DEPRECATED (use P4EST_ENABLE_VTK_DOUBLES instead) */
-/* #undef VTK_DOUBLES */
-
-/* Define to 1 if BLAS is used */
-/* #undef WITH_BLAS */
-
-/* Define to 1 if LAPACK is used */
-/* #undef WITH_LAPACK */
-
-/* enable metis-dependent code */
-/* #undef WITH_METIS */
-
-/* enable PETSc-dependent code */
-/* #undef WITH_PETSC */
-
-/* path to installed package sc (optional) */
-/* #undef WITH_SC */
- 
-/* once: _SRC_P_EST_CONFIG_H */
-#endif
diff --git a/OctreeRefinement/include/p4est_connectivity.h b/OctreeRefinement/include/p4est_connectivity.h
deleted file mode 100644
index 2413cd5..0000000
--- a/OctreeRefinement/include/p4est_connectivity.h
+++ /dev/null
@@ -1,773 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p4est_connectivity.h
- *
- * The coarse topological description of the forest.
- *
- * \ingroup p4est
- */
-
-#ifndef P4EST_CONNECTIVITY_H
-#define P4EST_CONNECTIVITY_H
-
-#ifdef P4_TO_P8
-#error "Including a p4est header with P4_TO_P8 defined"
-#endif
-
-#include <sc_io.h>
-#include <p4est_base.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** The spatial dimension */
-#define P4EST_DIM 2
-/** The number of faces of a quadrant */
-#define P4EST_FACES (2 * P4EST_DIM)
-/** The number of children of a quadrant
- *
- * also the number of corners */
-#define P4EST_CHILDREN 4
-/** The number of children/corners touching one face */
-#define P4EST_HALF (P4EST_CHILDREN / 2)
-/** The size of insulation layer */
-#define P4EST_INSUL 9
-
-/* size of face transformation encoding */
-#define P4EST_FTRANSFORM 9
-
-/** p4est identification string */
-#define P4EST_STRING "p4est"
-
-/* Increase this number whenever the on-disk format for
- * p4est_connectivity, p4est, or any other 2D data structure changes.
- * The format for reading and writing must be the same.
- */
-#define P4EST_ONDISK_FORMAT 0x2000009
-
-/** Characterize a type of adjacency.
- *
- * Several functions involve relationships between neighboring trees and/or
- * quadrants, and their behavior depends on how one defines adjacency:
- * 1) entities are adjacent if they share a face, or
- * 2) entities are adjacent if they share a face or corner.
- * p4est_connect_type_t is used to choose the desired behavior.
- * This enum must fit into an int8_t.
- */
-typedef enum
-{
-  /* make sure to have different values 2D and 3D */
-  P4EST_CONNECT_FACE = 21,
-  P4EST_CONNECT_CORNER = 22,
-  P4EST_CONNECT_FULL = P4EST_CONNECT_CORNER
-}
-p4est_connect_type_t;
-
-#ifdef P4EST_BACKWARD_DEALII
-typedef p4est_connect_type_t p4est_balance_type_t;
-#endif
-
-/** Typedef for serialization method. */
-typedef enum
-{
-  P4EST_CONN_ENCODE_NONE = SC_IO_ENCODE_NONE,
-  P4EST_CONN_ENCODE_LAST        /**< Invalid entry to close the list. */
-}
-p4est_connectivity_encode_t;
-
-/** Convert the p4est_connect_type_t into a number.
- * \param [in] btype    The balance type to convert.
- * \return              Returns 1 or 2.
- */
-int                 p4est_connect_type_int (p4est_connect_type_t btype);
-
-/** Convert the p4est_connect_type_t into a const string.
- * \param [in] btype    The balance type to convert.
- * \return              Returns a pointer to a constant string.
- */
-const char         *p4est_connect_type_string (p4est_connect_type_t btype);
-
-/** This structure holds the 2D inter-tree connectivity information.
- * Identification of arbitrary faces and corners is possible.
- *
- * The arrays tree_to_* are stored in z ordering.
- * For corners the order wrt. yx is 00 01 10 11.
- * For faces the order is -x +x -y +y.
- * They are allocated [0][0]..[0][3]..[num_trees-1][0]..[num_trees-1][3].
- *
- * The values for tree_to_face are 0..7
- * where ttf % 4 gives the face number and ttf / 4 the face orientation code.
- * The orientation is 0 for edges that are aligned in z-order,
- * and 1 for edges that are running opposite in z-order.
- *
- * It is valid to specify num_vertices as 0.
- * In this case vertices and tree_to_vertex are set to NULL.
- * Otherwise the vertex coordinates are stored in the array vertices as
- * [0][0]..[0][2]..[num_vertices-1][0]..[num_vertices-1][2].
- *
- * The corners are only stored when they connect trees.
- * In this case tree_to_corner indexes into \a ctt_offset.
- * Otherwise the tree_to_corner entry must be -1 and this corner is ignored.
- * If num_corners == 0, tree_to_corner and corner_to_* arrays are set to NULL.
- *
- * The arrays corner_to_* store a variable number of entries per corner.
- * For corner c these are at position [ctt_offset[c]]..[ctt_offset[c+1]-1].
- * Their number for corner c is ctt_offset[c+1] - ctt_offset[c].
- * The entries encode all trees adjacent to corner c.
- * The size of the corner_to_* arrays is num_ctt = ctt_offset[num_corners].
- *
- * The *_to_attr arrays may have arbitrary contents defined by the user.
- */
-typedef struct p4est_connectivity
-{
-  p4est_topidx_t      num_vertices; /**< the number of vertices that define
-                                         the \a embedding of the forest (not
-                                         the topology) */
-  p4est_topidx_t      num_trees;    /**< the number of trees */
-  p4est_topidx_t      num_corners;  /**< the number of corners that help
-                                         define topology */
-  double             *vertices;     /**< an array of size
-                                         (3 * \a num_vertices) */
-  p4est_topidx_t     *tree_to_vertex; /**< embed each tree into \f$R^3\f$ for
-                                           e.g. visualization (see
-                                           p4est_vtk.h) */
-
-  size_t              tree_attr_bytes;  /**< bytes per tree in tree_to_attr */
-  char               *tree_to_attr;     /**< not touched by p4est */
-
-  p4est_topidx_t     *tree_to_tree; /**< (4 * \a num_trees) neighbors across
-                                         faces */
-  int8_t             *tree_to_face; /**< (4 * \a num_trees) face to
-                                         face+orientation (see description) */
-
-  p4est_topidx_t     *tree_to_corner; /**< (4 * \a num_trees) or NULL (see
-                                           description) */
-  p4est_topidx_t     *ctt_offset; /**< corner to offset in \a corner_to_tree
-                                       and \a corner_to_corner */
-  p4est_topidx_t     *corner_to_tree; /**< list of trees that meet at a corner */
-  int8_t             *corner_to_corner; /**< list of tree-corners that meet at
-                                             a corner */
-}
-p4est_connectivity_t;
-
-/** Calculate memory usage of a connectivity structure.
- * \param [in] conn   Connectivity structure.
- * \return            Memory used in bytes.
- */
-size_t              p4est_connectivity_memory_used (p4est_connectivity_t *
-                                                    conn);
-
-typedef struct
-{
-  p4est_topidx_t      ntree;
-  int8_t              ncorner;
-}
-p4est_corner_transform_t;
-
-typedef struct
-{
-  p4est_topidx_t      icorner;
-  sc_array_t          corner_transforms;
-}
-p4est_corner_info_t;
-
-/** Store the corner numbers 0..4 for each tree face. */
-extern const int    p4est_face_corners[4][2];
-
-/** Store the face numbers in the face neighbor's system. */
-extern const int    p4est_face_dual[4];
-
-/** Store the face numbers 0..3 for each tree corner. */
-extern const int    p4est_corner_faces[4][2];
-
-/** Store the face corner numbers for the faces touching a tree corner. */
-extern const int    p4est_corner_face_corners[4][4];
-
-/** Store the faces for each child and corner, can be -1. */
-extern const int    p4est_child_corner_faces[4][4];
-
-/** Transform a face corner across one of the adjacent faces into a neighbor tree.
- * This version expects the neighbor face and orientation separately.
- * \param [in] fc   A face corner number in 0..1.
- * \param [in] f    A face number that touches the corner \a c.
- * \param [in] nf   A neighbor face that is on the other side of \f.
- * \param [in] o    The orientation between tree boundary faces \a f and \nf.
- */
-int                 p4est_connectivity_face_neighbor_face_corner_orientation
-  (int fc, int f, int nf, int o);
-
-/** Transform a corner across one of the adjacent faces into a neighbor tree.
- * This version expects the neighbor face and orientation separately.
- * \param [in] c    A corner number in 0..3.
- * \param [in] f    A face number that touches the corner \a c.
- * \param [in] nf   A neighbor face that is on the other side of \f.
- * \param [in] o    The orientation between tree boundary faces \a f and \nf.
- */
-int                 p4est_connectivity_face_neighbor_corner_orientation
-  (int c, int f, int nf, int o);
-
-/** Allocate a connectivity structure.
- * The attribute fields are initialized to NULL.
- * \param [in] num_vertices   Number of total vertices (i.e. geometric points).
- * \param [in] num_trees      Number of trees in the forest.
- * \param [in] num_corners    Number of tree-connecting corners.
- * \param [in] num_ctt        Number of total trees in corner_to_tree array.
- * \return                    A connectivity structure with allocated arrays.
- */
-p4est_connectivity_t *p4est_connectivity_new (p4est_topidx_t num_vertices,
-                                              p4est_topidx_t num_trees,
-                                              p4est_topidx_t num_corners,
-                                              p4est_topidx_t num_ctt);
-
-/** Allocate a connectivity structure and populate from constants.
- * The attribute fields are initialized to NULL.
- * \param [in] num_vertices   Number of total vertices (i.e. geometric points).
- * \param [in] num_trees      Number of trees in the forest.
- * \param [in] num_corners    Number of tree-connecting corners.
- * \param [in] coff           Corner-to-tree offsets (num_corners + 1 values).
- *                            This must always be non-NULL; in trivial cases
- *                            it is just a pointer to a p4est_topix value of 0.
- * \return                    The connectivity is checked for validity.
- */
-p4est_connectivity_t *p4est_connectivity_new_copy (p4est_topidx_t
-                                                   num_vertices,
-                                                   p4est_topidx_t num_trees,
-                                                   p4est_topidx_t num_corners,
-                                                   const double *vertices,
-                                                   const p4est_topidx_t * ttv,
-                                                   const p4est_topidx_t * ttt,
-                                                   const int8_t * ttf,
-                                                   const p4est_topidx_t * ttc,
-                                                   const p4est_topidx_t *
-                                                   coff,
-                                                   const p4est_topidx_t * ctt,
-                                                   const int8_t * ctc);
-
-/** Broadcast a connectivity structure that exists only on one process to all.
- *  On the other processors, it will be allocated using p4est_connectivity_new.
- *  \param [in] conn_in For the root process the connectivity to be broadcast,
- *                      for the other processes it must be NULL.
- *  \param [in] root    The rank of the process that provides the connectivity.
- *  \param [in] comm    The MPI communicator.
- *  \return             For the root process this is a pointer to \a conn_in.
- *                      Else, a pointer to a newly allocated connectivity
- *                      structure with the same values as \a conn_in on the
- *                      root process.
- */
-p4est_connectivity_t *p4est_connectivity_bcast (p4est_connectivity_t *
-                                                conn_in, int root,
-                                                sc_MPI_Comm comm);
-
-/** Destroy a connectivity structure.  Also destroy all attributes.
- */
-void                p4est_connectivity_destroy (p4est_connectivity_t *
-                                                connectivity);
-
-/** Allocate or free the attribute fields in a connectivity.
- * \param [in,out] conn         The conn->*_to_attr fields must either be NULL
- *                              or previously be allocated by this function.
- * \param [in] bytes_per_tree   If 0, tree_to_attr is freed (being NULL is ok).
- *                              If positive, requested space is allocated.
- */
-void                p4est_connectivity_set_attr (p4est_connectivity_t * conn,
-                                                 size_t bytes_per_tree);
-
-/** Examine a connectivity structure.
- * \return          Returns true if structure is valid, false otherwise.
- */
-int                 p4est_connectivity_is_valid (p4est_connectivity_t *
-                                                 connectivity);
-
-/** Check two connectivity structures for equality.
- * \return          Returns true if structures are equal, false otherwise.
- */
-int                 p4est_connectivity_is_equal (p4est_connectivity_t * conn1,
-                                                 p4est_connectivity_t *
-                                                 conn2);
-
-/** Write connectivity to a sink object.
- * \param [in] conn     The connectivity to be written.
- * \param [in,out] sink The connectivity is written into this sink.
- * \return              0 on success, nonzero on error.
- */
-int                 p4est_connectivity_sink (p4est_connectivity_t * conn,
-                                             sc_io_sink_t * sink);
-
-/** Allocate memory and store the connectivity information there.
- * \param [in] conn     The connectivity structure to be exported to memory.
- * \param [in] code     Encoding and compression method for serialization.
- * \return              Newly created array that contains the information.
- */
-sc_array_t         *p4est_connectivity_deflate (p4est_connectivity_t * conn,
-                                                p4est_connectivity_encode_t
-                                                code);
-
-/** Save a connectivity structure to disk.
- * \param [in] filename         Name of the file to write.
- * \param [in] connectivity     Valid connectivity structure.
- * \return                      Returns 0 on success, nonzero on file error.
- */
-int                 p4est_connectivity_save (const char *filename,
-                                             p4est_connectivity_t *
-                                             connectivity);
-
-/** Read connectivity from a source object.
- * \param [in,out] source       The connectivity is read from this source.
- * \return              The newly created connectivity, or NULL on error.
- */
-p4est_connectivity_t *p4est_connectivity_source (sc_io_source_t * source);
-
-/** Create new connectivity from a memory buffer.
- * \param [in] buffer   The connectivity is created from this memory buffer.
- * \return              The newly created connectivity, or NULL on error.
- */
-p4est_connectivity_t *p4est_connectivity_inflate (sc_array_t * buffer);
-
-/** Load a connectivity structure from disk.
- * \param [in] filename         Name of the file to read.
- * \param [in,out] bytes        Size in bytes of connectivity on disk or NULL.
- * \return              Returns valid connectivity, or NULL on file error.
- */
-p4est_connectivity_t *p4est_connectivity_load (const char *filename,
-                                               size_t * bytes);
-
-/** Create a connectivity structure for the unit square.
- */
-p4est_connectivity_t *p4est_connectivity_new_unitsquare (void);
-
-/** Create a connectivity structure for an all-periodic unit square.
- */
-p4est_connectivity_t *p4est_connectivity_new_periodic (void);
-
-/** Create a connectivity structure for a periodic unit square.
- * The left and right faces are identified, and bottom and top opposite.
- */
-p4est_connectivity_t *p4est_connectivity_new_rotwrap (void);
-
-/** Create a connectivity structure for two trees being rotated
- * w.r.t. each other in a user-defined way
- * \param[in] l_face      index of left face
- * \param[in] r_face      index of right face
- * \param[in] orientation orientation of trees w.r.t. each other
- */
-p4est_connectivity_t *p4est_connectivity_new_twotrees (int l_face,
-                                                       int r_face,
-                                                       int orientation);
-
-/** Create a connectivity structure for a three-tree mesh around a corner.
- */
-p4est_connectivity_t *p4est_connectivity_new_corner (void);
-
-/** Create a connectivity structure for two trees on top of each other.
- */
-p4est_connectivity_t *p4est_connectivity_new_pillow (void);
-
-/** Create a connectivity structure for a five-tree moebius band.
- */
-p4est_connectivity_t *p4est_connectivity_new_moebius (void);
-
-/** Create a connectivity structure for a six-tree star.
- */
-p4est_connectivity_t *p4est_connectivity_new_star (void);
-
-/** Create a connectivity structure for the six sides of a unit cube.
- * The ordering of the trees is as follows: 0 1
- *                                            2 3 <-- 3: axis-aligned top side
- *                                              4 5.
- * This choice has been made for maximum symmetry (see tree_to_* in .c file).
- */
-p4est_connectivity_t *p4est_connectivity_new_cubed (void);
-
-/** Create a connectivity structure for a five-tree flat spherical disk.
- * The ordering of the trees is as follows:   4
- *                                          1 2 3
- *                                            0.
- */
-p4est_connectivity_t *p4est_connectivity_new_disk (void);
-
-/** An m by n array with periodicity in x and y if periodic_a and periodic_b
- * are true, respectively.
- */
-p4est_connectivity_t *p4est_connectivity_new_brick (int mi, int ni,
-                                                    int periodic_a,
-                                                    int periodic_b);
-
-/** Create connectivity structure from predefined catalogue.
- * \param [in]  name            Invokes connectivity_new_* function.
- *              brick23         brick (2, 3, 0, 0)
- *              corner          corner
- *              cubed           cubed
- *              disk            disk
- *              moebius         moebius
- *              periodic        periodic
- *              pillow          pillow
- *              rotwrap         rotwrap
- *              star            star
- *              unit            unitsquare
- * \return      An initialized connectivity if name is defined, NULL else.
- */
-p4est_connectivity_t *p4est_connectivity_new_byname (const char *name);
-
-/** Uniformly refine a connectivity.
- * This is useful if you would like to uniformly refine by something other
- * than a power of 2.
- *
- * \param [in] conn         a valid connectivity
- * \param [in] num_per_edge the number of new trees in each direction
- *
- * \return a refined connectivity.
- */
-p4est_connectivity_t *p4est_connectivity_refine (p4est_connectivity_t * conn,
-                                                 int num_per_edge);
-
-/** Fill an array with the axis combination of a face neighbor transform.
- * \param [in]  iface       The number of the originating face.
- * \param [in]  nface       Encoded as nface = r * 4 + nf, where nf = 0..3 is
- *                          the neigbbor's connecting face number and r = 0..1
- *                          is the relative orientation to the neighbor's face.
- *                          This encoding matches p4est_connectivity_t.
- * \param [out] ftransform  This array holds 9 integers.
- *              [0,2]       The coordinate axis sequence of the origin face,
- *                          the first referring to the tangential and the second
- *                          to the normal.  A permutation of (0, 1).
- *              [3,5]       The coordinate axis sequence of the target face.
- *              [6,8]       Edge reversal flag for tangential axis (boolean);
- *                          face code in [0, 3] for the normal coordinate q:
- *                          0: q' = -q
- *                          1: q' = q + 1
- *                          2: q' = q - 1
- *                          3: q' = 2 - q
- *              [1,4,7]     0 (unused for compatibility with 3D).
- */
-void                p4est_expand_face_transform (int iface, int nface,
-                                                 int ftransform[]);
-
-/** Fill an array with the axis combinations of a tree neighbor transform.
- * \param [in]  itree       The number of the originating tree.
- * \param [in]  iface       The number of the originating tree's face.
- * \param [out] ftransform  This array holds 9 integers.
- *              [0,2]       The coordinate axis sequence of the origin face.
- *              [3,5]       The coordinate axis sequence of the target face.
- *              [6,8]       Edge reverse flag for axis t; face code for axis n.
- *              [1,4,7]     0 (unused for compatibility with 3D).
- * \return                  The face neighbor tree if it exists, -1 otherwise.
- */
-p4est_topidx_t      p4est_find_face_transform (p4est_connectivity_t *
-                                               connectivity,
-                                               p4est_topidx_t itree,
-                                               int iface, int ftransform[]);
-
-/** Fills an array with information about corner neighbors.
- * \param [in] itree    The number of the originating tree.
- * \param [in] icorner  The number of the originating corner.
- * \param [in,out] ci   A p4est_corner_info_t structure with initialized array.
- */
-void                p4est_find_corner_transform (p4est_connectivity_t *
-                                                 connectivity,
-                                                 p4est_topidx_t itree,
-                                                 int icorner,
-                                                 p4est_corner_info_t * ci);
-
-/** Internally connect a connectivity based on tree_to_vertex information.
- * Periodicity that is not inherent in the list of vertices will be lost.
- * \param [in,out] conn     The connectivity needs to have proper vertices
- *                          and tree_to_vertex fields.  The tree_to_tree
- *                          and tree_to_face fields must be allocated
- *                          and satisfy p4est_connectivity_is_valid (conn)
- *                          but will be overwritten.  The corner
- *                          fields will be freed and allocated anew.
- */
-void                p4est_connectivity_complete (p4est_connectivity_t * conn);
-
-/** Removes corner information of a connectivity
- *  such that enough information is left to run p4est_connectivity_complete successfully.
- *  The reduced connectivity still passes p4est_connectivity_is_valid.
- * \param [in,out] conn     The connectivity to be reduced.
- */
-void                p4est_connectivity_reduce (p4est_connectivity_t * conn);
-
-/** p4est_connectivity_permute
- * Given a permutation \a perm of the trees in a connectivity \a conn,
- * permute the trees of \a conn in place and update \a conn to match.
- * \param [in,out] conn                The connectivity whose trees are
- *                                     permuted.
- * \param [in] perm                    A permutation array, whose elements are
- *                                     size_t's.
- * \param [in] is_current_to_new       if true, the jth entry of perm is the
- *                                     new index for the entry whose current
- *                                     index is j, otherwise the jth entry of
- *                                     perm is the current index of the tree
- *                                     whose index will be j after the
- *                                     permutation.
- */
-void                p4est_connectivity_permute (p4est_connectivity_t * conn,
-                                                sc_array_t * perm,
-                                                int is_current_to_new);
-#ifdef P4EST_WITH_METIS
-
-/** p4est_connectivity_reorder
- * This function takes a connectivity \a conn and a parameter \a k,
- * which will typically be the number of processes, and reorders the trees
- * such that if every processes is assigned (num_trees / k) trees, the
- * communication volume will be minimized.  This is intended for use with
- * connectivities that contain a large number of trees.  This should be done
- * BEFORE a p4est is created using the connectivity.  This is done in place:
- * any data structures that use indices to refer to trees before this
- * procedure will be invalid.  Note that this routine calls metis and not
- * parmetis because the connectivity is copied on every process.
- * A communicator is required because I'm not positive that metis is
- * deterministic. \a ctype determines when an edge exist between two trees in
- * the dual graph used by metis in the reordering.
- * \param [in]     comm       MPI communicator.
- * \param [in]     k          if k > 0, the number of pieces metis will use to
- *                            guide the reordering; if k = 0, the number of
- *                            pieces will be determined from the MPI
- *                            communicator.
- * \param [in,out] conn       connectivity that will be reordered.
- * \param [in]     ctype      determines when an edge exists in the dual graph
- *                            of the connectivity structure.
- */
-void                p4est_connectivity_reorder (MPI_Comm comm, int k,
-                                                p4est_connectivity_t * conn,
-                                                p4est_connect_type_t ctype);
-
-#endif /* P4EST_WITH_METIS */
-
-/** p4est_connectivity_join_faces
- * This function takes an existing valid connectivity \a conn and modifies it
- * by joining two tree faces that are currently boundary faces.
- * \param [in,out] conn        connectivity that will be altered.
- * \param [in]     tree_left   tree that will be on the left side of the joined
- *                             faces.
- * \param [in]     tree_right  tree that will be on the right side of the
- *                             joined faces.
- * \param [in]     face_left   face of \a tree_left that will be joined.
- * \param [in]     face_right  face of \a tree_right that will be joined.
- * \param [in]     orientation the orientation of \a face_left and
- *                             \a face_right once joined (see the description
- *                             of p4est_connectivity_t to understand
- *                             orientation).
- */
-void                p4est_connectivity_join_faces (p4est_connectivity_t *
-                                                   conn,
-                                                   p4est_topidx_t tree_left,
-                                                   p4est_topidx_t tree_right,
-                                                   int face_left,
-                                                   int face_right,
-                                                   int orientation);
-
-/** p4est_connectivity_is_equivalent
- * This function compares two connectivities for equivalence: it returns
- * \a true if they are the same connectivity, or if they have the same
- * topology.  The definition of topological sameness is strict: there is no
- * attempt made to determine whether permutation and/or rotation of the trees
- * makes the connectivities equivalent.
- *
- * \param[in]      conn1    a valid connectivity
- * \param[out]     conn2    a valid connectivity
- */
-int                 p4est_connectivity_is_equivalent (p4est_connectivity_t *
-                                                      conn1,
-                                                      p4est_connectivity_t *
-                                                      conn2);
-
-/** Return a pointer to a p4est_corner_transform_t array element. */
-/*@unused@*/
-static inline p4est_corner_transform_t *
-p4est_corner_array_index (sc_array_t * array, size_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p4est_corner_transform_t));
-  P4EST_ASSERT (it < array->elem_count);
-
-  return
-    (p4est_corner_transform_t *) (array->array +
-                                  sizeof (p4est_corner_transform_t) * it);
-}
-
-/** Read an ABAQUS input file from a file stream.
- *
- * This utility function reads a basic ABAQUS file supporting element type with
- * the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as
- * bilinear quadrilateral and trilinear hexahedral trees respectively.
- *
- * A basic 2D mesh is given below.  The \c *Node section gives the vertex
- * number and x, y, and z components for each vertex.  The \c *Element section
- * gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter
- * clockwise order. So in 2D the nodes are given as:
- *
- *   4                     3
- *   +-------------------+
- *   |                   |
- *   |                   |
- *   |                   |
- *   |                   |
- *   |                   |
- *   |                   |
- *   +-------------------+
- *   1                   2
- *
- * and in 3D they are given as:
- *
- * 8                     7
- *  +---------------------+
- *  |\                    |\
- *  | \                   | \
- *  |  \                  |  \
- *  |   \                 |   \
- *  |   5+---------------------+6
- *  |    |                |    |
- *  +----|----------------+    |
- *  4\   |               3 \   |
- *    \  |                  \  |
- *     \ |                   \ |
- *      \|                    \|
- *       +---------------------+
- *       1                     2
- *
- * \code
- * *Heading
- *  box.inp
- * *Node
- * 1,  -5, -5, 0
- * 2,   5, -5, 0
- * 3,   5,  5, 0
- * 4,  -5,  5, 0
- * 5,   0, -5, 0
- * 6,   5,  0, 0
- * 7,   0,  5, 0
- * 8,  -5,  0, 0
- * 9,   1, -1, 0
- * 10,  0,  0, 0
- * 11, -2,  1, 0
- * *Element, type=CPS4, ELSET=Surface1
- * 1,  1, 10, 11, 8
- * 2,  3, 10, 9,  6
- * 3,  9, 10, 1,  5
- * 4,  7,  4, 8, 11
- * 5, 11, 10, 3,  7
- * 6,  2,  6, 9,  5
- * \endcode
- *
- * This code can be called two ways.  The first, when \c vertex==NULL and \c
- * tree_to_vertex==NULL, is used to count the number of trees and vertices in
- * the connectivity to be generated by the \c .inp mesh in the \a stream.  The
- * second, when \c vertices!=NULL and \c tree_to_vertex!=NULL, fill \c vertices
- * and \c tree_to_vertex.  In this case \c num_vertices and \c num_trees need
- * to be set to the maximum number of entries allocated in \c vertices and \c
- * tree_to_vertex.
- *
- * \param[in,out]  stream         file stream to read the connectivity from
- * \param[in,out]  num_vertices   the number of vertices in the connectivity
- * \param[in,out]  num_trees      the number of trees in the connectivity
- * \param[out]     vertices       the list of \c vertices of the connectivity
- * \param[out]     tree_to_vertex the \c tree_to_vertex map of the connectivity
- *
- * \returns 0 if successful and nonzero if not
- */
-int                 p4est_connectivity_read_inp_stream (FILE * stream,
-                                                        p4est_topidx_t *
-                                                        num_vertices,
-                                                        p4est_topidx_t *
-                                                        num_trees,
-                                                        double *vertices,
-                                                        p4est_topidx_t *
-                                                        tree_to_vertex);
-
-/** Create a p4est connectivity from an ABAQUS input file.
- *
- * This utility function reads a basic ABAQUS file supporting element type with
- * the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as
- * bilinear quadrilateral and trilinear hexahedral trees respectively.
- *
- * A basic 2D mesh is given below.  The \c *Node section gives the vertex
- * number and x, y, and z components for each vertex.  The \c *Element section
- * gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter
- * clockwise order. So in 2D the nodes are given as:
- *
- *   4                     3
- *   +-------------------+
- *   |                   |
- *   |                   |
- *   |                   |
- *   |                   |
- *   |                   |
- *   |                   |
- *   +-------------------+
- *   1                   2
- *
- * and in 3D they are given as:
- *
- * 8                     7
- *  +---------------------+
- *  |\                    |\
- *  | \                   | \
- *  |  \                  |  \
- *  |   \                 |   \
- *  |   5+---------------------+6
- *  |    |                |    |
- *  +----|----------------+    |
- *  4\   |               3 \   |
- *    \  |                  \  |
- *     \ |                   \ |
- *      \|                    \|
- *       +---------------------+
- *       1                     2
- *
- * \code
- * *Heading
- *  box.inp
- * *Node
- * 1,  -5, -5, 0
- * 2,   5, -5, 0
- * 3,   5,  5, 0
- * 4,  -5,  5, 0
- * 5,   0, -5, 0
- * 6,   5,  0, 0
- * 7,   0,  5, 0
- * 8,  -5,  0, 0
- * 9,   1, -1, 0
- * 10,  0,  0, 0
- * 11, -2,  1, 0
- * *Element, type=CPS4, ELSET=Surface1
- * 1,  1, 10, 11, 8
- * 2,  3, 10, 9,  6
- * 3,  9, 10, 1,  5
- * 4,  7,  4, 8, 11
- * 5, 11, 10, 3,  7
- * 6,  2,  6, 9,  5
- * \endcode
- *
- * This function reads a mesh from \a filename and returns an associated p4est
- * connectivity.
- *
- * \param[in]  filename         file to read the connectivity from
- *
- * \return  an allocated connectivity associated with the mesh in \a filename
- *          or NULL if an error occurred.
- */
-p4est_connectivity_t *p4est_connectivity_read_inp (const char *filename);
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_CONNECTIVITY_H */
diff --git a/OctreeRefinement/include/p4est_extended.h b/OctreeRefinement/include/p4est_extended.h
deleted file mode 100644
index 94b9253..0000000
--- a/OctreeRefinement/include/p4est_extended.h
+++ /dev/null
@@ -1,399 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/********************************************************************
- *                          IMPORTANT NOTE                          *
- *                                                                  *
- * These interfaces are intended for those who like finer control.  *
- * The API offers extended versions of some basic p4est functions.  *
- * The API may change without notice.                               *
- ********************************************************************/
-
-/** \file p4est_extended.h
- *
- * Interface routines with extended capabilities.
- *
- * \ingroup p4est
- */
-
-#ifndef P4EST_EXTENDED_H
-#define P4EST_EXTENDED_H
-
-#include <p4est.h>
-#include <p4est_mesh.h>
-#include <p4est_iterate.h>
-#include <p4est_lnodes.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Data pertaining to selecting, inspecting, and profiling algorithms.
- * A pointer to this structure is hooked into the p4est main structure.
- *
- *
- * The balance_ranges and balance_notify* times are collected
- * whenever an inspect structure is present in p4est.
- */
-/* TODO: Describe the purpose of various switches, counters, and timings. */
-struct p4est_inspect
-{
-  /** Use sc_ranges to determine the asymmetric communication pattern.
-   * If \a use_balance_ranges is false (the default), sc_notify is used. */
-  int                 use_balance_ranges;
-  /** If true, call both sc_ranges and sc_notify and verify consistency.
-   * Which is actually used is still determined by \a use_balance_ranges. */
-  int                 use_balance_ranges_notify;
-  /** Verify sc_ranges and/or sc_notify as applicable. */
-  int                 use_balance_verify;
-  /** If positive and smaller than p4est_num ranges, overrides it */
-  int                 balance_max_ranges;
-  size_t              balance_A_count_in;
-  size_t              balance_A_count_out;
-  size_t              balance_comm_sent;
-  size_t              balance_comm_nzpeers;
-  size_t              balance_B_count_in;
-  size_t              balance_B_count_out;
-  size_t              balance_zero_sends[2], balance_zero_receives[2];
-  double              balance_A;
-  double              balance_comm;
-  double              balance_B;
-  double              balance_ranges;   /**< time spent in sc_ranges */
-  double              balance_notify;   /**< time spent in sc_notify */
-  /** time spent in sc_notify_allgather */
-  double              balance_notify_allgather;
-  int                 use_B;
-};
-
-/** Callback function prototype to replace one set of quadrants with another.
- *
- * This is used by extended routines when the quadrants of an existing, valid
- * p4est are changed.  The callback allows the user to make changes to newly
- * initialized quadrants before the quadrants that they replace are destroyed.
- *
- * \param [in] num_outgoing The number of outgoing quadrants.
- * \param [in] outgoing     The outgoing quadrants: after the callback, the
- *                          user_data, if \a p4est->data_size is nonzero,
- *                          will be destroyed.
- * \param [in] num_incoming The number of incoming quadrants.
- * \param [in,out] incoming The incoming quadrants: prior to the callback,
- *                          the user_data, if \a p4est->data_size is nonzero,
- *                          is allocated, and the p4est_init_t callback,
- *                          if it has been provided, will be called.
- *
- * If the mesh is being refined, num_outgoing will be 1 and num_incoming will
- * be 4, and vice versa if the mesh is being coarsened.
- */
-typedef void        (*p4est_replace_t) (p4est_t * p4est,
-                                        p4est_topidx_t which_tree,
-                                        int num_outgoing,
-                                        p4est_quadrant_t * outgoing[],
-                                        int num_incoming,
-                                        p4est_quadrant_t * incoming[]);
-
-/** Create a new forest.
- * This is a more general form of p4est_new.
- * See the documentation of p4est_new for basic usage.
- *
- * \param [in] min_quadrants    Minimum initial quadrants per processor.
- *                              Makes the refinement pattern mpisize-specific.
- * \param [in] min_level        The forest is refined at least to this level.
- *                              May be negative or 0, then it has no effect.
- * \param [in] fill_uniform     If true, fill the forest with a uniform mesh
- *                              instead of the coarsest possible one.
- *                              The latter is partition-specific so that
- *                              is usually not a good idea.
- */
-p4est_t            *p4est_new_ext (sc_MPI_Comm mpicomm,
-                                   p4est_connectivity_t * connectivity,
-                                   p4est_locidx_t min_quadrants,
-                                   int min_level, int fill_uniform,
-                                   size_t data_size, p4est_init_t init_fn,
-                                   void *user_pointer);
-
-/** Create a new mesh.
- * \param [in] p4est                A forest that is fully 2:1 balanced.
- * \param [in] ghost                The ghost layer created from the
- *                                  provided p4est.
- * \param [in] compute_tree_index   Boolean to decide whether to allocate and
- *                                  compute the quad_to_tree list.
- * \param [in] compute_level_lists  Boolean to decide whether to compute the
- *                                  level lists in quad_level.
- * \param [in] btype                Currently ignored, only face neighbors
- *                                  are stored.
- * \return                          A fully allocated mesh structure.
- */
-p4est_mesh_t       *p4est_mesh_new_ext (p4est_t * p4est,
-                                        p4est_ghost_t * ghost,
-                                        int compute_tree_index,
-                                        int compute_level_lists,
-                                        p4est_connect_type_t btype);
-
-/** Make a deep copy of a p4est.
- * The connectivity is not duplicated.
- * Copying of quadrant user data is optional.
- * If old and new data sizes are 0, the user_data field is copied regardless.
- * The inspect member of the copy is set to NULL.
- * The revision counter of the copy is set to zero.
- *
- * \param [in]  copy_data  If true, data are copied.
- *                         If false, data_size is set to 0.
- * \param [in]  duplicate_mpicomm  If true, MPI communicator is copied.
- * \return  Returns a valid p4est that does not depend on the input,
- *                         except for borrowing the same connectivity.
- *                         Its revision counter is 0.
- */
-p4est_t            *p4est_copy_ext (p4est_t * input, int copy_data,
-                                    int duplicate_mpicomm);
-
-/** Refine a forest with a bounded refinement level and a replace option.
- * \param [in,out] p4est The forest is changed in place.
- * \param [in] refine_recursive Boolean to decide on recursive refinement.
- * \param [in] maxlevel   Maximum allowed refinement level (inclusive).
- *                        If this is negative the level is restricted only
- *                        by the compile-time constant QMAXLEVEL in p4est.h.
- * \param [in] refine_fn  Callback function that must return true if a quadrant
- *                        shall be refined.  If refine_recursive is true,
- *                        refine_fn is called for every existing and newly
- *                        created quadrant.  Otherwise, it is called for every
- *                        existing quadrant.  It is possible that a refinement
- *                        request made by the callback is ignored.  To catch
- *                        this case, you can examine whether init_fn or
- *                        replace_fn gets called.
- * \param [in] init_fn    Callback function to initialize the user_data for
- *                        newly created quadrants, which is guaranteed to be
- *                        allocated.  This function pointer may be NULL.
- * \param [in] replace_fn Callback function that allows the user to change
- *                        incoming quadrants based on the quadrants they
- *                        replace; may be NULL.
- */
-void                p4est_refine_ext (p4est_t * p4est,
-                                      int refine_recursive, int maxlevel,
-                                      p4est_refine_t refine_fn,
-                                      p4est_init_t init_fn,
-                                      p4est_replace_t replace_fn);
-
-/** Coarsen a forest.
- * \param [in,out] p4est The forest is changed in place.
- * \param [in] coarsen_recursive Boolean to decide on recursive coarsening.
- * \param [in] callback_orphans Boolean to enable calling coarsen_fn even on
- *                        non-families.  In this case, the second quadrant
- *                        pointer in the argument list of the callback is NULL,
- *                        subsequent pointers are undefined, and the return
- *                        value is ignored.  If coarsen_recursive is true, it
- *                        is possible that a quadrant is called once or more as
- *                        an orphan and eventually becomes part of a family.
- * \param [in] coarsen_fn Callback function that returns true if a
- *                        family of quadrants shall be coarsened.
- * \param [in] init_fn    Callback function to initialize the user_data
- *                        which is already allocated automatically.
- * \param [in] replace_fn Callback function that allows the user to change
- *                        incoming quadrants based on the quadrants they
- *                        replace.
- */
-void                p4est_coarsen_ext (p4est_t * p4est, int coarsen_recursive,
-                                       int callback_orphans,
-                                       p4est_coarsen_t coarsen_fn,
-                                       p4est_init_t init_fn,
-                                       p4est_replace_t replace_fn);
-
-/** 2:1 balance the size differences of neighboring elements in a forest.
- * \param [in,out] p4est  The p4est to be worked on.
- * \param [in] btype      Balance type (face or corner/full).
- *                        Corner balance is almost never required when
- *                        discretizing a PDE; just causes smoother mesh grading.
- * \param [in] init_fn    Callback function to initialize the user_data
- *                        which is already allocated automatically.
- * \param [in] replace_fn Callback function that allows the user to change
- *                        incoming quadrants based on the quadrants they
- *                        replace.
- */
-void                p4est_balance_ext (p4est_t * p4est,
-                                       p4est_connect_type_t btype,
-                                       p4est_init_t init_fn,
-                                       p4est_replace_t replace_fn);
-
-void                p4est_balance_subtree_ext (p4est_t * p4est,
-                                               p4est_connect_type_t btype,
-                                               p4est_topidx_t which_tree,
-                                               p4est_init_t init_fn,
-                                               p4est_replace_t replace_fn);
-
-/** Repartition the forest.
- *
- * The forest is partitioned between processors such that each processor
- * has an approximately equal number of quadrants (or weight).
- *
- * \param [in,out] p4est      The forest that will be partitioned.
- * \param [in]     partition_for_coarsening     If true, the partition
- *                            is modified to allow one level of coarsening.
- * \param [in]     weight_fn  A weighting function or NULL
- *                            for uniform partitioning.
- * \return         The global number of shipped quadrants
- */
-p4est_gloidx_t      p4est_partition_ext (p4est_t * p4est,
-                                         int partition_for_coarsening,
-                                         p4est_weight_t weight_fn);
-
-/** Correct partition to allow one level of coarsening.
- *
- * \param [in] p4est                     forest whose partition is corrected
- * \param [in,out] num_quadrants_in_proc partition that will be corrected
- * \return                               absolute number of moved quadrants
- */
-p4est_gloidx_t      p4est_partition_for_coarsening (p4est_t * p4est,
-                                                    p4est_locidx_t *
-                                                    num_quadrants_in_proc);
-
-/** p4est_iterate_ext adds the option \a remote: if this is false, then it is
- * the same as p4est_iterate; if this is true, then corner callbacks are also
- * called on corners for hanging faces touched by local quadrants.
- */
-void                p4est_iterate_ext (p4est_t * p4est,
-                                       p4est_ghost_t * ghost_layer,
-                                       void *user_data,
-                                       p4est_iter_volume_t iter_volume,
-                                       p4est_iter_face_t iter_face,
-                                       p4est_iter_corner_t iter_corner,
-                                       int remote);
-
-/** Save the complete connectivity/p4est data to disk.  This is a collective
- * operation that all MPI processes need to call.  All processes write
- * into the same file, so the filename given needs to be identical over
- * all parallel invocations.
- * See p4est_load_ext for information on the autopartition parameter.
- * \param [in] filename    Name of the file to write.
- * \param [in] p4est       Valid forest structure.
- * \param [in] save_data   If true, the element data is saved.
- *                         Otherwise, a data size of 0 is saved.
- * \param [in] save_partition   If false, save file as if 1 core was used.
- *                              If true, save core count and partition.
- *                         Advantage: Partition can be recovered on loading
- *                              with same mpisize and autopartition false.
- *                         Disadvantage: Makes the file depend on mpisize.
- *                  Either way the file can be loaded with autopartition true.
- * \note            Aborts on file errors.
- */
-void                p4est_save_ext (const char *filename, p4est_t * p4est,
-                                    int save_data, int save_partition);
-
-/** Load the complete connectivity/p4est structure from disk.
- * It is possible to load the file with a different number of processors
- * than has been used to write it.  The partition will then be uniform.
- * \param [in] filename         Name of the file to read.
- * \param [in] mpicomm          A valid MPI communicator.
- * \param [in] data_size        Size of data for each quadrant which can be
- *                              zero.  Then user_data_pool is set to NULL.
- *                              If data_size is zero, load_data is ignored.
- * \param [in] load_data        If true, the element data is loaded.  This is
- *                              only permitted if the saved data size matches.
- *                              If false, the stored data size is ignored.
- * \param [in] autopartition    Ignore saved partition and make it uniform.
- * \param [in] broadcasthead    Have only rank 0 read headers and bcast them.
- * \param [in] user_pointer     Assign to the user_pointer member of the p4est
- *                              before init_fn is called the first time.
- * \param [out] connectivity    Connectivity must be destroyed separately.
- * \return          Returns a valid forest structure. A pointer to a valid
- *                  connectivity structure is returned through the last
- *                  argument.
- * \note            Aborts on file errors or invalid file contents.
- */
-p4est_t            *p4est_load_ext (const char *filename, sc_MPI_Comm mpicomm,
-                                    size_t data_size, int load_data,
-                                    int autopartition, int broadcasthead,
-                                    void *user_pointer,
-                                    p4est_connectivity_t ** connectivity);
-
-/** The same as p4est_load_ext, but reading the connectivity/p4est from an
- * open sc_io_source_t stream.
- */
-p4est_t            *p4est_source_ext (sc_io_source_t * src,
-                                      sc_MPI_Comm mpicomm, size_t data_size,
-                                      int load_data, int autopartition,
-                                      int broadcasthead, void *user_pointer,
-                                      p4est_connectivity_t ** connectivity);
-
-/** Create the data necessary to create a PETsc DMPLEX representation of a
- * forest, as well as the accompanying lnodes and ghost layer.  The forest
- * must be at least face balanced (see p4est_balance()).  See
- * test/test_plex2.c for example usage.
- *
- * All arrays should be initialized to hold sizeof (p4est_locidx_t), except
- * for \a out_remotes, which should be initialized to hold
- * (2 * sizeof (p4est_locidx_t)).
- *
- * \param[in]     p4est                 the forest
- * \param[out]    ghost                 the ghost layer
- * \param[out]    lnodes                the lnodes
- * \param[in]     ctype                 the type of adjacency for the overlap
- * \param[in]     overlap               the number of layers of overlap (zero
- *                                      is acceptable)
- * \param[out]    first_local_quad      the local quadrants are assigned
- *                                      contiguous plex indices, starting with
- *                                      this index
- * \param[in,out] out_points_per_dim    filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_cone_sizes        filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_cones             filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_cone_orientations filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_vertex_coords     filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_children          filled with argument for
- *                                      DMPlexSetTree()
- * \param[in,out] out_parents           filled with argument for
- *                                      DMPlexSetTree()
- * \param[in,out] out_childids          filled with argument for
- *                                      DMPlexSetTree()
- * \param[in,out] out_leaves            filled with argument for
- *                                      PetscSFSetGraph()
- * \param[in,out] out_remotes           filled with argument for
- *                                      PetscSFSetGraph()
- * \param[in]     custom_numbering      Whether or use the default numbering
- *                                      (0) of DMPlex child ids or the custom
- *                                      (1).
- */
-void                p4est_get_plex_data_ext (p4est_t * p4est,
-                                             p4est_ghost_t ** ghost,
-                                             p4est_lnodes_t ** lnodes,
-                                             p4est_connect_type_t ctype,
-                                             int overlap,
-                                             p4est_locidx_t *
-                                             first_local_quad,
-                                             sc_array_t * out_points_per_dim,
-                                             sc_array_t * out_cone_sizes,
-                                             sc_array_t * out_cones,
-                                             sc_array_t *
-                                             out_cone_orientations,
-                                             sc_array_t * out_vertex_coords,
-                                             sc_array_t * out_children,
-                                             sc_array_t * out_parents,
-                                             sc_array_t * out_childids,
-                                             sc_array_t * out_leaves,
-                                             sc_array_t * out_remotes,
-                                             int custom_numbering);
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_EXTENDED_H */
diff --git a/OctreeRefinement/include/p4est_geometry.h b/OctreeRefinement/include/p4est_geometry.h
deleted file mode 100644
index f1df947..0000000
--- a/OctreeRefinement/include/p4est_geometry.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p4est_geometry.h transforms from vertex frame to physical space.
- *
- * \ingroup p4est
- */
-
-#ifndef P4EST_GEOMETRY_H
-#define P4EST_GEOMETRY_H
-
-#include <p4est_connectivity.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** This object encapsulates a custom geometry transformation. */
-typedef struct p4est_geometry p4est_geometry_t;
-
-/** Forward transformation from the reference unit square to physical space.
- * Note that the two-dimensional connectivities have 3D vertex coordinates
- * that can be used in the transformation if so desired.
- * The physical space "xyz" is user-defined, currently used for VTK output.
- */
-typedef void        (*p4est_geometry_X_t) (p4est_geometry_t * geom,
-                                           p4est_topidx_t which_tree,
-                                           const double abc[3],
-                                           double xyz[3]);
-
-/** Destructor prototype for a user-allocated \a p4est_geometry_t.
- * It is invoked by p4est_geometry_destroy.  If the user chooses to
- * reserve the structure statically, simply don't call p4est_geometry_destroy.
- */
-typedef void        (*p4est_geometry_destroy_t) (p4est_geometry_t * geom);
-
-/** This structure can be filled or allocated by the user.
- * p4est will never change its contents.
- */
-struct p4est_geometry
-{
-  const char         *name;     /**< User's choice is arbitrary. */
-  void               *user;     /**< User's choice is arbitrary. */
-  p4est_geometry_X_t  X;        /**< Coordinate transformation. */
-  p4est_geometry_destroy_t destroy;     /**< Destructor called by
-                                             p4est_geometry_destroy.  If
-                                             NULL, P4EST_FREE is called. */
-};
-
-/** Can be used to conveniently destroy a geometry structure.
- * The user is free not to call this function at all if they handle the
- * memory of the p4est_geometry_t in their own way.
- */
-void                p4est_geometry_destroy (p4est_geometry_t * geom);
-
-/** Create a geometry structure based on the vertices in a connectivity.
- * The transformation is constructed using bilinear interpolation.
- * \param [in] conn A p4est_connectivity_t with valid vertices.  We do NOT
- *                  take ownership and expect this structure to stay alive.
- * \return          Geometry structure; use with p4est_geometry_destroy.
- */
-p4est_geometry_t   *p4est_geometry_new_connectivity (p4est_connectivity_t *
-                                                     conn);
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_GEOMETRY_H */
diff --git a/OctreeRefinement/include/p4est_ghost.h b/OctreeRefinement/include/p4est_ghost.h
deleted file mode 100644
index 5c74baa..0000000
--- a/OctreeRefinement/include/p4est_ghost.h
+++ /dev/null
@@ -1,387 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p4est_ghost.h
- *
- * passing quadrants and data to neighboring processes
- *
- * \ingroup p4est
- */
-
-#ifndef P4EST_GHOST_H
-#define P4EST_GHOST_H
-
-#include <p4est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** quadrants that neighbor the local domain */
-typedef struct
-{
-  int                 mpisize;
-  p4est_topidx_t      num_trees;
-  p4est_connect_type_t btype; /**< which neighbors are in the ghost layer */
-
-  /** An array of quadrants which make up the ghost layer around \a
-   * p4est.  Their piggy3 data member is filled with their owner's tree
-   * and local number (cumulative over trees).  Quadrants are ordered in \c
-   * p4est_quadrant_compare_piggy order.  These are quadrants inside the
-   * neighboring tree, i.e., \c p4est_quadrant_is_inside() is true for the
-   * quadrant and the neighboring tree.
-   */
-  sc_array_t          ghosts; /**< array of p4est_quadrant_t type */
-  p4est_locidx_t     *tree_offsets;     /**< num_trees + 1 ghost indices */
-  p4est_locidx_t     *proc_offsets;     /**< mpisize + 1 ghost indices */
-
-  /** An array of local quadrants that touch the parallel boundary from the
-   * inside, i.e., that are ghosts in the perspective of at least one other
-   * processor.  The storage convention is the same as for \c ghosts above.
-   */
-  sc_array_t          mirrors; /**< array of p4est_quadrant_t type */
-  p4est_locidx_t     *mirror_tree_offsets;      /**< num_trees + 1 mirror indices */
-  p4est_locidx_t     *mirror_proc_mirrors;      /**< indices into mirrors grouped by
-                                                   outside processor rank and
-                                                   ascending within each rank */
-  p4est_locidx_t     *mirror_proc_offsets;      /**< mpisize + 1 indices into 
-                                                   mirror_proc_mirrors */
-
-  p4est_locidx_t     *mirror_proc_fronts;       /**< like mirror_proc_mirrors,
-                                                   but limited to the
-                                                   outermost octants.  This is
-                                                   NULL until
-                                                   p4est_ghost_expand is
-                                                   called */
-  p4est_locidx_t     *mirror_proc_front_offsets;        /**< NULL until
-                                                           p4est_ghost_expand is
-                                                           called */
-}
-p4est_ghost_t;
-
-/** Examine if a ghost structure is valid.
- * Test if within a ghost-structure the array ghosts is in
- * p4est_quadrant_compare_piggy order.
- * Test if local_num in piggy3 data member of the quadrants in ghosts and
- * mirrors are in ascending order (ascending within each rank for ghost).
- *
- * Test if the p4est_locidx_t arrays are in ascending order
- * (for mirror_proc_mirrors ascending within each rank)
- * \param [in] p4est    the forest.
- * \param [in] ghost    Ghost layer structure.
- * \return true if \a ghost is valid
- */
-int                 p4est_ghost_is_valid (p4est_t * p4est,
-                                          p4est_ghost_t * ghost);
-
-/** Calculate the memory usage of the ghost layer.
- * \param [in] ghost    Ghost layer structure.
- * \return              Memory used in bytes.
- */
-size_t              p4est_ghost_memory_used (p4est_ghost_t * ghost);
-
-/** Gets the processor id of a quadrant's owner.
- * The quadrant can lie outside of a tree across faces (and only faces).
- *
- * \param [in] p4est  The forest in which to search for a quadrant.
- * \param [in] treeid The tree to which the quadrant belongs.
- * \param [in] face   Supply a face direction if known, or -1 otherwise.
- * \param [in] q      The quadrant that is being searched for.
- *
- * \return Processor id of the owner
- *                or -1 if the quadrant lies outside of the mesh.
- *
- * \warning Does not work for tree edge or corner neighbors.
- */
-int                 p4est_quadrant_find_owner (p4est_t * p4est,
-                                               p4est_topidx_t treeid,
-                                               int face,
-                                               const p4est_quadrant_t * q);
-
-/** Builds the ghost layer.
- *
- * This will gather the quadrants from each neighboring proc to build
- * one layer of face and corner based ghost elements around the ones they own.
- *
- * \param [in] p4est            The forest for which the ghost layer will be
- *                              generated.
- * \param [in] btype            Which ghosts to include (across face, corner
- *                              or full).
- * \return                      A fully initialized ghost layer.
- */
-p4est_ghost_t      *p4est_ghost_new (p4est_t * p4est,
-                                     p4est_connect_type_t btype);
-
-/** Frees all memory used for the ghost layer. */
-void                p4est_ghost_destroy (p4est_ghost_t * ghost);
-
-/** Conduct binary search for exact match on a range of the ghost layer.
- * \param [in] ghost            The ghost layer.
- * \param [in] which_proc       The owner of the searched quadrant.  Can be -1.
- * \param [in] which_tree       The tree of the searched quadrant.  Can be -1.
- * \param [in] q                Valid quadrant is searched in the ghost layer.
- * \return                      Offset in the ghost layer, or -1 if not found.
- */
-ssize_t             p4est_ghost_bsearch (p4est_ghost_t * ghost,
-                                         int which_proc,
-                                         p4est_topidx_t which_tree,
-                                         const p4est_quadrant_t * q);
-
-/** Conduct binary search for ancestor on range of the ghost layer.
- * \param [in] ghost            The ghost layer.
- * \param [in] which_proc       The owner of the searched quadrant.  Can be -1.
- * \param [in] which_tree       The tree of the searched quadrant.  Can be -1.
- * \param [in] q                Valid quadrant's ancestor is searched.
- * \return                      Offset in the ghost layer, or -1 if not found.
- */
-ssize_t             p4est_ghost_contains (p4est_ghost_t * ghost,
-                                          int which_proc,
-                                          p4est_topidx_t which_tree,
-                                          const p4est_quadrant_t * q);
-
-/** Checks if quadrant exists in the local forest or the ghost layer.
- *
- * For quadrants across tree boundaries it checks if the quadrant exists
- * across any face, but not across corners.
- *
- * \param [in]  p4est        The forest in which to search for \a q.
- * \param [in]  ghost        The ghost layer in which to search for \a q.
- * \param [in]  treeid       The tree to which \a q belongs.
- * \param [in]  q            The quadrant that is being searched for.
- * \param [in,out] face      On input, face id across which \a q was created.
- *                           On output, the neighbor's face number augmented
- *                           by orientation, so face is in 0..7.
- * \param [in,out] hang      If not NULL, signals that q is bigger than
- *                           the quadrant it came from.  The child id
- *                           of that originating quadrant is passed into hang.
- *                           On output, hang holds the hanging face number
- *                           of \a q that is in contact with its originator.
- * \param [out] owner_rank   Filled with the rank of the owner if it is found
- *                           and undefined otherwise.
- *
- * \return      Returns the local number of \a q if the quadrant exists
- *              in the local forest or in the ghost_layer.  Otherwise,
- *              returns -2 for a domain boundary and -1 if not found.
- */
-p4est_locidx_t      p4est_face_quadrant_exists (p4est_t * p4est,
-                                                p4est_ghost_t * ghost,
-                                                p4est_topidx_t treeid,
-                                                const p4est_quadrant_t * q,
-                                                int *face, int *hang,
-                                                int *owner_rank);
-
-/** Checks if quadrant exists in the local forest or the ghost layer.
- *
- * For quadrants across tree corners it checks if the quadrant exists
- * in any of the corner neighbors, thus it can execute multiple queries.
- *
- * \param [in]  p4est        The forest in which to search for \a q
- * \param [in]  ghost        The ghost layer in which to search for \a q
- * \param [in]  treeid       The tree to which \a q belongs (can be extended).
- * \param [in]  q            The quadrant that is being searched for.
- * \param [in,out] exists_arr Must exist and be of of elem_size = sizeof (int)
- *                           for inter-tree corner cases.  Is resized by this
- *                           function to one entry for each corner search
- *                           and set to true/false depending on its existence
- *                           in the local forest or ghost_layer.
- * \param [in,out] rproc_arr If not NULL is filled with one rank per query.
- * \param [in,out] rquad_arr If not NULL is filled with one quadrant per query.
- *                           Its piggy3 member is defined as well.
- *
- * \return true if the quadrant exists in the local forest or in the
- *                  ghost_layer, and false if doesn't exist in either.
- */
-int                 p4est_quadrant_exists (p4est_t * p4est,
-                                           p4est_ghost_t * ghost,
-                                           p4est_topidx_t treeid,
-                                           const p4est_quadrant_t * q,
-                                           sc_array_t * exists_arr,
-                                           sc_array_t * rproc_arr,
-                                           sc_array_t * rquad_arr);
-
-/** Check a forest to see if it is balanced.
- *
- * This function builds the ghost layer and discards it when done.
- *
- * \param [in] p4est    The p4est to be tested.
- * \param [in] btype    Balance type (face, corner or default, full).
- * \return Returns true if balanced, false otherwise.
- */
-int                 p4est_is_balanced (p4est_t * p4est,
-                                       p4est_connect_type_t btype);
-
-/** Compute the parallel checksum of a ghost layer.
- * \param [in] p4est   The MPI information of this p4est will be used.
- * \param [in] ghost   A ghost layer obtained from the p4est.
- * \return             Parallel checksum on rank 0, 0 otherwise.
- */
-unsigned            p4est_ghost_checksum (p4est_t * p4est,
-                                          p4est_ghost_t * ghost);
-
-/** Transfer data for local quadrants that are ghosts to other processors.
- * Send the data stored in the quadrant's user_data.  This is either the
- * pointer variable itself if \c p4est->data_size is 0, or the content of
- * the referenced memory field if p4est->data_size is positive.
- * \param [in] p4est            The forest used for reference.
- * \param [in] ghost            The ghost layer used for reference.
- * \param [in,out] ghost_data   Pre-allocated contiguous data for all ghost
- *                              quadrants in sequence.  If p4est->data_size is
- *                              0, must at least hold sizeof (void *) bytes for
- *                              each, otherwise p4est->data_size each.
- */
-void                p4est_ghost_exchange_data (p4est_t * p4est,
-                                               p4est_ghost_t * ghost,
-                                               void *ghost_data);
-
-/** Transient storage for asynchronous ghost exchange. */
-typedef struct p4est_ghost_exchange
-{
-  int                 is_custom;        /**< False for p4est_ghost_exchange_data */
-  int                 is_levels;        /**< Are we restricted to levels or not */
-  p4est_t            *p4est;
-  p4est_ghost_t      *ghost;
-  int                 minlevel, maxlevel;       /**< Meaningful with is_levels */
-  size_t              data_size;
-  void               *ghost_data;
-  int                *qactive, *qbuffer;
-  sc_array_t          requests, sbuffers;
-  sc_array_t          rrequests, rbuffers;
-}
-p4est_ghost_exchange_t;
-
-/** Begin an asynchronous ghost data exchange by posting messages.
- * The arguments are identical to p4est_ghost_exchange_data.
- * The return type is always non-NULL and must be passed to
- * p4est_ghost_exchange_data_end to complete the exchange.
- * The ghost data must not be accessed before completion.
- * \param [in,out]  ghost_data  Must stay alive into the completion call.
- * \return          Transient storage for messages in progress.
- */
-p4est_ghost_exchange_t *p4est_ghost_exchange_data_begin
-  (p4est_t * p4est, p4est_ghost_t * ghost, void *ghost_data);
-
-/** Complete an asynchronous ghost data exchange.
- * This function waits for all pending MPI communications.
- * \param [in,out]  Data created ONLY by p4est_ghost_exchange_data_begin.
- *                  It is deallocated before this function returns.
- */
-void                p4est_ghost_exchange_data_end
-  (p4est_ghost_exchange_t * exc);
-
-/** Transfer data for local quadrants that are ghosts to other processors.
- * The data size is the same for all quadrants and can be chosen arbitrarily.
- * \param [in] p4est            The forest used for reference.
- * \param [in] ghost            The ghost layer used for reference.
- * \param [in] data_size        The data size to transfer per quadrant.
- * \param [in] mirror_data      One data pointer per mirror quadrant as input. 
- * \param [in,out] ghost_data   Pre-allocated contiguous data for all ghosts
- *                              in sequence, which must hold at least \c
- *                              data_size for each ghost.
- */
-void                p4est_ghost_exchange_custom (p4est_t * p4est,
-                                                 p4est_ghost_t * ghost,
-                                                 size_t data_size,
-                                                 void **mirror_data,
-                                                 void *ghost_data);
-
-/** Begin an asynchronous ghost data exchange by posting messages.
- * The arguments are identical to p4est_ghost_exchange_custom.
- * The return type is always non-NULL and must be passed to
- * p4est_ghost_exchange_custom_end to complete the exchange.
- * The ghost data must not be accessed before completion.
- * The mirror data can be safely discarded right after this function returns
- * since it is copied into internal send buffers.
- * \param [in]      mirror_data Not required to stay alive any longer.
- * \param [in,out]  ghost_data  Must stay alive into the completion call.
- * \return          Transient storage for messages in progress.
- */
-p4est_ghost_exchange_t *p4est_ghost_exchange_custom_begin
-  (p4est_t * p4est, p4est_ghost_t * ghost,
-   size_t data_size, void **mirror_data, void *ghost_data);
-
-/** Complete an asynchronous ghost data exchange.
- * This function waits for all pending MPI communications.
- * \param [in,out]  Data created ONLY by p4est_ghost_exchange_custom_begin.
- *                  It is deallocated before this function returns.
- */
-void                p4est_ghost_exchange_custom_end
-  (p4est_ghost_exchange_t * exc);
-
-/** Transfer data for local quadrants that are ghosts to other processors.
- * The data size is the same for all quadrants and can be chosen arbitrarily.
- * This function restricts the transfer to a range of refinement levels.
- * The memory for quadrants outside the level range is not dereferenced.
- * \param [in] p4est            The forest used for reference.
- * \param [in] ghost            The ghost layer used for reference.
- * \param [in] minlevel         Level of the largest quads to be exchanged.
- *                              Use <= 0 for no restriction.
- * \param [in] maxlevel         Level of the smallest quads to be exchanged.
- *                              Use >= P4EST_QMAXLEVEL for no restriction.
- * \param [in] data_size        The data size to transfer per quadrant.
- * \param [in] mirror_data      One data pointer per mirror quadrant as input. 
- * \param [in,out] ghost_data   Pre-allocated contiguous data for all ghosts
- *                              in sequence, which must hold at least \c
- *                              data_size for each ghost.
- */
-void                p4est_ghost_exchange_custom_levels (p4est_t * p4est,
-                                                        p4est_ghost_t * ghost,
-                                                        int minlevel,
-                                                        int maxlevel,
-                                                        size_t data_size,
-                                                        void **mirror_data,
-                                                        void *ghost_data);
-
-/** Begin an asynchronous ghost data exchange by posting messages.
- * The arguments are identical to p4est_ghost_exchange_custom_levels.
- * The return type is always non-NULL and must be passed to
- * p4est_ghost_exchange_custom_levels_end to complete the exchange.
- * The ghost data must not be accessed before completion.
- * The mirror data can be safely discarded right after this function returns
- * since it is copied into internal send buffers.
- * \param [in]      mirror_data Not required to stay alive any longer.
- * \param [in,out]  ghost_data  Must stay alive into the completion call.
- * \return          Transient storage for messages in progress.
- */
-p4est_ghost_exchange_t *p4est_ghost_exchange_custom_levels_begin
-  (p4est_t * p4est, p4est_ghost_t * ghost, int minlevel, int maxlevel,
-   size_t data_size, void **mirror_data, void *ghost_data);
-
-/** Complete an asynchronous ghost data exchange.
- * This function waits for all pending MPI communications.
- * \param [in,out]  Data created ONLY by p4est_ghost_exchange_custom_levels_begin.
- *                  It is deallocated before this function returns.
- */
-void                p4est_ghost_exchange_custom_levels_end
-  (p4est_ghost_exchange_t * exc);
-
-/** Expand the size of the ghost layer and mirrors by one additional layer of
- * adjacency.
- * \param [in] p4est            The forest from which the ghost layer was
- *                              generated.
- * \param [in,out] ghost        The ghost layer to be expanded.
- */
-void                p4est_ghost_expand (p4est_t * p4est,
-                                        p4est_ghost_t * ghost);
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_GHOST_H */
diff --git a/OctreeRefinement/include/p4est_io.h b/OctreeRefinement/include/p4est_io.h
deleted file mode 100644
index 4f4cecb..0000000
--- a/OctreeRefinement/include/p4est_io.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P4EST_IO_H
-#define P4EST_IO_H
-
-#include <p4est.h>
-
-/** Extract processor local quadrants' x y level data.
- * Optionally extracts the quadrant data as well into a separate array.
- * \param [in] p4est    The forest is not modified.
- * \param [in,out] data If not NULL, pointer to a pointer that will be set
- *                      to a newly allocated array with per-quadrant data.
- *                      Must be NULL if p4est->data_size == 0.
- * \return              An array of type p4est_qcoord_t that contains
- *                      x y level for each quadrant on this processor.
- *                      The tree information is not extracted.
- */
-sc_array_t         *p4est_deflate_quadrants (p4est_t * p4est,
-                                             sc_array_t ** data);
-
-/** Create a new p4est based on serialized data.
- * Its revision counter is set to zero.
- * See p4est.h and p4est_communication.h for more information on parameters.
- * \param [in] mpicomm       A valid MPI communicator.
- * \param [in] connectivity  This is the connectivity information that
- *                           the forest is built with.  Note that p4est
- *                           does not take ownership of the memory.
- * \param [in] global_first_quadrant First global quadrant on each proc and
- *                           one beyond.  Copied into global_first_quadrant.
- *                           Local count on rank is gfq[rank + 1] - gfq[rank].
- * \param [in] pertree       The cumulative quadrant counts per tree.
- * \param [in] quadrants     Array as returned by p4est_deflate_quadrants.
- * \param [in] data          Array as from p4est_deflate_quadrants or NULL.
- *                           The elem_size of this array informs data_size.
- *                           Its elem_count equals the number of local quads.
- * \param [in] user_pointer  Assign to the user_pointer member of the p4est.
- * \return              The newly created p4est with a zero revision counter.
- */
-p4est_t            *p4est_inflate (sc_MPI_Comm mpicomm,
-                                   p4est_connectivity_t * connectivity,
-                                   const p4est_gloidx_t *
-                                   global_first_quadrant,
-                                   const p4est_gloidx_t * pertree,
-                                   sc_array_t * quadrants, sc_array_t * data,
-                                   void *user_pointer);
-
-#endif /* !P4EST_IO_H */
diff --git a/OctreeRefinement/include/p4est_iterate.h b/OctreeRefinement/include/p4est_iterate.h
deleted file mode 100644
index 5a56224..0000000
--- a/OctreeRefinement/include/p4est_iterate.h
+++ /dev/null
@@ -1,294 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p4est_iterate.h
- *
- * Iteration over mesh topology via callbacks
- *
- * \ingroup p4est
- */
-
-#ifndef P4EST_ITERATE_H
-#define P4EST_ITERATE_H
-
-#include <p4est.h>
-#include <p4est_ghost.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** The information that is available to the user-defined p4est_iter_volume_t
- * callback function.
- *
- * \a treeid gives the index in \a p4est->trees of the tree to which
- *    \a quad belongs.
- * \a quadid gives the index of \a quad within \a tree's quadrants array.
- */
-typedef struct p4est_iter_volume_info
-{
-  p4est_t            *p4est;
-  p4est_ghost_t      *ghost_layer;
-  p4est_quadrant_t   *quad;    /**< the quadrant of the callback */
-  p4est_locidx_t      quadid;  /**< id in \a quad's tree array (see
-                                    p4est_tree_t) */
-  p4est_topidx_t      treeid;  /**< the tree containing \a quad */
-}
-p4est_iter_volume_info_t;
-
-/** The prototype for a function that p4est_iterate will execute at every
- * quadrant local to the current process.
- * \param [in] info          information about a quadrant provided to the user
- * \param [in,out] user_data the user context passed to p4est_iterate()
- */
-typedef void        (*p4est_iter_volume_t) (p4est_iter_volume_info_t * info,
-                                            void *user_data);
-
-/** Information about one side of a face in the forest.
- *
- * If a \a quad is local
- * (\a is_ghost is false), then its \a quadid indexes the tree's quadrant
- * array; otherwise, it indexes the ghosts array. If the face is hanging, then
- * the quadrants are listed in z-order.  If a quadrant should be present, but
- * it is not included in the ghost layer, then quad = NULL, is_ghost is true,
- * and quadid = -1.
- */
-typedef struct p4est_iter_face_side
-{
-  p4est_topidx_t      treeid;          /**< the tree on this side */
-  int8_t              face;            /**< which quadrant side the face
-                                            touches */
-  int8_t              is_hanging;      /**< boolean: one full quad (0) or
-                                            two smaller quads (1) */
-  union p4est_iter_face_side_data
-  {
-    struct
-    {
-      int8_t              is_ghost;    /**< boolean: local (0) or ghost (1) */
-      p4est_quadrant_t   *quad;        /**< the actual quadrant */
-      p4est_locidx_t      quadid;      /**< index in tree or ghost array */
-    }
-    full; /**< if \a is_hanging = 0,
-               use is.full to access per-quadrant data */
-    struct
-    {
-      int8_t              is_ghost[2]; /**< boolean: local (0) or ghost (1) */
-      p4est_quadrant_t   *quad[2];     /**< the actual quadrant */
-      p4est_locidx_t      quadid[2];   /**< index in tree or ghost array */
-    }
-    hanging; /**< if \a is_hanging = 1,
-                  use is.hanging to access per-quadrant data */
-  }
-  is;
-}
-p4est_iter_face_side_t;
-
-/** The information that is available to the user-defined p4est_iter_face_t
- * callback.
- *
- * The orientation is 0 if the face is within one tree; otherwise, it is the
- * same as the orientation value between the two trees given in the
- * connectivity.  If the face is on the outside boundary of the forest, then
- * there is only one side.  If tree_boundary is false, the face is on the
- * interior of a tree.  When tree_boundary is false, sides[0] contains the
- * lowest z-order quadrant that touches the face.
- * When tree_boundary is true, its value is P4EST_CONNECT_FACE.
- */
-typedef struct p4est_iter_face_info
-{
-  p4est_t            *p4est;
-  p4est_ghost_t      *ghost_layer;
-  int8_t              orientation; /**< the orientation of the sides to each
-                                        other, as in the definition of
-                                        p4est_connectivity_t */
-  int8_t              tree_boundary; /**< boolean: interior face (0),
-                                          boundary face (1) */
-  sc_array_t          sides;    /* array of p4est_iter_face_side_t type */
-}
-p4est_iter_face_info_t;
-
-/** The prototype for a function that p4est_iterate will execute wherever two
- * quadrants share a face: the face can be a 2:1 hanging face, it does not have
- * to be conformal.
- *
- * \param [in] info          information about a quadrant provided to the user
- * \param [in,out] user_data the user context passed to p4est_iterate()
- *
- * \note the forest must be face balanced for p4est_iterate() to execute a
- * callback function on faces (see p4est_balance()).
- */
-typedef void        (*p4est_iter_face_t) (p4est_iter_face_info_t * info,
-                                          void *user_data);
-
-/** Information about one side of a corner in the forest.  If a \a quad is local
- * (\a is_ghost is false), then its \a quadid indexes the tree's quadrant array;
- * otherwise, it indexes the ghosts array. If a quadrant should be present, but
- * it is not included in the ghost layer, then quad = NULL, is_ghost is true,
- * and quadid = -1.
- *
- * the \a faces field provides some additional information about the local
- * topology: if side[i]->faces[j] == side[k]->faces[l], this indicates that
- * there is a common face between these two sides of the corner.
- */
-typedef struct p4est_iter_corner_side
-{
-  p4est_topidx_t      treeid;   /**< the tree that contains \a quad */
-  int8_t              corner;   /**< which of the quadrant's corners touches
-                                     this corner */
-  int8_t              is_ghost; /**< boolean: local (0) or ghost (1) */
-  p4est_quadrant_t   *quad;
-  p4est_locidx_t      quadid;   /**< the index in the tree or ghost array */
-  int8_t              faces[2]; /**< internal work data */
-}
-p4est_iter_corner_side_t;
-
-/** The information that is available to the user-defined p4est_iter_corner_t
- * callback.
- *
- * If tree_boundary is false, the corner is on the interior of a tree.
- * When tree_boundary is false, sides[0] contains the lowest z-order quadrant
- * that touches the corner.
- * When tree_boundary is true, its value is P4EST_CONNECT_FACE/CORNER
- * depending on the location of the corner relative to the tree.
- */
-typedef struct p4est_iter_corner_info
-{
-  p4est_t            *p4est;
-  p4est_ghost_t      *ghost_layer;
-  int8_t              tree_boundary; /**< boolean: interior face (0),
-                                           boundary face (1) */
-  sc_array_t          sides; /**< array of type p4est_iter_corner_side_t type */
-}
-p4est_iter_corner_info_t;
-
-/** The prototype for a function that p4est_iterate will execute wherever
- * quadrants meet at a conformal corner
- *
- * i.e. the callback will not execute on a hanging corner.
- *
- * \param [in] info          information about a quadrant provided to the user
- * \param [in,out] user_data the user context passed to p4est_iterate()
- *
- * \note the forest does not need to be corner balanced for p4est_iterate() to
- * correctly execute a callback function at corners, only face balanced (see
- * p4est_balance()).
- */
-typedef void        (*p4est_iter_corner_t) (p4est_iter_corner_info_t * info,
-                                            void *user_data);
-
-/** Execute user supplied callbacks at every volume, face, and corner in the
- * local forest.
- *
- * p4est_iterate executes the user-supplied callback functions at every
- * volume, face, and corner in the local forest. The ghost_layer may be NULL.
- * The \a user_data pointer is not touched by p4est_iterate, but is passed to
- * each of the callbacks.  Any of the callbacks may be NULL.
- * The callback functions are interspersed with each other, i.e. some face
- * callbacks will occur between volume callbacks, and some corner callbacks
- * will occur between face callbacks:
- *
- * 1) volume callbacks occur in the sorted Morton-index order.
- * 2) a face callback is not executed until after the volume callbacks have
- *    been executed for the quadrants that share it.
- * 3) a corner callback is not executed until the face callbacks have been
- *    executed for all faces that touch the corner.
- * 4) it is not always the case that every face callback for a given quadrant
- *    is executed before any of the corner callbacks.
- * 5) callbacks are not executed at faces or corners that only involve ghost
- *    quadrants, i.e. that are not adjacent in the local section of the
- *    forest.
- *
- * \param[in] p4est          the forest
- * \param[in] ghost_layer    optional: when not given, callbacks at the
- *                           boundaries of the local partition cannot provide
- *                           quadrant data about ghost quadrants: missing
- *                           (p4est_quadrant_t *) pointers are set to NULL,
- *                           missing indices are set to -1.
- * \param[in,out] user_data  optional context to supply to each callback
- * \param[in] iter_volume    callback function for every quadrant's interior
- * \param[in] iter_face      callback function for every face between
- *                           quadrants
- * \param[in] iter_corner    callback function for every corner between
- *                           quadrants
- */
-void                p4est_iterate (p4est_t * p4est,
-                                   p4est_ghost_t * ghost_layer,
-                                   void *user_data,
-                                   p4est_iter_volume_t iter_volume,
-                                   p4est_iter_face_t iter_face,
-                                   p4est_iter_corner_t iter_corner);
-
-/** Return a pointer to a iter_corner_side array element indexed by a int.
- */
-/*@unused@*/
-static inline p4est_iter_corner_side_t *
-p4est_iter_cside_array_index_int (sc_array_t * array, int it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p4est_iter_corner_side_t));
-  P4EST_ASSERT (it >= 0 && (size_t) it < array->elem_count);
-
-  return (p4est_iter_corner_side_t *)
-    (array->array + sizeof (p4est_iter_corner_side_t) * (size_t) it);
-}
-
-/** Return a pointer to a iter_corner_side array element indexed by a size_t.
- */
-/*@unused@*/
-static inline p4est_iter_corner_side_t *
-p4est_iter_cside_array_index (sc_array_t * array, size_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p4est_iter_corner_side_t));
-  P4EST_ASSERT (it < array->elem_count);
-
-  return (p4est_iter_corner_side_t *)
-    (array->array + sizeof (p4est_iter_corner_side_t) * it);
-}
-
-/** Return a pointer to a iter_face_side array element indexed by a int.
- */
-/*@unused@*/
-static inline p4est_iter_face_side_t *
-p4est_iter_fside_array_index_int (sc_array_t * array, int it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p4est_iter_face_side_t));
-  P4EST_ASSERT (it >= 0 && (size_t) it < array->elem_count);
-
-  return (p4est_iter_face_side_t *)
-    (array->array + sizeof (p4est_iter_face_side_t) * (size_t) it);
-}
-
-/** Return a pointer to a iter_face_side array element indexed by a size_t.
- */
-/*@unused@*/
-static inline p4est_iter_face_side_t *
-p4est_iter_fside_array_index (sc_array_t * array, size_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p4est_iter_face_side_t));
-  P4EST_ASSERT (it < array->elem_count);
-
-  return (p4est_iter_face_side_t *)
-    (array->array + sizeof (p4est_iter_face_side_t) * it);
-}
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_ITERATE_H */
diff --git a/OctreeRefinement/include/p4est_lnodes.h b/OctreeRefinement/include/p4est_lnodes.h
deleted file mode 100644
index eea9f8a..0000000
--- a/OctreeRefinement/include/p4est_lnodes.h
+++ /dev/null
@@ -1,391 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P4EST_LNODES_H
-#define P4EST_LNODES_H
-
-#include <p4est.h>
-#include <p4est_ghost.h>
-
-SC_EXTERN_C_BEGIN;
-
-typedef int8_t      p4est_lnodes_code_t;
-
-/** Store a parallel numbering of Lobatto points of a given degree > 0.
- *
- * Each element has degree+1 nodes per face
- * and vnodes = (degree+1)^2 nodes per volume.
- * num_local_elements is the number of local quadrants in the p4est.
- * element_nodes is of dimension vnodes * num_local_elements and lists the
- * nodes of each element in lexicographic yx-order (x varies fastest); so for
- * degree == 2, this is the layout of nodes:
- *
- *         f_3
- *  c_2           c_3
- *      6---7---8
- *      |       |
- * f_0  3   4   5  f_1
- *      |       |
- *      0---1---2
- *  c_0           c_1
- *         f_2
- *
- * element_nodes indexes into the set of local nodes, layed out as follows:
- * local nodes = [<-----owned_count----->|<-----nonlocal_nodes----->]
- *             = [<----------------num_local_nodes----------------->]
- * nonlocal_nodes contains the globally unique numbers for independent nodes
- * that are owned by other processes; for local nodes, the globally unique
- * numbers are given by i + global_offset, where i is the local number.
- * Hanging nodes are always local and don't have a global number.
- * They index the geometrically corresponding independent nodes of a neighbor.
- *
- * Whether nodes are hanging or not is decided based on the element faces.
- * This information is encoded in face_code with one int8_t per element.
- * If no faces are hanging, the value is zero, otherwise the face_code is
- * interpreted by p4est_lnodes_decode.
- *
- * Independent nodes can be shared by multiple MPI ranks.
- * The owner rank of a node is the one from the lowest numbered element
- * on the lowest numbered octree *touching* the node.
- *
- * What is meant by *touching*?
- * A quadrant is said to touch all faces/corners that are incident on it,
- * and by extension all nodes that are contained in those faces/corners.
- *
- *         X +-----------+
- *         o |           |
- *         o |           |
- * +-----+ o |     p     |
- * |  q  | o |           |
- * |     | o |           |
- * +-----+ O +-----------+
- *
- * In this example degree = 6.  There are 5 nodes that live on the face
- * between q and p, and one at each corner of that face.  The face is incident
- * on q, so q owns the nodes on the face (provided q is from a lower tree or
- * has a lower index than p).  The lower corner is incident on q, so q owns it
- * as well.  The upper corner is not incident on q, so q cannot own it.
- *
- * global_owned_count contains the number of independent nodes owned by each
- * process.
- *
- * The sharers array contains items of type p4est_lnodes_rank_t
- * that hold the ranks that own or share independent local nodes.
- * If there are no shared nodes on this processor, it is empty.
- * Otherwise, it is sorted by rank and the current process is included.
- *
- * degree < 0 indicates that the lnodes data structure is being used to number
- * the quadrant boundary object (faces and corners) rather than the $C^0$
- * Lobatto nodes:
- *
- * if degree == -1, then one node is assigned per face, and no nodes are
- * assigned per volume or per corner: this numbering can be used for low-order
- * Raviart-Thomas elements.  In this case, vnodes == 4, and the nodes are
- * listed in face-order:
- *
- *         f_3
- *  c_2           c_3
- *      +---3---+
- *      |       |
- * f_0  0       1  f_1
- *      |       |
- *      +---2---+
- *  c_0           c_1
- *         f_2
- *
- * if degree == -2, then one node is assigned per face and per corner and no
- * nodes are assigned per volume.  In this case, vnodes == 8, and the
- * nodes are listed in face-order, followed by corner-order:
- *
- *         f_3
- *  c_2           c_3
- *      6---3---7
- *      |       |
- * f_0  0       1  f_1
- *      |       |
- *      4---2---5
- *  c_0           c_1
- *         f_2
- *
- */
-typedef struct p4est_lnodes
-{
-  sc_MPI_Comm         mpicomm;
-  p4est_locidx_t      num_local_nodes;
-  p4est_locidx_t      owned_count;
-  p4est_gloidx_t      global_offset;
-  p4est_gloidx_t     *nonlocal_nodes;
-  sc_array_t         *sharers;
-  p4est_locidx_t     *global_owned_count;
-
-  int                 degree, vnodes;
-  p4est_locidx_t      num_local_elements;
-  p4est_lnodes_code_t *face_code;
-  p4est_locidx_t     *element_nodes;
-}
-p4est_lnodes_t;
-
-/** The structure stored in the sharers array.
- *
- * shared_nodes is a sorted array of p4est_locidx_t
- * that indexes into local nodes.  The shared_nodes array has a
- * contiguous (or empty) section of nodes owned by the current rank.
- * shared_mine_offset and shared_mine_count identify this section
- * by indexing the shared_nodes array, not the local nodes array.
- * owned_offset and owned_count define the section of local nodes
- * that is owned by the listed rank (the section may be empty).
- * For the current process these coincide with those in p4est_lnodes_t.
- */
-typedef struct p4est_lnodes_rank
-{
-  int                 rank;
-  sc_array_t          shared_nodes;
-  p4est_locidx_t      shared_mine_offset, shared_mine_count;
-  p4est_locidx_t      owned_offset, owned_count;
-}
-p4est_lnodes_rank_t;
-
-/** Decode the face_code into hanging face information.
- *
- * This is mostly for demonstration purposes.  Applications probably will
- * integrate it into their own loop over the face for performance reasons.
- *
- * \param[in] face_code as in the p4est_lnodes_t structure.
- * \param[out] hanging face: if there are hanging faces,
- *             hanging_face = -1 if the face is not hanging,
- *                          = 0 if the face is the first half,
- *                          = 1 if the face is the second half.
- *             note: not touched if there are no hanging faces.
- * \return              true if any face is hanging, false otherwise.
- */
-/*@unused@*/
-static inline int
-p4est_lnodes_decode (p4est_lnodes_code_t face_code, int hanging_face[4])
-{
-  P4EST_ASSERT (face_code >= 0);
-
-  if (face_code) {
-    int                 i;
-    int8_t              c = face_code & 0x03;
-    int                 f;
-    int8_t              work = face_code >> 2;
-
-    memset (hanging_face, -1, 4 * sizeof (int));
-
-    for (i = 0; i < 2; ++i) {
-      f = p4est_corner_faces[c][i];
-      hanging_face[f] = (work & 0x01) ? p4est_corner_face_corners[c][f] : -1;
-      work >>= 1;
-    }
-
-    return 1;
-  }
-  else {
-    return 0;
-  }
-}
-
-p4est_lnodes_t     *p4est_lnodes_new (p4est_t * p4est,
-                                      p4est_ghost_t * ghost_layer,
-                                      int degree);
-
-void                p4est_lnodes_destroy (p4est_lnodes_t * lnodes);
-
-/** Expand the ghost layer to include the support of all nodes supported on
- * the local partition.
- *
- * \param [in]     p4est        The forest from which the ghost layer was
- *                              generated.
- * \param [in]     lnodes       The nodes to support.
- * \param [in,out] ghost        The ghost layer to be expanded.
- */
-void                p4est_ghost_support_lnodes (p4est_t * p4est,
-                                                p4est_lnodes_t * lnodes,
-                                                p4est_ghost_t * ghost);
-
-/** Expand the ghost layer as in p4est_ghost_expand(), but use node support to
- * define adjacency instead of geometric adjacency.
- *
- * \param [in]     p4est        The forest from which the ghost layer was
- *                              generated.
- * \param [in]     lnodes       The nodes to support.
- * \param [in,out] ghost        The ghost layer to be expanded.
- */
-void                p4est_ghost_expand_by_lnodes (p4est_t * p4est,
-                                                  p4est_lnodes_t * lnodes,
-                                                  p4est_ghost_t * ghost);
-
-/** Partition using weights based on the number of nodes assigned to each
- * element in lnodes
- *
- * \param[in,out] p4est                    the forest to be repartitioned
- * \param[in]     ghost                    the ghost layer
- * \param[in]     degree                   the degree that would be passed to p4est_lnodes_new()
- * \param[in]     partition_for_coarsening whether the partition should allow
- *                                         coarsening (i.e. group siblings who
- *                                         might merge)
- */
-void                p4est_partition_lnodes (p4est_t * p4est,
-                                            p4est_ghost_t * ghost, int degree,
-                                            int partition_for_coarsening);
-
-/** Partition using weights that are broken down by where they reside: in
- * volumes, on faces, or on corners.
- */
-void                p4est_partition_lnodes_detailed (p4est_t * p4est,
-                                                     p4est_ghost_t * ghost,
-                                                     int nodes_per_volume,
-                                                     int nodes_per_face,
-                                                     int nodes_per_corner,
-                                                     int
-                                                     partition_for_coarsening);
-
-/** p4est_lnodes_buffer_t handles the communication of data associated with
- * nodes.
- *
- * \a send_buffers is an array of arrays: one buffer for each process to which
- * the current process sends node-data.  It should not be altered between
- * a shared_*_begin and a shared_*_end call.
- *
- * \a recv_buffers is an array of arrays that is used in lnodes_share_all_*.
- * \a recv_buffers[j] corresponds with lnodes->sharers[j]: it is the same
- * length as \a lnodes->sharers[j]->shared_nodes.  At the completion of
- * lnodes_share_all or lnodes_share_all_end, recv_buffers[j] contains the
- * node-data from the process lnodes->sharers[j]->rank
- * (unless j is the current rank, in which case recv_buffers[j] is empty).
- */
-typedef struct p4est_lnodes_buffer
-{
-  sc_array_t         *requests; /* sc_MPI_Request */
-  sc_array_t         *send_buffers;
-  sc_array_t         *recv_buffers;
-}
-p4est_lnodes_buffer_t;
-
-/** p4est_lnodes_share_owned_begin
- *
- * \a node_data is a user-defined array of arbitrary type, where each entry
- * is associated with the \a lnodes local nodes entry of matching index.
- * For every local nodes entry that is owned by a process
- * other than the current one, the value in the \a node_data array of the
- * owning process is written directly into the \a node_data array of the current
- * process.  Values of \a node_data are not guaranteed to be sent or received
- * until the \a buffer created by p4est_lnodes_share_owned_begin is passed to
- * p4est_lnodes_share_owned_end.
- *
- * To be memory neutral, the \a buffer created by
- * p4est_lnodes_share_owned_begin must be destroying with
- * p4est_lnodes_buffer_destroy (it is not destroyed by
- * p4est_lnodes_share_owned_end).
- */
-p4est_lnodes_buffer_t *p4est_lnodes_share_owned_begin (sc_array_t * node_data,
-                                                       p4est_lnodes_t *
-                                                       lnodes);
-
-void                p4est_lnodes_share_owned_end (p4est_lnodes_buffer_t *
-                                                  buffer);
-
-/** Equivalent to calling p4est_lnodes_share_owned_end directly after
- * p4est_lnodes_share_owned_begin.  Use if there is no local work that can be
- * done to mask the communication cost.
- */
-void                p4est_lnodes_share_owned (sc_array_t * node_data,
-                                              p4est_lnodes_t * lnodes);
-
-/** p4est_lnodes_share_all_begin
- *
- * \a node_data is a user_defined array of arbitrary type, where each entry
- * is associated with the lnodes local nodes entry of matching index.
- * For every process that shares an entry with the current one, the value in
- * the \a node_data array of that process is written into a
- * \a buffer->recv_buffers entry as described above.  The user can then perform
- * some arbitrary work that requires the data from all processes that share a
- * node (such as reduce, max, min, etc.).  When the work concludes, the
- * \a buffer should be destroyed with p4est_lnodes_buffer_destroy.
- *
- * Values of \a node_data are not guaranteed to be sent, and
- * \a buffer->recv_buffer entries are not guaranteed to be received until
- * the \a buffer created by p4est_lnodes_share_all_begin is passed to
- * p4est_lnodes_share_all_end.
- */
-p4est_lnodes_buffer_t *p4est_lnodes_share_all_begin (sc_array_t * node_data,
-                                                     p4est_lnodes_t * lnodes);
-
-void                p4est_lnodes_share_all_end (p4est_lnodes_buffer_t *
-                                                buffer);
-
-/** Equivalent to calling p4est_lnodes_share_all_end directly after
- * p4est_lnodes_share_all_begin.  Use if there is no local work that can be
- * done to mask the communication cost.
- * \return          A fully initialized buffer that contains the received data.
- *                  After processing this data, the buffer must be freed with
- *                  p4est_lnodes_buffer_destroy.
- */
-p4est_lnodes_buffer_t *p4est_lnodes_share_all (sc_array_t * node_data,
-                                               p4est_lnodes_t * lnodes);
-
-void                p4est_lnodes_buffer_destroy (p4est_lnodes_buffer_t *
-                                                 buffer);
-
-/** Return a pointer to a lnodes_rank array element indexed by a int.
- */
-/*@unused@*/
-static inline p4est_lnodes_rank_t *
-p4est_lnodes_rank_array_index_int (sc_array_t * array, int it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p4est_lnodes_rank_t));
-  P4EST_ASSERT (it >= 0 && (size_t) it < array->elem_count);
-
-  return (p4est_lnodes_rank_t *)
-    (array->array + sizeof (p4est_lnodes_rank_t) * (size_t) it);
-}
-
-/** Return a pointer to a lnodes_rank array element indexed by a size_t.
- */
-/*@unused@*/
-static inline p4est_lnodes_rank_t *
-p4est_lnodes_rank_array_index (sc_array_t * array, size_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p4est_lnodes_rank_t));
-  P4EST_ASSERT (it < array->elem_count);
-
-  return (p4est_lnodes_rank_t *)
-    (array->array + sizeof (p4est_lnodes_rank_t) * it);
-}
-
-/** Compute the global number of a local node number */
-/*@unused@*/
-static inline       p4est_gloidx_t
-p4est_lnodes_global_index (p4est_lnodes_t * lnodes, p4est_locidx_t lidx)
-{
-  p4est_locidx_t      owned = lnodes->owned_count;
-  P4EST_ASSERT (lidx >= 0 && lidx < lnodes->num_local_nodes);
-
-  return (lidx < owned) ? lnodes->global_offset + lidx :
-    lnodes->nonlocal_nodes[lidx - owned];
-}
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_LNODES */
diff --git a/OctreeRefinement/include/p4est_mesh.h b/OctreeRefinement/include/p4est_mesh.h
deleted file mode 100644
index 01abef5..0000000
--- a/OctreeRefinement/include/p4est_mesh.h
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p4est_mesh.h
- *
- * forest topology in a conventional mesh format
- *
- * \ingroup p4est
- */
-
-#ifndef P4EST_MESH_H
-#define P4EST_MESH_H
-
-#include <p4est_ghost.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** This structure contains complete mesh information on the forest.
- * It stores the locally relevant neighborhood, that is, all locally owned
- * quadrants and one layer of adjacent ghost quadrants and their owners.
- *
- * For each local quadrant, its tree number is stored in quad_to_tree. The
- * quad_to_tree array is NULL by default and can be enabled using
- * p4est_mesh_new_ext.
- * For each ghost quadrant, its owner rank is stored in ghost_to_proc.
- * For each level, an array of local quadrant numbers is stored in quad_level.
- * The quad_level array is NULL by default and can be enabled using
- * p4est_mesh_new_ext.
- *
- * The quad_to_quad list stores one value for each local quadrant's face.
- * This value is in 0..local_num_quadrants-1 for local quadrants, or in
- * local_num_quadrants + (0..ghost_num_quadrants-1) for ghost quadrants.
- * The quad_to_face list has equally many entries which are either:
- * 1. A value of v = 0..7 indicates one same-size neighbor.
- *    This value is decoded as v = r * 4 + nf, where nf = 0..3 is the
- *    neighbor's connecting face number and r = 0..1 is the relative
- *    orientation of the neighbor's face, see p4est_connectivity.h.
- * 2. A value of v = 8..23 indicates a double-size neighbor.
- *    This value is decoded as v = 8 + h * 8 + r * 4 + nf, where
- *    r and nf are as above and h = 0..1 is the number of the subface.
- * 3. A value of v = -8..-1 indicates two half-size neighbors.
- *    In this case the corresponding quad_to_quad index points into the
- *    quad_to_half array which stores two quadrant numbers per index,
- *    and the orientation of the smaller faces follows from 8 + v.
- *    The entries of quad_to_half encode between local and ghost quadrant
- *    in the same way as the quad_to_quad values described above.
- * A quadrant on the boundary of the forest sees itself and its face number.
- *
- * The quad_to_corner list stores corner neighbors that are not face neighbors.
- * On the inside of a tree, there is precisely one such neighbor per corner.
- * In this case, its index is encoded as described above for quad_to_quad.
- * The neighbor's matching corner number is always diagonally opposite.
- *
- * On the inside of an inter-tree face, we have precisely one corner neighbor.
- * If a corner is an inter-tree corner, then the number of corner neighbors
- * may be any non-negative number.  In both cases, the quad_to_corner value
- * is in
- *    local_num_quadrants + local_num_ghosts + [0 .. local_num_corners - 1]
- * where the offset by local quadrants and ghosts is implicitly substracted.
- * It indexes into corner_offset, which encodes a group of corner neighbors.
- * Each group contains the quadrant numbers encoded as usual for quad_to_quad
- * in corner_quad, and the corner number from the neighbor as corner_corner.
- *
- * Corners with no diagonal neighbor at all are assigned the value -1.
- */
-typedef struct
-{
-  p4est_locidx_t      local_num_quadrants;
-  p4est_locidx_t      ghost_num_quadrants;
-
-  p4est_topidx_t     *quad_to_tree;     /**< tree index for each local quad,
-                                             NULL by default */
-  int                *ghost_to_proc;    /**< processor for each ghost quad */
-
-  p4est_locidx_t     *quad_to_quad;     /**< one index for each of the 4 faces */
-  int8_t             *quad_to_face;     /**< encodes orientation/2:1 status */
-  sc_array_t         *quad_to_half;     /**< stores half-size neighbors */
-  sc_array_t         *quad_level;       /**< stores lists of per-level quads,
-                                             NULL by default */
-
-  /* These members are NULL if the connect_t is not P4EST_CONNECT_CORNER */
-  /* CAUTION: tree-boundary corners not yet implemented */
-  p4est_locidx_t      local_num_corners;        /* tree-boundary corners */
-  p4est_locidx_t     *quad_to_corner;   /* 4 indices for each local quad */
-  sc_array_t         *corner_offset;    /* local_num_corners + 1 entries */
-  sc_array_t         *corner_quad;      /* corner_offset indexes into this */
-  sc_array_t         *corner_corner;    /* and this one too (type int8_t) */
-}
-p4est_mesh_t;
-
-/** This structure can be used as the status of a face neighbor iterator.
-  * It always contains the face and subface of the neighbor to be processed.
-  */
-typedef struct
-{
-  /* forest information */
-  p4est_t            *p4est;
-  p4est_ghost_t      *ghost;
-  p4est_mesh_t       *mesh;
-
-  /* quadrant information */
-  p4est_topidx_t      which_tree;
-  p4est_locidx_t      quadrant_id;      /* tree-local quadrant index */
-  p4est_locidx_t      quadrant_code;    /* 4 * (quadrant_id + tree_offset) */
-
-  /* neighbor information */
-  int                 face;     /* Face number in 0..3. */
-  int                 subface;  /* Hanging neighbor number in 0..1. */
-
-  /* internal information */
-  p4est_locidx_t      current_qtq;
-}
-p4est_mesh_face_neighbor_t;
-
-/** Calculate the memory usage of the mesh structure.
- * \param [in] mesh     Mesh structure.
- * \return              Memory used in bytes.
- */
-size_t              p4est_mesh_memory_used (p4est_mesh_t * mesh);
-
-/** Create a p4est_mesh structure.
- * \param [in] p4est    A forest that is fully 2:1 balanced.
- * \param [in] ghost    The ghost layer created from the provided p4est.
- * \param [in] btype    Determines the highest codimension of neighbors.
- * \return              A fully allocated mesh structure.
- */
-p4est_mesh_t       *p4est_mesh_new (p4est_t * p4est, p4est_ghost_t * ghost,
-                                    p4est_connect_type_t btype);
-
-/** Destroy a p4est_mesh structure.
- * \param [in] mesh     Mesh structure previously created by p4est_mesh_new.
- */
-void                p4est_mesh_destroy (p4est_mesh_t * mesh);
-
-/** Find a quadrant based on its cumulative number in the local forest.
- * \param [in]  p4est           Forest to be worked with.
- * \param [in]  cumulative_id   Cumulative index over all trees of quadrant.
- * \param [in,out] which_tree   If not NULL, the input value can be -1
- *                              or an initial guess for the quadrant's tree
- *                              and output is the tree of returned quadrant.
- * \param [out] quadrant_id     If not NULL, the number of quadrant in tree.
- * \return                      The identified quadrant.
- */
-p4est_quadrant_t   *p4est_mesh_quadrant_cumulative (p4est_t * p4est,
-                                                    p4est_locidx_t
-                                                    cumulative_id,
-                                                    p4est_topidx_t
-                                                    * which_tree,
-                                                    p4est_locidx_t
-                                                    * quadrant_id);
-
-/** Initialize a mesh neighbor iterator by quadrant index.
- * \param [out] mfn         A p4est_mesh_face_neighbor_t to be initialized.
- * \param [in]  which_tree  Tree of quadrant whose neighbors are looped over.
- * \param [in]  quadrant_id Index relative to which_tree of quadrant.
- */
-void                p4est_mesh_face_neighbor_init2 (p4est_mesh_face_neighbor_t
-                                                    * mfn, p4est_t * p4est,
-                                                    p4est_ghost_t * ghost,
-                                                    p4est_mesh_t * mesh,
-                                                    p4est_topidx_t which_tree,
-                                                    p4est_locidx_t
-                                                    quadrant_id);
-
-/** Initialize a mesh neighbor iterator by quadrant pointer.
- * \param [out] mfn         A p4est_mesh_face_neighbor_t to be initialized.
- * \param [in]  which_tree  Tree of quadrant whose neighbors are looped over.
- * \param [in]  quadrant    Pointer to quadrant contained in which_tree.
- */
-void                p4est_mesh_face_neighbor_init (p4est_mesh_face_neighbor_t
-                                                   * mfn, p4est_t * p4est,
-                                                   p4est_ghost_t * ghost,
-                                                   p4est_mesh_t * mesh,
-                                                   p4est_topidx_t which_tree,
-                                                   p4est_quadrant_t
-                                                   * quadrant);
-
-/** Move the iterator forward to loop around neighbors of the quadrant.
- * \param [in,out] mfn      Internal status of the iterator.
- * \param [out]    ntree    If not NULL, the tree number of the neighbor.
- * \param [out]    nquad    If not NULL, the quadrant number within tree.
- *                          For ghosts instead the number in ghost layer.
- * \param [out]    nface    If not NULL, neighbor's face as in p4est_mesh_t.
- * \param [out]    nrank    If not NULL, the owner process of the neighbor.
- * \return                  Either a real quadrant or one from the ghost layer.
- *                          Returns NULL when the iterator is done.
- */
-p4est_quadrant_t   *p4est_mesh_face_neighbor_next (p4est_mesh_face_neighbor_t
-                                                   * mfn,
-                                                   p4est_topidx_t * ntree,
-                                                   p4est_locidx_t * nquad,
-                                                   int *nface, int *nrank);
-
-/** Get the user data for the current face neighbor.
- * \param [in]     mfn           Internal status of the iterator.
- * \param [in]     ghost_data    Data for the ghost quadrants that has been
- *                               synchronized with p4est_ghost_exchange_data.
- * \return                       A pointer to the user data for the current
- *                               neighbor.
- */
-void               *p4est_mesh_face_neighbor_data (p4est_mesh_face_neighbor_t
-                                                   * mfn, void *ghost_data);
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_MESH_H */
diff --git a/OctreeRefinement/include/p4est_nodes.h b/OctreeRefinement/include/p4est_nodes.h
deleted file mode 100644
index 690374a..0000000
--- a/OctreeRefinement/include/p4est_nodes.h
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P4EST_NODES_H
-#define P4EST_NODES_H
-
-#include <p4est.h>
-#include <p4est_ghost.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Store an independent node.
- * Keep this in sync with the p4est_t data structure.
- */
-typedef struct p4est_indep
-{
-  p4est_qcoord_t      x, y;
-  int8_t              level, pad8;
-  int16_t             pad16;
-  union p4est_indep_data
-  {
-    void               *unused;
-    p4est_topidx_t      which_tree;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      int                 owner_rank;
-    }
-    piggy1;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_topidx_t      from_tree;
-    }
-    piggy_unused2;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_locidx_t      local_num;
-    }
-    piggy3;
-  }
-  p;
-}
-p4est_indep_t;
-
-/** Store a hanging node that depends on two independent nodes.
- * Keep this in sync with the p4est_t data structure.
- */
-typedef struct p4est_hang2
-{
-  p4est_qcoord_t      x, y;
-  int8_t              level, pad8;
-  int16_t             pad16;
-  union p4est_hang2_data
-  {
-    void               *unused;
-    p4est_topidx_t      which_tree;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      int                 owner_rank;
-    }
-    piggy_unused1;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_topidx_t      from_tree;
-    }
-    piggy_unused2;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_locidx_t      local_num;
-    }
-    piggy_unused3;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_locidx_t      depends[2];
-    }
-    piggy;
-  }
-  p;
-}
-p4est_hang2_t;
-
-/** This structure holds complete parallel node information.
- *
- * Nodes are unique and either independent or face hanging.
- * Independent nodes store their owner's tree id in piggy3.which_tree.
- * The index in their owner's ordering is stored in piggy3.local_num.
- * Hanging nodes store their owner's tree id in piggy.which_tree.
- * The numbers of their associated independent nodes are in piggy.depends[].
- *
- * The local_nodes table is of dimension 4 * num_local_quadrants
- * and encodes the node indexes for all corners of all quadrants.  Let
- * ni := indep_nodes.elem_count,
- * fi := face_hangings.elem_count,
- * If for l := local_nodes[k]
- * l >= 0 && l < ni: l indexes into indep_nodes.
- * l >= ni && l < ni + fi: l - ni indexes into face_hangings.
- * No other values for l are permitted.
- *
- * The array shared_indeps holds lists of node sharers (not including rank).
- * The entry shared_indeps[i] is of type sc_recycle_array_t
- * and holds the list of nodes with i + 1 sharers.
- * For each independent node, its member pad8 holds the number of sharers
- * and its member pad16 holds the position in the assigned recycle array
- * if this number fits into an int16_t.  If this limit is exceeded, the
- * array shared_offsets is filled with these positions as one p4est_locidx_t
- * per independent node, and all pad16 members are set to -1.  To recognize
- * the latter situation you can check for shared_offsets != NULL.
- *
- * Each processor owns num_owned_indeps of the stored independent nodes.
- * The first independent owned node is at index offset_owned_indeps.
- * The table nonlocal_ranks contains the ranks of all stored non-owned nodes.
- * The table global_owned_indeps holds the number of owned nodes for each rank.
- */
-typedef struct p4est_nodes
-{
-  p4est_locidx_t      num_local_quadrants;
-  p4est_locidx_t      num_owned_indeps, num_owned_shared;
-  p4est_locidx_t      offset_owned_indeps;
-  sc_array_t          indep_nodes;
-  sc_array_t          face_hangings;
-  p4est_locidx_t     *local_nodes;
-  sc_array_t          shared_indeps;
-  p4est_locidx_t     *shared_offsets;
-  int                *nonlocal_ranks;
-  p4est_locidx_t     *global_owned_indeps;
-}
-p4est_nodes_t;
-
-/** Create node information.
- * \param [in] ghost    Ghost layer.  If this is NULL, then only
- *                      tree- and processor-local nodes will be matched
- *                      and all others duplicated, all nodes will be
- *                      counted as independent with no sharers, and
- *                      nodes->global_owned_indeps will be NULL;
- *                      this also works for a corner-unbalanced forest,
- *                      but nodes may not be numbered uniquely in this case.
- */
-p4est_nodes_t      *p4est_nodes_new (p4est_t * p4est, p4est_ghost_t * ghost);
-
-/** Destroy node information. */
-void                p4est_nodes_destroy (p4est_nodes_t * nodes);
-
-/** Check node information for internal consistency. */
-int                 p4est_nodes_is_valid (p4est_t * p4est,
-                                          p4est_nodes_t * nodes);
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_NODES_H */
diff --git a/OctreeRefinement/include/p4est_plex.h b/OctreeRefinement/include/p4est_plex.h
deleted file mode 100644
index 3af8ba0..0000000
--- a/OctreeRefinement/include/p4est_plex.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P4EST_PLEX_H
-#define P4EST_PLEX_H
-
-#include <p4est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Create the data necessary to create a PETsc DMPLEX representation of a
- * forest.  The forest must be at least face balanced (see p4est_balance()).
- * See test/test_plex2.c for example usage.
- *
- * All arrays should be initialized to hold sizeof (p4est_locidx_t), except
- * for \a out_remotes, which should be initialized to hold
- * (2 * sizeof (p4est_locidx_t)).
- *
- * \param[in]     p4est                 the forest
- * \param[in]     ctype                 the type of adjacency for the overlap
- * \param[in]     overlap               the number of layers of overlap (zero
- *                                      is acceptable)
- * \param[out]    first_local_quad      the local quadrants are assigned
- *                                      contiguous plex indices, starting with
- *                                      this index
- * \param[in,out] out_points_per_dim    filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_cone_sizes        filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_cones             filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_cone_orientations filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_vertex_coords     filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_children          filled with argument for
- *                                      DMPlexSetTree()
- * \param[in,out] out_parents           filled with argument for
- *                                      DMPlexSetTree()
- * \param[in,out] out_childids          filled with argument for
- *                                      DMPlexSetTree()
- * \param[in,out] out_leaves            filled with argument for
- *                                      PetscSFSetGraph()
- * \param[in,out] out_remotes           filled with argument for
- *                                      PetscSFSetGraph()
- */
-void                p4est_get_plex_data (p4est_t * p4est,
-                                         p4est_connect_type_t ctype,
-                                         int overlap,
-                                         p4est_locidx_t * first_local_quad,
-                                         sc_array_t * out_points_per_dim,
-                                         sc_array_t * out_cone_sizes,
-                                         sc_array_t * out_cones,
-                                         sc_array_t * out_cone_orientations,
-                                         sc_array_t * out_vertex_coords,
-                                         sc_array_t * out_children,
-                                         sc_array_t * out_parents,
-                                         sc_array_t * out_childids,
-                                         sc_array_t * out_leaves,
-                                         sc_array_t * out_remotes);
-
-SC_EXTERN_C_END;
-#endif /* P4EST_PLEX_H */
diff --git a/OctreeRefinement/include/p4est_points.h b/OctreeRefinement/include/p4est_points.h
deleted file mode 100644
index 8f9ff72..0000000
--- a/OctreeRefinement/include/p4est_points.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/********************************************************************
- *                          IMPORTANT NOTE                          *
- *                                                                  *
- * The p4est_points functionality depends on sc/src/sc_sort.        *
- * That parallel bitonic sort is still buggy (see sc/bugs).         *
- * If you want to use this code you have to fix the sort first.     *
- ********************************************************************/
-
-#ifndef P4EST_POINTS_H
-#define P4EST_POINTS_H
-
-#include <p4est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Create a new forest based on a distributed set of points.
- *
- * \param [in] mpicomm       A valid MPI communicator.
- * \param [in] connectivity  This is the connectivity information that
- *                           the forest is built with.  Note the p4est
- *                           does not take ownership of the memory.
- * \param [in] maxlevel      Level of the smallest possible quadrants.
- * \param [in] points        Unsorted collection of clamped quadrant nodes.
- *                           The tree id must be stored in p.which_tree.
- * \param [in] num_points    Number of local points provided in the array.
- * \param [in] max_points    Maximum number of points per quadrant.
- *                           Applies to quadrants above maxlevel, so 0 is ok.
- *                           A value of -1 disables all refinement.
- * \param [in] data_size     This is the size of data for each quadrant which
- *                           can be zero.  Then user_data_pool is set to NULL.
- * \param [in] init_fn       Callback function to initialize the user_data
- *                           which is already allocated automatically.
- * \param [in] user_pointer  Assign to the user_pointer member of the p4est
- *                           before init_fn is called the first time.
- *
- * \return This returns a valid forest.
- *
- * \note The connectivity structure must not be destroyed
- *       during the lifetime of this forest.
- */
-p4est_t            *p4est_new_points (sc_MPI_Comm mpicomm,
-                                      p4est_connectivity_t * connectivity,
-                                      int maxlevel, p4est_quadrant_t * points,
-                                      p4est_locidx_t num_points,
-                                      p4est_locidx_t max_points,
-                                      size_t data_size, p4est_init_t init_fn,
-                                      void *user_pointer);
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_POINTS_H */
diff --git a/OctreeRefinement/include/p4est_search.h b/OctreeRefinement/include/p4est_search.h
deleted file mode 100644
index 4001d41..0000000
--- a/OctreeRefinement/include/p4est_search.h
+++ /dev/null
@@ -1,184 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P4EST_SEARCH_H
-#define P4EST_SEARCH_H
-
-/** \file p4est_search.h
- * Search through quadrants, the local part of a forest, or the partition.
- *
- * This file provides several helper functions and recursive algorithms.
- * \ingroup p4est
- */
-
-#include <p4est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Find the lowest position tq in a quadrant array such that tq >= q.
- * \return  Returns the id of the matching quadrant
- *                  or -1 if array < q or the array is empty.
- */
-ssize_t             p4est_find_lower_bound (sc_array_t * array,
-                                            const p4est_quadrant_t * q,
-                                            size_t guess);
-
-/** Find the highest position tq in a quadrant array such that tq <= q.
- * \return  Returns the id of the matching quadrant
- *                  or -1 if array > q or the array is empty.
- */
-ssize_t             p4est_find_higher_bound (sc_array_t * array,
-                                             const p4est_quadrant_t * q,
-                                             size_t guess);
-
-/** Split an array of quadrants by the children of an ancestor.
- *
- * Given a sorted \b array of quadrants that have a common ancestor at level
- * \b level, compute the \b indices of the first quadrant in each of the common
- * ancestor's children at level \b level + 1.
- * \param [in] array     The sorted array of quadrants of level > \b level.
- * \param [in] level     The level at which there is a common ancestor.
- * \param [in,out] indices     The indices of the first quadrant in each of
- *                             the ancestors's children, plus an additional
- *                             index on the end.  The quadrants of \b array
- *                             that are descendants of child i have indices
- *                             between indices[i] and indices[i + 1] - 1.  If
- *                             indices[i] = indices[i+1], this indicates that
- *                             no quadrant in the array is contained in
- *                             child i.
- */
-void                p4est_split_array (sc_array_t * array, int level,
-                                       size_t indices[]);
-
-/** Find the boundary points touched by a range of quadrants.
- *
- * Given two smallest quadrants, \b lq and \b uq, that mark the first and the
- * last quadrant in a range of quadrants, determine which portions of the tree
- * boundary the range touches.
- * \param [in] lq        The smallest quadrant at the start of the range: if
- *                       NULL, the tree's first quadrant is taken to be the
- *                       start of the range.
- * \param [in] uq        The smallest quadrant at the end of the range: if
- *                       NULL, the tree's last quadrant is taken to be the
- *                       end of the range.
- * \param [in] level     The level of the containing quadrant whose boundaries
- *                       are tested: 0 if we want to test the boundaries of the
- *                       whole tree.
- * \param [in,out] faces       An array of size 4 that is filled: faces[i] is
- *                             true if the range touches that face.
- * \param [in,out] corners     An array of size 4 that is filled: corners[i] is
- *                             true if the range touches that corner.
- *                             \b faces or \b corners may be NULL.
- * \return  Returns an int32_t encoded with the same information in \b faces
- *          and \b corners: the first (least) four bits represent the four
- *          faces, the next four bits represent the four corners.
- */
-int32_t             p4est_find_range_boundaries (p4est_quadrant_t * lq,
-                                                 p4est_quadrant_t * uq,
-                                                 int level, int faces[],
-                                                 int corners[]);
-
-/** Callback function to query the match of a "point" with a quadrant.
- *
- * This function can be called in two roles:  Per-quadrant, in which case the
- * parameter \b point is NULL, or per-point, possibly many times per quadrant.
- *
- * \param [in] p4est        The forest to be queried.
- * \param [in] which_tree   The tree id under consideration.
- * \param [in] quadrant     The quadrant under consideration.
- *                          This quadrant may be coarser than the quadrants
- *                          that are contained in the forest (an ancestor), in
- *                          which case it is a temporary variable and not part
- *                          of the forest storage.  Otherwise, it is a leaf and
- *                          points directly into the forest storage.
- * \param [in] local_num    If the quadrant is not a leaf, this is -1.  Otherwise
- *                          it is the (non-negative) index of the quadrant
- *                          relative to the processor-local quadrant storage.
- * \param [in] point        Representation of a "point"; user-defined.
- *                          If \b point is NULL, the callback may be used to
- *                          prepare quadrant-related search meta data.
- * \return                  If \b point is NULL, true if the search confined to
- *                          \b quadrant should be executed, false to skip it.
- *                          Else, true if point may be contained in the
- *                          quadrant and false otherwise; the return value has
- *                          no effect on a leaf.
- */
-typedef int         (*p4est_search_query_t) (p4est_t * p4est,
-                                             p4est_topidx_t which_tree,
-                                             p4est_quadrant_t * quadrant,
-                                             p4est_locidx_t local_num,
-                                             void *point);
-
-/** Search through the local part of a forest.
- * The search is especially efficient if multiple targets, called "points"
- * below, are searched for simultaneously.
- *
- * The search runs over all local quadrants and proceeds recursively top-down.
- * For each tree, it may start at the root of that tree, or further down at the
- * root of the subtree that contains all of the tree's local quadrants.
- * Likewise, some intermediate levels in the recursion may be skipped.
- * Its outer loop is thus a depth-first, processor-local forest traversal.
- * Each quadrant in that loop either is a leaf, or a (direct or indirect)
- * strict ancestor of a leaf.  On entering a new quadrant, a user-provided
- * quadrant-callback is executed.
- *
- * As a convenience, the user may provide anonymous "points" that are tracked
- * down the forest.  This way one search call may be used for multiple targets.
- * The set of points that potentially matches a given quadrant diminishes from
- * the root down to the leaves:  For each quadrant, an inner loop over the
- * potentially matching points executes a point-callback for each candidate
- * that determines whether the point may be a match.  If not, it is discarded
- * immediately, otherwise it is passed to the next finer level.
- * The callback is allowed to return true for the same point and more than one
- * quadrant; in this case more than one matching quadrant may be identified.
- * The callback is also allowed to return false for all children of a quadrant
- * that it returned true for earlier.
- * The points can really be anything, p4est does not perform any
- * interpretation, just passes the pointer along to the callback function.
- *
- * \param [in] p4est        The forest to be searched.
- * \param [in] search_quadrant_fn   Executed once for each quadrant that is
- *                          entered.  This quadrant is always local, if not
- *                          itself then at least one child of it.  If the
- *                          callback returns false, this quadrant and its
- *                          descendants are excluded from the search.
- *                          Its \b point argument is always NULL.
- *                          May be NULL in which case it is ignored.
- * \param [in] search_point_fn      If \b points is not NULL, must be not NULL.
- *                          Must return true for any possible matching point.
- *                          If \b points is NULL, this callback is ignored.
- * \param [in] points       User-defined array of "points".
- *                          If NULL, only the \b search_quadrant_fn callback
- *                          is executed.  If that is NULL, this function noops.
- *                          If not NULL, the \b search_point_fn is called on
- *                          its members during the search.
- */
-void                p4est_search (p4est_t * p4est,
-                                  p4est_search_query_t search_quadrant_fn,
-                                  p4est_search_query_t search_point_fn,
-                                  sc_array_t * points);
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_SEARCH_H */
diff --git a/OctreeRefinement/include/p4est_to_p8est.h b/OctreeRefinement/include/p4est_to_p8est.h
deleted file mode 100644
index 432c426..0000000
--- a/OctreeRefinement/include/p4est_to_p8est.h
+++ /dev/null
@@ -1,453 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** We do not process this file in Doxygen since it overwrites types.
- *
- * Transform 2D \ref p4est routines into 3D \ref p8est routines.  This file can
- * be included from a .c file that has been written for 2D to turn it into a 3D
- * code with minor modifications.  We #define P4_TO_P8, which allows to compile
- * a source file twice, once for 2D without and once for 3D with including this
- * header, adding extra code for 3D if necessary.
- */
-
-#ifndef P4EST_TO_P8EST_H
-#define P4EST_TO_P8EST_H
-
-#ifdef P4EST_H
-#error "The include files p4est.h and p4est_to_p8est.h cannot be combined"
-#endif
-#define P4_TO_P8
-
-#include <p4est_base.h>
-
-/* redefine macros */
-#define P4EST_ONDISK_FORMAT             P8EST_ONDISK_FORMAT
-#define P4EST_DIM                       P8EST_DIM
-#define P4EST_FACES                     P8EST_FACES
-#define P4EST_CHILDREN                  P8EST_CHILDREN
-#define P4EST_HALF                      P8EST_HALF
-#define P4EST_FTRANSFORM                P8EST_FTRANSFORM
-#define P4EST_INSUL                     P8EST_INSUL
-#define P4EST_STRING                    P8EST_STRING
-#define P4EST_MAXLEVEL                  P8EST_MAXLEVEL
-#define P4EST_QMAXLEVEL                 P8EST_QMAXLEVEL
-#define P4EST_ROOT_LEN                  P8EST_ROOT_LEN
-#define P4EST_QUADRANT_LEN              P8EST_QUADRANT_LEN
-#define P4EST_LAST_OFFSET               P8EST_LAST_OFFSET
-#define P4EST_QUADRANT_INIT             P8EST_QUADRANT_INIT
-#define P4EST_LEAF_IS_FIRST_IN_TREE     P8EST_LEAF_IS_FIRST_IN_TREE
-
-/* redefine enums */
-#define P4EST_CONNECT_FACE              P8EST_CONNECT_FACE
-#define P4EST_CONNECT_CORNER            P8EST_CONNECT_CORNER
-#define P4EST_CONNECT_FULL              P8EST_CONNECT_FULL
-#define P4EST_CONN_ENCODE_NONE          P8EST_CONN_ENCODE_NONE
-#define P4EST_TRANSFER_COMM_SRC         P8EST_TRANSFER_COMM_SRC
-#define P4EST_TRANSFER_COMM_DEST        P8EST_TRANSFER_COMM_DEST
-#define P4EST_TRANSFER_COMM_SRC_DUP     P8EST_TRANSFER_COMM_SRC_DUP
-#define P4EST_TRANSFER_COMM_DEST_DUP    P8EST_TRANSFER_COMM_DEST_DUP
-#define P4EST_TRANSFER_COMM_EXTERNAL    P8EST_TRANSFER_COMM_EXTERNAL
-#define P4EST_WRAP_NONE                 P8EST_WRAP_NONE
-#define P4EST_WRAP_REFINE               P8EST_WRAP_REFINE
-#define P4EST_WRAP_COARSEN              P8EST_WRAP_COARSEN
-
-/* redefine types */
-#ifdef P4EST_BACKWARD_DEALII
-#define p4est_balance_type_t            p8est_balance_type_t
-#endif
-#define p4est_connect_type_t            p8est_connect_type_t
-#define p4est_connectivity_encode_t     p8est_connectivity_encode_t
-#define p4est_connectivity_t            p8est_connectivity_t
-#define p4est_corner_transform_t        p8est_corner_transform_t
-#define p4est_corner_info_t             p8est_corner_info_t
-#define p4est_geometry_t                p8est_geometry_t
-#define p4est_t                         p8est_t
-#define p4est_tree_t                    p8est_tree_t
-#define p4est_quadrant_t                p8est_quadrant_t
-#define p4est_inspect_t                 p8est_inspect_t
-#define p4est_position_t                p8est_position_t
-#define p4est_init_t                    p8est_init_t
-#define p4est_refine_t                  p8est_refine_t
-#define p4est_coarsen_t                 p8est_coarsen_t
-#define p4est_weight_t                  p8est_weight_t
-#define p4est_ghost_t                   p8est_ghost_t
-#define p4est_ghost_exchange_t          p8est_ghost_exchange_t
-#define p4est_indep_t                   p8est_indep_t
-#define p4est_nodes_t                   p8est_nodes_t
-#define p4est_lnodes_t                  p8est_lnodes_t
-#define p4est_lnodes_code_t             p8est_lnodes_code_t
-#define p4est_lnodes_rank_t             p8est_lnodes_rank_t
-#define p4est_lnodes_buffer_t           p8est_lnodes_buffer_t
-#define p4est_iter_volume_t             p8est_iter_volume_t
-#define p4est_iter_volume_info_t        p8est_iter_volume_info_t
-#define p4est_iter_face_t               p8est_iter_face_t
-#define p4est_iter_face_info_t          p8est_iter_face_info_t
-#define p4est_iter_face_side_t          p8est_iter_face_side_t
-#define p4est_iter_corner_t             p8est_iter_corner_t
-#define p4est_iter_corner_side_t        p8est_iter_corner_side_t
-#define p4est_iter_corner_info_t        p8est_iter_corner_info_t
-#define p4est_search_query_t            p8est_search_query_t
-#define p4est_transfer_comm_t           p8est_transfer_comm_t
-#define p4est_transfer_context_t        p8est_transfer_context_t
-#define p4est_traverse_query_t          p8est_traverse_query_t
-#define p4est_mesh_t                    p8est_mesh_t
-#define p4est_mesh_face_neighbor_t      p8est_mesh_face_neighbor_t
-#define p4est_wrap_t                    p8est_wrap_t
-#define p4est_wrap_leaf_t               p8est_wrap_leaf_t
-#define p4est_wrap_flags_t              p8est_wrap_flags_t
-#define p4est_vtk_context_t             p8est_vtk_context_t
-
-/* redefine external variables */
-#define p4est_face_corners              p8est_face_corners
-#define p4est_face_dual                 p8est_face_dual
-#define p4est_corner_faces              p8est_corner_faces
-#define p4est_corner_face_corners       p8est_corner_face_corners
-#define p4est_child_corner_faces        p8est_child_corner_faces
-#define P4EST_DATA_UNINITIALIZED        P8EST_DATA_UNINITIALIZED
-
-/* functions in p4est_connectivity */
-#define p4est_connectivity_face_neighbor_face_corner_orientation        \
-        p8est_connectivity_face_neighbor_face_corner_orientation
-#define p4est_connectivity_face_neighbor_corner_orientation     \
-        p8est_connectivity_face_neighbor_corner_orientation
-#define p4est_connectivity_memory_used  p8est_connectivity_memory_used
-#define p4est_connectivity_new          p8est_connectivity_new
-#define p4est_connectivity_new_brick    p8est_connectivity_new_brick
-#define p4est_connectivity_new_twotrees p8est_connectivity_new_twotrees
-#define p4est_connectivity_new_byname   p8est_connectivity_new_byname
-#define p4est_connectivity_new_copy     p8est_connectivity_new_copy
-#define p4est_connectivity_bcast        p8est_connectivity_bcast
-#define p4est_connectivity_destroy      p8est_connectivity_destroy
-#define p4est_connectivity_set_attr     p8est_connectivity_set_attr
-#define p4est_connectivity_is_valid     p8est_connectivity_is_valid
-#define p4est_connectivity_is_equal     p8est_connectivity_is_equal
-#define p4est_connectivity_sink         p8est_connectivity_sink
-#define p4est_connectivity_deflate      p8est_connectivity_deflate
-#define p4est_connectivity_save         p8est_connectivity_save
-#define p4est_connectivity_source       p8est_connectivity_source
-#define p4est_connectivity_inflate      p8est_connectivity_inflate
-#define p4est_connectivity_load         p8est_connectivity_load
-#define p4est_connectivity_complete     p8est_connectivity_complete
-#define p4est_connectivity_reduce       p8est_connectivity_reduce
-#define p4est_expand_face_transform     p8est_expand_face_transform
-#define p4est_find_face_transform       p8est_find_face_transform
-#define p4est_find_corner_transform     p8est_find_corner_transform
-#define p4est_corner_array_index        p8est_corner_array_index
-#define p4est_connectivity_reorder      p8est_connectivity_reorder
-#define p4est_connectivity_permute      p8est_connectivity_permute
-#define p4est_connectivity_join_faces   p8est_connectivity_join_faces
-#define p4est_connectivity_is_equivalent p8est_connectivity_is_equivalent
-#define p4est_connectivity_read_inp_stream p8est_connectivity_read_inp_stream
-#define p4est_connectivity_read_inp     p8est_connectivity_read_inp
-
-/* functions in p4est */
-#define p4est_qcoord_to_vertex          p8est_qcoord_to_vertex
-#define p4est_memory_used               p8est_memory_used
-#define p4est_revision                  p8est_revision
-#define p4est_new                       p8est_new
-#define p4est_destroy                   p8est_destroy
-#define p4est_copy                      p8est_copy
-#define p4est_reset_data                p8est_reset_data
-#define p4est_refine                    p8est_refine
-#define p4est_coarsen                   p8est_coarsen
-#define p4est_balance                   p8est_balance
-#define p4est_partition                 p8est_partition
-#define p4est_checksum                  p8est_checksum
-#define p4est_save                      p8est_save
-#define p4est_load                      p8est_load
-#define p4est_connect_type_int          p8est_connect_type_int
-#define p4est_connect_type_string       p8est_connect_type_string
-#define p4est_tree_array_index          p8est_tree_array_index
-#define p4est_quadrant_array_index      p8est_quadrant_array_index
-#define p4est_quadrant_array_push       p8est_quadrant_array_push
-#define p4est_quadrant_mempool_alloc    p8est_quadrant_mempool_alloc
-#define p4est_quadrant_list_pop         p8est_quadrant_list_pop
-
-/* functions in p4est_extended */
-#define p4est_replace_t                 p8est_replace_t
-#define p4est_new_ext                   p8est_new_ext
-#define p4est_mesh_new_ext              p8est_mesh_new_ext
-#define p4est_copy_ext                  p8est_copy_ext
-#define p4est_refine_ext                p8est_refine_ext
-#define p4est_coarsen_ext               p8est_coarsen_ext
-#define p4est_balance_ext               p8est_balance_ext
-#define p4est_balance_subtree_ext       p8est_balance_subtree_ext
-#define p4est_partition_ext             p8est_partition_ext
-#define p4est_partition_for_coarsening  p8est_partition_for_coarsening
-#define p4est_save_ext                  p8est_save_ext
-#define p4est_load_ext                  p8est_load_ext
-#define p4est_source_ext                p8est_source_ext
-
-/* functions in p4est_iterate */
-#define p4est_iterate                   p8est_iterate
-#define p4est_iterate_ext               p8est_iterate_ext
-#define p4est_iter_fside_array_index    p8est_iter_fside_array_index
-#define p4est_iter_fside_array_index_int p8est_iter_fside_array_index_int
-#define p4est_iter_cside_array_index    p8est_iter_cside_array_index
-#define p4est_iter_cside_array_index_int p8est_iter_cside_array_index_int
-
-/* functions in p4est_points */
-#define p4est_new_points                p8est_new_points
-
-/* functions in p4est_bits */
-#define p4est_quadrant_print            p8est_quadrant_print
-#define p4est_quadrant_is_equal         p8est_quadrant_is_equal
-#define p4est_quadrant_overlaps         p8est_quadrant_overlaps
-#define p4est_quadrant_is_equal_piggy   p8est_quadrant_is_equal_piggy
-#define p4est_quadrant_compare          p8est_quadrant_compare
-#define p4est_quadrant_disjoint         p8est_quadrant_disjoint
-#define p4est_quadrant_compare_piggy    p8est_quadrant_compare_piggy
-#define p4est_quadrant_compare_local_num p8est_quadrant_compare_local_num
-#define p4est_quadrant_equal_fn         p8est_quadrant_equal_fn
-#define p4est_quadrant_hash_fn          p8est_quadrant_hash_fn
-#define p4est_node_equal_piggy_fn       p8est_node_equal_piggy_fn
-#define p4est_node_hash_piggy_fn        p8est_node_hash_piggy_fn
-#define p4est_node_clamp_inside         p8est_node_clamp_inside
-#define p4est_node_unclamp              p8est_node_unclamp
-#define p4est_node_to_quadrant          p8est_node_to_quadrant
-#define p4est_quadrant_contains_node    p8est_quadrant_contains_node
-#define p4est_quadrant_ancestor_id      p8est_quadrant_ancestor_id
-#define p4est_quadrant_child_id         p8est_quadrant_child_id
-#define p4est_quadrant_is_inside_root   p8est_quadrant_is_inside_root
-#define p4est_quadrant_is_inside_3x3    p8est_quadrant_is_inside_3x3
-#define p4est_quadrant_is_outside_face  p8est_quadrant_is_outside_face
-#define p4est_quadrant_is_outside_corner p8est_quadrant_is_outside_corner
-#define p4est_quadrant_is_node          p8est_quadrant_is_node
-#define p4est_quadrant_is_valid         p8est_quadrant_is_valid
-#define p4est_quadrant_is_extended      p8est_quadrant_is_extended
-#define p4est_quadrant_is_sibling       p8est_quadrant_is_sibling
-#define p4est_quadrant_is_sibling_D     p8est_quadrant_is_sibling_D
-#define p4est_quadrant_is_family        p8est_quadrant_is_family
-#define p4est_quadrant_is_familyv       p8est_quadrant_is_familyv
-#define p4est_quadrant_is_familypv      p8est_quadrant_is_familypv
-#define p4est_quadrant_is_parent        p8est_quadrant_is_parent
-#define p4est_quadrant_is_parent_D      p8est_quadrant_is_parent_D
-#define p4est_quadrant_is_ancestor      p8est_quadrant_is_ancestor
-#define p4est_quadrant_is_ancestor_D    p8est_quadrant_is_ancestor_D
-#define p4est_quadrant_is_next          p8est_quadrant_is_next
-#define p4est_quadrant_is_next_D        p8est_quadrant_is_next_D
-#define p4est_quadrant_overlaps_tree    p8est_quadrant_overlaps_tree
-#define p4est_quadrant_is_inside_tree   p8est_quadrant_is_inside_tree
-#define p4est_quadrant_ancestor         p8est_quadrant_ancestor
-#define p4est_quadrant_parent           p8est_quadrant_parent
-#define p4est_quadrant_sibling          p8est_quadrant_sibling
-#define p4est_quadrant_child            p8est_quadrant_child
-#define p4est_quadrant_face_neighbor    p8est_quadrant_face_neighbor
-#define p4est_quadrant_face_neighbor_extra p8est_quadrant_face_neighbor_extra
-#define p4est_quadrant_half_face_neighbors p8est_quadrant_half_face_neighbors
-#define p4est_quadrant_all_face_neighbors p8est_quadrant_all_face_neighbors
-#define p4est_quadrant_corner_neighbor  p8est_quadrant_corner_neighbor
-#define p4est_quadrant_corner_neighbor_extra    \
-        p8est_quadrant_corner_neighbor_extra
-#define p4est_quadrant_half_corner_neighbor     \
-        p8est_quadrant_half_corner_neighbor
-#define p4est_quadrant_corner_node      p8est_quadrant_corner_node
-#define p4est_quadrant_children         p8est_quadrant_children
-#define p4est_quadrant_childrenv        p8est_quadrant_childrenv
-#define p4est_quadrant_childrenpv       p8est_quadrant_childrenpv
-#define p4est_quadrant_first_descendant p8est_quadrant_first_descendant
-#define p4est_quadrant_last_descendant  p8est_quadrant_last_descendant
-#define p4est_quadrant_corner_descendant p8est_quadrant_corner_descendant
-#define p4est_nearest_common_ancestor   p8est_nearest_common_ancestor
-#define p4est_nearest_common_ancestor_D p8est_nearest_common_ancestor_D
-#define p4est_quadrant_transform_face   p8est_quadrant_transform_face
-#define p4est_quadrant_touches_corner   p8est_quadrant_touches_corner
-#define p4est_quadrant_transform_corner p8est_quadrant_transform_corner
-#define p4est_quadrant_shift_corner     p8est_quadrant_shift_corner
-#define p4est_quadrant_linear_id        p8est_quadrant_linear_id
-#define p4est_quadrant_set_morton       p8est_quadrant_set_morton
-
-/* functions in p4est_search */
-#define p4est_find_lower_bound          p8est_find_lower_bound
-#define p4est_find_higher_bound         p8est_find_higher_bound
-#define p4est_split_array               p8est_split_array
-#define p4est_find_range_boundaries     p8est_find_range_boundaries
-#define p4est_search                    p8est_search
-#define p4est_traverse                  p8est_traverse
-
-/* functions in p4est_algorithms */
-#define p4est_quadrant_init_data        p8est_quadrant_init_data
-#define p4est_quadrant_free_data        p8est_quadrant_free_data
-#define p4est_quadrant_checksum         p8est_quadrant_checksum
-#define p4est_tree_is_sorted            p8est_tree_is_sorted
-#define p4est_tree_is_linear            p8est_tree_is_linear
-#define p4est_tree_is_almost_sorted     p8est_tree_is_almost_sorted
-#define p4est_tree_is_complete          p8est_tree_is_complete
-#define p4est_tree_print                p8est_tree_print
-#define p4est_is_equal                  p8est_is_equal
-#define p4est_is_valid                  p8est_is_valid
-#define p4est_tree_compute_overlap      p8est_tree_compute_overlap
-#define p4est_tree_uniqify_overlap      p8est_tree_uniqify_overlap
-#define p4est_tree_remove_nonowned      p8est_tree_remove_nonowned
-#define p4est_complete_region           p8est_complete_region
-#define p4est_complete_subtree          p8est_complete_subtree
-#define p4est_balance_subtree           p8est_balance_subtree
-#define p4est_balance_border            p8est_balance_border
-#define p4est_linearize_tree            p8est_linearize_tree
-#define p4est_next_nonempty_process     p8est_next_nonempty_process
-#define p4est_partition_correction      p8est_partition_correction
-#define p4est_partition_for_coarsening  p8est_partition_for_coarsening
-#define p4est_partition_given           p8est_partition_given
-
-/* functions in p4est_communication */
-#define p4est_comm_parallel_env_assign  p8est_comm_parallel_env_assign
-#define p4est_comm_parallel_env_duplicate p8est_comm_parallel_env_duplicate
-#define p4est_comm_parallel_env_release p8est_comm_parallel_env_release
-#define p4est_comm_parallel_env_replace p8est_comm_parallel_env_replace
-#define p4est_comm_parallel_env_get_info p8est_comm_parallel_env_get_info
-#define p4est_comm_parallel_env_is_null p8est_comm_parallel_env_is_null
-#define p4est_comm_parallel_env_reduce  p8est_comm_parallel_env_reduce
-#define p4est_comm_parallel_env_reduce_ext p8est_comm_parallel_env_reduce_ext
-#define p4est_comm_count_quadrants      p8est_comm_count_quadrants
-#define p4est_comm_global_partition     p8est_comm_global_partition
-#define p4est_comm_count_pertree        p8est_comm_count_pertree
-#define p4est_comm_is_empty             p8est_comm_is_empty
-#define p4est_comm_is_contained         p8est_comm_is_contained
-#define p4est_comm_is_owner             p8est_comm_is_owner
-#define p4est_comm_find_owner           p8est_comm_find_owner
-#define p4est_comm_tree_info            p8est_comm_tree_info
-#define p4est_comm_neighborhood_owned   p8est_comm_neighborhood_owned
-#define p4est_comm_sync_flag            p8est_comm_sync_flag
-#define p4est_comm_checksum             p8est_comm_checksum
-#define p4est_transfer_fixed            p8est_transfer_fixed
-#define p4est_transfer_fixed_begin      p8est_transfer_fixed_begin
-#define p4est_transfer_fixed_end        p8est_transfer_fixed_end
-#define p4est_transfer_custom           p8est_transfer_custom
-#define p4est_transfer_custom_begin     p8est_transfer_custom_begin
-#define p4est_transfer_custom_end       p8est_transfer_custom_end
-
-/* functions in p4est_io */
-#define p4est_deflate_quadrants         p8est_deflate_quadrants
-#define p4est_inflate                   p8est_inflate
-
-/* functions in p4est_geometry */
-#define p4est_geometry_destroy          p8est_geometry_destroy
-#define p4est_geometry_new_connectivity p8est_geometry_new_connectivity
-
-/* functions in p4est_vtk */
-#define p4est_vtk_context_new           p8est_vtk_context_new
-#define p4est_vtk_context_destroy       p8est_vtk_context_destroy
-#define p4est_vtk_context_set_geom      p8est_vtk_context_set_geom
-#define p4est_vtk_context_set_scale     p8est_vtk_context_set_scale
-#define p4est_vtk_context_set_continuous p8est_vtk_context_set_continuous
-#define p4est_vtk_write_file            p8est_vtk_write_file
-#define p4est_vtk_write_header          p8est_vtk_write_header
-#define p4est_vtk_write_cell_dataf      p8est_vtk_write_cell_dataf
-#define p4est_vtk_write_cell_data       p8est_vtk_write_cell_data
-#define p4est_vtk_write_point_dataf     p8est_vtk_write_point_dataf
-#define p4est_vtk_write_point_data      p8est_vtk_write_point_data
-#define p4est_vtk_write_footer          p8est_vtk_write_footer
-
-/* functions in p4est_ghost */
-#define p4est_quadrant_find_owner       p8est_quadrant_find_owner
-#define p4est_ghost_memory_used         p8est_ghost_memory_used
-#define p4est_ghost_new                 p8est_ghost_new
-#define p4est_ghost_destroy             p8est_ghost_destroy
-#define p4est_ghost_exchange_data       p8est_ghost_exchange_data
-#define p4est_ghost_exchange_data_begin p8est_ghost_exchange_data_begin
-#define p4est_ghost_exchange_data_end   p8est_ghost_exchange_data_end
-#define p4est_ghost_exchange_custom     p8est_ghost_exchange_custom
-#define p4est_ghost_exchange_custom_begin p8est_ghost_exchange_custom_begin
-#define p4est_ghost_exchange_custom_end p8est_ghost_exchange_custom_end
-#define p4est_ghost_exchange_custom_levels p8est_ghost_exchange_custom_levels
-#define p4est_ghost_exchange_custom_levels_begin        \
-        p8est_ghost_exchange_custom_levels_begin
-#define p4est_ghost_exchange_custom_levels_end  \
-        p8est_ghost_exchange_custom_levels_end
-#define p4est_ghost_bsearch             p8est_ghost_bsearch
-#define p4est_ghost_contains            p8est_ghost_contains
-#define p4est_ghost_is_valid            p8est_ghost_is_valid
-#define p4est_face_quadrant_exists      p8est_face_quadrant_exists
-#define p4est_quadrant_exists           p8est_quadrant_exists
-#define p4est_is_balanced               p8est_is_balanced
-#define p4est_ghost_checksum            p8est_ghost_checksum
-#define p4est_ghost_expand              p8est_ghost_expand
-
-/* functions in p4est_nodes */
-#define p4est_nodes_new                 p8est_nodes_new
-#define p4est_nodes_destroy             p8est_nodes_destroy
-#define p4est_nodes_is_valid            p8est_nodes_is_valid
-
-/* functions in p4est_lnodes */
-#define p4est_lnodes_new                p8est_lnodes_new
-#define p4est_lnodes_destroy            p8est_lnodes_destroy
-#define p4est_ghost_support_lnodes      p8est_ghost_support_lnodes
-#define p4est_ghost_expand_by_lnodes    p8est_ghost_expand_by_lnodes
-#define p4est_partition_lnodes          p8est_partition_lnodes
-#define p4est_partition_lnodes_detailed p8est_partition_lnodes_detailed
-#define p4est_lnodes_decode             p8est_lnodes_decode
-#define p4est_lnodes_share_owned_begin  p8est_lnodes_share_owned_begin
-#define p4est_lnodes_share_owned_end    p8est_lnodes_share_owned_end
-#define p4est_lnodes_share_owned        p8est_lnodes_share_owned
-#define p4est_lnodes_share_all_begin    p8est_lnodes_share_all_begin
-#define p4est_lnodes_share_all_end      p8est_lnodes_share_all_end
-#define p4est_lnodes_share_all          p8est_lnodes_share_all
-#define p4est_lnodes_buffer_destroy     p8est_lnodes_buffer_destroy
-#define p4est_lnodes_rank_array_index   p8est_lnodes_rank_array_index
-#define p4est_lnodes_rank_array_index_int p8est_lnodes_rank_array_index_int
-#define p4est_lnodes_global_index       p8est_lnodes_global_index
-
-/* functions in p4est_mesh */
-#define p4est_mesh_memory_used          p8est_mesh_memory_used
-#define p4est_mesh_new                  p8est_mesh_new
-#define p4est_mesh_destroy              p8est_mesh_destroy
-#define p4est_mesh_quadrant_cumulative  p8est_mesh_quadrant_cumulative
-#define p4est_mesh_face_neighbor_init   p8est_mesh_face_neighbor_init
-#define p4est_mesh_face_neighbor_init2  p8est_mesh_face_neighbor_init2
-#define p4est_mesh_face_neighbor_next   p8est_mesh_face_neighbor_next
-#define p4est_mesh_face_neighbor_data   p8est_mesh_face_neighbor_data
-
-/* functions in p4est_balance */
-#define p4est_balance_seeds_face        p8est_balance_seeds_face
-#define p4est_balance_seeds_corner      p8est_balance_seeds_corner
-#define p4est_balance_seeds             p8est_balance_seeds
-
-/* functions in p4est_wrap */
-#define p4est_wrap_new_conn             p8est_wrap_new_conn
-#define p4est_wrap_new_p4est            p8est_wrap_new_p8est
-#define p4est_wrap_new_brick            p8est_wrap_new_brick
-#define p4est_wrap_new_world            p8est_wrap_new_world
-#define p4est_wrap_new_ext              p8est_wrap_new_ext
-#define p4est_wrap_new_copy             p8est_wrap_new_copy
-#define p4est_wrap_destroy              p8est_wrap_destroy
-#define p4est_wrap_set_hollow           p8est_wrap_set_hollow
-#define p4est_wrap_set_coarsen_delay    p8est_wrap_set_coarsen_delay
-#define p4est_wrap_get_ghost            p8est_wrap_get_ghost
-#define p4est_wrap_get_mesh             p8est_wrap_get_mesh
-#define p4est_wrap_mark_refine          p8est_wrap_mark_refine
-#define p4est_wrap_mark_coarsen         p8est_wrap_mark_coarsen
-#define p4est_wrap_adapt                p8est_wrap_adapt
-#define p4est_wrap_partition            p8est_wrap_partition
-#define p4est_wrap_complete             p8est_wrap_complete
-#define p4est_wrap_leaf_next            p8est_wrap_leaf_next
-#define p4est_wrap_leaf_first           p8est_wrap_leaf_first
-
-/* functions in p4est_plex */
-#define p4est_get_plex_data             p8est_get_plex_data
-#define p4est_get_plex_data_ext         p8est_get_plex_data_ext
-
-/* functions in p4est_connrefine */
-#define p4est_connectivity_refine       p8est_connectivity_refine
-
-#endif /* !P4EST_TO_P8EST_H */
diff --git a/OctreeRefinement/include/p4est_vtk.h b/OctreeRefinement/include/p4est_vtk.h
deleted file mode 100644
index 8e554ff..0000000
--- a/OctreeRefinement/include/p4est_vtk.h
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p4est_vtk.h
- *
- * Routines for printing a forest and associated fields to VTK format.
- *
- * \ingroup p4est
- */
-
-#ifndef P4EST_VTK_H
-#define P4EST_VTK_H
-
-#include <p4est_geometry.h>
-#include <p4est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Opaque context type for writing VTK output with multiple function calls.
- */
-typedef struct p4est_vtk_context p4est_vtk_context_t;
-
-/** Write the p4est in VTK format.
- *
- * This is a convenience function for the special case of writing out
- * the tree id, quadrant level, and MPI rank only.
- * One file is written per MPI rank, and one meta file on rank 0.
- * The quadrants are scaled to length .95; see \ref p4est_vtk_write_header.
- * This function will abort if there is a file error.
- *
- * \param [in] p4est    The p4est to be written.
- * \param [in] geom     A p4est_geometry_t structure or NULL for vertex space
- *                      as defined by p4est->connectivity.
- * \param [in] filename The first part of the file name which will have the
- *                      MPI rank appended to it: The output file will be
- *                      filename_rank.vtu, and the meta file filename.pvtu.
- */
-void                p4est_vtk_write_file (p4est_t * p4est,
-                                          p4est_geometry_t * geom,
-                                          const char *filename);
-
-/** The first call to write a VTK file using individual functions.
- *
- * Writing a VTK file is split into multiple functions that keep a context.
- * This is the first function that allocates the opaque context structure.
- * After allocation, further parameters can be set for the context.
- * Then, the header, possible data fields, and the footer must be written.
- * The process can be aborted any time by destroying the context.  In this
- * case, open files are closed cleanly with only partially written content.
- *
- * \param p4est     The p4est to be written.
- *                  If no geometry is specified in
- *                  \ref p4est_vtk_context_set_geom, we require
- *                  \b p4est->connectivity to have valid vertex arrays.
- * \param filename  The first part of the name which will have the processor
- *                  number appended to it (i.e., the output file will be
- *                  filename_rank.vtu).  The parallel meta-files for Paraview
- *                  and Visit use this basename too.
- *                  We copy this filename to internal storage, so it is not
- *                  needed to remain alive after calling this function.
- * \return          A VTK context fur further use.
- */
-p4est_vtk_context_t *p4est_vtk_context_new (p4est_t * p4est,
-                                            const char *filename);
-
-/** Modify the geometry transformation registered in the context.
- * After \ref p4est_vtk_context_new, it is at the default NULL.
- * \param [in,out] cont         The context is modified.
- *                              It must not yet have been used to start writing
- *                              in \ref p4est_vtk_write_header.
- * \param geom      A \ref p4est_geometry_t structure, or NULL for vertex space.
- *                  If NULL, \b p4est->connectivity->vertices and
- *                  \b tree_to_vertex must be non-NULL.
- */
-void                p4est_vtk_context_set_geom (p4est_vtk_context_t * cont,
-                                                p4est_geometry_t * geom);
-
-/** Modify the context parameter for scaling the quadrants.
- * After \ref p4est_vtk_context_new, it is at the default 0.95.
- * \param [in,out] cont         The context is modified.
- *                              It must not yet have been used to start writing
- *                              in \ref p4est_vtk_write_header.
- * \param [in] scale            Scale parameter must be in (0, 1].
- */
-void                p4est_vtk_context_set_scale (p4est_vtk_context_t * cont,
-                                                 double scale);
-
-/** Modify the context parameter for expecting continuous point data.
- * If set to true, the point data is understood as a continuous field.
- * In this case, we can significantly reduce the file size when scale == 1.
- * For discontinuous point data, it should be set to false.
- * After \ref p4est_vtk_context_new, it is at the default false.
- * \param [in,out] cont         The context is modified.
- *                              It must not yet have been used to start writing
- *                              in \ref p4est_vtk_write_header.
- * \param [in] continuous       Boolean parameter.
- */
-void                p4est_vtk_context_set_continuous (p4est_vtk_context_t *
-                                                      cont, int continuous);
-
-/** Cleanly destroy a \ref p4est_vtk_context_t structure.
- *
- * This function closes all the file pointers and frees the context.
- * It can be called even if the VTK output
- * has only been partially written, the files' content will be incomplete.
- *
- * \param[in] context     The VTK file context to be destroyed.
- */
-void                p4est_vtk_context_destroy (p4est_vtk_context_t * context);
-
-/** Write the VTK header.
- *
- * Writing a VTK file is split into a few routines.
- * This allows there to be an arbitrary number of
- * fields.  The calling sequence would be something like
- *
- *     vtk_context = p4est_vtk_context_new (p4est, "output");
- *     p4est_vtk_context_set_* (vtk_context, parameter);
- *     vtk_context = p4est_vtk_write_header (vtk_context, ...);
- *     if (vtk_context == NULL) { error; }
- *     vtk_context = p4est_vtk_write_cell_data (vtk_context, ...);
- *     if (vtk_context == NULL) { error; }
- *     vtk_context = p4est_vtk_write_point_data (vtk_context, ...);
- *     if (vtk_context == NULL) { error; }
- *     retval = p4est_vtk_write_footer (vtk_context);
- *     if (retval) { error; }
- *
- * \param [in,out] cont    A VTK context created by \ref p4est_vtk_context_new.
- *                         None of the vtk_write functions must have been called.
- *                         This context is the return value if no error occurs.
- *
- * \return          On success, an opaque context (p4est_vtk_context_t) pointer
- *                  that must be passed to subsequent p4est_vtk calls.  It is
- *                  required to call \ref p4est_vtk_write_footer eventually with
- *                  this value.  Returns NULL on error.
- */
-p4est_vtk_context_t *p4est_vtk_write_header (p4est_vtk_context_t * cont);
-
-/** Write VTK cell data.
- *
- * There are options to have this function write
- * the tree id, quadrant level, or MPI rank without explicit input data.
- *
- * Writing a VTK file is split into a few routines.
- * This allows there to be an arbitrary number of
- * fields.
- *
- * \param [in,out] cont    A VTK context created by \ref p4est_vtk_context_new.
- * \param [in] write_tree  Boolean to determine if the tree id should be output.
- * \param [in] write_level Boolean to determine if the tree levels should be output.
- * \param [in] write_rank  Boolean to determine if the MPI rank should be output.
- * \param [in] wrap_rank   Number to wrap around the rank with a modulo operation.
- *                         Can be 0 for no wrapping.
- * \param [in] num_cell_scalars Number of cell scalar datasets to output.
- * \param [in] num_cell_vectors Number of cell vector datasets to output.
- *
- * The variable arguments need to be pairs of (fieldname, fieldvalues), followed
- * by a final argument of the VTK context cont (same as the first argument).
- * The cell scalar pairs come first, followed by the cell vector pairs, then cont.
- * Each 'fieldname' argument shall be a char string containing the name of the data
- * contained in the following 'fieldvalues'. Each of the 'fieldvalues'
- * arguments shall be an sc_array_t * holding double variables.  The number of
- * doubles in each sc_array must be exactly \a p4est->local_num_quadrants for
- * scalar data and \a 3*p4est->local_num_quadrants for vector data.
- *
- * \note The current p4est_vtk_context_t structure, \a cont, must be the first
- * and the last argument
- * of any call to this function; this argument is used to validate that the
- * correct number of variable arguments have been provided.
- *
- * \return          On success, the context that has been passed in.
- *                  On failure, returns NULL and deallocates the context.
- */
-p4est_vtk_context_t *p4est_vtk_write_cell_dataf (p4est_vtk_context_t * cont,
-                                                 int write_tree,
-                                                 int write_level,
-                                                 int write_rank,
-                                                 int wrap_rank,
-                                                 int num_cell_scalars,
-                                                 int num_cell_vectors, ...);
-
-/** This is an alternate version of the varargs function.
- * Works exactly the same otherwise.
- * TODO: implement, also for vectors and point data.
- */
-p4est_vtk_context_t *p4est_vtk_write_cell_data (p4est_vtk_context_t * cont,
-                                                int write_tree,
-                                                int write_level,
-                                                int write_rank,
-                                                int wrap_rank,
-                                                int num_cell_scalars,
-                                                int num_cell_vectors,
-                                                const char *filenames[],
-                                                sc_array_t * values[]);
-
-/** Write VTK point data.
- *
- * Writing a VTK file is split into a few routines.
- * This allows there to be an arbitrary number of
- * fields.
- *
- * \param [in,out] cont    A VTK context created by \ref p4est_vtk_context_new.
- * \param [in] num_point_scalars Number of point scalar datasets to output.
- * \param [in] num_point_vectors Number of point vector datasets to output.
- *
- * The variable arguments need to be pairs of (fieldname, fieldvalues) where
- * the point scalar pairs come first, followed by the point vector pairs.  Each
- * 'fieldname' argument shall be a char string containing the name of the data
- * contained in the following 'fieldvalues'. Each of the 'fieldvalues'
- * arguments shall be an sc_array_t * holding double variables. The number of
- * doubles in each sc_array must be exactly the number of components (1 for
- * scalar and 3 for vector) times 4 times number of elements.
- *
- * \note The current
- * p4est_vtk_context_t structure, cont, must be the last argument of any call
- * to this function; this argument is used to validate that the correct number
- * of variable arguments have been provided.
- *
- * \note The number of point scalar data in each
- * sc_array must be exactly \a P4EST_CHILDREN*local_num_quadrants, and the
- * number of point vector data must be exactly \a
- * 3*P4EST_CHILDREN*local_num_quadrants. I.e. there must be data for every
- * corner of every quadrant in the \a p4est, even if the corner is shared by
- * multiple quadrants.
- *
- * \return          On success, the context that has been passed in.
- *                  On failure, returns NULL and deallocates the context.
- */
-p4est_vtk_context_t *p4est_vtk_write_point_dataf (p4est_vtk_context_t * cont,
-                                                  int num_point_scalars,
-                                                  int num_point_vectors, ...);
-
-/** Write the VTU footer and clean up.
- *
- * Writing a VTK file is split into a few routines.
- * This function writes the footer information to the VTK file and cleanly
- * destroys the VTK context.
- *
- * \param [in] cont Context is deallocated before the function returns.
- *
- * \return          This returns 0 if no error and -1 if there is an error.
- */
-int                 p4est_vtk_write_footer (p4est_vtk_context_t * cont);
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_VTK_H */
diff --git a/OctreeRefinement/include/p4est_wrap.h b/OctreeRefinement/include/p4est_wrap.h
deleted file mode 100644
index 7a48351..0000000
--- a/OctreeRefinement/include/p4est_wrap.h
+++ /dev/null
@@ -1,368 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P4EST_WRAP_H
-#define P4EST_WRAP_H
-
-/** \file p4est_wrap.h
- * The logic in p4est_wrap encapsulates core p4est data structures and provides
- * functions that clarify the mark-adapt-partition cycle.  There is also an
- * element iterator that can replace the nested loops over trees and tree
- * quadrants, respectively, which can help make application code cleaner.
- */
-
-#include <p4est_mesh.h>
-#include <p4est_extended.h>
-#include <sc_refcount.h>
-
-SC_EXTERN_C_BEGIN;
-
-/*** COMPLETE INTERNAL STATE OF P4EST ***/
-
-typedef enum p4est_wrap_flags
-{
-  P4EST_WRAP_NONE = 0,
-  P4EST_WRAP_REFINE = 0x01,
-  P4EST_WRAP_COARSEN = 0x02
-}
-p4est_wrap_flags_t;
-
-typedef struct p4est_wrap
-{
-  /* this member is never used or changed by p4est_wrap */
-  void               *user_pointer;     /**< Convenience member for users */
-
-  /** If true, this wrap has NULL for ghost, mesh, and flag members.
-   * If false, they are properly allocated and kept current internally. */
-  int                 hollow;
-
-  /** Non-negative integer tells us how many adaptations to wait
-   * before any given quadrent may be coarsened again. */
-  int                 coarsen_delay;
-
-  /** Boolean: If true, we delay coarsening not only after refinement,
-   * but also between subsequent coarsenings of the same quadrant. */
-  int                 coarsen_affect;
-
-  /** This reference counter is a workaround for internal use only.
-   * Until we have refcounting/copy-on-write for the connectivity,
-   * we count the references to conn by copies of this wrap structure.
-   * There must be no external references left when this wrap is destroyed.
-   */
-  sc_refcount_t       conn_rc;
-  p4est_connectivity_t *conn;
-  struct p4est_wrap  *conn_owner;
-
-  /* these members are considered public and read-only */
-  int                 p4est_dim;
-  int                 p4est_half;
-  int                 p4est_faces;
-  int                 p4est_children;
-  p4est_connect_type_t btype;
-  p4est_replace_t     replace_fn;
-  p4est_t            *p4est;    /**< p4est->user_pointer is used internally */
-
-  /* anything below here is considered private und should not be touched */
-  int                 weight_exponent;
-  uint8_t            *flags, *temp_flags;
-  p4est_locidx_t      num_refine_flags, inside_counter, num_replaced;
-
-  /* for ghost and mesh use p4est_wrap_get_ghost, _mesh declared below */
-  p4est_ghost_t      *ghost;
-  p4est_mesh_t       *mesh;
-  p4est_ghost_t      *ghost_aux;
-  p4est_mesh_t       *mesh_aux;
-  int                 match_aux;
-}
-p4est_wrap_t;
-
-/** Create a p4est wrapper from a given connectivity structure.
- * The ghost and mesh members are initialized as well as the flags.
- * The btype is set to P4EST_CONNECT_FULL.
- * \param [in] mpicomm        We expect sc_MPI_Init to be called already.
- * \param [in] conn           Connectivity structure.  Wrap takes ownership.
- * \param [in] initial_level  Initial level of uniform refinement.
- * \return                    A fully initialized p4est_wrap structure.
- */
-p4est_wrap_t       *p4est_wrap_new_conn (sc_MPI_Comm mpicomm,
-                                         p4est_connectivity_t * conn,
-                                         int initial_level);
-
-/** Create a wrapper for a given p4est structure.
- * \param [in,out] p4est      Valid p4est object that we will own.
- *                            We take ownership of its connectivity too.
- *                            Its user pointer must be NULL and will be changed.
- * \param [in] hollow         Do not allocate flags, ghost, and mesh members.
- * \param [in] btype          The neighborhood used for balance, ghost, mesh.
- * \param [in] replace_fn     Callback to replace quadrants during refinement,
- *                            coarsening or balancing in \ref p4est_wrap_adapt.
- *                            May be NULL.
- * \param [in] user_pointer   Set the user pointer in \ref p4est_wrap_t.
- *                            Subsequently, we will never access it.
- * \return                    A fully initialized p4est_wrap structure.
- */
-p4est_wrap_t       *p4est_wrap_new_p4est (p4est_t * p4est, int hollow,
-                                          p4est_connect_type_t btype,
-                                          p4est_replace_t replace_fn,
-                                          void *user_pointer);
-
-/** Create a p4est wrapper from a given connectivity structure.
- * Like p4est_wrap_new_conn, but with extra parameters \a hollow and \a btype.
- * \param [in] mpicomm        We expect sc_MPI_Init to be called already.
- * \param [in] conn           Connectivity structure.  Wrap takes ownership.
- * \param [in] initial_level  Initial level of uniform refinement.
- *                            No effect if less/equal to zero.
- * \param [in] hollow         Do not allocate flags, ghost, and mesh members.
- * \param [in] btype          The neighborhood used for balance, ghost, mesh.
- * \param [in] replace_fn     Callback to replace quadrants during refinement,
- *                            coarsening or balancing in \ref p4est_wrap_adapt.
- *                            May be NULL.
- * \param [in] user_pointer   Set the user pointer in \ref p4est_wrap_t.
- *                            Subsequently, we will never access it.
- * \return                    A fully initialized p4est_wrap structure.
- */
-p4est_wrap_t       *p4est_wrap_new_ext (sc_MPI_Comm mpicomm,
-                                        p4est_connectivity_t * conn,
-                                        int initial_level, int hollow,
-                                        p4est_connect_type_t btype,
-                                        p4est_replace_t replace_fn,
-                                        void *user_pointer);
-
-/** Create a p4est wrapper from an existing one.
- * \note This wrapper must be destroyed before the original one.
- * We set it to hollow and copy the original p4est data structure.
- * \param [in,out] source   We access the source for debugging purposes.
- * \param [in] data_size    The data size installed in the copied forest.
- * \param [in] replace_fn     Callback to replace quadrants during refinement,
- *                            coarsening or balancing in \ref p4est_wrap_adapt.
- *                            May be NULL.
- * \param [in] user_pointer   Set the user pointer in \ref p4est_wrap_t.
- *                            Subsequently, we will never access it.
- * \return                    A fully initialized p4est_wrap structure.
- */
-p4est_wrap_t       *p4est_wrap_new_copy (p4est_wrap_t * source,
-                                         size_t data_size,
-                                         p4est_replace_t replace_fn,
-                                         void *user_pointer);
-
-/** Create p4est and auxiliary data structures.
- * Expects sc_MPI_Init to be called beforehand.
- */
-p4est_wrap_t       *p4est_wrap_new_unitsquare (sc_MPI_Comm mpicomm,
-                                               int initial_level);
-p4est_wrap_t       *p4est_wrap_new_periodic (sc_MPI_Comm mpicomm,
-                                             int initial_level);
-p4est_wrap_t       *p4est_wrap_new_rotwrap (sc_MPI_Comm mpicomm,
-                                            int initial_level);
-p4est_wrap_t       *p4est_wrap_new_corner (sc_MPI_Comm mpicomm,
-                                           int initial_level);
-p4est_wrap_t       *p4est_wrap_new_pillow (sc_MPI_Comm mpicomm,
-                                           int initial_level);
-p4est_wrap_t       *p4est_wrap_new_moebius (sc_MPI_Comm mpicomm,
-                                            int initial_level);
-p4est_wrap_t       *p4est_wrap_new_cubed (sc_MPI_Comm mpicomm,
-                                          int initial_level);
-p4est_wrap_t       *p4est_wrap_new_disk (sc_MPI_Comm mpicomm,
-                                         int initial_level);
-p4est_wrap_t       *p4est_wrap_new_brick (sc_MPI_Comm mpicomm,
-                                          int bx, int by, int px, int py,
-                                          int initial_level);
-
-/** Passes sc_MPI_COMM_WORLD to p4est_wrap_new_unitsquare. */
-p4est_wrap_t       *p4est_wrap_new_world (int initial_level);
-void                p4est_wrap_destroy (p4est_wrap_t * pp);
-
-/** Change hollow status of the wrap.
- * A wrap is hollow if the flags, ghost, and mesh members are NULL.
- * Legal to set to current hollow status, in which case wrap is not changed.
- * If changed from not hollow to hollow, previously set refinement and
- * coarsening flags are zeroed.
- * \param [in,out] pp   The present wrap structure, hollow or not.
- * \param [in] hollow   The desired hollow status.  If set to hollow,
- *                      refinement flags are zeroed.
- */
-void                p4est_wrap_set_hollow (p4est_wrap_t * pp, int hollow);
-
-/** Set a parameter that delays coarsening after adaptation.
- * If positive each quadrant counts the number of adaptations it has survived.
- * Calling this function initializes all quadrant counters to zero.
- * On adaptation we only coarsen a quadrant if it is old enough.
- * Optionally, we can also delay the time between subsequent coarsenings.
- * \param [in,out] pp           A valid p4est_wrap structure.
- * \param [in] coarsen_delay    Set how many adaptation cycles a quadrant has
- *                              to wait to be allowed to coarsen.
- *                              Non-negative number; 0 disables the feature.
- *                              Suggested default value: not larger than 2.
- * \param [in] coarsen_affect   Boolean; If true, we not only count from the
- *                              most recent refinement but also between
- *                              subsequent coarsenings.
- *                              Suggested default: 0.
- */
-void                p4est_wrap_set_coarsen_delay (p4est_wrap_t * pp,
-                                                  int coarsen_delay,
-                                                  int coarsen_affect);
-
-/** Return the appropriate ghost layer.
- * This function is necessary since two versions may exist simultaneously
- * after refinement and before partition/complete.
- * \param [in] pp   Must have !pp->hollow.
- * */
-p4est_ghost_t      *p4est_wrap_get_ghost (p4est_wrap_t * pp);
-
-/** Return the appropriate mesh structure.
- * This function is necessary since two versions may exist simultaneously
- * after refinement and before partition/complete.
- * \param [in] pp   Must have !pp->hollow.
- * */
-p4est_mesh_t       *p4est_wrap_get_mesh (p4est_wrap_t * pp);
-
-/** Mark a local element for refinement.
- * This will cancel any coarsening mark set previously for this element.
- * \param [in,out] pp The p4est wrapper to work with, must not be hollow.
- * \param [in] which_tree The number of the tree this element lives in.
- * \param [in] which_quad The number of this element relative to its tree.
- */
-void                p4est_wrap_mark_refine (p4est_wrap_t * pp,
-                                            p4est_topidx_t which_tree,
-                                            p4est_locidx_t which_quad);
-
-/** Mark a local element for coarsening.
- * This will cancel any refinement mark set previously for this element.
- * \param [in,out] pp The p4est wrapper to work with, must not be hollow.
- * \param [in] which_tree The number of the tree this element lives in.
- * \param [in] which_quad The number of this element relative to its tree.
- */
-void                p4est_wrap_mark_coarsen (p4est_wrap_t * pp,
-                                             p4est_topidx_t which_tree,
-                                             p4est_locidx_t which_quad);
-
-/** Call p4est_refine, coarsen, and balance to update pp->p4est.
- * Checks pp->flags as per-quadrant input against p4est_wrap_flags_t.
- * The pp->flags array is updated along with p4est and reset to zeros.
- * Creates ghost_aux and mesh_aux to represent the intermediate mesh.
- * \param [in,out] pp The p4est wrapper to work with, must not be hollow.
- * \return          boolean whether p4est has changed.
- *                  If true, partition must be called.
- *                  If false, partition must not be called, and
- *                  complete must not be called either.
- */
-int                 p4est_wrap_adapt (p4est_wrap_t * pp);
-
-/** Call p4est_partition for equal leaf distribution.
- * Frees the old ghost and mesh first and updates pp->flags along with p4est.
- * The pp->flags array is reset to zeros.
- * Creates ghost and mesh to represent the new mesh.
- * \param [in,out] pp The p4est wrapper to work with, must not be hollow.
- * \param [in] weight_exponent      Integer weight assigned to each leaf
- *                  according to 2 ** (level * exponent).  Passing 0 assigns
- *                  equal weight to all leaves.  Passing 1 increases the
- *                  leaf weight by a factor of two for each level increase.
- *                  CURRENTLY ONLY 0 AND 1 ARE LEGAL VALUES.
- * \param [out] unchanged_first
- *                  If not NULL, is assigned the processor-local index of the
- *                  first local quadrant that has stayed on this processor.  If
- *                  no quadrant has stayed, the value is set to zero.
- *                  This number is in reference to the new (output) partition.
- * \param [out] unchanged_length
- *                  If not NULL, is assigned the number of quadrants that have
- *                  stayed on this processor.  If no quadrant has stayed, the
- *                  value is set to zero.
- * \param [out] unchanged_old_first
- *                  If not NULL, is assigned the processor-local index of the
- *                  first local quadrant that has stayed with reference to
- *                  the old (input) partition.  If no quadrant has stayed,
- *                  the value is set to zero.
- * \return          boolean whether p4est has changed.
- *                  If true, complete must be called.
- *                  If false, complete must not be called.
- */
-int                 p4est_wrap_partition (p4est_wrap_t * pp,
-                                          int weight_exponent,
-                                          p4est_locidx_t * unchanged_first,
-                                          p4est_locidx_t * unchanged_length,
-                                          p4est_locidx_t *
-                                          unchanged_old_first);
-
-/** Free memory for the intermediate mesh.
- * Sets mesh_aux and ghost_aux to NULL.
- * This function must be used if both refinement and partition effect changes.
- * After this call, we are ready for another mark-refine-partition cycle.
- * \param [in,out] pp The p4est wrapper to work with, must not be hollow.
- */
-void                p4est_wrap_complete (p4est_wrap_t * pp);
-
-/*** ITERATOR OVER THE FOREST LEAVES ***/
-
-typedef struct p4est_wrap_leaf
-{
-  p4est_wrap_t       *pp;             /**< Must contain a valid ghost */
-
-  /* Information about the current quadrant */
-  p4est_topidx_t      which_tree;     /**< Current tree number */
-  p4est_locidx_t      which_quad;     /**< Quadrant number relative to tree */
-  p4est_locidx_t      local_quad;     /**< Quadrant number relative to proc */
-  p4est_tree_t       *tree;           /**< Current tree */
-  sc_array_t         *tquadrants;     /**< Current tree's quadrants */
-  p4est_quadrant_t   *quad;           /**< Current quadrant */
-#if 0                           /* DEPRECATED -- anyone using them? */
-  int                 level;
-  double              lowerleft[3];
-  double              upperright[3];
-#endif
-
-  /* Information about parallel neighbors */
-  int                 is_mirror;      /**< Quadrant at parallel boundary? */
-  sc_array_t         *mirrors;        /**< If not NULL, from pp's ghost */
-  p4est_locidx_t      nm;             /**< Internal: mirror counter */
-  p4est_locidx_t      next_mirror_quadrant;     /**< Internal: next */
-}
-p4est_wrap_leaf_t;
-
-/** Determine whether we have just entered a different tree */
-#define P4EST_LEAF_IS_FIRST_IN_TREE(wleaf) ((wleaf)->which_quad == 0)
-
-/* Create an iterator over the local leaves in the forest.
- * Returns a newly allocated state containing the first leaf,
- * or NULL if the local partition of the tree is empty.
- * \param [in] pp   Legal p4est_wrap structure, hollow or not.
- * \param [in] track_mirrors    If true, \a pp must not be hollow and mirror
- *                              information from the ghost layer is stored.
- * \return          NULL if processor is empty, otherwise a leaf iterator for
- *                  subsequent use with \a p4est_wrap_leaf_next.
- */
-p4est_wrap_leaf_t  *p4est_wrap_leaf_first (p4est_wrap_t * pp,
-                                           int track_mirrors);
-
-/* Move the forest leaf iterator forward.
- * \param [in,out] leaf     A non-NULL leaf iterator created by
- *                          \ref p4est_wrap_leaf_first.
- * \return          The state that was input with updated information for the
- *                  next leaf, or NULL and deallocates the input if called with
- *                  the last leaf on this processor.
- */
-p4est_wrap_leaf_t  *p4est_wrap_leaf_next (p4est_wrap_leaf_t * leaf);
-
-SC_EXTERN_C_END;
-
-#endif /* !P4EST_WRAP_H */
diff --git a/OctreeRefinement/include/p6est.h b/OctreeRefinement/include/p6est.h
deleted file mode 100644
index 6e27408..0000000
--- a/OctreeRefinement/include/p6est.h
+++ /dev/null
@@ -1,629 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P6EST_H
-#define P6EST_H
-
-/** \file p6est.h
- *
- * A hybrid 2D+1D AMR extension.
- *
- * \ingroup p6est
- */
-
-/** \defgroup p6est p6est
- *
- * A hybrid 2D+1D AMR extension.
- *
- * To include this component of the p4est library, configure p4est with the
- * --enable-p6est option given.  This module provides a specific kind of
- * anisotropic adaptive mesh refinement for 3D meshes: it organizes the
- * hexahedral cells into columns.  Each column has the footprint of a 2D p4est
- * quadrant.  The cells within a column can be individually refined
- * vertically, and a whole column of cells can be refined horizontally.  When
- * the forest is partitioned, each column is assigned to a single MPI process,
- * i.e., a column cannot be split between processes.  Most of the main 2D / 3D
- * interface is available for p6est: refinement and coarsening, balance, ghost
- * layers, and i/o.  Finite element nodes can also be created using
- * p6est_lnodes_new(): this creates nodes in the same data structure as
- * p8est_lnodes_new().
- */
-
-/* 2+1D refinement is based on the 2D p4est datatypes */
-#include <p4est.h>
-/* We need p8est_connect_type_t typedef from p8est_connectivity */
-#include <p8est_connectivity.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** This structure holds the 2D+1D inter-tree connectivity information.
- * It is essentially a wrapper of the 2D p4est_connecitivity_t datatype, with
- * some additional information about how the third dimension is embedded.
- */
-typedef struct p6est_connectivity
-{
-  p4est_connectivity_t *conn4;  /**< the 2D connecitvity; owned; vertices
-                                  interpreted as the vertices of the bottom of
-                                  the sheet */
-  double             *top_vertices;     /**< if NULL, uniform vertical profile,
-                                           otherwise the vertices of the top of
-                                           the sheet: should be the same size
-                                           as \a conn4->tree_to_vertex; owned. */
-  double              height[3];        /**< if \a top_vertices == NULL, this gives the
-                                           offset from the bottom of the sheet to
-                                           the top */
-}
-p6est_connectivity_t;
-
-/** Create a p6est_connectivity_t from a p4est_connectivity_t.  All fields
- * are copied, so all inputs can be safey destroyed.
- *
- * \param[in] conn4         the 2D connectivity
- * \param[in] top_vertices  if NULL, then the sheet has a uniform vertical
- *                          profile; otherwise, \a top_vertices gives teh
- *                          vertices of the top of the sheet; should be the
- *                          same size as \a conn4->tree_to_vertex
- * \param[in] height        if \a top_vertices == NULL, then this gives the
- *                          offset fro the bottom of the sheet to the top.
- *
- * \return the 2D+1D connectivity information.
- */
-p6est_connectivity_t *p6est_connectivity_new (p4est_connectivity_t * conn4,
-                                              double *top_vertices,
-                                              double height[3]);
-
-/** Destroy a p6est_connectivity structure */
-void                p6est_connectivity_destroy (p6est_connectivity_t * conn);
-
-/** Get the vertices of the corners of a tree.
- *
- * \param[in]  conn         the 2D+1D connectivity structure
- * \param[in]  which_tree   a tree in the forest
- * \param[out] vertices     the coordinates of the corners of the tree
- */
-void                p6est_tree_get_vertices (p6est_connectivity_t * conn,
-                                             p4est_topidx_t which_tree,
-                                             double vertices[24]);
-
-/** Transform a quadrant coordinate into the space spanned by tree vertices.
- *
- * \param [in] connectivity     Connectivity must provide the vertices.
- * \param [in] treeid           Identify the tree that contains x, y.
- * \param [in] x, y             Quadrant coordinates relative to treeid.
- * \param [out] vxy             Transformed coordinates in vertex space.
- */
-void                p6est_qcoord_to_vertex (p6est_connectivity_t *
-                                            connectivity,
-                                            p4est_topidx_t treeid,
-                                            p4est_qcoord_t x,
-                                            p4est_qcoord_t y,
-                                            p4est_qcoord_t z, double vxyz[3]);
-
-/** A 1D quadrant datatype: this is used to encode a "layer" of a column in
- * the 2D+1D AMR scheme.
- */
-typedef struct p2est_quadrant
-{
-  p4est_qcoord_t      z;                /**< vertical coordinate */
-  int8_t              level,            /**< level of refinement */
-                      pad8;             /**< padding */
-  int16_t             pad16;            /**< padding */
-  union p6est_quadrant_data
-  {
-    void               *user_data;      /**< never changed by p4est */
-    long                user_long;      /**< never changed by p4est */
-    int                 user_int;       /**< never changed by p4est */
-    p4est_topidx_t      which_tree;     /**< the tree containing the quadrant */
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      int                 owner_rank;
-    }
-    piggy1; /**< of ghost layer, store the tree and owner rank */
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_topidx_t      from_tree;
-    }
-    piggy2; /**< of transformed layers, store the original tree and the
-                 target tree */
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_locidx_t      local_num;
-    }
-    piggy3; /**< of ghost layers, store the tree and index in the owner's
-                 numbering */
-  }
-  p; /**< a union of additional data attached to a layer */
-}
-p2est_quadrant_t;
-
-/** The p6est forest datatype */
-typedef struct p6est
-{
-  sc_MPI_Comm         mpicomm;          /**< MPI communicator */
-  int                 mpisize,          /**< number of MPI processes */
-                      mpirank;          /**< this process's MPI rank */
-  int                 mpicomm_owned;    /**< whether this communicator is
-                                             owned by the forest */
-  size_t              data_size;        /**< size of per-quadrant p.user_data
-                     (see p2est_quadrant_t::p2est_quadrant_data::user_data) */
-  void               *user_pointer;     /**< convenience pointer for users,
-                                             never touched by p4est */
-  p6est_connectivity_t *connectivity;   /**< topology of sheet, not owned. */
-  p4est_t            *columns;  /**< 2D description of column layout
-                                     built from \a connectivity */
-  sc_array_t         *layers;   /**< single array that stores
-                                     p2est_quadrant_t layers within columns */
-  sc_mempool_t       *user_data_pool;   /**< memory allocator for user data */
-  /* WARNING: This is NULL if data size
-   *          equals zero.  */
-  sc_mempool_t       *layer_pool;       /**< memory allocator
-                                             for temporary layers */
-  p4est_gloidx_t     *global_first_layer; /**< first global quadrant index for
-                                               each process and 1 beyond */
-  p4est_qcoord_t      root_len; /**< height of the domain */
-}
-p6est_t;
-
-/** Callback function prototype to initialize the layers's user data.
- *
- * \param[in] p6est        the forest
- * \param[in] which_tree   the tree in the forest
- * \param[in] column       the column in the tree in the forest
- * \param[in] layer        the layer in the column in the tree in the
- *                         forest, whose \a user_data is to be initialized
- */
-typedef void        (*p6est_init_t) (p6est_t * p6est,
-                                     p4est_topidx_t which_tree,
-                                     p4est_quadrant_t * column,
-                                     p2est_quadrant_t * layer);
-
-/** Callback function prototype to transfer information from outgoing layers
- * to incoming layers.
- *
- * This is used by extended routines when the layers of an existing, valid
- * p6est are changed.  The callback allows the user to make changes to newly
- * initialized layers before the layers that they replace are destroyed.
- *
- * \param [in] num_outcolumns  The number of columns that contain the outgoing
- *                             layers: will be either 1 or 4.
- * \param [in] num_outlayers   The number of outgoing layers: will be either 1
- *                             (a single layer is being refined), 2 (two
- *                             layers are being vertically coarsened), or 4
- *                             (four layers are being horizontally coarsened).
- * \param [in] outcolumns      The columns of the outgoing layers
- * \param [in] outlayers       The outgoing layers: after the callback, the
- *                             user_data, if \a p6est->data_size is nonzero,
- *                             will be destroyed.
- * \param [in] num_incolumns   The number of columns that contain the outgoing
- *                             layers: will be either 1 or 4.
- * \param [in] num_inlayers    The number of incoming layers: will be either 1
- *                             (coarsening), 2 (vertical refinement), or 4
- *                             (horizontal refinement)
- * \param [in] incolumns       The columns of the incoming layers
- * \param [in,out] inlayers    The incoming layers: prior to the callback,
- *                             the user_data, if \a p6est->data_size is nonzero,
- *                             is allocated, and the p6est_init_t callback,
- *                             if it has been provided, will be called.
- */
-typedef void        (*p6est_replace_t) (p6est_t * p6est,
-                                        p4est_topidx_t which_tree,
-                                        int num_outcolumns,
-                                        int num_outlayers,
-                                        p4est_quadrant_t * outcolumns[],
-                                        p2est_quadrant_t * outlayers[],
-                                        int num_incolumns,
-                                        int num_inlayers,
-                                        p4est_quadrant_t * incolumns[],
-                                        p2est_quadrant_t * inlayers[]);
-
-/** Callback function prototype to decide whether to horizontally refine a
- * column, i.e., horizontally refine all of the layers in the column.
- * \return nonzero if the layer shall be refined.
- */
-typedef int         (*p6est_refine_column_t) (p6est_t * p6est,
-                                              p4est_topidx_t which_tree,
-                                              p4est_quadrant_t * column);
-
-/** Callback function prototype to decide whether to vertically refine a
- * layer.
- * \return nonzero if the layer shall be refined.
- */
-typedef int         (*p6est_refine_layer_t) (p6est_t * p6est,
-                                             p4est_topidx_t which_tree,
-                                             p4est_quadrant_t * column,
-                                             p2est_quadrant_t * layer);
-
-/** Callback function prototype to decide for horizontal coarsening.
- * \param [in] columns      Pointers to 4 sibling columns.
- * \return nonzero if the columns shall be replaced with their parent.
- */
-typedef int         (*p6est_coarsen_column_t) (p6est_t * p6est,
-                                               p4est_topidx_t which_tree,
-                                               p4est_quadrant_t * columns[]);
-
-/** Callback function prototype to decide for vertical coarsening.
- * \param [in] layers      Pointers to 2 vertical sibling layers.
- * \return nonzero if the layers shall be replaced with their parent.
- */
-typedef int         (*p6est_coarsen_layer_t) (p6est_t * p6est,
-                                              p4est_topidx_t which_tree,
-                                              p4est_quadrant_t * column,
-                                              p2est_quadrant_t * layers[]);
-
-/** Callback function prototype to calculate weights for partitioning.
- * \return a 32bit integer >= 0 as the quadrant weight.
- * \note    Global sum of weights must fit into a 64bit integer.
- */
-typedef int         (*p6est_weight_t) (p6est_t * p6est,
-                                       p4est_topidx_t which_tree,
-                                       p4est_quadrant_t * column,
-                                       p2est_quadrant_t * layer);
-
-extern void        *P2EST_DATA_UNINITIALIZED;
-
-/** set statically allocated quadrant to defined values */
-#define P2EST_QUADRANT_INIT(q) \
-  ((void) memset ((q), -1, sizeof (p2est_quadrant_t)))
-
-/** Create a new forest.
- *
- * The new forest consists of equi-partitioned root quadrants.
- * When there are more processors than trees, some processors are empty.
- *
- * \param [in] mpicomm       A valid MPI communicator.
- * \param [in] connectivity  This is the connectivity information that
- *                           the forest is built with.  Note the p6est
- *                           does not take ownership of the memory.
- * \param [in] data_size     This is the size of data for each quadrant which
- *                           can be zero.  Then user_data_pool is set to NULL.
- * \param [in] init_fn       Callback function to initialize the user_data
- *                           which is already allocated automatically.
- * \param [in] user_pointer  Assign to the user_pointer member of the p6est
- *                           before init_fn is called the first time.
- *
- * \return This returns a valid forest.
- *
- * \note The connectivity structure must not be destroyed
- *       during the lifetime of this forest.
- */
-p6est_t            *p6est_new (sc_MPI_Comm mpicomm,
-                               p6est_connectivity_t * connectivity,
-                               size_t data_size,
-                               p6est_init_t init_fn, void *user_pointer);
-
-/** Create a new forest from an already created p4est that represents
- * columns.
- *
- * \param [in] p4est         A valid p4est.  A deep copy will be created, so
- *                           this can be destroyed without affectin the new
- *                           p6est object.
- * \param [in] top_vertices  the same as in p6est_conectivity_new()
- * \param [in] height        the same as in p6est_conectivity_new()
- * \param [in] min_zlevel    the same as in p6est_new()
- * \param [in] data_size     the same as in p6est_new()
- * \param [in] init_fn       the same as in p6est_new()
- * \param [in] user_pointer  the same as in p6est_new()
- *
- * \return This returns a valid forest.  The user must destroy the
- * connectivity for the new p6est independently.
- */
-p6est_t            *p6est_new_from_p4est (p4est_t * p4est,
-                                          double *top_vertices,
-                                          double height[3], int min_zlevel,
-                                          size_t data_size,
-                                          p6est_init_t init_fn,
-                                          void *user_pointer);
-
-/** Destroy a p6est.
- *
- * \note The connectivity structure is not destroyed with the p6est.
- */
-void                p6est_destroy (p6est_t * p6est);
-
-/** Make a deep copy of a p6est.
- * The connectivity is not duplicated.
- * Copying of quadrant user data is optional.
- * If old and new data sizes are 0, the user_data field is copied regardless.
- *
- * \param [in]  copy_data  If true, data are copied.
- *                         If false, data_size is set to 0.
- * \return  Returns a valid p6est that does not depend on the input.
- */
-p6est_t            *p6est_copy (p6est_t * input, int copy_data);
-
-/** Reset user pointer and element data.
- * When the data size is changed the quadrant data is freed and allocated.
- * The initialization callback is invoked on each quadrant.
- * Old user_data content is disregarded.
- *
- * \param [in] data_size     This is the size of data for each quadrant which
- *                           can be zero.  Then user_data_pool is set to NULL.
- * \param [in] init_fn       Callback function to initialize the user_data
- *                           which is already allocated automatically.
- * \param [in] user_pointer  Assign to the user_pointer member of the p6est
- *                           before init_fn is called the first time.
- */
-void                p6est_reset_data (p6est_t * p6est, size_t data_size,
-                                      p6est_init_t init_fn,
-                                      void *user_pointer);
-
-/** Refine the columns of a sheet.
- *
- * \param [in,out] p6est The forest is changed in place.
- * \param [in] refine_recursive Boolean to decide on recursive refinement.
- * \param [in] refine_fn Callback function that must return true if a column
- *                       shall be refined into smaller columns.  If
- *                       refine_recursive is true, refine_fn is called for
- *                       every existing and newly created column.
- *                       Otherwise, it is called for every existing column.
- *                       It is possible that a refinement request made by the
- *                       callback is ignored.  To catch this case, you can
- *                       examine whether init_fn gets called, or use
- *                       p6est_refine_columns_ext in p6est_extended.h and examine
- *                       whether replace_fn gets called.
- * \param [in] init_fn   Callback function to initialize the user_data of newly
- *                       created layers within columns, which are already
- *                       allocated.  This function pointer may be NULL.
- */
-void                p6est_refine_columns (p6est_t * p6est,
-                                          int refine_recursive,
-                                          p6est_refine_column_t refine_fn,
-                                          p6est_init_t init_fn);
-
-/** Refine the layers within the columns of a sheet.
- *
- * \param [in,out] p6est The forest is changed in place.
- * \param [in] refine_recursive Boolean to decide on recursive refinement.
- * \param [in] refine_fn Callback function that must return true if a layer
- *                       shall be refined into smaller layers.  If
- *                       refine_recursive is true, refine_fn is called for
- *                       every existing and newly created layer.
- *                       Otherwise, it is called for every existing layer.
- *                       It is possible that a refinement request made by the
- *                       callback is ignored.  To catch this case, you can
- *                       examine whether init_fn gets called, or use
- *                       p6est_refine_layers_ext in p6est_extended.h and examine
- *                       whether replace_fn gets called.
- * \param [in] init_fn   Callback function to initialize the user_data of newly
- *                       created layers, which are already allocated.  This
- *                       function pointer may be NULL.
- */
-void                p6est_refine_layers (p6est_t * p6est,
-                                         int refine_recursive,
-                                         p6est_refine_layer_t refine_fn,
-                                         p6est_init_t init_fn);
-
-/** Coarsen the columns of a sheet.
- *
- * \param [in,out] p6est  The forest is changed in place.
- * \param [in] coarsen_recursive Boolean to decide on recursive coarsening.
- * \param [in] coarsen_fn Callback function that returns true if a
- *                        family of columns shall be coarsened
- * \param [in] init_fn    Callback function to initialize the user_data
- *                        which is already allocated automatically.
- */
-void                p6est_coarsen_columns (p6est_t * p6est,
-                                           int coarsen_recursive,
-                                           p6est_coarsen_column_t coarsen_fn,
-                                           p6est_init_t init_fn);
-
-/** Coarsen the layers of a sheet.
- *
- * \param [in,out] p6est  The forest is changed in place.
- * \param [in] coarsen_recursive Boolean to decide on recursive coarsening.
- * \param [in] coarsen_fn Callback function that returns true if a
- *                        family of layers shall be coarsened
- * \param [in] init_fn    Callback function to initialize the user_data
- *                        which is already allocated automatically.
- */
-void                p6est_coarsen_layers (p6est_t * p6est,
-                                          int coarsen_recursive,
-                                          p6est_coarsen_layer_t coarsen_fn,
-                                          p6est_init_t init_fn);
-
-/** Balance a forest.
- *
- * \param [in] p6est     The p6est to be worked on.
- * \param [in] btype     Balance type (face, corner or default, full).
- * \param [in] init_fn   Callback function to initialize the user_data
- *                       which is already allocated automatically.
- */
-void                p6est_balance (p6est_t * p6est,
-                                   p8est_connect_type_t btype,
-                                   p6est_init_t init_fn);
-
-typedef enum
-{
-  P6EST_COMM_PARTITION = 1,
-  P6EST_COMM_GHOST,
-  P6EST_COMM_BALANCE
-}
-p6est_comm_tag_t;
-
-/** Equally partition the forest.
- *
- * The forest will be partitioned between processors where they each
- * have an approximately equal number of quadrants.
- *
- * Note that \a p6est->layers and \a p6est->global_first_layers may change
- * during this call.  Address pointers referencing these objects from before
- * \a p6est_partition is called become invalid.
- *
- * \param [in,out] p6est      The forest that will be partitioned.
- * \param [in]     weight_fn  A weighting function or NULL
- *                            for uniform partitioning.
- */
-p4est_gloidx_t      p6est_partition (p6est_t * p6est,
-                                     p6est_weight_t weight_fn);
-void                p6est_partition_correct (p6est_t * p6est,
-                                             p4est_locidx_t *
-                                             num_layers_in_proc);
-void                p6est_partition_to_p4est_partition (p6est_t * p6est,
-                                                        p4est_locidx_t *
-                                                        num_layers_in_proc,
-                                                        p4est_locidx_t *
-                                                        num_columns_in_proc);
-void                p4est_partition_to_p6est_partition (p6est_t * p6est,
-                                                        p4est_locidx_t *
-                                                        num_columns_in_proc,
-                                                        p4est_locidx_t *
-                                                        num_layers_in_proc);
-
-p4est_gloidx_t      p6est_partition_for_coarsening (p6est_t * p6est,
-                                                    p4est_locidx_t *
-                                                    num_layers_in_proc);
-p4est_gloidx_t      p6est_partition_given (p6est_t * p6est,
-                                           p4est_locidx_t *
-                                           num_layers_in_proc);
-
-/** Compute the checksum for a forest.
- * Based on quadrant arrays only. It is independent of partition and mpisize.
- * \return  Returns the checksum on processor 0 only. 0 on other processors.
- */
-unsigned            p6est_checksum (p6est_t * p6est);
-
-/** Save the complete connectivity/p6est data to disk.  This is a collective
- *
- * operation that all MPI processes need to call.  All processes write
- * into the same file, so the filename given needs to be identical over
- * all parallel invocations.
- * \param [in] filename    Name of the file to write.
- * \param [in] p6est       Valid forest structure.
- * \param [in] save_data   If true, the element data is saved.
- *                         Otherwise, a data size of 0 is saved.
- * \note            Aborts on file errors.
- */
-void                p6est_save (const char *filename, p6est_t * p6est,
-                                int save_data);
-
-/** Load the complete connectivity/p6est structure from disk.
- *
- * \param [in] filename         Name of the file to read.
- * \param [in] mpicomm          A valid MPI communicator.
- * \param [in] data_size        Size of data for each quadrant which can be
- *                              zero.  Then user_data_pool is set to NULL.
- *                              If data_size is zero, load_data is ignored.
- * \param [in] load_data        If true, the element data is loaded.  This is
- *                              only permitted if the saved data size matches.
- *                              If false, the stored data size is ignored.
- * \param [in] user_pointer     Assign to the user_pointer member of the p6est
- *                              before init_fn is called the first time.
- * \param [out] connectivity    Connectivity must be destroyed separately.
- * \return          Returns a valid forest structure. A pointer to a valid
- *                  connectivity structure is returned through the last
- *                  argument.
- * \note            Aborts on file errors or invalid file contents.
- */
-p6est_t            *p6est_load (const char *filename, sc_MPI_Comm mpicomm,
-                                size_t data_size, int load_data,
-                                void *user_pointer,
-                                p6est_connectivity_t ** connectivity);
-
-/** Return a pointer to a quadrant array element indexed by a size_t. */
-/*@unused@*/
-static inline p2est_quadrant_t *
-p2est_quadrant_array_index (sc_array_t * array, size_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p2est_quadrant_t));
-  P4EST_ASSERT (it < array->elem_count);
-
-  return (p2est_quadrant_t *) (array->array + sizeof (p2est_quadrant_t) * it);
-}
-
-/** Call sc_array_push for a quadrant array. */
-/*@unused@*/
-static inline p2est_quadrant_t *
-p2est_quadrant_array_push (sc_array_t * array)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p2est_quadrant_t));
-
-  return (p2est_quadrant_t *) sc_array_push (array);
-}
-
-/** Call sc_mempool_alloc for a mempool creating quadrants. */
-/*@unused@*/
-static inline p2est_quadrant_t *
-p2est_quadrant_mempool_alloc (sc_mempool_t * mempool)
-{
-  P4EST_ASSERT (mempool->elem_size == sizeof (p2est_quadrant_t));
-
-  return (p2est_quadrant_t *) sc_mempool_alloc (mempool);
-}
-
-/** Call sc_list pop for a quadrant array. */
-/*@unused@*/
-static inline p2est_quadrant_t *
-p2est_quadrant_list_pop (sc_list_t * list)
-{
-  return (p2est_quadrant_t *) sc_list_pop (list);
-}
-
-#define P6EST_COLUMN_GET_RANGE(q,f,l)                \
-  do {                                               \
-    *(f) = (size_t) (q)->p.piggy3.local_num;         \
-    *(l) = *(f) + (size_t) (q)->p.piggy3.which_tree; \
-  } while (0);
-
-#define P6EST_COLUMN_SET_RANGE(q,f,l)                        \
-  do {                                                       \
-    (q)->p.piggy3.local_num = (p4est_locidx_t) (f);          \
-    (q)->p.piggy3.which_tree = (p4est_topidx_t) ((l) - (f)); \
-  } while (0);
-
-/*@unused@*/
-static inline void
-p6est_layer_init_data (p6est_t * p6est, p4est_topidx_t which_tree,
-                       p4est_quadrant_t * column,
-                       p2est_quadrant_t * layer, p6est_init_t init_fn)
-{
-  if (p6est->data_size > 0) {
-    layer->p.user_data = sc_mempool_alloc (p6est->user_data_pool);
-  }
-  else {
-    layer->p.user_data = NULL;
-  }
-  if (init_fn != NULL) {
-    init_fn (p6est, which_tree, column, layer);
-  }
-}
-
-/*@unused@*/
-static inline void
-p6est_layer_free_data (p6est_t * p6est, p2est_quadrant_t * layer)
-{
-  if (p6est->data_size > 0) {
-    sc_mempool_free (p6est->user_data_pool, layer->p.user_data);
-  }
-  layer->p.user_data = NULL;
-}
-
-void                p6est_compress_columns (p6est_t * p6est);
-void                p6est_update_offsets (p6est_t * p6est);
-
-SC_EXTERN_C_END;
-
-#endif /* !P6EST_H */
diff --git a/OctreeRefinement/include/p6est_communication.h b/OctreeRefinement/include/p6est_communication.h
deleted file mode 100644
index be2fdee..0000000
--- a/OctreeRefinement/include/p6est_communication.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P6EST_COMMUNICATION_H
-#define P6EST_COMMUNICATION_H
-
-/** \file p6est_communication.h
- *
- * MPI_Comm management.
- *
- * \ingroup p6est
- */
-
-#include <p6est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Assign an MPI communicator to p6est; retrieve parallel environment.
- *
- * \param [in] mpicomm    A valid MPI communicator.
- *
- * \note The provided MPI communicator is not owned by p6est.
- */
-void                p6est_comm_parallel_env_assign (p6est_t * p6est,
-                                                    sc_MPI_Comm mpicomm);
-
-/** Duplicate MPI communicator and replace the current one by the duplicate.
- *
- * \note The duplicated MPI communicator is owned by p6est.
- */
-void                p6est_comm_parallel_env_duplicate (p6est_t * p6est);
-
-/** Release MPI communicator if it is owned by p6est.
- */
-void                p6est_comm_parallel_env_release (p6est_t * p6est);
-
-/** Replace the current MPI communicator by the one provided as input.
- *
- * \param [in] mpicomm    A valid MPI communicator.
- *
- * \note The provided MPI communicator is not owned by p6est.
- */
-void                p6est_comm_parallel_env_replace (p6est_t * p6est,
-                                                     sc_MPI_Comm mpicomm);
-
-/** Retrieve parallel environment information.
- */
-void                p6est_comm_parallel_env_get_info (p6est_t * p6est);
-
-/** Check if the MPI communicator is valid.
- *
- * \return True if communicator is not NULL communicator, false otherwise.
- */
-int                 p6est_comm_parallel_env_is_null (p6est_t * p6est);
-
-/** Reduce MPI communicator to non-empty ranks (i.e., nonzero quadrant counts).
- *
- * \param [in/out] p6est_supercomm  Object which communicator is reduced.
- *                                  points to NULL if this p6est does not
- *                                  exists.
- *
- * \return True if p6est exists on this MPI rank after reduction.
- */
-int                 p6est_comm_parallel_env_reduce (p6est_t **
-                                                    p6est_supercomm);
-
-/** Reduce MPI communicator to non-empty ranks and add a group of ranks that
- * will remain in the reduced communicator regardless whether they are empty
- * or not.
- *
- * \param [in/out] p6est_supercomm  Object which communicator is reduced.
- *                                  Points to NULL if this p6est does not
- *                                  exists.
- * \param [in] group_add         Group of ranks that will remain in
- *                               communicator.
- * \param [in] add_to_beginning  If true, ranks will be added to the beginning
- *                               of the reduced communicator, otherwise to the
- *                               end.
- * \param[out] ranks_subcomm     If not null, array of size 'subcommsize' with
- *                               subcommrank->supercommrank map.
- *
- * \return True if p6est exists on this MPI rank after reduction.
- */
-int                 p6est_comm_parallel_env_reduce_ext (p6est_t **
-                                                        p6est_supercomm,
-                                                        sc_MPI_Group
-                                                        group_add,
-                                                        int add_to_beginning,
-                                                        int **ranks_subcomm);
-
-SC_EXTERN_C_END;
-
-#endif /* !P6EST_COMMUNICATION_H */
diff --git a/OctreeRefinement/include/p6est_extended.h b/OctreeRefinement/include/p6est_extended.h
deleted file mode 100644
index 96712c8..0000000
--- a/OctreeRefinement/include/p6est_extended.h
+++ /dev/null
@@ -1,288 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P6EST_EXTENDED_H
-#define P6EST_EXTENDED_H
-
-/********************************************************************
- *                          IMPORTANT NOTE                          *
- *                                                                  *
- * These interfaces are intended for those who like finer control.  *
- * The API offers extended versions of some basic p6est functions.  *
- * The API may change without notice.                               *
- ********************************************************************/
-
-/** \file p6est_extended.h
- *
- * Interface routines with extended capabilities.
- *
- * \ingroup p6est
- */
-
-#include <p6est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Create a new forest.
- * This is a more general form of p6est_new().
- * See the documentation of p6est_new() for basic usage.
- *
- * \param [in] min_quadrants    Minimum initial quadrants per processor.
- *                              Makes the refinement pattern mpisize-specific.
- * \param [in] min_level        The forest is horizontally refined at least to
- *                              this level.  May be negative or 0, then it has
- *                              no effect.
- * \param [in] min_zlevel       The forest is vertically refined at least to
- *                              this level.  May be negative or 0, then it has
- *                              no effect.
- * \parem [in] num_zroot        The number of "root" vertical layers
- *                              (used when non-power-of-2 layers are desired)
- * \param [in] fill_uniform     If true, fill the forest with a uniform mesh
- *                              instead of the coarsest possible one.
- *                              The latter is partition-specific so that
- *                              is usually not a good idea.
- */
-p6est_t            *p6est_new_ext (sc_MPI_Comm mpicomm,
-                                   p6est_connectivity_t * connectivity,
-                                   p4est_locidx_t min_quadrants,
-                                   int min_level, int min_zlevel,
-                                   int num_zroot,
-                                   int fill_uniform, size_t data_size,
-                                   p6est_init_t init_fn, void *user_pointer);
-
-/** Make a deep copy of a p6est.
- * The connectivity is not duplicated.
- * Copying of quadrant user data is optional.
- * If old and new data sizes are 0, the user_data field is copied regardless.
- * The inspect member of the copy is set to NULL.
- *
- * \param [in]  copy_data  If true, data are copied.
- *                         If false, data_size is set to 0.
- * \param [in]  duplicate_mpicomm  If true, MPI communicator is copied.
- * \return  Returns a valid p6est that does not depend on the input.
- */
-p6est_t            *p6est_copy_ext (p6est_t * input, int copy_data,
-                                    int duplicate_mpicomm);
-
-/** Save the complete connectivity/p6est data to disk.
- *
- * This is a collective operation that all MPI processes need to call.  All
- * processes write into the same file, so the filename given needs to be
- * identical over all parallel invocations.  See p6est_load_ext() for
- * information on the autopartition parameter.
- *
- * \param [in] filename    Name of the file to write.
- * \param [in] p6est       Valid forest structure.
- * \param [in] save_data   If true, the element data is saved.
- *                         Otherwise, a data size of 0 is saved.
- * \param [in] save_partition   If false, save file as if 1 core was used.
- *                              If true, save core count and partition.
- *                         Advantage: Partition can be recovered on loading
- *                              with same mpisize and autopartition false.
- *                         Disadvantage: Makes the file depend on mpisize.
- *                  Either way the file can be loaded with autopartition true.
- * \note            Aborts on file errors.
- */
-void                p6est_save_ext (const char *filename, p6est_t * p6est,
-                                    int save_data, int save_partition);
-
-/** Load the complete connectivity/p6est structure from disk.
- *
- * It is possible to load the file with a different number of processors
- * than has been used to write it.  The partition will then be uniform.
- *
- * \param [in] filename         Name of the file to read.
- * \param [in] mpicomm          A valid MPI communicator.
- * \param [in] data_size        Size of data for each quadrant which can be
- *                              zero.  Then user_data_pool is set to NULL.
- *                              If data_size is zero, load_data is ignored.
- * \param [in] load_data        If true, the element data is loaded.  This is
- *                              only permitted if the saved data size matches.
- *                              If false, the stored data size is ignored.
- * \param [in] autopartition    Ignore saved partition and make it uniform.
- * \param [in] broadcasthead    Have only rank 0 read headers and bcast them.
- * \param [in] user_pointer     Assign to the user_pointer member of the p6est
- *                              before init_fn is called the first time.
- * \param [out] connectivity    Connectivity must be destroyed separately.
- * \return          Returns a valid forest structure. A pointer to a valid
- *                  connectivity structure is returned through the last
- *                  argument.
- * \note            Aborts on file errors or invalid file contents.
- */
-p6est_t            *p6est_load_ext (const char *filename, sc_MPI_Comm mpicomm,
-                                    size_t data_size, int load_data,
-                                    int autopartition, int broadcasthead,
-                                    void *user_pointer,
-                                    p6est_connectivity_t ** connectivity);
-
-/** Horizontally refine a forest with a bounded refinement level and a replace option.
- *
- * \param [in,out] p6est The forest is changed in place.
- * \param [in] refine_recursive Boolean to decide on recursive refinement.
- * \param [in] maxlevel   Maximum allowed refinement level (inclusive).
- *                        If this is negative the level is restricted only
- *                        by the compile-time constant QMAXLEVEL in p4est.h.
- * \param [in] refine_fn  Callback function that must return true if a quadrant
- *                        shall be refined.  If refine_recursive is true,
- *                        refine_fn is called for every existing and newly
- *                        created quadrant.  Otherwise, it is called for every
- *                        existing quadrant.  It is possible that a refinement
- *                        request made by the callback is ignored.  To catch
- *                        this case, you can examine whether init_fn or
- *                        replace_fn gets called.
- * \param [in] init_fn    Callback function to initialize the user_data for
- *                        newly created quadrants, which is guaranteed to be
- *                        allocated.  This function pointer may be NULL.
- * \param [in] replace_fn Callback function that allows the user to change
- *                        incoming quadrants based on the quadrants they
- *                        replace; may be NULL.
- */
-void                p6est_refine_columns_ext (p6est_t * p6est,
-                                              int refine_recursive,
-                                              int maxlevel,
-                                              p6est_refine_column_t refine_fn,
-                                              p6est_init_t init_fn,
-                                              p6est_replace_t replace_fn);
-
-/** Vertically refine a forest with a bounded refinement level and a replace option.
- *
- * \param [in,out] p6est The forest is changed in place.
- * \param [in] refine_recursive Boolean to decide on recursive refinement.
- * \param [in] maxlevel   Maximum allowed refinement level (inclusive).
- *                        If this is negative the level is restricted only
- *                        by the compile-time constant QMAXLEVEL in p4est.h.
- * \param [in] refine_fn  Callback function that must return true if a quadrant
- *                        shall be refined.  If refine_recursive is true,
- *                        refine_fn is called for every existing and newly
- *                        created quadrant.  Otherwise, it is called for every
- *                        existing quadrant.  It is possible that a refinement
- *                        request made by the callback is ignored.  To catch
- *                        this case, you can examine whether init_fn or
- *                        replace_fn gets called.
- * \param [in] init_fn    Callback function to initialize the user_data for
- *                        newly created quadrants, which is guaranteed to be
- *                        allocated.  This function pointer may be NULL.
- * \param [in] replace_fn Callback function that allows the user to change
- *                        incoming quadrants based on the quadrants they
- *                        replace; may be NULL.
- */
-void                p6est_refine_layers_ext (p6est_t * p6est,
-                                             int refine_recursive,
-                                             int maxlevel,
-                                             p6est_refine_layer_t refine_fn,
-                                             p6est_init_t init_fn,
-                                             p6est_replace_t replace_fn);
-
-/** Horizontally coarsen a forest.
- * \param [in,out] p6est The forest is changed in place.
- * \param [in] coarsen_recursive Boolean to decide on recursive coarsening.
- * \param [in] callback_orphans Boolean to enable calling coarsen_fn even on
- *                        non-families.  In this case, the second quadrant
- *                        pointer in the argument list of the callback is NULL,
- *                        subsequent pointers are undefined, and the return
- *                        value is ignored.  If coarsen_recursive is true, it
- *                        is possible that a quadrant is called once or more as
- *                        an orphan and eventually becomes part of a family.
- * \param [in] coarsen_fn Callback function that returns true if a
- *                        family of quadrants shall be coarsened.
- * \param [in] init_fn    Callback function to initialize the user_data
- *                        which is already allocated automatically.
- * \param [in] replace_fn Callback function that allows the user to change
- *                        incoming quadrants based on the quadrants they
- *                        replace.
- */
-void                p6est_coarsen_columns_ext (p6est_t * p6est,
-                                               int coarsen_recursive,
-                                               int callback_orphans,
-                                               p6est_coarsen_column_t
-                                               coarsen_fn,
-                                               p6est_init_t init_fn,
-                                               p6est_replace_t replace_fn);
-
-/** Vertically coarsen a forest.
- * \param [in,out] p6est The forest is changed in place.
- * \param [in] coarsen_recursive Boolean to decide on recursive coarsening.
- * \param [in] callback_orphans Boolean to enable calling coarsen_fn even on
- *                        non-families.  In this case, the second quadrant
- *                        pointer in the argument list of the callback is NULL,
- *                        subsequent pointers are undefined, and the return
- *                        value is ignored.  If coarsen_recursive is true, it
- *                        is possible that a quadrant is called once or more as
- *                        an orphan and eventually becomes part of a family.
- * \param [in] coarsen_fn Callback function that returns true if a
- *                        family of quadrants shall be coarsened.
- * \param [in] init_fn    Callback function to initialize the user_data
- *                        which is already allocated automatically.
- * \param [in] replace_fn Callback function that allows the user to change
- *                        incoming quadrants based on the quadrants they
- *                        replace.
- */
-void                p6est_coarsen_layers_ext (p6est_t * p6est,
-                                              int coarsen_recursive,
-                                              int callback_orphans,
-                                              p6est_coarsen_layer_t
-                                              coarsen_fn,
-                                              p6est_init_t init_fn,
-                                              p6est_replace_t replace_fn);
-
-/** Repartition the forest.
- *
- * The forest is partitioned between processors such that each processor
- * has an approximately equal number of quadrants (or weight).
- *
- * \param [in,out] p6est      The forest that will be partitioned.
- * \param [in]     partition_for_coarsening     If true, the partition
- *                            is modified to allow one level of coarsening.
- * \param [in]     weight_fn  A weighting function or NULL
- *                            for uniform partitioning.
- * \return         The global number of shipped quadrants
- */
-p4est_gloidx_t      p6est_partition_ext (p6est_t * p6est,
-                                         int partition_for_coarsening,
-                                         p6est_weight_t weight_fn);
-
-/** 2:1 balance the size differences of neighboring elements in a forest.
- * \param [in,out] p6est  The p6est to be worked on.
- * \param [in] btype      Balance type (face or corner/full).
- *                        Corner balance is almost never required when
- *                        discretizing a PDE; just causes smoother mesh grading.
- * \param [in] max_diff   The maximum difference between the horizontal
- *                        refinement level and the vertical refinement level
- * \param [in] min_diff   The minimum difference between the horizontal
- *                        refinement level and the vertical refinement level
- * \param [in] init_fn    Callback function to initialize the user_data
- *                        which is already allocated automatically.
- * \param [in] replace_fn Callback function that allows the user to change
- *                        incoming quadrants based on the quadrants they
- *                        replace.
- */
-void                p6est_balance_ext (p6est_t * p6est,
-                                       p8est_connect_type_t btype,
-                                       int max_diff, int min_diff,
-                                       p6est_init_t init_fn,
-                                       p6est_replace_t replace_fn);
-
-SC_EXTERN_C_END;
-
-#endif
diff --git a/OctreeRefinement/include/p6est_ghost.h b/OctreeRefinement/include/p6est_ghost.h
deleted file mode 100644
index b6142c3..0000000
--- a/OctreeRefinement/include/p6est_ghost.h
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P6EST_GHOST_H
-#define P6EST_GHOST_H
-
-/** \file p6est_ghost.h
- *
- * passing columns of layers and data to neighboring processes
- *
- * \ingroup p6est
- */
-
-#include <p6est.h>
-#include <p4est_ghost.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** columns of layers that neighbor the local domain */
-typedef struct p6est_ghost
-{
-  int                 mpisize;
-  p4est_topidx_t      num_trees;
-  p4est_connect_type_t btype; /**< which neighboring columns are in the ghost layer */
-
-  p4est_ghost_t      *column_ghost; /**< describes the ghost columns */
-  sc_array_t         *column_layer_offsets; /**< array of p4est_locidx_t type:
-                                              the offset of each ghost columns
-                                              within the \a ghosts array of
-                                              column-layers */
-
-  /** An array of column-layers which make up the ghost layer around \a
-   * p6est.  Their piggy3 data member is filled with their owner's tree
-   * and local number (cumulative over trees).  Quadrants are ordered in \c
-   * p4est_quadrant_compare_piggy order.  These are quadrants inside the
-   * neighboring tree, i.e., \c p4est_quadrant_is_inside is true for the
-   * quadrant and the neighboring tree.
-   */
-  sc_array_t          ghosts; /**< array of p2est_quadrant_t type */
-  p4est_locidx_t     *tree_offsets;     /**< num_trees + 1 ghost indices */
-  p4est_locidx_t     *proc_offsets;     /**< mpisize + 1 ghost indices */
-
-  /** An array of local quadrants that touch the parallel boundary from the
-   * inside, i.e., that are ghosts in the perspective of at least one other
-   * processor.  The storage convention is the same as for \c ghosts above.
-   */
-  sc_array_t          mirrors; /**< array of p4est_quadrant_t type */
-  p4est_locidx_t     *mirror_tree_offsets;      /**< num_trees + 1 mirror indices */
-  p4est_locidx_t     *mirror_proc_mirrors;      /**< indices into mirrors grouped by
-                                                   outside processor rank and
-                                                   ascending within each rank */
-  p4est_locidx_t     *mirror_proc_offsets;      /**< mpisize + 1 indices into 
-                                                   mirror_proc_mirrors */
-
-  p4est_locidx_t     *mirror_proc_fronts;       /**< like mirror_proc_mirrors,
-                                                   but limited to the
-                                                   outermost octants.  This is
-                                                   NULL until
-                                                   p4est_ghost_expand is
-                                                   called */
-  p4est_locidx_t     *mirror_proc_front_offsets;        /**< NULL until
-                                                           p4est_ghost_expand is
-                                                           called */
-
-}
-p6est_ghost_t;
-
-/** Calculate the memory usage of the ghost layer.
- * \param [in] ghost    Ghost layer structure.
- * \return              Memory used in bytes.
- */
-size_t              p6est_ghost_memory_used (p6est_ghost_t * ghost);
-
-/** Builds the ghost layer.
- *
- * This will gather the quadrants from each neighboring proc to build
- * one layer of face and corner based ghost elements around the ones they own.
- *
- * \param [in] p4est            The forest for which the ghost layer will be
- *                              generated.
- * \param [in] btype            Which ghosts to include (across face, corner
- *                              or default, full).
- * \return                      A fully initialized ghost layer.
- */
-p6est_ghost_t      *p6est_ghost_new (p6est_t * p4est,
-                                     p4est_connect_type_t btype);
-
-/** Expand the size of the ghost layer and mirrors by one additional layer of
- * adjacency.
- * \param [in] p6est            The forest from which the ghost layer was
- *                              generated.
- * \param [in,out] ghost        The ghost layer to be expanded.
- */
-void                p6est_ghost_expand (p6est_t * p6est,
-                                        p6est_ghost_t * ghost);
-
-/** Frees all memory used for the ghost layer. */
-void                p6est_ghost_destroy (p6est_ghost_t * ghost);
-
-/** Conduct binary search for exact match on a range of the ghost layer.
- * \param [in] ghost            The ghost layer.
- * \param [in] which_proc       The owner of the searched quadrant.  Can be -1.
- * \param [in] which_tree       The tree of the searched quadrant.  Can be -1.
- * \param [in] q                Valid quadrant is searched in the ghost layer.
- * \return                      Offset in the ghost layer, or -1 if not found.
- */
-ssize_t             p6est_ghost_bsearch (p6est_ghost_t * ghost,
-                                         int which_proc,
-                                         p4est_topidx_t which_tree,
-                                         const p4est_quadrant_t * column,
-                                         const p2est_quadrant_t * layer);
-
-/** Conduct binary search for ancestor on range of the ghost layer.
- * \param [in] ghost            The ghost layer.
- * \param [in] which_proc       The owner of the searched quadrant.  Can be -1.
- * \param [in] which_tree       The tree of the searched quadrant.  Can be -1.
- * \param [in] q                Valid quadrant's ancestor is searched.
- * \return                      Offset in the ghost layer, or -1 if not found.
- */
-ssize_t             p6est_ghost_contains (p6est_ghost_t * ghost,
-                                          int which_proc,
-                                          p4est_topidx_t which_tree,
-                                          const p4est_quadrant_t * column,
-                                          const p2est_quadrant_t * layer);
-
-/** Checks if layer exists in the local forest or the ghost layer.
- *
- * For quadrants across tree corners it checks if the quadrant exists
- * in any of the corner neighbors, thus it can execute multiple queries.
- *
- * \param [in]  p4est        The forest in which to search for \a q
- * \param [in]  ghost        The ghost layer in which to search for \a q
- * \param [in]  treeid       The tree to which \a q belongs (can be extended).
- * \param [in]  column       The column that is being searched for.
- * \param [in]  layer        The layer that is being searched for.
- * \param [in,out] exists_arr Must exist and be of of elem_size = sizeof (int)
- *                           for inter-tree corner cases.  Is resized by this
- *                           function to one entry for each corner search
- *                           and set to true/false depending on its existence
- *                           in the local forest or ghost_layer.
- * \param [in,out] rproc_arr If not NULL is filled with one rank per query.
- * \param [in,out] rquad_arr If not NULL is filled with one quadrant per query.
- *                           Its piggy3 member is defined as well.
- *
- * \return true if the quadrant exists in the local forest or in the
- *                  ghost_layer, and false if doesn't exist in either.
- */
-int                 p6est_layer_exists (p6est_t * p6est,
-                                        p6est_ghost_t * ghost,
-                                        p4est_topidx_t treeid,
-                                        const p4est_quadrant_t * column,
-                                        const p2est_quadrant_t * layer,
-                                        sc_array_t * exists_arr,
-                                        sc_array_t * rproc_arr,
-                                        sc_array_t * rquad_arr);
-
-/** Check a forest to see if it is balanced.
- *
- * This function builds the ghost layer and discards it when done.
- *
- * \param [in] p4est    The p4est to be tested.
- * \param [in] btype    Balance type (face, corner or default, full).
- * \return Returns true if balanced, false otherwise.
- */
-int                 p6est_is_balanced (p6est_t * p6est,
-                                       p8est_connect_type_t btype);
-
-/** Compute the parallel checksum of a ghost layer.
- * \param [in] p4est   The MPI information of this p4est will be used.
- * \param [in] ghost   A ghost layer obtained from the p4est.
- * \return             Parallel checksum on rank 0, 0 otherwise.
- */
-unsigned            p6est_ghost_checksum (p6est_t * p6est,
-                                          p6est_ghost_t * ghost);
-
-SC_EXTERN_C_END;
-
-#endif /* P6EST_GHOST_H */
diff --git a/OctreeRefinement/include/p6est_lnodes.h b/OctreeRefinement/include/p6est_lnodes.h
deleted file mode 100644
index bd6bfd7..0000000
--- a/OctreeRefinement/include/p6est_lnodes.h
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P6EST_LNODES_H
-#define P6EST_LNODES_H
-
-#include <p6est.h>
-#include <p6est_ghost.h>
-#include <p4est_lnodes.h>
-#include <p8est_lnodes.h>
-
-SC_EXTERN_C_BEGIN;
-
-/* A p6est_lnodes_t is exactly the same as a p8est_lnodes_t, with the only
- * difference being that the face_codes are interpreted differently to account
- * for the types of hanging faces that occur in a p6est.  Please see the
- * documentation for p8est_lnodes */
-
-/* The only other differece is in the numbering of nodes and the number of
- * faces.
- *
- * Columns of nodes are numbered contiguously: this still generates a
- * partition-unique numbering.
- *
- * Although we call a p2est_quadrant_t coordinate layer->z, the orientaton of
- * a layer from lnodes perspective is that the vertical axis is the X axis of
- * the 3D element, the x axis of the columns is the Y axis of the 3D element,
- * and the y axis of the columns is the Z axis of the 3D element
- */
-
-typedef p8est_lnodes_t p6est_lnodes_t;
-typedef p8est_lnodes_code_t p6est_lnodes_code_t;
-typedef p8est_lnodes_rank_t p6est_lnodes_rank_t;
-typedef p8est_lnodes_buffer_t p6est_lnodes_buffer_t;
-
-/** Decode the face_code into hanging face information.
- *
- * \param[in] face_code as in the p6est_lnodes_t structure.
- * \param[out] hanging_face: if there are hanging faces or edges,
- *             hanging_face = -1 if the face is not hanging,
- *                          = the corner of the full face that it touches:
- *                            e.g. if face = i and hanging_face[i] =
- *                            j, then the interpolation operator corresponding
- *                            to corner j should be used for that face.
- *             note: not touched if there are no hanging faces or edges.
- * \param[out] hanging_edge: if there are hanging faces or edges,
- *             hanging_edge = -1 if the edge is not hanging,
- *                          =  0 if the edge is the first half of a full edge,
- *                               but neither of the two faces touching the
- *                               edge is hanging,
- *                          =  1 if the edge is the second half of a full edge,
- *                               but neither of the two faces touching the
- *                               edge is hanging,
- *                          =  2 if the edge is the first half of a full edge
- *                               and is on the boundary of a full face,
- *                          =  3 if the edge is the second half of a full edge
- *                               and is on the boundary of a full face,
- *                          =  4 if the edge is in the middle of a full face.
- *                               See the diagram below for clarification.
- *             note: not touched if there are no hanging faces or edges.
- * \return             true if any face or edge is hanging, false otherwise.
- *
- * o...............o  o...............o  +---2---+.......o  o.......+---3---+
- * :               :  :               :  |       |       :  :       |       |
- * :               :  :               :  3   2   4       :  :       4   3   3
- * :               :  :               :  |       |       :  :       |       |
- * +---4---+       :  :       +---4---+  +---4---+       :  :       +---4---+
- * |       |       :  :       |       |  :               :  :               :
- * 2   0   4       :  :       4   1   2  :               :  :               :
- * |       |       :  :       |       |  :               :  :               :
- * +---2---+.......o  o.......+---3---+  o...............o  o...............o
- *
- * o...............o  +-----(-1)------+  +---2---+.......o  o.......+---3---+
- * :               :  |               |  |       |       :  :       |       |
- * :               :  3       5       3  |       |       :  :       |       |
- * :               :  |               |  |       |       :  :       |       |
- * +-------4-------+  +-------4-------+ -1   6   4       :  :       4   7  -1
- * |               |  :               :  |       |       :  :       |       |
- * 2       4       2  :               :  |       |       :  :       |       |
- * |               |  :               :  |       |       :  :       |       |
- * +-----(-1)------+  o...............o  +---2---+.......o  o.......+---3---+
- *
- *                    o                  +-------+
- *                    :                  |\       \
- *                    :                  1 \       \
- *                    :                  |  +-------+
- *                    +-------+          +  |       |
- *                    |\       \         :\ |       |
- *                    0 \       \        : \|       |
- *                    |  +-------+       :  +-------+
- *                    +  |       |       o
- *                     \ |       |
- *                      \|       |
- *                       +-------+
- */
-/*@unused@*/
-static inline int
-p6est_lnodes_decode (p6est_lnodes_code_t face_code, int hanging_face[6],
-                     int hanging_edge[12])
-{
-  P4EST_ASSERT (face_code >= 0);
-
-  if (face_code) {
-    /* we pack the p4est_lnodes_code_t at the bottom, followed by a bit
-     * indicating whether this layer is a first or second sibling, followed by
-     * four bits indicating which of the four side faces are layerwise
-     * nonconforming, followed by four bits indicating which of the four side
-     * edges are layerwise nonconforming */
-    p4est_lnodes_code_t fc4 = face_code & 0x000f;
-    int16_t             h = (face_code & 0x0010) >> 4;
-    int16_t             work = face_code >> 5;
-    int                 hf;
-    int                 f, e, w;
-
-    memset (hanging_face, -1, 6 * sizeof (int));
-    memset (hanging_edge, -1, 12 * sizeof (int));
-
-    /* the first two faces are the top and bottom faces, which we know are not
-     * hanging */
-    p4est_lnodes_decode (fc4, hanging_face + 2);
-    for (f = 0; f < 4; f++) {
-      hf = hanging_face[f + 2];
-      w = work & 0x0001;
-      if (hf >= 0) {
-        hanging_edge[p8est_face_edges[f + 2][2]] = 2 + hf;
-        hanging_edge[p8est_face_edges[f + 2][3]] = 2 + hf;
-        hanging_edge[p8est_face_edges[f + 2][1 ^ hf]] = 4;
-        if (w) {
-          hanging_edge[p8est_face_edges[f + 2][3 ^ h]] = 4;
-          hanging_edge[p8est_face_edges[f + 2][1 ^ hf]] = 4;
-          hanging_edge[p8est_face_edges[f + 2][hf]] = 2 + h;
-          hanging_face[f + 2] = (hf << 1) | h;
-        }
-        else {
-          hanging_face[f + 2] = 4 + hf;
-        }
-      }
-      else if (w) {
-        hanging_edge[p8est_face_edges[f + 2][3 ^ h]] = 4;
-        hanging_edge[p8est_face_edges[f + 2][0]] =
-          SC_MAX (hanging_edge[p8est_face_edges[f + 2][0]], 2 + h);
-        hanging_edge[p8est_face_edges[f + 2][1]] =
-          SC_MAX (hanging_edge[p8est_face_edges[f + 2][1]], 2 + h);
-        hanging_face[f + 2] = 6 + h;
-      }
-      work >>= 1;
-    }
-    for (e = 0; e < 4; e++) {
-      if (work & 0x0001) {
-        if (hanging_edge[e] < 0) {
-          hanging_edge[e] = h;
-        }
-#ifdef P4EST_ENABLE_DEBUG
-        else {
-          P4EST_ASSERT (hanging_edge[e] == 2 + h || hanging_edge[e] == 4);
-        }
-#endif
-      }
-      work >>= 1;
-    }
-    return 1;
-  }
-  else {
-    return 0;
-  }
-}
-
-p6est_lnodes_t     *p6est_lnodes_new (p6est_t * p6est,
-                                      p6est_ghost_t * ghost_layer,
-                                      int degree);
-
-static inline void
-p6est_lnodes_destroy (p6est_lnodes_t * lnodes)
-{
-  p8est_lnodes_destroy (lnodes);
-}
-
-/*@unused@*/
-static inline p6est_lnodes_buffer_t *
-p6est_lnodes_share_owned_begin (sc_array_t * node_data,
-                                p6est_lnodes_t * lnodes)
-{
-  return p8est_lnodes_share_owned_begin (node_data, lnodes);
-}
-
-/*@unused@*/
-static inline void
-p6est_lnodes_share_owned_end (p6est_lnodes_buffer_t * buffer)
-{
-  p8est_lnodes_share_owned_end (buffer);
-}
-
-/*@unused@*/
-static inline void
-p6est_lnodes_share_owned (sc_array_t * node_data, p6est_lnodes_t * lnodes)
-{
-  p8est_lnodes_share_owned (node_data, lnodes);
-}
-
-/*@unused@*/
-static inline p6est_lnodes_buffer_t *
-p6est_lnodes_share_all_begin (sc_array_t * node_data, p6est_lnodes_t * lnodes)
-{
-  return p8est_lnodes_share_all_begin (node_data, lnodes);
-}
-
-/*@unused@*/
-static inline void
-p6est_lnodes_share_all_end (p6est_lnodes_buffer_t * buffer)
-{
-  p8est_lnodes_share_all_end (buffer);
-}
-
-/*@unused@*/
-static inline p6est_lnodes_buffer_t *
-p6est_lnodes_share_all (sc_array_t * node_data, p6est_lnodes_t * lnodes)
-{
-  return p8est_lnodes_share_all (node_data, lnodes);
-}
-
-/*@unused@*/
-static inline void
-p6est_lnodes_buffer_destroy (p6est_lnodes_buffer_t * buffer)
-{
-  p8est_lnodes_buffer_destroy (buffer);
-}
-
-/*@unused@*/
-static inline p6est_lnodes_rank_t *
-p6est_lnodes_rank_array_index_int (sc_array_t * array, int it)
-{
-  return p8est_lnodes_rank_array_index_int (array, it);
-}
-
-/*@unused@*/
-static inline p6est_lnodes_rank_t *
-p6est_lnodes_rank_array_index (sc_array_t * array, size_t it)
-{
-  return p8est_lnodes_rank_array_index (array, it);
-}
-
-/*@unused@*/
-static inline       p4est_gloidx_t
-p6est_lnodes_global_index (p6est_lnodes_t * lnodes, p4est_locidx_t lidx)
-{
-  return p8est_lnodes_global_index (lnodes, lidx);
-}
-
-/** For each owned node, get the global 2D number for the node-column
- * containing it.
- *
- * \param[in] p6est  The forest
- * \param[in] lnodes The nodes
- * \return an array of size \a lnodes->owned_count, giving the unique global
- * number of the node-column containing each node.  Should be free'd with
- * P4EST_FREE().
- */
-p4est_gloidx_t     *p6est_lnodes_get_column_labels (p6est_t * p6est,
-                                                    p8est_lnodes_t * lnodes);
-
-SC_EXTERN_C_END;
-
-#endif /* !P6EST_LNODES */
diff --git a/OctreeRefinement/include/p6est_profile.h b/OctreeRefinement/include/p6est_profile.h
deleted file mode 100644
index eb7314e..0000000
--- a/OctreeRefinement/include/p6est_profile.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P6EST_PROFILE_H
-#define P6EST_PROFILE_H
-
-#include <p6est.h>
-#include <p6est_ghost.h>
-#include <p4est_lnodes.h>
-#include <p6est_lnodes.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** A p6est profile is used to (a) balance a p6est, and (b) generate a
- * p6est_lnodes.  In every case, layers in a column are compressed to one
- * int8_t each.  The resulting column profiles and be quickly intersected,
- * unioned and balanced.  We use a p4est_lnodes_t to communicate between
- * neighboring columns, and a p4est_ghost_t to communicate between neighboring
- * processes.
- */
-
-typedef enum
-{
-  P6EST_PROFILE_UNION,
-  P6EST_PROFILE_INTERSECTION
-}
-p6est_profile_type_t;
-
-typedef struct p6est_profile
-{
-  p6est_profile_type_t ptype;
-  p8est_connect_type_t btype;
-  p4est_lnodes_t     *lnodes;
-  p4est_ghost_t      *cghost;
-  int                 ghost_owned;
-  p4est_locidx_t     *lnode_ranges;
-  sc_array_t         *lnode_columns;
-  int                *lnode_changed[2];
-  p4est_locidx_t     *enode_counts;
-  int                 evenodd;
-  p4est_qcoord_t      diff;
-}
-p6est_profile_t;
-
-/** Create a new profile.
- * \param[in] p6est
- * \param[in] ghost optional, can be NULL
- * \param[in] ptype P6EST_PROFILE_UNION if we are balancing,
- *                  P6EST_PROFILE_INTERSECTION if we are generating lnodes
- * \param[in] btype Type of 3D balance law desired.
- * \param[in] degree degree of underlying lnodes, should be 2 if used for
- *                   balancing
- */
-
-p6est_profile_t    *p6est_profile_new_local (p6est_t * p6est,
-                                             p6est_ghost_t * ghost,
-                                             p6est_profile_type_t ptype,
-                                             p8est_connect_type_t btype,
-                                             int degree);
-
-/** Destroy a profile */
-void                p6est_profile_destroy (p6est_profile_t * profile);
-
-/** Enforce balance between the column profiles locally: no communication */
-void                p6est_profile_balance_local (p6est_profile_t * profile);
-
-/** Synchronize the data from other processors, taking unions or
- * intersections, as determined at profile creation in \a
- * p6est_profile_new_local
- *
- * \return whether any change has occured.
- * */
-int                 p6est_profile_sync (p6est_profile_t * profile);
-
-/** modify a p6est, whose columns match the column profiles, to match the
- * column profiles */
-void                p6est_refine_to_profile (p6est_t * p6est,
-                                             p6est_profile_t * profile,
-                                             p6est_init_t init_fn,
-                                             p6est_replace_t replace_fn);
-
-void                p6est_profile_element_to_node (p6est_t * p6est,
-                                                   p6est_profile_t * profile,
-                                                   p4est_locidx_t * offsets,
-                                                   p4est_locidx_t *
-                                                   elem_to_node,
-                                                   p6est_lnodes_code_t * fc);
-
-SC_EXTERN_C_END;
-
-#endif /* !P6EST_PROFILE_H */
diff --git a/OctreeRefinement/include/p6est_vtk.h b/OctreeRefinement/include/p6est_vtk.h
deleted file mode 100644
index 234d617..0000000
--- a/OctreeRefinement/include/p6est_vtk.h
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P6EST_VTK_H
-#define P6EST_VTK_H
-
-#include <p6est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** This writes out the p6est in VTK format.
- *
- * This is a convenience function for the special
- * case of writing out the tree id and MPI rank only.
- * One file is written per MPI rank, and one meta file on rank 0.
- * This function will abort if there is a file error.
- *
- * \param [in] p6est    The p6est to be written.
- * \param [in] filename The first part of the file name which will have the
- *                      MPI rank appended to it: The output file will be
- *                      filename_rank.vtu, and the meta file filename.pvtu).
- */
-void                p6est_vtk_write_file (p6est_t * p6est,
-                                          const char *filename);
-
-/** This writes out the p6est and any number of point fields in VTK format.
- *
- * This is a convenience function that will abort if there is a file error.
- *
- * \param [in] p6est    The p6est to be written.
- * \param [in] scale    Double value between 0 and 1 to scale each quadrant.
- * \param [in] write_tree   Include the tree id as output field.
- * \param [in] write_rank   Include the MPI rank as output field.
- * \param [in] wrap_tree    The MPI rank is written module wrap_tree, or 0.
- * \param filename      First part of the name, see p6est_vtk_write_file.
- * \param num_scalars   Number of scalar fields to write.
- * \param num_vectors   Number of vector fields to write.
- *
- * The variable arguments need to be pairs of (fieldname, fieldvalues)
- * where the scalars come first, then the vectors.
- */
-void                p6est_vtk_write_all (p6est_t * p6est,
-                                         double scale, int write_tree,
-                                         int write_rank, int wrap_rank,
-                                         int num_scalars, int num_vectors,
-                                         const char *filename, ...);
-
-/** This will write the header of the vtu file.
- *
- * Writing a VTK file is split into a couple of routines.
- * The allows there to be an arbitrary number of
- * fields.  The calling sequence would be something like
- *
- * \begincode
- * p6est_vtk_write_header(p6est, 1., 1, 1, 0, "output");
- * p6est_vtk_write_point_scalar (...);
- * ...
- * p6est_vtk_write_footer(p6est, "output");
- * \endcode
- *
- * \param p6est     The p6est to be written.
- * \param scale     The relative length factor of the quadrants.
- *                  Use 1.0 to fit quadrants exactly, less to create gaps.
- * \param write_tree    Boolean to determine if the tree id should be output.
- * \param write_rank    Boolean to determine if the MPI rank should be output.
- * \param wrap_rank Number to wrap around the rank with a modulo operation.
- *                  Can be 0 for no wrapping.
- * \param point_scalars  Comma-separated list of point scalar fields, or NULL.
- * \param point_vectors  Comma-separated list of point vector fields, or NULL.
- * \param filename  The first part of the name which will have
- *                  the proc number appended to it (i.e., the
- *                  output file will be filename_procNum.vtu).
- *
- * \return          This returns 0 if no error and -1 if there is an error.
- */
-int                 p6est_vtk_write_header (p6est_t * p6est,
-                                            double scale, int write_tree,
-                                            int write_rank, int wrap_rank,
-                                            const char *point_scalars,
-                                            const char *point_vectors,
-                                            const char *filename);
-
-/** This will write a scalar field to the vtu file.
- *
- * It is good practice to make sure that the scalar field also
- * exists in the comma separated string \a point_scalars passed
- * to \c p4est_vtk_write_header.
- *
- * Writing a VTK file is split into a couple of routines.
- * The allows there to be an arbitrary number of fields.
- *
- * \param p6est     The p6est to be written.
- * \param filename  The first part of the name which will have
- *                  the proc number appended to it (i.e., the
- *                  output file will be filename_procNum.vtu).
- * \param scalar_name The name of the scalar field.
- * \param values    The point values that will be written.
- *
- * \return          This returns 0 if no error and -1 if there is an error.
- */
-int                 p6est_vtk_write_point_scalar (p6est_t * p6est,
-                                                  const char *filename,
-                                                  const char *scalar_name,
-                                                  const double *values);
-
-/** This will write a 3-vector field to the vtu file.
- *
- * It is good practice to make sure that the vector field also
- * exists in the comma separated string \a point_vectors passed
- * to \c p6est_vtk_write_header.
- *
- * Writing a VTK file is split into a couple of routines.
- * The allows there to be an arbitrary number of fields.
- *
- * \param p6est     The p6est to be written.
- * \param filename  The first part of the name which will have
- *                  the proc number appended to it (i.e., the
- *                  output file will be filename_procNum.vtu).
- * \param vector_name The name of the vector field.
- * \param values    The point values that will be written.
- *
- * \return          This returns 0 if no error and -1 if there is an error.
- */
-int                 p6est_vtk_write_point_vector (p6est_t * p6est,
-                                                  const char *filename,
-                                                  const char *vector_name,
-                                                  const double *values);
-
-/** This will write the footer of the vtu file.
- *
- * Writing a VTK file is split into a couple of routines.
- * The allows there to be an arbitrary number of
- * fields.  To write out two fields the
- * calling sequence would be something like
- *
- * \begincode
- * p6est_vtk_write_header(p6est, ..., "output");
- * p6est_vtk_write_footer(p6est, "output");
- * \endcode
- *
- * \param p6est     The p6est to be written.
- * \param filename  The first part of the name which will have
- *                  the proc number appended to it (i.e., the
- *                  output file will be filename_procNum.vtu).
- *
- * \return          This returns 0 if no error and -1 if there is an error.
- */
-int                 p6est_vtk_write_footer (p6est_t * p6est,
-                                            const char *filename);
-
-SC_EXTERN_C_END;
-
-#endif /* P6EST_VTK_H */
diff --git a/OctreeRefinement/include/p8est.h b/OctreeRefinement/include/p8est.h
deleted file mode 100644
index 0dd145f..0000000
--- a/OctreeRefinement/include/p8est.h
+++ /dev/null
@@ -1,495 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p8est.h
- *
- * The top-level 3D p8est interface.
- *
- * \ingroup p8est
- */
-
-/** \defgroup p8est p8est
- *
- * The 3D version of the p4est library.
- */
-
-#ifndef P8EST_H
-#define P8EST_H
-
-/* p8est_connectivity.h includes p4est_base.h sc_containers.h */
-#include <p8est_connectivity.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** The finest level of the octree for representing nodes */
-#define P8EST_MAXLEVEL 19
-
-/** The finest level of the octree for representing octants */
-#define P8EST_QMAXLEVEL 18
-
-/** The length of a side of the root quadrant */
-#define P8EST_ROOT_LEN ((p4est_qcoord_t) 1 << P8EST_MAXLEVEL)
-
-/** The length of a quadrant of level l */
-#define P8EST_QUADRANT_LEN(l) ((p4est_qcoord_t) 1 << (P8EST_MAXLEVEL - (l)))
-
-/** The offset of the highest (farthest from the origin) quadrant at level l
- */
-#define P8EST_LAST_OFFSET(l) (P8EST_ROOT_LEN - P8EST_QUADRANT_LEN (l))
-
-/** The 3D quadrant (i.e., octant) datatype */
-typedef struct p8est_quadrant
-{
-  /*@{ */
-  p4est_qcoord_t      x, y, z;  /**< coordinates */
-  /*@} */
-  int8_t              level,    /**< level of refinement */
-                      pad8;     /**< padding */
-  int16_t             pad16;    /**< padding */
-  union p8est_quadrant_data
-  {
-    void               *user_data;      /**< never changed by p4est */
-    long                user_long;      /**< never changed by p4est */
-    int                 user_int;       /**< never changed by p4est */
-    p4est_topidx_t      which_tree;     /**< the tree containing the quadrant
-                                             (used in auxiliary octants such
-                                             as the ghost octants in
-                                             p4est_ghost_t) */
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      int                 owner_rank;
-    }
-    piggy1; /**< of ghost octants, store the tree and owner rank */
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_topidx_t      from_tree;
-    }
-    piggy2; /**< of transformed octants, store the original tree and the
-                 target tree */
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_locidx_t      local_num;
-    }
-    piggy3; /**< of ghost octants, store the tree and index in the owner's
-                 numbering */
-  }
-  p; /**< a union of additional data attached to a quadrant */
-}
-p8est_quadrant_t;
-
-/** The p8est tree datatype */
-typedef struct p8est_tree
-{
-  sc_array_t          quadrants;             /**< locally stored quadrants */
-  p8est_quadrant_t    first_desc,            /**< first local descendant */
-                      last_desc;             /**< last local descendant */
-  p4est_locidx_t      quadrants_offset;      /**< cumulative sum over earlier
-                                                  trees on this processor
-                                                  (locals only) */
-  p4est_locidx_t      quadrants_per_level[P8EST_MAXLEVEL + 1];
-                                             /**< locals only */
-  int8_t              maxlevel;              /**< highest local quadrant level */
-}
-p8est_tree_t;
-
-/** Data pertaining to selecting, inspecting, and profiling algorithms.
- * A pointer to this structure is hooked into the p8est main structure.
- * Declared in p8est_extended.h.  Used to profile important algorithms.
- */
-typedef struct p8est_inspect p8est_inspect_t;
-
-/** The p8est forest datatype */
-typedef struct p8est
-{
-  sc_MPI_Comm         mpicomm;          /**< MPI communicator */
-  int                 mpisize,          /**< number of MPI processes */
-                      mpirank;          /**< this process's MPI rank */
-  int                 mpicomm_owned;    /**< flag if communicator is owned */
-  size_t              data_size;        /**< size of per-quadrant p.user_data
-                     (see p8est_quadrant_t::p8est_quadrant_data::user_data) */
-  void               *user_pointer;     /**< convenience pointer for users,
-                                             never touched by p4est */
-
-  long                revision;         /**< Gets bumped on mesh change */
-  p4est_topidx_t      first_local_tree; /**< 0-based index of first local
-                                             tree, must be -1 for an empty
-                                             processor */
-  p4est_topidx_t      last_local_tree;  /**< 0-based index of last local
-                                             tree, must be -2 for an empty
-                                             processor */
-  p4est_locidx_t      local_num_quadrants;   /**< number of quadrants on all
-                                                  trees on this processor */
-  p4est_gloidx_t      global_num_quadrants;  /**< number of quadrants on all
-                                                  trees on all processors */
-  p4est_gloidx_t     *global_first_quadrant; /**< first global quadrant index
-                                                  for each process and 1
-                                                  beyond */
-  p8est_quadrant_t   *global_first_position; /**< first smallest possible quad
-                                                  for each process and 1
-                                                  beyond */
-  p8est_connectivity_t *connectivity; /**< connectivity structure, not owned */
-  sc_array_t         *trees;          /**< array of all trees */
-
-  sc_mempool_t       *user_data_pool; /**< memory allocator for user data */
-  /*   WARNING: This is NULL if data size
-     equals zero. */
-  sc_mempool_t       *quadrant_pool;  /**< memory allocator for temporary
-                                           quadrants */
-  p8est_inspect_t    *inspect;        /**< algorithmic switches */
-}
-p8est_t;
-
-/** Calculate local memory usage of a forest structure.
- * Not collective.  The memory used on the current rank is returned.
- * The connectivity structure is not counted since it is not owned;
- * use p8est_connectivity_memory_usage (p8est->connectivity).
- * \param [in] p8est    Valid forest structure.
- * \return              Memory used in bytes.
- */
-size_t              p8est_memory_used (p8est_t * p8est);
-
-/** Return the revision counter of the forest.
- * Not collective, even though the revision value is the same on all ranks.
- * A newly created forest starts with a revision counter of zero.
- * Every refine, coarsen, partition, and balance that actually changes the mesh
- * increases the counter by one.  Operations with no effect keep the old value.
- * \param [in] p8est    The forest must be valid.
- * \return              Non-negative number.
- */
-long                p8est_revision (p8est_t * p8est);
-
-/** Callback function prototype to initialize the quadrant's user data.
- * \param [in] p8est         the forest
- * \param [in] which_tree    the tree containing \a quadrant
- * \param [in,out] quadrant  the quadrant to be initialized: if data_size > 0,
- *                           the data to be initialized is at
- *                           \a quadrant->p.user_data; otherwise, the
- *                           non-pointer user data (such as
- *                           \a quadrant->p.user_int) can be initialized
- */
-typedef void        (*p8est_init_t) (p8est_t * p8est,
-                                     p4est_topidx_t which_tree,
-                                     p8est_quadrant_t * quadrant);
-
-/** Callback function prototype to decide for refinement.
- * \param [in] p8est       the forest
- * \param [in] which_tree  the tree containing \a quadrant
- * \param [in] quadrant    the quadrant that may be refined
- * \return nonzero if the quadrant shall be refined.
- */
-typedef int         (*p8est_refine_t) (p8est_t * p8est,
-                                       p4est_topidx_t which_tree,
-                                       p8est_quadrant_t * quadrant);
-
-/** Callback function prototype to decide for coarsening.
- * \param [in] p8est       the forest
- * \param [in] which_tree  the tree containing \a quadrant
- * \param [in] quadrants   Pointers to 8 siblings in Morton ordering.
- * \return nonzero if the quadrants shall be replaced with their parent.
- */
-typedef int         (*p8est_coarsen_t) (p8est_t * p8est,
-                                        p4est_topidx_t which_tree,
-                                        p8est_quadrant_t * quadrants[]);
-
-/** Callback function prototype to calculate weights for partitioning.
- * \param [in] p8est       the forest
- * \param [in] which_tree  the tree containing \a quadrant
- * \return a 32bit integer >= 0 as the quadrant weight.
- * \note    Global sum of weights must fit into a 64bit integer.
- */
-typedef int         (*p8est_weight_t) (p8est_t * p8est,
-                                       p4est_topidx_t which_tree,
-                                       p8est_quadrant_t * quadrant);
-
-extern void        *P8EST_DATA_UNINITIALIZED;
-
-/** set statically allocated quadrant to defined values */
-#define P8EST_QUADRANT_INIT(q) \
-  ((void) memset ((q), -1, sizeof (p8est_quadrant_t)))
-
-/** Transform a quadrant coordinate into the space spanned by tree vertices.
- * \param [in] connectivity     Connectivity must provide the vertices.
- * \param [in] treeid           Identify the tree that contains x, y, z.
- * \param [in] x, y, z          Quadrant coordinates relative to treeid.
- * \param [out] vxyz            Transformed coordinates in vertex space.
- */
-void                p8est_qcoord_to_vertex (p8est_connectivity_t *
-                                            connectivity,
-                                            p4est_topidx_t treeid,
-                                            p4est_qcoord_t x,
-                                            p4est_qcoord_t y,
-                                            p4est_qcoord_t z, double vxyz[3]);
-
-/** Create a new forest.
- * The new forest consists of equi-partitioned root quadrants.
- * When there are more processors than trees, some processors are empty.
- *
- * \param [in] mpicomm       A valid MPI communicator.
- * \param [in] connectivity  This is the connectivity information that
- *                           the forest is built with.  Note the p8est
- *                           does not take ownership of the memory.
- * \param [in] data_size     This is the size of data for each quadrant which
- *                           can be zero.  Then user_data_pool is set to NULL.
- * \param [in] init_fn       Callback function to initialize the user_data
- *                           which is already allocated automatically.
- * \param [in] user_pointer  Assign to the user_pointer member of the p8est
- *                           before init_fn is called the first time.
- *
- * \return This returns a valid forest.
- *
- * \note The connectivity structure must not be destroyed
- *       during the lifetime of this forest.
- */
-p8est_t            *p8est_new (sc_MPI_Comm mpicomm,
-                               p8est_connectivity_t * connectivity,
-                               size_t data_size,
-                               p8est_init_t init_fn, void *user_pointer);
-
-/** Destroy a p8est.
- *
- * \note The connectivity structure is not destroyed with the p8est.
- */
-void                p8est_destroy (p8est_t * p8est);
-
-/** Make a deep copy of a p8est.
- * The connectivity is not duplicated.
- * Copying of quadrant user data is optional.
- * If old and new data sizes are 0, the user_data field is copied regardless.
- * The inspect member of the copy is set to NULL.
- * The revision counter of the copy is set to zero.
- *
- * \param [in]  copy_data  If true, data are copied.
- *                         If false, data_size is set to 0.
- * \return  Returns a valid p8est that does not depend on the input,
- *                         except for borrowing the same connectivity.
- *                         Its revision counter is 0.
- */
-p8est_t            *p8est_copy (p8est_t * input, int copy_data);
-
-/** Reset user pointer and element data.
- * When the data size is changed the quadrant data is freed and allocated.
- * The initialization callback is invoked on each quadrant.
- * Old user_data content is disregarded.
- *
- * \param [in] data_size     This is the size of data for each quadrant which
- *                           can be zero.  Then user_data_pool is set to NULL.
- * \param [in] init_fn       Callback function to initialize the user_data
- *                           which is already allocated automatically.
- *                           May be NULL.
- * \param [in] user_pointer  Assign to the user_pointer member of the p8est
- *                           before init_fn is called the first time.
- */
-void                p8est_reset_data (p8est_t * p8est, size_t data_size,
-                                      p8est_init_t init_fn,
-                                      void *user_pointer);
-
-/** Refine a forest.
- * \param [in,out] p8est The forest is changed in place.
- * \param [in] refine_recursive Boolean to decide on recursive refinement.
- * \param [in] refine_fn Callback function that must return true if a quadrant
- *                       shall be refined.  If refine_recursive is true,
- *                       refine_fn is called for every existing and newly
- *                       created quadrant.  Otherwise, it is called for every
- *                       existing quadrant.  It is possible that a refinement
- *                       request made by the callback is ignored.  To catch
- *                       this case, you can examine whether init_fn gets
- *                       called, or use p8est_refine_ext in p8est_extended.h
- *                       and examine whether replace_fn gets called.
- * \param [in] init_fn   Callback function to initialize the user_data of newly
- *                       created quadrants, which is already allocated.  This
- *                       function pointer may be NULL.
- */
-void                p8est_refine (p8est_t * p8est,
-                                  int refine_recursive,
-                                  p8est_refine_t refine_fn,
-                                  p8est_init_t init_fn);
-
-/** Coarsen a forest.
- * \param [in,out] p8est  The forest is changed in place.
- * \param [in] coarsen_recursive Boolean to decide on recursive coarsening.
- * \param [in] coarsen_fn Callback function that returns true if a
- *                        family of quadrants shall be coarsened
- * \param [in] init_fn    Callback function to initialize the user_data
- *                        which is already allocated automatically.
- */
-void                p8est_coarsen (p8est_t * p8est,
-                                   int coarsen_recursive,
-                                   p8est_coarsen_t coarsen_fn,
-                                   p8est_init_t init_fn);
-
-/** 2:1 balance the size differences of neighboring elements in a forest.
- * \param [in,out] p8est  The p8est to be worked on.
- * \param [in] btype      Balance type (face, edge, or corner/full).  Examples:
- *                        Finite volume or discontinuous Galerkin methods only
- *                        require face balance.  Continuous finite element
- *                        methods usually require edge balance.  Corner balance
- *                        is almost never required mathematically; it just
- *                        produces a smoother mesh grading.
- * \param [in] init_fn    Callback function to initialize the user_data
- *                        which is already allocated automatically.
- */
-void                p8est_balance (p8est_t * p8est,
-                                   p8est_connect_type_t btype,
-                                   p8est_init_t init_fn);
-
-/** Equally partition the forest.
- * The partition can be by element count or by a user-defined weight.
- *
- * The forest will be partitioned between processors such that they
- * have an approximately equal number of quadrants (or sum of weights).
- *
- * \param [in,out] p8est      The forest that will be partitioned.
- * \param [in]     allow_for_coarsening Slightly modify partition such that
- *                            quadrant families are not split between ranks.
- * \param [in]     weight_fn  A weighting function or NULL
- *                            for uniform partitioning.
- */
-void                p8est_partition (p8est_t * p8est,
-                                     int allow_for_coarsening,
-                                     p8est_weight_t weight_fn);
-
-/** Compute the checksum for a forest.
- * Based on quadrant arrays only. It is independent of partition and mpisize.
- * \return  Returns the checksum on processor 0 only. 0 on other processors.
- */
-unsigned            p8est_checksum (p8est_t * p8est);
-
-/** Save the complete connectivity/p8est data to disk.
- *
- * This is a collective operation that all MPI processes need to call.  All
- * processes write into the same file, so the filename given needs to be
- * identical over all parallel invocations.
- *
- * By default, we write the current processor count and partition into the file
- * header.  This makes the file depend on mpisize.  For changing this see
- * p8est_save_ext() in p8est_extended.h.
- *
- * The revision counter is not saved to the file, since that would make files
- * different that come from different revisions but store the same mesh.
- *
- * \param [in] filename    Name of the file to write.
- * \param [in] p8est       Valid forest structure.
- * \param [in] save_data   If true, the element data is saved.
- *                         Otherwise, a data size of 0 is saved.
- * \note            Aborts on file errors.
- * \note            If p4est is not configured to use MPI-IO, some processes
- *                  return from this function before the file is complete, in
- *                  which case immediate read-access to the file may require a
- *                  call to sc_MPI_Barrier.
- */
-void                p8est_save (const char *filename, p8est_t * p8est,
-                                int save_data);
-
-/** Load the complete connectivity/p8est structure from disk.
- *
- * This is a collective operation that all MPI processes need to call.  All
- * processes read from the same file, so the filename given needs to be
- * identical over all parallel invocations.
- *
- * By default, a file can only be loaded with the same number of processors
- * that it was stored with.  The defaults can be changed with p8est_load_ext()
- * in p8est_extended.h.
- *
- * The revision counter of the loaded p4est is set to zero.
- *
- * \param [in] filename         Name of the file to read.
- * \param [in] mpicomm          A valid MPI communicator.
- * \param [in] data_size        Size of data for each quadrant which can be
- *                              zero.  Then user_data_pool is set to NULL.
- *                              If data_size is zero, load_data is ignored.
- * \param [in] load_data        If true, the element data is loaded.  This is
- *                              only permitted if the saved data size matches.
- *                              If false, the stored data size is ignored.
- * \param [in] user_pointer     Assign to the user_pointer member of the p8est
- *                              before init_fn is called the first time.
- * \param [out] connectivity    Connectivity must be destroyed separately.
- * \return          Returns a valid forest structure. A pointer to a valid
- *                  connectivity structure is returned through the last
- *                  argument.
- * \note            Aborts on file errors or invalid file contents.
- */
-p8est_t            *p8est_load (const char *filename, sc_MPI_Comm mpicomm,
-                                size_t data_size, int load_data,
-                                void *user_pointer,
-                                p8est_connectivity_t ** connectivity);
-
-/** Return a pointer to an array element indexed by a p4est_topidx_t.
- * \param [in] index needs to be in [0]..[elem_count-1].
- */
-/*@unused@*/
-static inline p8est_tree_t *
-p8est_tree_array_index (sc_array_t * array, p4est_topidx_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p8est_tree_t));
-  P4EST_ASSERT (it >= 0 && (size_t) it < array->elem_count);
-
-  return (p8est_tree_t *) (array->array +
-                           sizeof (p8est_tree_t) * (size_t) it);
-}
-
-/** Return a pointer to a quadrant array element indexed by a size_t. */
-/*@unused@*/
-static inline p8est_quadrant_t *
-p8est_quadrant_array_index (sc_array_t * array, size_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p8est_quadrant_t));
-  P4EST_ASSERT (it < array->elem_count);
-
-  return (p8est_quadrant_t *) (array->array + sizeof (p8est_quadrant_t) * it);
-}
-
-/** Call sc_array_push for a quadrant array. */
-/*@unused@*/
-static inline p8est_quadrant_t *
-p8est_quadrant_array_push (sc_array_t * array)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p8est_quadrant_t));
-
-  return (p8est_quadrant_t *) sc_array_push (array);
-}
-
-/** Call sc_mempool_alloc for a mempool creating quadrants. */
-/*@unused@*/
-static inline p8est_quadrant_t *
-p8est_quadrant_mempool_alloc (sc_mempool_t * mempool)
-{
-  P4EST_ASSERT (mempool->elem_size == sizeof (p8est_quadrant_t));
-
-  return (p8est_quadrant_t *) sc_mempool_alloc (mempool);
-}
-
-/** Call sc_list pop for a quadrant array. */
-/*@unused@*/
-static inline p8est_quadrant_t *
-p8est_quadrant_list_pop (sc_list_t * list)
-{
-  return (p8est_quadrant_t *) sc_list_pop (list);
-}
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_H */
diff --git a/OctreeRefinement/include/p8est_algorithms.h b/OctreeRefinement/include/p8est_algorithms.h
deleted file mode 100644
index ae1444d..0000000
--- a/OctreeRefinement/include/p8est_algorithms.h
+++ /dev/null
@@ -1,311 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P8EST_ALGORITHMS_H
-#define P8EST_ALGORITHMS_H
-
-#include <p8est.h>
-#include <p8est_extended.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Alloc and initialize the user data of a valid quadrant.
- * \param [in]  which_tree 0-based index of this quadrant's tree.
- * \param [in,out]  quad       The quadrant to be initialized.
- * \param [in]  init_fn    User-supplied callback function to init data.
- */
-void                p8est_quadrant_init_data (p8est_t * p8est,
-                                              p4est_topidx_t which_tree,
-                                              p8est_quadrant_t * quad,
-                                              p8est_init_t init_fn);
-
-/** Free the user data of a valid quadrant.
- * \param [in,out]  quad The quadrant whose data shall be freed.
- */
-void                p8est_quadrant_free_data (p8est_t * p8est,
-                                              p8est_quadrant_t * quad);
-
-/** Computes a machine-independent checksum of a list of quadrants.
- * \param [in] quadrants       Array of quadrants.
- * \param [in,out] checkarray  Temporary array of elem_size 4.
- *                             Will be resized to quadrants->elem_count * 3.
- *                             If it is NULL, will be allocated internally.
- * \param [in] first_quadrant  Index of the quadrant to start with.
- *                             Can be between 0 and elem_count (inclusive).
- */
-unsigned            p8est_quadrant_checksum (sc_array_t * quadrants,
-                                             sc_array_t * checkarray,
-                                             size_t first_quadrant);
-
-/** Test if a tree is sorted in Morton ordering.
- * \return Returns true if sorted, false otherwise.
- * \note Duplicate quadrants are not allowed.
- */
-int                 p8est_tree_is_sorted (p8est_tree_t * tree);
-
-/** Test if a tree is sorted in Morton ordering and linear.
- * \return Returns true if linear, false otherwise.
- * \note Linear means that the tree has no overlaps.
- */
-int                 p8est_tree_is_linear (p8est_tree_t * tree);
-
-/** Test if a tree is sorted in Morton ordering and complete.
- * \return Returns true if complete, false otherwise.
- * \note Complete means that the tree has no holes and no overlaps.
- */
-int                 p8est_tree_is_complete (p8est_tree_t * tree);
-
-/** Check if a tree is sorted/linear except across edges or corners.
- * \param [in]  check_linearity  Boolean for additional check for linearity.
- * \return Returns true if almost sorted/linear, false otherwise.
- */
-int                 p8est_tree_is_almost_sorted (p8est_tree_t * tree,
-                                                 int check_linearity);
-
-/** Print the quadrants in a tree.
- * Prints one line per quadrant with x, y, level and a string.
- * The string denotes the relation to the previous quadrant and can be:
- *   Fn  for the first quadrant in the tree with child id n
- *   I   for identical quadrants
- *   R   for a quadrant that with smaller Morton index
- *   Cn  for child id n
- *   Sn  for sibling with child id n
- *   D   for a descendant
- *   Nn   for a next quadrant in the tree with no holes in between and child id n
- *   qn  for a general quadrant whose child id is n
- * \param [in] tree        Any (possibly incomplete, unsorted) tree to be printed.
- */
-void                p8est_tree_print (int log_priority, p8est_tree_t * tree);
-
-/** Locally check forest/connectivity structures for equality.
- * \param [in] p8est1    The first forest to be compared.
- * \param [in] p8est2    The second forest to be compared.
- * \param [in] compare_data     Also check if quadrant data are identical.
- * \return          Returns true if forests and their connectivities are equal.
- */
-int                 p8est_is_equal (p8est_t * p8est1, p8est_t * p8est2,
-                                    int compare_data);
-
-/** Check a forest for validity and allreduce the result.
- * Some properties of a valid forest are:
- *    the quadrant counters are consistent
- *    all trees are complete
- *    all non-local trees are empty
- * This function is collective!
- * It is also relatively expensive, so its use in production should be limited.
- * \param [in] p8est    The forest to be tested.
- *                      Itself and its connectivity must be non-NULL.
- * \return              Returns true if valid, false otherwise.
- */
-int                 p8est_is_valid (p8est_t * p8est);
-
-/** Compute the overlap of a number of insulation layers with a tree.
- * Every quadrant out of the insulation layer of the quadrants in \a in
- * except the quadrant itself is checked for overlap of quadrants
- * from all trees that are smaller by at least two levels and thus
- * can cause a split. Those elements that cause a split (as determined by the
- * p8est_balance_*_test routines) create quadrants in \a out that will
- * reproduce those splits when \a in is balanced.
- * Note: Use this version if you are using less than full balance.
- *
- * \param [in] p4est    The p8est to work on.
- * \param [in] in       A piggy-sorted linear list of quadrants.
- *                      The piggy2->from_tree member must be set.
- * \param [in,out] out  A piggy-sorted subset of tree->quadrants.
- * \param [in] balance  The type of balance condition that should be enforced.
- * \param [in] borders  Array of arrays of tree border elements: if not NULL,
- *                      this will be used to fill \a out.
- * \param [in] inseeds  The seeds that \a in generates locally.
- */
-void                p8est_tree_compute_overlap (p8est_t * p8est,
-                                                sc_array_t * in,
-                                                sc_array_t * out,
-                                                p8est_connect_type_t
-                                                balance,
-                                                sc_array_t * borders,
-                                                sc_array_t * inseeds);
-
-/** Gets the reduced representation of the overlap that results from using
- * p8est_tree_compute_overlap_new
- * \param [in,out] out  A piggy-sorted subset of tree->quadrants.
-  */
-void                p8est_tree_uniqify_overlap (sc_array_t * out);
-
-/** Removes quadrants that are outside the owned tree boundaries from a tree.
- * \param [in,out] p8est    The p8est to work on.
- * \param [in] which_tree   Index to a sorted owned tree in the p8est.
- * \return                  Returns the number of removed quadrants.
- */
-size_t              p8est_tree_remove_nonowned (p8est_t * p8est,
-                                                p4est_topidx_t which_tree);
-
-/** Constructs a minimal linear octree between two octants.
- *
- * This is alogorithm 2 from H. Sundar, R.S. Sampath and G. Biros
- * with the additional improvements that we do not require sorting
- * and the runtime is O(N).
- *
- * \pre \a q1 < \a q2 in the Morton ordering.
- *
- * \param [in]  p8est      Used for the memory pools and quadrant init.
- * \param [in]  q1         First input quadrant.  Data init'ed if included.
- * \param [in]  include_q1 Flag to specify whether q1 is included.
- * \param [in]  q2         Second input quadrant.  Data init'ed if included.
- * \param [in]  include_q2 Flag to specify whether q2 is included.
- * \param [out] tree       Initialized tree with zero elements.
- * \param [in]  which_tree The 0-based index of \a tree which is needed for
- *                         the \c p8est_quadrant_init_data routine.
- * \param [in]  init_fn    Callback function to initialize the user_data
- *                         which is already allocated automatically.
- */
-void                p8est_complete_region (p8est_t * p8est,
-                                           const p8est_quadrant_t * q1,
-                                           int include_q1,
-                                           const p8est_quadrant_t * q2,
-                                           int include_q2,
-                                           p8est_tree_t * tree,
-                                           p4est_topidx_t which_tree,
-                                           p8est_init_t init_fn);
-
-/** Completes a sorted tree within a p8est. It may have exterior quadrants.
- * The completed tree will have only owned quadrants and no overlap.
- * Note that the tree's counters (\a quadrants_per_level, \a maxlevel) must be
- * correct for the quadrants in the incoming tree.
- *
- * \param [in,out] p8est      The p8est to work on.
- * \param [in]     which_tree The 0-based index of the subtree to complete.
- * \param [in]     init_fn    Callback function to initialize the user_data
- *                            which is already allocated automatically.
- */
-void                p8est_complete_subtree (p8est_t * p8est,
-                                            p4est_topidx_t which_tree,
-                                            p8est_init_t init_fn);
-
-/** Balances a sorted tree within a p8est. It may have exterior quadrants.
- * The completed tree will have only owned quadrants and no overlap.
- * \param [in,out] p8est      The p8est to work on.
- * \param [in]     btype      The balance type (face, edge or corner).
- * \param [in]     which_tree The 0-based index of the subtree to balance.
- * \param [in]     init_fn    Callback function to initialize the user_data
- *                            which is already allocated automatically.
- */
-void                p8est_balance_subtree (p8est_t * p8est,
-                                           p8est_connect_type_t btype,
-                                           p4est_topidx_t which_tree,
-                                           p8est_init_t init_fn);
-
-void                p8est_balance_border (p8est_t * p8est,
-                                          p8est_connect_type_t btype,
-                                          p4est_topidx_t which_tree,
-                                          p8est_init_t init_fn,
-                                          p8est_replace_t replace_fn,
-                                          sc_array_t * borders);
-
-/** Remove overlaps from a sorted list of quadrants.
- *
- * This is alogorithm 8 from H. Sundar, R.S. Sampath and G. Biros
- * with the additional improvement that it works in-place.
- *
- * \param [in]     p8est used for the memory pool and quadrant free.
- * \param [in,out] tree   A sorted tree to be linearized in-place.
- * \return                Returns the number of removed quadrants.
- */
-size_t              p8est_linearize_tree (p8est_t * p8est,
-                                          p8est_tree_t * tree);
-
-/** Compute correction of partition for a process.
- *
- * The correction denotes how many quadrants the process with id \a rank takes
- * from (if correction positive) or gives to (if correction negative) the
- * previous process with id \a rank-1 in order to assign a family of quadrants
- * to one process.
- * The process with the highest number of quadrants of a family gets all
- * quadrants belonging to this family from other processes. If this applies to
- * several processes, then the process with the lowest id gets the quadrants.
- * A process can give more quadrants than it owns, if it passes quadrants from
- * other processes.
- *
- * \param [in] partition       first global quadrant index for each process (+1)
- * \param [in] num_procs       number of processes
- * \param [in] rank            process id for which correction is computed
- * \param [in] min_quadrant_id minimal global quadrant index of family
- * \param [in] max_quadrant_id maximal global quadrant index of family
- * \return                     correction for process \a rank
- */
-p4est_locidx_t      p8est_partition_correction (p4est_gloidx_t *
-                                                partition,
-                                                int num_procs,
-                                                int rank,
-                                                p4est_gloidx_t
-                                                min_quadrant_id,
-                                                p4est_gloidx_t
-                                                max_quadrant_id);
-
-/** Correct partition counters to allow one level of coarsening.
- * No quadrants are actually shipped, just the desired number is updated.
- * This function guarantees that empty processors remain empty.
- * This function is collective and acts as a synchronization point.
- *
- * \param [in] p8est                     forest whose partition is corrected
- * \param [in,out] num_quadrants_in_proc partition that will be corrected
- * \return                               total absolute number of moved
- *                                       quadrants.  In practice, at most
- *                                       a small number per processor.
- */
-p4est_gloidx_t      p8est_partition_for_coarsening (p8est_t * p8est,
-                                                    p4est_locidx_t *
-                                                    num_quadrants_in_proc);
-
-/** Find next non-empty process.
- *
- * Finds the next process id >= \a rank which is not empty according to
- * \a num_quadrants_in_proc.
- *
- * \param [in] rank                  process id where search starts
- * \param [in] num_proc              number of processes
- * \param [in] num_quadrants_in_proc number of quadrants for each process
- * \return                           process id of a non empty process
- */
-int                 p8est_next_nonempty_process (int rank,
-                                                 int num_procs,
-                                                 p4est_locidx_t *
-                                                 num_quadrants_in_proc);
-
-/** Partition \a p8est given the number of quadrants per proc.
- *
- * Given the desired number of quadrants per proc \a num_quadrants_in_proc
- * the forest \a p8est is partitioned.
- *
- * \param [in,out] p8est the forest that is partitioned.
- * \param [in]     num_quadrants_in_proc  an integer array of the number of
- *                                        quadrants desired per processor.
- * \return  Returns the global count of shipped quadrants.
- */
-p4est_gloidx_t      p8est_partition_given (p8est_t * p8est,
-                                           const p4est_locidx_t *
-                                           num_quadrants_in_proc);
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_ALGORITHMS_H */
diff --git a/OctreeRefinement/include/p8est_balance.h b/OctreeRefinement/include/p8est_balance.h
deleted file mode 100644
index 43bd570..0000000
--- a/OctreeRefinement/include/p8est_balance.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P8EST_BALANCE_H
-#define P8EST_BALANCE_H
-
-#include <p8est.h>
-
-/** Determines if quadrant \a q causes quadrant \a p to split under the given
- * \a balance condition.
- *
- * \param [in] q         Test quadrant.
- * \param [in] p         Trial quadrant.
- * \param [in] balance   Balance condition.
- * \param [out] seeds    optional array: if \a seeds is not NULL, then it will
- *                       be resized and filled with descendants of \a p such
- *                       that the coarsest balanced subtree rooted at \a p
- *                       that contains all of \a seeds is also the coarset
- *                       subtree rooted at \a p that is entirely balanced with
- *                       \a q.
- * \return               True if \a q causes \a p to split.
- */
-int                 p8est_balance_seeds (p8est_quadrant_t * q,
-                                         p8est_quadrant_t * p,
-                                         p8est_connect_type_t balance,
-                                         sc_array_t * seeds);
-
-/** Same as p8est_balance_seeds, optimized for the case when it is already
- * known that \a q is outside of a certain \a face of \a p.
- */
-int                 p8est_balance_seeds_face (p8est_quadrant_t * q,
-                                              p8est_quadrant_t * p,
-                                              int face, p8est_connect_type_t
-                                              balance, sc_array_t * seeds);
-
-/** Same as p8est_balance_seeds, optimized for the case when it is already
- * known that \a q is outside of a certain \a edge of \a p.
- */
-int                 p8est_balance_seeds_edge (p8est_quadrant_t * q,
-                                              p8est_quadrant_t * p,
-                                              int face, p8est_connect_type_t
-                                              balance, sc_array_t * seeds);
-
-/** Same as p8est_balance_seeds, optimized for the case when it is already
- * known that \a q is outside of a certain \a corner of \a p.
- */
-int                 p8est_balance_seeds_corner (p8est_quadrant_t * q,
-                                                p8est_quadrant_t * p,
-                                                int face, p8est_connect_type_t
-                                                balance, sc_array_t * seeds);
-
-#endif
diff --git a/OctreeRefinement/include/p8est_bits.h b/OctreeRefinement/include/p8est_bits.h
deleted file mode 100644
index d9f03ca..0000000
--- a/OctreeRefinement/include/p8est_bits.h
+++ /dev/null
@@ -1,716 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p8est_bits.h
- *
- * Routines for manipulating quadrants (neighbors, parents, children, etc.)
- *
- * \ingroup p8est
- */
-
-#ifndef P8EST_BITS_H
-#define P8EST_BITS_H
-
-#include <p8est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Prints one line with quadrant's x, y, z and level.
- * \param [in] log_priority  see \ref logpriorities in sc.h for the meanings
- *                           of numerical priority values
- * \param [in] q             quadrant to print
- */
-void                p8est_quadrant_print (int log_priority,
-                                          const p8est_quadrant_t * q);
-
-/** Test if two quadrants have equal Morton indices.
- * \return true if \a q1 describes the same quadrant as \a q2.
- */
-int                 p8est_quadrant_is_equal (const p8est_quadrant_t * q1,
-                                             const p8est_quadrant_t * q2);
-
-/** Test if two quadrants overlap.
- * \return true if \a q1 and \a q2 are equal or one is the ancestor of the
- * other.
- */
-int                 p8est_quadrant_overlaps (const p8est_quadrant_t * q1,
-                                             const p8est_quadrant_t * q2);
-
-/** Test if two quadrants have equal Morton indices and the same tree id.
- * \return          true if \a q1 describes the same quadrant as \a q2
- *                  and the p.which_tree fields are equal.
- */
-int                 p8est_quadrant_is_equal_piggy (const p8est_quadrant_t *
-                                                   q1,
-                                                   const p8est_quadrant_t *
-                                                   q2);
-
-/** Compare two quadrants in their Morton ordering.
- * Both quadrants must be valid.
- * \return Returns < 0 if \a v1 < \a v2,
- *                   0 if \a v1 == \a v2,
- *                 > 0 if \a v1 > \a v2
- */
-int                 p8est_quadrant_compare (const void *v1, const void *v2);
-
-/** Compare two quadrants in their Morton ordering, with equivalence if the
- * two quadrants overlap.
- * \return Returns < 0 if \a v1 < \a v2 and \a v1 and \v2 do not overlap,
- *                   0 if \a v1 and \a v2 overlap,
- *                 > 0 if \a v1 > \a v2 and \a v1 and \v2 do not overlap.
- */
-int                 p8est_quadrant_disjoint (const void *v1, const void *v2);
-
-/** Compare two quadrants in their Morton ordering and the which_tree member.
- * Both quadrants must be extended (superset of valid, see below).
- * \return Returns < 0 if \a v1 < \a v2,
- *                   0 if \a v1 == \a v2,
- *                 > 0 if \a v1 > \a v2
- */
-int                 p8est_quadrant_compare_piggy (const void *v1,
-                                                  const void *v2);
-
-/** Compare two quadrants with respect to their local_num in the piggy3 member.
- * \return Returns < 0 if \a v1 < \a v2,
- *                   0 if \a v1 == \a v2,
- *                 > 0 if \a v1 > \a v2
- */
-int                 p8est_quadrant_compare_local_num (const void *v1,
-                                                      const void *v2);
-
-/** Test if two quadrants have equal Morton indices, callback version.
- * \return true if \a v1 describes the same quadrant as \a v2.
- */
-int                 p8est_quadrant_equal_fn (const void *v1, const void *v2,
-                                             const void *u);
-
-/** Computes a hash value for a quadrant by the lookup3 method.
- */
-unsigned            p8est_quadrant_hash_fn (const void *v, const void *u);
-
-/** Test if two nodes are in the same tree and have equal Morton indices.
- * \param [in] v1   Pointer to a clamped or unclamped node, depending on u.
- * \param [in] v2   Pointer to a clamped or unclamped node, depending on u.
- * \param [in] u    User data, points to an int holding the clamped-flag.
- */
-int                 p8est_node_equal_piggy_fn (const void *v1,
-                                               const void *v2, const void *u);
-
-/** Compute hash value of a node based on its tree and Morton index.
- * \param [in] v    Pointer to a clamped or unclamped node, depending on u.
- * \param [in] u    User data, points to an int holding the clamped-flag.
- */
-unsigned            p8est_node_hash_piggy_fn (const void *v, const void *u);
-
-/** Clamp a node inside the unit tree if it sits on a high border.
- * \param [in] n    Node to be clamped. Must not yet be clamped.
- * \param [out] r   Existing node overwritten by the clamped result.
- */
-void                p8est_node_clamp_inside (const p8est_quadrant_t * n,
-                                             p8est_quadrant_t * r);
-
-/** Move a clamped node out on the border.
- * \param [in] n    Node to be unclamped in-place.
- */
-void                p8est_node_unclamp (p8est_quadrant_t * n);
-
-/** Find the enclosing quadrant of a given node at a given level.
- * \param [in] n        Clamped node.
- * \param [in] level    Level of the quadrant to be created.
- * \param [out] q       Output quadrant, n == q is permitted.
- */
-void                p8est_node_to_quadrant (const p8est_quadrant_t * n,
-                                            int level, p8est_quadrant_t * q);
-
-/** Decide if a node is completely contained within a quadrant.
- * \param [in] q        Valid quadrant.
- * \param [in] n        Clamped node.
- */
-int                 p8est_quadrant_contains_node (const p8est_quadrant_t * q,
-                                                  const p8est_quadrant_t * n);
-
-/** Compute the position of the ancestor of this child at level \a level within
- * its siblings.
- * \return Returns its child id in 0..7
- */
-int                 p8est_quadrant_ancestor_id (const p8est_quadrant_t * q,
-                                                int level);
-
-/** Compute the position of this child within its siblings.
- * \return Returns its child id in 0..7
- */
-int                 p8est_quadrant_child_id (const p8est_quadrant_t * q);
-
-/** Test if a quadrant is inside the unit tree.
- * \param [in] q Quadrant to be tested.
- * \return Returns true if \a q is inside the unit tree.
- */
-int                 p8est_quadrant_is_inside_root (const p8est_quadrant_t *
-                                                   q);
-
-/** Test if a quadrant is inside the 3x3 box around the root tree.
- * \param [in] q Quadrant to be tested.
- * \return Returns true if \a q is inside the unit tree.
- */
-int                 p8est_quadrant_is_inside_3x3 (const p8est_quadrant_t * q);
-
-/** Test if a quadrant is outside a tree face boundary (no edge or corner).
- * \param [in] q Quadrant to be tested.
- * \return Returns true if \a q is outside across a unit tree face.
- */
-int                 p8est_quadrant_is_outside_face (const p8est_quadrant_t *
-                                                    q);
-
-/** Test if a quadrant is outside a tree edge boundary (no corner).
- * \param [in] q Quadrant to be tested.
- * \return Returns true if \a q is outside across a unit tree edge.
- */
-int                 p8est_quadrant_is_outside_edge (const p8est_quadrant_t *
-                                                    q);
-
-/** Test if a quadrant is outside a tree edge boundary (no corner).
- * \param [in] q       Quadrant to be tested.
- * \param [out] edge   The tree edge number is computed if outside edge.
- *                     This pointer may be NULL.
- * \return Returns true if \a q is outside across a unit tree edge.
- */
-int                 p8est_quadrant_is_outside_edge_extra (const
-                                                          p8est_quadrant_t *
-                                                          q, int *edge);
-
-/** Test if a quadrant is outside a tree corner boundary.
- * \param [in] q Quadrant to be tested.
- * \return Returns true if \a q is outside across a unit tree corner.
- */
-int                 p8est_quadrant_is_outside_corner (const p8est_quadrant_t *
-                                                      q);
-
-/** Test if a quadrant is used to represent a mesh node.
- * \param [in] q        Quadrant to be tested.
- * \param [in] inside   If true, boundary nodes must be clamped inside.
- *                      If false, nodes must align with the quadrant grid.
- * \return Returns true if \a q is a node.
- */
-int                 p8est_quadrant_is_node (const p8est_quadrant_t * q,
-                                            int inside);
-
-/** Test if a quadrant has valid Morton indices and is inside the unit tree.
- * \param [in] q Quadrant to be tested.
- * \return Returns true if \a q is valid.
- */
-int                 p8est_quadrant_is_valid (const p8est_quadrant_t * q);
-
-/** Test if a quadrant has valid Morton indices in the 3x3 box around root.
- * \param [in] q Quadrant to be tested.
- * \return Returns true if \a q is extended.
- */
-int                 p8est_quadrant_is_extended (const p8est_quadrant_t * q);
-
-/** Test if two quadrants are siblings.
- * \param [in] q1 First quadrant to be tested.
- * \param [in] q2 Second quadrant to be tested.
- * \return true if \a q1 is unequal to and a sibling of \a q2.
- */
-int                 p8est_quadrant_is_sibling (const p8est_quadrant_t * q1,
-                                               const p8est_quadrant_t * q2);
-
-/** Compute a specific child of a quadrant.
- * \param [in]     q    Input quadrant.
- * \param [in,out] r    Existing quadrant whose Morton index will be filled
- *                      with the coordinates of its child no. \b child_id.
- * \param [in] child_id The id of the child computed, 0..7.
- */
-void                p8est_quadrant_child (const p8est_quadrant_t * q,
-                                          p8est_quadrant_t * r, int child_id);
-
-/** Test if two quadrants are siblings.
- * Descriptive, slower version of \a p8est_quadrant_is_sibling.
- * For debugging and educational purposes only.
- */
-int                 p8est_quadrant_is_sibling_D (const p8est_quadrant_t * q1,
-                                                 const p8est_quadrant_t * q2);
-
-/** Test if 8 quadrants are siblings in Morton ordering.
- */
-int                 p8est_quadrant_is_family (const p8est_quadrant_t * q0,
-                                              const p8est_quadrant_t * q1,
-                                              const p8est_quadrant_t * q2,
-                                              const p8est_quadrant_t * q3,
-                                              const p8est_quadrant_t * q4,
-                                              const p8est_quadrant_t * q5,
-                                              const p8est_quadrant_t * q6,
-                                              const p8est_quadrant_t * q7);
-
-/** Test if 8 quadrants are siblings in Morton ordering, array version.
- * \param [in] q   Array of 8 quadrants.
- */
-int                 p8est_quadrant_is_familyv (const p8est_quadrant_t q[]);
-
-/** Test if 8 quadrants are siblings in Morton ordering, array version.
- * \param [in] q   Array of 8 pointers to quadrants.
- */
-int                 p8est_quadrant_is_familypv (p8est_quadrant_t * q[]);
-
-/** Test if a quadrant is the parent of another quadrant.
- * \param [in] q Quadrant to be tested.
- * \param [in] r Possible child quadrant.
- * \return true if \a q is the parent of \a r.
- */
-int                 p8est_quadrant_is_parent (const p8est_quadrant_t * q,
-                                              const p8est_quadrant_t * r);
-
-/** Test if a quadrant is the parent of another quadrant.
- * Descriptive, slower version of \a p8est_quadrant_is_parent.
- * For debugging and educational purposes only.
- */
-int                 p8est_quadrant_is_parent_D (const p8est_quadrant_t * q,
-                                                const p8est_quadrant_t * r);
-
-/** Test if a quadrant is an ancestor of another quadrant.
- * \param [in] q Quadrant to be tested.
- * \param [in] r Descendent quadrant.
- * \return true if \a q is unequal to and an ancestor of \a r.
- */
-int                 p8est_quadrant_is_ancestor (const p8est_quadrant_t * q,
-                                                const p8est_quadrant_t * r);
-
-/** Test if a quadrant is an ancestor of another quadrant.
- * Descriptive, slower version of \a p8est_quadrant_is_ancestor.
- * Contrary to \a p8est_quadrant_is_ancestor, it aborts for inter-tree q, r.
- * For debugging and educational purposes only.
- */
-int                 p8est_quadrant_is_ancestor_D (const p8est_quadrant_t * q,
-                                                  const p8est_quadrant_t * r);
-
-/** Test if two quadrants follow each other in the tree with no holes.
- * \param [in] q A quadrant
- * \param [in] r Another quadrant
- * \return true if \a q is immediately before \a r in the tree.
- * \note for every \a q there are between 0 and P8EST_MAXLEVEL+1 possible nexts.
- */
-int                 p8est_quadrant_is_next (const p8est_quadrant_t * q,
-                                            const p8est_quadrant_t * r);
-
-/** Test if two quadrants follow each other in the tree with no holes.
- * Descriptive, slower version of \a p8est_quadrant_is_next.
- * For debugging and educational purposes only.
- */
-int                 p8est_quadrant_is_next_D (const p8est_quadrant_t * q,
-                                              const p8est_quadrant_t * r);
-
-/** Test if a quadrant has at least partial overlap with a tree.
- */
-int                 p8est_quadrant_overlaps_tree (p8est_tree_t * tree,
-                                                  const p8est_quadrant_t * q);
-
-/** Test if a quadrant is completely contained within a tree.
- */
-int                 p8est_quadrant_is_inside_tree (p8est_tree_t * tree,
-                                                   const p8est_quadrant_t *
-                                                   q);
-
-/** Compute the ancestor of a quadrant at a given level.
- * \param [in]  q       Input quadrant.
- * \param [in]  level   A smaller level than q.
- * \param [in,out]  r   Existing quadrent whose Morton index will be filled
- *                      with the ancestor of q at the given level.
- * \note The quadrant q may point to the same quadrant as r.
- *       The user_data of r are never modified.
- */
-void                p8est_quadrant_ancestor (const p8est_quadrant_t * q,
-                                             int level, p8est_quadrant_t * r);
-
-/** Compute the parent of a quadrant.
- * \param [in]  q Input quadrant.
- * \param [in,out] r Existing quadrant whose Morton index will be filled
- *                   with the Morton index of the parent of \a q.
- *                   Its user_data will be untouched.
- * \note \a q may point to the same quadrant as \a r.
-         The user_data of \a r is never modified.
- */
-void                p8est_quadrant_parent (const p8est_quadrant_t * q,
-                                           p8est_quadrant_t * r);
-
-/** Compute a specific sibling of a quadrant.
- * \param [in]     q  Input quadrant.
- * \param [in,out] r  Existing quadrant whose Morton index will be filled
- *                    with the coordinates of sibling no. sibling_id of q.
- * \param [in]     sibling_id The id of the sibling computed, 0..3.
- */
-void                p8est_quadrant_sibling (const p8est_quadrant_t * q,
-                                            p8est_quadrant_t * r,
-                                            int sibling_id);
-
-/** Compute the face neighbor of a quadrant.
- * \param [in]     q      Input quadrant, must be valid.
- * \param [in]     face   The face across which to generate the neighbor.
- * \param [in,out] r      Existing quadrant whose Morton index will be filled.
- * \note \a q may point to the same quadrant as \a r.
- */
-void                p8est_quadrant_face_neighbor (const p8est_quadrant_t * q,
-                                                  int face,
-                                                  p8est_quadrant_t * r);
-
-/** Compute the face neighbor of a quadrant, transforming across tree
- * boundaries if necessary.
- * \param [in]     q      Input quadrant, must be valid.
- * \param [in]     t      Tree that contains \q.
- * \param [in]     face   The face across which to generate the neighbor.
- * \param [in,out] r      Existing quadrant whose Morton index will be filled.
- *                        By convention, if there is no tree across \face,
- *                        \r has the same Morton index as \q.
- * \param [in,out] nface  if not NULL, set to the face of \r that neighbors
- *                        \q.  nface is encoded with orientation information
- *                        in the same manner as the tree_to_face array in
- *                        the p8est_connectivity_t struct.
- * \param [in]     conn   The connectivity structure for the forest.
- * \return Returns the tree that contains \r.  By convention, if there is no
- * tree across \face, then -1 is returned.
- */
-p4est_locidx_t      p8est_quadrant_face_neighbor_extra (const p8est_quadrant_t
-                                                        * q, p4est_topidx_t t,
-                                                        int face,
-                                                        p8est_quadrant_t * r,
-                                                        int *nface,
-                                                        p8est_connectivity_t *
-                                                        conn);
-
-/** Get the smaller face neighbors of \a q.
- *
- * Gets the smaller face neighbors, which are half of the size assuming the
- * 2-1 constant.
- *
- * The order of the \a n[i] is given in the Morton ordering.
- *
- * \param [in]  q      The quadrant whose face neighbors will be constructed.
- * \param [in]  face   The face across which to generate the neighbors.
- * \param [out] n[0]..n[3] Filled with the four smaller face neighbors.
- * \param [out] nur[0]..nur[3] If not NULL, filled with smallest quadrants
- *                     that fit in the upper right corners of \a n.
- */
-void                p8est_quadrant_half_face_neighbors (const p8est_quadrant_t
-                                                        * q, int face,
-                                                        p8est_quadrant_t n[],
-                                                        p8est_quadrant_t
-                                                        nur[]);
-
-/** Create all possible face neighbors of \a q.
- *
- * Gets the face neighbors, possible assuming the 2-1 constraint.
- * If the larger or smaller quadrants do not exist than they are returned
- * as initialized by P4EST_QUADRANT_INIT.
- *
- * The order of \a n[0] through \a n[3] are given in Morton ordering.
- *
- * \param [in]  q      The quadrant whose face neighbors will be constructed.
- * \param [in]  face   The face across which to generate the neighbors.
- * \param [out] n[0]..n[3] Filled with the smaller possible face neighbors,
- *                     which are half of the size if they exist
- *                     or initialized to P4EST_QUADRANT_INIT.
- * \param [out] n[4]   Filled with the face neighbor, which is the same size.
- * \param [out] n[5]   Filled with the face neighbor, which is twice the size
- *                     if it exists or initialized to P4EST_QUADRANT_INIT.
- */
-void                p8est_quadrant_all_face_neighbors (const p8est_quadrant_t
-                                                       * q, int face,
-                                                       p8est_quadrant_t n[]);
-
-/** Compute the edge neighbor of a quadrant.
- * \param [in]     q      Input quadrant, must be valid.
- * \param [in]     edge   The edge across which to generate the neighbor.
- * \param [in,out] r      Existing quadrant whose Morton index will be filled.
- * \note \a q may point to the same quadrant as \a r.
- */
-void                p8est_quadrant_edge_neighbor (const p8est_quadrant_t * q,
-                                                  int edge,
-                                                  p8est_quadrant_t * r);
-
-/** Compute the edge neighbors of a quadrant, transforming across tree
- * boundaries if necessary.  Only computes neighbors that are not face
- * neighbors.
- * \param [in]     q      Input quadrant, must be valid.
- * \param [in]     t      Tree that contains \q.
- * \param [in]     edge   The edge across which to generate the neighbor.
- * \param [in,out] quads  An initialized but empty array where the edge
- *                        neighbors will be placed.
- * \param [in,out] treeids An initialized but empty array where the ids of the
- *                        trees containing the edge neighbors will be placed.
- * \param [in,out] nedges if not NULL, filled with the edges of \a quads that
- *                        neighbor \q. the ints in \nedges are encoded with
- *                        orientation informatin like the edge_to_edge array
- *                        in the p8est_connectivity_t struct
- * \param [in]     conn   The connectivity structure for the forest.
- */
-void                p8est_quadrant_edge_neighbor_extra (const p8est_quadrant_t
-                                                        * q, p4est_locidx_t t,
-                                                        int edge, sc_array_t *
-                                                        quads, sc_array_t *
-                                                        treeids,
-                                                        sc_array_t * nedges,
-                                                        p8est_connectivity_t *
-                                                        conn);
-
-/** Compute the corner neighbor of a quadrant.
- * \param [in]     q      Input quadrant, must be valid.
- * \param [in]     corner The corner across which to generate the neighbor.
- * \param [in,out] r      Existing quadrant whose Morton index will be filled.
- * \note \a q may point to the same quadrant as \a r.
- */
-void                p8est_quadrant_corner_neighbor (const p8est_quadrant_t *
-                                                    q, int corner,
-                                                    p8est_quadrant_t * r);
-
-/** Compute the corner neighbors of a quadrant, transforming across tree
- * boundaries if necessary.  Only computes neighbors that are not face or edge
- * neighbors.
- * \param [in]     q      Input quadrant, must be valid.
- * \param [in]     t      Tree that contains \q.
- * \param [in]     corner The corner across which to generate the neighbor.
- * \param [in,out] quads  An initialized but empty array where the corner
- *                        neighbors will be placed.
- * \param [in,out] treeids An initialized but empty array where the ids of the
- *                        trees containing the corner neighbors will be placed.
- * \param [in,out] ncorners if not NULL, filled with the corners of \a quads
- *                          that neighbor \q.
- * \param [in]     conn   The connectivity structure for the forest.
- */
-void                p8est_quadrant_corner_neighbor_extra (const
-                                                          p8est_quadrant_t *
-                                                          q, p4est_locidx_t t,
-                                                          int corner,
-                                                          sc_array_t * quads,
-                                                          sc_array_t *
-                                                          treeids,
-                                                          sc_array_t *
-                                                          ncorners,
-                                                          p8est_connectivity_t
-                                                          * conn);
-
-/** Compute the half size corner neighbor of a quadrant.
- *
- * \param [in]  q       The quadrant whose corner neighbor will be constructed.
- * \param [in]  corner  The corner across which to generate the neighbor.
- * \param [out] r       Morton index filled with the half size corner neighbor.
- */
-void                p8est_quadrant_half_corner_neighbor (const
-                                                         p8est_quadrant_t * q,
-                                                         int corner,
-                                                         p8est_quadrant_t *
-                                                         r);
-
-/** Compute the corner node of a quadrant.
- * \param [in]     q      Input quadrant, must be valid.
- * \param [in]     corner The corner across which to generate the neighbor.
- * \param [in,out] r      Node that will not be clamped inside.
- * \note \a q may point to the same quadrant as \a r.
- */
-void                p8est_quadrant_corner_node (const p8est_quadrant_t * q,
-                                                int corner,
-                                                p8est_quadrant_t * r);
-
-/** Compute the 8 children of a quadrant.
- * \param [in]     q  Input quadrant.
- * \param [in,out] c0 First computed child.
- *                    \a q may point to the same quadrant as \a c0.
- * \note The user_data of \a c0, c1, c2, c3, c4, c5, c6, c7 is never modified.
- */
-void                p8est_quadrant_children (const p8est_quadrant_t * q,
-                                             p8est_quadrant_t * c0,
-                                             p8est_quadrant_t * c1,
-                                             p8est_quadrant_t * c2,
-                                             p8est_quadrant_t * c3,
-                                             p8est_quadrant_t * c4,
-                                             p8est_quadrant_t * c5,
-                                             p8est_quadrant_t * c6,
-                                             p8est_quadrant_t * c7);
-
-/** Compute the 8 children of a quadrant, array version.
- * \param [in]     q  Input quadrant.
- * \param [in,out] c  The 8 computed children in z-order.
- *                    q may point to the same quadrant as c[0].
- * \note The user_data of c[i] is never modified.
- */
-void                p8est_quadrant_childrenv (const p8est_quadrant_t * q,
-                                              p8est_quadrant_t c[]);
-
-/** Compute the 8 children of a quadrant, array version.
- * \param [in]     q  Input quadrant.
- * \param [in,out] c  Pointers to the 8 computed children in z-order.
- *                    q may point to the same quadrant as c[0].
- * \note The user_data of c[i] is never modified.
- */
-void                p8est_quadrant_childrenpv (const p8est_quadrant_t * q,
-                                               p8est_quadrant_t * c[]);
-
-/** Compute the first descendant of a quadrant on a given level.
- * \param [in]  q      Input quadrant.
- * \param [out] fd     First descendant of \a q on level \a level.
- * \param [in]  level  Level must be greater equal than q's level.
- */
-void                p8est_quadrant_first_descendant (const p8est_quadrant_t *
-                                                     q, p8est_quadrant_t * fd,
-                                                     int level);
-
-/** Compute the last descendant of a quadrant on a given level.
- * \param [in]  q      Input quadrant.
- * \param [out] ld     Last descendant of \a q on level \a level.
- * \param [in]  level  Level must be greater equal than q's level.
- */
-void                p8est_quadrant_last_descendant (const p8est_quadrant_t *
-                                                    q, p8est_quadrant_t * ld,
-                                                    int level);
-
-/** Compute the descendant of a quadrant touching a given corner.
- * \param [in]     q   Input quadrant.
- * \param [in,out] r   Existing quadrant whose Morton index will be filled.
- *                     Its user_data will be untouched.
- * \param [in]     c   The corner of \a q that \a r touches.
- * \param [in] level   The size of \a r.
- */
-void                p8est_quadrant_corner_descendant (const p8est_quadrant_t *
-                                                      q, p8est_quadrant_t * r,
-                                                      int c, int level);
-
-/** Computes the nearest common ancestor of two quadrants in the same tree.
- * \param [in]     q1 First input quadrant.
- * \param [in]     q2 Second input quadrant.
- * \param [in,out] r Existing quadrant whose Morton index will be filled.
- *                   Its user_data will be untouched.
- * \note \a q1, \a q2, \a r may point to the same quadrant.
- *       The user_data of \a r is never modified.
- */
-void                p8est_nearest_common_ancestor (const p8est_quadrant_t *
-                                                   q1,
-                                                   const p8est_quadrant_t *
-                                                   q2, p8est_quadrant_t * r);
-
-/** Computes the nearest common ancestor of two quadrants in the same tree.
- * Descriptive, slower version of \a p8est_nearest_common_ancestor.
- * For debugging and educationial purposes only.
- */
-void                p8est_nearest_common_ancestor_D (const p8est_quadrant_t *
-                                                     q1,
-                                                     const p8est_quadrant_t *
-                                                     q2,
-                                                     p8est_quadrant_t * r);
-
-/** Transforms a quadrant/node across a face between trees.
- * \param [in]     q        Input quadrant/non-clamped node.
- * \param [in,out] r        Quadrant/node whose Morton index will be filled.
- * \param [in] ftransform   This array holds 9 integers.
- *             [0]..[2]     The coordinate axis sequence of the origin face.
- *             [3]..[5]     The coordinate axis sequence of the target face.
- *             [6]..[8]     Edge reverse flag for axes 0, 1; face code for 2.
- * \note \a q and \q r may NOT point to the same quadrant structure.
- */
-void                p8est_quadrant_transform_face (const p8est_quadrant_t * q,
-                                                   p8est_quadrant_t * r,
-                                                   const int ftransform[]);
-
-/** Checks if a quadrant touches an edge (diagonally inside or outside).
- */
-int                 p8est_quadrant_touches_edge (const p8est_quadrant_t * q,
-                                                 int edge, int inside);
-
-/** Transforms a quadrant across an edge between trees.
- * \param [in]     q          Input quadrant.
- * \param [in,out] r          Quadrant whose Morton index will be filled.
- * \param [in]     edge       Edge index of the originating quadrant.
- * \param [in]     ei         Edge information computed previously.
- * \param [in]     inside     The quadrant will be placed inside or outside.
- */
-void                p8est_quadrant_transform_edge (const p8est_quadrant_t * q,
-                                                   p8est_quadrant_t * r,
-                                                   const p8est_edge_info_t *
-                                                   ei,
-                                                   const
-                                                   p8est_edge_transform_t *
-                                                   et, int inside);
-
-/** Shifts a quadrant until it touches the specified edge from the inside.
- * If this shift is meant to recreate the effects of \a q on balancing across
- * the edge, then \a r, \a rup, and \a rdown may all be necessary for that
- * recreation.
- * \param [in]     q          Valid input quadrant.
- * \param [out]    r          Quadrant whose Morton index will be filled.
- *                            This quadrant results from shifting \a q
- *                            laterally towards the edge.
- * \param [out]    rup        Quadrant whose Morton index will be filled (may
- *                            be NULL).  This quadrant results from shifting
- *                            \a q diagonally towards \a edge's higher
- *                            corner.
- * \param [out]    rdown      Quadrant whose Morton index will be filled (may
- *                            be NULL).  This quadrant results from shifting
- *                            \a q diagonally towards \a edge's lower corner.
- * \param [in]     edge       Edge index.
- */
-void                p8est_quadrant_shift_edge (const p8est_quadrant_t * q,
-                                               p8est_quadrant_t * r,
-                                               p8est_quadrant_t * rup,
-                                               p8est_quadrant_t * rdown,
-                                               int edge);
-
-/** Checks if a quadrant touches a corner (diagonally inside or outside).
- */
-int                 p8est_quadrant_touches_corner (const p8est_quadrant_t * q,
-                                                   int corner, int inside);
-
-/** Move a quadrant inside or diagonally outside a corner position.
- * \param [in,out] q        This quadrant only requires a valid level.
- * \param [in]     icorner  Number of the corner in 0..7.
- * \param [int]    inside   Boolean flag for inside or diagonally outside.
- */
-void                p8est_quadrant_transform_corner (p8est_quadrant_t * r,
-                                                     int corner, int inside);
-
-/** Shifts a quadrant until it touches the specified corner from the inside.
- * \param [in]     q          Valid input quadrant.
- * \param [in,out] r          Quadrant whose Morton index will be filled.
- * \param [in]     corner     Corner index.
- */
-void                p8est_quadrant_shift_corner (const p8est_quadrant_t * q,
-                                                 p8est_quadrant_t * r,
-                                                 int corner);
-
-/** Computes the linear position of a quadrant in a uniform grid.
- * \param [in] quadrant  Quadrant whose id will be computed.
- * \return Returns the linear position of this quadrant on a grid.
- * \note This is the inverse operation of p8est_quadrant_set_morton.
- *       The user_data of \a quadrant is never modified.
- */
-uint64_t            p8est_quadrant_linear_id (const p8est_quadrant_t *
-                                              quadrant, int level);
-
-/** Set quadrant Morton indices based on linear position in uniform grid.
- * \param [in,out] quadrant  Quadrant whose Morton indices will be set.
- * \param [in]     id        The linear position of this quadrant on a grid.
- * \note This is the inverse operation of p8est_quadrant_linear_id.
- *       The user_data of \a quadrant is never modified.
- */
-void                p8est_quadrant_set_morton (p8est_quadrant_t * quadrant,
-                                               int level, uint64_t id);
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_BITS_H */
diff --git a/OctreeRefinement/include/p8est_communication.h b/OctreeRefinement/include/p8est_communication.h
deleted file mode 100644
index aa36028..0000000
--- a/OctreeRefinement/include/p8est_communication.h
+++ /dev/null
@@ -1,412 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P8EST_COMMUNICATION_H
-#define P8EST_COMMUNICATION_H
-
-#include <p8est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Assign an MPI communicator to p8est; retrieve parallel environment.
- *
- * \param [in] mpicomm    A valid MPI communicator.
- *
- * \note The provided MPI communicator is not owned by p8est.
- */
-void                p8est_comm_parallel_env_assign (p8est_t * p8est,
-                                                    sc_MPI_Comm mpicomm);
-
-/** Duplicate MPI communicator and replace the current one by the duplicate.
- *
- * \note The duplicated MPI communicator is owned by p8est.
- */
-void                p8est_comm_parallel_env_duplicate (p8est_t * p8est);
-
-/** Release MPI communicator if it is owned by p8est.
- */
-void                p8est_comm_parallel_env_release (p8est_t * p8est);
-
-/** Replace the current MPI communicator by the one provided as input.
- *
- * \param [in] mpicomm    A valid MPI communicator.
- *
- * \note The provided MPI communicator is not owned by p8est.
- */
-void                p8est_comm_parallel_env_replace (p8est_t * p8est,
-                                                     sc_MPI_Comm mpicomm);
-
-/** Retrieve parallel environment information.
- */
-void                p8est_comm_parallel_env_get_info (p8est_t * p8est);
-
-/** Check if the MPI communicator is valid.
- *
- * \return True if communicator is not NULL communicator, false otherwise.
- */
-int                 p8est_comm_parallel_env_is_null (p8est_t * p8est);
-
-/** Reduce MPI communicator to non-empty ranks (i.e., nonzero quadrant counts).
- *
- * \param [in/out] p8est_supercomm  Object which communicator is reduced.
- *                                  Points to NULL if this p8est does not
- *                                  exists.
- *
- * \return True if p8est exists on this MPI rank after reduction.
- */
-int                 p8est_comm_parallel_env_reduce (p8est_t **
-                                                    p8est_supercomm);
-
-/** Reduce MPI communicator to non-empty ranks and add a group of ranks that
- * will remain in the reduced communicator regardless whether they are empty
- * or not.
- *
- * \param [in/out] p8est_supercomm  Object which communicator is reduced.
- *                                  Points to NULL if this p8est does not
- *                                  exists.
- * \param [in] group_add         Group of ranks that will remain in
- *                               communicator.
- * \param [in] add_to_beginning  If true, ranks will be added to the beginning
- *                               of the reduced communicator, otherwise to the
- *                               end.
- * \param[out] ranks_subcomm     If not null, array of size 'subcommsize' with
- *                               subcommrank->supercommrank map.
- *
- * \return True if p8est exists on this MPI rank after reduction.
- */
-int                 p8est_comm_parallel_env_reduce_ext (p8est_t **
-                                                        p8est_supercomm,
-                                                        sc_MPI_Group
-                                                        group_add,
-                                                        int add_to_beginning,
-                                                        int **ranks_subcomm);
-
-/** Caculate the number and partition of quadrents.
- * \param [in,out] p8est  Adds all \c p8est->local_num_quadrant counters and
- *                        puts cumulative sums in p4est->global_first_quadrant.
- */
-void                p8est_comm_count_quadrants (p8est_t * p8est);
-
-/** Distribute the global partition boundaries.
- * \param [in,out] p8est        Fills \c p8est->global_first_position.
- *                              p8est->first_local_tree must be set correctly.
- *                              If this processor is not empty and
- *                              first_quad is NULL, the first quadrant
- *                              of the first local tree must be set correctly.
- * \param [in] first_quad       If not NULL will be used as first quadrant.
- */
-void                p8est_comm_global_partition (p8est_t * p8est,
-                                                 p8est_quadrant_t *
-                                                 first_quad);
-
-/** Compute and distribute the cumulative number of quadrants per tree.
- * \param [in] p8est    This p8est needs to have correct values for
- *                      global_first_quadrant and global_first_position.
- * \param [in,out] pertree      On input, memory for num_trees + 1 numbers.
- *                              On output, the cumulative quadrant counts.
- */
-void                p8est_comm_count_pertree (p8est_t * p8est,
-                                              p4est_gloidx_t * pertree);
-
-/** Query whether a processor has no quadrants.
- * \param [in] p8est    This forests' global_first_position array must be valid.
- * \param [in] p        Valid processor id.
- * \return              True if and only if processor \p is empty.
- */
-int                 p8est_comm_is_empty (p8est_t * p8est, int p);
-
-/** Test whether a quadrant is fully contained in a rank's owned regien.
- * This function may return false when \ref p8est_comm_is_owner returns true.
- * \param [in] rank    Rank whose ownership is tested.
- *                     Assumes a forest with no overlaps.
- * \return true if rank is the owner of the whole area of the quadrant.
- */
-int                 p8est_comm_is_contained (p8est_t * p8est,
-                                             p4est_locidx_t which_tree,
-                                             const p8est_quadrant_t * q,
-                                             int rank);
-
-/** Test ownershop of a quadrant via p8est->global_first_position.
- * The quadrant is considered owned if its first descendant is owned.
- * This, a positive result occurs even if its last descendant overlaps
- * a higher process.
- * \param [in] rank    Rank whose ownership is tested.
- *                     Assumes a forest with no overlaps.
- * \return true if rank is the owner of the first descendant.
- */
-int                 p8est_comm_is_owner (p8est_t * p8est,
-                                         p4est_locidx_t which_tree,
-                                         const p8est_quadrant_t * q,
-                                         int rank);
-
-/** Searches the owner of a quadrant via p8est->global_first_position.
- * Assumes a tree with no overlaps.
- * \param [in] guess   Initial guess for the search.
- * \return Returns the processor id of the owner.
- */
-int                 p8est_comm_find_owner (p8est_t * p8est,
-                                           p4est_locidx_t which_tree,
-                                           const p8est_quadrant_t * q,
-                                           int guess);
-
-/** Computes information about a tree being fully owned.
- * This is determined separately for the beginning and end of the tree.
- * \param [in] p8est            The p8est to work on.
- * \param [in] which_tree       The tree in question must be partially owned.
- * \param [out] full_tree[2]    Full ownership of beginning and end of tree.
- * \param [out] tree_contact[6] True if there are neighbors across the face.
- * \param [out] firstq          Smallest possible first quadrant on this core.
- * \param [out] nextq           Smallest possible first quadrant on next core.
- *                          Any of tree_contact, firstq and nextq may be NULL.
- */
-void                p8est_comm_tree_info (p8est_t * p8est,
-                                          p4est_locidx_t which_tree,
-                                          int full_tree[],
-                                          int tree_contact[],
-                                          const p8est_quadrant_t ** firstq,
-                                          const p8est_quadrant_t ** nextq);
-
-/** Test if the 3x3 neighborhood of a quadrant is owned by this processor.
- * \param [in] p8est            The p8est to work on.
- * \param [in] which_tree       The tree index to work on.
- * \param [in] full_tree[2]     Flags as computed by p4est_comm_tree_info.
- * \param [in] tree_contact[6]  Flags as computed by p4est_comm_tree_info.
- * \param [in] q                The quadrant to be checked.
- * \return          Returns true iff this quadrant's 3x3 neighborhood is owned.
- */
-int                 p8est_comm_neighborhood_owned (p8est_t * p8est,
-                                                   p4est_locidx_t which_tree,
-                                                   int full_tree[],
-                                                   int tree_contact[],
-                                                   p8est_quadrant_t * q);
-
-/** Evaluates true/false of a flag among processors.
- * \param [in] p8est        The MPI communicator of this p8est will be used.
- * \param [in] flag         The variable to communicate.
- * \param [in] operation    Either sc_MPI_BAND or sc_MPI_BOR (not used bitwise).
- * \return          Returns the logical AND resp. OR of all processors' flags.
- */
-int                 p8est_comm_sync_flag (p8est_t * p8est,
-                                          int flag, sc_MPI_Op operation);
-
-/** Compute a parallel checksum out of local checksums.
- * \param [in] p8est       The MPI information of this p8est will be used.
- * \param [in] local_crc   Locally computed adler32 checksum.
- * \param [in] local_bytes Number of bytes used for local checksum.
- * \return                 Parallel checksum on rank 0, 0 otherwise.
- */
-unsigned            p8est_comm_checksum (p8est_t * p8est,
-                                         unsigned local_crc,
-                                         size_t local_bytes);
-
-/** Context data to allow for split begin/end data transfer. */
-typedef struct p8est_transfer_context
-{
-  int                 variable;
-  int                 num_senders;
-  int                 num_receivers;
-  sc_MPI_Request     *recv_req;
-  sc_MPI_Request     *send_req;
-}
-p8est_transfer_context_t;
-
-/** Transfer data associated with one forest partition to another.
- * In \ref p8est_partition, each quadrant's user data is transferred.
- * If the application maintains per-quadrant data outside of the p8est object,
- * this function can be used to transfer it, matching the call to partition.
- * This variant of the function assumes that the quadrant data size is fixed.
- * It sends point-to-point messages only and is blocking collective.
- * There is a split collective version; see the functions
- * \ref p8est_transfer_fixed_begin and \ref p8est_transfer_fixed_end.
- * \param [in] dest_gfq     The target partition encoded as a \b
- *                          p8est->global_first_quadrant array.  Has \b mpisize
- *                          + 1 members, must be non-decreasing and satisfy
- *                          gfq[0] == 0, gfq[mpisize] == global_num_quadrants.
- * \param [in] src_gfq      The original partition, analogous to \b dest_gfq.
- * \param [in] mpicomm      The communicator to use.
- *                          Its mpisize must match \b dest_gfq and \b src_gfq.
- * \param [in] tag          This tag is used in all messages.  The user must
- *                          guarantee that \b mpicomm and \b tag do not
- *                          conflict with other messages in transit.
- * \param [out] dest_data   User-allocated memory of size \b data_size * \b
- *                          dest->local_num_quadrants is received into.
- * \param [in] src_data     User-allocated memory of size \b data_size * \b
- *                          src->local_num_quadrants bytes is sent from.
- * \param [in] data_size    Fixed data size per quadrant.
- */
-void                p8est_transfer_fixed (const p4est_gloidx_t * dest_gfq,
-                                          const p4est_gloidx_t * src_gfq,
-                                          sc_MPI_Comm mpicomm, int tag,
-                                          void *dest_data,
-                                          const void *src_data,
-                                          size_t data_size);
-
-/** Initiate a fixed-size data transfer between partitions.
- * See \ref p8est_transfer_fixed for a full description.
- * Must be matched with \ref p8est_transfer_fixed_end for completion.
- * All parameters must stay alive until the completion has been called.
- * \param [in] dest_gfq     The target partition encoded as a \b
- *                          p8est->global_first_quadrant array.  Has \b mpisize
- *                          + 1 members, must be non-decreasing and satisfy
- *                          gfq[0] == 0, gfq[mpisize] == global_num_quadrants.
- * \param [in] src_gfq      The original partition, analogous to \b dest_gfq.
- * \param [in] mpicomm      The communicator to use.
- *                          Its mpisize must match \b dest_gfq and \b src_gfq.
- * \param [in] tag          This tag is used in all messages.  The user must
- *                          guarantee that \b mpicomm and \b tag do not
- *                          conflict with other messages in transit.
- * \param [out] dest_data   User-allocated memory of size \b data_size * \b
- *                          dest->local_num_quadrants bytes is received into.
- *                          It must not be accessed before completion with
- *                          \ref p8est_transfer_fixed_end.
- * \param [in] src_data     User-allocated memory of size \b data_size * \b
- *                          src->local_num_quadrants bytes is sent from.
- *                          It must not be accessed before completion with
- *                          \ref p8est_transfer_fixed_end.
- * \param [in] data_size    Fixed data size per quadrant.
- * \return                  The context object must be passed to the matching
- *                          call to \ref p8est_transfer_fixed_end.
- */
-p8est_transfer_context_t *p8est_transfer_fixed_begin (const p4est_gloidx_t *
-                                                      dest_gfq,
-                                                      const p4est_gloidx_t *
-                                                      src_gfq,
-                                                      sc_MPI_Comm mpicomm,
-                                                      int tag,
-                                                      void *dest_data,
-                                                      const void *src_data,
-                                                      size_t data_size);
-
-/** Complete a fixed-size data transfer between partitions.
- * \param [in] tc       Context data from \ref p8est_transfer_fixed_begin.
- *                      Is deallocated before this function returns.
- */
-void                p8est_transfer_fixed_end (p8est_transfer_context_t * tc);
-
-/** Transfer variable-size quadrant data between partitions.
- * (See \ref p8est_transfer_fixed that is optimized for fixed-size data.)
- * The destination process may not know the data size for the elements it
- * receives.  In this case the sizes need to be obtained separately in advance,
- * for example by calling \ref p8est_transfer_fixed with \b src_sizes as
- * payload data, or alternatively its split begin/end versions.
- * \param [in] dest_gfq     The target partition encoded as a \b
- *                          p8est->global_first_quadrant array.  Has \b mpisize
- *                          + 1 members, must be non-decreasing and satisfy
- *                          gfq[0] == 0, gfq[mpisize] == global_num_quadrants.
- * \param [in] src_gfq      The original partition, analogous to \b dest_gfq.
- * \param [in] mpicomm      The communicator to use.
- *                          Its mpisize must match \b dest_gfq and \b src_gfq.
- * \param [in] tag          This tag is used in all messages.  The user must
- *                          guarantee that \b mpicomm and \b tag do not
- *                          conflict with other messages in transit.
- * \param [out] dest_data   User-allocated memory of
- *                          sum_{i in \b dest->local_num_quadrants} \b
- *                          dest_sizes [i] many bytes is received into.
- *                          See below about how to choose its size.
- * \param [in] dest_sizes   User-allocated memory of one integer for each
- *                          quadrant, storing the data size to receive for it.
- *                          We understand that the sizes are often not known a
- *                          priori, in which case they can be obtained by a
- *                          prior call to \ref p8est_transfer_fixed.
- *                          Optionally the split begin/end versions can be used
- *                          for added flexibility and overlapping of messages.
- *                          We use the type int to minimize the message size,
- *                          and to conform to MPI that has no type for size_t.
- * \param [in] src_data     User-allocated memory of
- *                          sum_{i in \b src->local_num_quadrants} \b
- *                          src_sizes [i] many bytes is sent from.
- * \param [in] src_sizes    User-allocated memory of one integer for each
- *                          quadrant, storing the data size to send for it.
- *                          We use the type int to minimize the message size,
- *                          and to conform to MPI that has no type for size_t.
- */
-void                p8est_transfer_custom (const p4est_gloidx_t * dest_gfq,
-                                           const p4est_gloidx_t * src_gfq,
-                                           sc_MPI_Comm mpicomm, int tag,
-                                           void *dest_data,
-                                           const int *dest_sizes,
-                                           const void *src_data,
-                                           const int *src_sizes);
-
-/** Initiate a variable-size data transfer between partitions.
- * See \ref p8est_transfer_custom for a full description.
- * Must be matched with \ref p8est_transfer_custom_end for completion.
- * All parameters must stay alive until the completion has been called.
- * \param [in] dest_gfq     The target partition encoded as a \b
- *                          p8est->global_first_quadrant array.  Has \b mpisize
- *                          + 1 members, must be non-decreasing and satisfy
- *                          gfq[0] == 0, gfq[mpisize] == global_num_quadrants.
- * \param [in] src_gfq      The original partition, analogous to \b dest_gfq.
- * \param [in] mpicomm      The communicator to use.
- *                          Its mpisize must match \b dest_gfq and \b src_gfq.
- * \param [in] tag          This tag is used in all messages.  The user must
- *                          guarantee that \b mpicomm and \b tag do not
- *                          conflict with other messages in transit.
- * \param [out] dest_data   User-allocated memory of
- *                          sum_{i in \b dest->local_num_quadrants} \b
- *                          dest_sizes [i] many bytes is received into.
- *                          It must not be accessed before completion with
- *                          \ref p8est_transfer_custom_end.
- *                          See below about how to choose its size.
- * \param [in] dest_sizes   User-allocated memory of one integer for each
- *                          quadrant, storing the data size to receive for it.
- *                          We understand that the sizes are often not known a
- *                          priori, in which case they can be obtained by a
- *                          prior call to \ref p8est_transfer_fixed.
- *                          Optionally the split begin/end versions can be used
- *                          for added flexibility and overlapping of messages.
- *                          We use the type int to minimize the message size,
- *                          and to conform to MPI that has no type for size_t.
- * \param [in] src_data     User-allocated memory of
- *                          sum_{i in \b src->local_num_quadrants} \b
- *                          src_sizes [i] many bytes is sent from.
- *                          It must not be accessed before completion with
- *                          \ref p8est_transfer_custom_end.
- * \param [in] src_sizes    User-allocated memory of one integer for each
- *                          quadrant, storing the data size to send for it.
- *                          We use the type int to minimize the message size,
- *                          and to conform to MPI that has no type for size_t.
- * \return                  The context object must be passed to the matching
- *                          call to \ref p8est_transfer_custom_end.
- */
-p8est_transfer_context_t *p8est_transfer_custom_begin (const p4est_gloidx_t *
-                                                       dest_gfq,
-                                                       const p4est_gloidx_t *
-                                                       src_gfq,
-                                                       sc_MPI_Comm mpicomm,
-                                                       int tag,
-                                                       void *dest_data,
-                                                       const int *dest_sizes,
-                                                       const void *src_data,
-                                                       const int *src_sizes);
-
-/** Complete a variable-size data transfer between partitions.
- * \param [in] tc       Context data from \ref p8est_transfer_custom_begin.
- *                      Is deallocated before this function returns.
- */
-void                p8est_transfer_custom_end (p8est_transfer_context_t * tc);
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_COMMUNICATION_H */
diff --git a/OctreeRefinement/include/p8est_connectivity.h b/OctreeRefinement/include/p8est_connectivity.h
deleted file mode 100644
index e545891..0000000
--- a/OctreeRefinement/include/p8est_connectivity.h
+++ /dev/null
@@ -1,987 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p8est_connectivity.h
- *
- * The coarse topological description of the forest.
- *
- * \ingroup p8est
- */
-
-#ifndef P8EST_CONNECTIVITY_H
-#define P8EST_CONNECTIVITY_H
-
-#include <sc_io.h>
-#include <p4est_base.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** The spatial dimension */
-#define P8EST_DIM 3
-/** The number of faces of an octant
- *
- * \note for uniform naming reasons, an
- * octant is represented by the datatype p8est_quadrant_t */
-#define P8EST_FACES (2 * P8EST_DIM)
-/** The number of children of an octant
- *
- * also the nmber of corners */
-#define P8EST_CHILDREN 8
-/** The number of children/corners touching one face */
-#define P8EST_HALF (P8EST_CHILDREN / 2)
-/** The number of edges around an octant */
-#define P8EST_EDGES 12
-/** The size of insulation layer */
-#define P8EST_INSUL 27
-
-/* size of face transformation encoding */
-#define P8EST_FTRANSFORM 9
-
-/** p8est identification string */
-#define P8EST_STRING "p8est"
-
-/* Increase this number whenever the on-disk format for
- * p8est_connectivity, p8est, or any other 3D data structure changes.
- * The format for reading and writing must be the same.
- */
-#define P8EST_ONDISK_FORMAT 0x3000009
-
-/** Characterize a type of adjacency.
- *
- * Several functions involve relationships between neighboring trees and/or
- * quadrants, and their behavior depends on how one defines adjacency:
- * 1) entities are adjacent if they share a face, or
- * 2) entities are adjacent if they share a face or corner, or
- * 3) entities are adjacent if they share a face, corner or edge.
- * p8est_connect_type_t is used to choose the desired behavior.
- * This enum must fit into an int8_t.
- */
-typedef enum
-{
-  /* make sure to have different values 2D and 3D */
-  P8EST_CONNECT_FACE = 31,
-  P8EST_CONNECT_EDGE = 32,
-  P8EST_CONNECT_CORNER = 33,
-  P8EST_CONNECT_FULL = P8EST_CONNECT_CORNER
-}
-p8est_connect_type_t;
-
-#ifdef P4EST_BACKWARD_DEALII
-typedef p8est_connect_type_t p8est_balance_type_t;
-#endif
-
-/** Typedef for serialization method. */
-typedef enum
-{
-  P8EST_CONN_ENCODE_NONE = SC_IO_ENCODE_NONE,
-  P8EST_CONN_ENCODE_LAST        /**< Invalid entry to close the list. */
-}
-p8est_connectivity_encode_t;
-
-/** Convert the p8est_connect_type_t into a number.
- * \param [in] btype    The balance type to convert.
- * \return              Returns 1, 2 or 3.
- */
-int                 p8est_connect_type_int (p8est_connect_type_t btype);
-
-/** Convert the p8est_connect_type_t into a const string.
- * \param [in] btype    The balance type to convert.
- * \return              Returns a pointer to a constant string.
- */
-const char         *p8est_connect_type_string (p8est_connect_type_t btype);
-
-/** This structure holds the 3D inter-tree connectivity information.
- * Identification of arbitrary faces, edges and corners is possible.
- *
- * The arrays tree_to_* are stored in z ordering.
- * For corners the order wrt. zyx is 000 001 010 011 100 101 110 111.
- * For faces the order is -x +x -y +y -z +z.
- * They are allocated [0][0]..[0][N-1]..[num_trees-1][0]..[num_trees-1][N-1].
- * where N is 6 for tree and face, 8 for corner, 12 for edge.
- *
- * The values for tree_to_face are in 0..23
- * where ttf % 6 gives the face number and ttf / 6 the face orientation code.
- * The orientation is determined as follows.  Let my_face and other_face
- * be the two face numbers of the connecting trees in 0..5.  Then the first
- * face corner of the lower of my_face and other_face connects to a face
- * corner numbered 0..3 in the higher of my_face and other_face.  The face
- * orientation is defined as this number.  If my_face == other_face, treating
- * either of both faces as the lower one leads to the same result.
- *
- * It is valid to specify num_vertices as 0.
- * In this case vertices and tree_to_vertex are set to NULL.
- * Otherwise the vertex coordinates are stored in the array vertices as
- * [0][0]..[0][2]..[num_vertices-1][0]..[num_vertices-1][2].
- *
- * The edges are only stored when they connect trees.
- * In this case tree_to_edge indexes into \a ett_offset.
- * Otherwise the tree_to_edge entry must be -1 and this edge is ignored.
- * If num_edges == 0, tree_to_edge and edge_to_* arrays are set to NULL.
- *
- * The arrays edge_to_* store a variable number of entries per edge.
- * For edge e these are at position [ett_offset[e]]..[ett_offset[e+1]-1].
- * Their number for edge e is ett_offset[e+1] - ett_offset[e].
- * The entries encode all trees adjacent to edge e.
- * The size of the edge_to_* arrays is num_ett = ett_offset[num_edges].
- * The edge_to_edge array holds values in 0..23, where the lower 12 indicate
- * one edge orientation and the higher 12 the opposite edge orientation.
- *
- * The corners are only stored when they connect trees.
- * In this case tree_to_corner indexes into \a ctt_offset.
- * Otherwise the tree_to_corner entry must be -1 and this corner is ignored.
- * If num_corners == 0, tree_to_corner and corner_to_* arrays are set to NULL.
- *
- * The arrays corner_to_* store a variable number of entries per corner.
- * For corner c these are at position [ctt_offset[c]]..[ctt_offset[c+1]-1].
- * Their number for corner c is ctt_offset[c+1] - ctt_offset[c].
- * The entries encode all trees adjacent to corner c.
- * The size of the corner_to_* arrays is num_ctt = ctt_offset[num_corners].
- *
- * The *_to_attr arrays may have arbitrary contents defined by the user.
- */
-typedef struct p8est_connectivity
-{
-  p4est_topidx_t      num_vertices; /**< the number of vertices that define
-                                         the \a embedding of the forest (not
-                                         the topology) */
-  p4est_topidx_t      num_trees;    /**< the number of trees */
-  p4est_topidx_t      num_edges;    /**< the number of edges that help define
-                                         the topology */
-  p4est_topidx_t      num_corners;  /**< the number of corners that help
-                                         define the topology */
-
-  double             *vertices;     /**< an array of size
-                                         (3 * \a num_vertices) */
-  p4est_topidx_t     *tree_to_vertex; /**< embed each tree into \f$R^3\f$ for
-                                           e.g. visualization (see
-                                           p8est_vtk.h) */
-
-  size_t              tree_attr_bytes;  /**< bytes per tree in tree_to_attr */
-  char               *tree_to_attr;     /**< not touched by p4est */
-
-  p4est_topidx_t     *tree_to_tree; /**< (6 * \a num_trees) neighbors across
-                                         faces */
-  int8_t             *tree_to_face; /**< (6 * \a num_trees) face to
-                                         face+orientation (see description) */
-  p4est_topidx_t     *tree_to_edge; /**< (12 * \a num_trees) or NULL (see
-                                          description) */
-  p4est_topidx_t     *ett_offset; /**< edge to offset in \a edge_to_tree and
-                                       \a edge_to_edge */
-  p4est_topidx_t     *edge_to_tree; /**< list of trees that meet at an edge */
-  int8_t             *edge_to_edge; /**< list of tree-edges+orientations that
-                                         meet at an edge (see description) */
-  p4est_topidx_t     *tree_to_corner; /**< (8 * \a num_trees) or NULL (see
-                                           description) */
-  p4est_topidx_t     *ctt_offset; /**< corner to offset in \a corner_to_tree
-                                       and \a corner_to_corner */
-  p4est_topidx_t     *corner_to_tree; /**< list of trees that meet at a corner */
-  int8_t             *corner_to_corner; /**< list of tree-corners that meet at
-                                             a corner */
-}
-p8est_connectivity_t;
-
-/** Calculate memory usage of a connectivity structure.
- * \param [in] conn   Connectivity structure.
- * \return            Memory used in bytes.
- */
-size_t              p8est_connectivity_memory_used (p8est_connectivity_t *
-                                                    conn);
-
-typedef struct
-{
-  p4est_topidx_t      ntree;
-  int8_t              nedge, naxis[3], nflip, corners;
-}
-p8est_edge_transform_t;
-
-typedef struct
-{
-  int8_t              iedge;
-  sc_array_t          edge_transforms;
-}
-p8est_edge_info_t;
-
-typedef struct
-{
-  p4est_topidx_t      ntree;
-  int8_t              ncorner;
-}
-p8est_corner_transform_t;
-
-typedef struct
-{
-  p4est_topidx_t      icorner;
-  sc_array_t          corner_transforms;
-}
-p8est_corner_info_t;
-
-/** Store the corner numbers 0..7 for each tree face. */
-extern const int    p8est_face_corners[6][4];
-
-/** Store the edge numbers 0..12 for each tree face. */
-extern const int    p8est_face_edges[6][4];
-
-/** Store the face numbers in the face neighbor's system. */
-extern const int    p8est_face_dual[6];
-
-/* face corners */
-
-/** Store only the 8 out of 24 possible permutations that occur. */
-extern const int    p8est_face_permutations[8][4];
-
-/** Store the 3 occurring sets of 4 permutations per face. */
-extern const int    p8est_face_permutation_sets[3][4];
-
-/** For each face combination store the permutation set.
- * The order is [my_face][neighbor_face] */
-extern const int    p8est_face_permutation_refs[6][6];
-
-/* face edges */
-
-/** Store only the 8 out of 24 possible permutations that occur. */
-extern const int    p8est_face_edge_permutations[8][4];
-
-/** Store the 3 occurring sets of 4 permutations per face. */
-extern const int    p8est_face_edge_permutation_sets[3][4];
-
-/** Store the face numbers 0..5 for each tree edge. */
-extern const int    p8est_edge_faces[12][2];
-
-/** Store the corner numbers 0..8 for each tree edge. */
-extern const int    p8est_edge_corners[12][2];
-
-/** Store the edge corner numbers 0..1 for the corners touching a tree edge */
-extern const int    p8est_edge_edge_corners[12][8];
-
-/** Store the face corner numbers 0..3 for the faces touching a tree edge. */
-extern const int    p8est_edge_face_corners[12][6][2];
-
-/** Store the face edge numbers 0..3 for the faces touching a tree edge. */
-extern const int    p8est_edge_face_edges[12][6];
-
-/** Store the sets of permutations that occur */
-extern const int    p8est_edge_corner_permutation_sets[2];
-
-/** Store the two possible permutations that occur */
-extern const int    p8est_edge_corner_permutations[2][2];
-
-/** Store the face numbers 0..5 for each tree corner. */
-extern const int    p8est_corner_faces[8][3];
-
-/** Store the edge numbers 0..11 for each tree corner. */
-extern const int    p8est_corner_edges[8][3];
-
-/** Store the face corner numbers for the faces touching a tree corner. */
-extern const int    p8est_corner_face_corners[8][6];
-
-/** Store the edge corner numbers for the edges touching a tree corner. */
-extern const int    p8est_corner_edge_corners[8][12];
-
-/** Store the faces for each child and edge, can be -1. */
-extern const int    p8est_child_edge_faces[8][12];
-
-/** Store the faces for each child and corner, can be -1. */
-extern const int    p8est_child_corner_faces[8][8];
-
-/** Store the edges for each child and corner, can be -1. */
-extern const int    p8est_child_corner_edges[8][8];
-
-/** Transform a corner across one of the adjacent faces into a neighbor tree.
- * It expects a face permutation index that has been precomputed.
- * \param [in] c    A corner number in 0..7.
- * \param [in] f    A face number that touches the corner \a c.
- * \param [in] nf   A neighbor face that is on the other side of \f.
- * \param [in] set  A value from \a p8est_face_permutation_sets that is
- *                  obtained using \a f, \a nf, and a valid orientation:
- *                  ref = p8est_face_permutation_refs[f][nf];
- *                  set = p8est_face_permutation_sets[ref][orientation];
- * \return          The corner number in 0..7 seen from the other face.
- */
-int                 p8est_connectivity_face_neighbor_corner_set
-  (int c, int f, int nf, int set);
-
-/** Transform a face corner across one of the adjacent faces into a neighbor tree.
- * This version expects the neighbor face and orientation separately.
- * \param [in] fc   A face corner number in 0..3.
- * \param [in] f    A face number that touches the corner \a c.
- * \param [in] nf   A neighbor face that is on the other side of \f.
- * \param [in] o    The orientation between tree boundary faces \a f and \nf.
- */
-int                 p8est_connectivity_face_neighbor_face_corner_orientation
-  (int fc, int f, int nf, int o);
-
-/** Transform a corner across one of the adjacent faces into a neighbor tree.
- * This version expects the neighbor face and orientation separately.
- * \param [in] c    A corner number in 0..7.
- * \param [in] f    A face number that touches the corner \a c.
- * \param [in] nf   A neighbor face that is on the other side of \f.
- * \param [in] o    The orientation between tree boundary faces \a f and \nf.
- */
-int                 p8est_connectivity_face_neighbor_corner_orientation
-  (int c, int f, int nf, int o);
-
-/** Transform an edge across one of the adjacent faces into a neighbor tree.
- * This version expects the neighbor face and orientation separately.
- * \param [in] e    A edge number in 0..11.
- * \param [in] f    A face number that touches the edge \a e.
- * \param [in] nf   A neighbor face that is on the other side of \f.
- * \param [in] o    The orientation between tree boundary faces \a f and \nf.
- */
-int                 p8est_connectivity_face_neighbor_edge_orientation
-  (int e, int f, int nf, int o);
-
-/** Transform an edge corner across one of the adjacent edges into a neighbor tree.
- * This version expects the neighbor edge and orientation separately.
- * \param [in] ec    An edge corner number in 0..1.
- * \param [in] e    A edge number that touches the corner \a c.
- * \param [in] ne   A neighbor edge that is on the other side of \e.
- * \param [in] o    The orientation between tree boundary faces \a e and \ne.
- */
-int                 p8est_connectivity_edge_neighbor_edge_corner_orientation
-  (int ec, int e, int ne, int o);
-
-/** Transform a corner across one of the adjacent edges into a neighbor tree.
- * This version expects the neighbor edge and orientation separately.
- * \param [in] c    A corner number in 0..7.
- * \param [in] e    A edge number that touches the corner \a c.
- * \param [in] ne   A neighbor edge that is on the other side of \e.
- * \param [in] o    The orientation between tree boundary faces \a e and \ne.
- */
-int                 p8est_connectivity_edge_neighbor_corner_orientation
-  (int c, int e, int ne, int o);
-
-/** Allocate a connectivity structure.
- * The attribute fields are initialized to NULL.
- * \param [in] num_vertices   Number of total vertices (i.e. geometric points).
- * \param [in] num_trees      Number of trees in the forest.
- * \param [in] num_edges      Number of tree-connecting edges.
- * \param [in] num_ett        Number of total trees in edge_to_tree array.
- * \param [in] num_corners    Number of tree-connecting corners.
- * \param [in] num_ctt        Number of total trees in corner_to_tree array.
- * \return                    A connectivity structure with allocated arrays.
- */
-p8est_connectivity_t *p8est_connectivity_new (p4est_topidx_t num_vertices,
-                                              p4est_topidx_t num_trees,
-                                              p4est_topidx_t num_edges,
-                                              p4est_topidx_t num_ett,
-                                              p4est_topidx_t num_corners,
-                                              p4est_topidx_t num_ctt);
-
-/** Allocate a connectivity structure and populate from constants.
- * The attribute fields are initialized to NULL.
- * \param [in] num_vertices   Number of total vertices (i.e. geometric points).
- * \param [in] num_trees      Number of trees in the forest.
- * \param [in] num_edges      Number of tree-connecting edges.
- * \param [in] num_corners    Number of tree-connecting corners.
- * \param [in] eoff           Edge-to-tree offsets (num_edges + 1 values).
- *                            This must always be non-NULL; in trivial cases
- *                            it is just a pointer to a p4est_topix value of 0.
- * \param [in] coff           Corner-to-tree offsets (num_corners + 1 values).
- *                            This must always be non-NULL; in trivial cases
- *                            it is just a pointer to a p4est_topix value of 0.
- * \return                    The connectivity is checked for validity.
- */
-p8est_connectivity_t *p8est_connectivity_new_copy (p4est_topidx_t
-                                                   num_vertices,
-                                                   p4est_topidx_t num_trees,
-                                                   p4est_topidx_t num_edges,
-                                                   p4est_topidx_t num_corners,
-                                                   const double *vertices,
-                                                   const p4est_topidx_t * ttv,
-                                                   const p4est_topidx_t * ttt,
-                                                   const int8_t * ttf,
-                                                   const p4est_topidx_t * tte,
-                                                   const p4est_topidx_t *
-                                                   eoff,
-                                                   const p4est_topidx_t * ett,
-                                                   const int8_t * ete,
-                                                   const p4est_topidx_t * ttc,
-                                                   const p4est_topidx_t *
-                                                   coff,
-                                                   const p4est_topidx_t * ctt,
-                                                   const int8_t * ctc);
-
-/** Broadcast a connectivity structure that exists only on one process to all.
- *  On the other processors, it will be allocated using p8est_connectivity_new.
- *  \param [in] conn_in For the root process the connectivity to be broadcast,
- *                      for the other processes it must be NULL.
- *  \param [in] root    The rank of the process that provides the connectivity.
- *  \param [in] comm    The MPI communicator.
- *  \return             For the root process this is a pointer to \a conn_in.
- *                      Else, a pointer to a newly allocated connectivity
- *                      structure with the same values as \a conn_in on the
- *                      root process.
- */
-p8est_connectivity_t *p8est_connectivity_bcast (p8est_connectivity_t *
-                                                conn_in, int root,
-                                                sc_MPI_Comm comm);
-
-/** Destroy a connectivity structure.  Also destroy all attributes.
- */
-void                p8est_connectivity_destroy (p8est_connectivity_t *
-                                                connectivity);
-
-/** Allocate or free the attribute fields in a connectivity.
- * \param [in,out] conn         The conn->*_to_attr fields must either be NULL
- *                              or previously be allocated by this function.
- * \param [in] bytes_per_tree   If 0, tree_to_attr is freed (being NULL is ok).
- *                              If positive, requested space is allocated.
- */
-void                p8est_connectivity_set_attr (p8est_connectivity_t * conn,
-                                                 size_t bytes_per_tree);
-
-/** Examine a connectivity structure.
- * \return  Returns true if structure is valid, false otherwise.
- */
-int                 p8est_connectivity_is_valid (p8est_connectivity_t *
-                                                 connectivity);
-
-/** Check two connectivity structures for equality.
- * \return          Returns true if structures are equal, false otherwise.
- */
-int                 p8est_connectivity_is_equal (p8est_connectivity_t * conn1,
-                                                 p8est_connectivity_t *
-                                                 conn2);
-
-/** Write connectivity to a sink object.
- * \param [in] conn     The connectivity to be written.
- * \param [in,out] sink The connectivity is written into this sink.
- * \return              0 on success, nonzero on error.
- */
-int                 p8est_connectivity_sink (p8est_connectivity_t * conn,
-                                             sc_io_sink_t * sink);
-
-/** Allocate memory and store the connectivity information there.
- * \param [in] conn     The connectivity structure to be exported to memory.
- * \param [in] code     Encoding and compression method for serialization.
- * \return              Newly created array that contains the information.
- */
-sc_array_t         *p8est_connectivity_deflate (p8est_connectivity_t * conn,
-                                                p8est_connectivity_encode_t
-                                                code);
-
-/** Save a connectivity structure to disk.
- * \param [in] filename         Name of the file to write.
- * \param [in] connectivity     Valid connectivity structure.
- * \return                      Returns 0 on success, nonzero on file error.
- */
-int                 p8est_connectivity_save (const char *filename,
-                                             p8est_connectivity_t *
-                                             connectivity);
-
-/** Read connectivity from a source object.
- * \param [in,out] source       The connectivity is read from this source.
- * \return              The newly created connectivity, or NULL on error.
- */
-p8est_connectivity_t *p8est_connectivity_source (sc_io_source_t * source);
-
-/** Create new connectivity from a memory buffer.
- * \param [in] buffer   The connectivity is created from this memory buffer.
- * \return              The newly created connectivity, or NULL on error.
- */
-p8est_connectivity_t *p8est_connectivity_inflate (sc_array_t * buffer);
-
-/** Load a connectivity structure from disk.
- * \param [in] filename         Name of the file to read.
- * \param [out] bytes           Size in bytes of connectivity on disk or NULL.
- * \return              Returns valid connectivity, or NULL on file error.
- */
-p8est_connectivity_t *p8est_connectivity_load (const char *filename,
-                                               size_t * bytes);
-
-/** Create a connectivity structure for the unit cube.
- */
-p8est_connectivity_t *p8est_connectivity_new_unitcube (void);
-
-/** Create a connectivity structure for an all-periodic unit cube.
- */
-p8est_connectivity_t *p8est_connectivity_new_periodic (void);
-
-/** Create a connectivity structure for a mostly periodic unit cube.
- * The left and right faces are identified, and bottom and top rotated.
- * Front and back are not identified.
- */
-p8est_connectivity_t *p8est_connectivity_new_rotwrap (void);
-
-/** Create a connectivity structure that contains two cubes.
- */
-p8est_connectivity_t *p8est_connectivity_new_twocubes (void);
-
-/** Create a connectivity structure for two trees being rotated
- * w.r.t. each other in a user-defined way.
- * \param[in] l_face      index of left face
- * \param[in] r_face      index of right face
- * \param[in] orientation orientation of trees w.r.t. each other
- */
-p8est_connectivity_t *p8est_connectivity_new_twotrees (int l_face,
-                                                       int r_face,
-                                                       int orientation);
-
-/** Create a connectivity structure that contains two cubes
- * where the two far ends are identified periodically.
- */
-p8est_connectivity_t *p8est_connectivity_new_twowrap (void);
-
-/** Create a connectivity structure that contains a few cubes.
- * These are rotated against each other to stress the topology routines.
- */
-p8est_connectivity_t *p8est_connectivity_new_rotcubes (void);
-
-/** An m by n by p array with periodicity in x, y, and z if
- * periodic_a, periodic_b, and periodic_c are true, respectively.
- */
-p8est_connectivity_t *p8est_connectivity_new_brick (int m, int n, int p,
-                                                    int periodic_a,
-                                                    int periodic_b,
-                                                    int periodic_c);
-
-/** Create a connectivity structure that builds a spherical shell.
- * It is made up of six connected parts [-1,1]x[-1,1]x[1,2].
- * This connectivity reuses vertices and relies on a geometry transformation.
- * It is thus not suitable for p8est_connectivity_complete.
- */
-p8est_connectivity_t *p8est_connectivity_new_shell (void);
-
-/** Create a connectivity structure that builds a solid sphere.
- * It is made up of two layers and a cube in the center.
- * This connectivity reuses vertices and relies on a geometry transformation.
- * It is thus not suitable for p8est_connectivity_complete.
- */
-p8est_connectivity_t *p8est_connectivity_new_sphere (void);
-
-/** Create connectivity structure from predefined catalogue.
- * \param [in]  name            Invokes connectivity_new_* function.
- *              brick235        brick (2, 3, 5, 0, 0, 0)
- *              periodic        periodic
- *              rotcubes        rotcubes
- *              rotwrap         rotwrap
- *              shell           shell
- *              sphere          sphere
- *              twocubes        twocubes
- *              twowrap         twowrap
- *              unit            unitcube
- * \return      An initialized connectivity if name is defined, NULL else.
- */
-p8est_connectivity_t *p8est_connectivity_new_byname (const char *name);
-
-/** Uniformly refine a connectivity.
- * This is useful if you would like to uniformly refine by something other
- * than a power of 2.
- *
- * \param [in] conn         a valid connectivity
- * \param [in] num_per_edge the number of new trees in each direction
- *
- * \return a refined connectivity.
- */
-p8est_connectivity_t *p8est_connectivity_refine (p8est_connectivity_t * conn,
-                                                 int num_per_edge);
-
-/** Fill an array with the axis combination of a face neighbor transform.
- * \param [in]  iface       The number of the originating face.
- * \param [in]  nface       Encoded as nface = r * 6 + nf, where nf = 0..5 is
- *                          the neigbbor's connecting face number and r = 0..3
- *                          is the relative orientation to the neighbor's face.
- *                          This encoding matches p8est_connectivity_t.
- * \param [out] ftransform  This array holds 9 integers.
- *              [0]..[2]    The coordinate axis sequence of the origin face,
- *                          the first two referring to the tangentials and the
- *                          third to the normal.  A permutation of (0, 1, 2).
- *              [3]..[5]    The coordinate axis sequence of the target face.
- *              [6]..[8]    Edge reversal flags for tangential axes (boolean);
- *                          face code in [0, 3] for the normal coordinate q:
- *                          0: q' = -q
- *                          1: q' = q + 1
- *                          2: q' = q - 1
- *                          3: q' = 2 - q
- */
-void                p8est_expand_face_transform (int iface, int nface,
-                                                 int ftransform[]);
-
-/** Fill an array with the axis combination of a face neighbor transform.
- * \param [in]  itree       The number of the originating tree.
- * \param [in]  iface       The number of the originating tree's face.
- * \param [out] ftransform  This array holds 9 integers.
- *              [0]..[2]    The coordinate axis sequence of the origin face.
- *              [3]..[5]    The coordinate axis sequence of the target face.
- *              [6]..[8]    Edge reverse flag for axes t1, t2; face code for n.
- * \return                  The face neighbor tree if it exists, -1 otherwise.
- */
-p4est_topidx_t      p8est_find_face_transform (p8est_connectivity_t *
-                                               connectivity,
-                                               p4est_topidx_t itree,
-                                               int iface, int ftransform[]);
-
-/** Fills an array with information about edge neighbors.
- * \param [in] itree    The number of the originating tree.
- * \param [in] iedge    The number of the originating edge.
- * \param [in,out] ei   A p8est_edge_info_t structure with initialized array.
- */
-void                p8est_find_edge_transform (p8est_connectivity_t *
-                                               connectivity,
-                                               p4est_topidx_t itree,
-                                               int iedge,
-                                               p8est_edge_info_t * ei);
-
-/** Fills an array with information about corner neighbors.
- * \param [in] itree    The number of the originating tree.
- * \param [in] icorner  The number of the originating corner.
- * \param [in,out] ci   A p8est_corner_info_t structure with initialized array.
- */
-void                p8est_find_corner_transform (p8est_connectivity_t *
-                                                 connectivity,
-                                                 p4est_topidx_t itree,
-                                                 int icorner,
-                                                 p8est_corner_info_t * ci);
-
-/** Internally connect a connectivity based on tree_to_vertex information.
- * Periodicity that is not inherent in the list of vertices will be lost.
- * \param [in,out] conn     The connectivity needs to have proper vertices
- *                          and tree_to_vertex fields.  The tree_to_tree
- *                          and tree_to_face fields must be allocated
- *                          and satisfy p8est_connectivity_is_valid (conn)
- *                          but will be overwritten.  The edge and corner
- *                          fields will be freed and allocated anew.
- */
-void                p8est_connectivity_complete (p8est_connectivity_t * conn);
-
-/** Removes corner and edge information of a connectivity
- *  such that enough information is left to run p8est_connectivity_complete successfully.
- *  The reduced connectivity still passes p8est_connectivity_is_valid.
- * \param [in,out] conn     The connectivity to be reduced.
- */
-void                p8est_connectivity_reduce (p8est_connectivity_t * conn);
-
-/** p8est_connectivity_permute
- * Given a permutation \a perm of the trees in a connectivity \a conn,
- * permute the trees of \a conn in place and update \a conn to match.
- * \param [in,out] conn                The connectivity whose trees are
- *                                     permuted.
- * \param [in] perm                    A permutation array, whose elements are
- *                                     size_t's.
- * \param [in] is_current_to_new       if true, the jth entry of perm is the
- *                                     new index for the entry whose current
- *                                     index is j, otherwise the jth entry of
- *                                     perm is the current index of the tree
- *                                     whose index will be j after the
- *                                     permutation.
- */
-void                p8est_connectivity_permute (p8est_connectivity_t * conn,
-                                                sc_array_t * perm,
-                                                int is_current_to_new);
-
-#ifdef P4EST_WITH_METIS
-
-/** p8est_connectivity_reorder
- * This function takes a connectivity \a conn and a parameter \a k,
- * which will typically be the number of processes, and reorders the trees
- * such that if every processes is assigned (num_trees / k) trees, the
- * communication volume will be minimized.  This is intended for use with
- * connectivities that contain a large number of trees.  This should be done
- * BEFORE a p8est is created using the connectivity.  This is done in place:
- * any data structures that use indices to refer to trees before this
- * procedure will be invalid.  Note that this routine calls metis and not
- * parmetis because the connectivity is copied on every process.
- * A communicator is required because I'm not positive that metis is
- * deterministic. \a ctype determines when an edge exist between two trees in
- * the dual graph used by metis in the reordering.
- * \param [in]     comm       MPI communicator.
- * \param [in]     k          if k > 0, the number of pieces metis will use to
- *                            guide the reordering; if k = 0, the number of
- *                            pieces will be determined from the MPI
- *                            communicator.
- * \param [in,out] conn       connectivity that will be reordered.
- * \param [in]     ctype      determines when an edge exists in the dual graph
- *                            of the connectivity structure.
- */
-void                p8est_connectivity_reorder (MPI_Comm comm, int k,
-                                                p8est_connectivity_t * conn,
-                                                p8est_connect_type_t ctype);
-
-#endif /* P4EST_WITH_METIS */
-
-/** p8est_connectivity_join_faces
- * This function takes an existing valid connectivity \a conn and modifies it
- * by joining two tree faces that are currently boundary faces.
- * \param [in,out] conn        connectivity that will be altered.
- * \param [in]     tree_left   tree that will be on the left side of the joined
- *                             faces.
- * \param [in]     tree_right  tree that will be on the right side of the
- *                             joined faces.
- * \param [in]     face_left   face of \a tree_left that will be joined.
- * \param [in]     face_right  face of \a tree_right that will be joined.
- * \param [in]     orientation the orientation of \a face_left and
- *                             \a face_right once joined (see the description
- *                             of p8est_connectivity_t to understand
- *                             orientation).
- */
-void                p8est_connectivity_join_faces (p8est_connectivity_t *
-                                                   conn,
-                                                   p4est_topidx_t tree_left,
-                                                   p4est_topidx_t tree_right,
-                                                   int face_left,
-                                                   int face_right,
-                                                   int orientation);
-
-/** p8est_connectivity_is_equivalent
- * This function compares two connectivities for equivalence: it returns
- * \a true if they are the same connectivity, or if they have the same
- * topology.  The definition of topological sameness is strict: there is no
- * attempt made to determine whether permutation and/or rotation of the trees
- * makes the connectivities equivalent.
- *
- * \param[in]      conn1    a valid connectivity
- * \param[out]     conn2    a valid connectivity
- */
-int                 p8est_connectivity_is_equivalent (p8est_connectivity_t *
-                                                      conn1,
-                                                      p8est_connectivity_t *
-                                                      conn2);
-
-/** Return a pointer to a p8est_edge_transform_t array element. */
-/*@unused@*/
-static inline p8est_edge_transform_t *
-p8est_edge_array_index (sc_array_t * array, size_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p8est_edge_transform_t));
-  P4EST_ASSERT (it < array->elem_count);
-
-  return (p8est_edge_transform_t *) (array->array +
-                                     sizeof (p8est_edge_transform_t) * it);
-}
-
-/** Return a pointer to a p8est_corner_transform_t array element. */
-/*@unused@*/
-static inline p8est_corner_transform_t *
-p8est_corner_array_index (sc_array_t * array, size_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p8est_corner_transform_t));
-  P4EST_ASSERT (it < array->elem_count);
-
-  return
-    (p8est_corner_transform_t *) (array->array +
-                                  sizeof (p8est_corner_transform_t) * it);
-}
-
-/** Read an ABAQUS input file from a file stream.
- *
- * This utility function reads a basic ABAQUS file supporting element type with
- * the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as
- * bilinear quadrilateral and trilinear hexahedral trees respectively.
- *
- * A basic 2D mesh is given below.  The \c *Node section gives the vertex
- * number and x, y, and z components for each vertex.  The \c *Element section
- * gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter
- * clockwise order. So in 2D the nodes are given as:
- *
- *   4                     3
- *   +-------------------+
- *   |                   |
- *   |                   |
- *   |                   |
- *   |                   |
- *   |                   |
- *   |                   |
- *   +-------------------+
- *   1                   2
- *
- * and in 3D they are given as:
- *
- * 8                     7
- *  +---------------------+
- *  |\                    |\
- *  | \                   | \
- *  |  \                  |  \
- *  |   \                 |   \
- *  |   5+---------------------+6
- *  |    |                |    |
- *  +----|----------------+    |
- *  4\   |               3 \   |
- *    \  |                  \  |
- *     \ |                   \ |
- *      \|                    \|
- *       +---------------------+
- *       1                     2
- *
- * \code
- * *Heading
- *  box.inp
- * *Node
- *     1,    5,   -5,    5
- *     2,    5,    5,    5
- *     3,    5,    0,    5
- *     4,   -5,    5,    5
- *     5,    0,    5,    5
- *     6,   -5,   -5,    5
- *     7,   -5,    0,    5
- *     8,    0,   -5,    5
- *     9,    0,    0,    5
- *    10,    5,    5,   -5
- *    11,    5,   -5,   -5
- *    12,    5,    0,   -5
- *    13,   -5,   -5,   -5
- *    14,    0,   -5,   -5
- *    15,   -5,    5,   -5
- *    16,   -5,    0,   -5
- *    17,    0,    5,   -5
- *    18,    0,    0,   -5
- *    19,   -5,   -5,    0
- *    20,    5,   -5,    0
- *    21,    0,   -5,    0
- *    22,   -5,    5,    0
- *    23,   -5,    0,    0
- *    24,    5,    5,    0
- *    25,    0,    5,    0
- *    26,    5,    0,    0
- *    27,    0,    0,    0
- * *Element, type=C3D8, ELSET=EB1
- *     1,       6,      19,      23,       7,       8,      21,      27,       9
- *     2,      19,      13,      16,      23,      21,      14,      18,      27
- *     3,       7,      23,      22,       4,       9,      27,      25,       5
- *     4,      23,      16,      15,      22,      27,      18,      17,      25
- *     5,       8,      21,      27,       9,       1,      20,      26,       3
- *     6,      21,      14,      18,      27,      20,      11,      12,      26
- *     7,       9,      27,      25,       5,       3,      26,      24,       2
- *     8,      27,      18,      17,      25,      26,      12,      10,      24
- * \endcode
- *
- * This code can be called two ways.  The first, when \c vertex==NULL and \c
- * tree_to_vertex==NULL, is used to count the number of trees and vertices in
- * the connectivity to be generated by the \c .inp mesh in the \a stream.  The
- * second, when \c vertices!=NULL and \c tree_to_vertex!=NULL, fill \c vertices
- * and \c tree_to_vertex.  In this case \c num_vertices and \c num_trees need
- * to be set to the maximum number of entries allocated in \c vertices and \c
- * tree_to_vertex.
- *
- * \param[in,out]  stream         file stream to read the connectivity from
- * \param[in,out]  num_vertices   the number of vertices in the connectivity
- * \param[in,out]  num_trees      the number of trees in the connectivity
- * \param[out]     vertices       the list of \c vertices of the connectivity
- * \param[out]     tree_to_vertex the \c tree_to_vertex map of the connectivity
- *
- * \returns 0 if successful and nonzero if not
- */
-
-int                 p8est_connectivity_read_inp_stream (FILE * stream,
-                                                        p4est_topidx_t *
-                                                        num_vertices,
-                                                        p4est_topidx_t *
-                                                        num_trees,
-                                                        double *vertices,
-                                                        p4est_topidx_t *
-                                                        tree_to_vertex);
-
-/** Create a p4est connectivity from an ABAQUS input file.
- *
- * This utility function reads a basic ABAQUS file supporting element type with
- * the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as
- * bilinear quadrilateral and trilinear hexahedral trees respectively.
- *
- * A basic 2D mesh is given below.  The \c *Node section gives the vertex
- * number and x, y, and z components for each vertex.  The \c *Element section
- * gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter
- * clockwise order. So in 2D the nodes are given as:
- *
- *   4                     3
- *   +-------------------+
- *   |                   |
- *   |                   |
- *   |                   |
- *   |                   |
- *   |                   |
- *   |                   |
- *   +-------------------+
- *   1                   2
- *
- * and in 3D they are given as:
- *
- * 8                     7
- *  +---------------------+
- *  |\                    |\
- *  | \                   | \
- *  |  \                  |  \
- *  |   \                 |   \
- *  |   5+---------------------+6
- *  |    |                |    |
- *  +----|----------------+    |
- *  4\   |               3 \   |
- *    \  |                  \  |
- *     \ |                   \ |
- *      \|                    \|
- *       +---------------------+
- *       1                     2
- *
- * \code
- * *Heading
- *  box.inp
- * *Node
- *     1,    5,   -5,    5
- *     2,    5,    5,    5
- *     3,    5,    0,    5
- *     4,   -5,    5,    5
- *     5,    0,    5,    5
- *     6,   -5,   -5,    5
- *     7,   -5,    0,    5
- *     8,    0,   -5,    5
- *     9,    0,    0,    5
- *    10,    5,    5,   -5
- *    11,    5,   -5,   -5
- *    12,    5,    0,   -5
- *    13,   -5,   -5,   -5
- *    14,    0,   -5,   -5
- *    15,   -5,    5,   -5
- *    16,   -5,    0,   -5
- *    17,    0,    5,   -5
- *    18,    0,    0,   -5
- *    19,   -5,   -5,    0
- *    20,    5,   -5,    0
- *    21,    0,   -5,    0
- *    22,   -5,    5,    0
- *    23,   -5,    0,    0
- *    24,    5,    5,    0
- *    25,    0,    5,    0
- *    26,    5,    0,    0
- *    27,    0,    0,    0
- * *Element, type=C3D8, ELSET=EB1
- *     1,       6,      19,      23,       7,       8,      21,      27,       9
- *     2,      19,      13,      16,      23,      21,      14,      18,      27
- *     3,       7,      23,      22,       4,       9,      27,      25,       5
- *     4,      23,      16,      15,      22,      27,      18,      17,      25
- *     5,       8,      21,      27,       9,       1,      20,      26,       3
- *     6,      21,      14,      18,      27,      20,      11,      12,      26
- *     7,       9,      27,      25,       5,       3,      26,      24,       2
- *     8,      27,      18,      17,      25,      26,      12,      10,      24
- * \endcode
- *
- * This function reads a mesh from \a filename and returns an associated p4est
- * connectivity.
- *
- * \param[in]  filename         file to read the connectivity from
- *
- * \returns an allocated connectivity associated with the mesh in \a filename
- */
-p8est_connectivity_t *p8est_connectivity_read_inp (const char *filename);
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_CONNECTIVITY_H */
diff --git a/OctreeRefinement/include/p8est_extended.h b/OctreeRefinement/include/p8est_extended.h
deleted file mode 100644
index 6a1e1a7..0000000
--- a/OctreeRefinement/include/p8est_extended.h
+++ /dev/null
@@ -1,401 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/********************************************************************
- *                          IMPORTANT NOTE                          *
- *                                                                  *
- * These interfaces are intended for those who like finer control.  *
- * The API offers extended versions of some basic p4est functions.  *
- * The API may change without notice.                               *
- ********************************************************************/
-
-/** \file p8est_extended.h
- *
- * Interface routines with extended capabilities.
- *
- * \ingroup p8est
- */
-
-#ifndef P8EST_EXTENDED_H
-#define P8EST_EXTENDED_H
-
-#include <p8est.h>
-#include <p8est_mesh.h>
-#include <p8est_iterate.h>
-#include <p8est_lnodes.h>
-
-SC_EXTERN_C_BEGIN;
-
-/* Data pertaining to selecting, inspecting, and profiling algorithms.
- * A pointer to this structure is hooked into the p8est main structure.
- *
- * TODO: Describe the purpose of various switches, counters, and timings.
- *
- * The balance_ranges and balance_notify* times are collected
- * whenever an inspect structure is present in p8est.
- */
-struct p8est_inspect
-{
-  /** Use sc_ranges to determine the asymmetric communication pattern.
-   * If \a use_balance_ranges is false (the default), sc_notify is used. */
-  int                 use_balance_ranges;
-  /** If true, call both sc_ranges and sc_notify and verify consistency.
-   * Which is actually used is still determined by \a use_balance_ranges. */
-  int                 use_balance_ranges_notify;
-  /** Verify sc_ranges and/or sc_notify as applicable. */
-  int                 use_balance_verify;
-  /** If positive and smaller than p8est_num ranges, overrides it */
-  int                 balance_max_ranges;
-  size_t              balance_A_count_in;
-  size_t              balance_A_count_out;
-  size_t              balance_comm_sent;
-  size_t              balance_comm_nzpeers;
-  size_t              balance_B_count_in;
-  size_t              balance_B_count_out;
-  size_t              balance_zero_sends[2], balance_zero_receives[2];
-  double              balance_A;
-  double              balance_comm;
-  double              balance_B;
-  double              balance_ranges;   /**< time spent in sc_ranges */
-  double              balance_notify;   /**< time spent in sc_notify */
-  /** time spent in sc_notify_allgather */
-  double              balance_notify_allgather;
-  int                 use_B;
-};
-
-/** Callback function prototype to replace one set of quadrants with another.
- *
- * This is used by extended routines when the quadrants of an existing, valid
- * p8est are changed.  The callback allows the user to make changes to newly
- * initialized quadrants before the quadrants that they replace are destroyed.
- *
- * \param [in] num_outgoing The number of outgoing quadrants.
- * \param [in] outgoing     The outgoing quadrants: after the callback, the
- *                          user_data, if \a p8est->data_size is nonzero,
- *                          will be destroyed.
- * \param [in] num_incoming The number of incoming quadrants.
- * \param [in,out] incoming The incoming quadrants: prior to the callback,
- *                          the user_data, if \a p8est->data_size is nonzero,
- *                          is allocated, and the p8est_init_t callback,
- *                          if it has been provided, will be called.
- *
- * If the mesh is being refined, num_outgoing will be 1 and num_incoming will
- * be 8, and vice versa if the mesh is being coarsened.
- */
-typedef void        (*p8est_replace_t) (p8est_t * p8est,
-                                        p4est_topidx_t which_tree,
-                                        int num_outgoing,
-                                        p8est_quadrant_t * outgoing[],
-                                        int num_incoming,
-                                        p8est_quadrant_t * incoming[]);
-
-/** Create a new forest.
- * This is a more general form of p8est_new.
- * See the documentation of p8est_new for basic usage.
- *
- * \param [in] min_quadrants    Minimum initial quadrants per processor.
- *                              Makes the refinement pattern mpisize-specific.
- * \param [in] min_level        The forest is refined at least to this level.
- *                              May be negative or 0, then it has no effect.
- * \param [in] fill_uniform     If true, fill the forest with a uniform mesh
- *                              instead of the coarsest possible one.
- *                              The latter is partition-specific so that
- *                              is usually not a good idea.
- */
-p8est_t            *p8est_new_ext (sc_MPI_Comm mpicomm,
-                                   p8est_connectivity_t * connectivity,
-                                   p4est_locidx_t min_quadrants,
-                                   int min_level, int fill_uniform,
-                                   size_t data_size, p8est_init_t init_fn,
-                                   void *user_pointer);
-
-/** Create a new mesh.
- * \param [in] p8est                A forest that is fully 2:1 balanced.
- * \param [in] ghost                The ghost layer created from the
- *                                  provided p4est.
- * \param [in] compute_tree_index   Boolean to decide whether to allocate and
- *                                  compute the quad_to_tree list.
- * \param [in] compute_level_lists  Boolean to decide whether to compute the
- *                                  level lists in quad_level.
- * \param [in] btype                Currently ignored, only face neighbors
- *                                  are stored.
- * \return                          A fully allocated mesh structure.
- */
-p8est_mesh_t       *p8est_mesh_new_ext (p8est_t * p4est,
-                                        p8est_ghost_t * ghost,
-                                        int compute_tree_index,
-                                        int compute_level_lists,
-                                        p8est_connect_type_t btype);
-
-/** Make a deep copy of a p8est.
- * The connectivity is not duplicated.
- * Copying of quadrant user data is optional.
- * If old and new data sizes are 0, the user_data field is copied regardless.
- * The inspect member of the copy is set to NULL.
- * The revision counter of the copy is set to zero.
- *
- * \param [in]  copy_data  If true, data are copied.
- *                         If false, data_size is set to 0.
- * \param [in]  duplicate_mpicomm  If true, MPI communicator is copied.
- * \return  Returns a valid p8est that does not depend on the input,
- *                         except for borrowing the same connectivity.
- *                         Its revision counter is 0.
- */
-p8est_t            *p8est_copy_ext (p8est_t * input, int copy_data,
-                                    int duplicate_mpicomm);
-
-/** Refine a forest with a bounded refinement level and a replace option.
- * \param [in,out] p8est The forest is changed in place.
- * \param [in] refine_recursive Boolean to decide on recursive refinement.
- * \param [in] maxlevel   Maximum allowed refinement level (inclusive).
- *                        If this is negative the level is restricted only
- *                        by the compile-time constant QMAXLEVEL in p8est.h.
- * \param [in] refine_fn  Callback function that must return true if a quadrant
- *                        shall be refined.  If refine_recursive is true,
- *                        refine_fn is called for every existing and newly
- *                        created quadrant.  Otherwise, it is called for every
- *                        existing quadrant.  It is possible that a refinement
- *                        request made by the callback is ignored.  To catch
- *                        this case, you can examine whether init_fn or
- *                        replace_fn gets called.
- * \param [in] init_fn    Callback function to initialize the user_data for
- *                        newly created quadrants, which is guaranteed to be
- *                        allocated.  This function pointer may be NULL.
- * \param [in] replace_fn Callback function that allows the user to change
- *                        incoming quadrants based on the quadrants they
- *                        replace; may be NULL.
- */
-void                p8est_refine_ext (p8est_t * p8est,
-                                      int refine_recursive, int maxlevel,
-                                      p8est_refine_t refine_fn,
-                                      p8est_init_t init_fn,
-                                      p8est_replace_t replace_fn);
-
-/** Coarsen a forest.
- * \param [in,out] p8est The forest is changed in place.
- * \param [in] coarsen_recursive Boolean to decide on recursive coarsening.
- * \param [in] callback_orphans Boolean to enable calling coarsen_fn even on
- *                        non-families.  In this case, the second quadrant
- *                        pointer in the argument list of the callback is NULL,
- *                        subsequent pointers are undefined, and the return
- *                        value is ignored.  If coarsen_recursive is true, it
- *                        is possible that a quadrant is called once or more as
- *                        an orphan and eventually becomes part of a family.
- * \param [in] coarsen_fn Callback function that returns true if a
- *                        family of quadrants shall be coarsened.
- * \param [in] init_fn    Callback function to initialize the user_data
- *                        which is already allocated automatically.
- * \param [in] replace_fn Callback function that allows the user to change
- *                        incoming quadrants based on the quadrants they
- *                        replace.
- */
-void                p8est_coarsen_ext (p8est_t * p8est, int coarsen_recursive,
-                                       int callback_orphans,
-                                       p8est_coarsen_t coarsen_fn,
-                                       p8est_init_t init_fn,
-                                       p8est_replace_t replace_fn);
-
-/** 2:1 balance the size differences of neighboring elements in a forest.
- * \param [in,out] p8est  The p8est to be worked on.
- * \param [in] btype      Balance type (face, edge, or corner/full).
- *                        Corner balance is almost never required when
- *                        discretizing a PDE; just causes smoother mesh grading.
- * \param [in] init_fn    Callback function to initialize the user_data
- *                        which is already allocated automatically.
- * \param [in] replace_fn Callback function that allows the user to change
- *                        incoming quadrants based on the quadrants they
- *                        replace.
- */
-void                p8est_balance_ext (p8est_t * p8est,
-                                       p8est_connect_type_t btype,
-                                       p8est_init_t init_fn,
-                                       p8est_replace_t replace_fn);
-
-void                p8est_balance_subtree_ext (p8est_t * p8est,
-                                               p8est_connect_type_t btype,
-                                               p4est_topidx_t which_tree,
-                                               p8est_init_t init_fn,
-                                               p8est_replace_t replace_fn);
-
-/** Repartition the forest.
- *
- * The forest is partitioned between processors such that each processor
- * has an approximately equal number of quadrants (or weight).
- *
- * \param [in,out] p8est      The forest that will be partitioned.
- * \param [in]     partition_for_coarsening     If true, the partition
- *                            is modified to allow one level of coarsening.
- * \param [in]     weight_fn  A weighting function or NULL
- *                            for uniform partitioning.
- * \return         The global number of shipped quadrants
- */
-p4est_gloidx_t      p8est_partition_ext (p8est_t * p8est,
-                                         int partition_for_coarsening,
-                                         p8est_weight_t weight_fn);
-
-/** Correct partition to allow one level of coarsening.
- *
- * \param [in] p8est                     forest whose partition is corrected
- * \param [in,out] num_quadrants_in_proc partition that will be corrected
- * \return                               absolute number of moved quadrants
- */
-p4est_gloidx_t      p8est_partition_for_coarsening (p8est_t * p8est,
-                                                    p4est_locidx_t *
-                                                    num_quadrants_in_proc);
-
-/** p8est_iterate_ext adds the option \a remote: if this is false, then it is
- * the same as p8est_iterate; if this is true, then corner/edge callbacks are
- * also called on corners/edges for hanging faces/edges touched by local
- * quadrants.
- */
-void                p8est_iterate_ext (p8est_t * p8est,
-                                       p8est_ghost_t * ghost_layer,
-                                       void *user_data,
-                                       p8est_iter_volume_t iter_volume,
-                                       p8est_iter_face_t iter_face,
-                                       p8est_iter_edge_t iter_edge,
-                                       p8est_iter_corner_t iter_corner,
-                                       int remote);
-
-/** Save the complete connectivity/p8est data to disk.  This is a collective
- * operation that all MPI processes need to call.  All processes write
- * into the same file, so the filename given needs to be identical over
- * all parallel invocations.
- * See p8est_load_ext for information on the autopartition parameter.
- * \param [in] filename    Name of the file to write.
- * \param [in] p8est       Valid forest structure.
- * \param [in] save_data   If true, the element data is saved.
- *                         Otherwise, a data size of 0 is saved.
- * \param [in] save_partition   If false, save file as if 1 core was used.
- *                              If true, save core count and partition.
- *                         Advantage: Partition can be recovered on loading
- *                              with same mpisize and autopartition false.
- *                         Disadvantage: Makes the file depend on mpisize.
- *                  Either way the file can be loaded with autopartition true.
- * \note            Aborts on file errors.
- */
-void                p8est_save_ext (const char *filename, p8est_t * p8est,
-                                    int save_data, int save_partition);
-
-/** Load the complete connectivity/p4est structure from disk.
- * It is possible to load the file with a different number of processors
- * than has been used to write it.  The partition will then be uniform.
- * \param [in] filename         Name of the file to read.
- * \param [in] mpicomm          A valid MPI communicator.
- * \param [in] data_size        Size of data for each quadrant which can be
- *                              zero.  Then user_data_pool is set to NULL.
- *                              If data_size is zero, load_data is ignored.
- * \param [in] load_data        If true, the element data is loaded.  This is
- *                              only permitted if the saved data size matches.
- *                              If false, the stored data size is ignored.
- * \param [in] autopartition    Ignore saved partition and make it uniform.
- * \param [in] broadcasthead    Have only rank 0 read headers and bcast them.
- * \param [in] user_pointer     Assign to the user_pointer member of the p4est
- *                              before init_fn is called the first time.
- * \param [out] connectivity    Connectivity must be destroyed separately.
- * \return          Returns a valid forest structure. A pointer to a valid
- *                  connectivity structure is returned through the last
- *                  argument.
- * \note            Aborts on file errors or invalid file contents.
- */
-p8est_t            *p8est_load_ext (const char *filename, sc_MPI_Comm mpicomm,
-                                    size_t data_size, int load_data,
-                                    int autopartition, int broadcasthead,
-                                    void *user_pointer,
-                                    p8est_connectivity_t ** connectivity);
-
-/** The same as p8est_load_ext, but reading the connectivity/p8est from an
- * open sc_io_source_t stream.
- */
-p8est_t            *p8est_source_ext (sc_io_source_t * src,
-                                      sc_MPI_Comm mpicomm, size_t data_size,
-                                      int load_data, int autopartition,
-                                      int broadcasthead, void *user_pointer,
-                                      p8est_connectivity_t ** connectivity);
-
-/** Create the data necessary to create a PETsc DMPLEX representation of a
- * forest, as well as the accompanying lnodes and ghost layer.  The forest
- * must be at least face balanced (see p4est_balance()).  See
- * test/test_plex2.c for example usage.
- *
- * All arrays should be initialized to hold sizeof (p4est_locidx_t), except
- * for \a out_remotes, which should be initialized to hold
- * (2 * sizeof (p4est_locidx_t)).
- *
- * \param[in]     p8est                 the forest
- * \param[out]    ghost                 the ghost layer
- * \param[out]    lnodes                the lnodes
- * \param[in]     ctype                 the type of adjacency for the overlap
- * \param[in]     overlap               the number of layers of overlap (zero
- *                                      is acceptable)
- * \param[out]    first_local_quad      the local quadrants are assigned
- *                                      contiguous plex indices, starting with
- *                                      this index
- * \param[in,out] out_points_per_dim    filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_cone_sizes        filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_cones             filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_cone_orientations filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_vertex_coords     filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_children          filled with argument for
- *                                      DMPlexSetTree()
- * \param[in,out] out_parents           filled with argument for
- *                                      DMPlexSetTree()
- * \param[in,out] out_childids          filled with argument for
- *                                      DMPlexSetTree()
- * \param[in,out] out_leaves            filled with argument for
- *                                      PetscSFSetGraph()
- * \param[in,out] out_remotes           filled with argument for
- *                                      PetscSFSetGraph()
- * \param[in]     custom_numbering      Whether or use the default numbering
- *                                      (0) of DMPlex child ids or the custom
- *                                      (1).
- */
-void                p8est_get_plex_data_ext (p8est_t * p8est,
-                                             p8est_ghost_t ** ghost,
-                                             p8est_lnodes_t ** lnodes,
-                                             p8est_connect_type_t ctype,
-                                             int overlap,
-                                             p4est_locidx_t *
-                                             first_local_quad,
-                                             sc_array_t * out_points_per_dim,
-                                             sc_array_t * out_cone_sizes,
-                                             sc_array_t * out_cones,
-                                             sc_array_t *
-                                             out_cone_orientations,
-                                             sc_array_t * out_vertex_coords,
-                                             sc_array_t * out_children,
-                                             sc_array_t * out_parents,
-                                             sc_array_t * out_childids,
-                                             sc_array_t * out_leaves,
-                                             sc_array_t * out_remotes,
-                                             int custom_numbering);
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_EXTENDED_H */
diff --git a/OctreeRefinement/include/p8est_geometry.h b/OctreeRefinement/include/p8est_geometry.h
deleted file mode 100644
index 3c664c2..0000000
--- a/OctreeRefinement/include/p8est_geometry.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p8est_geometry.h transforms from vertex frame to physical space.
- *
- * \ingroup p8est
- */
-
-#ifndef P8EST_GEOMETRY_H
-#define P8EST_GEOMETRY_H
-
-#include <p8est_connectivity.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** This object encapsulates a custom geometry transformation. */
-typedef struct p8est_geometry p8est_geometry_t;
-
-/** Forward transformation from the reference unit square to physical space.
- * The physical space "xyz" is user-defined, currently used for VTK output.
- */
-typedef void        (*p8est_geometry_X_t) (p8est_geometry_t * geom,
-                                           p4est_topidx_t which_tree,
-                                           const double abc[3],
-                                           double xyz[3]);
-
-/** Destructor prototype for a user-allocated \a p8est_geometry_t.
- * It is invoked by p8est_geometry_destroy.  If the user chooses to
- * reserve the structure statically, simply don't call p4est_geometry_destroy.
- */
-typedef void        (*p8est_geometry_destroy_t) (p8est_geometry_t * geom);
-
-/** This structure can be created by the user,
- * p4est will never change its contents.
- */
-struct p8est_geometry
-{
-  const char         *name;     /**< User's choice is arbitrary. */
-  void               *user;     /**< User's choice is arbitrary. */
-  p8est_geometry_X_t  X;        /**< Coordinate transformation. */
-  p8est_geometry_destroy_t destroy;     /**< Destructor called by
-                                             p8est_geometry_destroy.  If
-                                             NULL, P4EST_FREE is called. */
-};
-
-/** Can be used to conveniently destroy a geometry structure.
- * The user is free not to call this function at all if they handle the
- * memory of the p8est_geometry_t in their own way.
- */
-void                p8est_geometry_destroy (p8est_geometry_t * geom);
-
-/** Create a geometry structure based on the vertices in a connectivity.
- * The transformation is constructed using trilinear interpolation.
- * \param [in] conn A p8est_connectivity_t with valid vertices.  We do NOT
- *                  take ownership and expect this structure to stay alive.
- * \return          Geometry structure; use with p4est_geometry_destroy.
- */
-p8est_geometry_t   *p8est_geometry_new_connectivity (p8est_connectivity_t *
-                                                     conn);
-
-/** Create a geometry structure for the spherical shell of 24 trees.
- * \param [in] conn Result of p8est_connectivity_new_shell or equivalent.
- *                  We do NOT take ownership and expect it to stay alive.
- * \param [in] R2   The outer radius of the shell.
- * \param [in] R1   The inner radius of the shell.
- * \return          Geometry structure; use with p4est_geometry_destroy.
- */
-p8est_geometry_t   *p8est_geometry_new_shell (p8est_connectivity_t * conn,
-                                              double R2, double R1);
-
-/** Create a geometry structure for the solid sphere of 13 trees.
- * \param [in] conn Result of p8est_connectivity_new_sphere or equivalent.
- *                  We do NOT take ownership and expect it to stay alive.
- * \param [in] R2   The outer radius of the sphere.
- * \param [in] R1   The outer radius of the inner shell.
- * \param [in] R0   The inner radius of the inner shell.
- * \return          Geometry structure; use with p4est_geometry_destroy.
- */
-p8est_geometry_t   *p8est_geometry_new_sphere (p8est_connectivity_t * conn,
-                                               double R2, double R1,
-                                               double R0);
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_GEOMETRY_H */
diff --git a/OctreeRefinement/include/p8est_ghost.h b/OctreeRefinement/include/p8est_ghost.h
deleted file mode 100644
index eb2a362..0000000
--- a/OctreeRefinement/include/p8est_ghost.h
+++ /dev/null
@@ -1,386 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p8est_ghost.h
- *
- * passing quadrants and data to neighboring processes
- *
- * \ingroup p8est
- */
-
-#ifndef P8EST_GHOST_H
-#define P8EST_GHOST_H
-
-#include <p8est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** quadrants that neighbor the local domain */
-typedef struct
-{
-  int                 mpisize;
-  p4est_topidx_t      num_trees;
-  p8est_connect_type_t btype; /**< which neighbors are in the ghost layer */
-
-  /** An array of quadrants which make up the ghost layer around \a
-   * p4est.  Their piggy3 data member is filled with their owner's tree
-   * and local number (cumulative over trees).  Quadrants are ordered in \c
-   * p8est_quadrant_compare_piggy order.  These are quadrants inside the
-   * neighboring tree, i.e., \c p8est_quadrant_is_inside() is true for the
-   * quadrant and the neighboring tree.
-   */
-  sc_array_t          ghosts; /**< array of p8est_quadrant_t type */
-  p4est_locidx_t     *tree_offsets;     /**< num_trees + 1 ghost indices */
-  p4est_locidx_t     *proc_offsets;     /**< mpisize + 1 ghost indices */
-
-  /** An array of local quadrants that touch the parallel boundary from the
-   * inside, i.e., that are ghosts in the perspective of at least one other
-   * processor.  The storage convention is the same as for \c ghosts above.
-   */
-  sc_array_t          mirrors; /**< array of p4est_quadrant_t type */
-  p4est_locidx_t     *mirror_tree_offsets;      /**< num_trees + 1 mirror indices */
-  p4est_locidx_t     *mirror_proc_mirrors;      /**< indices into mirrors grouped by
-                                                   outside processor rank and
-                                                   ascending within each rank */
-  p4est_locidx_t     *mirror_proc_offsets;      /**< mpisize + 1 indices into 
-                                                   mirror_proc_mirrors */
-  p4est_locidx_t     *mirror_proc_fronts;       /**< like mirror_proc_mirrors,
-                                                   but limited to the
-                                                   outermost octants.  This is
-                                                   NULL until
-                                                   p4est_ghost_expand is
-                                                   called */
-  p4est_locidx_t     *mirror_proc_front_offsets;        /**< NULL until
-                                                           p4est_ghost_expand is
-                                                           called */
-}
-p8est_ghost_t;
-
-/** Examine if a ghost structure is valid as desribed above.
- * Test if within a ghost-structure the arrays ghosts and mirrors are in
- * p4est_quadrant_compare_piggy order.
- * Test if local_num in piggy3 data member of the quadrants in ghosts and
- * mirrors are in ascending order (ascending within each rank for ghost).
- *
- * Test if the p4est_locidx_t arrays are in ascending order
- * (for mirror_proc_mirrors ascending within each rank)
- * \param [in] p8est    the forest.
- * \param [in] ghost    Ghost layer structure.
- * \return true if \a ghost is valid
- */
-int                 p8est_ghost_is_valid (p8est_t * p8est,
-                                          p8est_ghost_t * ghost);
-
-/** Calculate the memory usage of the ghost layer.
- * \param [in] ghost    Ghost layer structure.
- * \return              Memory used in bytes.
- */
-size_t              p8est_ghost_memory_used (p8est_ghost_t * ghost);
-
-/** Gets the processor id of a quadrant's owner.
- * The quadrant can lie outside of a tree across faces (and only faces).
- *
- * \param [in] p8est  The forest in which to search for a quadrant.
- * \param [in] treeid The tree to which the quadrant belongs.
- * \param [in] face   Supply a face direction if known, or -1 otherwise.
- * \param [in] q      The quadrant that is being searched for.
- *
- * \return Processor id of the owner
- *                or -1 if the quadrant lies outside of the mesh.
- *
- * \warning Does not work for tree edge or corner neighbors.
- */
-int                 p8est_quadrant_find_owner (p8est_t * p8est,
-                                               p4est_topidx_t treeid,
-                                               int face,
-                                               const p8est_quadrant_t * q);
-
-/** Builds the ghost layer.
- *
- * This will gather the quadrants from each neighboring proc to build one layer
- * of face, edge and corner based ghost elements around the ones they own.
- *
- * \param [in] p8est            The forest for which the ghost layer will be
- *                              generated.
- * \param [in] btype            Which ghosts to include (across face, edge,
- *                              or corner/full).
- * \return                      A fully initialized ghost layer.
- */
-p8est_ghost_t      *p8est_ghost_new (p8est_t * p8est,
-                                     p8est_connect_type_t btype);
-
-/** Frees all memory used for the ghost layer. */
-void                p8est_ghost_destroy (p8est_ghost_t * ghost);
-
-/** Conduct binary search for exact match on a range of the ghost layer.
- * \param [in] ghost            The ghost layer.
- * \param [in] which_proc       The owner of the searched quadrant.  Can be -1.
- * \param [in] which_tree       The tree of the searched quadrant.  Can be -1.
- * \param [in] q                Valid quadrant is searched in the ghost layer.
- * \return                      Offset in the ghost layer, or -1 if not found.
- */
-ssize_t             p8est_ghost_bsearch (p8est_ghost_t * ghost,
-                                         int which_proc,
-                                         p4est_topidx_t which_tree,
-                                         const p8est_quadrant_t * q);
-
-/** Conduct binary search for ancestor on range of the ghost layer.
- * \param [in] ghost            The ghost layer.
- * \param [in] which_proc       The owner of the searched quadrant.  Can be -1.
- * \param [in] which_tree       The tree of the searched quadrant.  Can be -1.
- * \param [in] q                Valid quadrant's ancestor is searched.
- * \return                      Offset in the ghost layer, or -1 if not found.
- */
-ssize_t             p8est_ghost_tree_contains (p8est_ghost_t * ghost,
-                                               int which_proc,
-                                               p4est_topidx_t which_tree,
-                                               const p8est_quadrant_t * q);
-
-/** Checks if quadrant exists in the local forest or the ghost layer.
- *
- * For quadrants across tree boundaries it checks if the quadrant exists
- * across any face, but not across edges or corners.
- *
- * \param [in]  p8est        The forest in which to search for \a q.
- * \param [in]  ghost        The ghost layer in which to search for \a q.
- * \param [in]  treeid       The tree to which \a q belongs.
- * \param [in]  q            The quadrant that is being searched for.
- * \param [in,out] face      On input, face id across which \a q was created.
- *                           On output, the neighbor's face number augmented
- *                           by orientation, so face is in 0..23.
- * \param [in,out] hang      If not NULL, signals that q is bigger than
- *                           the quadrant it came from.  The child id
- *                           of that originating quadrant is passed into hang.
- *                           On output, hang holds the hanging face number
- *                           of \a q that is in contact with its originator.
- * \param [out] owner_rank   Filled with the rank of the owner if it is found
- *                           and undefined otherwise.
- *
- * \return      Returns the local number of \a q if the quadrant exists
- *              in the local forest or in the ghost_layer.  Otherwise,
- *              returns -2 for a domain boundary and -1 if not found.
- */
-p4est_locidx_t      p8est_face_quadrant_exists (p8est_t * p8est,
-                                                p8est_ghost_t * ghost,
-                                                p4est_topidx_t treeid,
-                                                const p8est_quadrant_t * q,
-                                                int *face, int *hang,
-                                                int *owner_rank);
-
-/** Checks if quadrant exists in the local forest or the ghost layer.
- *
- * For quadrants across tree corners it checks if the quadrant exists
- * in any of the corner neighbors, thus it can execute multiple queries.
- *
- * \param [in]  p4est        The forest in which to search for \a q
- * \param [in]  ghost        The ghost layer in which to search for \a q
- * \param [in]  treeid       The tree to which \a q belongs (can be extended).
- * \param [in]  q            The quadrant that is being searched for.
- * \param [in,out] exists_arr Must exist and be of of elem_size = sizeof (int)
- *                           for inter-tree corner cases.  Is resized by this
- *                           function to one entry for each corner search
- *                           and set to true/false depending on its existence
- *                           in the local forest or ghost_layer.
- * \param [in,out] rproc_arr If not NULL is filled with one rank per query.
- * \param [in,out] rquad_arr If not NULL is filled with one quadrant per query.
- *                           Its piggy3 member is defined as well.
- *
- * \return true if the quadrant exists in the local forest or in the
- *                  ghost_layer, and false if doesn't exist in either.
- */
-int                 p8est_quadrant_exists (p8est_t * p8est,
-                                           p8est_ghost_t * ghost,
-                                           p4est_topidx_t treeid,
-                                           const p8est_quadrant_t * q,
-                                           sc_array_t * exists_arr,
-                                           sc_array_t * rproc_arr,
-                                           sc_array_t * rquad_arr);
-
-/** Check a forest to see if it is balanced.
- *
- * This function builds the ghost layer and discards it when done.
- *
- * \param [in] p8est    The p8est to be tested.
- * \param [in] btype    Balance type (face, edge, corner or default, full).
- * \return Returns true if balanced, false otherwise.
- */
-int                 p8est_is_balanced (p8est_t * p8est,
-                                       p8est_connect_type_t btype);
-
-/** Compute the parallel checksum of a ghost layer.
- * \param [in] p8est   The MPI information of this p8est will be used.
- * \param [in] ghost   A ghost layer obtained from the p8est.
- * \return             Parallel checksum on rank 0, 0 otherwise.
- */
-unsigned            p8est_ghost_checksum (p8est_t * p8est,
-                                          p8est_ghost_t * ghost);
-
-/** Transfer data for local quadrants that are ghosts to other processors.
- * Send the data stored in the quadrant's user_data.  This is either the
- * pointer variable itself if \c p8est->data_size is 0, or the content of
- * the referenced memory field if p8est->data_size is positive.
- * \param [in] p8est            The forest used for reference.
- * \param [in] ghost            The ghost layer used for reference.
- * \param [in,out] ghost_data   Pre-allocated contiguous data for all ghost
- *                              quadrants in sequence.  If p8est->data_size is
- *                              0, must at least hold sizeof (void *) bytes for
- *                              each, otherwise p8est->data_size each.
- */
-void                p8est_ghost_exchange_data (p8est_t * p4est,
-                                               p8est_ghost_t * ghost,
-                                               void *ghost_data);
-
-/** Transient storage for asynchronous ghost exchange. */
-typedef struct p8est_ghost_exchange
-{
-  int                 is_custom;        /**< False for p4est_ghost_exchange_data */
-  int                 is_levels;        /**< Are we restricted to levels or not */
-  p8est_t            *p4est;
-  p8est_ghost_t      *ghost;
-  int                 minlevel, maxlevel;       /**< Meaningful with is_levels */
-  size_t              data_size;
-  void               *ghost_data;
-  int                *qactive, *qbuffer;
-  sc_array_t          requests, sbuffers;
-  sc_array_t          rrequests, rbuffers;
-}
-p8est_ghost_exchange_t;
-
-/** Begin an asynchronous ghost data exchange by posting messages.
- * The arguments are identical to p8est_ghost_exchange_data.
- * The return type is always non-NULL and must be passed to
- * p8est_ghost_exchange_data_end to complete the exchange.
- * The ghost data must not be accessed before completion.
- * \param [in,out]  ghost_data  Must stay alive into the completion call.
- * \return          Transient storage for messages in progress.
- */
-p8est_ghost_exchange_t *p8est_ghost_exchange_data_begin
-  (p8est_t * p4est, p8est_ghost_t * ghost, void *ghost_data);
-
-/** Complete an asynchronous ghost data exchange.
- * This function waits for all pending MPI communications.
- * \param [in,out]  Data created ONLY by p8est_ghost_exchange_data_begin.
- *                  It is deallocated before this function returns.
- */
-void                p8est_ghost_exchange_data_end
-  (p8est_ghost_exchange_t * exc);
-
-/** Transfer data for local quadrants that are ghosts to other processors.
- * The data size is the same for all quadrants and can be chosen arbitrarily.
- * \param [in] p8est            The forest used for reference.
- * \param [in] ghost            The ghost layer used for reference.
- * \param [in] data_size        The data size to transfer per quadrant.
- * \param [in] mirror_data      One data pointer per mirror quadrant. 
- * \param [in,out] ghost_data   Pre-allocated contiguous data for all ghosts
- *                              in sequence, which must hold at least \c
- *                              data_size for each ghost.
- */
-void                p8est_ghost_exchange_custom (p8est_t * p4est,
-                                                 p8est_ghost_t * ghost,
-                                                 size_t data_size,
-                                                 void **mirror_data,
-                                                 void *ghost_data);
-
-/** Begin an asynchronous ghost data exchange by posting messages.
- * The arguments are identical to p8est_ghost_exchange_custom.
- * The return type is always non-NULL and must be passed to
- * p8est_ghost_exchange_custom_end to complete the exchange.
- * The ghost data must not be accessed before completion.
- * The mirror data can be safely discarded right after this function returns
- * since it is copied into internal send buffers.
- * \param [in]      mirror_data Not required to stay alive any longer.
- * \param [in,out]  ghost_data  Must stay alive into the completion call.
- * \return          Transient storage for messages in progress.
- */
-p8est_ghost_exchange_t *p8est_ghost_exchange_custom_begin
-  (p8est_t * p4est, p8est_ghost_t * ghost,
-   size_t data_size, void **mirror_data, void *ghost_data);
-
-/** Complete an asynchronous ghost data exchange.
- * This function waits for all pending MPI communications.
- * \param [in,out]  Data created ONLY by p8est_ghost_exchange_custom_begin.
- *                  It is deallocated before this function returns.
- */
-void                p8est_ghost_exchange_custom_end
-  (p8est_ghost_exchange_t * exc);
-
-/** Transfer data for local quadrants that are ghosts to other processors.
- * The data size is the same for all quadrants and can be chosen arbitrarily.
- * This function restricts the transfer to a range of refinement levels.
- * The memory for quadrants outside the level range is not dereferenced.
- * \param [in] p4est            The forest used for reference.
- * \param [in] ghost            The ghost layer used for reference.
- * \param [in] minlevel         Level of the largest quads to be exchanged.
- *                              Use <= 0 for no restriction.
- * \param [in] maxlevel         Level of the smallest quads to be exchanged.
- *                              Use >= P8EST_QMAXLEVEL for no restriction.
- * \param [in] data_size        The data size to transfer per quadrant.
- * \param [in] mirror_data      One data pointer per mirror quadrant as input. 
- * \param [in,out] ghost_data   Pre-allocated contiguous data for all ghosts
- *                              in sequence, which must hold at least \c
- *                              data_size for each ghost.
- */
-void                p8est_ghost_exchange_custom_levels (p8est_t * p8est,
-                                                        p8est_ghost_t * ghost,
-                                                        int minlevel,
-                                                        int maxlevel,
-                                                        size_t data_size,
-                                                        void **mirror_data,
-                                                        void *ghost_data);
-
-/** Begin an asynchronous ghost data exchange by posting messages.
- * The arguments are identical to p8est_ghost_exchange_custom_levels.
- * The return type is always non-NULL and must be passed to
- * p8est_ghost_exchange_custom_levels_end to complete the exchange.
- * The ghost data must not be accessed before completion.
- * The mirror data can be safely discarded right after this function returns
- * since it is copied into internal send buffers.
- * \param [in]      mirror_data Not required to stay alive any longer.
- * \param [in,out]  ghost_data  Must stay alive into the completion call.
- * \return          Transient storage for messages in progress.
- */
-p8est_ghost_exchange_t *p8est_ghost_exchange_custom_levels_begin
-  (p8est_t * p4est, p8est_ghost_t * ghost, int minlevel, int maxlevel,
-   size_t data_size, void **mirror_data, void *ghost_data);
-
-/** Complete an asynchronous ghost data exchange.
- * This function waits for all pending MPI communications.
- * \param [in,out]  Data created ONLY by p8est_ghost_exchange_custom_levels_begin.
- *                  It is deallocated before this function returns.
- */
-void                p8est_ghost_exchange_custom_levels_end
-  (p8est_ghost_exchange_t * exc);
-
-/** Expand the size of the ghost layer and mirrors by one additional layer of
- * adjacency.
- * \param [in] p8est            The forest from which the ghost layer was
- *                              generated.
- * \param [in,out] ghost        The ghost layer to be expanded.
- */
-void                p8est_ghost_expand (p8est_t * p8est,
-                                        p8est_ghost_t * ghost);
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_GHOST_H */
diff --git a/OctreeRefinement/include/p8est_io.h b/OctreeRefinement/include/p8est_io.h
deleted file mode 100644
index e478c32..0000000
--- a/OctreeRefinement/include/p8est_io.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P8EST_IO_H
-#define P8EST_IO_H
-
-#include <p8est.h>
-
-/** Extract processor local quadrants' x y z level data.
- * Optionally extracts the quadrant data as well into a separate array.
- * \param [in] p8est    The forest is not modified.
- * \param [in,out] data If not NULL, pointer to a pointer that will be set
- *                      to a newly allocated array with per-quadrant data.
- *                      Must be NULL if p4est->data_size == 0.
- * \return              An array of type p8est_qcoord_t that contains
- *                      x y z level for each quadrant on this processor.
- *                      The tree information is not extracted.
- */
-sc_array_t         *p8est_deflate_quadrants (p8est_t * p8est,
-                                             sc_array_t ** data);
-
-/** Create a new p4est based on serialized data.
- * Its revision counter is set to zero.
- * See p8est.h and p8est_communication.h for more information on parameters.
- * \param [in] mpicomm       A valid MPI communicator.
- * \param [in] connectivity  This is the connectivity information that
- *                           the forest is built with.  Note that p4est
- *                           does not take ownership of the memory.
- * \param [in] global_first_quadrant First global quadrant on each proc and
- *                           one beyond.  Copied into global_first_quadrant.
- *                           Local count on rank is gfq[rank + 1] - gfq[rank].
- * \param [in] pertree       The cumulative quadrant counts per tree.
- * \param [in] quadrants     Array as returned by p8est_deflate_quadrants.
- * \param [in] data          Array as from p8est_deflate_quadrants or NULL.
- *                           The elem_size of this array informs data_size.
- *                           Its elem_count equals the number of local quads.
- * \param [in] user_pointer  Assign to the user_pointer member of the p4est.
- * \return              The newly created p4est with a zero revision counter.
- */
-p8est_t            *p8est_inflate (sc_MPI_Comm mpicomm,
-                                   p8est_connectivity_t * connectivity,
-                                   const p4est_gloidx_t *
-                                   global_first_quadrant,
-                                   const p4est_gloidx_t * pertree,
-                                   sc_array_t * quadrants, sc_array_t * data,
-                                   void *user_pointer);
-
-#endif /* !P8EST_IO_H */
diff --git a/OctreeRefinement/include/p8est_iterate.h b/OctreeRefinement/include/p8est_iterate.h
deleted file mode 100644
index d39d8ad..0000000
--- a/OctreeRefinement/include/p8est_iterate.h
+++ /dev/null
@@ -1,404 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p8est_iterate.h
- *
- * Iteration over mesh topology via callbacks
- *
- * \ingroup p8est
- */
-
-#ifndef P8EST_ITERATE_H
-#define P8EST_ITERATE_H
-
-#include <p8est.h>
-#include <p8est_ghost.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** The information that is available to the user-defined p8est_iter_volume_t
- * callback function.
- *
- * \a treeid gives the index in \a p4est->trees of the tree to which
- *    \a quad belongs.
- * \a quadid gives the index of \a quad within \a tree's quadrants array.
- */
-typedef struct p8est_iter_volume_info
-{
-  p8est_t            *p4est;
-  p8est_ghost_t      *ghost_layer;
-  p8est_quadrant_t   *quad;    /**< the quadrant of the callback */
-  p4est_locidx_t      quadid;  /**< id in \a quad's tree array (see
-                                    p8est_tree_t) */
-  p4est_topidx_t      treeid;  /**< the tree containing \a quad */
-}
-p8est_iter_volume_info_t;
-
-/** The prototype for a function that p8est_iterate() will execute at every
- * quadrant local to the current process.
- * \param [in] info          information about a quadrant provided to the user
- * \param [in,out] user_data the user context passed to p8est_iterate()
- */
-typedef void        (*p8est_iter_volume_t) (p8est_iter_volume_info_t * info,
-                                            void *user_data);
-
-/** Information about one side of a face in the forest.  If a \a quad is local
- * (\a is_ghost is false), then its \a quadid indexes the tree's quadrant array;
- * otherwise, it indexes the ghosts array. If the face is hanging, then the
- * quadrants are listed in z-order. If a quadrant should be present, but it is
- * not included in the ghost layer, then quad = NULL, is_ghost is true, and
- * quadid = -1.
- */
-typedef struct p8est_iter_face_side
-{
-  p4est_topidx_t      treeid;          /**< the tree on this side */
-  int8_t              face;            /**< which quadrant side the face
-                                            touches */
-  int8_t              is_hanging;      /**< boolean: one full quad (0) or
-                                            four smaller quads (1) */
-  union p8est_iter_face_side_data
-  {
-    struct
-    {
-      int8_t              is_ghost;    /**< boolean: local (0) or ghost (1) */
-      p8est_quadrant_t   *quad;        /**< the actual quadrant */
-      p4est_locidx_t      quadid;      /**< index in tree or ghost array */
-    }
-    full; /**< if \a is_hanging = 0,
-               use is.full to access per-quadrant data */
-    struct
-    {
-      int8_t              is_ghost[4]; /**< boolean: local (0) or ghost (1) */
-      p8est_quadrant_t   *quad[4];     /**< the actual quadrant */
-      p4est_locidx_t      quadid[4];   /**< index in tree or ghost array */
-    }
-    hanging; /**< if \a is_hanging = 1,
-                  use is.hanging to access per-quadrant data */
-  }
-  is;
-}
-p8est_iter_face_side_t;
-
-/** The information that is available to the user-defined p8est_iter_face_t
- * callback.
- *
- * The orientation is 0 if the face is within one tree; otherwise, it is the
- * same as the orientation value between the two trees given in the
- * connectivity.  If the face is on the outside of the forest, then there is
- * only one side.  If tree_boundary is false, the face is on the interior of a
- * tree.  When tree_boundary false, sides[0] contains the lowest z-order
- * quadrant that touches the face.
- * When tree_boundary is true, its value is P8EST_CONNECT_FACE.
- */
-typedef struct p8est_iter_face_info
-{
-  p8est_t            *p4est;
-  p8est_ghost_t      *ghost_layer;
-  int8_t              orientation; /**< the orientation of the sides to each
-                                        other, as in the definition of
-                                        p8est_connectivity_t */
-  int8_t              tree_boundary; /**< boolean: interior face (0),
-                                          boundary face (1) */
-  sc_array_t          sides;    /* array of p8est_iter_face_side_t type */
-}
-p8est_iter_face_info_t;
-
-/** The prototype for a function that p8est_iterate() will execute wherever
- * two quadrants share a face: the face can be a 2:1 hanging face, it does not
- * have to be conformal.
- *
- * \param [in] info          information about a quadrant provided to the user
- * \param [in,out] user_data the user context passed to p8est_iterate()
- *
- * \note the forest must be face balanced for p8est_iterate() to execute a
- * callback function on faces (see p8est_balance()).
- */
-typedef void        (*p8est_iter_face_t) (p8est_iter_face_info_t * info,
-                                          void *user_data);
-
-/* The information that is available to the user-defined p8est_iter_edge_t
- * callback.
- *
- * If a \a quad is local (\a is_ghost is false), then its \a quadid indexes
- * the tree's quadrant array; otherwise, it indexes the ghosts array. If the
- * edge is hanging, then the quadrants are listed in z-order. If an edge is in
- * the interior of a tree, orientation is 0; if an edge is between trees,
- * orientation is the same as edge orientation in the connectivity. If a
- * quadrant should be present, but it is not included in the ghost layer, then
- * quad = NULL, is_ghost is true, and quadid = -1.
-                      *
- * the \a faces field provides some additional information about the local
- * neighborhood: if side[i]->faces[j] == side[k]->faces[l], this indicates that
- * there is a common face between these two sides of the edge.
- */
-typedef struct p8est_iter_edge_side
-{
-  p4est_topidx_t      treeid;          /**< the tree on this side */
-  int8_t              edge;            /**< which quadrant side the edge
-                                            touches */
-  int8_t              orientation; /**< the orientation of each quadrant
-                                        relative to this edge, as in the
-                                        definition of p8est_connectivity_t */
-
-  int8_t              is_hanging;      /**< boolean: one full quad (0) or
-                                            two smaller quads (1) */
-  union p8est_iter_edge_side_data
-  {
-    struct
-    {
-      int8_t              is_ghost;    /**< boolean: local (0) or ghost (1) */
-      p8est_quadrant_t   *quad;        /**< the actual quadrant */
-      p4est_locidx_t      quadid;      /**< index in tree or ghost array */
-    }
-    full; /**< if \a is_hanging = 0,
-               use is.full to access per-quadrant data */
-
-    struct
-    {
-      int8_t              is_ghost[2]; /**< boolean: local (0) or ghost (1) */
-      p8est_quadrant_t   *quad[2];     /**< the actual quadrant */
-      p4est_locidx_t      quadid[2];   /**< index in tree or ghost array */
-    }
-    hanging; /**< if \a is_hanging = 1,
-                  use is.hanging to access per-quadrant data */
-  }
-  is;
-  int8_t              faces[2];
-}
-p8est_iter_edge_side_t;
-
-/** The information about all sides of an edge in the forest.
- * If tree_boundary is false, the edge is on the interior of a tree.
- * When tree_boundary is false, sides[0] contains the lowest z-order quadrant
- * that touches the edge.
- * When tree_boundary is true, its value is P8EST_CONNECT_FACE/EDGE
- * depending on the location of the edge relative to the tree.
- */
-typedef struct p8est_iter_edge_info
-{
-  p8est_t            *p4est;
-  p8est_ghost_t      *ghost_layer;
-  int8_t              tree_boundary;  /**< boolean: interior face (0),
-                                           boundary face (1) */
-  sc_array_t          sides; /**< array of p8est_iter_edge_side_t type */
-}
-p8est_iter_edge_info_t;
-
-/** The prototype for a function that p8est_iterate will execute wherever
- * the edge is an edge of all quadrants that touch it i.e. the callback will
- * not execute on an edge the sits on a hanging face.
- *
- * \param [in] info          information about a quadrant provided to the user
- * \param [in,out] user_data the user context passed to p8est_iterate()
- *
- * \note the forest must be edge balanced for p8est_iterate() to execute a
- * callback function on edges.
- */
-typedef void        (*p8est_iter_edge_t) (p8est_iter_edge_info_t * info,
-                                          void *user_data);
-
-/* Information about one side of a corner in the forest.  If a \a quad is local,
- * then its \a quadid indexes the tree's quadrant array; otherwise, it indexes
- * the ghosts array.
- *
- * the \a faces and \a edges field provides some additional information about
- * the local neighborhood: if side[i]->faces[j] == side[k]->faces[l], this
- * indicates that there is a common face between these two sides of the
- * corner.
- */
-typedef struct p8est_iter_corner_side
-{
-  p4est_topidx_t      treeid;   /**< the tree that contains \a quad */
-  int8_t              corner;   /**< which of the quadrant's corners touches
-                                     this corner */
-  int8_t              is_ghost; /**< boolean: local (0) or ghost (1) */
-  p8est_quadrant_t   *quad;
-  p4est_locidx_t      quadid;   /**< the index in the tree or ghost array */
-  int8_t              faces[3]; /**< internal work data */
-  int8_t              edges[3]; /**< internal work data */
-}
-p8est_iter_corner_side_t;
-
-/** The information that is availalbe to the user-defined p8est_iter_corner_t
- * callback.
- *
- * If tree_boundary is false, the corner is on the interior of a tree.
- * When tree_boundary is false, sides[0] contains the lowest z-order quadrant
- * that touches the corner.
- * When tree_boundary is true, its value is P8EST_CONNECT_FACE/EDGE/CORNER
- * depending on the location of the corner relative to the tree.
- */
-typedef struct p8est_iter_corner_info
-{
-  p8est_t            *p4est;
-  p8est_ghost_t      *ghost_layer;
-  int8_t              tree_boundary; /**< boolean: interior face (0),
-                                           boundary face (1) */
-  sc_array_t          sides; /**< array of p8est_iter_corner_side_t type */
-}
-p8est_iter_corner_info_t;
-
-/** The prototype for a function that p8est_iterate will execute wherever
- * the corner is a corner for all quadrants that touch it
- *
- * i.e. the callback will not execute on a corner that sits on a hanging face
- * or edge.
- *
- * \param [in] info          information about a quadrant provided to the user
- * \param [in,out] user_data the user context passed to p8est_iterate()
- *
- * \note the forest does not need to be corner balanced for p8est_iterate() to
- * execute a callback function at corners, only face and edge balanced.
- */
-typedef void        (*p8est_iter_corner_t) (p8est_iter_corner_info_t * info,
-                                            void *user_data);
-
-/** Execute the user-supplied callback functions at every volume, face, edge
- * and corner in the local forest.
- *
- * The ghost_layer may be NULL. The \a user_data pointer is not touched by
- * p8est_iterate, but is passed to each of the callbacks. Any of the callback
- * functions may be NULL.  The callback functions are interspersed with each
- * other, i.e. some face callbacks will occur between volume callbacks, and
- * some edge callbacks will occur between face callbacks, etc.:
- *
- * 1) volume callbacks occur in the sorted Morton-index order.
- * 2) a face callback is not executed until after the volume callbacks have
- *    been executed for the quadrants that share it.
- * 3) an edge callback is not executed until the face callbacks have been
- *    executed for all faces that touch the edge.
- * 4) a corner callback is not executed until the edge callbacks have been
- *    executed for all edges that touch the corner.
- * 5) it is not always the case that every face callback for a given quadrant
- *    is executed before any of the edge or corner callbacks, and it is not
- *    always the case that every edge callback for a given quadrant is executed
- *    before any of the corner callbacks.
- * 6) callbacks are not executed at faces, edges or corners that only involve
- *    ghost quadrants, i.e. that are not adjacent in the local section of the
- *    forest.
- *
- * \param[in] p4est          the forest
- * \param[in] ghost_layer    optional: when not given, callbacks at the
- *                           boundaries of the local partition cannot provide
- *                           quadrant data about ghost quadrants: missing
- *                           (p8est_quadrant_t *) pointers are set to NULL,
- *                           missing indices are set to -1.
- * \param[in,out] user_data  optional context to supply to each callback
- * \param[in] iter_volume    callback function for every quadrant's interior
- * \param[in] iter_face      callback function for every face between
- *                           quadrants
- * \param[in] iter_edge      callback function for every edge between
- *                           quadrants
- * \param[in] iter_corner    callback function for every corner between
- *                           quadrants
- */
-void                p8est_iterate (p8est_t * p4est,
-                                   p8est_ghost_t * ghost_layer,
-                                   void *user_data,
-                                   p8est_iter_volume_t iter_volume,
-                                   p8est_iter_face_t iter_face,
-                                   p8est_iter_edge_t iter_edge,
-                                   p8est_iter_corner_t iter_corner);
-
-/** Return a pointer to a iter_corner_side array element indexed by a int.
- */
-/*@unused@*/
-static inline p8est_iter_corner_side_t *
-p8est_iter_cside_array_index_int (sc_array_t * array, int it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p8est_iter_corner_side_t));
-  P4EST_ASSERT (it >= 0 && (size_t) it < array->elem_count);
-
-  return (p8est_iter_corner_side_t *)
-    (array->array + sizeof (p8est_iter_corner_side_t) * (size_t) it);
-}
-
-/** Return a pointer to a iter_corner_side array element indexed by a size_t.
- */
-/*@unused@*/
-static inline p8est_iter_corner_side_t *
-p8est_iter_cside_array_index (sc_array_t * array, size_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p8est_iter_corner_side_t));
-  P4EST_ASSERT (it < array->elem_count);
-
-  return (p8est_iter_corner_side_t *)
-    (array->array + sizeof (p8est_iter_corner_side_t) * it);
-}
-
-/** Return a pointer to a iter_edge_side array element indexed by a int.
- */
-/*@unused@*/
-static inline p8est_iter_edge_side_t *
-p8est_iter_eside_array_index_int (sc_array_t * array, int it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p8est_iter_edge_side_t));
-  P4EST_ASSERT (it >= 0 && (size_t) it < array->elem_count);
-
-  return (p8est_iter_edge_side_t *)
-    (array->array + sizeof (p8est_iter_edge_side_t) * (size_t) it);
-}
-
-/** Return a pointer to a iter_edge_side array element indexed by a size_t.
- */
-/*@unused@*/
-static inline p8est_iter_edge_side_t *
-p8est_iter_eside_array_index (sc_array_t * array, size_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p8est_iter_edge_side_t));
-  P4EST_ASSERT (it < array->elem_count);
-
-  return (p8est_iter_edge_side_t *)
-    (array->array + sizeof (p8est_iter_edge_side_t) * it);
-}
-
-/** Return a pointer to a iter_face_side array element indexed by a int.
- */
-/*@unused@*/
-static inline p8est_iter_face_side_t *
-p8est_iter_fside_array_index_int (sc_array_t * array, int it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p8est_iter_face_side_t));
-  P4EST_ASSERT (it >= 0 && (size_t) it < array->elem_count);
-
-  return (p8est_iter_face_side_t *)
-    (array->array + sizeof (p8est_iter_face_side_t) * (size_t) it);
-}
-
-/** Return a pointer to a iter_face_side array element indexed by a size_t.
- */
-/*@unused@*/
-static inline p8est_iter_face_side_t *
-p8est_iter_fside_array_index (sc_array_t * array, size_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p8est_iter_face_side_t));
-  P4EST_ASSERT (it < array->elem_count);
-
-  return (p8est_iter_face_side_t *)
-    (array->array + sizeof (p8est_iter_face_side_t) * it);
-}
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_ITERATE_H */
diff --git a/OctreeRefinement/include/p8est_lnodes.h b/OctreeRefinement/include/p8est_lnodes.h
deleted file mode 100644
index 8208dd4..0000000
--- a/OctreeRefinement/include/p8est_lnodes.h
+++ /dev/null
@@ -1,431 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P8EST_LNODES_H
-#define P8EST_LNODES_H
-
-#include <p8est.h>
-#include <p8est_ghost.h>
-
-SC_EXTERN_C_BEGIN;
-
-typedef int16_t     p8est_lnodes_code_t;
-
-/** Store a parallel numbering of Lobatto points of a given degree > 0.
- *
- * Each element has degree+1 nodes per edge
- * and vnodes = (degree+1)^3 nodes per volume.
- * element_nodes is of dimension vnodes * num_local_elements and lists the
- * nodes of each element in lexicographic yx-order (x varies fastest);
- * element_nodes indexes into the set of local nodes, layed out as follows:
- * local nodes = [<-----owned_count----->|<-----nonlocal_nodes----->]
- *             = [<----------------num_local_nodes----------------->]
- * nonlocal_nodes contains the globally unique numbers for independent nodes
- * that are owned by other processes; for local nodes, the globally unique
- * numbers are given by i + global_offset, where i is the local number.
- * Hanging nodes are always local and don't have a global number.
- * They index the geometrically corresponding independent nodes of a neighbor.
- *
- * Whether nodes are hanging or not is decided based on the element faces and
- * edges. This information is encoded in face_code with one int16_t per
- * element. If no faces or edges are hanging, the value is zero, otherwise the
- * face_code is interpreted by p8est_lnodes_decode.
- *
- * Independent nodes can be shared by multiple MPI ranks.
- * The owner rank of a node is the one from the lowest numbered element
- * on the lowest numbered octree *touching* the node.
- *
- * What is meant by *touching*?
- * A quadrant is said to touch all faces/edges/corners that are incident on it,
- * and by extension all nodes that are contained in those faces/edges/corners.
- *
- *            X      +-----------+
- *             x     |\           \
- *            x      | \           \
- *             . x   |  \           \
- *            x   X  |   +-----------+
- * +-----+     . .   |   |           |
- * |\     \   X   o  +   |           |
- * | +-----+   o .    \  |     p     |
- * + |  q  |      o    \ |           |
- *  \|     |     o      \|           |
- *   +-----+      O      +-----------+
- *
- * In this example degree = 3.  There are 4 nodes that live on the face
- * between q and p, two on each edge and one at each corner of that face.
- * The face is incident on q, so q owns the nodes marked '.' on the face
- * (provided q is from a lower tree or has a lower index than p).
- * The bottom and front edges are incident on q, so q owns its nodes marked
- * 'o' as well.
- * The front lower corner is incident on q, so q owns its node 'O' as
- * well.  The other edges and corners are not incident on q, so q cannot own
- * their nodes, marked 'x' and 'X'.
- *
- * global_owned_count contains the number of independent nodes owned by each
- * process.
- *
- * The sharers array contains items of type p8est_lnodes_rank_t
- * that hold the ranks that own or share independent local nodes.
- * If there are no shared nodes on this processor, it is empty.
- * Otherwise, it is sorted by rank and the current process is included.
- *
- * degree < 0 indicates that the lnodes data structure is being used to number
- * the quadrant boundary object (faces, edge  and corners) rather than the
- * $C^0$ Lobatto nodes:
- *
- * if degree == -1, then one node is assigned per face, and no nodes are
- * assigned per volume, per edge,  or per corner: this numbering can be used
- * for low-order Raviart-Thomas elements.  In this case, vnodes == 6, and the
- * nodes are listed in face-order.
- *
- * if degree == -2, then one node is assigned per face and per edge and no
- * nodes are assigned per volume or per corner.  In this case, vnodes == 18,
- * and the nodes are listed in face-order, followed by edge-order.
- *
- * if degree == -3, then one node is assigned per face, per edge and per
- * corner and no nodes are assigned per volume.  In this case, vnodes == 26,
- * and the nodes are listed in face-order, followed by edge-order, followed by
- * corner-order.
- *
- */
-typedef struct p8est_lnodes
-{
-  sc_MPI_Comm         mpicomm;
-  p4est_locidx_t      num_local_nodes;
-  p4est_locidx_t      owned_count;
-  p4est_gloidx_t      global_offset;
-  p4est_gloidx_t     *nonlocal_nodes;
-  sc_array_t         *sharers;
-  p4est_locidx_t     *global_owned_count;
-
-  int                 degree, vnodes;
-  p4est_locidx_t      num_local_elements;
-  p8est_lnodes_code_t *face_code;
-  p4est_locidx_t     *element_nodes;
-}
-p8est_lnodes_t;
-
-/** The structure stored in the sharers array.
- *
- * shared_nodes is a sorted array of p4est_locidx_t
- * that indexes into local nodes.  The shared_nodes array has a
- * contiguous (or empty) section of nodes owned by the current rank.
- * shared_mine_offset and shared_mine_count identify this section
- * by indexing the shared_nodes array, not the local nodes array.
- * owned_offset and owned_count define the section of local nodes
- * that is owned by the listed rank (the section may be empty).
- * For the current process these coincide with those in p8est_lnodes_t.
- */
-typedef struct p8est_lnodes_rank
-{
-  int                 rank;
-  sc_array_t          shared_nodes;
-  p4est_locidx_t      shared_mine_offset, shared_mine_count;
-  p4est_locidx_t      owned_offset, owned_count;
-}
-p8est_lnodes_rank_t;
-
-/** Decode the face_code into hanging face information.
- *
- * This is mostly for demonstration purposes.  Applications probably will
- * integrate it into their own loop over the face for performance reasons.
- *
- * \param[in] face_code as in the p8est_lnodes_t structure.
- * \param[out] hanging_face: if there are hanging faces or edges,
- *             hanging_face = -1 if the face is not hanging,
- *                          = the corner of the full face that it touches:
- *                            e.g. if face = i and hanging_face[i] =
- *                            j, then the interpolation operator corresponding
- *                            to corner j should be used for that face.
- *             note: not touched if there are no hanging faces or edges.
- * \param[out] hanging_edge: if there are hanging faces or edges,
- *             hanging_edge = -1 if the edge is not hanging,
- *                          =  0 if the edge is the first half of a full edge,
- *                               but neither of the two faces touching the
- *                               edge is hanging,
- *                          =  1 if the edge is the second half of a full edge,
- *                               but neither of the two faces touching the
- *                               edge is hanging,
- *                          =  2 if the edge is the first half of a full edge
- *                               and is on the boundary of a full face,
- *                          =  3 if the edge is the second half of a full edge
- *                               and is on the boundary of a full face,
- *                          =  4 if the edge is in the middle of a full face.
- *                               See the diagram below for clarification.
- *             note: not touched if there are no hanging faces or edges.
- * \return             true if any face or edge is hanging, false otherwise.
- *
- * o...............o  o...............o  +---2---+.......o  o.......+---3---+
- * :               :  :               :  |       |       :  :       |       |
- * :               :  :               :  3   2   4       :  :       4   3   3
- * :               :  :               :  |       |       :  :       |       |
- * +---4---+       :  :       +---4---+  +---4---+       :  :       +---4---+
- * |       |       :  :       |       |  :               :  :               :
- * 2   0   4       :  :       4   1   2  :               :  :               :
- * |       |       :  :       |       |  :               :  :               :
- * +---2---+.......o  o.......+---3---+  o...............o  o...............o
- *
- *                    o                  +-------+
- *                    :                  |\       \
- *                    :                  1 \       \
- *                    :                  |  +-------+
- *                    +-------+          +  |       |
- *                    |\       \         :\ |       |
- *                    0 \       \        : \|       |
- *                    |  +-------+       :  +-------+
- *                    +  |       |       o
- *                     \ |       |
- *                      \|       |
- *                       +-------+
- */
-/*@unused@*/
-static inline int
-p8est_lnodes_decode (p8est_lnodes_code_t face_code, int hanging_face[6],
-                     int hanging_edge[12])
-{
-  P4EST_ASSERT (face_code >= 0);
-
-  if (face_code) {
-    int                 i, j;
-    int16_t             c = face_code & 0x0007;
-    int16_t             cwork;
-    int                 f;
-    int                 e;
-    int16_t             work = face_code >> 3;
-
-    memset (hanging_face, -1, 6 * sizeof (int));
-    memset (hanging_edge, -1, 12 * sizeof (int));
-
-    cwork = c;
-    for (i = 0; i < 3; ++i) {
-      if (work & 0x0001) {
-        f = p8est_corner_faces[c][i];
-        hanging_face[f] = p8est_corner_face_corners[c][f];
-        for (j = 0; j < 4; j++) {
-          e = p8est_face_edges[f][j];
-          hanging_edge[e] = 4;
-        }
-      }
-      work >>= 1;
-    }
-    for (i = 0; i < 3; ++i) {
-      if (work & 0x0001) {
-        e = p8est_corner_edges[c][i];
-        hanging_edge[e] = (hanging_edge[e] == -1) ? 0 : 2;
-        hanging_edge[e] += (int) (cwork & 0x0001);
-      }
-      cwork >>= 1;
-      work >>= 1;
-    }
-    return 1;
-  }
-  else {
-    return 0;
-  }
-}
-
-p8est_lnodes_t     *p8est_lnodes_new (p8est_t * p8est,
-                                      p8est_ghost_t * ghost_layer,
-                                      int degree);
-
-void                p8est_lnodes_destroy (p8est_lnodes_t * lnodes);
-
-/** Partition using weights based on the number of nodes assigned to each
- * element in lnodes
- *
- * \param[in,out] p8est                    the forest to be repartitioned
- * \param[in]     ghost                    the ghost layer
- * \param[in]     degree                   the degree that would be passed to p8est_lnodes_new()
- * \param[in]     partition_for_coarsening whether the partition should allow
- *                                         coarsening (i.e. group siblings who
- *                                         might merge)
- */
-void                p8est_partition_lnodes (p8est_t * p8est,
-                                            p8est_ghost_t * ghost, int degree,
-                                            int partition_for_coarsening);
-
-/** Partition using weights that are broken down by where they reside: in
- * volumes, on faces, on edges, or on corners.
- */
-void                p8est_partition_lnodes_detailed (p8est_t * p4est,
-                                                     p8est_ghost_t * ghost,
-                                                     int nodes_per_volume,
-                                                     int nodes_per_face,
-                                                     int nodes_per_edge,
-                                                     int nodes_per_corner,
-                                                     int
-                                                     partition_for_coarsening);
-
-/** Expand the ghost layer to include the support of all nodes supported on
- * the local partition.
- *
- * \param [in]     p8est        The forest from which the ghost layer was
- *                              generated.
- * \param [in]     lnodes       The nodes to support.
- * \param [in,out] ghost        The ghost layer to be expanded.
- */
-void                p8est_ghost_support_lnodes (p8est_t * p8est,
-                                                p8est_lnodes_t * lnodes,
-                                                p8est_ghost_t * ghost);
-
-/** Expand the ghost layer as in p8est_ghost_expand(), but use node support to
- * define adjacency instead of geometric adjacency.
- *
- * \param [in]     p8est        The forest from which the ghost layer was
- *                              generated.
- * \param [in]     lnodes       The nodes to support.
- * \param [in,out] ghost        The ghost layer to be expanded.
- */
-void                p8est_ghost_expand_by_lnodes (p8est_t * p4est,
-                                                  p8est_lnodes_t * lnodes,
-                                                  p8est_ghost_t * ghost);
-
-/** p8est_lnodes_buffer_t handles the communication of data associated with
- * nodes.
- *
- * \a send_buffers is an array of arrays: one buffer for each process to which
- * the current process sends node-data.  It should not be altered between
- * a shared_*_begin and a shared_*_end call.
- *
- * \a recv_buffers is an array of arrays that is used in lnodes_share_all_*.
- * \a recv_buffers[j] corresponds with lnodes->sharers[j]: it is the same
- * length as \a lnodes->sharers[j]->shared_nodes.  At the completion of
- * lnodes_share_all or lnodes_share_all_end, recv_buffers[j] contains the
- * node-data from the process lnodes->sharers[j]->rank
- * (unless j is the current rank, in which case recv_buffers[j] is empty).
- */
-typedef struct p8est_lnodes_buffer
-{
-  sc_array_t         *requests; /* sc_MPI_Request */
-  sc_array_t         *send_buffers;
-  sc_array_t         *recv_buffers;
-}
-p8est_lnodes_buffer_t;
-
-/** p8est_lnodes_share_owned_begin
- *
- * \a node_data is a user-defined array of arbitrary type, where each entry
- * is associated with the \a lnodes local nodes entry of matching index.
- * For every local nodes entry that is owned by a process
- * other than the current one, the value in the \a node_data array of the
- * owning process is written directly into the \a node_data array of the current
- * process.  Values of \a node_data are not guaranteed to be sent or received
- * until the \a buffer created by p8est_lnodes_share_owned_begin is passed to
- * p8est_lnodes_share_owned_end.
- *
- * To be memory neutral, the \a buffer created by
- * p8est_lnodes_share_owned_begin must be destroying with
- * p8est_lnodes_buffer_destroy (it is not destroyed by
- * p8est_lnodes_share_owned_end).
- */
-p8est_lnodes_buffer_t *p8est_lnodes_share_owned_begin (sc_array_t * node_data,
-                                                       p8est_lnodes_t *
-                                                       lnodes);
-
-void                p8est_lnodes_share_owned_end (p8est_lnodes_buffer_t *
-                                                  buffer);
-
-/** Equivalent to calling p8est_lnodes_share_owned_end directly after
- * p8est_lnodes_share_owned_begin.  Use if there is no local work that can be
- * done to mask the communication cost.
- */
-void                p8est_lnodes_share_owned (sc_array_t * node_data,
-                                              p8est_lnodes_t * lnodes);
-
-/** p8est_lnodes_share_all_begin
- *
- * \a node_data is a user_defined array of arbitrary type, where each entry
- * is associated with the \a lnodes local nodes entry of matching index.
- * For every process that shares an entry with the current one, the value in
- * the \a node_data array of that process is written into a
- * \a buffer->recv_buffers entry as described above.  The user can then perform
- * some arbitrary work that requires the data from all processes that share a
- * node (such as reduce, max, min, etc.).  When the work concludes, the
- * \a buffer should be destroyed with p8est_lnodes_buffer_destroy.
- *
- * Values of \a node_data are not guaranteed to be send, and
- * \a buffer->recv_buffer entries are not guaranteed to be received until
- * the \a buffer created by p8est_lnodes_share_all_begin is passed to
- * p8est_lnodes_share_all_end.
- */
-p8est_lnodes_buffer_t *p8est_lnodes_share_all_begin (sc_array_t * node_data,
-                                                     p8est_lnodes_t * lnodes);
-
-void                p8est_lnodes_share_all_end (p8est_lnodes_buffer_t *
-                                                buffer);
-
-/** Equivalend to calling p8est_lnodes_share_all_end directly after
- * p8est_lnodes_share_all_begin.  Use if there is no local work that can be
- * done to mask the communication cost.
- * \return          A fully initialized buffer that contains the received data.
- *                  After processing this data, the buffer must be freed with
- *                  p8est_lnodes_buffer_destroy.
- */
-p8est_lnodes_buffer_t *p8est_lnodes_share_all (sc_array_t * node_data,
-                                               p8est_lnodes_t * lnodes);
-
-void                p8est_lnodes_buffer_destroy (p8est_lnodes_buffer_t *
-                                                 buffer);
-
-/** Return a pointer to a lnodes_rank array element indexed by a int.
- */
-/*@unused@*/
-static inline p8est_lnodes_rank_t *
-p8est_lnodes_rank_array_index_int (sc_array_t * array, int it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p8est_lnodes_rank_t));
-  P4EST_ASSERT (it >= 0 && (size_t) it < array->elem_count);
-
-  return (p8est_lnodes_rank_t *)
-    (array->array + sizeof (p8est_lnodes_rank_t) * (size_t) it);
-}
-
-/** Return a pointer to a lnodes_rank array element indexed by a size_t.
- */
-/*@unused@*/
-static inline p8est_lnodes_rank_t *
-p8est_lnodes_rank_array_index (sc_array_t * array, size_t it)
-{
-  P4EST_ASSERT (array->elem_size == sizeof (p8est_lnodes_rank_t));
-  P4EST_ASSERT (it < array->elem_count);
-
-  return (p8est_lnodes_rank_t *)
-    (array->array + sizeof (p8est_lnodes_rank_t) * it);
-}
-
-/** Compute the global number of a local node number */
-/*@unused@*/
-static inline       p4est_gloidx_t
-p8est_lnodes_global_index (p8est_lnodes_t * lnodes, p4est_locidx_t lidx)
-{
-  p4est_locidx_t      owned = lnodes->owned_count;
-  P4EST_ASSERT (lidx >= 0 && lidx < lnodes->num_local_nodes);
-
-  return (lidx < owned) ? lnodes->global_offset + lidx :
-    lnodes->nonlocal_nodes[lidx - owned];
-}
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_LNODES */
diff --git a/OctreeRefinement/include/p8est_mesh.h b/OctreeRefinement/include/p8est_mesh.h
deleted file mode 100644
index d3898f1..0000000
--- a/OctreeRefinement/include/p8est_mesh.h
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p8est_mesh.h
- *
- * forest topology in a conventional mesh format
- *
- * \ingroup p8est
- */
-
-#ifndef P8EST_MESH_H
-#define P8EST_MESH_H
-
-#include <p8est_ghost.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** This structure contains complete mesh information on the forest.
- * It stores the locally relevant neighborhood, that is, all locally owned
- * quadrants and one layer of adjacent ghost quadrants and their owners.
- *
- * For each local quadrant, its tree number is stored in quad_to_tree. The
- * quad_to_tree array is NULL by default and can be enabled using
- * p8est_mesh_new_ext.
- * For each ghost quadrant, its owner rank is stored in ghost_to_proc.
- * For each level, an array of local quadrant numbers is stored in quad_level.
- * The quad_level array is NULL by default and can be enabled using
- * p8est_mesh_new_ext.
- *
- * The quad_to_quad list stores one value for each local quadrant's face.
- * This value is in 0..local_num_quadrants-1 for local quadrants, or in
- * local_num_quadrants + (0..ghost_num_quadrants-1) for ghost quadrants.
- * The quad_to_face list has equally many entries which are either:
- * 1. A value of v = 0..23 indicates one same-size neighbor.
- *    This value is decoded as v = r * 6 + nf, where nf = 0..5 is the
- *    neighbor's connecting face number and r = 0..3 is the relative
- *    orientation of the neighbor's face, see p8est_connectivity.h.
- * 2. A value of v = 24..119 indicates a double-size neighbor.
- *    This value is decoded as v = 24 + h * 24 + r * 6 + nf, where
- *    r and nf are as above and h = 0..3 is the number of the subface.
- * 3. A value of v = -24..-1 indicates four half-size neighbors.
- *    In this case the corresponding quad_to_quad index points into the
- *    quad_to_half array which stores four quadrant numbers per index,
- *    and the orientation of the smaller faces follows from 24 + v.
- *    The entries of quad_to_half encode between local and ghost quadrant
- *    in the same way as the quad_to_quad values described above.
- * A quadrant on the boundary of the forest sees itself and its face number.
- *
- * The quad_to_corner list stores corner neighbors that are not face or edge
- * neighbors.  On the inside of a tree, there is precisely one such neighbor
- * per corner.  In this case, its index is encoded as described above for
- * quad_to_quad.  The neighbor's matching corner number is always diagonally
- * opposite.
- *
- * On the inside of an inter-tree face, we have precisely one corner neighbor.
- * If a corner is across an inter-tree edge or corner, then the number of
- * corner neighbors may be any non-negative number.  In all inter-tree cases,
- * the quad_to_corner value is in
- *    local_num_quadrants + local_num_ghosts + [0 .. local_num_corners - 1]
- * where the offset by local quadrants and ghosts is implicitly substracted.
- * It indexes into corner_offset, which encodes a group of corner neighbors.
- * Each group contains the quadrant numbers encoded as usual for quad_to_quad
- * in corner_quad, and the corner number from the neighbor as corner_corner.
- *
- * Intra-tree corners and inter-tree face and corner corners are implemented.
- * Edge inter-tree corners are NOT IMPLEMENTED and are assigned the value -2.
- * Corners with no diagonal neighbor at all are assigned the value -1.
- */
-typedef struct
-{
-  p4est_locidx_t      local_num_quadrants;
-  p4est_locidx_t      ghost_num_quadrants;
-
-  p4est_topidx_t     *quad_to_tree;     /**< tree index for each local quad,
-                                             NULL by default */
-  int                *ghost_to_proc;    /**< processor for each ghost quad */
-
-  p4est_locidx_t     *quad_to_quad;     /**< one index for each of the 6 faces */
-  int8_t             *quad_to_face;     /**< encodes orientation/2:1 status */
-  sc_array_t         *quad_to_half;     /**< stores half-size neighbors */
-  sc_array_t         *quad_level;       /**< stores lists of per-level quads,
-                                             NULL by default */
-
-  /* These members are NULL if the connect_t is not P4EST_CONNECT_CORNER */
-  /* CAUTION: tree-boundary corners not yet implemented */
-  p4est_locidx_t      local_num_corners;        /* tree-boundary corners */
-  p4est_locidx_t     *quad_to_corner;   /* 8 indices for each local quad */
-  sc_array_t         *corner_offset;    /* local_num_corners + 1 entries */
-  sc_array_t         *corner_quad;      /* corner_offset indexes into this */
-  sc_array_t         *corner_corner;    /* and this one too (type int8_t) */
-}
-p8est_mesh_t;
-
-/** This structure can be used as the status of a face neighbor iterator.
-  * It always contains the face and subface of the neighbor to be processed.
-  */
-typedef struct
-{
-  /* forest information */
-  p8est_t            *p4est;
-  p8est_ghost_t      *ghost;
-  p8est_mesh_t       *mesh;
-
-  /* quadrant information */
-  p4est_topidx_t      which_tree;
-  p4est_locidx_t      quadrant_id;      /* tree-local quadrant index */
-  p4est_locidx_t      quadrant_code;    /* 6 * (quadrant_id + tree_offset) */
-
-  /* neighbor information */
-  int                 face;     /* Face number in 0..5. */
-  int                 subface;  /* Hanging neighbor number in 0..3. */
-
-  /* internal information */
-  p4est_locidx_t      current_qtq;
-}
-p8est_mesh_face_neighbor_t;
-
-/** Calculate the memory usage of the mesh structure.
- * \param [in] mesh     Mesh structure.
- * \return              Memory used in bytes.
- */
-size_t              p8est_mesh_memory_used (p8est_mesh_t * mesh);
-
-/** Create a p8est_mesh structure.
- * \param [in] p8est    A forest that is fully 2:1 balanced.
- * \param [in] ghost    The ghost layer created from the provided p4est.
- * \param [in] btype    Determines the highest codimension of neighbors.
- * \return              A fully allocated mesh structure.
- */
-p8est_mesh_t       *p8est_mesh_new (p8est_t * p8est, p8est_ghost_t * ghost,
-                                    p8est_connect_type_t btype);
-
-/** Destroy a p8est_mesh structure.
- * \param [in] mesh     Mesh structure previously created by p8est_mesh_new.
- */
-void                p8est_mesh_destroy (p8est_mesh_t * mesh);
-
-/** Find a quadrant based on its cumulative number in the local forest.
- * \param [in]  p8est           Forest to be worked with.
- * \param [in]  cumulative_id   Cumulative index over all trees of quadrant.
- * \param [in,out] which_tree   If not NULL, the input value can be -1
- *                              or an initial guess for the quadrant's tree
- *                              and output is the tree of returned quadrant.
- * \param [out] quadrant_id     If not NULL, the number of quadrant in tree.
- * \return                      The identified quadrant.
- */
-p8est_quadrant_t   *p8est_mesh_quadrant_cumulative (p8est_t * p8est,
-                                                    p4est_locidx_t
-                                                    cumulative_id,
-                                                    p4est_topidx_t
-                                                    * which_tree,
-                                                    p4est_locidx_t
-                                                    * quadrant_id);
-
-/** Initialize a mesh neighbor iterator by quadrant index.
- * \param [out] mfn         A p8est_mesh_face_neighbor_t to be initialized.
- * \param [in]  which_tree  Tree of quadrant whose neighbors are looped over.
- * \param [in]  quadrant_id Index relative to which_tree of quadrant.
- */
-void                p8est_mesh_face_neighbor_init2 (p8est_mesh_face_neighbor_t
-                                                    * mfn, p8est_t * p8est,
-                                                    p8est_ghost_t * ghost,
-                                                    p8est_mesh_t * mesh,
-                                                    p4est_topidx_t which_tree,
-                                                    p4est_locidx_t
-                                                    quadrant_id);
-
-/** Initialize a mesh neighbor iterator by quadrant pointer.
- * \param [out] mfn         A p8est_mesh_face_neighbor_t to be initialized.
- * \param [in]  which_tree  Tree of quadrant whose neighbors are looped over.
- * \param [in]  quadrant    Pointer to quadrant contained in which_tree.
- */
-void                p8est_mesh_face_neighbor_init (p8est_mesh_face_neighbor_t
-                                                   * mfn, p8est_t * p8est,
-                                                   p8est_ghost_t * ghost,
-                                                   p8est_mesh_t * mesh,
-                                                   p4est_topidx_t which_tree,
-                                                   p8est_quadrant_t
-                                                   * quadrant);
-
-/** Move the iterator forward to loop around neighbors of the quadrant.
- * \param [in,out] mfn      Internal status of the iterator.
- * \param [out]    ntree    If not NULL, the tree number of the neighbor.
- * \param [out]    nquad    If not NULL, the quadrant number within tree.
- *                          For ghosts instead the number in ghost layer.
- * \param [out]    nface    If not NULL, neighbor's face as in p8est_mesh_t.
- * \param [out]    nrank    If not NULL, the owner process of the neighbor.
- * \return                  Either a real quadrant or one from the ghost layer.
- *                          Returns NULL when the iterator is done.
- */
-p8est_quadrant_t   *p8est_mesh_face_neighbor_next (p8est_mesh_face_neighbor_t
-                                                   * mfn,
-                                                   p4est_topidx_t * ntree,
-                                                   p4est_locidx_t * nquad,
-                                                   int *nface, int *nrank);
-
-/** Get the user data for the current face neighbor.
- * \param [in]     mfn           Internal status of the iterator.
- * \param [in]     ghost_data    Data for the ghost quadrants that has been
- *                               synchronized with p4est_ghost_exchange_data.
- * \return                       A pointer to the user data for the current
- *                               neighbor.
- */
-void               *p8est_mesh_face_neighbor_data (p8est_mesh_face_neighbor_t
-                                                   * mfn, void *ghost_data);
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_MESH_H */
diff --git a/OctreeRefinement/include/p8est_nodes.h b/OctreeRefinement/include/p8est_nodes.h
deleted file mode 100644
index 1a1c923..0000000
--- a/OctreeRefinement/include/p8est_nodes.h
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P8EST_NODES_H
-#define P8EST_NODES_H
-
-#include <p8est.h>
-#include <p8est_ghost.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Store an independent node.
- * Keep this in sync with the p8est_t data structure.
- */
-typedef struct p8est_indep
-{
-  p4est_qcoord_t      x, y, z;
-  int8_t              level, pad8;
-  int16_t             pad16;
-  union p4est_indep_data
-  {
-    void               *unused;
-    p4est_topidx_t      which_tree;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      int                 owner_rank;
-    }
-    piggy1;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_topidx_t      from_tree;
-    }
-    piggy_unused2;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_locidx_t      local_num;
-    }
-    piggy3;
-  }
-  p;
-}
-p8est_indep_t;
-
-/** Store a hanging node that depends on two independent nodes.
- * Keep this in sync with the p8est_t data structure.
- */
-typedef struct p8est_hang2
-{
-  p4est_qcoord_t      x, y, z;
-  int8_t              level, pad8;
-  int16_t             pad16;
-  union p8est_hang2_data
-  {
-    void               *unused;
-    p4est_topidx_t      which_tree;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      int                 owner_rank;
-    }
-    piggy_unused1;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_topidx_t      from_tree;
-    }
-    piggy_unused2;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_locidx_t      local_num;
-    }
-    piggy_unused3;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_locidx_t      depends[2];
-    }
-    piggy;
-  }
-  p;
-}
-p8est_hang2_t;
-
-/** Store a hanging node that depends on four independent nodes.
- * Keep this in sync with the p8est_t data structure.
- */
-typedef struct p8est_hang4
-{
-  p4est_qcoord_t      x, y, z;
-  int8_t              level, pad8;
-  int16_t             pad16;
-  union p8est_hang4_data
-  {
-    void               *unused;
-    p4est_topidx_t      which_tree;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      int                 owner_rank;
-    }
-    piggy_unused1;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_topidx_t      from_tree;
-    }
-    piggy_unused2;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_locidx_t      local_num;
-    }
-    piggy_unused3;
-    struct
-    {
-      p4est_topidx_t      which_tree;
-      p4est_locidx_t      depends[4];
-    }
-    piggy;
-  }
-  p;
-}
-p8est_hang4_t;
-
-/** This structure holds complete parallel node information.
- *
- * Nodes are unique and either independent, face or edge hanging.
- * Independent nodes store their owner's tree id in piggy3.which_tree.
- * The index in their owner's ordering is stored in piggy3.local_num.
- * Hanging nodes store their owner's tree id in piggy.which_tree.
- * The numbers of their associated independent nodes are in piggy.depends[].
- *
- * The local_nodes table is of dimension 8 * num_local_quadrants
- * and encodes the node indexes for all corners of all quadrants.  Let
- * ni := indep_nodes.elem_count,
- * fi := face_hangings.elem_count,
- * ei := edge_hangings.elem_count.
- * If for l := local_nodes[k]
- * l >= 0 && l < ni: l indexes into indep_nodes.
- * l >= ni && l < ni + fi: l - ni indexes into face_hangings.
- * l >= ni + fi && l < ni + fi + ei: l - ni - fi indexes into edge_hangings.
- * No other values for l are permitted.
- *
- * The array shared_indeps holds lists of node sharers (not including rank).
- * The entry shared_indeps[i] is of type sc_recycle_array_t
- * and holds the list of nodes with i + 1 sharers.
- * For each independent node, its member pad8 holds the number of sharers
- * and its member pad16 holds the position in the assigned recycle array
- * if this number fits into an int16_t.  If this limit is exceeded, the
- * array shared_offsets is filled with these positions as one p4est_locidx_t
- * per independent node, and all pad16 members are set to -1.  To recognize
- * the latter situation you can check for shared_offsets != NULL.
- *
- * Each processor owns num_owned_indeps of the stored independent nodes.
- * The first independent owned node is at index offset_owned_indeps.
- * The table nonlocal_ranks contains the ranks of all stored non-owned nodes.
- * The table global_owned_indeps holds the number of owned nodes for each rank.
- */
-typedef struct p8est_nodes
-{
-  p4est_locidx_t      num_local_quadrants;
-  p4est_locidx_t      num_owned_indeps, num_owned_shared;
-  p4est_locidx_t      offset_owned_indeps;
-  sc_array_t          indep_nodes;
-  sc_array_t          face_hangings;
-  sc_array_t          edge_hangings;
-  p4est_locidx_t     *local_nodes;
-  sc_array_t          shared_indeps;
-  p4est_locidx_t     *shared_offsets;
-  int                *nonlocal_ranks;
-  p4est_locidx_t     *global_owned_indeps;
-}
-p8est_nodes_t;
-
-/** Create node information.
- * \param [in] ghost    Ghost layer.  If this is NULL, then only
- *                      tree- and processor-local nodes will be matched
- *                      and all others duplicated, all nodes will be
- *                      counted as independent with no sharers, and
- *                      nodes->global_owned_indeps will be NULL;
- *                      this also works for a corner-unbalanced forest,
- *                      but nodes may not be numbered uniquely in this case.
- */
-p8est_nodes_t      *p8est_nodes_new (p8est_t * p8est, p8est_ghost_t * ghost);
-
-/** Destroy node information. */
-void                p8est_nodes_destroy (p8est_nodes_t * nodes);
-
-/** Check node information for internal consistency. */
-int                 p8est_nodes_is_valid (p8est_t * p8est,
-                                          p8est_nodes_t * nodes);
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_NODES_H */
diff --git a/OctreeRefinement/include/p8est_plex.h b/OctreeRefinement/include/p8est_plex.h
deleted file mode 100644
index 26fda37..0000000
--- a/OctreeRefinement/include/p8est_plex.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P8EST_PLEX_H
-#define P8EST_PLEX_H
-
-#include <p8est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Create the data necessary to create a PETsc DMPLEX representation of a
- * forest.  The forest must be at least edge balanced (see p8est_balance()).
- * See test/test_plex2.c for example usage.
- *
- * All arrays should be initialized to hold sizeof (p4est_locidx_t), except
- * for \a out_remotes, which should be initialized to hold
- * (2 * sizeof (p4est_locidx_t)).
- *
- * \param[in]     p8est                 the forest
- * \param[in]     ctype                 the type of adjacency for the overlap
- * \param[in]     overlap               the number of layers of overlap (zero
- *                                      is acceptable)
- * \param[out]    first_local_quad      the local quadrants are assigned
- *                                      contiguous plex indices, starting with
- *                                      this index
- * \param[in,out] out_points_per_dim    filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_cone_sizes        filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_cones             filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_cone_orientations filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_vertex_coords     filled with argument for
- *                                      DMPlexCreateFromDAG()
- * \param[in,out] out_children          filled with argument for
- *                                      DMPlexSetTree()
- * \param[in,out] out_parents           filled with argument for
- *                                      DMPlexSetTree()
- * \param[in,out] out_childids          filled with argument for
- *                                      DMPlexSetTree()
- * \param[in,out] out_leaves            filled with argument for
- *                                      PetscSFSetGraph()
- * \param[in,out] out_remotes           filled with argument for
- *                                      PetscSFSetGraph()
- */
-void                p8est_get_plex_data (p8est_t * p8est,
-                                         p8est_connect_type_t ctype,
-                                         int overlap,
-                                         p4est_locidx_t * first_local_quad,
-                                         sc_array_t * out_points_per_dim,
-                                         sc_array_t * out_cone_sizes,
-                                         sc_array_t * out_cones,
-                                         sc_array_t * out_cone_orientations,
-                                         sc_array_t * out_vertex_coords,
-                                         sc_array_t * out_children,
-                                         sc_array_t * out_parents,
-                                         sc_array_t * out_childids,
-                                         sc_array_t * out_leaves,
-                                         sc_array_t * out_remotes);
-
-SC_EXTERN_C_END;
-#endif /* P4EST_PLEX_H */
diff --git a/OctreeRefinement/include/p8est_points.h b/OctreeRefinement/include/p8est_points.h
deleted file mode 100644
index 42a39e7..0000000
--- a/OctreeRefinement/include/p8est_points.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/********************************************************************
- *                          IMPORTANT NOTE                          *
- *                                                                  *
- * The p4est_points functionality depends on sc/src/sc_sort.        *
- * That parallel bitonic sort is still buggy (see sc/bugs).         *
- * If you want to use this code you have to fix the sort first.     *
- ********************************************************************/
-
-#ifndef P8EST_POINTS_H
-#define P8EST_POINTS_H
-
-#include <p8est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Create a new forest based on a distributed set of points.
- *
- * \param [in] mpicomm       A valid MPI communicator.
- * \param [in] connectivity  This is the connectivity information that
- *                           the forest is built with.  Note the p8est
- *                           does not take ownership of the memory.
- * \param [in] maxlevel      Level of the smallest possible quadrants.
- * \param [in] points        Unsorted collection of clamped quadrant nodes.
- *                           The tree id must be stored in p.which_tree.
- * \param [in] num_points    Number of local points provided in the array.
- * \param [in] max_points    Maximum number of points per quadrant.
- *                           Applies to quadrants above maxlevel, so 0 is ok.
- *                           A value of -1 disables all refinement.
- * \param [in] data_size     This is the size of data for each quadrant which
- *                           can be zero.  Then user_data_pool is set to NULL.
- * \param [in] init_fn       Callback function to initialize the user_data
- *                           which is already allocated automatically.
- * \param [in] user_pointer  Assign to the user_pointer member of the p8est
- *                           before init_fn is called the first time.
- *
- * \return This returns a valid forest.
- *
- * \note The connectivity structure must not be destroyed
- *       during the lifetime of this forest.
- */
-p8est_t            *p8est_new_points (sc_MPI_Comm mpicomm,
-                                      p8est_connectivity_t * connectivity,
-                                      int maxlevel, p8est_quadrant_t * points,
-                                      p4est_locidx_t num_points,
-                                      p4est_locidx_t max_points,
-                                      size_t data_size, p8est_init_t init_fn,
-                                      void *user_pointer);
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_POINTS_H */
diff --git a/OctreeRefinement/include/p8est_search.h b/OctreeRefinement/include/p8est_search.h
deleted file mode 100644
index eb00210..0000000
--- a/OctreeRefinement/include/p8est_search.h
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P8EST_SEARCH_H
-#define P8EST_SEARCH_H
-
-/** \file p8est_search.h
- * Search through quadrants, the local part of a forest, or the partition.
- *
- * This file provides several helper functions and recursive algorithms.
- * \ingroup p8est
- */
-
-#include <p8est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Find the lowest position tq in a quadrant array such that tq >= q.
- * \return  Returns the id of the matching quadrant
- *                  or -1 if not found or the array is empty.
- */
-ssize_t             p8est_find_lower_bound (sc_array_t * array,
-                                            const p8est_quadrant_t * q,
-                                            size_t guess);
-
-/** Find the highest position tq in a quadrant array such that tq <= q.
- * \return  Returns the id of the matching quadrant
- *                  or -1 if not found or the array is empty.
- */
-ssize_t             p8est_find_higher_bound (sc_array_t * array,
-                                             const p8est_quadrant_t * q,
-                                             size_t guess);
-
-/** Given a sorted \b array of quadrants that have a common ancestor at level
- * \b level, compute the \b indices of the first quadrant in each of the common
- * ancestor's children at level \b level + 1.
- * \param [in] array     The sorted array of quadrants of level > \b level.
- * \param [in] level     The level at which there is a common ancestor.
- * \param [in,out] indices     The indices of the first quadrant in each of
- *                             the ancestors's children, plus an additional
- *                             index on the end.  The quadrants of \b array
- *                             that are descendants of child i have indices
- *                             between indices[i] and indices[i + 1] - 1.  If
- *                             indices[i] = indices[i+1], this indicates that
- *                             no quadrant in the array is contained in
- *                             child i.
- */
-void                p8est_split_array (sc_array_t * array, int level,
-                                       size_t indices[]);
-
-/** Find the boundary points touched by a range of quadrants.
- *
- * Given two smallest quadrants, \b lq and \b uq, that mark the first and the
- * last quadrant in a range of quadrants, determine which portions of the tree
- * boundary the range touches.
- * \param [in] lq        The smallest quadrant at the start of the range: if
- *                       NULL, the tree's first quadrant is taken to be the
- *                       start of the range.
- * \param [in] uq        The smallest quadrant at the end of the range: if
- *                       NULL, the tree's last quadrant is taken to be the
- *                       end of the range.
- * \param [in] level     The level of the containing quadrant whose boundaries
- *                       are tested: 0 if we want to test the boundaries of the
- *                       whole tree.
- * \param [in,out] faces       An array of size 6 that is filled: faces[i] is
- *                             true if the range touches that face.
- * \param [in,out] edges       An array of size 12 that is filled: edges[i] is
- *                             true if the range touches that edge.
- * \param [in,out] corners     An array of size 8 that is filled: corners[i] is
- *                             true if the range touches that corner.
- *                             \b faces, \b edges or \b corners may be NULL.
- * \return  Returns an int32_t encoded with the same information in \b faces,
- *          \b edges and \b corners: the first (least) six bits represent the
- *          six faces, the next twelve bits represent the twelve edges, the
- *          next eight bits represent the eight corners.
- */
-int32_t             p8est_find_range_boundaries (p8est_quadrant_t * lq,
-                                                 p8est_quadrant_t * uq,
-                                                 int level, int faces[],
-                                                 int edges[], int corners[]);
-
-/** Callback function to query the match of a "point" with a quadrant.
- *
- * This function can be called in two roles:  Per-quadrant, in which case the
- * parameter \b point is NULL, or per-point, possibly many times per quadrant.
- *
- * \param [in] p8est        The forest to be queried.
- * \param [in] which_tree   The tree id under consideration.
- * \param [in] quadrant     The quadrant under consideration.
- *                          This quadrant may be coarser than the quadrants
- *                          that are contained in the forest (an ancestor), in
- *                          which case it is a temporary variable and not part
- *                          of the forest storage.  Otherwise, it is a leaf and
- *                          points directly into the forest storage.
- * \param [in] local_num    If the quadrant is not a leaf, this is -1.  Otherwise
- *                          it is the (non-negative) index of the quadrant
- *                          relative to the processor-local quadrant storage.
- * \param [in] point        Representation of a "point"; user-defined.
- *                          If \b point is NULL, the callback may be used to
- *                          prepare quadrant-related search meta data.
- * \return                  If \b point is NULL, true if the search confined to
- *                          \b quadrant should be executed, false to skip it.
- *                          Else, true if point may be contained in the
- *                          quadrant and false otherwise; the return value has
- *                          no effect on a leaf.
- */
-typedef int         (*p8est_search_query_t) (p8est_t * p8est,
-                                             p4est_topidx_t which_tree,
-                                             p8est_quadrant_t * quadrant,
-                                             p4est_locidx_t local_num,
-                                             void *point);
-
-/** Search through the local part of a forest.
- * The search is especially efficient if multiple targets, called "points"
- * below, are searched for simultaneously.
- *
- * The search runs over all local quadrants and proceeds recursively top-down.
- * For each tree, it may start at the root of that tree, or further down at the
- * root of the subtree that contains all of the tree's local quadrants.
- * Likewise, some intermediate levels in the recursion may be skipped.
- * Its outer loop is thus a depth-first, processor-local forest traversal.
- * Each quadrant in that loop either is a leaf, or a (direct or indirect)
- * strict ancestor of a leaf.  On entering a new quadrant, a user-provided
- * quadrant-callback is executed.
- *
- * As a convenience, the user may provide anonymous "points" that are tracked
- * down the forest.  This way one search call may be used for multiple targets.
- * The set of points that potentially matches a given quadrant diminishes from
- * the root down to the leaves:  For each quadrant, an inner loop over the
- * potentially matching points executes a point-callback for each candidate
- * that determines whether the point may be a match.  If not, it is discarded
- * immediately, otherwise it is passed to the next finer level.
- * The callback is allowed to return true for the same point and more than one
- * quadrant; in this case more than one matching quadrant may be identified.
- * The callback is also allowed to return false for all children of a quadrant
- * that it returned true for earlier.
- * The points can really be anything, p4est does not perform any
- * interpretation, just passes the pointer along to the callback function.
- *
- * \param [in] p8est        The forest to be searched.
- * \param [in] search_quadrant_fn   Executed once for each quadrant that is
- *                          entered.  This quadrant is always local, if not
- *                          itself than at least one child of it.  If the
- *                          callback returns false, this quadrant and its
- *                          descendants are excluded from the search.
- *                          Its \b point argument is always NULL.
- *                          May be NULL in which case it is ignored.
- * \param [in] search_point_fn      If \b points is not NULL, must be not NULL.
- *                          Must return true for any possible matching point.
- *                          If \b points is NULL, this callback is ignored.
- * \param [in] points       User-defined array of "points".
- *                          If NULL, only the \b search_quadrant_fn callback
- *                          is executed.  If that is NULL, this function noops.
- *                          If not NULL, the \b search_point_fn is called on
- *                          its members during the search.
- */
-void                p8est_search (p8est_t * p8est,
-                                  p8est_search_query_t search_quadrant_fn,
-                                  p8est_search_query_t search_point_fn,
-                                  sc_array_t * points);
-
-/** Callback function for the traversal recursion.
- * \param [in] p8est        The forest to traverse.
- *                          Its local quadrants are never accessed.
- * \param [in] which_tree   The tree number under consideration.
- * \param [in] quadrant     This quadrant is not from local forest storage,
- *                          and its user data is undefined.  It represents
- *                          the branch of the forest in the top-down recursion.
- * \param [in] pfirst       The lowest processor that owns part of \b quadrant.
- *                          Guaranteed to be non-empty.
- * \param [in] plast        The highest processor that owns part of \b quadrant.
- *                          Guaranteed to be non-empty.  If this is equal to
- *                          \b pfirst, then the recursion will stop for
- *                          quadrant's branch after this function returns.
- * \return                  If false, the recursion at quadrant is terminated.
- *                          If true, it continues if \b pfirst < \b plast.
- */
-typedef int         (*p8est_traverse_query_t) (p8est_t * p8est,
-                                               p4est_topidx_t which_tree,
-                                               p8est_quadrant_t * quadrant,
-                                               int pfirst, int plast);
-
-/** Traverse the global partition top-down.
- * We proceed top-down through the partition, identically on all processors
- * except for the results of a user-provided callback.  The recursion will only
- * go down branches that are split between multiple processors.  The callback
- * function can be used to stop a branch recursion even for split branches.
- * \note Traversing the whole processor partition will likely by inefficient,
- *       so sensible use of the callback function is advised.
- * \param [in] p8est        The forest to traverse.
- *                          Its local quadrants are never accessed.
- * \param [in] traverse_fn  This function controls the recursion,
- *                          which only continues deeper if this
- *                          callback returns true for a branch quadrant.
- */
-void                p8est_traverse (p8est_t * p8est,
-                                    p8est_traverse_query_t traverse_fn);
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_SEARCH_H */
diff --git a/OctreeRefinement/include/p8est_tets_hexes.h b/OctreeRefinement/include/p8est_tets_hexes.h
deleted file mode 100644
index 4e041d8..0000000
--- a/OctreeRefinement/include/p8est_tets_hexes.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P8EST_TETS_HEXES_H
-#define P8EST_TETS_HEXES_H
-
-#include <p8est_connectivity.h>
-
-typedef struct p8est_tets
-{
-  /** The node array contains a triplet of double coordinates per node. */
-  sc_array_t         *nodes;
-
-  /** The tet array contains a quartet of p4est_topidx_t nodes per tet. */
-  sc_array_t         *tets;
-
-  /** The element_attributes array can contain one int attribute per tet. */
-  sc_array_t         *tet_attributes;
-}
-p8est_tets_t;
-
-/** Read nodes from a tetgen .node file.
- * \param [in] nodefile     Name of file in tetgen .node format.
- * \return                  An array with three double coordinates per node,
- *                          or NULL on file error.
- */
-sc_array_t         *p8est_tets_read_node (const char *nodefile);
-
-/** Read tetrahedra from a tetgen .ele file.
- * \param [in] elefile          Name of file in tetgen .ele format.
- * \param [in] num_nodes        If nonnegative, (exclusive) upper node number.
- * \param [in,out] attributes   If not NULL, an array will be created
- *                              if the .ele file contains attributes.
- * \return                      An array with four p4est_topidx_t nodes
- *                              per tet, or NULL on file error.
- */
-sc_array_t         *p8est_tets_read_ele (const char *elefile,
-                                         p4est_topidx_t num_nodes,
-                                         sc_array_t ** attributes);
-
-/** Read element and node information from a tetgen base name.
- * The names for element and node files are derived from base name by suffix.
- * \param [in] tetgenbasename   Base name for tetgen files (without suffix).
- * \return                      A populated p8est_tets_t structure
- *                              or NULL on file error.
- */
-p8est_tets_t       *p8est_tets_read (const char *tetgenbasename);
-
-/** Destroy all memory associated with a p8est_tets_t structure.
- * \param [in] ptg          Allocated p8est_tets_t structure.
- */
-void                p8est_tets_destroy (p8est_tets_t * ptg);
-
-/** Change all left-handed tetrahedra to right-handed ones.
- * \param [in,out] ptg      Structure with node and tet information.
- * \return                  The number of tets that were flipped.
- */
-p4est_topidx_t      p8est_tets_make_righthanded (p8est_tets_t * ptg);
-
-/** Create a fully populated connectivity structure from tetgen information.
- * \param [in] ptg  A p8est_tets_t structure with node and tet information.
- *                  If it contains attributes they will be cast with (int8_t).
- * \return          Connectivity (free with p8est_connectivity_destroy).
- */
-p8est_connectivity_t *p8est_connectivity_new_tets (p8est_tets_t * ptg);
-
-#endif /* !P8EST_TETS_HEXES */
diff --git a/OctreeRefinement/include/p8est_vtk.h b/OctreeRefinement/include/p8est_vtk.h
deleted file mode 100644
index 24988a9..0000000
--- a/OctreeRefinement/include/p8est_vtk.h
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-/** \file p8est_vtk.h
- *
- * Routines for printing a forest and associated fields to VTK format.
- *
- * \ingroup p8est
- */
-
-#ifndef P8EST_VTK_H
-#define P8EST_VTK_H
-
-#include <p8est_geometry.h>
-#include <p8est.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Opaque context type for writing VTK output with multiple function calls.
- */
-typedef struct p8est_vtk_context p8est_vtk_context_t;
-
-/** Write the p8est in VTK format.
- *
- * This is a convenience function for the special case of writing out
- * the tree id, quadrant level, and MPI rank only.
- * One file is written per MPI rank, and one meta file on rank 0.
- * The quadrants are scaled to length .95; see \ref p8est_vtk_write_header.
- * This function will abort if there is a file error.
- *
- * \param [in] p8est    The p8est to be written.
- * \param [in] geom     A p8est_geometry_t structure or NULL for vertex space
- *                      as defined by p8est->connectivity.
- * \param [in] filename The first part of the file name which will have the
- *                      MPI rank appended to it: The output file will be
- *                      filename_rank.vtu, and the meta file filename.pvtu.
- */
-void                p8est_vtk_write_file (p8est_t * p8est,
-                                          p8est_geometry_t * geom,
-                                          const char *filename);
-
-/** The first call to write a VTK file using individual functions.
- *
- * Writing a VTK file is split into multiple functions that keep a context.
- * This is the first function that allocates the opaque context structure.
- * After allocation, further parameters can be set for the context.
- * Then, the header, possible data fields, and the footer must be written.
- * The process can be aborted any time by destroying the context.  In this
- * case, open files are closed cleanly with only partially written content.
- *
- * \param p4est     The p8est to be written.
- *                  If no geometry is specified in
- *                  \ref p8est_vtk_context_set_geom, we require
- *                  \b p8est->connectivity to have valid vertex arrays.
- * \param filename  The first part of the name which will have the processor
- *                  number appended to it (i.e., the output file will be
- *                  filename_rank.vtu).  The parallel meta-files for Paraview
- *                  and Visit use this basename too.
- *                  We copy this filename to internal storage, so it is not
- *                  needed to remain alive after calling this function.
- * \return          A VTK context fur further use.
- */
-p8est_vtk_context_t *p8est_vtk_context_new (p8est_t * p4est,
-                                            const char *filename);
-
-/** Modify the geometry transformation registered in the context.
- * After \ref p8est_vtk_context_new, it is at the default NULL.
- * \param [in,out] cont         The context is modified.
- *                              It must not yet have been used to start writing
- *                              in \ref p8est_vtk_write_header.
- * \param geom      A \ref p8est_geometry_t structure, or NULL for vertex space.
- *                  If NULL, \b p8est->connectivity->vertices and
- *                  \b tree_to_vertex must be non-NULL.
- */
-void                p8est_vtk_context_set_geom (p8est_vtk_context_t * cont,
-                                                p8est_geometry_t * geom);
-
-/** Modify the context parameter for scaling the quadrants.
- * After \ref p8est_vtk_context_new, it is at the default 0.95.
- * \param [in,out] cont         The context is modified.
- *                              It must not yet have been used to start writing
- *                              in \ref p8est_vtk_write_header.
- * \param [in] scale            Scale parameter must be in (0, 1].
- */
-void                p8est_vtk_context_set_scale (p8est_vtk_context_t * cont,
-                                                 double scale);
-
-/** Modify the context parameter for expecting continuous point data.
- * If set to true, the point data is understood as a continuous field.
- * In this case, we can significantly reduce the file size when scale == 1.
- * For discontinuous point data, it should be set to false.
- * After \ref p8est_vtk_context_new, it is at the default false.
- * \param [in,out] cont         The context is modified.
- *                              It must not yet have been used to start writing
- *                              in \ref p8est_vtk_write_header.
- * \param [in] continuous       Boolean parameter.
- */
-void                p8est_vtk_context_set_continuous (p8est_vtk_context_t *
-                                                      cont, int continuous);
-/** Cleanly destroy a \ref p8est_vtk_context_t structure.
- *
- * This function closes all the file pointers and frees the context.
- * Tt can be called even if the VTK output
- * has only been partially written, the files' content will be incomplete.
- *
- * \param[in] context     The VTK file context to be destroyed.
- */
-void                p8est_vtk_context_destroy (p8est_vtk_context_t * context);
-
-/** Write the VTK header.
- *
- * Writing a VTK file is split into a few routines.
- * This allows there to be an arbitrary number of
- * fields.  The calling sequence would be something like
- *
- *     vtk_context = p8est_vtk_context_new (p8est, "output");
- *     p8est_vtk_context_set_* (vtk_context, parameter);
- *     vtk_context = p8est_vtk_write_header (vtk_context, ...);
- *     if (vtk_context == NULL) { error; }
- *     vtk_context = p8est_vtk_write_cell_data (vtk_context, ...);
- *     if (vtk_context == NULL) { error; }
- *     vtk_context = p8est_vtk_write_point_data (vtk_context, ...);
- *     if (vtk_context == NULL) { error; }
- *     retval = p8est_vtk_write_footer (vtk_context);
- *     if (retval) { error; }
- *
- * \param [in,out] cont    A VTK context created by \ref p8est_vtk_context_new.
- *                         None of the vtk_write functions must have been called.
- *                         This context is the return value if no error occurs.
- *
- * \return          On success, an opaque context (p8est_vtk_context_t) pointer
- *                  that must be passed to subsequent p8est_vtk calls.  It is
- *                  required to call \ref p8est_vtk_write_footer eventually with
- *                  this value.  Returns NULL on error.
- */
-p8est_vtk_context_t *p8est_vtk_write_header (p8est_vtk_context_t * cont);
-
-/** Write VTK cell data.
- *
- * There are options to have this function write
- * the tree id, quadrant level, or MPI rank without explicit input data.
- *
- * Writing a VTK file is split into a few routines.
- * This allows there to be an arbitrary number of
- * fields.
- *
- * \param [in,out] cont    A VTK context created by \ref p8est_vtk_context_new.
- * \param [in] write_tree  Boolean to determine if the tree id should be output.
- * \param [in] write_level Boolean to determine if the tree levels should be output.
- * \param [in] write_rank  Boolean to determine if the MPI rank should be output.
- * \param [in] wrap_rank   Number to wrap around the rank with a modulo operation.
- *                         Can be 0 for no wrapping.
- * \param [in] num_cell_scalars Number of cell scalar datasets to output.
- * \param [in] num_cell_vectors Number of cell vector datasets to output.
- *
- * The variable arguments need to be pairs of (fieldname, fieldvalues), followed
- * by a final argument of the VTK context cont (same as the first argument).
- * The cell scalar pairs come first, followed by the cell vector pairs, then cont.
- * Each 'fieldname' argument shall be a char string containing the name of the data
- * contained in the following 'fieldvalues'.  Each of the 'fieldvalues'
- * arguments shall be an sc_array_t * holding double variables.  The number of
- * doubles in each sc_array must be exactly \a p4est->local_num_quadrants for
- * scalar data and \a 3*p4est->local_num_quadrants for vector data.
- *
- * \note The current p8est_vtk_context_t structure, \a cont, must be the first
- * and the last argument
- * of any call to this function; this argument is used to validate that the
- * correct number of variable arguments have been provided.
- *
- * \return          On success, the context that has been passed in.
- *                  On failure, returns NULL and deallocates the context.
- */
-p8est_vtk_context_t *p8est_vtk_write_cell_dataf (p8est_vtk_context_t * cont,
-                                                 int write_tree,
-                                                 int write_level,
-                                                 int write_rank,
-                                                 int wrap_rank,
-                                                 int num_cell_scalars,
-                                                 int num_cell_vectors, ...);
-
-/** Write VTK point data.
- *
- * Writing a VTK file is split into a few routines.
- * This allows there to be an arbitrary number of
- * fields.
- *
- * \param [in,out] cont    A VTK context created by \ref p8est_vtk_context_new.
- * \param [in] num_point_scalars Number of point scalar datasets to output.
- * \param [in] num_point_vectors Number of point vector datasets to output.
- *
- * The variable arguments need to be pairs of (fieldname, fieldvalues) where
- * the point scalar pairs come first, followed by the point vector pairs.  Each
- * 'fieldname' argument shall be a char string containing the name of the data
- * contained in the following 'fieldvalues'. Each of the 'fieldvalues'
- * arguments shall be an sc_array_t * holding double variables. The number of
- * doubles in each sc_array must be exactly the number of components (1 for
- * scalar and 3 for vector) times 8 times number of elements.
- *
- * \note The current
- * p8est_vtk_context_t structure, cont, must be the last argument of any call
- * to this function; this argument is used to validate that the correct number
- * of variable arguments have been provided.
- *
- * \note The number of point scalar data in each
- * sc_array must be exactly \a P8EST_CHILDREN*local_num_quadrants, and the
- * number of point vector data must be exactly \a
- * 3*P8EST_CHILDREN*local_num_quadrants. I.e. there must be data for every
- * corner of every quadrant in the \a p8est, even if the corner is shared by
- * multiple quadrants.
- *
- * \return          On success, the context that has been passed in.
- *                  On failure, returns NULL and deallocates the context.
- */
-p8est_vtk_context_t *p8est_vtk_write_point_dataf (p8est_vtk_context_t * cont,
-                                                  int num_point_scalars,
-                                                  int num_point_vectors, ...);
-
-/** Write the VTU footer and clean up.
- *
- * Writing a VTK file is split into a few routines.
- * This function writes the footer information to the VTK file and cleanly
- * destroys the VTK context.
- *
- * \param [in] cont Context is deallocated before the function returns.
- *
- * \return          This returns 0 if no error and -1 if there is an error.
- */
-int                 p8est_vtk_write_footer (p8est_vtk_context_t * cont);
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_VTK_H */
diff --git a/OctreeRefinement/include/p8est_wrap.h b/OctreeRefinement/include/p8est_wrap.h
deleted file mode 100644
index 45ea270..0000000
--- a/OctreeRefinement/include/p8est_wrap.h
+++ /dev/null
@@ -1,352 +0,0 @@
-/*
-  This file is part of p4est.
-  p4est is a C library to manage a collection (a forest) of multiple
-  connected adaptive quadtrees or octrees in parallel.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac
-
-  p4est is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  p4est is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with p4est; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*/
-
-#ifndef P8EST_WRAP_H
-#define P8EST_WRAP_H
-
-/** \file p8est_wrap.h
- * The logic in p8est_wrap encapsulates core p4est data structures and provides
- * functions that clarify the mark-adapt-partition cycle.  There is also an
- * element iterator that can replace the nested loops over trees and tree
- * quadrants, respectively, which can help make application code cleaner.
- */
-
-#include <p8est_mesh.h>
-#include <p8est_extended.h>
-#include <sc_refcount.h>
-
-SC_EXTERN_C_BEGIN;
-
-/*** COMPLETE INTERNAL STATE OF P8EST ***/
-
-typedef enum p8est_wrap_flags
-{
-  P8EST_WRAP_NONE = 0,
-  P8EST_WRAP_REFINE = 0x01,
-  P8EST_WRAP_COARSEN = 0x02
-}
-p8est_wrap_flags_t;
-
-typedef struct p8est_wrap
-{
-  /* this member is never used or changed by p8est_wrap */
-  void               *user_pointer;     /**< Convenience member for users */
-
-  /** If true, this wrap has NULL for ghost, mesh, and flag members.
-   * If false, they are properly allocated and kept current internally. */
-  int                 hollow;
-
-  /** Non-negative integer tells us how many adaptations to wait
-   * before any given quadrent may be coarsened again. */
-  int                 coarsen_delay;
-
-  /** Boolean: If true, we delay coarsening not only after refinement,
-   * but also between subsequent coarsenings of the same quadrant. */
-  int                 coarsen_affect;
-
-  /** This reference counter is a workaround for internal use only.
-   * Until we have refcounting/copy-on-write for the connectivity,
-   * we count the references to conn by copies of this wrap structure.
-   * There must be no external references left when this wrap is destroyed.
-   */
-  sc_refcount_t       conn_rc;
-  p8est_connectivity_t *conn;
-  struct p8est_wrap  *conn_owner;
-
-  /* these members are considered public and read-only */
-  int                 p4est_dim;
-  int                 p4est_half;
-  int                 p4est_faces;
-  int                 p4est_children;
-  p8est_connect_type_t btype;
-  p8est_replace_t     replace_fn;
-  p8est_t            *p4est;    /**< p4est->user_pointer is used internally */
-
-  /* anything below here is considered private und should not be touched */
-  int                 weight_exponent;
-  uint8_t            *flags, *temp_flags;
-  p4est_locidx_t      num_refine_flags, inside_counter, num_replaced;
-
-  /* for ghost and mesh use p8est_wrap_get_ghost, _mesh declared below */
-  p8est_ghost_t      *ghost;
-  p8est_mesh_t       *mesh;
-  p8est_ghost_t      *ghost_aux;
-  p8est_mesh_t       *mesh_aux;
-  int                 match_aux;
-}
-p8est_wrap_t;
-
-/** Create a p8est wrapper from a given connectivity structure.
- * The ghost and mesh members are initialized as well as the flags.
- * The btype is set to P8EST_CONNECT_FULL.
- * \param [in] mpicomm        We expect sc_MPI_Init to be called already.
- * \param [in] conn           Connectivity structure.  Wrap takes ownership.
- * \param [in] initial_level  Initial level of uniform refinement.
- * \return                    A fully initialized p8est_wrap structure.
- */
-p8est_wrap_t       *p8est_wrap_new_conn (sc_MPI_Comm mpicomm,
-                                         p8est_connectivity_t * conn,
-                                         int initial_level);
-
-/** Create a wrapper for a given p8est structure.
- * \param [in,out] p8est      Valid p8est object that we will own.
- *                            We take ownership of its connectivity too.
- *                            Its user pointer must be NULL and will be changed.
- * \param [in] hollow         Do not allocate flags, ghost, and mesh members.
- * \param [in] btype          The neighborhood used for balance, ghost, mesh.
- * \param [in] replace_fn     Callback to replace quadrants during refinement,
- *                            coarsening or balancing in \ref p8est_wrap_adapt.
- *                            May be NULL.
- * \param [in] user_pointer   Set the user pointer in \ref p8est_wrap_t.
- *                            Subsequently, we will never access it.
- * \return                    A fully initialized p8est_wrap structure.
- */
-p8est_wrap_t       *p8est_wrap_new_p8est (p8est_t * p8est, int hollow,
-                                          p8est_connect_type_t btype,
-                                          p8est_replace_t replace_fn,
-                                          void *user_pointer);
-
-/** Create a p8est wrapper from a given connectivity structure.
- * Like p8est_wrap_new_conn, but with extra parameters \a hollow and \a btype.
- * \param [in] mpicomm        We expect sc_MPI_Init to be called already.
- * \param [in] conn           Connectivity structure.  Wrap takes ownership.
- * \param [in] initial_level  Initial level of uniform refinement.
- *                            No effect if less/equal to zero.
- * \param [in] hollow         Do not allocate flags, ghost, and mesh members.
- * \param [in] btype          The neighborhood used for balance, ghost, mesh.
- * \param [in] replace_fn     Callback to replace quadrants during refinement,
- *                            coarsening or balancing in \ref p8est_wrap_adapt.
- *                            May be NULL.
- * \param [in] user_pointer   Set the user pointer in \ref p8est_wrap_t.
- *                            Subsequently, we will never access it.
- * \return                    A fully initialized p8est_wrap structure.
- */
-p8est_wrap_t       *p8est_wrap_new_ext (sc_MPI_Comm mpicomm,
-                                        p8est_connectivity_t * conn,
-                                        int initial_level, int hollow,
-                                        p8est_connect_type_t btype,
-                                        p8est_replace_t replace_fn,
-                                        void *user_pointer);
-
-/** Create a p8est wrapper from an existing one.
- * \note This wrapper must be destroyed before the original one.
- * We set it to hollow and copy the original p8est data structure.
- * \param [in,out] source   We access the source for debugging purposes.
- * \param [in] data_size    The data size installed in the copied forest.
- * \param [in] replace_fn     Callback to replace quadrants during refinement,
- *                            coarsening or balancing in \ref p8est_wrap_adapt.
- *                            May be NULL.
- * \param [in] user_pointer   Set the user pointer in \ref p8est_wrap_t.
- *                            Subsequently, we will never access it.
- * \return                    A fully initialized p8est_wrap structure.
- */
-p8est_wrap_t       *p8est_wrap_new_copy (p8est_wrap_t * source,
-                                         size_t data_size,
-                                         p8est_replace_t replace_fn,
-                                         void *user_pointer);
-
-/** Create p8est and auxiliary data structures.
- * Expects sc_MPI_Init to be called beforehand.
- */
-p8est_wrap_t       *p8est_wrap_new_unitcube (sc_MPI_Comm mpicomm,
-                                             int initial_level);
-p8est_wrap_t       *p8est_wrap_new_rotwrap (sc_MPI_Comm mpicomm,
-                                            int initial_level);
-p8est_wrap_t       *p8est_wrap_new_brick (sc_MPI_Comm mpicomm,
-                                          int bx, int by, int bz,
-                                          int px, int py, int pz,
-                                          int initial_level);
-
-/** Passes sc_MPI_COMM_WORLD to p8est_wrap_new_unitcube. */
-p8est_wrap_t       *p8est_wrap_new_world (int initial_level);
-void                p8est_wrap_destroy (p8est_wrap_t * pp);
-
-/** Change hollow status of the wrap.
- * It is legal to set to the current hollow status.
- * \param [in,out] pp   The present wrap structure, hollow or not.
- * \param [in] hollow   The desired hollow status.
- */
-void                p8est_wrap_set_hollow (p8est_wrap_t * pp, int hollow);
-
-/** Set a parameter that delays coarsening after adaptation.
- * If positive each quadrant counts the number of adaptations it has survived.
- * Calling this function initializes all quadrant counters to zero.
- * On adaptation we only coarsen a quadrant if it is old enough.
- * Optionally, we can also delay the time between subsequent coarsenings.
- * \param [in,out] pp           A valid p8est_wrap structure.
- * \param [in] coarsen_delay    Set how many adaptation cycles a quadrant has
- *                              to wait to be allowed to coarsen.
- *                              Non-negative number; 0 disables the feature.
- *                              Suggested default value: not larger than 2.
- * \param [in] coarsen_affect   Boolean; If true, we not only count from the
- *                              most recent refinement but also between
- *                              subsequent coarsenings.
- *                              Suggested default: 0.
- */
-void                p8est_wrap_set_coarsen_delay (p8est_wrap_t * pp,
-                                                  int coarsen_delay,
-                                                  int coarsen_affect);
-
-/** Return the appropriate ghost layer.
- * This function is necessary since two versions may exist simultaneously
- * after refinement and before partition/complete.
- * \param [in,out] pp The p8est wrapper to work with, must not be hollow.
- * */
-p8est_ghost_t      *p8est_wrap_get_ghost (p8est_wrap_t * pp);
-
-/** Return the appropriate mesh structure.
- * This function is necessary since two versions may exist simultaneously
- * after refinement and before partition/complete.
- * \param [in,out] pp The p8est wrapper to work with, must not be hollow.
- * */
-p8est_mesh_t       *p8est_wrap_get_mesh (p8est_wrap_t * pp);
-
-/** Mark a local element for refinement.
- * This will cancel any coarsening mark set previously for this element.
- * \param [in,out] pp The p8est wrapper to work with, must not be hollow.
- * \param [in] which_tree The number of the tree this element lives in.
- * \param [in] which_quad The number of this element relative to its tree.
- */
-void                p8est_wrap_mark_refine (p8est_wrap_t * pp,
-                                            p4est_topidx_t which_tree,
-                                            p4est_locidx_t which_quad);
-
-/** Mark a local element for coarsening.
- * This will cancel any refinement mark set previously for this element.
- * \param [in,out] pp The p8est wrapper to work with, must not be hollow.
- * \param [in] which_tree The number of the tree this element lives in.
- * \param [in] which_quad The number of this element relative to its tree.
- */
-void                p8est_wrap_mark_coarsen (p8est_wrap_t * pp,
-                                             p4est_topidx_t which_tree,
-                                             p4est_locidx_t which_quad);
-
-/** Call p8est_refine, coarsen, and balance to update pp->p8est.
- * Checks pp->flags as per-quadrant input against p8est_wrap_flags_t.
- * The pp->flags array is updated along with p8est and reset to zeros.
- * Creates ghost_aux and mesh_aux to represent the intermediate mesh.
- * \param [in,out] pp The p8est wrapper to work with, must not be hollow.
- * \return          boolean whether p8est has changed.
- *                  If true, partition must be called.
- *                  If false, partition must not be called,
- *                  and complete must not be called either.
- */
-int                 p8est_wrap_adapt (p8est_wrap_t * pp);
-
-/** Call p8est_partition for equal leaf distribution.
- * Frees the old ghost and mesh first and updates pp->flags along with p8est.
- * Creates ghost and mesh to represent the new mesh.
- * \param [in,out] pp The p8est wrapper to work with, must not be hollow.
- * \param [in] weight_exponent      Integer weight assigned to each leaf
- *                  according to 2 ** (level * exponent).  Passing 0 assigns
- *                  equal weight to all leaves.  Passing 1 increases the
- *                  leaf weight by a factor of two for each level increase.
- *                  CURRENTLY ONLY 0 AND 1 ARE LEGAL VALUES.
- * \param [out] unchanged_first
- *                  If not NULL, is assigned the processor-local index of the
- *                  first local quadrant that has stayed on this processor.  If
- *                  no quadrant has stayed, the value is set to zero.
- *                  This number is in reference to the new (output) partition.
- * \param [out] unchanged_length
- *                  If not NULL, is assigned the number of quadrants that have
- *                  stayed on this processor.  If no quadrant has stayed, the
- *                  value is set to zero.
- * \param [out] unchanged_old_first
- *                  If not NULL, is assigned the processor-local index of the
- *                  first local quadrant that has stayed with reference to
- *                  the old (input) partition.  If no quadrant has stayed,
- *                  the value is set to zero.
- * \return          boolean whether p8est has changed.
- *                  If true, complete must be called.
- *                  If false, complete must not be called.
- */
-int                 p8est_wrap_partition (p8est_wrap_t * pp,
-                                          int weight_exponent,
-                                          p4est_locidx_t * unchanged_first,
-                                          p4est_locidx_t * unchanged_length,
-                                          p4est_locidx_t *
-                                          unchanged_old_first);
-
-/** Free memory for the intermediate mesh.
- * Sets mesh_aux and ghost_aux to NULL.
- * This function must be used if both refinement and partition effect changes.
- * After this call, we are ready for another mark-refine-partition cycle.
- * \param [in,out] pp The p8est wrapper to work with, must not be hollow.
- */
-void                p8est_wrap_complete (p8est_wrap_t * pp);
-
-/*** ITERATOR OVER THE FOREST LEAVES ***/
-
-typedef struct p8est_wrap_leaf
-{
-  p8est_wrap_t       *pp;             /**< Must contain a valid ghost */
-
-  /* Information about the current quadrant */
-  p4est_topidx_t      which_tree;     /**< Current tree number */
-  p4est_locidx_t      which_quad;     /**< Quadrant number relative to tree */
-  p4est_locidx_t      local_quad;     /**< Quadrant number relative to proc */
-  p8est_tree_t       *tree;           /**< Current tree */
-  sc_array_t         *tquadrants;     /**< Current tree's quadrants */
-  p8est_quadrant_t   *quad;           /**< Current quadrant */
-#if 0                           /* DEPRECATED -- anyone using them? */
-  int                 level;
-  double              lowerleft[3];
-  double              upperright[3];
-#endif
-
-  /* Information about parallel neighbors */
-  int                 is_mirror;      /**< Quadrant at parallel boundary? */
-  sc_array_t         *mirrors;        /**< If not NULL, from pp's ghost */
-  p4est_locidx_t      nm;             /**< Internal: mirror counter */
-  p4est_locidx_t      next_mirror_quadrant;     /**< Internal: next */
-}
-p8est_wrap_leaf_t;
-
-/** Determine whether we have just entered a different tree */
-#define P8EST_LEAF_IS_FIRST_IN_TREE(wleaf) ((wleaf)->which_quad == 0)
-
-/* Create an iterator over the local leaves in the forest.
- * Returns a newly allocated state containing the first leaf,
- * or NULL if the local partition of the tree is empty.
- * \param [in] pp   Legal p8est_wrap structure, hollow or not.
- * \param [in] track_mirrors    If true, \a pp must not be hollow and mirror
- *                              information from the ghost layer is stored.
- * \return          NULL if processor is empty, otherwise a leaf iterator for
- *                  subsequent use with \a p8est_wrap_leaf_next.
- */
-p8est_wrap_leaf_t  *p8est_wrap_leaf_first (p8est_wrap_t * pp,
-                                           int track_mirrors);
-
-/* Move the forest leaf iterator forward.
- * \param [in,out] leaf     A non-NULL leaf iterator created by
- *                          \ref p8est_wrap_leaf_first.
- * \return          The state that was input with updated information for the
- *                  next leaf, or NULL and deallocates the input if called with
- *                  the last leaf on this processor.
- */
-p8est_wrap_leaf_t  *p8est_wrap_leaf_next (p8est_wrap_leaf_t * leaf);
-
-SC_EXTERN_C_END;
-
-#endif /* !P8EST_WRAP_H */
diff --git a/OctreeRefinement/include/sc.h b/OctreeRefinement/include/sc.h
deleted file mode 100644
index ead4c16..0000000
--- a/OctreeRefinement/include/sc.h
+++ /dev/null
@@ -1,685 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-/** \file sc.h
- *
- * Support for process management (memory allocation, logging, etc.)
- */
-
-/** \defgroup sc libsc
- *
- * The SC Library provides support for parallel scientific applications.
- */
-
-#ifndef SC_H
-#define SC_H
-
-/* include the sc_config header first */
-
-#include <sc_config.h>
-#ifndef _sc_const
-#define _sc_const const
-#endif
-#ifndef _sc_restrict
-#define _sc_restrict restrict
-#endif
-
-/* test for gcc version without features.h */
-#define SC_CALC_VERSION(major,minor,patchlevel) \
-                       (((major) * 1000 + (minor)) * 1000 + (patchlevel))
-#ifdef __GNUC__
-#define SC_GCC_VERSION \
-        SC_CALC_VERSION(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
-#else
-#define SC_GCC_VERSION \
-        SC_CALC_VERSION (0, 0, 0)
-#endif
-
-/* use this feature macro, be minimally invasive */
-#ifdef SC_ENABLE_MEMALIGN
-/* we disable the system-provided functions for the time being */
-#ifdef SC_HAVE_ANY_MEMALIGN
-#undef SC_HAVE_ANY_MEMALIGN
-#endif
-/* if system-provided functions are needed, give them the prototype */
-#ifdef SC_HAVE_ANY_MEMALIGN
-#ifndef SC_HAVE_POSIX_MEMALIGN
-#ifdef SC_HAVE_ALIGNED_ALLOC
-#define _ISOC11_SOURCE
-#endif
-#endif
-#endif
-/* done with memalign macros */
-#endif
-
-/* use this in case mpi.h includes stdint.h */
-
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS
-#endif
-
-/* include MPI before stdio.h */
-
-#ifdef SC_ENABLE_MPI
-#include <mpi.h>
-#else
-#ifdef MPI_SUCCESS
-#error "mpi.h is included.  Use --enable-mpi."
-#endif
-#endif
-
-/* include system headers */
-
-#include <math.h>
-#include <ctype.h>
-#include <float.h>
-//#include <libgen.h>
-#include <limits.h>
-#include <stdarg.h>
-#include <stddef.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-//#include <unistd.h>
-
-/* provide extern C defines */
-
-/* The hacks below enable semicolons after the SC_EXTERN_C_ macros
- * and also take care of the different semantics of () / (...) */
-#ifdef __cplusplus
-#define SC_EXTERN_C_BEGIN       extern "C" { void sc_extern_c_hack_1 (void)
-#define SC_EXTERN_C_END                    } void sc_extern_c_hack_2 (void)
-#define SC_NOARGS               ...
-#else
-#define SC_EXTERN_C_BEGIN                    void sc_extern_c_hack_3 (void)
-#define SC_EXTERN_C_END                      void sc_extern_c_hack_4 (void)
-#define SC_NOARGS
-#endif
-
-/* this libsc header is always included */
-#define __attribute__(x)
-#include <sc_mpi.h>
-
-SC_EXTERN_C_BEGIN;
-
-/* extern variables */
-
-extern const int    sc_log2_lookup_table[256];
-extern int          sc_package_id;
-
-/* control a trace file by environment variables (see sc_init) */
-extern FILE        *sc_trace_file;
-extern int          sc_trace_prio;
-
-/* define math constants if necessary */
-#ifndef M_E
-#define M_E 2.7182818284590452354       /* e */
-#endif
-#ifndef M_LOG2E
-#define M_LOG2E 1.4426950408889634074   /* log_2 e */
-#endif
-#ifndef M_LOG10E
-#define M_LOG10E 0.43429448190325182765 /* log_10 e */
-#endif
-#ifndef M_LN2
-#define M_LN2 0.69314718055994530942    /* log_e 2 */
-#endif
-#ifndef M_LN10
-#define M_LN10 2.30258509299404568402   /* log_e 10 */
-#endif
-#ifndef M_PI
-#define M_PI 3.14159265358979323846     /* pi */
-#endif
-#ifndef M_PI_2
-#define M_PI_2 1.57079632679489661923   /* pi/2 */
-#endif
-#ifndef M_PI_4
-#define M_PI_4 0.78539816339744830962   /* pi/4 */
-#endif
-#ifndef M_1_PI
-#define M_1_PI 0.31830988618379067154   /* 1/pi */
-#endif
-#ifndef M_2_PI
-#define M_2_PI 0.63661977236758134308   /* 2/pi */
-#endif
-#ifndef M_2_SQRTPI
-#define M_2_SQRTPI 1.12837916709551257390       /* 2/sqrt(pi) */
-#endif
-#ifndef M_SQRT2
-#define M_SQRT2 1.41421356237309504880  /* sqrt(2) */
-#endif
-#ifndef M_SQRT1_2
-#define M_SQRT1_2 0.70710678118654752440        /* 1/sqrt(2) */
-#endif
-
-#define SC_EPS               2.220446049250313e-16
-#define SC_1000_EPS (1000. * 2.220446049250313e-16)
-
-#if 0
-/*@ignore@*/
-#define index   DONT_USE_NAME_CONFLICT_1 ---
-#define rindex  DONT_USE_NAME_CONFLICT_2 ---
-#define link    DONT_USE_NAME_CONFLICT_3 ---
-#define NO_DEFINE_DONT_USE_CONFLICT SPLINT_IS_STUPID_ALSO
-/*@end@*/
-#endif /* 0 */
-
-/* check macros, always enabled */
-
-#define SC_NOOP() ((void) (0))
-#define SC_ABORT(s)                             \
-  sc_abort_verbose (__FILE__, __LINE__, (s))
-#define SC_ABORT_NOT_REACHED() SC_ABORT ("Unreachable code")
-#define SC_CHECK_ABORT(q,s)                     \
-  ((q) ? (void) 0 : SC_ABORT (s))
-#define SC_CHECK_MPI(r) SC_CHECK_ABORT ((r) == sc_MPI_SUCCESS, "MPI error")
-#define SC_CHECK_ZLIB(r) SC_CHECK_ABORT ((r) == Z_OK, "zlib error")
-
-/*
- * C++98 does not allow variadic macros
- * 1. Declare a default variadic function for C and C++
- * 2. Use macros in C instead of the function
- * This loses __FILE__ and __LINE__ in the C++ ..F log functions
- */
-void                SC_ABORTF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)))
-  __attribute__ ((noreturn));
-void                SC_CHECK_ABORTF (int success, const char *fmt, ...)
-  __attribute__ ((format (printf, 2, 3)));
-#ifndef __cplusplus
-#define SC_ABORTF(fmt,...)                                      \
-  sc_abort_verbosef (__FILE__, __LINE__, (fmt), __VA_ARGS__)
-#define SC_CHECK_ABORTF(q,fmt,...)                      \
-  ((q) ? (void) 0 : SC_ABORTF (fmt, __VA_ARGS__))
-#endif
-#define SC_ABORT1(fmt,a)                                \
-  sc_abort_verbosef (__FILE__, __LINE__, (fmt), (a))
-#define SC_ABORT2(fmt,a,b)                                      \
-  sc_abort_verbosef (__FILE__, __LINE__, (fmt), (a), (b))
-#define SC_ABORT3(fmt,a,b,c)                                    \
-  sc_abort_verbosef (__FILE__, __LINE__, (fmt), (a), (b), (c))
-#define SC_ABORT4(fmt,a,b,c,d)                                          \
-  sc_abort_verbosef (__FILE__, __LINE__, (fmt), (a), (b), (c), (d))
-#define SC_ABORT5(fmt,a,b,c,d,e)                                        \
-  sc_abort_verbosef (__FILE__, __LINE__, (fmt), (a), (b), (c), (d), (e))
-#define SC_ABORT6(fmt,a,b,c,d,e,f)                                      \
-  sc_abort_verbosef (__FILE__, __LINE__, (fmt), (a), (b), (c), (d), (e), (f))
-#define SC_CHECK_ABORT1(q,fmt,a)                \
-  ((q) ? (void) 0 : SC_ABORT1 ((fmt), (a)))
-#define SC_CHECK_ABORT2(q,fmt,a,b)                      \
-  ((q) ? (void) 0 : SC_ABORT2 ((fmt), (a), (b)))
-#define SC_CHECK_ABORT3(q,fmt,a,b,c)                    \
-  ((q) ? (void) 0 : SC_ABORT3 ((fmt), (a), (b), (c)))
-#define SC_CHECK_ABORT4(q,fmt,a,b,c,d)                          \
-  ((q) ? (void) 0 : SC_ABORT4 ((fmt), (a), (b), (c), (d)))
-#define SC_CHECK_ABORT5(q,fmt,a,b,c,d,e)                        \
-  ((q) ? (void) 0 : SC_ABORT5 ((fmt), (a), (b), (c), (d), (e)))
-#define SC_CHECK_ABORT6(q,fmt,a,b,c,d,e,f)                              \
-  ((q) ? (void) 0 : SC_ABORT6 ((fmt), (a), (b), (c), (d), (e), (f)))
-
-/* assertions, only enabled in debug mode */
-
-#ifdef SC_ENABLE_DEBUG
-#define SC_ASSERT(c) SC_CHECK_ABORT ((c), "Assertion '" #c "'")
-#define SC_EXECUTE_ASSERT_FALSE(expression)                             \
-  do { int _sc_i = (int) (expression);                                  \
-       SC_CHECK_ABORT (!_sc_i, "Expected false: '" #expression "'");    \
-  } while (0)
-#define SC_EXECUTE_ASSERT_TRUE(expression)                              \
-  do { int _sc_i = (int) (expression);                                  \
-       SC_CHECK_ABORT (_sc_i, "Expected true: '" #expression "'");      \
-  } while (0)
-#else
-#define SC_ASSERT(c) SC_NOOP ()
-#define SC_EXECUTE_ASSERT_FALSE(expression) \
-  do { (void) (expression); } while (0)
-#define SC_EXECUTE_ASSERT_TRUE(expression) \
-  do { (void) (expression); } while (0)
-#endif
-
-/* macros for memory allocation, will abort if out of memory */
-
-#define SC_ALLOC(t,n)         (t *) sc_malloc (sc_package_id, (n) * sizeof(t))
-#define SC_ALLOC_ZERO(t,n)    (t *) sc_calloc (sc_package_id, \
-                                               (size_t) (n), sizeof(t))
-#define SC_REALLOC(p,t,n)     (t *) sc_realloc (sc_package_id,          \
-                                             (p), (n) * sizeof(t))
-#define SC_STRDUP(s)                sc_strdup (sc_package_id, (s))
-#define SC_FREE(p)                  sc_free (sc_package_id, (p))
-
-/* macros for memory alignment */
-/* some copied from bfam: https://github.com/bfam/bfam */
-
-#define SC_ALIGN_UP(x,n) ( ((n) <= 0) ? (x) : ((x) + (n) - 1) / (n) * (n) )
-
-#if defined (__bgq__)
-#define SC_ARG_ALIGN(p,t,n) __alignx((n), (p))
-#elif defined (__ICC)
-#define SC_ARG_ALIGN(p,t,n) __assume_aligned((p), (n))
-#elif defined (__clang__)
-#define SC_ARG_ALIGN(p,t,n) SC_NOOP ()
-#elif defined (__GNUC__) || defined (__GNUG__)
-
-#if SC_GCC_VERSION >= SC_CALC_VERSION (4, 7, 0)
-#define SC_ARG_ALIGN(p,t,n) do {                              \
-  (p) = (t) __builtin_assume_aligned((void *) (p), (n));      \
-} while (0)
-#else
-#define SC_ARG_ALIGN(p,t,n) SC_NOOP ()
-#endif
-
-#else
-#define SC_ARG_ALIGN(p,t,n) SC_NOOP ()
-#endif
-
-#if (defined __GNUC__) || (defined __PGI) || (defined __IBMC__)
-#define SC_ATTR_ALIGN(n) __attribute__((aligned(n)))
-#else
-#define SC_ATTR_ALIGN(n)
-#endif
-
-/**
- * Sets n elements of a memory range to zero.
- * Assumes the pointer p is of the correct type.
- */
-#define SC_BZERO(p,n) ((void) memset ((p), 0, (n) * sizeof (*(p))))
-
-/* min, max and square helper macros */
-
-#define SC_MIN(a,b) (((a) < (b)) ? (a) : (b))
-#define SC_MAX(a,b) (((a) > (b)) ? (a) : (b))
-#define SC_SQR(a) ((a) * (a))
-
-/* hopefully fast binary logarithms and binary round up */
-
-#define SC_LOG2_8(x) (sc_log2_lookup_table[(x)])
-#define SC_LOG2_16(x) (((x) > 0xff) ?                                   \
-                       (SC_LOG2_8 ((x) >> 8) + 8) : SC_LOG2_8 (x))
-#define SC_LOG2_32(x) (((x) > 0xffff) ?                                 \
-                       (SC_LOG2_16 ((x) >> 16)) + 16 : SC_LOG2_16 (x))
-#define SC_LOG2_64(x) (((x) > 0xffffffffLL) ?                           \
-                       (SC_LOG2_32 ((x) >> 32)) + 32 : SC_LOG2_32 (x))
-#define SC_ROUNDUP2_32(x)                               \
-  (((x) <= 0) ? 0 : (1 << (SC_LOG2_32 ((x) - 1) + 1)))
-#define SC_ROUNDUP2_64(x)                               \
-  (((x) <= 0) ? 0 : (1LL << (SC_LOG2_64 ((x) - 1LL) + 1)))
-
-/* log categories */
-
-#define SC_LC_GLOBAL      1     /**< log only for master process */
-#define SC_LC_NORMAL      2     /**< log for every process */
-
-/** \defgroup logpriorities log priorities
- *
- * Numbers designating the level of logging output.
- *
- * Priorities TRACE to VERBOSE are appropriate when all parallel processes
- * contribute log messages.  INFO and above must not clutter the output of
- * large parallel runs.  STATISTICS can be used for important measurements.
- * PRODUCTION is meant for rudimentary information on the program flow.
- * ESSENTIAL can be used for one-time messages, say at program startup.
- *
- * \ingroup sc
- */
-/*@{ \ingroup logpriorities */
-/* log priorities */
-#define SC_LP_DEFAULT   (-1)    /**< this selects the SC default threshold */
-#define SC_LP_ALWAYS      0     /**< this will log everything */
-#define SC_LP_TRACE       1     /**< this will prefix file and line number */
-#define SC_LP_DEBUG       2     /**< any information on the internal state */
-#define SC_LP_VERBOSE     3     /**< information on conditions, decisions */
-#define SC_LP_INFO        4     /**< the main things a function is doing */
-#define SC_LP_STATISTICS  5     /**< important for consistency/performance */
-#define SC_LP_PRODUCTION  6     /**< a few lines for a major api function */
-#define SC_LP_ESSENTIAL   7     /**< this logs a few lines max per program */
-#define SC_LP_ERROR       8     /**< this logs errors only */
-#define SC_LP_SILENT      9     /**< this never logs anything */
-/*@}*/
-
-/** The log priority for the sc package.
- *
- */
-#ifdef SC_LOG_PRIORITY
-#define SC_LP_THRESHOLD SC_LOG_PRIORITY
-#else
-#ifdef SC_ENABLE_DEBUG
-#define SC_LP_THRESHOLD SC_LP_TRACE
-#else
-#define SC_LP_THRESHOLD SC_LP_INFO
-#endif
-#endif
-
-/* generic log macros */
-#define SC_GEN_LOG(package,category,priority,s)                         \
-  ((priority) < SC_LP_THRESHOLD ? (void) 0 :                            \
-   sc_log (__FILE__, __LINE__, (package), (category), (priority), (s)))
-#define SC_GLOBAL_LOG(p,s) SC_GEN_LOG (sc_package_id, SC_LC_GLOBAL, (p), (s))
-#define SC_LOG(p,s) SC_GEN_LOG (sc_package_id, SC_LC_NORMAL, (p), (s))
-void                SC_GEN_LOGF (int package, int category, int priority,
-                                 const char *fmt, ...)
-  __attribute__ ((format (printf, 4, 5)));
-void                SC_GLOBAL_LOGF (int priority, const char *fmt, ...)
-  __attribute__ ((format (printf, 2, 3)));
-void                SC_LOGF (int priority, const char *fmt, ...)
-  __attribute__ ((format (printf, 2, 3)));
-#ifndef __cplusplus
-#define SC_GEN_LOGF(package,category,priority,fmt,...)                  \
-  ((priority) < SC_LP_THRESHOLD ? (void) 0 :                            \
-   sc_logf (__FILE__, __LINE__, (package), (category), (priority),      \
-            (fmt), __VA_ARGS__))
-#define SC_GLOBAL_LOGF(p,fmt,...)                                       \
-  SC_GEN_LOGF (sc_package_id, SC_LC_GLOBAL, (p), (fmt), __VA_ARGS__)
-#define SC_LOGF(p,fmt,...)                                              \
-  SC_GEN_LOGF (sc_package_id, SC_LC_NORMAL, (p), (fmt), __VA_ARGS__)
-#endif
-
-/* convenience global log macros will only output if identifier <= 0 */
-#define SC_GLOBAL_TRACE(s) SC_GLOBAL_LOG (SC_LP_TRACE, (s))
-#define SC_GLOBAL_LDEBUG(s) SC_GLOBAL_LOG (SC_LP_DEBUG, (s))
-#define SC_GLOBAL_VERBOSE(s) SC_GLOBAL_LOG (SC_LP_VERBOSE, (s))
-#define SC_GLOBAL_INFO(s) SC_GLOBAL_LOG (SC_LP_INFO, (s))
-#define SC_GLOBAL_STATISTICS(s) SC_GLOBAL_LOG (SC_LP_STATISTICS, (s))
-#define SC_GLOBAL_PRODUCTION(s) SC_GLOBAL_LOG (SC_LP_PRODUCTION, (s))
-#define SC_GLOBAL_ESSENTIAL(s) SC_GLOBAL_LOG (SC_LP_ESSENTIAL, (s))
-#define SC_GLOBAL_LERROR(s) SC_GLOBAL_LOG (SC_LP_ERROR, (s))
-void                SC_GLOBAL_TRACEF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                SC_GLOBAL_LDEBUGF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                SC_GLOBAL_VERBOSEF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                SC_GLOBAL_INFOF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                SC_GLOBAL_STATISTICSF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                SC_GLOBAL_PRODUCTIONF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                SC_GLOBAL_ESSENTIALF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                SC_GLOBAL_LERRORF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-#ifndef __cplusplus
-#define SC_GLOBAL_TRACEF(fmt,...)                       \
-  SC_GLOBAL_LOGF (SC_LP_TRACE, (fmt), __VA_ARGS__)
-#define SC_GLOBAL_LDEBUGF(fmt,...)                      \
-  SC_GLOBAL_LOGF (SC_LP_DEBUG, (fmt), __VA_ARGS__)
-#define SC_GLOBAL_VERBOSEF(fmt,...)                     \
-  SC_GLOBAL_LOGF (SC_LP_VERBOSE, (fmt), __VA_ARGS__)
-#define SC_GLOBAL_INFOF(fmt,...)                        \
-  SC_GLOBAL_LOGF (SC_LP_INFO, (fmt), __VA_ARGS__)
-#define SC_GLOBAL_STATISTICSF(fmt,...)                  \
-  SC_GLOBAL_LOGF (SC_LP_STATISTICS, (fmt), __VA_ARGS__)
-#define SC_GLOBAL_PRODUCTIONF(fmt,...)                  \
-  SC_GLOBAL_LOGF (SC_LP_PRODUCTION, (fmt), __VA_ARGS__)
-#define SC_GLOBAL_ESSENTIALF(fmt,...)                   \
-  SC_GLOBAL_LOGF (SC_LP_ESSENTIAL, (fmt), __VA_ARGS__)
-#define SC_GLOBAL_LERRORF(fmt,...)                      \
-  SC_GLOBAL_LOGF (SC_LP_ERROR, (fmt), __VA_ARGS__)
-#endif
-
-/* convenience log macros that output regardless of identifier */
-#define SC_TRACE(s) SC_LOG (SC_LP_TRACE, (s))
-#define SC_LDEBUG(s) SC_LOG (SC_LP_DEBUG, (s))
-#define SC_VERBOSE(s) SC_LOG (SC_LP_VERBOSE, (s))
-#define SC_INFO(s) SC_LOG (SC_LP_INFO, (s))
-#define SC_STATISTICS(s) SC_LOG (SC_LP_STATISTICS, (s))
-#define SC_PRODUCTION(s) SC_LOG (SC_LP_PRODUCTION, (s))
-#define SC_ESSENTIAL(s) SC_LOG (SC_LP_ESSENTIAL, (s))
-#define SC_LERROR(s) SC_LOG (SC_LP_ERROR, (s))
-void                SC_TRACEF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                SC_LDEBUGF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                SC_VERBOSEF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                SC_INFOF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                SC_STATISTICSF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                SC_PRODUCTIONF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                SC_ESSENTIALF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-void                SC_LERRORF (const char *fmt, ...)
-  __attribute__ ((format (printf, 1, 2)));
-#ifndef __cplusplus
-#define SC_TRACEF(fmt,...)                      \
-  SC_LOGF (SC_LP_TRACE, (fmt), __VA_ARGS__)
-#define SC_LDEBUGF(fmt,...)                     \
-  SC_LOGF (SC_LP_DEBUG, (fmt), __VA_ARGS__)
-#define SC_VERBOSEF(fmt,...)                    \
-  SC_LOGF (SC_LP_VERBOSE, (fmt), __VA_ARGS__)
-#define SC_INFOF(fmt,...)                       \
-  SC_LOGF (SC_LP_INFO, (fmt), __VA_ARGS__)
-#define SC_STATISTICSF(fmt,...)                         \
-  SC_LOGF (SC_LP_STATISTICS, (fmt), __VA_ARGS__)
-#define SC_PRODUCTIONF(fmt,...)                         \
-  SC_LOGF (SC_LP_PRODUCTION, (fmt), __VA_ARGS__)
-#define SC_ESSENTIALF(fmt,...)                  \
-  SC_LOGF (SC_LP_ESSENTIAL, (fmt), __VA_ARGS__)
-#define SC_LERRORF(fmt,...)                     \
-  SC_LOGF (SC_LP_ERROR, (fmt), __VA_ARGS__)
-#endif
-
-/* callback typedefs */
-
-typedef void        (*sc_handler_t) (void *data);
-typedef void        (*sc_log_handler_t) (FILE * log_stream,
-                                         const char *filename, int lineno,
-                                         int package, int category,
-                                         int priority, const char *msg);
-typedef void        (*sc_abort_handler_t) (void);
-
-/* memory allocation functions, will abort if out of memory */
-
-void               *sc_malloc (int package, size_t size);
-void               *sc_calloc (int package, size_t nmemb, size_t size);
-void               *sc_realloc (int package, void *ptr, size_t size);
-char               *sc_strdup (int package, const char *s);
-void                sc_free (int package, void *ptr);
-int                 sc_memory_status (int package);
-void                sc_memory_check (int package);
-
-/* comparison functions for various integer sizes */
-
-int                 sc_int_compare (const void *v1, const void *v2);
-int                 sc_int8_compare (const void *v1, const void *v2);
-int                 sc_int16_compare (const void *v1, const void *v2);
-int                 sc_int32_compare (const void *v1, const void *v2);
-int                 sc_int64_compare (const void *v1, const void *v2);
-int                 sc_double_compare (const void *v1, const void *v2);
-
-/** Controls the default SC log behavior.
- * \param [in] log_stream    Set stream to use by sc_logf (or NULL for stdout).
- * \param [in] log_handler   Set default SC log handler (NULL selects builtin).
- * \param [in] log_threshold Set default SC log threshold (or SC_LP_DEFAULT).
- *                           May be SC_LP_ALWAYS or SC_LP_SILENT.
- */
-void                sc_set_log_defaults (FILE * log_stream,
-                                         sc_log_handler_t log_handler,
-                                         int log_thresold);
-
-/** Controls the default SC abort behavior.
- * \param [in] abort_handler Set default SC above handler (NULL selects
- *                           builtin).  ***This function should not return!***
- */
-void                sc_set_abort_handler (sc_abort_handler_t abort_handler);
-
-/** The central log function to be called by all packages.
- * Dispatches the log calls by package and filters by category and priority.
- * \param [in] package   Must be a registered package id or -1.
- * \param [in] category  Must be SC_LC_NORMAL or SC_LC_GLOBAL.
- * \param [in] priority  Must be > SC_LP_ALWAYS and < SC_LP_SILENT.
- */
-void                sc_log (const char *filename, int lineno,
-                            int package, int category, int priority,
-                            const char *msg);
-void                sc_logf (const char *filename, int lineno,
-                             int package, int category, int priority,
-                             const char *fmt, ...)
-  __attribute__ ((format (printf, 6, 7)));
-void                sc_logv (const char *filename, int lineno,
-                             int package, int category, int priority,
-                             const char *fmt, va_list ap);
-
-/** Add spaces to the start of a package's default log format. */
-void                sc_log_indent_push_count (int package, int count);
-
-/** Remove spaces from the start of a package's default log format. */
-void                sc_log_indent_pop_count (int package, int count);
-
-/** Add one space to the start of sc's default log format. */
-void                sc_log_indent_push (void);
-
-/** Remove one space from the start of a sc's default log format. */
-void                sc_log_indent_pop (void);
-
-/** Print a stack trace, call the abort handler and then call abort (). */
-void                sc_abort (void)
-  __attribute__ ((noreturn));
-
-/** Print a message to stderr and then call sc_abort (). */
-void                sc_abort_verbose (const char *filename, int lineno,
-                                      const char *msg)
-  __attribute__ ((noreturn));
-
-/** Print a message to stderr and then call sc_abort (). */
-void                sc_abort_verbosef (const char *filename, int lineno,
-                                       const char *fmt, ...)
-  __attribute__ ((format (printf, 3, 4)))
-  __attribute__ ((noreturn));
-
-/** Print a message to stderr and then call sc_abort (). */
-void                sc_abort_verbosev (const char *filename, int lineno,
-                                       const char *fmt, va_list ap)
-  __attribute__ ((noreturn));
-
-/** Collective abort where only root prints a message */
-void                sc_abort_collective (const char *msg)
-  __attribute__ ((noreturn));
-
-/** Register a software package with SC.
- * This function must only be called before additional threads are created.
- * The logging parameters are as in sc_set_log_defaults.
- * \return                   Returns a unique package id.
- */
-int                 sc_package_register (sc_log_handler_t log_handler,
-                                         int log_threshold,
-                                         const char *name, const char *full);
-
-/** Query whether an identifier matches a registered package.
- * \param [in] package_id       Only a non-negative id can be registered.
- * \return                      True if and only if the package id is
- *                              non-negative and package is registered.
- */
-int                 sc_package_is_registered (int package_id);
-
-/** Acquire a pthread mutex lock.
- * If configured without --enable-pthread, this function does nothing.
- * This function must be followed with a matching \ref sc_package_unlock.
- * \param [in] package_id       Either -1 for an undefined package or
- *                              an id returned from \ref sc_package_register.
- *                              Depending on the value, the appropriate mutex
- *                              is chosen.  Thus, we may overlap locking calls
- *                              with distinct package_id.
- */
-void                sc_package_lock (int package_id);
-
-/** Release a pthread mutex lock.
- * If configured without --enable-pthread, this function does nothing.
- * This function must be follow a matching \ref sc_package_lock.
- * \param [in] package_id       Either -1 for an undefined package or
- *                              an id returned from \ref sc_package_register.
- *                              Depending on the value, the appropriate mutex
- *                              is chosen.  Thus, we may overlap locking calls
- *                              with distinct package_id.
- */
-void                sc_package_unlock (int package_id);
-
-/** Set the logging verbosity of a registered package.
- * This can be called at any point in the program, any number of times.
- * It can only lower the verbosity at and below the value of SC_LP_THRESHOLD.
- * \param [in] package_id       Must be a registered package identifier.
- */
-void                sc_package_set_verbosity (int package_id,
-                                              int log_priority);
-
-/** Set the unregister behavior of sc_package_unregister().
- *
- * \param[in] package_id    Must be -1 for the default package or
- *                          the identifier of a registered package.
- * \param[in] set_abort     True if sc_package_unregister() should abort if the
- *                          number of allocs does not match the number of
- *                          frees; false otherwise.
- */
-void                sc_package_set_abort_alloc_mismatch (int package_id,
-                                                         int set_abort);
-
-/** Unregister a software package with SC.
- * This function must only be called after additional threads are finished.
- */
-void                sc_package_unregister (int package_id);
-
-/** Print a summary of all packages registered with SC.
- * Uses the SC_LC_GLOBAL log category which by default only prints on rank 0.
- * \param [in] log_priority     Priority passed to sc log functions.
- */
-void                sc_package_print_summary (int log_priority);
-
-/** Sets the global program identifier (e.g. the MPI rank) and some flags.
- * This function is optional.
- * This function must only be called before additional threads are created.
- * If this function is not called or called with log_handler == NULL,
- * the default SC log handler will be used.
- * If this function is not called or called with log_threshold == SC_LP_DEFAULT,
- * the default SC log threshold will be used.
- * The default SC log settings can be changed with sc_set_log_defaults ().
- * \param [in] mpicomm          MPI communicator, can be sc_MPI_COMM_NULL.
- *                              If sc_MPI_COMM_NULL, the identifier is set to -1.
- *                              Otherwise, sc_MPI_Init must have been called.
- * \param [in] catch_signals    If true, signals INT SEGV USR2 are be caught.
- * \param [in] print_backtrace  If true, sc_abort prints a backtrace.
- */
-void                sc_init (sc_MPI_Comm mpicomm,
-                             int catch_signals, int print_backtrace,
-                             sc_log_handler_t log_handler, int log_threshold);
-
-/** Unregisters all packages, runs the memory check, removes the
- * signal handlers and resets sc_identifier and sc_root_*.
- * This function is optional.
- * This function does not require sc_init to be called first.
- */
-void                sc_finalize (void);
-
-/** Identify the root process.
- * Only meaningful between sc_init and sc_finalize and
- * with a communicator that is not sc_MPI_COMM_NULL (otherwise always true).
- *
- * \return          Return true for the root process and false otherwise.
- */
-int                 sc_is_root (void);
-
-SC_EXTERN_C_END;
-
-#endif /* SC_H */
diff --git a/OctreeRefinement/include/sc_allgather.h b/OctreeRefinement/include/sc_allgather.h
deleted file mode 100644
index d3caf7b..0000000
--- a/OctreeRefinement/include/sc_allgather.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_ALLGATHER_H
-#define SC_ALLGATHER_H
-
-#include <sc.h>
-
-#ifndef SC_AG_ALLTOALL_MAX
-#define SC_AG_ALLTOALL_MAX      5
-#endif
-
-SC_EXTERN_C_BEGIN;
-
-/** Allgather by direct point-to-point communication.
- * Only makes sense for small group sizes.
- */
-void                sc_allgather_alltoall (sc_MPI_Comm mpicomm, char *data,
-                                           int datasize, int groupsize,
-                                           int myoffset, int myrank);
-
-/** Performs recursive bisection allgather.
- * When size becomes small enough, calls sc_ag_alltoall.
- */
-void                sc_allgather_recursive (sc_MPI_Comm mpicomm, char *data,
-                                            int datasize, int groupsize,
-                                            int myoffset, int myrank);
-
-/** Drop-in allgather replacement.
- */
-int                 sc_allgather (void *sendbuf, int sendcount,
-                                  sc_MPI_Datatype sendtype, void *recvbuf,
-                                  int recvcount, sc_MPI_Datatype recvtype,
-                                  sc_MPI_Comm mpicomm);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_ALLGATHER_H */
diff --git a/OctreeRefinement/include/sc_amr.h b/OctreeRefinement/include/sc_amr.h
deleted file mode 100644
index 83d26b1..0000000
--- a/OctreeRefinement/include/sc_amr.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_AMR_H
-#define SC_AMR_H
-
-#include <sc_statistics.h>
-
-SC_EXTERN_C_BEGIN;
-
-typedef struct sc_amr_control
-{
-  const double       *errors;
-  sc_statinfo_t       estats;
-  sc_MPI_Comm         mpicomm;
-  long                num_procs_long;
-  long                num_total_elements;
-  double              coarsen_threshold;
-  double              refine_threshold;
-  long                num_total_coarsen;
-  long                num_total_refine;
-  long                num_total_estimated;
-}
-sc_amr_control_t;
-
-/** Compute global error statistics.
- * \param [in] mpicomm        MPI communicator to use.
- * \param [in] mpisize        Number of MPI processes in this communicator.
- * \param [in] num_local_elements   Number of local elements.
- * \param [in] errors         The error values, one per local element.
- * \param [out] amr           Structure will be initialized and estats filled.
- */
-void                sc_amr_error_stats (sc_MPI_Comm mpicomm,
-                                        long num_local_elements,
-                                        const double *errors,
-                                        sc_amr_control_t * amr);
-
-/** Count the local number of elements that will be coarsened.
- *
- * This is all elements whose error is below threshold
- * and where there are no other conditions preventing coarsening
- * (such as not all siblings may be coarsened or are on another processor).
- *
- * \return          Returns the net loss of local elements.
- */
-typedef long        (*sc_amr_count_coarsen_fn) (sc_amr_control_t * amr,
-                                                void *user_data);
-
-/** Count the local number of elements that will be refined.
- *
- * This is all elements whose error is above the threshold
- * and where there are no other conditions preventing refinement
- * (such as refinement would not make the element too small).
- *
- * \return          Returns the net gain of local elements.
- */
-typedef long        (*sc_amr_count_refine_fn) (sc_amr_control_t * amr,
-                                               void *user_data);
-
-/** Specify a coarsening threshold and count the expected elements.
- *
- * \param [in] package_id               Registered package id or -1.
- * \param [in,out] amr                  AMR control structure.
- * \param [in] coarsen_threshold        Coarsening threshold.
- * \param [in] cfn                      Callback to count local coarsenings.
- * \param [in] user_data                Will be passed to the cfn callback.
- */
-void                sc_amr_coarsen_specify (int package_id,
-                                            sc_amr_control_t * amr,
-                                            double coarsen_threshold,
-                                            sc_amr_count_coarsen_fn cfn,
-                                            void *user_data);
-
-/** Binary search for coarsening threshold without refinement.
- *
- * \param [in] package_id               Registered package id or -1.
- * \param [in,out] amr                  AMR control structure.
- * \param [in] num_total_ideal          Target number of global elements.
- * \param [in] coarsen_threshold_high   Upper bound on the error indicator.
- * \param [in] target_window            Relative target window (< 1).
- * \param [in] max_binary_steps         Upper bound on binary search steps.
- * \param [in] cfn                      Callback to count local coarsenings.
- * \param [in] user_data                Will be passed to the cfn callback.
- */
-void                sc_amr_coarsen_search (int package_id,
-                                           sc_amr_control_t * amr,
-                                           long num_total_ideal,
-                                           double coarsen_threshold_high,
-                                           double target_window,
-                                           int max_binary_steps,
-                                           sc_amr_count_coarsen_fn cfn,
-                                           void *user_data);
-
-/** Binary search for refinement threshold without coarsening.
- *
- * \param [in] package_id               Registered package id or -1.
- * \param [in,out] amr                  AMR control structure.
- * \param [in] num_total_ideal          Target number of global elements.
- * \param [in] refine_threshold_low     Lower bound on the error indicator.
- * \param [in] target_window            Relative target window (< 1).
- * \param [in] max_binary_steps         Upper bound on binary search steps.
- * \param [in] rfn                      Callback to count local refinements.
- * \param [in] user_data                Will be passed to the rfn callback.
- */
-void                sc_amr_refine_search (int package_id,
-                                          sc_amr_control_t * amr,
-                                          long num_total_ideal,
-                                          double refine_threshold_low,
-                                          double target_window,
-                                          int max_binary_steps,
-                                          sc_amr_count_refine_fn rfn,
-                                          void *user_data);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_AMR_H */
diff --git a/OctreeRefinement/include/sc_avl.h b/OctreeRefinement/include/sc_avl.h
deleted file mode 100644
index 4e0cf05..0000000
--- a/OctreeRefinement/include/sc_avl.h
+++ /dev/null
@@ -1,212 +0,0 @@
-/* *INDENT-OFF* */
-
-/*****************************************************************************
-
-    avl.h - Source code for the AVL-tree library.
-
-    Copyright (C) 1998  Michael H. Buselli <cosine@cosine.org>
-    Copyright (C) 2000-2002  Wessel Dankers <wsl@nl.linux.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
-
-    Augmented AVL-tree. Original by Michael H. Buselli <cosine@cosine.org>.
-
-    Modified by Wessel Dankers <wsl@nl.linux.org> to add a bunch of bloat to
-    the sourcecode, change the interface and squash a few bugs.
-    Mail him if you find new bugs.
-
-*****************************************************************************/
-
-/* renamed from avl.h to sc_avl.h for the SC Library and modified */
-
-#ifndef _AVL_H
-#define _AVL_H
-
-#include <sc_containers.h>
-
-SC_EXTERN_C_BEGIN;
-
-/* modification to use count only */
-#define AVL_COUNT
-
-/* We need either depths, counts or both (the latter being the default) */
-#if !defined(AVL_DEPTH) && !defined(AVL_COUNT)
-#define AVL_DEPTH
-#define AVL_COUNT
-#endif
-
-/* User supplied function to compare two items like strcmp() does.
- * For example: cmp(a,b) will return:
- *   -1  if a < b
- *    0  if a = b
- *    1  if a > b
- */
-typedef int (*avl_compare_t)(const void *, const void *);
-
-/* User supplied function to delete an item when a node is free()d.
- * If NULL, the item is not free()d.
- */
-typedef void (*avl_freeitem_t)(void *);
-
-/* User supplied function to call on an item in foreach().
- */
-typedef void (*avl_foreach_t)(void *, void *);
-
-typedef struct avl_node_t {
-	struct avl_node_t *next;
-	struct avl_node_t *prev;
-	struct avl_node_t *parent;
-	struct avl_node_t *left;
-	struct avl_node_t *right;
-	void *item;
-#ifdef AVL_COUNT
-	unsigned int count;
-#endif
-#ifdef AVL_DEPTH
-	unsigned char depth;
-#endif
-} avl_node_t;
-
-typedef struct avl_tree_t {
-	avl_node_t *head;
-	avl_node_t *tail;
-	avl_node_t *top;
-	avl_compare_t cmp;
-	avl_freeitem_t freeitem;
-} avl_tree_t;
-
-/* Initializes a new tree for elements that will be ordered using
- * the supplied strcmp()-like function.
- * Returns the value of avltree (even if it's NULL).
- * O(1) */
-extern avl_tree_t *avl_init_tree(avl_tree_t *avltree, avl_compare_t, avl_freeitem_t);
-
-/* Allocates and initializes a new tree for elements that will be
- * ordered using the supplied strcmp()-like function.
- * Aborts if memory could not be allocated.
- * O(1) */
-extern avl_tree_t *avl_alloc_tree(avl_compare_t, avl_freeitem_t);
-
-/* Frees the entire tree efficiently. Nodes will be free()d.
- * If the tree's freeitem is not NULL it will be invoked on every item.
- * O(n) */
-extern void avl_free_tree(avl_tree_t *);
-
-/* Reinitializes the tree structure for reuse. Nothing is free()d.
- * Compare and freeitem functions are left alone.
- * O(1) */
-extern void avl_clear_tree(avl_tree_t *);
-
-/* Free()s all nodes in the tree but leaves the tree itself.
- * If the tree's freeitem is not NULL it will be invoked on every item.
- * O(n) */
-extern void avl_free_nodes(avl_tree_t *);
-
-/* Initializes memory for use as a node. Returns NULL if avlnode is NULL.
- * O(1) */
-extern avl_node_t *avl_init_node(avl_node_t *avlnode, void *item);
-
-/* Insert an item into the tree and return the new node.
- * Aborts if memory for the new node could not be allocated.
- * Returns NULL if the node is already in the tree, or the new node.
- * O(lg n) */
-extern avl_node_t *avl_insert(avl_tree_t *, void *item);
-
-/* Insert a node into the tree and return it.
- * Returns NULL if the node is already in the tree.
- * O(lg n) */
-extern avl_node_t *avl_insert_node(avl_tree_t *, avl_node_t *);
-
-/* Insert a node in an empty tree. If avlnode is NULL, the tree will be
- * cleared and ready for re-use.
- * If the tree is not empty, the old nodes are left dangling.
- * O(1) */
-extern avl_node_t *avl_insert_top(avl_tree_t *, avl_node_t *avlnode);
-
-/* Insert a node before another node. Returns the new node.
- * If old is NULL, the item is appended to the tree.
- * O(lg n) */
-extern avl_node_t *avl_insert_before(avl_tree_t *, avl_node_t *old, avl_node_t *nw);
-
-/* Insert a node after another node. Returns the new node.
- * If old is NULL, the item is prepended to the tree.
- * O(lg n) */
-extern avl_node_t *avl_insert_after(avl_tree_t *, avl_node_t *old, avl_node_t *nw);
-
-/* Deletes a node from the tree. Returns immediately if the node is NULL.
- * The item will not be free()d regardless of the tree's freeitem handler.
- * This function comes in handy if you need to update the search key.
- * O(lg n) */
-extern void avl_unlink_node(avl_tree_t *, avl_node_t *);
-
-/* Deletes a node from the tree. Returns immediately if the node is NULL.
- * If the tree's freeitem is not NULL, it is invoked on the item.
- * If it is, returns the item.
- * O(lg n) */
-extern void *avl_delete_node(avl_tree_t *, avl_node_t *);
-
-/* Searches for an item in the tree and deletes it if found.
- * If the tree's freeitem is not NULL, it is invoked on the item.
- * If it is, returns the item.
- * O(lg n) */
-extern void *avl_delete(avl_tree_t *, const void *item);
-
-/* If exactly one node is moved in memory, this will fix the pointers
- * in the tree that refer to it. It must be an exact shallow copy.
- * Returns the pointer to the old position.
- * O(1) */
-extern avl_node_t *avl_fixup_node(avl_tree_t *, avl_node_t *nw);
-
-/* Searches for a node with the key closest (or equal) to the given item.
- * If avlnode is not NULL, *avlnode will be set to the node found or NULL
- * if the tree is empty. Return values:
- *   -1  if the returned node is smaller
- *    0  if the returned node is equal or if the tree is empty
- *    1  if the returned node is greater
- * O(lg n) */
-extern int avl_search_closest(const avl_tree_t *, const void *item, avl_node_t **avlnode);
-
-/* Searches for the item in the tree and returns a matching node if found
- * or NULL if not.
- * O(lg n) */
-extern avl_node_t *avl_search(const avl_tree_t *, const void *item);
-
-/* Calls the callback function for every item in the tree in order.
- * O(n) */
-extern void avl_foreach(avl_tree_t *, avl_foreach_t, void *);
-
-#ifdef AVL_COUNT
-/* Returns the number of nodes in the tree.
- * O(1) */
-extern unsigned int avl_count(const avl_tree_t *);
-
-/* Searches a node by its rank in the list. Counting starts at 0.
- * Returns NULL if the index exceeds the number of nodes in the tree.
- * O(lg n) */
-extern avl_node_t *avl_at(const avl_tree_t *, unsigned int);
-
-/* Returns the rank of a node in the list. Counting starts at 0.
- * O(lg n) */
-extern unsigned int avl_index(const avl_node_t *);
-
-/* Copies all items into an array of void *.
-* O(n) */
-extern void avl_to_array (avl_tree_t *, sc_array_t *);
-
-#endif /* AVL_COUNT */
-
-SC_EXTERN_C_END;
-
-#endif /* !_AVL_H */
diff --git a/OctreeRefinement/include/sc_blas.h b/OctreeRefinement/include/sc_blas.h
deleted file mode 100644
index 9ceca9c..0000000
--- a/OctreeRefinement/include/sc_blas.h
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_BLAS_H
-#define SC_BLAS_H
-
-#include <sc.h>
-#if defined(__bgq__)
-/* TODO - FOR NOW WE DO NOT USE ESSL
-  # include <essl.h>
-*/
-#endif
-
-SC_EXTERN_C_BEGIN;
-
-typedef int         sc_bint_t;  /* Integer type for all of the blas calls */
-typedef unsigned int sc_buint_t;        /* Unsigned Integer type for blas */
-
-typedef enum sc_trans
-{
-  SC_NO_TRANS,
-  SC_TRANS,
-  SC_TRANS_ANCHOR
-}
-sc_trans_t;
-
-typedef enum sc_uplo
-{
-  SC_UPPER,
-  SC_LOWER,
-  SC_UPLO_ANCHOR
-}
-sc_uplo_t;
-
-typedef enum sc_cmach
-{
-  SC_CMACH_EPS,                 /* relative machine precision */
-  SC_CMACH_SFMIN,               /* safe minimum, such that 1/sfmin does not
-                                 * overflow
-                                 */
-  SC_CMACH_BASE,                /* base of the machine */
-  SC_CMACH_PREC,                /* eps*base */
-  SC_CMACH_T,                   /* number of (base) digits in the mantissa */
-  SC_CMACH_RND,                 /* 1.0 when rounding occurs in addition,
-                                 * 0.0 otherwise
-                                 */
-  SC_CMACH_EMIN,                /* minimum exponent before (gradual)
-                                 * underflow
-                                 */
-  SC_CMACH_RMIN,                /* underflow threshold - base**(emin-1) */
-  SC_CMACH_EMAX,                /* largest exponent before overflow */
-  SC_CMACH_RMAX,                /* overflow threshold  - (base**emax)*(1-eps) */
-  SC_CMACH_ANCHOR
-}
-sc_cmach_t;
-
-extern const char   sc_transchar[];
-extern const char   sc_antitranschar[]; /* does not work for complex */
-extern const char   sc_uplochar[];
-extern const char   sc_cmachchar[];
-
-#ifdef SC_WITH_BLAS
-
-#ifndef SC_F77_FUNC
-#if defined(__bgq__)            /* && defined(__HAVE_ESSL) */
-#define SC_F77_FUNC(small,CAPS) small
-/* TODO - For now we do not use ESSL
-  #   define SC_F77_FUNC(small,CAPS) small ## _
-*/
-#define SC_F77_FUNC_NOESSL(small,CAPS) small
-#else
-#define SC_F77_FUNC(small,CAPS) small ## _
-#endif
-#endif /* SC_F77_FUNC */
-
-#define SC_BLAS_DLAMCH  SC_F77_FUNC(dlamch,DLAMCH)
-#define SC_BLAS_DSCAL   SC_F77_FUNC(dscal,DSCAL)
-#define SC_BLAS_DCOPY   SC_F77_FUNC(dcopy,DCOPY)
-#define SC_BLAS_DAXPY   SC_F77_FUNC(daxpy,DAXPY)
-#define SC_BLAS_DDOT    SC_F77_FUNC(ddot,DDOT)
-#define SC_BLAS_DGEMV   SC_F77_FUNC(dgemv,DGEMV)
-#define SC_BLAS_DGEMM   SC_F77_FUNC(dgemm,DGEMM)
-
-double              SC_BLAS_DLAMCH (const char *cmach);
-void                SC_BLAS_DSCAL (const sc_bint_t * n, const double *alpha,
-                                   double *X, const sc_bint_t * incx);
-void                SC_BLAS_DCOPY (const sc_bint_t * n,
-                                   const double *X, const sc_bint_t * incx,
-                                   double *Y, const sc_bint_t * incy);
-void                SC_BLAS_DAXPY (const sc_bint_t * n, const double *alpha,
-                                   const double *X, const sc_bint_t * incx,
-                                   double *Y, const sc_bint_t * incy);
-double              SC_BLAS_DDOT (const sc_bint_t * n, const double *X,
-                                  const sc_bint_t * incx, const double *Y,
-                                  const sc_bint_t * incy);
-
-void                SC_BLAS_DGEMV (const char *transa, const sc_bint_t * m,
-                                   const sc_bint_t * n, const double *alpha,
-                                   const double *a, const sc_bint_t * lda,
-                                   const double *x, const sc_bint_t * incx,
-                                   const double *beta, double *y,
-                                   const sc_bint_t * incy);
-
-void                SC_BLAS_DGEMM (const char *transa, const char *transb,
-                                   const sc_bint_t * m, const sc_bint_t * n,
-                                   const sc_bint_t * k, const double *alpha,
-                                   const double *a, const sc_bint_t * lda,
-                                   const double *b, const sc_bint_t * ldb,
-                                   const double *beta, double *c,
-                                   const sc_bint_t * ldc);
-
-#else /* !SC_WITH_BLAS */
-
-#define SC_BLAS_DLAMCH (double) sc_blas_nonimplemented
-#define SC_BLAS_DSCAL  (void)   sc_blas_nonimplemented
-#define SC_BLAS_DCOPY  (void)   sc_blas_nonimplemented
-#define SC_BLAS_DAXPY  (void)   sc_blas_nonimplemented
-#define SC_BLAS_DDOT   (double) sc_blas_nonimplemented
-#define SC_BLAS_DGEMM  (void)   sc_blas_nonimplemented
-#define SC_BLAS_DGEMV  (void)   sc_blas_nonimplemented
-
-int                 sc_blas_nonimplemented (SC_NOARGS);
-
-#endif
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_BLAS_H */
diff --git a/OctreeRefinement/include/sc_bspline.h b/OctreeRefinement/include/sc_bspline.h
deleted file mode 100644
index d97a16f..0000000
--- a/OctreeRefinement/include/sc_bspline.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_BSPLINE_H
-#define SC_BSPLINE_H
-
-#include <sc_dmatrix.h>
-
-SC_EXTERN_C_BEGIN;
-
-typedef struct
-{
-  int                 d; /** Dimensionality of control points */
-  int                 p; /** Number of control points is p + 1 */
-  int                 n; /** Polynomial degree is n >= 0 */
-  int                 m; /** Number of knots is m + 1 =  n + p + 2 */
-  int                 l; /** Number of internal intervals l = m - 2 * n > 0 */
-  int                 cacheknot;        /* previously evaluated knot interval */
-  sc_dmatrix_t       *points;   /* (p + 1) x d array of points, not owned */
-  sc_dmatrix_t       *knots;    /* m + 1 array of knots */
-  int                 knots_owned;
-  sc_dmatrix_t       *works;    /* Workspace ((n + 1) * (n + 1)) x d */
-  int                 works_owned;
-}
-sc_bspline_t;
-
-/** Compute the minimum required number of points for a certain degree.
- * \param [in] n    Polynomial degree of the spline functions, n >= 0.
- * \return          Return minimum point number = p + 1 >= n + 1.
- */
-int                 sc_bspline_min_number_points (int n);
-
-/** Compute the minimum required number of knots for a certain degree.
- * \param [in] n    Polynomial degree of the spline functions, n >= 0.
- * \return          Return minimum knot number = m + 1 >= 2 * n + 2.
- */
-int                 sc_bspline_min_number_knots (int n);
-
-/** Create a uniform B-spline knot vector.
- * \param [in] n        Polynomial degree of the spline functions, n >= 0.
- * \param [in] points   (p + 1) x d array of points in R^d, p >= 0, d >= 1.
- * \return              (n + p + 2) x 1 array of knots.
- */
-sc_dmatrix_t       *sc_bspline_knots_new (int n, sc_dmatrix_t * points);
-
-/** Create a B-spline knots array roughly proportional to the arc length.
- * This works only for at least linear B-splines, n >= 1.
- * \param [in] n        Polynomial degree of the spline functions, n >= 1.
- * \param [in] points   (p + 1) x d array of points in R^d, p >= 0, d >= 1.
- * \return              (n + p + 2) x 1 array of knots.
- */
-sc_dmatrix_t       *sc_bspline_knots_new_length (int n,
-                                                 sc_dmatrix_t * points);
-
-/** Create a uniform B-spline knot vector for a periodic B-spline.
- * \param [in] n        Polynomial degree of the spline functions, n >= 0.
- * \param [in] points   (p + 1) x d array of points in R^d, p >= 0, d >= 1.
- * \return              (n + p + 2) x 1 array of knots.
- */
-sc_dmatrix_t       *sc_bspline_knots_new_periodic (int n,
-                                                   sc_dmatrix_t * points);
-
-/** Create a B-spline knots array roughly proportional to the arc length for a
- * periodic B-spline.
- * This works only for at least linear B-splines, n >= 1.
- * \param [in] n        Polynomial degree of the spline functions, n >= 1.
- * \param [in] points   (p + 1) x d array of points in R^d, p >= 0, d >= 1.
- * \return              (n + p + 2) x 1 array of knots.
- */
-sc_dmatrix_t       *sc_bspline_knots_new_length_periodic (int n,
-                                                          sc_dmatrix_t *
-                                                          points);
-
-/** Take a vector of points and make them appropriate for a periodic B-spine.
- * \param [in] n          Polynomial degree of the spline functions, n >= 0.
- * \param [in,out] points On input, an (l x d) array of points in R^d, l > 0,
- *                        d >= 1.  If n is odd, these points are associated
- *                        with the left endpoints of the intervals over
- *                        which the B-spline is fully defined; if n is odd,
- *                        they are associated with the midpoints.
- *                        On output, points is a (l + n) x d, array of points
- *                        appropriate for use as control points for a periodic
- *                        B-spline.
- */
-void                sc_bspline_make_points_periodic (int n, sc_dmatrix_t *
-                                                     points);
-
-/** Create workspace for B-spline evaluation.
- * \param [in] n        Polynomial degree of the spline functions, n >= 0.
- * \param [in] d        Dimension of the control points in R^d, d >= 1.
- * \return              Workspace ((n + 1) * (n + 1)) x d.
- */
-sc_dmatrix_t       *sc_bspline_workspace_new (int n, int d);
-
-/** Create a new B-spline structure.
- * \param [in] n        Polynomial degree of the spline functions, n >= 0.
- * \param [in] points   (p + 1) x d array of points in R^d, p >= 0, d >= 1.
- *                      Borrowed, matrix is not copied so it must not be
- *                      destroyed while the B-spline structure is in use.
- * \param [in] knots    (n + p + 2) x 1 array of knots.  Borrowed.
- *                      If NULL the knots are computed equidistantly.
- * \param [in] works    Workspace ((n + 1) * (n + 1)) x d.  Borrowed.
- *                      If NULL the workspace is allocated internally.
- */
-sc_bspline_t       *sc_bspline_new (int n, sc_dmatrix_t * points,
-                                    sc_dmatrix_t * knots,
-                                    sc_dmatrix_t * works);
-
-/** Destroy a B-spline structure.
- */
-void                sc_bspline_destroy (sc_bspline_t * bs);
-
-/** Evaluate a B-spline at a certain point.
- * \param [in] bs       B-spline structure.
- * \param [in] t        Value that must be within the range of the knots.
- * \param [out] result  The computed point in R^d is placed here.
- */
-void                sc_bspline_evaluate (sc_bspline_t * bs,
-                                         double t, double *result);
-
-/** Evaluate a B-spline derivative at a certain point.
- * \param [in] bs       B-spline structure.
- * \param [in] t        Value that must be within the range of the knots.
- * \param [out] result  The computed derivative in R^d is placed here.
- */
-void                sc_bspline_derivative (sc_bspline_t * bs,
-                                           double t, double *result);
-
-/** Evaluate any order B-spline derivative at a certain point.
- * \param [in] bs       B-spline structure.
- * \param [in] order    Order of the derivative >= 0.
- * \param [in] t        Value that must be within the range of the knots.
- * \param [out] result  The computed derivative in R^d is placed here.
- */
-void                sc_bspline_derivative_n (sc_bspline_t * bs, int order,
-                                             double t, double *result);
-
-/** Evaluate a B-spline derivative at a certain point.  Obsolete.
- * \param [in] bs       B-spline structure.
- * \param [in] t        Value that must be within the range of the knots.
- * \param [out] result  The computed derivative in R^d is placed here.
- */
-void                sc_bspline_derivative2 (sc_bspline_t * bs,
-                                            double t, double *result);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_BSPLINE_H */
diff --git a/OctreeRefinement/include/sc_builtin/getopt.h b/OctreeRefinement/include/sc_builtin/getopt.h
deleted file mode 100644
index b7a026c..0000000
--- a/OctreeRefinement/include/sc_builtin/getopt.h
+++ /dev/null
@@ -1,177 +0,0 @@
-/* Declarations for getopt.
-   Copyright (C) 1989-1994,1996-1999,2001,2003,2004
-   Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _GETOPT_H
-
-#ifndef __need_getopt
-# define _GETOPT_H 1
-#endif
-
-/* If __GNU_LIBRARY__ is not already defined, either we are being used
-   standalone, or this is the first header included in the source file.
-   If we are being used with glibc, we need to include <features.h>, but
-   that does not exist if we are standalone.  So: if __GNU_LIBRARY__ is
-   not defined, include <ctype.h>, which will pull in <features.h> for us
-   if it's from glibc.  (Why ctype.h?  It's guaranteed to exist and it
-   doesn't flood the namespace with stuff the way some other headers do.)  */
-#if !defined __GNU_LIBRARY__
-# include <ctype.h>
-#endif
-
-#ifndef __THROW
-# ifndef __GNUC_PREREQ
-#  define __GNUC_PREREQ(maj, min) (0)
-# endif
-# if defined __cplusplus && __GNUC_PREREQ (2,8)
-#  define __THROW	throw ()
-# else
-#  define __THROW
-# endif
-#endif
-
-#ifdef	__cplusplus
-extern "C" {
-#endif
-
-/* For communication from `getopt' to the caller.
-   When `getopt' finds an option that takes an argument,
-   the argument value is returned here.
-   Also, when `ordering' is RETURN_IN_ORDER,
-   each non-option ARGV-element is returned here.  */
-
-extern char *optarg;
-
-/* Index in ARGV of the next element to be scanned.
-   This is used for communication to and from the caller
-   and for communication between successive calls to `getopt'.
-
-   On entry to `getopt', zero means this is the first call; initialize.
-
-   When `getopt' returns -1, this is the index of the first of the
-   non-option elements that the caller should itself scan.
-
-   Otherwise, `optind' communicates from one call to the next
-   how much of ARGV has been scanned so far.  */
-
-extern int optind;
-
-/* Callers store zero here to inhibit the error message `getopt' prints
-   for unrecognized options.  */
-
-extern int opterr;
-
-/* Set to an option character which was unrecognized.  */
-
-extern int optopt;
-
-#ifndef __need_getopt
-/* Describe the long-named options requested by the application.
-   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector
-   of `struct option' terminated by an element containing a name which is
-   zero.
-
-   The field `has_arg' is:
-   no_argument		(or 0) if the option does not take an argument,
-   required_argument	(or 1) if the option requires an argument,
-   optional_argument 	(or 2) if the option takes an optional argument.
-
-   If the field `flag' is not NULL, it points to a variable that is set
-   to the value given in the field `val' when the option is found, but
-   left unchanged if the option is not found.
-
-   To have a long-named option do something other than set an `int' to
-   a compiled-in constant, such as set a value from `optarg', set the
-   option's `flag' field to zero and its `val' field to a nonzero
-   value (the equivalent single-letter option character, if there is
-   one).  For long options that have a zero `flag' field, `getopt'
-   returns the contents of the `val' field.  */
-
-struct option
-{
-  const char *name;
-  /* has_arg can't be an enum because some compilers complain about
-     type mismatches in all the code that assumes it is an int.  */
-  int has_arg;
-  int *flag;
-  int val;
-};
-
-/* Names for the values of the `has_arg' field of `struct option'.  */
-
-# define no_argument		0
-# define required_argument	1
-# define optional_argument	2
-#endif	/* need getopt */
-
-
-/* Get definitions and prototypes for functions to process the
-   arguments in ARGV (ARGC of them, minus the program name) for
-   options given in OPTS.
-
-   Return the option character from OPTS just read.  Return -1 when
-   there are no more options.  For unrecognized options, or options
-   missing arguments, `optopt' is set to the option letter, and '?' is
-   returned.
-
-   The OPTS string is a list of characters which are recognized option
-   letters, optionally followed by colons, specifying that that letter
-   takes an argument, to be placed in `optarg'.
-
-   If a letter in OPTS is followed by two colons, its argument is
-   optional.  This behavior is specific to the GNU `getopt'.
-
-   The argument `--' causes premature termination of argument
-   scanning, explicitly telling `getopt' that there are no more
-   options.
-
-   If OPTS begins with `--', then non-option arguments are treated as
-   arguments to the option '\0'.  This behavior is specific to the GNU
-   `getopt'.  */
-
-#ifdef __GNU_LIBRARY__
-/* Many other libraries have conflicting prototypes for getopt, with
-   differences in the consts, in stdlib.h.  To avoid compilation
-   errors, only prototype getopt for the GNU C library.  */
-extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
-       __THROW;
-#else /* not __GNU_LIBRARY__ */
-extern int getopt ();
-#endif /* __GNU_LIBRARY__ */
-
-#ifndef __need_getopt
-extern int getopt_long (int ___argc, char *const *___argv,
-			const char *__shortopts,
-		        const struct option *__longopts, int *__longind)
-       __THROW;
-extern int getopt_long_only (int ___argc, char *const *___argv,
-			     const char *__shortopts,
-		             const struct option *__longopts, int *__longind)
-       __THROW;
-
-#endif
-
-#ifdef	__cplusplus
-}
-#endif
-
-/* Make sure we later can get all the definitions and declarations.  */
-#undef __need_getopt
-
-#endif /* getopt.h */
diff --git a/OctreeRefinement/include/sc_builtin/getopt_int.h b/OctreeRefinement/include/sc_builtin/getopt_int.h
deleted file mode 100644
index d982c72..0000000
--- a/OctreeRefinement/include/sc_builtin/getopt_int.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/* Internal declarations for getopt.
-   Copyright (C) 1989-1994,1996-1999,2001,2003,2004
-   Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _GETOPT_INT_H
-#define _GETOPT_INT_H	1
-
-extern int _getopt_internal (int ___argc, char *const *___argv,
-			     const char *__shortopts,
-		             const struct option *__longopts, int *__longind,
-			     int __long_only);
-
-
-/* Reentrant versions which can handle parsing multiple argument
-   vectors at the same time.  */
-
-/* Data type for reentrant functions.  */
-struct _getopt_data
-{
-  /* These have exactly the same meaning as the corresponding global
-     variables, except that they are used for the reentrant
-     versions of getopt.  */
-  int optind;
-  int opterr;
-  int optopt;
-  char *optarg;
-
-  /* Internal members.  */
-
-  /* True if the internal members have been initialized.  */
-  int __initialized;
-
-  /* The next char to be scanned in the option-element
-     in which the last option character we returned was found.
-     This allows us to pick up the scan where we left off.
-
-     If this is zero, or a null string, it means resume the scan
-     by advancing to the next ARGV-element.  */
-  char *__nextchar;
-
-  /* Describe how to deal with options that follow non-option ARGV-elements.
-
-     If the caller did not specify anything,
-     the default is REQUIRE_ORDER if the environment variable
-     POSIXLY_CORRECT is defined, PERMUTE otherwise.
-
-     REQUIRE_ORDER means don't recognize them as options;
-     stop option processing when the first non-option is seen.
-     This is what Unix does.
-     This mode of operation is selected by either setting the environment
-     variable POSIXLY_CORRECT, or using `+' as the first character
-     of the list of option characters.
-
-     PERMUTE is the default.  We permute the contents of ARGV as we
-     scan, so that eventually all the non-options are at the end.
-     This allows options to be given in any order, even with programs
-     that were not written to expect this.
-
-     RETURN_IN_ORDER is an option available to programs that were
-     written to expect options and other ARGV-elements in any order
-     and that care about the ordering of the two.  We describe each
-     non-option ARGV-element as if it were the argument of an option
-     with character code 1.  Using `-' as the first character of the
-     list of option characters selects this mode of operation.
-
-     The special argument `--' forces an end of option-scanning regardless
-     of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
-     `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
-
-  enum
-    {
-      REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
-    } __ordering;
-
-  /* If the POSIXLY_CORRECT environment variable is set.  */
-  int __posixly_correct;
-
-
-  /* Handle permutation of arguments.  */
-
-  /* Describe the part of ARGV that contains non-options that have
-     been skipped.  `first_nonopt' is the index in ARGV of the first
-     of them; `last_nonopt' is the index after the last of them.  */
-
-  int __first_nonopt;
-  int __last_nonopt;
-
-#if defined _LIBC && defined USE_NONOPTION_FLAGS
-  int __nonoption_flags_max_len;
-  int __nonoption_flags_len;
-# endif
-};
-
-/* The initializer is necessary to set OPTIND and OPTERR to their
-   default values and to clear the initialization flag.  */
-#define _GETOPT_DATA_INITIALIZER	{ 1, 1 }
-
-extern int _getopt_internal_r (int ___argc, char *const *___argv,
-			       const char *__shortopts,
-			       const struct option *__longopts, int *__longind,
-			       int __long_only, struct _getopt_data *__data);
-
-extern int _getopt_long_r (int ___argc, char *const *___argv,
-			   const char *__shortopts,
-			   const struct option *__longopts, int *__longind,
-			   struct _getopt_data *__data);
-
-extern int _getopt_long_only_r (int ___argc, char *const *___argv,
-				const char *__shortopts,
-				const struct option *__longopts,
-				int *__longind,
-				struct _getopt_data *__data);
-
-#endif /* getopt_int.h */
diff --git a/OctreeRefinement/include/sc_builtin/obstack.h b/OctreeRefinement/include/sc_builtin/obstack.h
deleted file mode 100644
index 206fe55..0000000
--- a/OctreeRefinement/include/sc_builtin/obstack.h
+++ /dev/null
@@ -1,509 +0,0 @@
-/* obstack.h - object stack macros
-   Copyright (C) 1988-1994,1996-1999,2003,2004,2005
-	Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
-
-/* Summary:
-
-All the apparent functions defined here are macros. The idea
-is that you would use these pre-tested macros to solve a
-very specific set of problems, and they would run fast.
-Caution: no side-effects in arguments please!! They may be
-evaluated MANY times!!
-
-These macros operate a stack of objects.  Each object starts life
-small, and may grow to maturity.  (Consider building a word syllable
-by syllable.)  An object can move while it is growing.  Once it has
-been "finished" it never changes address again.  So the "top of the
-stack" is typically an immature growing object, while the rest of the
-stack is of mature, fixed size and fixed address objects.
-
-These routines grab large chunks of memory, using a function you
-supply, called `obstack_chunk_alloc'.  On occasion, they free chunks,
-by calling `obstack_chunk_free'.  You must define them and declare
-them before using any obstack macros.
-
-Each independent stack is represented by a `struct obstack'.
-Each of the obstack macros expects a pointer to such a structure
-as the first argument.
-
-One motivation for this package is the problem of growing char strings
-in symbol tables.  Unless you are "fascist pig with a read-only mind"
---Gosper's immortal quote from HAKMEM item 154, out of context--you
-would not like to put any arbitrary upper limit on the length of your
-symbols.
-
-In practice this often means you will build many short symbols and a
-few long symbols.  At the time you are reading a symbol you don't know
-how long it is.  One traditional method is to read a symbol into a
-buffer, realloc()ating the buffer every time you try to read a symbol
-that is longer than the buffer.  This is beaut, but you still will
-want to copy the symbol from the buffer to a more permanent
-symbol-table entry say about half the time.
-
-With obstacks, you can work differently.  Use one obstack for all symbol
-names.  As you read a symbol, grow the name in the obstack gradually.
-When the name is complete, finalize it.  Then, if the symbol exists already,
-free the newly read name.
-
-The way we do this is to take a large chunk, allocating memory from
-low addresses.  When you want to build a symbol in the chunk you just
-add chars above the current "high water mark" in the chunk.  When you
-have finished adding chars, because you got to the end of the symbol,
-you know how long the chars are, and you can create a new object.
-Mostly the chars will not burst over the highest address of the chunk,
-because you would typically expect a chunk to be (say) 100 times as
-long as an average object.
-
-In case that isn't clear, when we have enough chars to make up
-the object, THEY ARE ALREADY CONTIGUOUS IN THE CHUNK (guaranteed)
-so we just point to it where it lies.  No moving of chars is
-needed and this is the second win: potentially long strings need
-never be explicitly shuffled. Once an object is formed, it does not
-change its address during its lifetime.
-
-When the chars burst over a chunk boundary, we allocate a larger
-chunk, and then copy the partly formed object from the end of the old
-chunk to the beginning of the new larger chunk.  We then carry on
-accreting characters to the end of the object as we normally would.
-
-A special macro is provided to add a single char at a time to a
-growing object.  This allows the use of register variables, which
-break the ordinary 'growth' macro.
-
-Summary:
-	We allocate large chunks.
-	We carve out one object at a time from the current chunk.
-	Once carved, an object never moves.
-	We are free to append data of any size to the currently
-	  growing object.
-	Exactly one object is growing in an obstack at any one time.
-	You can run one obstack per control block.
-	You may have as many control blocks as you dare.
-	Because of the way we do it, you can `unwind' an obstack
-	  back to a previous state. (You may remove objects much
-	  as you would with a stack.)
-*/
-
-
-/* Don't do the contents of this file more than once.  */
-
-#ifndef _OBSTACK_H
-#define _OBSTACK_H 1
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* We need the type of a pointer subtraction.  If __PTRDIFF_TYPE__ is
-   defined, as with GNU C, use that; that way we don't pollute the
-   namespace with <stddef.h>'s symbols.  Otherwise, include <stddef.h>
-   and use ptrdiff_t.  */
-
-#ifdef __PTRDIFF_TYPE__
-# define PTR_INT_TYPE __PTRDIFF_TYPE__
-#else
-# include <stddef.h>
-# define PTR_INT_TYPE ptrdiff_t
-#endif
-
-/* If B is the base of an object addressed by P, return the result of
-   aligning P to the next multiple of A + 1.  B and P must be of type
-   char *.  A + 1 must be a power of 2.  */
-
-#define __BPTR_ALIGN(B, P, A) ((B) + (((P) - (B) + (A)) & ~(A)))
-
-/* Similiar to _BPTR_ALIGN (B, P, A), except optimize the common case
-   where pointers can be converted to integers, aligned as integers,
-   and converted back again.  If PTR_INT_TYPE is narrower than a
-   pointer (e.g., the AS/400), play it safe and compute the alignment
-   relative to B.  Otherwise, use the faster strategy of computing the
-   alignment relative to 0.  */
-
-#define __PTR_ALIGN(B, P, A)						    \
-  __BPTR_ALIGN (sizeof (PTR_INT_TYPE) < sizeof (void *) ? (B) : (char *) 0, \
-		P, A)
-
-#include <string.h>
-
-struct _obstack_chunk		/* Lives at front of each chunk. */
-{
-  char  *limit;			/* 1 past end of this chunk */
-  struct _obstack_chunk *prev;	/* address of prior chunk or NULL */
-  char	contents[4];		/* objects begin here */
-};
-
-struct obstack		/* control current object in current chunk */
-{
-  long	chunk_size;		/* preferred size to allocate chunks in */
-  struct _obstack_chunk *chunk;	/* address of current struct obstack_chunk */
-  char	*object_base;		/* address of object we are building */
-  char	*next_free;		/* where to add next char to current object */
-  char	*chunk_limit;		/* address of char after current chunk */
-  union
-  {
-    PTR_INT_TYPE tempint;
-    void *tempptr;
-  } temp;			/* Temporary for some macros.  */
-  int   alignment_mask;		/* Mask of alignment for each object. */
-  /* These prototypes vary based on `use_extra_arg', and we use
-     casts to the prototypeless function type in all assignments,
-     but having prototypes here quiets -Wstrict-prototypes.  */
-  struct _obstack_chunk *(*chunkfun) (void *, long);
-  void (*freefun) (void *, struct _obstack_chunk *);
-  void *extra_arg;		/* first arg for chunk alloc/dealloc funcs */
-  unsigned use_extra_arg:1;	/* chunk alloc/dealloc funcs take extra arg */
-  unsigned maybe_empty_object:1;/* There is a possibility that the current
-				   chunk contains a zero-length object.  This
-				   prevents freeing the chunk if we allocate
-				   a bigger chunk to replace it. */
-  unsigned alloc_failed:1;	/* No longer used, as we now call the failed
-				   handler on error, but retained for binary
-				   compatibility.  */
-};
-
-/* Declare the external functions we use; they are in obstack.c.  */
-
-extern void _obstack_newchunk (struct obstack *, int);
-extern int _obstack_begin (struct obstack *, int, int,
-			    void *(*) (long), void (*) (void *));
-extern int _obstack_begin_1 (struct obstack *, int, int,
-			     void *(*) (void *, long),
-			     void (*) (void *, void *), void *);
-extern int _obstack_memory_used (struct obstack *);
-
-void obstack_free (struct obstack *obstack, void *block);
-
-
-/* Error handler called when `obstack_chunk_alloc' failed to allocate
-   more memory.  This can be set to a user defined function which
-   should either abort gracefully or use longjump - but shouldn't
-   return.  The default action is to print a message and abort.  */
-extern void (*obstack_alloc_failed_handler) (void);
-
-/* Exit value used when `print_and_abort' is used.  */
-extern int obstack_exit_failure;
-
-/* Pointer to beginning of object being allocated or to be allocated next.
-   Note that this might not be the final address of the object
-   because a new chunk might be needed to hold the final size.  */
-
-#define obstack_base(h) ((void *) (h)->object_base)
-
-/* Size for allocating ordinary chunks.  */
-
-#define obstack_chunk_size(h) ((h)->chunk_size)
-
-/* Pointer to next byte not yet allocated in current chunk.  */
-
-#define obstack_next_free(h)	((h)->next_free)
-
-/* Mask specifying low bits that should be clear in address of an object.  */
-
-#define obstack_alignment_mask(h) ((h)->alignment_mask)
-
-/* To prevent prototype warnings provide complete argument list.  */
-#define obstack_init(h)						\
-  _obstack_begin ((h), 0, 0,					\
-		  (void *(*) (long)) obstack_chunk_alloc,	\
-		  (void (*) (void *)) obstack_chunk_free)
-
-#define obstack_begin(h, size)					\
-  _obstack_begin ((h), (size), 0,				\
-		  (void *(*) (long)) obstack_chunk_alloc,	\
-		  (void (*) (void *)) obstack_chunk_free)
-
-#define obstack_specify_allocation(h, size, alignment, chunkfun, freefun)  \
-  _obstack_begin ((h), (size), (alignment),				   \
-		  (void *(*) (long)) (chunkfun),			   \
-		  (void (*) (void *)) (freefun))
-
-#define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \
-  _obstack_begin_1 ((h), (size), (alignment),				\
-		    (void *(*) (void *, long)) (chunkfun),		\
-		    (void (*) (void *, void *)) (freefun), (arg))
-
-#define obstack_chunkfun(h, newchunkfun) \
-  ((h) -> chunkfun = (struct _obstack_chunk *(*)(void *, long)) (newchunkfun))
-
-#define obstack_freefun(h, newfreefun) \
-  ((h) -> freefun = (void (*)(void *, struct _obstack_chunk *)) (newfreefun))
-
-#define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = (achar))
-
-#define obstack_blank_fast(h,n) ((h)->next_free += (n))
-
-#define obstack_memory_used(h) _obstack_memory_used (h)
-
-#if defined __GNUC__ && defined __STDC__ && __STDC__
-/* NextStep 2.0 cc is really gcc 1.93 but it defines __GNUC__ = 2 and
-   does not implement __extension__.  But that compiler doesn't define
-   __GNUC_MINOR__.  */
-# if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)
-#  define __extension__
-# endif
-
-/* For GNU C, if not -traditional,
-   we can define these macros to compute all args only once
-   without using a global variable.
-   Also, we can avoid using the `temp' slot, to make faster code.  */
-
-# define obstack_object_size(OBSTACK)					\
-  __extension__								\
-  ({ struct obstack const *__o = (OBSTACK);				\
-     (unsigned) (__o->next_free - __o->object_base); })
-
-# define obstack_room(OBSTACK)						\
-  __extension__								\
-  ({ struct obstack const *__o = (OBSTACK);				\
-     (unsigned) (__o->chunk_limit - __o->next_free); })
-
-# define obstack_make_room(OBSTACK,length)				\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   int __len = (length);						\
-   if (__o->chunk_limit - __o->next_free < __len)			\
-     _obstack_newchunk (__o, __len);					\
-   (void) 0; })
-
-# define obstack_empty_p(OBSTACK)					\
-  __extension__								\
-  ({ struct obstack const *__o = (OBSTACK);				\
-     (__o->chunk->prev == 0						\
-      && __o->next_free == __PTR_ALIGN ((char *) __o->chunk,		\
-					__o->chunk->contents,		\
-					__o->alignment_mask)); })
-
-# define obstack_grow(OBSTACK,where,length)				\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   int __len = (length);						\
-   if (__o->next_free + __len > __o->chunk_limit)			\
-     _obstack_newchunk (__o, __len);					\
-   memcpy (__o->next_free, where, __len);				\
-   __o->next_free += __len;						\
-   (void) 0; })
-
-# define obstack_grow0(OBSTACK,where,length)				\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   int __len = (length);						\
-   if (__o->next_free + __len + 1 > __o->chunk_limit)			\
-     _obstack_newchunk (__o, __len + 1);				\
-   memcpy (__o->next_free, where, __len);				\
-   __o->next_free += __len;						\
-   *(__o->next_free)++ = 0;						\
-   (void) 0; })
-
-# define obstack_1grow(OBSTACK,datum)					\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   if (__o->next_free + 1 > __o->chunk_limit)				\
-     _obstack_newchunk (__o, 1);					\
-   obstack_1grow_fast (__o, datum);					\
-   (void) 0; })
-
-/* These assume that the obstack alignment is good enough for pointers
-   or ints, and that the data added so far to the current object
-   shares that much alignment.  */
-
-# define obstack_ptr_grow(OBSTACK,datum)				\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   if (__o->next_free + sizeof (void *) > __o->chunk_limit)		\
-     _obstack_newchunk (__o, sizeof (void *));				\
-   obstack_ptr_grow_fast (__o, datum); })				\
-
-# define obstack_int_grow(OBSTACK,datum)				\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   if (__o->next_free + sizeof (int) > __o->chunk_limit)		\
-     _obstack_newchunk (__o, sizeof (int));				\
-   obstack_int_grow_fast (__o, datum); })
-
-# define obstack_ptr_grow_fast(OBSTACK,aptr)				\
-__extension__								\
-({ struct obstack *__o1 = (OBSTACK);					\
-   *(const void **) __o1->next_free = (aptr);				\
-   __o1->next_free += sizeof (const void *);				\
-   (void) 0; })
-
-# define obstack_int_grow_fast(OBSTACK,aint)				\
-__extension__								\
-({ struct obstack *__o1 = (OBSTACK);					\
-   *(int *) __o1->next_free = (aint);					\
-   __o1->next_free += sizeof (int);					\
-   (void) 0; })
-
-# define obstack_blank(OBSTACK,length)					\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   int __len = (length);						\
-   if (__o->chunk_limit - __o->next_free < __len)			\
-     _obstack_newchunk (__o, __len);					\
-   obstack_blank_fast (__o, __len);					\
-   (void) 0; })
-
-# define obstack_alloc(OBSTACK,length)					\
-__extension__								\
-({ struct obstack *__h = (OBSTACK);					\
-   obstack_blank (__h, (length));					\
-   obstack_finish (__h); })
-
-# define obstack_copy(OBSTACK,where,length)				\
-__extension__								\
-({ struct obstack *__h = (OBSTACK);					\
-   obstack_grow (__h, (where), (length));				\
-   obstack_finish (__h); })
-
-# define obstack_copy0(OBSTACK,where,length)				\
-__extension__								\
-({ struct obstack *__h = (OBSTACK);					\
-   obstack_grow0 (__h, (where), (length));				\
-   obstack_finish (__h); })
-
-/* The local variable is named __o1 to avoid a name conflict
-   when obstack_blank is called.  */
-# define obstack_finish(OBSTACK)					\
-__extension__								\
-({ struct obstack *__o1 = (OBSTACK);					\
-   void *__value = (void *) __o1->object_base;				\
-   if (__o1->next_free == __value)					\
-     __o1->maybe_empty_object = 1;					\
-   __o1->next_free							\
-     = __PTR_ALIGN (__o1->object_base, __o1->next_free,			\
-		    __o1->alignment_mask);				\
-   if (__o1->next_free - (char *)__o1->chunk				\
-       > __o1->chunk_limit - (char *)__o1->chunk)			\
-     __o1->next_free = __o1->chunk_limit;				\
-   __o1->object_base = __o1->next_free;					\
-   __value; })
-
-# define obstack_free(OBSTACK, OBJ)					\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   void *__obj = (OBJ);							\
-   if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit)  \
-     __o->next_free = __o->object_base = (char *)__obj;			\
-   else (obstack_free) (__o, __obj); })
-
-#else /* not __GNUC__ or not __STDC__ */
-
-# define obstack_object_size(h) \
- (unsigned) ((h)->next_free - (h)->object_base)
-
-# define obstack_room(h)		\
- (unsigned) ((h)->chunk_limit - (h)->next_free)
-
-# define obstack_empty_p(h) \
- ((h)->chunk->prev == 0							\
-  && (h)->next_free == __PTR_ALIGN ((char *) (h)->chunk,		\
-				    (h)->chunk->contents,		\
-				    (h)->alignment_mask))
-
-/* Note that the call to _obstack_newchunk is enclosed in (..., 0)
-   so that we can avoid having void expressions
-   in the arms of the conditional expression.
-   Casting the third operand to void was tried before,
-   but some compilers won't accept it.  */
-
-# define obstack_make_room(h,length)					\
-( (h)->temp.tempint = (length),						\
-  (((h)->next_free + (h)->temp.tempint > (h)->chunk_limit)		\
-   ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0))
-
-# define obstack_grow(h,where,length)					\
-( (h)->temp.tempint = (length),						\
-  (((h)->next_free + (h)->temp.tempint > (h)->chunk_limit)		\
-   ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0),		\
-  memcpy ((h)->next_free, where, (h)->temp.tempint),			\
-  (h)->next_free += (h)->temp.tempint)
-
-# define obstack_grow0(h,where,length)					\
-( (h)->temp.tempint = (length),						\
-  (((h)->next_free + (h)->temp.tempint + 1 > (h)->chunk_limit)		\
-   ? (_obstack_newchunk ((h), (h)->temp.tempint + 1), 0) : 0),		\
-  memcpy ((h)->next_free, where, (h)->temp.tempint),			\
-  (h)->next_free += (h)->temp.tempint,					\
-  *((h)->next_free)++ = 0)
-
-# define obstack_1grow(h,datum)						\
-( (((h)->next_free + 1 > (h)->chunk_limit)				\
-   ? (_obstack_newchunk ((h), 1), 0) : 0),				\
-  obstack_1grow_fast (h, datum))
-
-# define obstack_ptr_grow(h,datum)					\
-( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)		\
-   ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),		\
-  obstack_ptr_grow_fast (h, datum))
-
-# define obstack_int_grow(h,datum)					\
-( (((h)->next_free + sizeof (int) > (h)->chunk_limit)			\
-   ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),			\
-  obstack_int_grow_fast (h, datum))
-
-# define obstack_ptr_grow_fast(h,aptr)					\
-  (((const void **) ((h)->next_free += sizeof (void *)))[-1] = (aptr))
-
-# define obstack_int_grow_fast(h,aint)					\
-  (((int *) ((h)->next_free += sizeof (int)))[-1] = (aint))
-
-# define obstack_blank(h,length)					\
-( (h)->temp.tempint = (length),						\
-  (((h)->chunk_limit - (h)->next_free < (h)->temp.tempint)		\
-   ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0),		\
-  obstack_blank_fast (h, (h)->temp.tempint))
-
-# define obstack_alloc(h,length)					\
- (obstack_blank ((h), (length)), obstack_finish ((h)))
-
-# define obstack_copy(h,where,length)					\
- (obstack_grow ((h), (where), (length)), obstack_finish ((h)))
-
-# define obstack_copy0(h,where,length)					\
- (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))
-
-# define obstack_finish(h)						\
-( ((h)->next_free == (h)->object_base					\
-   ? (((h)->maybe_empty_object = 1), 0)					\
-   : 0),								\
-  (h)->temp.tempptr = (h)->object_base,					\
-  (h)->next_free							\
-    = __PTR_ALIGN ((h)->object_base, (h)->next_free,			\
-		   (h)->alignment_mask),				\
-  (((h)->next_free - (char *) (h)->chunk				\
-    > (h)->chunk_limit - (char *) (h)->chunk)				\
-   ? ((h)->next_free = (h)->chunk_limit) : 0),				\
-  (h)->object_base = (h)->next_free,					\
-  (h)->temp.tempptr)
-
-# define obstack_free(h,obj)						\
-( (h)->temp.tempint = (char *) (obj) - (char *) (h)->chunk,		\
-  ((((h)->temp.tempint > 0						\
-    && (h)->temp.tempint < (h)->chunk_limit - (char *) (h)->chunk))	\
-   ? (int) ((h)->next_free = (h)->object_base				\
-	    = (h)->temp.tempint + (char *) (h)->chunk)			\
-   : (((obstack_free) ((h), (h)->temp.tempint + (char *) (h)->chunk), 0), 0)))
-
-#endif /* not __GNUC__ or not __STDC__ */
-
-#ifdef __cplusplus
-}	/* C++ */
-#endif
-
-#endif /* obstack.h */
diff --git a/OctreeRefinement/include/sc_config.h b/OctreeRefinement/include/sc_config.h
deleted file mode 100644
index bc03223..0000000
--- a/OctreeRefinement/include/sc_config.h
+++ /dev/null
@@ -1,470 +0,0 @@
-#ifndef _SRC_SC_CONFIG_H
-#define _SRC_SC_CONFIG_H 1
- 
-/* src/sc_config.h. Generated automatically at end of configure. */
-/* src/pre_config.h.  Generated from pre_config.h.in by configure.  */
-/* src/pre_config.h.in.  Generated from configure.ac by autoheader.  */
-
-/* Define if building universal (internal helper macro) */
-/* #undef AC_APPLE_UNIVERSAL_BUILD */
-
-/* C compiler */
-#ifndef SC_CC
-#define SC_CC "gcc"
-#endif
-
-/* C compiler flags */
-#ifndef SC_CFLAGS
-#define SC_CFLAGS "-g -O2"
-#endif
-
-/* C preprocessor */
-#ifndef SC_CPP
-#define SC_CPP "gcc -E"
-#endif
-
-/* C preprocessor flags */
-#ifndef SC_CPPFLAGS
-#define SC_CPPFLAGS ""
-#endif
-
-/* CXX compiler */
-#ifndef SC_CXX
-#define SC_CXX "g++"
-#endif
-
-/* CXX compiler flags */
-#ifndef SC_CXXFLAGS
-#define SC_CXXFLAGS "-g -O2"
-#endif
-
-/* Define to 1 if your C++ compiler doesn't accept -c and -o together. */
-/* #undef CXX_NO_MINUS_C_MINUS_O */
-
-/* DEPRECATED (use SC_ENABLE_DEBUG instead) */
-/* #undef DEBUG */
-
-/* enable debug mode (assertions and extra checks) */
-/* #undef ENABLE_DEBUG */
-
-/* Undefine if: use aligned malloc (optionally use --enable-memalign=<bytes>)
-   */
-#ifndef SC_ENABLE_MEMALIGN
-#define SC_ENABLE_MEMALIGN 1
-#endif
-
-/* Define to 1 if we are using MPI */
-/* #undef ENABLE_MPI */
-
-/* Define to 1 if we can use MPI_COMM_TYPE_SHARED */
-/* #undef ENABLE_MPICOMMSHARED */
-
-/* Define to 1 if we are using MPI I/O */
-/* #undef ENABLE_MPIIO */
-
-/* Define to 1 if we are using MPI_Init_thread */
-/* #undef ENABLE_MPITHREAD */
-
-/* Define to 1 if we can use MPI_Win_allocate_shared */
-/* #undef ENABLE_MPIWINSHARED */
-
-/* enable OpenMP (optionally use --enable-openmp=<OPENMP_CFLAGS>) */
-/* #undef ENABLE_OPENMP */
-
-/* enable POSIX threads (optionally use --enable-pthread=<PTHREAD_CFLAGS>) */
-/* #undef ENABLE_PTHREAD */
-
-/* Undefine if: replace array/dmatrix resize with malloc/copy/free */
-#ifndef SC_ENABLE_USE_REALLOC
-#define SC_ENABLE_USE_REALLOC 1
-#endif
-
-/* F77 compiler */
-#ifndef SC_F77
-#define SC_F77 "gfortran"
-#endif
-
-/* Define to dummy `main' function (if any) required to link to the Fortran
-   libraries. */
-/* #undef F77_DUMMY_MAIN */
-
-/* Define to a macro mangling the given C identifier (in lower and upper
-   case), which must not contain underscores, for linking with Fortran. */
-#ifndef SC_F77_FUNC
-#define SC_F77_FUNC(name,NAME) name ## _
-#endif
-
-/* As F77_FUNC, but for C identifiers containing underscores. */
-#ifndef SC_F77_FUNC_
-#define SC_F77_FUNC_(name,NAME) name ## _
-#endif
-
-/* Define to 1 if your Fortran compiler doesn't accept -c and -o together. */
-/* #undef F77_NO_MINUS_C_MINUS_O */
-
-/* FC compiler */
-#ifndef SC_FC
-#define SC_FC "gfortran"
-#endif
-
-/* FC compiler flags */
-#ifndef SC_FCFLAGS
-#define SC_FCFLAGS "-g -O2"
-#endif
-
-/* Define to dummy `main' function (if any) required to link to the Fortran
-   libraries. */
-/* #undef FC_DUMMY_MAIN */
-
-/* Define if F77 and FC dummy `main' functions are identical. */
-/* #undef FC_DUMMY_MAIN_EQ_F77 */
-
-/* Define to a macro mangling the given C identifier (in lower and upper
-   case), which must not contain underscores, for linking with Fortran. */
-#ifndef SC_FC_FUNC
-#define SC_FC_FUNC(name,NAME) name ## _
-#endif
-
-/* As FC_FUNC, but for C identifiers containing underscores. */
-#ifndef SC_FC_FUNC_
-#define SC_FC_FUNC_(name,NAME) name ## _
-#endif
-
-/* Define to 1 if your Fortran compiler doesn't accept -c and -o together. */
-/* #undef FC_NO_MINUS_C_MINUS_O */
-
-/* F77 compiler flags */
-#ifndef SC_FFLAGS
-#define SC_FFLAGS "-g -O2"
-#endif
-
-/* Define to 1 if you have the `aligned_alloc' function. */
-#ifndef SC_HAVE_ALIGNED_ALLOC
-#define SC_HAVE_ALIGNED_ALLOC 1
-#endif
-
-/* Define to 1 if you have the `backtrace' function. */
-/* #undef HAVE_BACKTRACE */
-
-/* Define to 1 if you have the `backtrace_symbols' function. */
-/* #undef HAVE_BACKTRACE_SYMBOLS */
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#ifndef SC_HAVE_DLFCN_H
-#define SC_HAVE_DLFCN_H 1
-#endif
-
-/* Define to 1 if you have the <execinfo.h> header file. */
-/* #undef HAVE_EXECINFO_H */
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#ifndef SC_HAVE_INTTYPES_H
-#define SC_HAVE_INTTYPES_H 1
-#endif
-
-/* Have we found function pthread_create. */
-#ifndef SC_HAVE_LPTHREAD
-#define SC_HAVE_LPTHREAD 1
-#endif
-
-/* Have we found function lua_createtable. */
-/* #undef HAVE_LUA */
-
-/* Define to 1 if you have the <lua5.1/lua.h> header file. */
-/* #undef HAVE_LUA5_1_LUA_H */
-
-/* Define to 1 if you have the <lua5.2/lua.h> header file. */
-/* #undef HAVE_LUA5_2_LUA_H */
-
-/* Define to 1 if you have the <lua5.3/lua.h> header file. */
-/* #undef HAVE_LUA5_3_LUA_H */
-
-/* Define to 1 if you have the <lua.h> header file. */
-/* #undef HAVE_LUA_H */
-
-/* Define to 1 if you have the <memory.h> header file. */
-#ifndef SC_HAVE_MEMORY_H
-#define SC_HAVE_MEMORY_H 1
-#endif
-
-/* Have we found function omp_get_thread_num. */
-#ifndef SC_HAVE_OPENMP
-#define SC_HAVE_OPENMP 1
-#endif
-
-/* Define to 1 if you have the `posix_memalign' function. */
-#ifndef SC_HAVE_POSIX_MEMALIGN
-#define SC_HAVE_POSIX_MEMALIGN 1
-#endif
-
-/* Define to 1 if you have the <signal.h> header file. */
-#ifndef SC_HAVE_SIGNAL_H
-#define SC_HAVE_SIGNAL_H 1
-#endif
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#ifndef SC_HAVE_STDINT_H
-#define SC_HAVE_STDINT_H 1
-#endif
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#ifndef SC_HAVE_STDLIB_H
-#define SC_HAVE_STDLIB_H 1
-#endif
-
-/* Define to 1 if you have the <strings.h> header file. */
-#ifndef SC_HAVE_STRINGS_H
-#define SC_HAVE_STRINGS_H 1
-#endif
-
-/* Define to 1 if you have the <string.h> header file. */
-#ifndef SC_HAVE_STRING_H
-#define SC_HAVE_STRING_H 1
-#endif
-
-/* Define to 1 if you have the `strtol' function. */
-#ifndef SC_HAVE_STRTOL
-#define SC_HAVE_STRTOL 1
-#endif
-
-/* Define to 1 if you have the `strtoll' function. */
-#ifndef SC_HAVE_STRTOLL
-#define SC_HAVE_STRTOLL 1
-#endif
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#ifndef SC_HAVE_SYS_STAT_H
-#define SC_HAVE_SYS_STAT_H 1
-#endif
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#ifndef SC_HAVE_SYS_TIME_H
-#define SC_HAVE_SYS_TIME_H 1
-#endif
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#ifndef SC_HAVE_SYS_TYPES_H
-#define SC_HAVE_SYS_TYPES_H 1
-#endif
-
-/* Define to 1 if you have the <time.h> header file. */
-#ifndef SC_HAVE_TIME_H
-#define SC_HAVE_TIME_H 1
-#endif
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#ifndef SC_HAVE_UNISTD_H
-#define SC_HAVE_UNISTD_H 1
-#endif
-
-/* Have we found function adler32_combine. */
-#ifndef SC_HAVE_ZLIB
-#define SC_HAVE_ZLIB 1
-#endif
-
-/* Define to 1 on a bigendian machine */
-/* #undef IS_BIGENDIAN */
-
-/* Linker flags */
-#ifndef SC_LDFLAGS
-#define SC_LDFLAGS ""
-#endif
-
-/* Libraries */
-#ifndef SC_LIBS
-#define SC_LIBS "-lgomp   -lz   "
-#endif
-
-/* minimal log priority */
-/* #undef LOG_PRIORITY */
-
-/* Define to the sub-directory where libtool stores uninstalled libraries. */
-#ifndef SC_LT_OBJDIR
-#define SC_LT_OBJDIR ".libs/"
-#endif
-
-/* DEPRECATED (use SC_ENABLE_MEMALIGN instead) */
-#ifndef SC_MEMALIGN
-#define SC_MEMALIGN 1
-#endif
-
-/* desired alignment of allocations in bytes */
-#ifndef SC_MEMALIGN_BYTES
-#define SC_MEMALIGN_BYTES (SC_SIZEOF_VOID_P)
-#endif
-
-/* DEPRECATED (use SC_ENABLE_MPI instead) */
-/* #undef MPI */
-
-/* DEPRECATED (use SC_ENABLE_MPIIO instead) */
-/* #undef MPIIO */
-
-/* Define to 1 if your C compiler doesn't accept -c and -o together. */
-/* #undef NO_MINUS_C_MINUS_O */
-
-/* DEPRECATED (use SC_ENABLE_OPENMP instead) */
-/* #undef OPENMP */
-
-/* Name of package */
-#ifndef SC_PACKAGE
-#define SC_PACKAGE "libsc"
-#endif
-
-/* Define to the address where bug reports for this package should be sent. */
-#ifndef SC_PACKAGE_BUGREPORT
-#define SC_PACKAGE_BUGREPORT "info@p4est.org"
-#endif
-
-/* Define to the full name of this package. */
-#ifndef SC_PACKAGE_NAME
-#define SC_PACKAGE_NAME "libsc"
-#endif
-
-/* Define to the full name and version of this package. */
-#ifndef SC_PACKAGE_STRING
-#define SC_PACKAGE_STRING "libsc UNKNOWN"
-#endif
-
-/* Define to the one symbol short name of this package. */
-#ifndef SC_PACKAGE_TARNAME
-#define SC_PACKAGE_TARNAME "libsc"
-#endif
-
-/* Define to the home page for this package. */
-#ifndef SC_PACKAGE_URL
-#define SC_PACKAGE_URL ""
-#endif
-
-/* Define to the version of this package. */
-#ifndef SC_PACKAGE_VERSION
-#define SC_PACKAGE_VERSION "UNKNOWN"
-#endif
-
-/* DEPRECATED (use SC_WITH_PAPI instead) */
-/* #undef PAPI */
-
-/* Use builtin getopt */
-/* #undef PROVIDE_GETOPT */
-
-/* Use builtin obstack */
-#ifndef SC_PROVIDE_OBSTACK
-#define SC_PROVIDE_OBSTACK 1
-#endif
-
-/* DEPRECATED (use SC_ENABLE_PTHREAD instead) */
-/* #undef PTHREAD */
-
-/* The size of `int', as computed by sizeof. */
-#ifndef SC_SIZEOF_INT
-#define SC_SIZEOF_INT 4
-#endif
-
-/* The size of `long', as computed by sizeof. */
-#ifndef SC_SIZEOF_LONG
-#define SC_SIZEOF_LONG 8
-#endif
-
-/* The size of `long long', as computed by sizeof. */
-#ifndef SC_SIZEOF_LONG_LONG
-#define SC_SIZEOF_LONG_LONG 8
-#endif
-
-/* The size of `unsigned long', as computed by sizeof. */
-#ifndef SC_SIZEOF_UNSIGNED_LONG
-#define SC_SIZEOF_UNSIGNED_LONG 8
-#endif
-
-/* The size of `unsigned long long', as computed by sizeof. */
-#ifndef SC_SIZEOF_UNSIGNED_LONG_LONG
-#define SC_SIZEOF_UNSIGNED_LONG_LONG 8
-#endif
-
-/* The size of `void *', as computed by sizeof. */
-#ifndef SC_SIZEOF_VOID_P
-#define SC_SIZEOF_VOID_P 8
-#endif
-
-/* Define to 1 if you have the ANSI C header files. */
-#ifndef SC_STDC_HEADERS
-#define SC_STDC_HEADERS 1
-#endif
-
-/* DEPRECATED (use SC_ENABLE_USE_REALLOC instead) */
-#ifndef SC_USE_REALLOC
-#define SC_USE_REALLOC 1
-#endif
-
-/* Version number of package */
-#ifndef SC_VERSION
-#define SC_VERSION "UNKNOWN"
-#endif
-
-/* Package major version */
-#ifndef SC_VERSION_MAJOR
-#define SC_VERSION_MAJOR UNKNOWN
-#endif
-
-/* Package minor version */
-#ifndef SC_VERSION_MINOR
-#define SC_VERSION_MINOR N
-#endif
-
-/* Package point version */
-#ifndef SC_VERSION_POINT
-#define SC_VERSION_POINT 
-#endif
-
-/* Define to 1 if BLAS is used */
-/* #undef WITH_BLAS */
-
-/* Define to 1 if LAPACK is used */
-/* #undef WITH_LAPACK */
-
-/* enable Flop counting with papi */
-/* #undef WITH_PAPI */
-
-/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
-   significant byte first (like Motorola and SPARC, unlike Intel). */
-#if defined AC_APPLE_UNIVERSAL_BUILD
-# if defined __BIG_ENDIAN__
-#  define WORDS_BIGENDIAN 1
-# endif
-#else
-# ifndef WORDS_BIGENDIAN
-/* #  undef WORDS_BIGENDIAN */
-# endif
-#endif
-
-/* Define to empty if `const' does not conform to ANSI C. */
-/* #undef const */
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef __cplusplus
-/* #undef inline */
-#endif
-
-/* Define to the equivalent of the C99 'restrict' keyword, or to
-   nothing if this is not supported.  Do not define if restrict is
-   supported directly.  */
-#ifndef _sc_restrict
-#define _sc_restrict __restrict
-#endif
-/* Work around a bug in Sun C++: it does not support _Restrict or
-   __restrict__, even though the corresponding Sun C compiler ends up with
-   "#define restrict _Restrict" or "#define restrict __restrict__" in the
-   previous line.  Perhaps some future version of Sun C++ will work with
-   restrict; if so, hopefully it defines __RESTRICT like Sun C does.  */
-#if defined __SUNPRO_CC && !defined __RESTRICT
-# define _Restrict
-# define __restrict__
-#endif
-
-/* Define to `unsigned int' if <sys/types.h> does not define. */
-/* #undef size_t */
-
-/* Define to `int' if <sys/types.h> does not define. */
-/* #undef ssize_t */
- 
-/* once: _SRC_SC_CONFIG_H */
-#endif
diff --git a/OctreeRefinement/include/sc_containers.h b/OctreeRefinement/include/sc_containers.h
deleted file mode 100644
index 8e01b79..0000000
--- a/OctreeRefinement/include/sc_containers.h
+++ /dev/null
@@ -1,978 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_CONTAINERS_H
-#define SC_CONTAINERS_H
-
-/** \file sc_containers.h
- *
- * Defines lists, arrays, hash tables, etc.
- *
- * \ingroup containers
- */
-
-/** \defgroup containers containers
- *
- * Defines lists, arrays, hash tables, etc.
- *
- * \ingroup sc
- */
-
-#include <sc_obstack.h>
-
-SC_EXTERN_C_BEGIN;
-
-/* Hash macros from lookup3.c by Bob Jenkins, May 2006, public domain. */
-#define sc_hash_rot(x,k) (((x) << (k)) | ((x) >> (32 - (k))))
-#define sc_hash_mix(a,b,c) ((void)                                      \
-                            (a -= c, a ^= sc_hash_rot(c, 4), c += b,    \
-                             b -= a, b ^= sc_hash_rot(a, 6), a += c,    \
-                             c -= b, c ^= sc_hash_rot(b, 8), b += a,    \
-                             a -= c, a ^= sc_hash_rot(c,16), c += b,    \
-                             b -= a, b ^= sc_hash_rot(a,19), a += c,    \
-                             c -= b, c ^= sc_hash_rot(b, 4), b += a))
-#define sc_hash_final(a,b,c) ((void)                            \
-                              (c ^= b, c -= sc_hash_rot(b,14),  \
-                               a ^= c, a -= sc_hash_rot(c,11),  \
-                               b ^= a, b -= sc_hash_rot(a,25),  \
-                               c ^= b, c -= sc_hash_rot(b,16),  \
-                               a ^= c, a -= sc_hash_rot(c, 4),  \
-                               b ^= a, b -= sc_hash_rot(a,14),  \
-                               c ^= b, c -= sc_hash_rot(b,24)))
-
-/** Function to compute a hash value of an object.
- * \param [in] v   The object to hash.
- * \param [in] u   Arbitrary user data.
- * \return Returns an unsigned integer.
- */
-typedef unsigned    (*sc_hash_function_t) (const void *v, const void *u);
-
-/** Function to check equality of two objects.
- * \param [in] u   Arbitrary user data.
- * \return Returns false if *v1 is unequal *v2 and true otherwise.
- */
-typedef int         (*sc_equal_function_t) (const void *v1,
-                                            const void *v2, const void *u);
-
-/** Function to call on every data item of a hash table.
- * \param [in] v   The address of the pointer to the current object.
- * \param [in] u   Arbitrary user data.
- * \return Return true if the traversal should continue, false to stop.
- */
-typedef int         (*sc_hash_foreach_t) (void **v, const void *u);
-
-/** The sc_array object provides a dynamic array of equal-size elements.
- * Elements are accessed by their 0-based index.  Their address may change.
- * The number of elements (== elem_count) of the array can be changed by 
- * \ref sc_array_resize and \ref sc_array_rewind.
- * Elements can be sorted with \ref sc_array_sort.
- * If the array is sorted, it can be searched with \ref sc_array_bsearch.
- * A priority queue is implemented with pqueue_add and pqueue_pop (untested).
- */
-typedef struct sc_array
-{
-  /* interface variables */
-  size_t              elem_size;        /**< size of a single element */
-  size_t              elem_count;       /**< number of valid elements */
-
-  /* implementation variables */
-  ssize_t             byte_alloc;       /**< number of allocated bytes
-                                           or -(number of viewed bytes + 1)
-                                           if this is a view: the "+ 1"
-                                           distinguishes an array of size 0
-                                           from a view of size 0 */
-  char               *array;    /**< linear array to store elements */
-}
-sc_array_t;
-
-/** test whether the sc_array_t owns its \a array */
-#define SC_ARRAY_IS_OWNER(a) ((a)->byte_alloc >= 0)
-/** the allocated size of the array */
-#define SC_ARRAY_BYTE_ALLOC(a) ((size_t) \
-         (SC_ARRAY_IS_OWNER (a) ? (a)->byte_alloc : -((a)->byte_alloc + 1)))
-
-/** Calculate the memory used by an array.
- * \param [in] array       The array.
- * \param [in] is_dynamic  True if created with sc_array_new,
- *                         false if initialized with sc_array_init
- * \return                 Memory used in bytes.
- */
-size_t              sc_array_memory_used (sc_array_t * array, int is_dynamic);
-
-/** Creates a new array structure with 0 elements.
- * \param [in] elem_size    Size of one array element in bytes.
- * \return                  Return an allocated array of zero length.
- */
-sc_array_t         *sc_array_new (size_t elem_size);
-
-/** Creates a new array structure with a given length (number of elements).
- * \param [in] elem_size    Size of one array element in bytes.
- * \param [in] elem_count   Initial number of array elements.
- * \return                  Return an allocated array
- *                          with allocated but uninitialized elements.
- */
-sc_array_t         *sc_array_new_count (size_t elem_size, size_t elem_count);
-
-/** Deprecated: use \ref sc_array_new_count. */
-#define sc_array_new_size(s,c) (sc_array_new_count ((s), (c)))
-
-/** Creates a new view of an existing sc_array_t.
- * \param [in] array    The array must not be resized while view is alive.
- * \param [in] offset   The offset of the viewed section in element units.
- *                      This offset cannot be changed until the view is reset.
- * \param [in] length   The length of the viewed section in element units.
- *                      The view cannot be resized to exceed this length.
- */
-sc_array_t         *sc_array_new_view (sc_array_t * array,
-                                       size_t offset, size_t length);
-
-/** Creates a new view of an existing plain C array.
- * \param [in] base         The data must not be moved while view is alive.
- * \param [in] elem_size    Size of one array element in bytes.
- * \param [in] elem_count   The length of the view in element units.
- *                          The view cannot be resized to exceed this length.
- */
-sc_array_t         *sc_array_new_data (void *base,
-                                       size_t elem_size, size_t elem_count);
-
-/** Destroys an array structure.
- * \param [in] array    The array to be destroyed.
- */
-void                sc_array_destroy (sc_array_t * array);
-
-/** Initializes an already allocated (or static) array structure.
- * \param [in,out]  array       Array structure to be initialized.
- * \param [in] elem_size        Size of one array element in bytes.
- */
-void                sc_array_init (sc_array_t * array, size_t elem_size);
-
-/** Initializes an already allocated (or static) array structure
- * and allocates a given number of elements.
- * \param [in,out]  array       Array structure to be initialized.
- * \param [in] elem_size        Size of one array element in bytes.
- * \param [in] elem_count       Number of initial array elements.
- */
-void                sc_array_init_size (sc_array_t * array,
-                                        size_t elem_size, size_t elem_count);
-
-/** Initializes an already allocated (or static) view from existing sc_array_t.
- * The array view returned does not require sc_array_reset (doesn't hurt though).
- * \param [in,out] view  Array structure to be initialized.
- * \param [in] array     The array must not be resized while view is alive.
- * \param [in] offset    The offset of the viewed section in element units.
- *                       This offset cannot be changed until the view is reset.
- * \param [in] length    The length of the view in element units.
- *                       The view cannot be resized to exceed this length.
- *                       It is not necessary to call sc_array_reset later.
- */
-void                sc_array_init_view (sc_array_t * view, sc_array_t * array,
-                                        size_t offset, size_t length);
-
-/** Initializes an already allocated (or static) view from given plain C data.
- * The array view returned does not require sc_array_reset (doesn't hurt though).
- * \param [in,out] view     Array structure to be initialized.
- * \param [in] base         The data must not be moved while view is alive.
- * \param [in] elem_size    Size of one array element in bytes.
- * \param [in] elem_count   The length of the view in element units.
- *                          The view cannot be resized to exceed this length.
- *                          It is not necessary to call sc_array_reset later.
- */
-void                sc_array_init_data (sc_array_t * view, void *base,
-                                        size_t elem_size, size_t elem_count);
-
-/** Sets the array count to zero and frees all elements.
- * This function turns a view into a newly initialized array.
- * \param [in,out]  array       Array structure to be reset.
- * \note Calling sc_array_init, then any array operations,
- *       then sc_array_reset is memory neutral.
- *       As an exception, the two functions sc_array_init_view and
- *       sc_array_init_data do not require a subsequent call to sc_array_reset.
- *       Regardless, it is legal to call sc_array_reset anyway.
- */
-void                sc_array_reset (sc_array_t * array);
-
-/** Sets the array count to zero, but does not free elements.
- * Not allowed for views.
- * \param [in,out]  array       Array structure to be truncated.
- * \note This is intended to allow an sc_array to be used as a reusable
- * buffer, where the "high water mark" of the buffer is preserved, so that
- * O(log (max n)) reallocs occur over the life of the buffer.
- */
-void                sc_array_truncate (sc_array_t * array);
-
-/** Shorten an array without reallocating it.
- * \param [in,out] array    The element count of this array is modified.
- * \param [in] new_count    Must be less or equal than the \b array's count.
- *                          If it is less, the number of elements in the
- *                          array is reduced without reallocating memory.
- *                          The exception is a \b new_count of zero
- *                          specified for an array that is not a view:
- *                          In this case \ref sc_array_reset is equivalent.
- */
-void                sc_array_rewind (sc_array_t * array, size_t new_count);
-
-/** Sets the element count to new_count.
- * If the array is not a view, reallocation takes place occasionally.
- * If the array is a view, new_count must not be greater than the element
- * count of the view when it was created.  The original offset of the view
- * cannot be changed.
- * \param [in,out] array    The element count and address is modified.
- * \param [in] new_count    New element count of the array.
- *                          If it is zero and the array is not a view,
- *                          the effect equals \ref sc_array_reset.
- */
-void                sc_array_resize (sc_array_t * array, size_t new_count);
-
-/** Copy the contents of an array into another.
- * Both arrays must have equal element sizes.
- * \param [in] dest Array (not a view) will be resized and get new data.
- * \param [in] src  Array used as source of new data, will not be changed.
- */
-void                sc_array_copy (sc_array_t * dest, sc_array_t * src);
-
-/** Sorts the array in ascending order wrt. the comparison function.
- * \param [in] array    The array to sort.
- * \param [in] compar   The comparison function to be used.
- */
-void                sc_array_sort (sc_array_t * array,
-                                   int (*compar) (const void *,
-                                                  const void *));
-
-/** Check whether the array is sorted wrt. the comparison function.
- * \param [in] array    The array to check.
- * \param [in] compar   The comparison function to be used.
- * \return              True if array is sorted, false otherwise.
- */
-int                 sc_array_is_sorted (sc_array_t * array,
-                                        int (*compar) (const void *,
-                                                       const void *));
-
-/** Check whether two arrays have equal size, count, and content.
- * Either array may be a view.  Both arrays will not be changed.
- * \param [in] array   One array to be compared.
- * \param [in] other   A second array to be compared.
- * \return              True if array and other are equal, false otherwise.
- */
-int                 sc_array_is_equal (sc_array_t * array,
-                                       sc_array_t * other);
-
-/** Removed duplicate entries from a sorted array.
- * This function is not allowed for views.
- * \param [in,out] array  The array size will be reduced as necessary.
- * \param [in] compar     The comparison function to be used.
- */
-void                sc_array_uniq (sc_array_t * array,
-                                   int (*compar) (const void *,
-                                                  const void *));
-
-/** Performs a binary search on an array. The array must be sorted.
- * \param [in] array   A sorted array to search in.
- * \param [in] key     An element to be searched for.
- * \param [in] compar  The comparison function to be used.
- * \return Returns the index into array for the item found, or -1.
- */
-ssize_t             sc_array_bsearch (sc_array_t * array,
-                                      const void *key,
-                                      int (*compar) (const void *,
-                                                     const void *));
-
-/** Function to determine the enumerable type of an object in an array.
- * \param [in] array   Array containing the object.
- * \param [in] index   The location of the object.
- * \param [in] data    Arbitrary user data.
- */
-typedef             size_t (*sc_array_type_t) (sc_array_t * array,
-                                               size_t index, void *data);
-
-/** Compute the offsets of groups of enumerable types in an array.
- * \param [in] array         Array that is sorted in ascending order by type.
- *                           If k indexes \a array, then
- *                           0 <= \a type_fn (\a array, k, \a data) <
- *                           \a num_types.
- * \param [in,out] offsets   An initialized array of type size_t that is
- *                           resized to \a num_types + 1 entries.  The indices
- *                           j of \a array that contain objects of type k are
- *                           \a offsets[k] <= j < \a offsets[k + 1].
- *                           If there are no objects of type k, then
- *                           \a offsets[k] = \a offset[k + 1].
- * \param [in] num_types     The number of possible types of objects in
- *                           \a array.
- * \param [in] type_fn       Returns the type of an object in the array.
- * \param [in] data          Arbitrary user data passed to \a type_fn.
- */
-void                sc_array_split (sc_array_t * array, sc_array_t * offsets,
-                                    size_t num_types, sc_array_type_t type_fn,
-                                    void *data);
-
-/** Determine whether \a array is an array of size_t's whose entries include
- * every integer 0 <= i < array->elem_count.
- * \param [in] array         An array.
- * \return                   Returns 1 if array contains size_t elements whose
- *                           entries include every integer
- *                           0 <= i < \a array->elem_count, 0 otherwise.
- */
-int                 sc_array_is_permutation (sc_array_t * array);
-
-/** Given permutation \a newindices, permute \a array in place.  The data that
- * on input is contained in \a array[i] will be contained in \a
- * array[newindices[i]] on output.  The entries of newindices will be altered
- * unless \a keepperm is true.
- * \param [in,out] array      An array.
- * \param [in,out] newindices Permutation array (see sc_array_is_permutation).
- * \param [in]     keepperm   If true, \a newindices will be unchanged by the
- *                            algorithm; if false, \a newindices will be the
- *                            identity permutation on output, but the
- *                            algorithm will only use O(1) space.
- */
-void                sc_array_permute (sc_array_t * array,
-                                      sc_array_t * newindices, int keepperm);
-
-/** Computes the adler32 checksum of array data (see zlib documentation).
- * This is a faster checksum than crc32, and it works with zeros as data.
- */
-unsigned            sc_array_checksum (sc_array_t * array);
-
-/** Adds an element to a priority queue.
- * PQUEUE FUNCTIONS ARE UNTESTED AND CURRENTLY DISABLED.
- * This function is not allowed for views.
- * The priority queue is implemented as a heap in ascending order.
- * A heap is a binary tree where the children are not less than their parent.
- * Assumes that elements [0]..[elem_count-2] form a valid heap.
- * Then propagates [elem_count-1] upward by swapping if necessary.
- * \param [in] temp    Pointer to unused allocated memory of elem_size.
- * \param [in] compar  The comparison function to be used.
- * \return Returns the number of swap operations.
- * \note  If the return value is zero for all elements in an array,
- *        the array is sorted linearly and unchanged.
- */
-size_t              sc_array_pqueue_add (sc_array_t * array,
-                                         void *temp,
-                                         int (*compar) (const void *,
-                                                        const void *));
-
-/** Pops the smallest element from a priority queue.
- * PQUEUE FUNCTIONS ARE UNTESTED AND CURRENTLY DISABLED.
- * This function is not allowed for views.
- * This function assumes that the array forms a valid heap in ascending order.
- * \param [out] result  Pointer to unused allocated memory of elem_size.
- * \param [in]  compar  The comparison function to be used.
- * \return Returns the number of swap operations.
- * \note This function resizes the array to elem_count-1.
- */
-size_t              sc_array_pqueue_pop (sc_array_t * array,
-                                         void *result,
-                                         int (*compar) (const void *,
-                                                        const void *));
-
-/** Returns a pointer to an array element.
- * \param [in] index needs to be in [0]..[elem_count-1].
- */
-/*@unused@*/
-static inline void *
-sc_array_index (sc_array_t * array, size_t iz)
-{
-  SC_ASSERT (iz < array->elem_count);
-
-  return (void *) (array->array + (array->elem_size * iz));
-}
-
-/** Returns a pointer to an array element indexed by a plain int.
- * \param [in] index needs to be in [0]..[elem_count-1].
- */
-/*@unused@*/
-static inline void *
-sc_array_index_int (sc_array_t * array, int i)
-{
-  SC_ASSERT (i >= 0 && (size_t) i < array->elem_count);
-
-  return (void *) (array->array + (array->elem_size * (size_t) i));
-}
-
-/** Returns a pointer to an array element indexed by a plain long.
- * \param [in] index needs to be in [0]..[elem_count-1].
- */
-/*@unused@*/
-static inline void *
-sc_array_index_long (sc_array_t * array, long l)
-{
-  SC_ASSERT (l >= 0 && (size_t) l < array->elem_count);
-
-  return (void *) (array->array + (array->elem_size * (size_t) l));
-}
-
-/** Returns a pointer to an array element indexed by a ssize_t.
- * \param [in] index needs to be in [0]..[elem_count-1].
- */
-/*@unused@*/
-static inline void *
-sc_array_index_ssize_t (sc_array_t * array, ssize_t is)
-{
-  SC_ASSERT (is >= 0 && (size_t) is < array->elem_count);
-
-  return (void *) (array->array + (array->elem_size * (size_t) is));
-}
-
-/** Returns a pointer to an array element indexed by a int16_t.
- * \param [in] index needs to be in [0]..[elem_count-1].
- */
-/*@unused@*/
-static inline void *
-sc_array_index_int16 (sc_array_t * array, int16_t i16)
-{
-  SC_ASSERT (i16 >= 0 && (size_t) i16 < array->elem_count);
-
-  return (void *) (array->array + (array->elem_size * (size_t) i16));
-}
-
-/** Return the index of an object in an array identified by a pointer.
- * \param [in] element needs to be the address of an element in array.
- */
-/*@unused@*/
-static inline       size_t
-sc_array_position (sc_array_t * array, void *element)
-{
-  ptrdiff_t           position;
-
-  SC_ASSERT (array->array <= (char *) element);
-  SC_ASSERT (((char *) element - array->array) %
-             (ptrdiff_t) array->elem_size == 0);
-
-  position = ((char *) element - array->array) / (ptrdiff_t) array->elem_size;
-  SC_ASSERT (0 <= position && position < (ptrdiff_t) array->elem_count);
-
-  return (size_t) position;
-}
-
-/** Remove the last element from an array and return a pointer to it.
- * This function is not allowed for views.
- * \return                The pointer to the removed object.  Will be valid
- *                        as long as no other function is called on this array.
- */
-/*@unused@*/
-static inline void *
-sc_array_pop (sc_array_t * array)
-{
-  SC_ASSERT (SC_ARRAY_IS_OWNER (array));
-  SC_ASSERT (array->elem_count > 0);
-
-  return (void *) (array->array + (array->elem_size * --array->elem_count));
-}
-
-/** Enlarge an array by a number of elements.  Grows the array if necessary.
- * This function is not allowed for views.
- * \return Returns a pointer to the uninitialized newly added elements.
- */
-/*@unused@*/
-static inline void *
-sc_array_push_count (sc_array_t * array, size_t add_count)
-{
-  const size_t        old_count = array->elem_count;
-  const size_t        new_count = old_count + add_count;
-
-  SC_ASSERT (SC_ARRAY_IS_OWNER (array));
-
-  if (array->elem_size * new_count > (size_t) array->byte_alloc) {
-    sc_array_resize (array, new_count);
-  }
-  else {
-    array->elem_count = new_count;
-  }
-
-  return (void *) (array->array + array->elem_size * old_count);
-}
-
-/** Enlarge an array by one element.  Grows the array if necessary.
- * This function is not allowed for views.
- * \return Returns a pointer to the uninitialized newly added element.
- */
-/*@unused@*/
-static inline void *
-sc_array_push (sc_array_t * array)
-{
-  return sc_array_push_count (array, 1);
-}
-
-/** The sc_mempool object provides a large pool of equal-size elements.
- * The pool grows dynamically for element allocation.
- * Elements are referenced by their address which never changes.
- * Elements can be freed (that is, returned to the pool)
- *    and are transparently reused.
- * If the zero_and_persist option is selected, new elements are initialized to
- * all zeros on creation, and the contents of an element are not touched
- * between freeing and re-returning it.
- */
-typedef struct sc_mempool
-{
-  /* interface variables */
-  size_t              elem_size;        /**< size of a single element */
-  size_t              elem_count;       /**< number of valid elements */
-  int                 zero_and_persist; /**< Boolean; is set in constructor. */
-
-  /* implementation variables */
-  struct obstack      obstack;  /**< holds the allocated elements */
-  sc_array_t          freed;    /**< buffers the freed elements */
-}
-sc_mempool_t;
-
-/** Calculate the memory used by a memory pool.
- * \param [in] array       The memory pool.
- * \return                 Memory used in bytes.
- */
-size_t              sc_mempool_memory_used (sc_mempool_t * mempool);
-
-/** Creates a new mempool structure with the zero_and_persist option off.
- * The contents of any elements returned by sc_mempool_alloc are undefined.
- * \param [in] elem_size  Size of one element in bytes.
- * \return Returns an allocated and initialized memory pool.
- */
-sc_mempool_t       *sc_mempool_new (size_t elem_size);
-
-/** Creates a new mempool structure with the zero_and_persist option on.
- * The memory of newly created elements is zero'd out, and the contents of an
- * element are not touched between freeing and re-returning it.
- * \param [in] elem_size  Size of one element in bytes.
- * \return Returns an allocated and initialized memory pool.
- */
-sc_mempool_t       *sc_mempool_new_zero_and_persist (size_t elem_size);
-
-/** Same as sc_mempool_new, but for an already allocated sc_mempool_t pointer. */
-void                sc_mempool_init (sc_mempool_t * mempool,
-                                     size_t elem_size);
-
-/** Destroys a mempool structure.
- * All elements that are still in use are invalidated.
- */
-void                sc_mempool_destroy (sc_mempool_t * mempool);
-
-/** Same as sc_mempool_destroy, but does not free the pointer */
-void                sc_mempool_reset (sc_mempool_t * mempool);
-
-/** Invalidates all previously returned pointers, resets count to 0.
- */
-void                sc_mempool_truncate (sc_mempool_t * mempool);
-
-/** Allocate a single element.
- * Elements previously returned to the pool are recycled.
- * \return Returns a new or recycled element pointer.
- */
-/*@unused@*/
-static inline void *
-sc_mempool_alloc (sc_mempool_t * mempool)
-{
-  void               *ret;
-  sc_array_t         *freed = &mempool->freed;
-
-  ++mempool->elem_count;
-
-  if (freed->elem_count > 0) {
-    ret = *(void **) sc_array_pop (freed);
-  }
-  else {
-    ret = obstack_alloc (&mempool->obstack, (int) mempool->elem_size);
-    if (mempool->zero_and_persist) {
-      memset (ret, 0, mempool->elem_size);
-    }
-  }
-
-#ifdef SC_ENABLE_DEBUG
-  if (!mempool->zero_and_persist) {
-    memset (ret, -1, mempool->elem_size);
-  }
-#endif
-
-  return ret;
-}
-
-/** Return a previously allocated element to the pool.
- * \param [in] elem  The element to be returned to the pool.
- */
-/*@unused@*/
-static inline void
-sc_mempool_free (sc_mempool_t * mempool, void *elem)
-{
-  sc_array_t         *freed = &mempool->freed;
-
-  SC_ASSERT (mempool->elem_count > 0);
-
-#ifdef SC_ENABLE_DEBUG
-  if (!mempool->zero_and_persist) {
-    memset (elem, -1, mempool->elem_size);
-  }
-#endif
-
-  --mempool->elem_count;
-
-  *(void **) sc_array_push (freed) = elem;
-}
-
-/** The sc_link structure is one link of a linked list.
- */
-typedef struct sc_link
-{
-  void               *data;
-  struct sc_link     *next;
-}
-sc_link_t;
-
-/** The sc_list object provides a linked list.
- */
-typedef struct sc_list
-{
-  /* interface variables */
-  size_t              elem_count;
-  sc_link_t          *first;
-  sc_link_t          *last;
-
-  /* implementation variables */
-  int                 allocator_owned;
-  sc_mempool_t       *allocator;        /* must allocate sc_link_t */
-}
-sc_list_t;
-
-/** Calculate the total memory used by a list.
- * \param [in] list        The list.
- * \param [in] is_dynamic  True if created with sc_list_new,
- *                         false if initialized with sc_list_init
- * \return                 Memory used in bytes.
- */
-size_t              sc_list_memory_used (sc_list_t * list, int is_dynamic);
-
-/** Allocate a new, empty linked list.
- * \param [in] allocator    Memory allocator for sc_link_t, can be NULL
- *                          in which case an internal allocator is created.
- * \return                  Pointer to a newly allocated, empty list object.
- */
-sc_list_t          *sc_list_new (sc_mempool_t * allocator);
-
-/** Destroy a linked list structure in O(N).
- * \param [in,out] list     All memory allocated for this list is freed.
- * \note If allocator was provided in sc_list_new, it will not be destroyed.
- */
-void                sc_list_destroy (sc_list_t * list);
-
-/** Initialize a list object with an external link allocator.
- * \param [in,out]  list       List structure to be initialized.
- * \param [in]      allocator  External memory allocator for sc_link_t,
- *                             which must exist already.
- */
-void                sc_list_init (sc_list_t * list, sc_mempool_t * allocator);
-
-/** Remove all elements from a list in O(N).
- * \param [in,out]  list       List structure to be emptied.
- * \note Calling sc_list_init, then any list operations,
- *       then sc_list_reset is memory neutral.
- */
-void                sc_list_reset (sc_list_t * list);
-
-/** Unlink all list elements without returning them to the mempool.
- * This runs in O(1) but is dangerous because the link memory stays alive.
- * \param [in,out]  list       List structure to be unlinked.
- */
-void                sc_list_unlink (sc_list_t * list);
-
-/** Insert a list element at the beginning of the list.
- * \param [in,out] list     Valid list object.
- * \param [in] data         A new link is created holding this data.
- * \return                  The link that has been created for data.
- */
-sc_link_t          *sc_list_prepend (sc_list_t * list, void *data);
-
-/** Insert a list element at the end of the list.
- * \param [in,out] list     Valid list object.
- * \param [in] data         A new link is created holding this data.
- * \return                  The link that has been created for data.
- */
-sc_link_t          *sc_list_append (sc_list_t * list, void *data);
-
-/** Insert an element after a given list position.
- * \param [in,out] list     Valid list object.
- * \param [in,out] pred     The predecessor of the element to be inserted.
- * \param [in] data         A new link is created holding this data.
- * \return                  The link that has been created for data.
- */
-sc_link_t          *sc_list_insert (sc_list_t * list,
-                                    sc_link_t * pred, void *data);
-
-/** Remove an element after a given list position.
- * \param [in,out] list     Valid, non-empty list object.
- * \param [in] pred  The predecessor of the element to be removed.
- *                   If \a pred == NULL, the first element is removed,
- *                   which is equivalent to calling sc_list_pop (list).
- * \return           The data of the removed and freed link.
- */
-void               *sc_list_remove (sc_list_t * list, sc_link_t * pred);
-
-/** Remove an element from the front of the list.
- * \param [in,out] list     Valid, non-empty list object.
- * \return Returns the data of the removed first list element.
- */
-void               *sc_list_pop (sc_list_t * list);
-
-/** The sc_hash implements a hash table.
- * It uses an array which has linked lists as elements.
- */
-typedef struct sc_hash
-{
-  /* interface variables */
-  size_t              elem_count;       /**< total number of objects contained */
-
-  /* implementation variables */
-  sc_array_t         *slots;    /**< the slot count is slots->elem_count */
-  void               *user_data;        /**< user data passed to hash function */
-  sc_hash_function_t  hash_fn;
-  sc_equal_function_t equal_fn;
-  size_t              resize_checks, resize_actions;
-  int                 allocator_owned;
-  sc_mempool_t       *allocator;        /**< must allocate sc_link_t */
-}
-sc_hash_t;
-
-/** Compute a hash value from a null-terminated string.
- * This hash function is NOT cryptographically safe! Use libcrypt then.
- * \param [in] s        Null-terminated string to be hashed.
- * \param [in] u        Not used.
- * \return              The computed hash value as an unsigned integer.
- */
-unsigned            sc_hash_function_string (const void *s, const void *u);
-
-/** Calculate the memory used by a hash table.
- * \param [in] hash        The hash table.
- * \return                 Memory used in bytes.
- */
-size_t              sc_hash_memory_used (sc_hash_t * hash);
-
-/** Create a new hash table.
- * The number of hash slots is chosen dynamically.
- * \param [in] hash_fn     Function to compute the hash value.
- * \param [in] equal_fn    Function to test two objects for equality.
- * \param [in] user_data   User data passed through to the hash function.
- * \param [in] allocator   Memory allocator for sc_link_t, can be NULL.
- */
-sc_hash_t          *sc_hash_new (sc_hash_function_t hash_fn,
-                                 sc_equal_function_t equal_fn,
-                                 void *user_data, sc_mempool_t * allocator);
-
-/** Destroy a hash table.
- *
- * If the allocator is owned, this runs in O(1), otherwise in O(N).
- * \note If allocator was provided in sc_hash_new, it will not be destroyed.
- */
-void                sc_hash_destroy (sc_hash_t * hash);
-
-/** Remove all entries from a hash table in O(N).
- *
- * If the allocator is owned, it calls sc_hash_unlink and sc_mempool_truncate.
- * Otherwise, it calls sc_list_reset on every hash slot which is slower.
- */
-void                sc_hash_truncate (sc_hash_t * hash);
-
-/** Unlink all hash elements without returning them to the mempool.
- *
- * If the allocator is not owned, this runs faster than sc_hash_truncate,
- *    but is dangerous because of potential memory leaks.
- * \param [in,out]  hash       Hash structure to be unlinked.
- */
-void                sc_hash_unlink (sc_hash_t * hash);
-
-/** Same effect as unlink and destroy, but in O(1).
- * This is dangerous because of potential memory leaks.
- * \param [in]  hash       Hash structure to be unlinked and destroyed.
- */
-void                sc_hash_unlink_destroy (sc_hash_t * hash);
-
-/** Check if an object is contained in the hash table.
- * \param [in]  v      The object to be looked up.
- * \param [out] found  If found != NULL, *found is set to the address of the
- *                     pointer to the already contained object if the object
- *                     is found.  You can assign to **found to override.
- * \return Returns true if object is found, false otherwise.
- */
-int                 sc_hash_lookup (sc_hash_t * hash, void *v, void ***found);
-
-/** Insert an object into a hash table if it is not contained already.
- * \param [in]  v      The object to be inserted.
- * \param [out] found  If found != NULL, *found is set to the address of the
- *                     pointer to the already contained, or if not present,
- *                     the new object.  You can assign to **found to override.
- * \return Returns true if object is added, false if it is already contained.
- */
-int                 sc_hash_insert_unique (sc_hash_t * hash, void *v,
-                                           void ***found);
-
-/** Remove an object from a hash table.
- * \param [in]  v      The object to be removed.
- * \param [out] found  If found != NULL, *found is set to the object
-                       that is removed if that exists.
- * \return Returns true if object is found, false if is not contained.
- */
-int                 sc_hash_remove (sc_hash_t * hash, void *v, void **found);
-
-/** Invoke a callback for every member of the hash table.
- * The functions hash_fn and equal_fn are not called by this function.
- */
-void                sc_hash_foreach (sc_hash_t * hash, sc_hash_foreach_t fn);
-
-/** Compute and print statistical information about the occupancy.
- */
-void                sc_hash_print_statistics (int package_id,
-                                              int log_priority,
-                                              sc_hash_t * hash);
-
-typedef struct sc_hash_array_data
-{
-  sc_array_t         *pa;
-  sc_hash_function_t  hash_fn;
-  sc_equal_function_t equal_fn;
-  void               *user_data;
-  void               *current_item;
-}
-sc_hash_array_data_t;
-
-/** The sc_hash_array implements an array backed up by a hash table.
- * This enables O(1) access for array elements.
- */
-typedef struct sc_hash_array
-{
-  /* implementation variables */
-  sc_array_t          a;
-  sc_hash_array_data_t internal_data;
-  sc_hash_t          *h;
-}
-sc_hash_array_t;
-
-/** Calculate the memory used by a hash array.
- * \param [in] ha          The hash array.
- * \return                 Memory used in bytes.
- */
-size_t              sc_hash_array_memory_used (sc_hash_array_t * ha);
-
-/** Create a new hash array.
- * \param [in] elem_size   Size of one array element in bytes.
- * \param [in] hash_fn     Function to compute the hash value.
- * \param [in] equal_fn    Function to test two objects for equality.
- */
-sc_hash_array_t    *sc_hash_array_new (size_t elem_size,
-                                       sc_hash_function_t hash_fn,
-                                       sc_equal_function_t equal_fn,
-                                       void *user_data);
-
-/** Destroy a hash array.
- */
-void                sc_hash_array_destroy (sc_hash_array_t * hash_array);
-
-/** Check the internal consistency of a hash array.
- */
-int                 sc_hash_array_is_valid (sc_hash_array_t * hash_array);
-
-/** Remove all elements from the hash array.
- * \param [in,out] hash_array   Hash array to truncate.
- */
-void                sc_hash_array_truncate (sc_hash_array_t * hash_array);
-
-/** Check if an object is contained in a hash array.
- *
- * \param [in]  v          A pointer to the object.
- * \param [out] position   If position != NULL, *position is set to the
- *                         array position of the already contained object
- *                         if found.
- * \return                 Returns true if object is found, false otherwise.
- */
-int                 sc_hash_array_lookup (sc_hash_array_t * hash_array,
-                                          void *v, size_t * position);
-
-/** Insert an object into a hash array if it is not contained already.
- * The object is not copied into the array.  Use the return value for that.
- * New objects are guaranteed to be added at the end of the array.
- *
- * \param [in]  v          A pointer to the object.  Used for search only.
- * \param [out] position   If position != NULL, *position is set to the
- *                         array position of the already contained, or if
- *                         not present, the new object.
- * \return                 Returns NULL if the object is already contained.
- *                         Otherwise returns its new address in the array.
- */
-void               *sc_hash_array_insert_unique (sc_hash_array_t * hash_array,
-                                                 void *v, size_t * position);
-
-/** Extract the array data from a hash array and destroy everything else.
- * \param [in] hash_array   The hash array is destroyed after extraction.
- * \param [in] rip          Array structure that will be overwritten.
- *                          All previous array data (if any) will be leaked.
- *                          The filled array can be freed with sc_array_reset.
- */
-void                sc_hash_array_rip (sc_hash_array_t * hash_array,
-                                       sc_array_t * rip);
-
-/** The sc_recycle_array object provides an array of slots that can be reused.
- *
- * It keeps a list of free slots in the array which will be used for insertion
- * while available.  Otherwise, the array is grown.
- */
-typedef struct sc_recycle_array
-{
-  /* interface variables */
-  size_t              elem_count;       /* number of valid entries */
-
-  /* implementation variables */
-  sc_array_t          a;
-  sc_array_t          f;
-}
-sc_recycle_array_t;
-
-/** Initialize a recycle array.
- *
- * \param [in] elem_size   Size of the objects to be stored in the array.
- */
-void                sc_recycle_array_init (sc_recycle_array_t * rec_array,
-                                           size_t elem_size);
-
-/** Reset a recycle array.
- *
- * As with all _reset functions, calling _init, then any array operations,
- * then _reset is memory neutral.
- */
-void                sc_recycle_array_reset (sc_recycle_array_t * rec_array);
-
-/** Insert an object into the recycle array.
- * The object is not copied into the array.  Use the return value for that.
- *
- * \param [out] position   If position != NULL, *position is set to the
- *                         array position of the inserted object.
- * \return                 Returns the new address of the object in the array.
- */
-void               *sc_recycle_array_insert (sc_recycle_array_t * rec_array,
-                                             size_t * position);
-
-/** Remove an object from the recycle array.  It must be valid.
- *
- * \param [in] position   Index into the array for the object to remove.
- * \return                The pointer to the removed object.  Will be valid
- *                        as long as no other function is called
- *                        on this recycle array.
- */
-void               *sc_recycle_array_remove (sc_recycle_array_t * rec_array,
-                                             size_t position);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_CONTAINERS_H */
diff --git a/OctreeRefinement/include/sc_dmatrix.h b/OctreeRefinement/include/sc_dmatrix.h
deleted file mode 100644
index 7d24c65..0000000
--- a/OctreeRefinement/include/sc_dmatrix.h
+++ /dev/null
@@ -1,478 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_DMATRIX_H
-#define SC_DMATRIX_H
-
-/** \file sc_dmatrix.h
- * Routines to create and manipulate small dense matrices of double.
- * We use BLAS and LAPACK for more advanced linear algebra computations.
- */
-
-#include <sc_blas.h>
-#include <sc_containers.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** This is the matrix object.  It can have its own storage or be a view. */
-typedef struct sc_dmatrix
-{
-  double            **e;        /**< Array into the rows of the matrix. */
-  sc_bint_t           m;        /**< Number of rows in this matrix. */
-  sc_bint_t           n;        /**< Number of columns in this matrix. */
-  int                 view;     /**< Boolean to indicate this is a view. */
-}
-sc_dmatrix_t;
-
-/** Check whether a double array is free of NaN entries.
- * \param [in] darray   Array of doubles.
- * \param [in] nelem    Number of doubles in the array.
- * \return              Return false if at least one entry is NaN.
- */
-int                 sc_darray_is_valid (const double *darray, size_t nelem);
-
-/** Check whether the values in a double array are in a certain range.
- * \param [in] darray   Array of doubles.
- * \param [in] nelem    Number of doubles in the array.
- * \param [in] low      Lowest allowed value in the array.
- * \param [in] high     Highest allowed value in the array.
- * \return              Return false if at least one entry is out of range.
- */
-int                 sc_darray_is_range (const double *darray, size_t nelem,
-                                        double low, double high);
-
-/** Calculate the memory used by a dmatrix.
- * \param [in] dmatrix     The dmatrix.
- * \return                 Memory used in bytes.
- */
-size_t              sc_dmatrix_memory_used (sc_dmatrix_t * dmatrix);
-
-/** Create a new uninitalized matrix object.
- * This function aborts on memory allocation errors.
- * \param [in] m            Number of rows.
- * \param [in] n            Number of columns.
- * \return                  A valid dmatrix object with uninitialized entries.
- */
-sc_dmatrix_t       *sc_dmatrix_new (sc_bint_t m, sc_bint_t n);
-
-/** Create a new matrix object with all entries set to zero.
- * This function aborts on memory allocation errors.
- * \param [in] m            Number of rows.
- * \param [in] n            Number of columns.
- * \return                  A valid dmatrix object storing all zeros.
- */
-sc_dmatrix_t       *sc_dmatrix_new_zero (sc_bint_t m, sc_bint_t n);
-
-/** Create a new matrix object with the same size and entries as another.
- * This function aborts on memory allocation errors.
- * \param [in] dmatrix      A valid dmatrix or view.
- * \return                  A valid dmatrix with size and entries of \b view.
- */
-sc_dmatrix_t       *sc_dmatrix_clone (const sc_dmatrix_t * dmatrix);
-
-/** Create a matrix view on an existing data array.
- * The data array must have been previously allocated and large enough.
- * The data array must not be deallocated while the view is in use.
- */
-sc_dmatrix_t       *sc_dmatrix_new_data (sc_bint_t m, sc_bint_t n,
-                                         double *data);
-
-/** Create a matrix view on an existing sc_dmatrix_t.
- * The original matrix must have greater equal as many elements as the view.
- * The original matrix must not be destroyed or resized while view is in use.
- * \note            Currently, creating views of views is not safe.
- */
-sc_dmatrix_t       *sc_dmatrix_new_view (sc_bint_t m, sc_bint_t n,
-                                         sc_dmatrix_t * orig);
-
-/** Create a matrix view on an existing sc_dmatrix_t.
- * The start of the view is offset by a number of rows.
- * The original matrix must have greater equal as many elements as view end.
- * The original matrix must not be destroyed or resized while view is in use.
- * \param [in] o    Number of rows that the view is offset.
- *                  Requires (o + m) * n <= orig->m * orig->n.
- * \param [in] m    Number of rows that the view shall have.
- * \param [in] n    Number of columns that the view shall have.
- * \param [in] orig     This valid matrix is viewed.
- * \return              A newly created mxn view onto \b orig.
- * \note            Currently, creating views of views is not safe.
- */
-sc_dmatrix_t       *sc_dmatrix_new_view_offset (sc_bint_t o,
-                                                sc_bint_t m, sc_bint_t n,
-                                                sc_dmatrix_t * orig);
-
-/** Create a matrix view onto one column of an existing sc_dmatrix_t.
- * \param [in] orig     This matrix must have at least one column.
- *                      Its \b jth column is returned as a view.
- * \param [in] j        Valid column index into \b orig.
- * \return              A matrix of as many rows as \b orig and one column
- *                      whose entries point at the jth column of \b orig.
- * \note            Currently, creating views of views is not safe.
- */
-sc_dmatrix_t       *sc_dmatrix_new_view_column (sc_dmatrix_t * orig,
-                                                sc_bint_t j);
-
-/** Change a matrix view to point at a single column of another matrix.
- * \param [in,out] view     This must be a view and is modified in place.
- *                          It must have the same number of rows as \b orig.
- *                          On return, its number of columns will be one.
- * \param [in] orig         The \b jth column of this matrix is viewed.
- * \param [in] j            Valid column index into \b orig.
- * \note            Currently, creating views of views is not safe.
- */
-void                sc_dmatrix_view_set_column (sc_dmatrix_t * view,
-                                                sc_dmatrix_t * orig,
-                                                sc_bint_t j);
-
-/** Change a matrix view to point at a single row of another matrix.
- * \param [in,out] view     This must be a view and is modified in place.
- *                          It must have precisely one row.  On return,
- *                          its number of columns will match \b orig.
- * \param [in] orig         The \b jth row of this matrix is viewed.
- * \param [in] i            Valid row index into \b orig.
- * \note            Currently, creating views of views is not safe.
- */
-void                sc_dmatrix_view_set_row (sc_dmatrix_t * view,
-                                             sc_dmatrix_t * orig,
-                                             sc_bint_t i);
-
-/** Reshape a matrix to different m and n without changing m * n.
- */
-void                sc_dmatrix_reshape (sc_dmatrix_t * dmatrix,
-                                        sc_bint_t m, sc_bint_t n);
-
-/** Change the matrix dimensions.
- * For views it must be known that the new size is permitted.
- * For non-views the data will be realloced if necessary.
- * The entries are unchanged to the minimum of the old and new sizes.
- */
-void                sc_dmatrix_resize (sc_dmatrix_t * dmatrix,
-                                       sc_bint_t m, sc_bint_t n);
-
-/** Change the matrix dimensions, while keeping the subscripts in place, i.e.
- * dmatrix->e[i][j] will have the same value before and after, as long as
- * (i, j) is still a valid subscript.
- * This is not valid for views.
- * For non-views the data will be realloced if necessary.
- * The entries are unchanged to the minimum of the old and new sizes.
- */
-void                sc_dmatrix_resize_in_place (sc_dmatrix_t * dmatrix,
-                                                sc_bint_t m, sc_bint_t n);
-
-/** Destroy a dmatrix and all allocated memory. */
-void                sc_dmatrix_destroy (sc_dmatrix_t * dmatrix);
-
-/** Check whether a dmatrix is free of NaN entries.
- * \return          true if the dmatrix does not contain any NaN entries.
- */
-int                 sc_dmatrix_is_valid (const sc_dmatrix_t * A);
-
-/** Check a square dmatrix for symmetry.
- * \param [in] A            This square dmatrix is checked for symmetry.
- * \param [in] tolerance    Measures the absolute value of the max difference.
- * \return                  true if and only if matrix is numerically symmetric.
- */
-int                 sc_dmatrix_is_symmetric (const sc_dmatrix_t * A,
-                                             double tolerance);
-
-/** Set a matrix to all zero entries.
- * \param [in,out] dmatrix  Valid dmatrix whose entries are zero'd.
- */
-void                sc_dmatrix_set_zero (sc_dmatrix_t * dmatrix);
-
-/** Set all entries of a matrix to a constant.
- * \param [in,out] dmatrix  Valid dmatrix whose entries are set to \b value.
- * \param [in] value        This value is written into every entry of \b dmatrix.
- */
-void                sc_dmatrix_set_value (sc_dmatrix_t * dmatrix,
-                                          double value);
-
-/** Perform element-wise multiplication with a scalar, X := alpha .* X.
- */
-void                sc_dmatrix_scale (double alpha, sc_dmatrix_t * X);
-
-/** Perform element-wise addition with a scalar, X := X + alpha.
- */
-void                sc_dmatrix_shift (double alpha, sc_dmatrix_t * X);
-
-/** Perform element-wise multipl. & addition w/ scalar, X := alpha .* X + beta.
- */
-void                sc_dmatrix_scale_shift (double alpha, double beta,
-                                            sc_dmatrix_t * X);
-
-/** Perform element-wise divison with a scalar, X := alpha ./ X.
- */
-void                sc_dmatrix_alphadivide (double alpha, sc_dmatrix_t * X);
-
-/** Perform element-wise exponentiation with a scalar, X := X ^ alpha.
- */
-void                sc_dmatrix_pow (double exponent, sc_dmatrix_t * X);
-
-/** Perform element-wise absolute value, Y := fabs(X).
- */
-void                sc_dmatrix_fabs (const sc_dmatrix_t * X,
-                                     sc_dmatrix_t * Y);
-
-/** Perform element-wise square root, Y := sqrt(X).
- */
-void                sc_dmatrix_sqrt (const sc_dmatrix_t * X,
-                                     sc_dmatrix_t * Y);
-
-/** Extract the element-wise sign of a matrix, Y := (X >= 0 ? 1 : -1)
- */
-void                sc_dmatrix_getsign (const sc_dmatrix_t * X,
-                                        sc_dmatrix_t * Y);
-
-/** Compare a matrix element-wise against a bound, Y := (X >= bound ? 1 : 0)
- */
-void                sc_dmatrix_greaterequal (const sc_dmatrix_t * X,
-                                             double bound, sc_dmatrix_t * Y);
-
-/** Compare a matrix element-wise against a bound, Y := (X <= bound ? 1 : 0)
- */
-void                sc_dmatrix_lessequal (const sc_dmatrix_t * X,
-                                          double bound, sc_dmatrix_t * Y);
-
-/** Assign element-wise maximum, Y_i := (X_i > Y_i ? X_i : Y_i)
- */
-void                sc_dmatrix_maximum (const sc_dmatrix_t * X,
-                                        sc_dmatrix_t * Y);
-
-/** Assign element-wise minimum, Y_i := (X_i < Y_i ? X_i : Y_i)
- */
-void                sc_dmatrix_minimum (const sc_dmatrix_t * X,
-                                        sc_dmatrix_t * Y);
-
-/** Perform element-wise multiplication, Y := Y .* X.
- */
-void                sc_dmatrix_dotmultiply (const sc_dmatrix_t * X,
-                                            sc_dmatrix_t * Y);
-
-/** Perform element-wise division, Y := Y ./ X.
- */
-void                sc_dmatrix_dotdivide (const sc_dmatrix_t * X,
-                                          sc_dmatrix_t * Y);
-
-/** Perform element-wise multiplication & addition, Y := A .* X + Y.
- */
-void                sc_dmatrix_dotmultiply_add (const sc_dmatrix_t * A,
-                                                const sc_dmatrix_t * X,
-                                                sc_dmatrix_t * Y);
-
-/** Copy one matrix into another.
- * \param [in] X        Matrix taken as a source.
- * \param [in,out] Y    Matrix of dimensions of \b X.
- *                      On output, its entries are set to X.
- */
-void                sc_dmatrix_copy (const sc_dmatrix_t * X,
-                                     sc_dmatrix_t * Y);
-
-/** Copy one matrix transposed into another.
- * \param [in] X        Matrix taken as a source.
- * \param [in,out] Y    Matrix of dimensions of \b X transposed.
- *                      On output, its entries are set to X transposed.
- */
-void                sc_dmatrix_transpose (const sc_dmatrix_t * X,
-                                          sc_dmatrix_t * Y);
-
-/*! \brief Matrix Matrix Add (AXPY)  \c Y := alpha X + Y
- */
-void                sc_dmatrix_add (double alpha, const sc_dmatrix_t * X,
-                                    sc_dmatrix_t * Y);
-
-/** Perform matrix-vector multiplication Y = alpha * A * X + beta * Y.
- * The dimensions of A, X, and Y must be compatible.
- * \param [in] transa   Transpose operation for matrix A.
- * \param [in] transx   Transpose operation for matrix X.
- * \param [in] transy   Transpose operation for matrix Y.
- * \param [in] alpha    Factor for the matrix to multiply.
- * \param [in] A        Valid matrix or view.
- * \param [in] X        Column or row vector.
- * \param [in] beta     Factor for the original matrix.
- * \param [in] Y        Column or row vector.
- */
-void                sc_dmatrix_vector (sc_trans_t transa,
-                                       sc_trans_t transx,
-                                       sc_trans_t transy,
-                                       double alpha, const sc_dmatrix_t * A,
-                                       const sc_dmatrix_t * X, double beta,
-                                       sc_dmatrix_t * Y);
-
-/** Matrix-matrix multiplication \c C := alpha * A * B + beta * C
- * The dimensions of A, B, and C must be compatible.
- * \param [in] transa   Transpose operation for matrix A.
- * \param [in] transb   Transpose operation for matrix B.
- * \param [in] alpha    Factor for the matrix to multiply.
- * \param [in] A        First matrix to multiply.
- * \param [in] B        Secend Matrix to multiply.
- * \param [in] beta     Factor for the original matrix.
- * \param [in,out] C    Matrix is modified in place.
- */
-void                sc_dmatrix_multiply (sc_trans_t transa,
-                                         sc_trans_t transb, double alpha,
-                                         const sc_dmatrix_t * A,
-                                         const sc_dmatrix_t * B, double beta,
-                                         sc_dmatrix_t * C);
-
-/** \brief Left Divide \c A \ \c B.
- * The matrices cannot have 0 rows or columns.
- * Solves  \c A \c C = \c B or \c A' \c C = \c B.
- *
- *   \param transa Use the transpose of \c A
- *   \param A matrix
- *   \param B matrix
- *   \param C matrix
- */
-void                sc_dmatrix_ldivide (sc_trans_t transa,
-                                        const sc_dmatrix_t * A,
-                                        const sc_dmatrix_t * B,
-                                        sc_dmatrix_t * C);
-
-/** \brief Right Divide \c A / \c B.
- * The matrices cannot have 0 rows or columns.
- * Solves  \c A = \c C \c B or \c A = \c C \c B'.
- *
- *   \param transb Use the transpose of \c B
- *   \param A matrix
- *   \param B matrix
- *   \param C matrix
- */
-void                sc_dmatrix_rdivide (sc_trans_t transb,
-                                        const sc_dmatrix_t * A,
-                                        const sc_dmatrix_t * B,
-                                        sc_dmatrix_t * C);
-
-/** \brief Solve B^T <- A^{-T} B^T.
- * This call is destructive on the entries of the matrix A.
- * Solving multiple right hand sides is supported.
- *
- *   \param[in,out] A   Square invertible matrix.  Values are changed.
- *                      Its transpose is inverted and applied to B^T.
- *   \param[in,out] B   Rectangular matrix with as many columns as A.
- *                      On input, each row is an independent right hand side.
- *                      On output, each row holds the corresponding solution.
- */
-void                sc_dmatrix_solve_transpose_inplace
-  (sc_dmatrix_t * A, sc_dmatrix_t * B);
-
-/** \brief Writes a matrix to an opened stream.
- *
- *   \param dmatrix Pointer to matrix to write
- *   \param fp      Pointer to file to write to
- */
-void                sc_dmatrix_write (const sc_dmatrix_t * dmatrix,
-                                      FILE * fp);
-
-/** The sc_dmatrix_pool recycles matrices of the same size. */
-typedef struct sc_dmatrix_pool
-{
-  sc_bint_t           m;        /**< Number of rows of the matrices stored. */
-  sc_bint_t           n;        /**< NUmber of columns of matrices stored. */
-  size_t              elem_count;       /**< Number of matrices alive. */
-  sc_array_t          freed;    /**< Buffer for the matrices returned. */
-}
-sc_dmatrix_pool_t;
-
-/** Create a new dmatrix pool.
- * \param [in] m    Row count of the stored matrices.
- * \param [in] n    Column count of the stored matrices.
- * \return          Returns a dmatrix pool that is ready to use.
- */
-sc_dmatrix_pool_t  *sc_dmatrix_pool_new (sc_bint_t m, sc_bint_t n);
-
-/** Destroy a dmatrix pool.
- * This will also destroy all matrices stored for reuse.
- * Requires all allocated matrices to be returned to the pool previously.
- * \param [in,out] dmpool       The dmatrix pool to destroy.
- */
-void                sc_dmatrix_pool_destroy (sc_dmatrix_pool_t * dmpool);
-
-/** Allocate a dmatrix from the pool.
- * Reuses a matrix previously returned to the pool, or allocated a fresh one.
- * \param [in,out] dmpool   The dmatrix pool to use.
- * \return                  Returns a matrix of size dmpool->m by dmpool->n.
- */
-sc_dmatrix_t       *sc_dmatrix_pool_alloc (sc_dmatrix_pool_t * dmpool);
-
-/** Return a dmatrix to the pool.
- * The matrix is stored internally for reuse and not freed in this function.
- * \param [in] dmpool The dmatrix pool to use.
- * \param [in] dm     The dmatrix pool to return to the pool.
- */
-void                sc_dmatrix_pool_free (sc_dmatrix_pool_t * dmpool,
-                                          sc_dmatrix_t * dm);
-
-/** Multithreaded workspace allocations of multiple blocks. */
-typedef struct sc_darray_work
-{
-  double             *data;       /**< Entries of all blocks of all threads */
-  int                 n_threads;  /**< Number of threads */
-  int                 n_blocks;   /**< Number of blocks per thread */
-  int                 n_entries;  /**< Number of entries per block */
-}
-sc_darray_work_t;
-
-/** Create a new multithreaded workspace allocation object.
- * For each thread \c n_blocks of memory blocks with at least \c n_entries
- * double values are allocated.  The actual number of entries per block is
- * adjusted such that the base-pointer for each block is aligned to
- * \c alignment_bytes.  It is assumed that SC_ALLOC returns an aligned
- * base-pointer.  This function aborts on memory allocation errors.
- * \param [in] n_threads        Number of thread.
- * \param [in] n_blocks         Number of blocks per thread.
- * \param [in] n_entries        Minimum number of entries per block.
- * \param [in] alignment_bytes  Align blocks to this byte boundary.
- * \return                      A valid darray_work object.
- */
-sc_darray_work_t   *sc_darray_work_new (const int n_threads,
-                                        const int n_blocks,
-                                        const int n_entries,
-                                        const int alignment_bytes);
-
-/** Destroy a darray_work object and all allocated memory. */
-void                sc_darray_work_destroy (sc_darray_work_t * work);
-
-/** Get workspace allocation of a certain thread and a specified block.
- * \param [in] work         Workspace taken as a source.
- * \param [in] thread       Valid thread index into \b work.
- * \param [in] block        Valid block index into \b work.
- * \return                  Pointer to entries (memory aligned).
- */
-double             *sc_darray_work_get (sc_darray_work_t * work,
-                                        const int thread, const int block);
-
-/** Get the number of blocks per thread of a workspace allocation.
- * \param [in] work         Workspace taken as a source.
- * \return                  Number of allocated blocks per thread.
- */
-int                 sc_darray_work_get_blockcount (sc_darray_work_t * work);
-
-/** Get the number of entries per block of a workspace allocation.
- * \param [in] work         Workspace taken as a source.
- * \return                  Number of allocated entries per blocks per thread.
- */
-int                 sc_darray_work_get_blocksize (sc_darray_work_t * work);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_DMATRIX_H */
diff --git a/OctreeRefinement/include/sc_flops.h b/OctreeRefinement/include/sc_flops.h
deleted file mode 100644
index bd3a13a..0000000
--- a/OctreeRefinement/include/sc_flops.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_FLOPS_H
-#define SC_FLOPS_H
-
-#include <sc.h>
-
-SC_EXTERN_C_BEGIN;
-
-typedef struct sc_flopinfo
-{
-  double              seconds;  /* current time from sc_MPI_Wtime */
-
-  /* these variables measure onward from from sc_flops_start */
-  double              cwtime;   /* cumulative wall time */
-  float               crtime;   /* cumulative real time */
-  float               cptime;   /* cumulative process time */
-  long long           cflpops;  /* cumulative floating point operations */
-
-  /* measure since sc_flops_start or the previous sc_flops_count */
-  double              iwtime;   /* interval wall time */
-  float               irtime;   /* interval real time */
-  float               iptime;   /* interval process time */
-  long long           iflpops;  /* interval floating point operations */
-  float               mflops;   /* MFlop/s rate in this interval */
-
-  /* without SC_PAPI only seconds, ?wtime and ?rtime are meaningful */
-}
-sc_flopinfo_t;
-
-/**
- * Calls PAPI_flops.  Aborts on PAPI error.
- * The first call sets up the performance counters.
- * Subsequent calls return cumulative real and process times,
- * cumulative floating point operations and the flop rate since the last call.
- */
-void                sc_flops_papi (float *rtime, float *ptime,
-                                   long long *flpops, float *mflops);
-
-/**
- * Prepare sc_flopinfo_t structure and start flop counters.
- * Must only be called once during the program run.
- * This function calls sc_flops_papi.
- *
- * \param [out] fi  Members will be initialized.
- */
-void                sc_flops_start (sc_flopinfo_t * fi);
-
-/**
- * Update sc_flopinfo_t structure with current measurement.
- * Must only be called after sc_flops_start.
- * Can be called any number of times.
- * This function calls sc_flops_papi.
- *
- * \param [in,out] fi   Members will be updated.
- */
-void                sc_flops_count (sc_flopinfo_t * fi);
-
-/**
- * Call sc_flops_count (fi) and copies fi into snapshot.
- *
- * \param [in,out] fi       Members will be updated.
- * \param [out] snapshot    On output is a copy of fi.
- */
-void                sc_flops_snap (sc_flopinfo_t * fi,
-                                   sc_flopinfo_t * snapshot);
-
-/**
- * Call sc_flops_count (fi) and override snapshot interval timings
- * with the differences since the previous call to sc_flops_snap.
- * The interval mflop rate is computed by iflpops / 1e6 / irtime.
- * The cumulative timings in snapshot are copied form fi.
- *
- * \param [in,out] fi       Members will be updated.
- * \param [in,out] snapshot Interval timings measured since sc_flops_snap.
- */
-void                sc_flops_shot (sc_flopinfo_t * fi,
-                                   sc_flopinfo_t * snapshot);
-
-/**
- * Call sc_flops_count (fi) and work on all arguments in the list
- * of type sc_flopinfo_t * as in sc_flops_shot.  Last argument must be NULL.
- */
-void                sc_flops_shotv (sc_flopinfo_t * fi, ...);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_FLOPS_H */
diff --git a/OctreeRefinement/include/sc_functions.h b/OctreeRefinement/include/sc_functions.h
deleted file mode 100644
index 4060940..0000000
--- a/OctreeRefinement/include/sc_functions.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_FUNCTIONS_H
-#define SC_FUNCTIONS_H
-
-#include <sc.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Integer power routine.
- * Found in github.com:bfam/bfam.git, and originally in
- * http://stackoverflow.com/questions/101439/\
- * the-most-efficient-way-to-implement-an-integer-based-power-function-powint-int
- *
- * \param [in] base         This integer is taken to the power of \exp.
- *                          It may be negative as well.
- * \param [in] exp          This non-negative integer is the exponent.
- * \return                  We compute \b base ** \b exp.
- */
-int                 sc_intpow (int base, int exp);
-
-/* Power routine for 64-bit integers.
- * \see sc_intpow.
- * \param [in] base         This integer is taken to the power of \exp.
- *                          It may be negative as well.
- * \param [in] exp          This non-negative integer is the exponent.
- * \return                  We compute \b base ** \b exp.
- */
-int64_t             sc_intpow64 (int64_t base, int exp);
-
-/* Power routine for unsigned 64-bit integers.
- * \see sc_intpow.
- * \param [in] base         This integer is taken to the power of \exp.
- * \param [in] exp          This non-negative integer is the exponent.
- * \return                  We compute \b base ** \b exp.
- */
-uint64_t            sc_intpow64u (uint64_t base, int exp);
-
-typedef double      (*sc_function1_t) (double x, void *data);
-
-typedef double      (*sc_function3_t) (double x, double y, double z,
-                                       void *data);
-
-/*
- * this structure is used as data element for the meta functions.
- * for _sum and _product:
- * f1 needs to be a valid function.
- * f2 can be a function, then it is used,
- *    or NULL, in which case parameter2 is used.
- * for _tensor: f1, f2, f3 need to be valid functions.
- */
-typedef struct sc_function3_meta
-{
-  sc_function3_t      f1;
-  sc_function3_t      f2;
-  double              parameter2;
-  sc_function3_t      f3;
-  void               *data;
-}
-sc_function3_meta_t;
-
-/* Evaluate the inverse function with regula falsi: x = func^{-1}(y) */
-double              sc_function1_invert (sc_function1_t func, void *data,
-                                         double x_low, double x_high,
-                                         double y, double rtol);
-
-/** Seed the random number generator differently on each process.
- * Seeds each process with seed and mpirank from sc_MPI_COMM_WORLD.
- *    ( mpirank + seed * large_prime )
- *
- * \param [in] seed Seed for random number generator, calls srand ().
- */
-void                sc_srand (unsigned int seed);
-
-/** Seed the random number generator differently on each process.
- * Seeds each process with time and mpirank from sc_MPI_COMM_WORLD.
- *    ( time + mpirank * small_prime )
- */
-void                sc_srand_time ();
-
-/** Sample a uniform value from [0,1) via rand ().
- *
- * \return    randum number from uniform distribution on [0,1)
- */
-double              sc_rand_uniform (void);
-
-/** Sample a (gaussian) standard normal distribution.
- * Implements polar form of the Box Muller transform based on rand ().
- *
- * \return    random number from a univariate standard normal distribution
- */
-double              sc_rand_normal (void);
-
-/* Some basic 3D functions */
-double              sc_zero3 (double x, double y, double z, void *data);
-double              sc_one3 (double x, double y, double z, void *data);
-double              sc_two3 (double x, double y, double z, void *data);
-double              sc_ten3 (double x, double y, double z, void *data);
-
-/**
- * \param data   needs to be *double with the value of the constant.
- */
-double              sc_constant3 (double x, double y, double z, void *data);
-
-double              sc_x3 (double x, double y, double z, void *data);
-double              sc_y3 (double x, double y, double z, void *data);
-double              sc_z3 (double x, double y, double z, void *data);
-
-double              sc_sum3 (double x, double y, double z, void *data);
-double              sc_product3 (double x, double y, double z, void *data);
-double              sc_tensor3 (double x, double y, double z, void *data);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_FUNCTIONS_H */
diff --git a/OctreeRefinement/include/sc_getopt.h b/OctreeRefinement/include/sc_getopt.h
deleted file mode 100644
index d99ac9d..0000000
--- a/OctreeRefinement/include/sc_getopt.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_GETOPT_H
-#define SC_GETOPT_H
-
-#include <sc.h>
-
-#ifdef SC_PROVIDE_GETOPT
-#ifdef _GETOPT_H
-#error "getopt.h is included.  Please #include sc.h first."
-#endif
-#include "sc_builtin/getopt.h"
-#else
-#include <getopt.h>
-#endif
-
-#endif /* !SC_GETOPT_H */
diff --git a/OctreeRefinement/include/sc_io.h b/OctreeRefinement/include/sc_io.h
deleted file mode 100644
index 728d2ef..0000000
--- a/OctreeRefinement/include/sc_io.h
+++ /dev/null
@@ -1,301 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_IO_H
-#define SC_IO_H
-
-#include <sc.h>
-#include <sc_containers.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Error values for io.
- */
-typedef enum
-{
-  SC_IO_ERROR_NONE,     /**< The value of zero means no error. */
-  SC_IO_ERROR_FATAL = -1,       /**< The io object is now disfunctional. */
-  SC_IO_ERROR_AGAIN = -2        /**< Another io operation may resolve it.
-                                The function just returned was a noop. */
-}
-sc_io_error_t;
-
-typedef enum
-{
-  SC_IO_MODE_WRITE,     /**< Semantics as "w" in fopen. */
-  SC_IO_MODE_APPEND,    /**< Semantics as "a" in fopen. */
-  SC_IO_MODE_LAST       /**< Invalid entry to close list */
-}
-sc_io_mode_t;
-
-typedef enum
-{
-  SC_IO_ENCODE_NONE,
-  SC_IO_ENCODE_LAST     /**< Invalid entry to close list */
-}
-sc_io_encode_t;
-
-typedef enum
-{
-  SC_IO_TYPE_BUFFER,
-  SC_IO_TYPE_FILENAME,
-  SC_IO_TYPE_FILEFILE,
-  SC_IO_TYPE_LAST       /**< Invalid entry to close list */
-}
-sc_io_type_t;
-
-typedef struct sc_io_sink
-{
-  sc_io_type_t        iotype;
-  sc_io_mode_t        mode;
-  sc_io_encode_t      encode;
-  sc_array_t         *buffer;
-  size_t              buffer_bytes;    /**< distinguish from array elems */
-  FILE               *file;
-  size_t              bytes_in;
-  size_t              bytes_out;
-}
-sc_io_sink_t;
-
-typedef struct sc_io_source
-{
-  sc_io_type_t        iotype;
-  sc_io_encode_t      encode;
-  sc_array_t         *buffer;
-  size_t              buffer_bytes;    /**< distinguish from array elems */
-  FILE               *file;
-  size_t              bytes_in;
-  size_t              bytes_out;
-  sc_io_sink_t       *mirror;
-  sc_array_t         *mirror_buffer;
-}
-sc_io_source_t;
-
-/** Create a generic data sink.
- * \param [in] iotype           Type of the sink.
- *                              Depending on iotype, varargs must follow:
- *                              BUFFER: sc_array_t * (existing array).
- *                              FILENAME: const char * (name of file to open).
- *                              FILEFILE: FILE * (file open for writing).
- *                              These buffers are only borrowed by the sink.
- * \param [in] mode             Mode to add data to sink.
- *                              For type FILEFILE, data is always appended.
- * \param [in] encode           Type of data encoding.
- * \return                      Newly allocated sink, or NULL on error.
- */
-sc_io_sink_t       *sc_io_sink_new (sc_io_type_t iotype,
-                                    sc_io_mode_t mode,
-                                    sc_io_encode_t encode, ...);
-
-/** Free data sink.
- * Calls sc_io_sink_complete and discards the final counts.
- * Errors from complete lead to SC_IO_ERROR_FATAL returned from this function.
- * Call sc_io_sink_complete yourself if bytes_out is of interest.
- * \param [in,out] sink         The sink object to complete and free.
- * \return                      0 on success, nonzero on error.
- */
-int                 sc_io_sink_destroy (sc_io_sink_t * sink);
-
-/** Write data to a sink.  Data may be buffered and sunk in a later call.
- * The internal counters sink->bytes_in and sink->bytes_out are updated.
- * \param [in,out] sink         The sink object to write to.
- * \param [in] data             Data passed into sink.
- * \param [in] bytes_avail      Number of data bytes passed in.
- * \return                      0 on success, nonzero on error.
- */
-int                 sc_io_sink_write (sc_io_sink_t * sink,
-                                      const void *data, size_t bytes_avail);
-
-/** Flush all buffered output data to sink.
- * This function may return SC_IO_ERROR_AGAIN if another write is required.
- * Currently this may happen if BUFFER requires an integer multiple of bytes.
- * If successful, the updated value of bytes read and written is returned
- * in bytes_in/out, and the sink status is reset as if the sink had just
- * been created.  In particular, the bytes counters are reset to zero.
- * The internal state of the sink is not changed otherwise.
- * It is legal to continue writing to the sink hereafter.
- * The sink actions taken depend on its type.
- * BUFFER, FILEFILE: none.
- * FILENAME: call fclose on sink->file.
- * \param [in,out] sink         The sink object to write to.
- * \param [in,out] bytes_in     Bytes received since the last new or complete
- *                              call.  May be NULL.
- * \param [in,out] bytes_out    Bytes written since the last new or complete
- *                              call.  May be NULL.
- * \return                      0 if completed, nonzero on error.
- */
-int                 sc_io_sink_complete (sc_io_sink_t * sink,
-                                         size_t * bytes_in,
-                                         size_t * bytes_out);
-
-/** Align sink to a byte boundary by writing zeros.
- * \param [in,out] sink         The sink object to align.
- * \param [in] bytes_align      Byte boundary.
- * \return                      0 on success, nonzero on error.
- */
-int                 sc_io_sink_align (sc_io_sink_t * sink,
-                                      size_t bytes_align);
-
-/** Create a generic data source.
- * \param [in] iotype           Type of the source.
- *                              Depending on iotype, varargs must follow:
- *                              BUFFER: sc_array_t * (existing array).
- *                              FILENAME: const char * (name of file to open).
- *                              FILEFILE: FILE * (file open for reading).
- * \param [in] encode           Type of data encoding.
- * \return                      Newly allocated source, or NULL on error.
- */
-sc_io_source_t     *sc_io_source_new (sc_io_type_t iotype,
-                                      sc_io_encode_t encode, ...);
-
-/** Free data source.
- * Calls sc_io_source_complete and requires it to return no error.
- * This is to avoid discarding buffered data that has not been passed to read.
- * \param [in,out] source       The source object to free.
- * \return                      0 on success.  Nonzero if an error is
- *                              encountered or is_complete returns one.
- */
-int                 sc_io_source_destroy (sc_io_source_t * source);
-
-/** Read data from a source.
- * The internal counters source->bytes_in and source->bytes_out are updated.
- * Data is read until the data buffer has not enough room anymore, or source
- * becomes empty.  It is possible that data already read internally remains
- * in the source object for the next call.  Call sc_io_source_complete and
- * check its return value to find out.
- * Returns an error if bytes_out is NULL and less than bytes_avail are read.
- * \param [in,out] source       The source object to read from.
- * \param [in] data             Data buffer for reading from sink.
- *                              If NULL the output data will be thrown away.
- * \param [in] bytes_avail      Number of bytes available in data buffer.
- * \param [in,out] bytes_out    If not NULL, byte count read into data buffer.
- *                              Otherwise, requires to read exactly bytes_avail.
- * \return                      0 on success, nonzero on error.
- */
-int                 sc_io_source_read (sc_io_source_t * source,
-                                       void *data, size_t bytes_avail,
-                                       size_t * bytes_out);
-
-/** Determine whether all data buffered from source has been returned by read.
- * If it returns SC_IO_ERROR_AGAIN, another sc_io_source_read is required.
- * If the call returns no error, the internal counters source->bytes_in and
- * source->bytes_out are returned to the caller if requested, and reset to 0.
- * The internal state of the source is not changed otherwise.
- * It is legal to continue reading from the source hereafter.
- *
- * \param [in,out] source       The source object to read from.
- * \param [in,out] bytes_in     If not NULL and true is returned,
- *                              the total size of the data sourced.
- * \param [in,out] bytes_out    If not NULL and true is returned,
- *                              total bytes passed out by source_read.
- * \return                      SC_IO_ERROR_AGAIN if buffered data remaining.
- *                              Otherwise return ERROR_NONE and reset counters.
- */
-int                 sc_io_source_complete (sc_io_source_t * source,
-                                           size_t * bytes_in,
-                                           size_t * bytes_out);
-
-/** Align source to a byte boundary by skipping.
- * \param [in,out] source       The source object to align.
- * \param [in] bytes_align      Byte boundary.
- * \return                      0 on success, nonzero on error.
- */
-int                 sc_io_source_align (sc_io_source_t * source,
-                                        size_t bytes_align);
-
-/** Activate a buffer that mirrors (i.e., stores) the data that was read.
- * \param [in,out] source       The source object to activate mirror in.
- * \return                      0 on success, nonzero on error.
- */
-int                 sc_io_source_activate_mirror (sc_io_source_t * source);
-
-/** Read data from the source's mirror.
- * Same behaviour as sc_io_source_read.
- * \param [in,out] source       The source object to read mirror data from.
- * \return                      0 on success, nonzero on error.
- */
-int                 sc_io_source_read_mirror (sc_io_source_t * source,
-                                              void *data,
-                                              size_t bytes_avail,
-                                              size_t * bytes_out);
-
-/** This function writes numeric binary data in VTK base64 encoding.
- * \param vtkfile        Stream openened for writing.
- * \param numeric_data   A pointer to a numeric data array.
- * \param byte_length    The length of the data array in bytes.
- * \return               Returns 0 on success, -1 on file error.
- */
-int                 sc_vtk_write_binary (FILE * vtkfile, char *numeric_data,
-                                         size_t byte_length);
-
-/** This function writes numeric binary data in VTK compressed format.
- * \param vtkfile        Stream openened for writing.
- * \param numeric_data   A pointer to a numeric data array.
- * \param byte_length    The length of the data array in bytes.
- * \return               Returns 0 on success, -1 on file error.
- */
-int                 sc_vtk_write_compressed (FILE * vtkfile,
-                                             char *numeric_data,
-                                             size_t byte_length);
-
-/** Write memory content to a file.
- * \param [in] ptr      Data array to write to disk.
- * \param [in] size     Size of one array member.
- * \param [in] nmemb    Number of array members.
- * \param [in,out] file File pointer, must be opened for writing.
- * \param [in] errmsg   Error message passed to SC_CHECK_ABORT.
- * \note                This function aborts on file errors.
- */
-void                sc_fwrite (const void *ptr, size_t size,
-                               size_t nmemb, FILE * file, const char *errmsg);
-
-/** Read file content into memory.
- * \param [out] ptr     Data array to read from disk.
- * \param [in] size     Size of one array member.
- * \param [in] nmemb    Number of array members.
- * \param [in,out] file File pointer, must be opened for reading.
- * \param [in] errmsg   Error message passed to SC_CHECK_ABORT.
- * \note                This function aborts on file errors.
- */
-void                sc_fread (void *ptr, size_t size,
-                              size_t nmemb, FILE * file, const char *errmsg);
-
-#ifdef SC_ENABLE_MPIIO
-
-/** Write memory content to an MPI file.
- * \param [in,out] mpifile      MPI file object opened for writing.
- * \param [in] ptr      Data array to write to disk.
- * \param [in] zcount   Number of array members.
- * \param [in] t        The MPI type for each array member.
- * \param [in] errmsg   Error message passed to SC_CHECK_ABORT.
- * \note                This function aborts on MPI file and count errors.
- */
-void                sc_mpi_write (MPI_File mpifile, const void *ptr,
-                                  size_t zcount, sc_MPI_Datatype t,
-                                  const char *errmsg);
-
-#endif
-
-SC_EXTERN_C_END;
-
-#endif /* SC_IO_H */
diff --git a/OctreeRefinement/include/sc_keyvalue.h b/OctreeRefinement/include/sc_keyvalue.h
deleted file mode 100644
index b8adef3..0000000
--- a/OctreeRefinement/include/sc_keyvalue.h
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_KEYVALUE_H
-#define SC_KEYVALUE_H
-
-/** \file sc_keyvalue.h
- * This file provides a lookup structure for key-value pairs.
- */
-
-#include <sc.h>
-#include <sc_containers.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** The values can have different types. */
-typedef enum
-{
-  SC_KEYVALUE_ENTRY_NONE = 0,   /**< Designate an invalid situation. */
-  SC_KEYVALUE_ENTRY_INT,        /**< Used for values of type int. */
-  SC_KEYVALUE_ENTRY_DOUBLE,     /**< Used for values of type double. */
-  SC_KEYVALUE_ENTRY_STRING,     /**< Used for values of type const char *. */
-  SC_KEYVALUE_ENTRY_POINTER     /**< Used for values of anonymous pointer type. */
-}
-sc_keyvalue_entry_type_t;
-
-/** The key-value container is an opaque structure. */
-typedef struct sc_keyvalue sc_keyvalue_t;
-
-/** Create a new key-value container.
- * \return          The container is ready to use.
- */
-sc_keyvalue_t      *sc_keyvalue_new ();
-
-/** Create a container and set one or more key-value pairs.
- * Arguments come in pairs of 2: a static string "type:key" and a value.
- * The type is the letter i, g, s, p for int, double, const char *, and void *,
- * respectively.
- * \param [in] dummy            Not touched, just to use the varargs feature.
- * \return                      A key-value container initialized with the given entries.
- */
-sc_keyvalue_t      *sc_keyvalue_newf (int dummy, ...);
-
-/** Create a container and set one or more key-value pairs.
- * This function works analogously to \ref sc_keyvalue_newf.
- * Arguments come in pairs of 2: a static string "type:key" and a value.
- * The type is the letter i, g, s, p for int, double, const char *, and void *,
- * respectively.
- * \param [in] ap               Varargs pointer; see stdarg.h for the syntax.
- * \return                      A key-value container initialized with the given entries.
- */
-sc_keyvalue_t      *sc_keyvalue_newv (va_list ap);
-
-/** Free a key-value container and all internal memory for key storage.
- * \param [in,out] kv           The key-value container is invalidated by this call.
- */
-void                sc_keyvalue_destroy (sc_keyvalue_t * kv);
-
-/** Routine to check existence of an entry.
- * \param [in] kv               Valid key-value container.
- * \param [in] key              Lookup key to query.
- * \return                      The entry's type if found
- *                              and SC_KEYVALUE_ENTRY_NONE otherwise.
- */
-sc_keyvalue_entry_type_t sc_keyvalue_exists (sc_keyvalue_t * kv,
-                                             const char *key);
-
-/** Routine to remove an entry.
- * \param [in] kv               Valid key-value container.
- * \param [in] key              Lookup key to remove if it exists.
- * \return                      The entry's type if found and removed,
- *                              SC_KEYVALUE_ENTRY_NONE otherwise.
- */
-sc_keyvalue_entry_type_t sc_keyvalue_unset (sc_keyvalue_t * kv,
-                                            const char *key);
-
-/** Routines to retrieve an integer value by its key.
- * This function asserts that the key, if existing, points to the correct type.
- * \param [in] kv               Valid key-value container.
- * \param [in] key              Lookup key, may or may not exist.
- * \param [in] dvalue           Default value returned if key is not found.
- * \return                      If key is not present then \b dvalue is returned,
- *                              otherwise the value stored under \b key.
- */
-int                 sc_keyvalue_get_int (sc_keyvalue_t * kv,
-                                         const char *key, int dvalue);
-
-/** Retrieve a double value by its key.
- * This function asserts that the key, if existing, points to the correct type.
- * \param [in] kv               Valid key-value container.
- * \param [in] key              Lookup key, may or may not exist.
- * \param [in] dvalue           Default value returned if key is not found.
- * \return                      If key is not present then \b dvalue is returned,
- *                              otherwise the value stored under \b key.
- */
-double              sc_keyvalue_get_double (sc_keyvalue_t * kv,
-                                            const char *key, double dvalue);
-
-/** Retrieve a string value by its key.
- * This function asserts that the key, if existing, points to the correct type.
- * \param [in] kv               Valid key-value container.
- * \param [in] key              Lookup key, may or may not exist.
- * \param [in] dvalue           Default value returned if key is not found.
- * \return                      If key is not present then \b dvalue is returned,
- *                              otherwise the value stored under \b key.
- */
-const char         *sc_keyvalue_get_string (sc_keyvalue_t * kv,
-                                            const char *key,
-                                            const char *dvalue);
-
-/** Retrieve a pointer value by its key.
- * This function asserts that the key, if existing, points to the correct type.
- * \param [in] kv               Valid key-value container.
- * \param [in] key              Lookup key, may or may not exist.
- * \param [in] dvalue           Default value returned if key is not found.
- * \return                      If key is not present then \b dvalue is returned,
- *                              otherwise the value stored under \b key.
- */
-void               *sc_keyvalue_get_pointer (sc_keyvalue_t * kv,
-                                             const char *key, void *dvalue);
-
-/** Query an integer key with error checking.
- * We check whether the key is not found or it is of the wrong type.
- * A default value to be returned on error can be passed in as *status.
- * If status is NULL, then the result on error is undefined.
- * \param [in] kv           Valid key-value table.
- * \param [in] key          Non-NULL key string.
- * \param [in,out] status   If not NULL, set to
- *                          0 if there is no error,
- *                          1 if the key is not found,
- *                          2 if a value is found but its type is not integer,
- *                          and return the input value *status on error.
- * \return                  On error we return *status if status is not NULL,
- *                          and else an undefined value backed by an assertion.
- *                          Without error, return the result of the lookup.
- */
-int                 sc_keyvalue_get_int_check (sc_keyvalue_t * kv,
-                                               const char *key, int *status);
-
-/** Routine to set an integer value for a given key.
- * \param [in] kv           Valid key-value table.
- * \param [in] key          Non-NULL key to insert or replace.
- *                          If it already exists, it must be of type integer.
- * \param [in] newvalue     New value will be stored under key.
- */
-void                sc_keyvalue_set_int (sc_keyvalue_t * kv,
-                                         const char *key, int newvalue);
-
-/** Routine to set a double value for a given key.
- * \param [in] kv           Valid key-value table.
- * \param [in] key          Non-NULL key to insert or replace.
- *                          If it already exists, it must be of type double.
- * \param [in] newvalue     New value will be stored under key.
- */
-void                sc_keyvalue_set_double (sc_keyvalue_t * kv,
-                                            const char *key, double newvalue);
-
-/** Routine to set a string value for a given key.
- * \param [in] kv           Valid key-value table.
- * \param [in] key          Non-NULL key to insert or replace.
- *                          If it already exists, it must be of type string.
- * \param [in] newvalue     New value will be stored under key.
- */
-void                sc_keyvalue_set_string (sc_keyvalue_t * kv,
-                                            const char *key,
-                                            const char *newvalue);
-
-/** Routine to set a pointer value for a given key.
- * \param [in] kv           Valid key-value table.
- * \param [in] key          Non-NULL key to insert or replace.
- *                          If it already exists, it must be of type pointer.
- * \param [in] newvalue     New value will be stored under key.
- */
-void                sc_keyvalue_set_pointer (sc_keyvalue_t * kv,
-                                             const char *key, void *newvalue);
-
-/** Function to call on every key value pair
- * \param [in] key   The key for this pair
- * \param [in] type  The type of entry
- * \param [in] entry Pointer to the entry
- * \param [in] u     Arbitrary user data.
- * \return Return true if the traversal should continue, false to stop.
- */
-typedef int         (*sc_keyvalue_foreach_t) (const char *key,
-                                              const sc_keyvalue_entry_type_t
-                                              type, void *entry,
-                                              const void *u);
-
-/** Iterate through all stored key-value pairs.
- * \param [in] kv               Valid key-value container.
- * \param [in] fn               Function to call on each key-value pair.
- * \param [in,out] user_data    This pointer is passed through to \b fn.
- */
-void                sc_keyvalue_foreach (sc_keyvalue_t * kv,
-                                         sc_keyvalue_foreach_t fn,
-                                         void *user_data);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_KEYVALUE_H */
diff --git a/OctreeRefinement/include/sc_lapack.h b/OctreeRefinement/include/sc_lapack.h
deleted file mode 100644
index bc9d299..0000000
--- a/OctreeRefinement/include/sc_lapack.h
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_LAPACK_H
-#define SC_LAPACK_H
-
-#include <sc_blas.h>
-
-SC_EXTERN_C_BEGIN;
-
-typedef enum sc_jobz
-{
-  SC_EIGVALS_ONLY,
-  SC_EIGVALS_AND_EIGVECS,
-  SC_JOBZ_ANCHOR
-}
-sc_jobz_t;
-
-extern const char   sc_jobzchar[];
-
-#ifdef SC_WITH_LAPACK
-
-#ifndef SC_F77_FUNC
-#if defined(__bgq__)            /* && defined(__HAVE_ESSL) */
-#define SC_F77_FUNC(small,CAPS) small
-/* TODO - FIX THIS FOR NOW WE DO NOT USE ESSL
-  #   define SC_F77_FUNC(small,CAPS) small ## _
-*/
-#define SC_F77_FUNC_NOESSL(small,CAPS) small
-#else
-#define SC_F77_FUNC(small,CAPS) small ## _
-#endif
-#endif /* SC_F77_FUNC */
-
-#define SC_LAPACK_DGELS   SC_F77_FUNC(dgels,DGELS)
-#define SC_LAPACK_DGESV   SC_F77_FUNC(dgesv,DGESV)
-#define SC_LAPACK_DGETRF  SC_F77_FUNC(dgetrf,DGETRF)
-#define SC_LAPACK_DGETRS  SC_F77_FUNC(dgetrs,DGETRS)
-#if defined(__bgq__)            /* && define(__HAVE_ESSL) */
-#define SC_LAPACK_DSTEV   SC_F77_FUNC_NOESSL(dstev,DSTEV)
-#else
-#define SC_LAPACK_DSTEV   SC_F77_FUNC(dstev,DSTEV)
-#endif
-#define SC_LAPACK_DTRSM   SC_F77_FUNC(dtrsm,DTRSM)
-#define SC_LAPACK_DLAIC1  SC_F77_FUNC(dlaic1,DLAIC1)
-#define SC_LAPACK_ILAENV  SC_F77_FUNC(ilaenv,ILAENV)
-
-void                SC_LAPACK_DGELS (const char *trans,
-                                     const sc_bint_t * m, const sc_bint_t * n,
-                                     const sc_bint_t * nrhs, double *a,
-                                     const sc_bint_t * lda, double *b,
-                                     const sc_bint_t * ldb, double *work,
-                                     const sc_bint_t * lwork,
-                                     sc_bint_t * info);
-
-void                SC_LAPACK_DGESV (const sc_bint_t * n,
-                                     const sc_bint_t * nrhs,
-                                     double *a, const sc_bint_t * lda,
-                                     sc_bint_t * ipiv,
-                                     double *b, const sc_bint_t * ldb,
-                                     sc_bint_t * info);
-
-void                SC_LAPACK_DGETRF (const sc_bint_t * m,
-                                      const sc_bint_t * n, double *a,
-                                      const sc_bint_t * lda, sc_bint_t * ipiv,
-                                      sc_bint_t * info);
-
-void                SC_LAPACK_DGETRS (const char *trans, const sc_bint_t * n,
-                                      const sc_bint_t * nrhs, const double *a,
-                                      const sc_bint_t * lda,
-                                      const sc_bint_t * ipiv, double *b,
-                                      const sc_bint_t * ldx,
-                                      sc_bint_t * info);
-
-void                SC_LAPACK_DSTEV (const char *jobz,
-                                     const sc_bint_t * n,
-                                     double *d,
-                                     double *e,
-                                     double *z,
-                                     const sc_bint_t * ldz,
-                                     double *work, sc_bint_t * info);
-
-void                SC_LAPACK_DTRSM (const char *side,
-                                     const char *uplo,
-                                     const char *transa,
-                                     const char *diag,
-                                     const sc_bint_t * m,
-                                     const sc_bint_t * n,
-                                     const double *alpha,
-                                     const double *a,
-                                     const sc_bint_t * lda,
-                                     const double *b, const sc_bint_t * ldb);
-
-void                SC_LAPACK_DLAIC1 (const int *job,
-                                      const int *j,
-                                      const double *x,
-                                      const double *sest,
-                                      const double *w,
-                                      const double *gamma,
-                                      double *sestpr, double *s, double *c);
-
-int                 SC_LAPACK_ILAENV (const sc_bint_t * ispec,
-                                      const char *name,
-                                      const char *opts,
-                                      const sc_bint_t * N1,
-                                      const sc_bint_t * N2,
-                                      const sc_bint_t * N3,
-                                      const sc_bint_t * N4,
-                                      sc_buint_t name_length,
-                                      sc_buint_t opts_length);
-
-#else /* !SC_WITH_LAPACK */
-
-#define SC_LAPACK_DGELS    (void) sc_lapack_nonimplemented
-#define SC_LAPACK_DGESV    (void) sc_lapack_nonimplemented
-#define SC_LAPACK_DGETRF   (void) sc_lapack_nonimplemented
-#define SC_LAPACK_DGETRS   (void) sc_lapack_nonimplemented
-#define SC_LAPACK_DSTEV    (void) sc_lapack_nonimplemented
-#define SC_LAPACK_DTRSM    (void) sc_lapack_nonimplemented
-#define SC_LAPACK_DLAIC1   (void) sc_lapack_nonimplemented
-#define SC_LAPACK_ILAENV   (int)  sc_lapack_nonimplemented
-
-int                 sc_lapack_nonimplemented (SC_NOARGS);
-
-#endif
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_LAPACK_H */
diff --git a/OctreeRefinement/include/sc_lua.h b/OctreeRefinement/include/sc_lua.h
deleted file mode 100644
index ce06b2b..0000000
--- a/OctreeRefinement/include/sc_lua.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_LUA_H
-#define SC_LUA_H
-
-#include <sc.h>
-
-#ifdef SC_HAVE_LUA
-
-SC_EXTERN_C_BEGIN;
-
-#ifdef SC_HAVE_LUA5_2_LUA_H
-#include <lua5.2/lua.h>
-#include <lua5.2/lualib.h>
-#include <lua5.2/lauxlib.h>
-#else
-#ifdef SC_HAVE_LUA5_1_LUA_H
-#include <lua5.1/lua.h>
-#include <lua5.1/lualib.h>
-#include <lua5.1/lauxlib.h>
-#else
-#ifdef SC_HAVE_LUA_H
-#include <lua.h>
-#include <lualib.h>
-#include <lauxlib.h>
-#endif
-#endif
-#endif
-
-SC_EXTERN_C_END;
-
-#else
-#error "We did not find a recent lua library that provides lua_createtable."
-#endif
-
-#endif /* !SC_LUA_H */
diff --git a/OctreeRefinement/include/sc_mpi.h b/OctreeRefinement/include/sc_mpi.h
deleted file mode 100644
index a28b6c3..0000000
--- a/OctreeRefinement/include/sc_mpi.h
+++ /dev/null
@@ -1,416 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-/** \file
- *
- * This file emulates collective MPI routines for non-MPI code.
- *
- * The goal is to make code compile and execute cleanly when `--enable-mpi` is
- * not given on the configure line.  To this end, several MPI routines that are
- * meaningful to call on one processor are provided with the prefix `sc_MPI_`,
- * as well as necessary types and defines.  If `--enable-mpi` is given, this
- * file provides macros that map the sc_-prefixed form to the standard form of
- * the symbols.
- *
- * When including this file in your code, everything inside `#ifdef
- * SC_ENABLE_MPI` can use the standard MPI API.  Outside of this define, you
- * may use the sc_MPI_* routines specified here to seamlessly use MPI calls.
- *
- * Some send and receive routines are wrapped.  They can thus be used
- * in code outside of `#ifdef SC_ENABLE_MPI` even though they will abort.  If
- * no messages are sent to the same processor when mpisize == 1, such aborts
- * will not occur.  The `MPI_Wait*` routines are safe to call as long as no or
- * only MPI_REQUEST_NULL requests are passed in.
- */
-
-#ifndef SC_MPI_H
-#define SC_MPI_H
-
-#include <sc.h>
-
-SC_EXTERN_C_BEGIN;
-
-typedef enum
-{
-  SC_TAG_FIRST = 's' + 'c',     /* anything really */
-  SC_TAG_AG_ALLTOALL = SC_TAG_FIRST,
-  SC_TAG_AG_RECURSIVE_A,
-  SC_TAG_AG_RECURSIVE_B,
-  SC_TAG_AG_RECURSIVE_C,
-  SC_TAG_NOTIFY_RECURSIVE,
-  SC_TAG_REDUCE = SC_TAG_NOTIFY_RECURSIVE + 32,
-  SC_TAG_PSORT_LO,
-  SC_TAG_PSORT_HI,
-  SC_TAG_LAST
-}
-sc_tag_t;
-
-#ifdef SC_ENABLE_MPI
-
-/* constants */
-
-#define sc_MPI_SUCCESS             MPI_SUCCESS
-#define sc_MPI_COMM_NULL           MPI_COMM_NULL
-#define sc_MPI_COMM_WORLD          MPI_COMM_WORLD
-#define sc_MPI_COMM_SELF           MPI_COMM_SELF
-
-#define sc_MPI_GROUP_NULL          MPI_GROUP_NULL
-#define sc_MPI_GROUP_EMPTY         MPI_GROUP_EMPTY
-
-#define sc_MPI_IDENT               MPI_IDENT
-#define sc_MPI_CONGRUENT           MPI_CONGRUENT
-#define sc_MPI_SIMILAR             MPI_SIMILAR
-#define sc_MPI_UNEQUAL             MPI_UNEQUAL
-
-#define sc_MPI_ANY_SOURCE          MPI_ANY_SOURCE
-#define sc_MPI_ANY_TAG             MPI_ANY_TAG
-#define sc_MPI_STATUS_IGNORE       MPI_STATUS_IGNORE
-#define sc_MPI_STATUSES_IGNORE     MPI_STATUSES_IGNORE
-
-#define sc_MPI_REQUEST_NULL        MPI_REQUEST_NULL
-
-#define sc_MPI_DATATYPE_NULL       MPI_DATATYPE_NULL
-
-#define sc_MPI_CHAR                MPI_CHAR
-#define sc_MPI_SIGNED_CHAR         MPI_SIGNED_CHAR
-#define sc_MPI_UNSIGNED_CHAR       MPI_UNSIGNED_CHAR
-#define sc_MPI_BYTE                MPI_BYTE
-#define sc_MPI_SHORT               MPI_SHORT
-#define sc_MPI_UNSIGNED_SHORT      MPI_UNSIGNED_SHORT
-#define sc_MPI_INT                 MPI_INT
-#define sc_MPI_UNSIGNED            MPI_UNSIGNED
-#define sc_MPI_LONG                MPI_LONG
-#define sc_MPI_UNSIGNED_LONG       MPI_UNSIGNED_LONG
-#define sc_MPI_LONG_LONG_INT       MPI_LONG_LONG_INT
-#define sc_MPI_UNSIGNED_LONG_LONG  MPI_UNSIGNED_LONG_LONG
-#define sc_MPI_FLOAT               MPI_FLOAT
-#define sc_MPI_DOUBLE              MPI_DOUBLE
-#define sc_MPI_LONG_DOUBLE         MPI_LONG_DOUBLE
-
-#define sc_MPI_MAX                 MPI_MAX
-#define sc_MPI_MIN                 MPI_MIN
-#define sc_MPI_SUM                 MPI_SUM
-#define sc_MPI_PROD                MPI_PROD
-#define sc_MPI_LAND                MPI_LAND
-#define sc_MPI_BAND                MPI_BAND
-#define sc_MPI_LOR                 MPI_LOR
-#define sc_MPI_BOR                 MPI_BOR
-#define sc_MPI_LXOR                MPI_LXOR
-#define sc_MPI_BXOR                MPI_BXOR
-#define sc_MPI_MINLOC              MPI_MINLOC
-#define sc_MPI_MAXLOC              MPI_MAXLOC
-#define sc_MPI_REPLACE             MPI_REPLACE
-
-#define sc_MPI_UNDEFINED           MPI_UNDEFINED
-
-#define sc_MPI_ERR_GROUP           MPI_ERR_GROUP
-
-/* types */
-
-#define sc_MPI_Comm                MPI_Comm
-#define sc_MPI_Group               MPI_Group
-#define sc_MPI_Datatype            MPI_Datatype
-#define sc_MPI_Op                  MPI_Op
-#define sc_MPI_Request             MPI_Request
-#define sc_MPI_Status              MPI_Status
-
-/* functions */
-
-#define sc_MPI_Init                MPI_Init
-/*      sc_MPI_Init_thread is handled below */
-#define sc_MPI_Finalize            MPI_Finalize
-#define sc_MPI_Abort               MPI_Abort
-#define sc_MPI_Comm_dup            MPI_Comm_dup
-#define sc_MPI_Comm_create         MPI_Comm_create
-#define sc_MPI_Comm_split          MPI_Comm_split
-#define sc_MPI_Comm_free           MPI_Comm_free
-#define sc_MPI_Comm_size           MPI_Comm_size
-#define sc_MPI_Comm_rank           MPI_Comm_rank
-#define sc_MPI_Comm_compare        MPI_Comm_compare
-#define sc_MPI_Comm_group          MPI_Comm_group
-#define sc_MPI_Group_free          MPI_Group_free
-#define sc_MPI_Group_size          MPI_Group_size
-#define sc_MPI_Group_rank          MPI_Group_rank
-#define sc_MPI_Group_translate_ranks MPI_Group_translate_ranks
-#define sc_MPI_Group_compare       MPI_Group_compare
-#define sc_MPI_Group_union         MPI_Group_union
-#define sc_MPI_Group_intersection  MPI_Group_intersection
-#define sc_MPI_Group_difference    MPI_Group_difference
-#define sc_MPI_Group_incl          MPI_Group_incl
-#define sc_MPI_Group_excl          MPI_Group_excl
-#define sc_MPI_Group_range_incl    MPI_Group_range_incl
-#define sc_MPI_Group_range_excl    MPI_Group_range_excl
-#define sc_MPI_Barrier             MPI_Barrier
-#define sc_MPI_Bcast               MPI_Bcast
-#define sc_MPI_Gather              MPI_Gather
-#define sc_MPI_Gatherv             MPI_Gatherv
-#define sc_MPI_Allgather           MPI_Allgather
-#define sc_MPI_Allgatherv          MPI_Allgatherv
-#define sc_MPI_Alltoall            MPI_Alltoall
-#define sc_MPI_Reduce              MPI_Reduce
-#define sc_MPI_Allreduce           MPI_Allreduce
-#define sc_MPI_Scan                MPI_Scan
-#define sc_MPI_Exscan              MPI_Exscan
-#define sc_MPI_Recv                MPI_Recv
-#define sc_MPI_Irecv               MPI_Irecv
-#define sc_MPI_Send                MPI_Send
-#define sc_MPI_Isend               MPI_Isend
-#define sc_MPI_Probe               MPI_Probe
-#define sc_MPI_Iprobe              MPI_Iprobe
-#define sc_MPI_Get_count           MPI_Get_count
-#define sc_MPI_Wtime               MPI_Wtime
-#define sc_MPI_Wait                MPI_Wait
-#define sc_MPI_Waitsome            MPI_Waitsome
-#define sc_MPI_Waitall             MPI_Waitall
-
-#else /* !SC_ENABLE_MPI */
-
-/* constants */
-
-#define sc_MPI_SUCCESS             0
-#define sc_MPI_COMM_NULL           ((sc_MPI_Comm) 0x04000000)
-#define sc_MPI_COMM_WORLD          ((sc_MPI_Comm) 0x44000000)
-#define sc_MPI_COMM_SELF           ((sc_MPI_Comm) 0x44000001)
-
-#define sc_MPI_GROUP_NULL          ((sc_MPI_Group) 0x54000000)  /* TODO change val */
-#define sc_MPI_GROUP_EMPTY         ((sc_MPI_Group) 0x54000001)  /* TODO change val */
-
-#define sc_MPI_IDENT               (1)  /* TODO change val */
-#define sc_MPI_CONGRUENT           (2)  /* TODO change val */
-#define sc_MPI_SIMILAR             (3)  /* TODO change val */
-#define sc_MPI_UNEQUAL             (-1) /* TODO change val */
-
-#define sc_MPI_ANY_SOURCE          (-2)
-#define sc_MPI_ANY_TAG             (-1)
-#define sc_MPI_STATUS_IGNORE       (sc_MPI_Status *) 1
-#define sc_MPI_STATUSES_IGNORE     (sc_MPI_Status *) 1
-
-#define sc_MPI_REQUEST_NULL        ((sc_MPI_Request) 0x2c000000)
-
-#define sc_MPI_DATATYPE_NULL       ((sc_MPI_Datatype) 0x4c000000)
-
-#define sc_MPI_CHAR                ((sc_MPI_Datatype) 0x4c000101)
-#define sc_MPI_SIGNED_CHAR         ((sc_MPI_Datatype) 0x4c000118)
-#define sc_MPI_UNSIGNED_CHAR       ((sc_MPI_Datatype) 0x4c000102)
-#define sc_MPI_BYTE                ((sc_MPI_Datatype) 0x4c00010d)
-#define sc_MPI_SHORT               ((sc_MPI_Datatype) 0x4c000203)
-#define sc_MPI_UNSIGNED_SHORT      ((sc_MPI_Datatype) 0x4c000204)
-#define sc_MPI_INT                 ((sc_MPI_Datatype) 0x4c000405)
-#define sc_MPI_UNSIGNED            ((sc_MPI_Datatype) 0x4c000406)
-#define sc_MPI_LONG                ((sc_MPI_Datatype) 0x4c000407)
-#define sc_MPI_UNSIGNED_LONG       ((sc_MPI_Datatype) 0x4c000408)
-#define sc_MPI_LONG_LONG_INT       ((sc_MPI_Datatype) 0x4c000809)
-#define sc_MPI_UNSIGNED_LONG_LONG  ((sc_MPI_Datatype) 0x4c000409)
-#define sc_MPI_FLOAT               ((sc_MPI_Datatype) 0x4c00040a)
-#define sc_MPI_DOUBLE              ((sc_MPI_Datatype) 0x4c00080b)
-#define sc_MPI_LONG_DOUBLE         ((sc_MPI_Datatype) 0x4c000c0c)
-
-#define sc_MPI_MAX                 ((sc_MPI_Op) 0x58000001)
-#define sc_MPI_MIN                 ((sc_MPI_Op) 0x58000002)
-#define sc_MPI_SUM                 ((sc_MPI_Op) 0x58000003)
-#define sc_MPI_PROD                ((sc_MPI_Op) 0x58000004)
-#define sc_MPI_LAND                ((sc_MPI_Op) 0x58000005)
-#define sc_MPI_BAND                ((sc_MPI_Op) 0x58000006)
-#define sc_MPI_LOR                 ((sc_MPI_Op) 0x58000007)
-#define sc_MPI_BOR                 ((sc_MPI_Op) 0x58000008)
-#define sc_MPI_LXOR                ((sc_MPI_Op) 0x58000009)
-#define sc_MPI_BXOR                ((sc_MPI_Op) 0x5800000a)
-#define sc_MPI_MINLOC              ((sc_MPI_Op) 0x5800000b)
-#define sc_MPI_MAXLOC              ((sc_MPI_Op) 0x5800000c)
-#define sc_MPI_REPLACE             ((sc_MPI_Op) 0x5800000d)
-
-#define sc_MPI_UNDEFINED           (-32766)
-
-#define sc_MPI_ERR_GROUP           (-123456)    /* TODO change val */
-
-/* types */
-
-typedef int         sc_MPI_Comm;
-typedef int         sc_MPI_Group;
-typedef int         sc_MPI_Datatype;
-typedef int         sc_MPI_Op;
-typedef int         sc_MPI_Request;
-typedef struct sc_MPI_Status
-{
-  int                 count;
-  int                 cancelled;
-  int                 MPI_SOURCE;
-  int                 MPI_TAG;
-  int                 MPI_ERROR;
-}
-sc_MPI_Status;
-
-/* These functions are valid and functional for a single process. */
-
-int                 sc_MPI_Init (int *, char ***);
-/*                  sc_MPI_Init_thread is handled below */
-
-int                 sc_MPI_Finalize (void);
-int                 sc_MPI_Abort (sc_MPI_Comm, int)
-  __attribute__ ((noreturn));
-
-int                 sc_MPI_Comm_dup (sc_MPI_Comm, sc_MPI_Comm *);
-int                 sc_MPI_Comm_create (sc_MPI_Comm, sc_MPI_Group,
-                                        sc_MPI_Comm *);
-int                 sc_MPI_Comm_split (sc_MPI_Comm, int, int, sc_MPI_Comm *);
-int                 sc_MPI_Comm_free (sc_MPI_Comm *);
-int                 sc_MPI_Comm_size (sc_MPI_Comm, int *);
-int                 sc_MPI_Comm_rank (sc_MPI_Comm, int *);
-int                 sc_MPI_Comm_compare (sc_MPI_Comm, sc_MPI_Comm, int *);
-int                 sc_MPI_Comm_group (sc_MPI_Comm, sc_MPI_Group *);
-
-int                 sc_MPI_Group_free (sc_MPI_Group *);
-int                 sc_MPI_Group_size (sc_MPI_Group, int *);
-int                 sc_MPI_Group_rank (sc_MPI_Group, int *);
-int                 sc_MPI_Group_translate_ranks (sc_MPI_Group, int, int *,
-                                                  sc_MPI_Group, int *);
-int                 sc_MPI_Group_compare (sc_MPI_Group, sc_MPI_Group, int *);
-int                 sc_MPI_Group_union (sc_MPI_Group, sc_MPI_Group,
-                                        sc_MPI_Group *);
-int                 sc_MPI_Group_intersection (sc_MPI_Group, sc_MPI_Group,
-                                               sc_MPI_Group *);
-int                 sc_MPI_Group_difference (sc_MPI_Group, sc_MPI_Group,
-                                             sc_MPI_Group *);
-int                 sc_MPI_Group_incl (sc_MPI_Group, int, int *,
-                                       sc_MPI_Group *);
-int                 sc_MPI_Group_excl (sc_MPI_Group, int, int *,
-                                       sc_MPI_Group *);
-int                 sc_MPI_Group_range_incl (sc_MPI_Group, int,
-                                             int ranges[][3], sc_MPI_Group *);
-int                 sc_MPI_Group_range_excl (sc_MPI_Group, int,
-                                             int ranges[][3], sc_MPI_Group *);
-
-int                 sc_MPI_Barrier (sc_MPI_Comm);
-int                 sc_MPI_Bcast (void *, int, sc_MPI_Datatype, int,
-                                  sc_MPI_Comm);
-int                 sc_MPI_Gather (void *, int, sc_MPI_Datatype, void *, int,
-                                   sc_MPI_Datatype, int, sc_MPI_Comm);
-int                 sc_MPI_Gatherv (void *, int, sc_MPI_Datatype, void *,
-                                    int *, int *, sc_MPI_Datatype, int,
-                                    sc_MPI_Comm);
-int                 sc_MPI_Allgather (void *, int, sc_MPI_Datatype, void *,
-                                      int, sc_MPI_Datatype, sc_MPI_Comm);
-int                 sc_MPI_Allgatherv (void *, int, sc_MPI_Datatype, void *,
-                                       int *, int *, sc_MPI_Datatype,
-                                       sc_MPI_Comm);
-int                 sc_MPI_Alltoall (void *, int, sc_MPI_Datatype, void *,
-                                     int, sc_MPI_Datatype, sc_MPI_Comm);
-int                 sc_MPI_Reduce (void *, void *, int, sc_MPI_Datatype,
-                                   sc_MPI_Op, int, sc_MPI_Comm);
-int                 sc_MPI_Allreduce (void *, void *, int, sc_MPI_Datatype,
-                                      sc_MPI_Op, sc_MPI_Comm);
-int                 sc_MPI_Scan (void *, void *, int, sc_MPI_Datatype,
-                                 sc_MPI_Op, sc_MPI_Comm);
-int                 sc_MPI_Exscan (void *, void *, int, sc_MPI_Datatype,
-                                   sc_MPI_Op, sc_MPI_Comm);
-
-double              sc_MPI_Wtime (void);
-
-/* These functions will abort. */
-
-int                 sc_MPI_Recv (void *, int, sc_MPI_Datatype, int, int,
-                                 sc_MPI_Comm, sc_MPI_Status *);
-int                 sc_MPI_Irecv (void *, int, sc_MPI_Datatype, int, int,
-                                  sc_MPI_Comm, sc_MPI_Request *);
-int                 sc_MPI_Send (void *, int, sc_MPI_Datatype, int, int,
-                                 sc_MPI_Comm);
-int                 sc_MPI_Isend (void *, int, sc_MPI_Datatype, int, int,
-                                  sc_MPI_Comm, sc_MPI_Request *);
-int                 sc_MPI_Probe (int, int, sc_MPI_Comm, sc_MPI_Status *);
-int                 sc_MPI_Iprobe (int, int, sc_MPI_Comm, int *,
-                                   sc_MPI_Status *);
-int                 sc_MPI_Get_count (sc_MPI_Status *, sc_MPI_Datatype,
-                                      int *);
-
-/* These functions are only allowed to be called with NULL requests. */
-
-int                 sc_MPI_Wait (sc_MPI_Request *, sc_MPI_Status *);
-int                 sc_MPI_Waitsome (int, sc_MPI_Request *,
-                                     int *, int *, sc_MPI_Status *);
-int                 sc_MPI_Waitall (int, sc_MPI_Request *, sc_MPI_Status *);
-
-#endif /* !SC_ENABLE_MPI */
-
-#if defined SC_ENABLE_MPI && defined SC_ENABLE_MPITHREAD
-
-#define sc_MPI_THREAD_SINGLE       MPI_THREAD_SINGLE
-#define sc_MPI_THREAD_FUNNELED     MPI_THREAD_FUNNELED
-#define sc_MPI_THREAD_SERIALIZED   MPI_THREAD_SERIALIZED
-#define sc_MPI_THREAD_MULTIPLE     MPI_THREAD_MULTIPLE
-
-#define sc_MPI_Init_thread         MPI_Init_thread
-
-#else
-
-#define sc_MPI_THREAD_SINGLE       0
-#define sc_MPI_THREAD_FUNNELED     1
-#define sc_MPI_THREAD_SERIALIZED   2
-#define sc_MPI_THREAD_MULTIPLE     3
-
-int                 sc_MPI_Init_thread (int *argc, char ***argv,
-                                        int required, int *provided);
-
-#endif /* !(SC_ENABLE_MPI && SC_ENABLE_MPITHREAD) */
-
-/** Return the size of MPI data types.
- * \param [in] t    MPI data type.
- * \return          Returns the size in bytes.
- */
-size_t              sc_mpi_sizeof (sc_MPI_Datatype t);
-
-/** Compute ``sc_intranode_comm'' and ``sc_internode_comm''
- * communicators and attach them to the current communicator.  This split
- * takes \a processes_per_node passed by the user at face value: there is no
- * hardware checking to see if this is the true affinity.
- *
- * \param [in/out] comm                 MPI communicator
- * \param [in]     processes_per_node   the size of the intranode
- *                                      communicators. if < 1,
- *                                      sc will try to determine the correct
- *                                      shared memory communicators.
- */
-void                sc_mpi_comm_attach_node_comms (sc_MPI_Comm comm,
-                                                   int processes_per_node);
-
-/** Destroy ``sc_intranode_comm'' and ``sc_internode_comm''
- * communicators that are stored as attributes to communicator ``comm''.
- * This routine enforces a call to the destroy callback for these attributes.
- *
- * \param [in/out] comm                 MPI communicator
- */
-void                sc_mpi_comm_detach_node_comms (sc_MPI_Comm comm);
-
-/** Get the communicators computed in sc_mpi_comm_attach_node_comms() if they
- * exist; return sc_MPI_COMM_NULL otherwise.
- *
- * \param[in] comm            Super communicator
- * \param[out] intranode      intranode communicator
- * \param[out] internode      internode communicator
- */
-void                sc_mpi_comm_get_node_comms (sc_MPI_Comm comm,
-                                                sc_MPI_Comm * intranode,
-                                                sc_MPI_Comm * internode);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_MPI_H */
diff --git a/OctreeRefinement/include/sc_notify.h b/OctreeRefinement/include/sc_notify.h
deleted file mode 100644
index 9f5ddb9..0000000
--- a/OctreeRefinement/include/sc_notify.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_NOTIFY_H
-#define SC_NOTIFY_H
-
-#include <sc.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Collective call to notify a set of receiver ranks of current rank.
- * This version uses one call to sc_MPI_Allgather and one to sc_MPI_Allgatherv.
- * \see sc_notify
- * \param [in] receivers        Array of MPI ranks to inform.
- * \param [in] num_receivers    Count of ranks contained in receivers.
- * \param [in,out] senders      Array of at least size sc_MPI_Comm_size.
- *                              On output it contains the notifying ranks.
- * \param [out] num_senders     On output the number of notifying ranks.
- * \param [in] mpicomm          MPI communicator to use.
- * \return                      Aborts on MPI error or returns sc_MPI_SUCCESS.
- */
-int                 sc_notify_allgather (int *receivers, int num_receivers,
-                                         int *senders, int *num_senders,
-                                         sc_MPI_Comm mpicomm);
-
-/** Collective call to notify a set of receiver ranks of current rank.
- * \param [in] receivers        Sorted and unique array of MPI ranks to inform.
- * \param [in] num_receivers    Count of ranks contained in receivers.
- * \param [in,out] senders      Array of at least size sc_MPI_Comm_size.
- *                              On output it contains the notifying ranks.
- * \param [out] num_senders     On output the number of notifying ranks.
- * \param [in] mpicomm          MPI communicator to use.
- * \return                      Aborts on MPI error or returns sc_MPI_SUCCESS.
- */
-int                 sc_notify (int *receivers, int num_receivers,
-                               int *senders, int *num_senders,
-                               sc_MPI_Comm mpicomm);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_NOTIFY_H */
diff --git a/OctreeRefinement/include/sc_obstack.h b/OctreeRefinement/include/sc_obstack.h
deleted file mode 100644
index 1f85b7a..0000000
--- a/OctreeRefinement/include/sc_obstack.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_OBSTACK_H
-#define SC_OBSTACK_H
-
-#include <sc.h>
-
-#ifdef SC_PROVIDE_OBSTACK
-#ifdef _OBSTACK_H
-#error "obstack.h is included.  Please #include sc.h first."
-#endif
-#include "sc_builtin/obstack.h"
-#else
-#include <obstack.h>
-#endif
-
-#endif /* !SC_OBSTACK_H */
diff --git a/OctreeRefinement/include/sc_options.h b/OctreeRefinement/include/sc_options.h
deleted file mode 100644
index d3f0677..0000000
--- a/OctreeRefinement/include/sc_options.h
+++ /dev/null
@@ -1,341 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_OPTIONS_H
-#define SC_OPTIONS_H
-
-/** \file sc_options.h
- * Register and parse command line options and read/write configuration files.
- */
-
-#include <sc_containers.h>
-#include <sc_keyvalue.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** The options data structure is opaque. */
-typedef struct sc_options sc_options_t;
-
-/** This callback can be invoked during sc_options_parse.
- * \param [in] opt      Valid options data structure.
- *                      This is passed in case a file should be loaded.
- * \param [in] optarg   The option argument or NULL if there is none.
- * \param [in] data     User-defined data passed to sc_options_add_callback.
- * \return              Return 0 if successful, -1 on error.
- */
-typedef int         (*sc_options_callback_t) (sc_options_t * opt,
-                                              const char *optarg, void *data);
-
-/** Create an empty options structure.
- * \param [in] program_path   Name or path name of the program to display.
- *                            Usually argv[0] is fine.
- * \return                    A valid and empty options structure.
- */
-sc_options_t       *sc_options_new (const char *program_path);
-
-/** Destroy the options structure and all allocated structures contained.
- * The keyvalue structure passed into sc_keyvalue_add is destroyed.
- * \param [in,out] opt          This options structure is deallocated,
- *                              including all key-value containers referenced.
- * \deprecated                  This function may go away soon.
- */
-void                sc_options_destroy_deep (sc_options_t * opt);
-
-/** Destroy the options structure.
- * Whatever has been passed into sc_keyvalue_add is left alone.
- * \param [in,out] opt          This options structure is deallocated.
- */
-void                sc_options_destroy (sc_options_t * opt);
-
-/** Set the spacing for \ref sc_options_print_summary.
- * There are two values to be set: the spacing from the beginning of the
- * printed line to the type of the option variable, and from the beginning
- * of the printed line to the help string.
- * \param [in,out] opt          Valid options structure.
- * \param [in] space_type       Number of spaces to the type display, for
- *                              example \<INT\>, \<STRING\>, etc.
- *                              Setting this negative sets the default 20.
- * \param [in] space_help       Number of space to the help string.
- *                              Setting this negative sets the default 32.
- */
-void                sc_options_set_spacing (sc_options_t * opt,
-                                            int space_type, int space_help);
-
-/** Add a switch option. This option is used without option arguments.
- * Every use increments the variable by one.  Its initial value is 0.
- * Either opt_char or opt_name must be valid, that is, not '\0'/NULL.
- * \param [in,out] opt       A valid options structure.
- * \param [in] opt_char      Short option character, may be '\0'.
- * \param [in] opt_name      Long option name without initial dashes, may be NULL.
- * \param [in] variable      Address of the variable to store the option value.
- * \param [in] help_string   Help string for usage message, may be NULL.
- */
-void                sc_options_add_switch (sc_options_t * opt,
-                                           int opt_char,
-                                           const char *opt_name,
-                                           int *variable,
-                                           const char *help_string);
-
-/** Add a boolean option.
- * It can be initialized to true or false in the C sense.
- * Specifying it on the command line without argument sets the option to true.
- * The argument 0/f/F/n/N sets it to false (0).
- * The argument 1/t/T/y/Y sets it to true (nonzero).
- * \param [in,out] opt       A valid options structure.
- * \param [in] opt_char      Short option character, may be '\0'.
- * \param [in] opt_name      Long option name without initial dashes, may be NULL.
- * \param [in] variable      Address of the variable to store the option value.
- * \param [in] init_value    Initial value to set the option, read as true or false.
- * \param [in] help_string   Help string for usage message, may be NULL.
- */
-void                sc_options_add_bool (sc_options_t * opt,
-                                         int opt_char,
-                                         const char *opt_name,
-                                         int *variable, int init_value,
-                                         const char *help_string);
-
-/** Add an option that takes an integer argument.
- * \param [in,out] opt       A valid options structure.
- * \param [in] opt_char      Short option character, may be '\0'.
- * \param [in] opt_name      Long option name without initial dashes, may be NULL.
- * \param [in] variable      Address of the variable to store the option value.
- * \param [in] init_value    The initial value of the option variable.
- * \param [in] help_string   Help string for usage message, may be NULL.
- */
-void                sc_options_add_int (sc_options_t * opt,
-                                        int opt_char,
-                                        const char *opt_name,
-                                        int *variable, int init_value,
-                                        const char *help_string);
-
-/** Add an option that takes a size_t argument.
- * The value of the size_t variable must not be greater than LLONG_MAX.
- * \param [in,out] opt       A valid options structure.
- * \param [in] opt_char      Short option character, may be '\0'.
- * \param [in] opt_name      Long option name without initial dashes, may be NULL.
- * \param [in] variable      Address of the variable to store the option value.
- * \param [in] init_value    The initial value of the option variable.
- * \param [in] help_string   Help string for usage message, may be NULL.
- */
-void                sc_options_add_size_t (sc_options_t * opt,
-                                           int opt_char,
-                                           const char *opt_name,
-                                           size_t * variable,
-                                           size_t init_value,
-                                           const char *help_string);
-
-/** Add an option that takes a double argument.
- * The double must be in the legal range.  "inf" and "nan" are legal too.
- * \param [in,out] opt       A valid options structure.
- * \param [in] opt_char      Short option character, may be '\0'.
- * \param [in] opt_name      Long option name without initial dashes, may be NULL.
- * \param [in] variable      Address of the variable to store the option value.
- * \param [in] init_value    The initial value of the option variable.
- * \param [in] help_string   Help string for usage message, may be NULL.
- */
-void                sc_options_add_double (sc_options_t * opt,
-                                           int opt_char,
-                                           const char *opt_name,
-                                           double *variable,
-                                           double init_value,
-                                           const char *help_string);
-
-/** Add a string option.
- * \param [in,out] opt       A valid options structure.
- * \param [in] opt_char      Short option character, may be '\0'.
- * \param [in] opt_name      Long option name without initial dashes, may be NULL.
- * \param [in] variable      Address of the variable to store the option value.
- * \param [in] init_value    This default value of the option may be NULL.
- *                           If not NULL, the value is copied to internal storage.
- * \param [in] help_string   Help string for usage message, may be NULL.
- */
-void                sc_options_add_string (sc_options_t * opt,
-                                           int opt_char,
-                                           const char *opt_name,
-                                           const char **variable,
-                                           const char *init_value,
-                                           const char *help_string);
-
-/** Add an option to read in a file in .ini format.
- * The argument to this option must be a filename.
- * On parsing the specified file is read to set known option variables.
- * It does not have an associated option variable itself.
- * \param [in,out] opt       A valid options structure.
- * \param [in] opt_char      Short option character, may be '\0'.
- * \param [in] opt_name      Long option name without initial dashes, may be NULL.
- * \param [in] help_string   Help string for usage message, may be NULL.
- */
-void                sc_options_add_inifile (sc_options_t * opt,
-                                            int opt_char,
-                                            const char *opt_name,
-                                            const char *help_string);
-
-/** Add an option that calls a user-defined function when parsed.
- * The callback function should be implemented to allow multiple calls.
- * The option does not have an associated variable.
- * The callback can be used to set multiple option variables in bulk that would
- * otherwise require an inconvenient number of individual options.
- * This is, however, currently not possible for options with
- * string values or key-value pairs due to the way the API is set up.
- * This function should not have non-option related side effects.
- * This option is not loaded from or saved to files.
- * \param [in,out] opt      A valid options structure.
- * \param [in] opt_char     Short option character, may be '\0'.
- * \param [in] opt_name     Long option name without initial dashes, may be NULL.
- * \param [in] has_arg      Specify if the option needs an option argument.
- * \param [in] fn           Function to call when this option is encountered.
- * \param [in] data         User-defined data passed to the callback.
- * \param [in] help_string  Help string for usage message, may be NULL.
- */
-void                sc_options_add_callback (sc_options_t * opt,
-                                             int opt_char,
-                                             const char *opt_name,
-                                             int has_arg,
-                                             sc_options_callback_t fn,
-                                             void *data,
-                                             const char *help_string);
-
-/** Add an option that takes string keys into a lookup table of integers.
- * On calling this function, it must be certain that the initial value exists.
- * \param [in] opt          Initialized options structure.
- * \param [in] opt_char     Option character for command line, or 0.
- * \param [in] opt_name     Name of the long option, or NULL.
- * \param [in] variable     Address of an existing integer that holds
- *                          the value of this option parameter.
- * \param [in] init_value   The key that is looked up for the initial value.
- *                          It must be certain that the key exists
- *                          and its value is of type integer.
- * \param [in] keyvalue     A valid key-value structure where the values
- *                          must be integers.  If a key is asked for that
- *                          does not exist, we will produce an option error.
- *                          This structure must stay alive as long as opt.
- * \param [in] help_string  Instructive one-line string to explain the option.
- */
-void                sc_options_add_keyvalue (sc_options_t * opt,
-                                             int opt_char,
-                                             const char *opt_name,
-                                             int *variable,
-                                             const char *init_value,
-                                             sc_keyvalue_t * keyvalue,
-                                             const char *help_string);
-
-/** Copy one set of options to another as a subset, with a prefix.
- * \param [in,out] opt  A set of options.
- * \param [in]  subopt  Another set of options to be copied.
- * \param [in]  prefix  The prefix to add to option names as they are copied.
- *                      If an option has a long name "name" in subopt, its
- *                      name in opt is "prefix:name"; if an option only has a
- *                      character 'c' in subopt, its name in opt is
- *                      "prefix:-c".
- */
-void                sc_options_add_suboptions (sc_options_t * opt,
-                                               sc_options_t * subopt,
-                                               const char *prefix);
-
-/** Print a usage message.
- * This function uses the SC_LC_GLOBAL log category.
- * That means the default action is to print only on rank 0.
- * Applications can change that by providing a user-defined log handler.
- * \param [in] package_id       Registered package id or -1.
- * \param [in] log_priority     Log priority for output according to sc.h.
- * \param [in] opt              The option structure.
- * \param [in] arg_usage        If not NULL, an \<ARGUMENTS\> string is appended
- *                              to the usage line.  If the string is non-empty,
- *                              it will be printed after the option summary
- *                              and an "ARGUMENTS:\n" title line.  Line breaks
- *                              are identified by strtok(3) and honored.
- */
-void                sc_options_print_usage (int package_id, int log_priority,
-                                            sc_options_t * opt,
-                                            const char *arg_usage);
-
-/** Print a summary of all option values.
- * Prints the title "Options:" and a line for every option,
- * then the title "Arguments:" and a line for every argument.
- * This function uses the SC_LC_GLOBAL log category.
- * That means the default action is to print only on rank 0.
- * Applications can change that by providing a user-defined log handler.
- * \param [in] package_id       Registered package id or -1.
- * \param [in] log_priority     Log priority for output according to sc.h.
- * \param [in] opt              The option structure.
- */
-void                sc_options_print_summary (int package_id,
-                                              int log_priority,
-                                              sc_options_t * opt);
-
-/** Load a file in .ini format and updates entries found under [Options].
- * An option whose name contains a colon such as "prefix:basename" will be
- * updated by a "basename =" entry in a [prefix] section.
- * \param [in] package_id       Registered package id or -1.
- * \param [in] err_priority     Error log priority according to sc.h.
- * \param [in] opt              The option structure.
- * \param [in] inifile          Filename of the ini file to load.
- * \return                      Returns 0 on success, -1 on failure.
- */
-int                 sc_options_load (int package_id, int err_priority,
-                                     sc_options_t * opt, const char *inifile);
-
-/** Save all options and arguments to a file in .ini format.
- * This function must only be called after successful option parsing.
- * This function should only be called on rank 0.
- * This function will log errors with category SC_LC_GLOBAL.
- * An options whose name contains a colon such as "prefix:basename" will be
- * written in a section titled [prefix] as "basename =".
- * \param [in] package_id       Registered package id or -1.
- * \param [in] err_priority     Error log priority according to sc.h.
- * \param [in] opt              The option structure.
- * \param [in] inifile          Filename of the ini file to save.
- * \return                      Returns 0 on success, -1 on failure.
- */
-int                 sc_options_save (int package_id, int err_priority,
-                                     sc_options_t * opt, const char *inifile);
-
-/** Parse command line options.
- * \param [in] package_id       Registered package id or -1.
- * \param [in] err_priority     Error log priority according to sc.h.
- * \param [in] opt              The option structure.
- * \param [in] argc             Length of argument list.
- * \param [in,out] argv         Argument list may be permuted.
- * \return                      Returns -1 on an invalid option, otherwise
- *                              the position of the first non-option argument.
- */
-int                 sc_options_parse (int package_id, int err_priority,
-                                      sc_options_t * opt, int argc,
-                                      char **argv);
-
-/** Load a file in .ini format and updates entries found under [Arguments].
- * There needs to be a key Arguments.count specifing the number.
- * Then as many integer keys starting with 0 need to be present.
- * \param [in] package_id       Registered package id or -1.
- * \param [in] err_priority     Error log priority according to sc.h.
- * \param [in] opt              The args are stored in this option structure.
- * \param [in] inifile          Filename of the ini file to load.
- * \return                      Returns 0 on success, -1 on failure.
- */
-int                 sc_options_load_args (int package_id, int err_priority,
-                                          sc_options_t * opt,
-                                          const char *inifile);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_OPTIONS_H */
diff --git a/OctreeRefinement/include/sc_private.h b/OctreeRefinement/include/sc_private.h
deleted file mode 100644
index de9bdcf..0000000
--- a/OctreeRefinement/include/sc_private.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-/** \file sc_private.h
- *
- * Support for calls between different parts of the sc library.
- * This is not meant for use from other packages or applications.
- */
-
-#ifndef SC_PRIVATE_H
-#define SC_PRIVATE_H
-
-#include <sc.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Add to the per-package variable about active reference counters.
- * This function is thread safe; it uses per-package locking internally
- * \param [in] package_id       The id of a registered package or -1.
- * \param [in] toadd            This is added to the package's internal
- *                              variable that counts active rcs.
- *                              We assert that the new count does not
- *                              drop below zero.
- */
-void                sc_package_rc_count_add (int package_id, int toadd);
-
-SC_EXTERN_C_END;
-
-#endif /* SC_PRIVATE_H */
diff --git a/OctreeRefinement/include/sc_ranges.h b/OctreeRefinement/include/sc_ranges.h
deleted file mode 100644
index 085a3cf..0000000
--- a/OctreeRefinement/include/sc_ranges.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_RANGES_H
-#define SC_RANGES_H
-
-#include <sc.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Compute the optimal ranges of processors to talk to.
- *
- * \param [in] package_id   Registered package id or -1.
- * \param [in] num_procs    Number of processors processed.
- * \param [in] procs        Array [num_procs] interpreted as booleans.
- *                          Nonzero entries need to be talked to.
- * \param [in] rank         The id of the calling process.
- *                          Will be excluded from the ranges.
- * \param [in] first_peer   First processor to be considered.
- * \param [in] last_peer    Last processor to be considered (inclusive).
- * \param [in] num_ranges   The maximum number of ranges to fill.
- * \param [in,out] ranges   Array [2 * num_ranges] that will be filled
- *                          with beginning and ending procs (inclusive)
- *                          that represent each range.  Values of -1
- *                          indicate that the range is not needed.
- * \return                  Returns the number of filled ranges.
- */
-int                 sc_ranges_compute (int package_id, int num_procs,
-                                       const int *procs, int rank,
-                                       int first_peer, int last_peer,
-                                       int num_ranges, int *ranges);
-
-/** Compute the globally optimal ranges of processors.
- *
- * \param [in] package_id   Registered package id or -1.
- * \param [in] mpicomm      MPI Communicator for Allreduce and Allgather.
- * \param [in] procs        Same as in sc_ranges_compute ().
- * \param [in,out] inout1
- *     On input, first_peer as in sc_ranges_compute ().
- *     On output, global maximum of peer counts.
- * \param [in,out] inout2
- *     On input, last_peer as in sc_ranges_compute ().
- *     On output, global maximum number of ranges.
- * \param [in] num_ranges   The maximum number of ranges to fill.
- * \param [in,out] ranges   Array [2 * num_ranges] that will be filled
- *                          with beginning and ending procs (inclusive)
- *                          that represent each local range.  Values of -1
- *                          indicate that the range is not needed.
- * \param [out] global_ranges
- *     If not NULL, will be allocated and filled with everybody's ranges.
- *     Size will be 2 * inout2 * num_procs.  Must be freed with SC_FREE ().
- * \return                  Returns the number of locally filled ranges.
- */
-int                 sc_ranges_adaptive (int package_id, sc_MPI_Comm mpicomm,
-                                        const int *procs,
-                                        int *inout1, int *inout2,
-                                        int num_ranges, int *ranges,
-                                        int **global_ranges);
-
-/** Determine an array of receivers and an array of senders from ranges.
- * This function is intended for compatibility and debugging only.
- * In particular, sc_ranges_adaptive may include non-receiving processors.
- * It is generally more efficient to use sc_notify instead of sc_ranges.
- *
- * \param [in] num_procs    The number of parallel processors (aka mpisize).
- * \param [in] rank         Number of this processors (aka mpirank).
- *                          Rank is excluded from receiver and sender output.
- * \param [in] max_ranges   Global maximum of filled range windows as
- *                          returned in inout2 by sc_ranges_adaptive.
- * \param [in] global_ranges    All processor ranges from sc_ranges_adaptive.
- * \param [out] num_receivers   Number of receiver ranks.  Greater/equal to
- *                              number of nonzero procs in sc_ranges_compute.
- * \param [in,out] receiver_ranks   Array of at least mpisize for output.
- * \param [out] num_senders         Number of senders to this processor.
- * \paarm [in,out] sender_ranks     Array of at least mpisize for output.
- */
-void                sc_ranges_decode (int num_procs, int rank,
-                                      int max_ranges,
-                                      const int *global_ranges,
-                                      int *num_receivers, int *receiver_ranks,
-                                      int *num_senders, int *sender_ranks);
-
-/** Compute global statistical information on the ranges.
- *
- * \param [in] package_id       Registered package id or -1.
- * \param [in] log_priority     Priority to use for logging.
- */
-void                sc_ranges_statistics (int package_id, int log_priority,
-                                          sc_MPI_Comm mpicomm, int num_procs,
-                                          const int *procs, int rank,
-                                          int num_ranges, int *ranges);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_RANGES_H */
diff --git a/OctreeRefinement/include/sc_reduce.h b/OctreeRefinement/include/sc_reduce.h
deleted file mode 100644
index 22b94c2..0000000
--- a/OctreeRefinement/include/sc_reduce.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_REDUCE_H
-#define SC_REDUCE_H
-
-#include <sc.h>
-
-/* highest level that uses all-to-all instead of recursion */
-#ifndef SC_REDUCE_ALLTOALL_LEVEL
-#define SC_REDUCE_ALLTOALL_LEVEL        3
-#endif
-
-SC_EXTERN_C_BEGIN;
-
-typedef void        (*sc_reduce_t) (void *sendbuf, void *recvbuf,
-                                    int sendcount, sc_MPI_Datatype sendtype);
-
-/** Custom allreduce operation.
- */
-int                 sc_allreduce_custom (void *sendbuf, void *recvbuf,
-                                         int sendcount,
-                                         sc_MPI_Datatype sendtype,
-                                         sc_reduce_t reduce_fn,
-                                         sc_MPI_Comm mpicomm);
-
-/** Custom reduce operation.
- * \param [in] target   The MPI rank that obtains the result.
- */
-int                 sc_reduce_custom (void *sendbuf, void *recvbuf,
-                                      int sendcount, sc_MPI_Datatype sendtype,
-                                      sc_reduce_t reduce_fn,
-                                      int target, sc_MPI_Comm mpicomm);
-
-/** Drop-in MPI_Allreduce replacement.
- */
-int                 sc_allreduce (void *sendbuf, void *recvbuf, int sendcount,
-                                  sc_MPI_Datatype sendtype,
-                                  sc_MPI_Op operation, sc_MPI_Comm mpicomm);
-
-/** Drop-in MPI_Reduce replacement.
- * \param [in] target   The MPI rank that obtains the result.
- */
-int                 sc_reduce (void *sendbuf, void *recvbuf, int sendcount,
-                               sc_MPI_Datatype sendtype, sc_MPI_Op operation,
-                               int target, sc_MPI_Comm mpicomm);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_REDUCE_H */
diff --git a/OctreeRefinement/include/sc_refcount.h b/OctreeRefinement/include/sc_refcount.h
deleted file mode 100644
index a289b18..0000000
--- a/OctreeRefinement/include/sc_refcount.h
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-/** \file sc_refcount.h
- *
- * Provide reference counting facilities.
- * The functions in this file can be used for multiple purposes.
- * The current setup is not so much targeted at garbage collection but rather
- * intended for debugging and verification.
- */
-
-#ifndef SC_REFCOUNT_H
-#define SC_REFCOUNT_H
-
-#include <sc.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** The refcount structure is declared in public so its size is known.
- * Its members should really never be accessed directly.
- */
-typedef struct sc_refcount
-{
-  /** The sc package that uses this reference counter. */
-  int                 package_id;
-
-  /** The reference count is always positive for a valid counter. */
-  int                 refcount;
-}
-sc_refcount_t;
-
-/** Initialize a well-defined but unusable reference counter.
- * Specifically, we set its package identifier and reference count to -1.
- * To make this reference counter usable, call \ref sc_refcount_init.
- * \param [out] rc          This reference counter is defined as invalid.
- *                          It will return false on both
- *                          \ref sc_refcount_is_active and
- *                          \ref sc_refcount_is_last.
- *                          It can be made valid by calling
- *                          \ref sc_refcount_init.
- *                          No other functions must be called on it.
- */
-void                sc_refcount_init_invalid (sc_refcount_t * rc);
-
-/** Initialize a reference counter to 1.
- * It is legal if its status prior to this call is undefined.
- * \param [out] rc          This reference counter is initialized to one.
- *                          The object's contents may be undefined on input.
- * \param [in] package_id   Either -1 or a package registered to libsc.
- */
-void                sc_refcount_init (sc_refcount_t * rc, int package_id);
-
-/** Create a new reference counter with count initialized to 1.
- * Equivalent to calling \ref sc_refcount_init on a newly allocated rc object.
- * \param [in] package_id   Either -1 or a package registered to libsc.
- * \return                  A reference counter with count one.
- */
-sc_refcount_t      *sc_refcount_new (int package_id);
-
-/** Destroy a reference counter.
- * It must have been counted down to zero before, thus reached an inactive state.
- * \param [in,out] rc       This reference counter must have reached count zero.
- */
-void                sc_refcount_destroy (sc_refcount_t * rc);
-
-/** Increase a reference counter.
- * The counter must be active, that is, have a value greater than zero.
- * \param [in,out] rc       This reference counter must be valid (greater zero).
- *                          Its count is increased by one.
- */
-void                sc_refcount_ref (sc_refcount_t * rc);
-
-/** Decrease the reference counter and notify when it reaches zero.
- * The count must be greater zero on input.  If the reference count reaches
- * zero, which is indicated by the return value, the counter may not be used
- * furter with \ref sc_refcount_ref or \see sc_refcount_unref.  It is legal,
- * however, to reactivate it later by calling \see sc_refcount_init.
- * \param [in,out] rc       This reference counter must be valid (greater zero).
- *                          Its count is decreased by one.
- * \return          True if the count has reached zero, false otherwise.
- */
-int                 sc_refcount_unref (sc_refcount_t * rc);
-
-/** Check whether a reference counter has a positive value.
- * This means that the reference counter is in use and corresponds to a live object.
- * \param [in] rc   A reference counter.
- * \return          True if the count is greater zero, false otherwise.
- */
-int                 sc_refcount_is_active (const sc_refcount_t * rc);
-
-/** Check whether a reference counter has value one.
- * This means that this counter is the last of its kind, which we may optimize for.
- * \param [in] rc   A reference counter.
- * \return          True if the count is exactly one.
- */
-int                 sc_refcount_is_last (const sc_refcount_t * rc);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_REFCOUNT_H */
diff --git a/OctreeRefinement/include/sc_search.h b/OctreeRefinement/include/sc_search.h
deleted file mode 100644
index 451a889..0000000
--- a/OctreeRefinement/include/sc_search.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_SEARCH_H
-#define SC_SEARCH_H
-
-#include <sc.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Find the branch of a tree that is biased towards a target.
- * We assume a binary tree of depth maxlevel and 0 <= target < 2**maxlevel.
- * We search the branch towards the target on 0 <= level <= maxlevel.
- * The branch number on level is specified by 0 <= interval < 2**level.
- *
- * \return          Branch position with 0 <= position <= 2**maxlevel.
- */
-int                 sc_search_bias (int maxlevel, int level,
-                                    int interval, int target);
-
-/** Find lowest position k in a sorted array such that array[k] >= target.
- * \param [in]  target  The target lower bound to binary search for.
- * \param [in]  array   The 64bit integer array to binary search in.
- * \param [in]  nmemb   The number of int64_t's in the array.
- * \param [in]  guess   Initial array position to look at.
- * \return  Returns the matching position
- *          or -1 if array[size-1] < target or if size == 0.
- */
-ssize_t             sc_search_lower_bound64 (int64_t target,
-                                             const int64_t * array,
-                                             size_t nmemb, size_t guess);
-
-/** Search position k in sorted array with array[k] <= target < array[k + 1].
- * This function is modeled after the libc bsearch function.
- * \param [in]  key     The target to find in the array range.
- * \param [in]  base    The array to binary search in.
- * \param [in]  nmemb   Number of entries in the array MINUS ONE.
- *                      Thus the array always contains at least one element.
- * \param [in]  size    Size of one entry in the array in bytes.
- * \param [in]  compar  Comparison function to return < 0 for less than,
- *                      0 for equal, and > 0 for greater between the arguments.
- * \return              The matching array position if found, or nmemb if not,
- *                      i.e., if target < array[0] or target >= array[nmemb].
- */
-size_t              sc_bsearch_range (const void *key, const void *base,
-                                      size_t nmemb, size_t size,
-                                      int (*compar) (const void *,
-                                                     const void *));
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_SEARCH_H */
diff --git a/OctreeRefinement/include/sc_shmem.h b/OctreeRefinement/include/sc_shmem.h
deleted file mode 100644
index fbc578a..0000000
--- a/OctreeRefinement/include/sc_shmem.h
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_SHMEM_H
-#define SC_SHMEM_H
-
-#include <sc.h>
-#include <sc_mpi.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** \file sc_shmem.h */
-
-/* sc_shmem: an interface for arrays that are redundant on each mpi
- * process */
-
-typedef enum
-{
-  SC_SHMEM_BASIC = 0,      /**< use allgathers, then sum to simulate scan */
-  SC_SHMEM_PRESCAN,        /**< mpi_scan, then allgather */
-#if defined(SC_ENABLE_MPIWINSHARED)
-  SC_SHMEM_WINDOW,         /**< MPI_Win (requires MPI 3) */
-  SC_SHMEM_WINDOW_PRESCAN, /**< mpi_scan, then MPI_Win (requires MPI 3) */
-#endif
-#if defined(__bgq__)
-  SC_SHMEM_BGQ,            /**< raw pointer passing: only works for
-                                shared-heap environments */
-  SC_SHMEM_BGQ_PRESCAN,    /**< mpi_scan, then raw pointer passing: only works
-                                for shared-heap environments */
-#endif
-  SC_SHMEM_NUM_TYPES,
-  SC_SHMEM_NOT_SET
-}
-sc_shmem_type_t;
-
-extern const char  *sc_shmem_type_to_string[SC_SHMEM_NUM_TYPES];
-
-extern sc_shmem_type_t sc_shmem_default_type;
-
-/* ALL sc_shmem routines should be considered collective: called on
- * every process in the communicator */
-
-/** Set the type of shared memory arrays to use on this mpi communicator.
- *
- * \param[in,out] comm        the mpi communicator
- * \param[in]     type        the type of shmem array behavior.
- */
-void                sc_shmem_set_type (sc_MPI_Comm comm,
-                                       sc_shmem_type_t type);
-
-/** Get the type of shared memory arrays to use on this mpi communicator.
- *
- * \param[in] comm        the mpi communicator
- *
- * \return the type of shmem array used on this communicator.
- */
-sc_shmem_type_t     sc_shmem_get_type (sc_MPI_Comm comm);
-
-/** Allocate a shmem array: an array that is redundant on every process.
- *
- * \param[in] package         package requesting memory
- * \param[in] elem_size       the size of each element in the array
- * \param[in] elem_count      the number of elements in the array
- * \param[in] comm            the mpi communicator
- *
- * \return a shared memory array
- * */
-void               *sc_shmem_malloc (int package, size_t elem_size,
-                                     size_t elem_count, sc_MPI_Comm comm);
-
-#define SC_SHMEM_ALLOC(t,e,c) (t *) sc_shmem_malloc(sc_package_id,sizeof(t),e,c)
-
-/** Destroy a shmem array created with sc_shmem_alloc()
- *
- * \param[in] package         package freeing memory
- * \param[in] array           array to be freed
- * \param[in] comm            the mpi communicator
- *
- * */
-void                sc_shmem_free (int package, void *array,
-                                   sc_MPI_Comm comm);
-
-#define SC_SHMEM_FREE(a,c) sc_shmem_free (sc_package_id,a,c)
-
-/** Start a write window for a shared array.
- *
- * \param[in] array           array that will be changed.
- * \param[in] comm            the mpi communicator
- *
- * \return 1 if I have write access, 0 if my proc should not change the
- * array.
- */
-int                 sc_shmem_write_start (void *array, sc_MPI_Comm comm);
-
-/** End a write window for a shared array.
- *
- * \param[in] array           array that has changed
- * \param[in] comm            the mpi communicator
- */
-void                sc_shmem_write_end (void *array, sc_MPI_Comm comm);
-
-/** Copy a shmem array.
- *
- * \param[out]  destarray     array to write to
- * \param[in]   srcarray      array to write from
- * \param[in]   bytes         number of bytes to write
- * \param[in]   comm          the mpi communicator
- */
-void                sc_shmem_memcpy (void *destarray, void *srcarray,
-                                     size_t bytes, sc_MPI_Comm comm);
-
-/** Fill a shmem array with an allgather.
- *
- * \param[in] sendbuf         the source from this process
- * \param[in] sendcount       the number of items to allgather
- * \param[in] sendtype        the type of items to allgather
- * \param[in,out] recvbuf     the destination shmem array
- * \param[in] recvcount       the number of items to allgather
- * \param[in] recvtype        the type of items to allgather
- * \param[in] comm            the mpi communicator
- */
-void                sc_shmem_allgather (void *sendbuf, int sendcount,
-                                        sc_MPI_Datatype sendtype,
-                                        void *recvbuf, int recvcount,
-                                        sc_MPI_Datatype recvtype,
-                                        sc_MPI_Comm comm);
-
-/** Fill a shmem array with an allgather of the prefix op over all processes.
- *
- * The return array will be
- * (0, send0, send0 op send1, send0 op send1 op send2, ...)
- *
- * Note that the first entry of \a recvbuf will be set to 0 using memset: if
- * this is not the desired value for the first entry of the array, the user
- * can change it *after* calling sc_shmem_prefix.
- *
- * \param[in] sendbuf         the source from this process
- * \param[in,out] recvbuf     the destination shmem array
- * \param[in] count           the number of items to allgather
- * \param[in] type            the type of items to allgather
- * \param[in] op              the operation to prefix (e.g., sc_MPI_SUM)
- * \param[in] comm            the mpi communicator
- */
-void                sc_shmem_prefix (void *sendbuf, void *recvbuf,
-                                     int count, sc_MPI_Datatype type,
-                                     sc_MPI_Op op, sc_MPI_Comm comm);
-SC_EXTERN_C_END;
-
-#endif /* SC_SHMEM_H */
diff --git a/OctreeRefinement/include/sc_sort.h b/OctreeRefinement/include/sc_sort.h
deleted file mode 100644
index f29bbca..0000000
--- a/OctreeRefinement/include/sc_sort.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_SORT_H
-#define SC_SORT_H
-
-#include <sc.h>
-
-SC_EXTERN_C_BEGIN;
-
-/** Sort a distributed set of values in parallel.
- * This algorithm uses bitonic sort between processors and qsort locally.
- * The partition of the data can be arbitrary and is not changed.
- * \param [in] mpicomm          Communicator to use.
- * \param [in] base             Pointer to the local subset of data.
- * \param [in] nmemb            Array of mpisize counts of local data.
- * \param [in] size             Size in bytes of each data value.
- * \param [in] compar           Comparison function to use.
- */
-void                sc_psort (sc_MPI_Comm mpicomm, void *base,
-                              size_t * nmemb, size_t size,
-                              int (*compar) (const void *, const void *));
-
-SC_EXTERN_C_END;
-
-#endif /* SC_SORT_H */
diff --git a/OctreeRefinement/include/sc_statistics.h b/OctreeRefinement/include/sc_statistics.h
deleted file mode 100644
index a6b2a41..0000000
--- a/OctreeRefinement/include/sc_statistics.h
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_STATISTICS_H
-#define SC_STATISTICS_H
-
-#include <sc.h>
-#include <sc_keyvalue.h>
-
-SC_EXTERN_C_BEGIN;
-
-/* sc_statinfo_t stores information for one random variable */
-typedef struct sc_statinfo
-{
-  int                 dirty;    /* only update stats if this is true */
-  long                count;    /* inout, global count is 52bit accurate */
-  double              sum_values, sum_squares, min, max;        /* inout */
-  int                 min_at_rank, max_at_rank; /* out */
-  double              average, variance, standev;       /* out */
-  double              variance_mean, standev_mean;      /* out */
-  const char         *variable; /* name of the variable for output */
-}
-sc_statinfo_t;
-
-/* sc_statistics_t allows dynamically adding random variables */
-typedef struct sc_stats
-{
-  sc_MPI_Comm         mpicomm;
-  sc_keyvalue_t      *kv;
-  sc_array_t         *sarray;
-}
-sc_statistics_t;
-
-/**
- * Populate a sc_statinfo_t structure assuming count=1 and mark it dirty.
- */
-void                sc_stats_set1 (sc_statinfo_t * stats,
-                                   double value, const char *variable);
-
-/**
- * Initialize a sc_statinfo_t structure assuming count=0 and mark it dirty.
- * This is useful if \a stats will be used to accumulate instances locally
- * before global statistics are computed.
- */
-void                sc_stats_init (sc_statinfo_t * stats,
-                                   const char *variable);
-
-/**
- * Add an instance of the random variable.
- */
-void                sc_stats_accumulate (sc_statinfo_t * stats, double value);
-
-/**
- * Compute global average and standard deviation.
- * Only updates dirty variables. Then removes the dirty flag.
- * \param [in]     mpicomm   MPI communicator to use.
- * \param [in]     nvars     Number of variables to be examined.
- * \param [in,out] stats     Set of statisitcs for each variable.
- * On input, set the following fields for each variable separately.
- *    count         Number of values for each process.
- *    sum_values    Sum of values for each process.
- *    sum_squares   Sum of squares for each process.
- *    min, max      Minimum and maximum of values for each process.
- *    variable      String describing the variable, or NULL.
- * On output, the fields have the following meaning.
- *    count                        Global number of values.
- *    sum_values                   Global sum of values.
- *    sum_squares                  Global sum of squares.
- *    min, max                     Global minimum and maximum values.
- *    min_at_rank, max_at_rank     The ranks that attain min and max.
- *    average, variance, standev   Global statistical measures.
- *    variance_mean, standev_mean  Statistical measures of the mean.
- */
-void                sc_stats_compute (sc_MPI_Comm mpicomm, int nvars,
-                                      sc_statinfo_t * stats);
-
-/**
- * Version of sc_statistics_statistics that assumes count=1.
- * On input, the field sum_values needs to be set to the value
- * and the field variable must contain a valid string or NULL.
- * Only updates dirty variables. Then removes the dirty flag.
- */
-void                sc_stats_compute1 (sc_MPI_Comm mpicomm, int nvars,
-                                       sc_statinfo_t * stats);
-
-/**
- * Print measured statistics.
- * This function uses the SC_LC_GLOBAL log category.
- * That means the default action is to print only on rank 0.
- * Applications can change that by providing a user-defined log handler.
- * \param [in] package_id       Registered package id or -1.
- * \param [in] log_priority     Log priority for output according to sc.h.
- * \param [in] full             Print full information for every variable.
- * \param [in] summary          Print summary information all on 1 line.
- */
-void                sc_stats_print (int package_id, int log_priority,
-                                    int nvars, sc_statinfo_t * stats,
-                                    int full, int summary);
-
-/** Create a new statistics structure that can grow dynamically.
- */
-sc_statistics_t    *sc_statistics_new (sc_MPI_Comm mpicomm);
-void                sc_statistics_destroy (sc_statistics_t * stats);
-
-/** Register a statistics variable by name and set its value to 0.
- * This variable must not exist already.
- */
-void                sc_statistics_add (sc_statistics_t * stats,
-                                       const char *name);
-
-/** Register a statistics variable by name and set its count to 0.
- * This variable must not exist already.
- */
-void                sc_statistics_add_empty (sc_statistics_t * stats,
-                                             const char *name);
-
-/** Returns true if the stats include a variable with the given name */
-int                 sc_statistics_has (sc_statistics_t * stats,
-                                       const char *name);
-/** Set the value of a statistics variable, see sc_stats_set1.
- * The variable must previously be added with sc_statistics_add.
- * This assumes count=1 as in the sc_stats_set1 function above.
- */
-void                sc_statistics_set (sc_statistics_t * stats,
-                                       const char *name, double value);
-
-/** Add an instance of a statistics variable, see sc_stats_accumulate
- * The variable must previously be added with sc_statistics_add_empty.
- */
-void                sc_statistics_accumulate (sc_statistics_t * stats,
-                                              const char *name, double value);
-
-/** Compute statistics for all variables, see sc_stats_compute.
- */
-void                sc_statistics_compute (sc_statistics_t * stats);
-
-/** Print all statistics variables, see sc_stats_print.
- */
-void                sc_statistics_print (sc_statistics_t * stats,
-                                         int package_id, int log_priority,
-                                         int full, int summary);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_STATISTICS_H */
diff --git a/OctreeRefinement/include/sc_string.h b/OctreeRefinement/include/sc_string.h
deleted file mode 100644
index 262993d..0000000
--- a/OctreeRefinement/include/sc_string.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_STRING_H
-#define SC_STRING_H
-
-#include <sc.h>
-
-/** \file sc_string.h
- * This file declares a simple string object that can be appended to.
- */
-
-/** This defines the maximum string storage including the trailing '\0'. */
-#define SC_STRING_SIZE 4088
-
-/** This is a simple opaque type for growing a string by printf-like commands.
- * It can be declared on the stack to avoid malloc and free.
- * This means that the length of the string is limited to \ref SC_STRING_SIZE - 1.
- * The current string can be accessed by \ref sc_string_get_content.
- * This is really an opaque object: its members shall not be accessed directly.
- */
-typedef struct sc_string
-{
-  /* None of the member variables are public.
-   * We provide the declaration here in sc_string.h
-   * so the object can be declared on the stack.
-   */
-  int                 printed;                  /**< Opaque object: do not access. */
-  char                buffer[SC_STRING_SIZE];   /**< Opaque object: do not access. */
-}
-sc_string_t;
-
-/** Initialize to an empty string.
- * This function can be used to reset a non-empty string to be empty again.
- * \param [out] scs             After returning, a valid object
- *                              containing the empty string.
- */
-void                sc_string_init (sc_string_t * scs);
-
-/** Append a single character to the string buffer object.
- * \param [in,out] scs          A valid string buffer object.
- * \param [in] c                Converted to an unsigned char and appended.
- * \return                      Zero if the character has been appended and
- *                              a negative value when the input was truncated.
- */
-int                 sc_string_putc (sc_string_t * scs, int c);
-
-/** Append a string to the string buffer object.
- * \param [in,out] scs          A valid string buffer object.
- * \param [in] s                This string is appended to the string buffer.
- * \return                      Zero if the string has been appended and
- *                              a negative value when the input was truncated.
- */
-int                 sc_string_puts (sc_string_t * scs, const char *s);
-
-/** Append to the string object using a format string and arguments.
- * The maximum length will not be exceeded.
- * The string object will remain valid even on truncated input.
- * \param [in,out] scs          Valid string object that is appended to.
- * \param [in] fmt              Format string as used with printf and friends.
- * \return                      Zero if everything has been appended and a
- *                              negative value when the input was truncated.
- */
-int                 sc_string_putf (sc_string_t * scs, const char *fmt, ...)
-  __attribute__ ((format (printf, 2, 3)));
-
-/** Append to the string object using a format string and a vararg pointer.
- * The maximum length will not be exceeded.
- * The string object will remain valid even on truncated input.
- * \param [in,out] scs          Valid string object that is appended to.
- * \param [in] fmt              Format string as used with printf and friends.
- * \param [in,out] ap           Argument list pointer as defined in stdarg.h.
- * \return                      Zero if everything has been appended and a
- *                              negative value when the input was truncated.
- */
-int                 sc_string_putv (sc_string_t * scs, const char *fmt,
-                                    va_list ap);
-
-/** Access content of the string buffer.
- * \param [in] scs              Valid sc_string object.
- * \param [in] length           If not NULL, assign length without trailing '\0'.
- * \return                      Pointer to an internally allocated string, may
- *                              not be used after \b scs goes out of scope.
- */
-const char         *sc_string_get_content (sc_string_t * scs, int *length);
-
-#endif /* !SC_STRING_H */
diff --git a/OctreeRefinement/include/sc_unique_counter.h b/OctreeRefinement/include/sc_unique_counter.h
deleted file mode 100644
index 8024da0..0000000
--- a/OctreeRefinement/include/sc_unique_counter.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_UNIQUE_COUNTER_H
-#define SC_UNIQUE_COUNTER_H
-
-#include <sc_containers.h>
-
-typedef struct sc_unique_counter
-{
-  int                 start_value;
-  sc_mempool_t       *mempool;
-}
-sc_unique_counter_t;
-
-/** Create a factory for unique tag numbers.
- * The first tag number created will be start_value.
- * Subsequent ones are counted forward from there.
- * If a counter is released, it will be reactivated by the next creation.
- * \param [in] start_value      Value of the first counter to be added.
- * \return                      Fully initialized counter factory.
- */
-sc_unique_counter_t *sc_unique_counter_new (int start_value);
-
-/** Destroy the counter factor and all counters created from it.
- * All counters added must have been released before calling this function.
- * \param [in,out] uc           This memory will be released.
- */
-void                sc_unique_counter_destroy (sc_unique_counter_t * uc);
-
-/** Return the size in bytes allocated by this counter factory.
- * \param [in,out] uc           Its total memory used will be counted.
- */
-size_t              sc_unique_counter_memory_used (sc_unique_counter_t * uc);
-
-/** Request and return a counter with a unique integer value.
- * The memory return is borrowed and still being owned by \a uc.  The same
- * number will never be returned twice, unless the counter has been released
- * first.
- * \param [in,out] uc           The factory to return a unique counter.
- * \return                      Pointer to internal memory.
- *                              The unique counter value is accessed by simply
- *                              dereferencing the int pointer.
- */
-int                *sc_unique_counter_add (sc_unique_counter_t * uc);
-
-/** Release and return a counter to the factory.
- * It will be reactivated on a subsequent call to sc_unique_counter_add.
- * \param [in,out] uc           The factory to return a unique counter.
- * \param [in] counter          This must be a pointer previously obtained from
- *                              sc_unique_counter_add and not since released.
- */
-void                sc_unique_counter_release (sc_unique_counter_t * uc,
-                                               int *counter);
-
-#endif /* !SC_UNIQUE_COUNTER */
diff --git a/OctreeRefinement/include/sc_warp.h b/OctreeRefinement/include/sc_warp.h
deleted file mode 100644
index d40cd86..0000000
--- a/OctreeRefinement/include/sc_warp.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
-  This file is part of the SC Library.
-  The SC Library provides support for parallel scientific applications.
-
-  Copyright (C) 2010 The University of Texas System
-  Additional copyright (C) 2011 individual authors
-
-  The SC Library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  The SC Library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the SC Library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-  02110-1301, USA.
-*/
-
-#ifndef SC_WARP_H
-#define SC_WARP_H
-
-#include <sc.h>
-
-typedef struct sc_warp_interval sc_warp_interval_t;
-
-struct sc_warp_interval
-{
-  int                 level;    /* level of root is 0 */
-  double              r_low, r_high;    /* interval coordinates */
-  sc_warp_interval_t *left, *right;     /* binary tree descendants */
-};
-
-SC_EXTERN_C_BEGIN;
-
-sc_warp_interval_t *sc_warp_new (double r_low, double r_high);
-void                sc_warp_destroy (sc_warp_interval_t * root);
-
-/** Refine the warp as necessary to accomodate a set of new points.
- * \param [in] root             The root warp interval.
- * \param [in] num_points       Number of new points to integrate.
- * \param [in] r_points         The new points need to be sorted.
- */
-void                sc_warp_update (sc_warp_interval_t * root,
-                                    int num_points, double *r_points,
-                                    double r_tol, int max_level);
-void                sc_warp_print (int package_id, int log_priority,
-                                   sc_warp_interval_t * root);
-void                sc_warp_write (sc_warp_interval_t * root, FILE * nout);
-
-SC_EXTERN_C_END;
-
-#endif /* !SC_WARP_H */
diff --git a/OctreeRefinement/include/unistd.h b/OctreeRefinement/include/unistd.h
deleted file mode 100644
index 219df14..0000000
--- a/OctreeRefinement/include/unistd.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/* ========================================================================== */
-/*                                                                            */
-/*   Filename.c                                                               */
-/*   (c) 2012 Author                                                          */
-/*                                                                            */
-/*   Description                                                              */
-/*                                                                            */
-/* ========================================================================== */
-
-#ifndef _UNISTD_H
-#define _UNISTD_H    1
-
-/* This file intended to serve as a drop-in replacement for 
- *  unistd.h on Windows
- *  Please add functionality as neeeded 
- */
-
-#include <stdlib.h>
-#include <io.h>
-#include <getopt.h> /* getopt at: https://gist.github.com/ashelly/7776712 */
-#include <process.h> /* for getpid() and the exec..() family */
-#include <direct.h> /* for _getcwd() and _chdir() */
-
-#define srandom srand
-#define random rand
-
-/* Values for the second argument to access.
-   These may be OR'd together.  */
-#define R_OK    4       /* Test for read permission.  */
-#define W_OK    2       /* Test for write permission.  */
-//#define   X_OK    1       /* execute permission - unsupported in windows*/
-#define F_OK    0       /* Test for existence.  */
-
-#define access _access
-#define dup2 _dup2
-#define execve _execve
-#define ftruncate _chsize
-#define unlink _unlink
-#define fileno _fileno
-#define getcwd _getcwd
-#define chdir _chdir
-#define isatty _isatty
-#define lseek _lseek
-/* read, write, and close are NOT being #defined here, because while there are file handle specific versions for Windows, they probably don't work for sockets. You need to look at your app and consider whether to call e.g. closesocket(). */
-
-#define ssize_t int
-
-#define STDIN_FILENO 0
-#define STDOUT_FILENO 1
-#define STDERR_FILENO 2
-/* should be in some equivalent to <sys/types.h> */
-//typedef __int8            int8_t;
-typedef __int16           int16_t; 
-typedef __int32           int32_t;
-typedef __int64           int64_t;
-typedef unsigned __int8   uint8_t;
-typedef unsigned __int16  uint16_t;
-typedef unsigned __int32  uint32_t;
-typedef unsigned __int64  uint64_t;
-
-#endif /* unistd.h  */
\ No newline at end of file
diff --git a/OctreeRefinement/libp4est-2.0.so b/OctreeRefinement/libp4est-2.0.so
deleted file mode 100644
index dfb1dad..0000000
Binary files a/OctreeRefinement/libp4est-2.0.so and /dev/null differ
diff --git a/OctreeRefinement/libp4est.dll b/OctreeRefinement/libp4est.dll
deleted file mode 100644
index 5528bf0..0000000
Binary files a/OctreeRefinement/libp4est.dll and /dev/null differ
diff --git a/OctreeRefinement/libp4est.lib b/OctreeRefinement/libp4est.lib
deleted file mode 100644
index 7dba629..0000000
Binary files a/OctreeRefinement/libp4est.lib and /dev/null differ
diff --git a/OctreeRefinement/libp4est.so b/OctreeRefinement/libp4est.so
deleted file mode 100644
index dfb1dad..0000000
Binary files a/OctreeRefinement/libp4est.so and /dev/null differ
diff --git a/OctreeRefinement/libsc-2.0.so b/OctreeRefinement/libsc-2.0.so
deleted file mode 100644
index 5f0626d..0000000
Binary files a/OctreeRefinement/libsc-2.0.so and /dev/null differ
diff --git a/OctreeRefinement/libsc.dll b/OctreeRefinement/libsc.dll
deleted file mode 100644
index 50c5914..0000000
Binary files a/OctreeRefinement/libsc.dll and /dev/null differ
diff --git a/OctreeRefinement/libsc.lib b/OctreeRefinement/libsc.lib
deleted file mode 100644
index 204a678..0000000
Binary files a/OctreeRefinement/libsc.lib and /dev/null differ
diff --git a/OctreeRefinement/libsc.so b/OctreeRefinement/libsc.so
deleted file mode 100644
index 5f0626d..0000000
Binary files a/OctreeRefinement/libsc.so and /dev/null differ
diff --git a/OctreeRefinement/zlib1.dll b/OctreeRefinement/zlib1.dll
deleted file mode 100644
index 1f16088..0000000
Binary files a/OctreeRefinement/zlib1.dll and /dev/null differ
