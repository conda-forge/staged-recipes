diff -Naur libAfterImage-1.20/ChangeLog root/graf2d/asimage/src/libAfterImage/ChangeLog
--- libAfterImage-1.20/ChangeLog	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/ChangeLog	2018-12-08 08:22:54.000000000 +0100
@@ -510,7 +510,7 @@
 	  up wharf's support for look defined folder icon. That should also
 	  speedup repeated changes of look
 	* adding support in Wharf for look-specific folder pixmap - so far
-	  only works 2 times, then stops changing - wierd
+	  only works 2 times, then stops changing - weird
 
 2007-07-19  sasha
 
@@ -1059,7 +1059,7 @@
 
 2005-04-22  sasha
 
-	* Fixed off-by-one bug in ASStorage causing wierd artefact and
+	* Fixed off-by-one bug in ASStorage causing weird artefact and
 	  possibly segfaults, due to occupied slots being reused improperly
 
 2005-04-21  sasha
@@ -1381,7 +1381,7 @@
 	* fixed segfault in asstorage when diff buffer does not gets
 	  reallocated
 	* fixed button ungrabbing on windows withdrawing that was causing
-	  wierd BadAccess errors in Wharf
+	  weird BadAccess errors in Wharf
 
 2004-09-23  sasha
 
@@ -1527,7 +1527,7 @@
 	  calls to storage destruction code
 	* fixed thresholding code in asstorage needed for rectangular shape
 	  stuff
-	* Improved reference counting in ASStorage to accomodate to wierd
+	* Improved reference counting in ASStorage to accomodate to weird
 	  storage states where some blocks have no space left for reference
 
 2004-07-30  sasha
@@ -1738,7 +1738,7 @@
 
 2004-03-18  sasha
 
-	* Found and fixed very wierd heap corruption bug, causing segfault
+	* Found and fixed very weird heap corruption bug, causing segfault
 	  whenever bevelled rectang is drawn
 	* Added builtin libungif to libAfterImage, and enabled support for
 	  it by default in configure
@@ -1839,7 +1839,7 @@
 2004-01-21  sasha
 
 	* fixed bug where empty locale would be specified while starting a
-	  module causing Pager to have 255 desktops and other wierdness
+	  module causing Pager to have 255 desktops and other weirdness
 
 2004-01-13  sasha
 
@@ -1917,7 +1917,7 @@
 
 	* Added ActiveDeskBevel and InActiveDeskBevel to Pager's options;
 	  Debugged bevel drawing when tbar has different bevels for focus
-	  and unfocus states( should get rid of wierd black frame when one
+	  and unfocus states( should get rid of weird black frame when one
 	  of the states is None)
 
 2003-09-25  sasha
@@ -2121,7 +2121,7 @@
 	  TakeFrameShot, as the side effect of debugging root background
 	  handling. Updated feel.DEFAULT to use those
 	* fixed bug in inheritance code where back_icon would get destroyed
-	  even if it was inherited, thus causing wierd things to happen
+	  even if it was inherited, thus causing weird things to happen
 	  when same style is inherited twice; Added code to
 	  mystyle_make_image to ensure that we always produce valid ASImage
 
@@ -3383,7 +3383,7 @@
 	* Completed Pseudo-color support with colormap allocation and
 	  ximage handling.  Added create_asimage and destroy_asimage for
 	  convinience.	Added missing stuff to libAfterImage/afterbase.h to
-	  make it completely independant.  libAfterImage thus should be
+	  make it completely independent.  libAfterImage thus should be
 	  ready for release - only to write up some docs :)
 
 2001-06-13  sasha
@@ -3495,7 +3495,7 @@
 	  it.  That should allow for better library independancy - visual
 	  will go with libAfterImage while ScreenInfo will move into
 	  libAfterStep , or, possibly will split up even more.	Goal is to
-	  make libAfterImage completely independant from everything else.
+	  make libAfterImage completely independent from everything else.
 
 2001-05-23  allanon
 
@@ -3646,7 +3646,7 @@
 	*  minor quality tweaks in rations 1-2 scaling up. Started
 	  implementing ASImageDecoder for automatic tinting/tiling
 	* IMplemented JPEG input filter for ASImage.  Fixed long standing
-	  bug in image scaling causing wierdness in scaling UP with small
+	  bug in image scaling causing weirdness in scaling UP with small
 	  ratios.  Started implemntation of XCF file reader.
 
 2001-04-15  sasha
diff -Naur libAfterImage-1.20/Makefile.in root/graf2d/asimage/src/libAfterImage/Makefile.in
--- libAfterImage-1.20/Makefile.in	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/Makefile.in	2018-12-08 08:18:38.000000000 +0100
@@ -19,7 +19,7 @@
 		libjpeg/jdpostct.o libjpeg/jdsample.o libjpeg/jdtrans.o \
 		libjpeg/jerror.o libjpeg/jfdctflt.o libjpeg/jfdctfst.o \
 		libjpeg/jfdctint.o libjpeg/jidctflt.o libjpeg/jidctfst.o \
-		libjpeg/jidctint.o libjpeg/jidctred.o libjpeg/jquant1.o \
+		libjpeg/jidctint.o libjpeg/jquant1.o \
 		libjpeg/jquant2.o libjpeg/jutils.o libjpeg/jmemmgr.o libjpeg/jmemnobs.o \
 		libjpeg/transupp.o
 
@@ -83,7 +83,7 @@
 MV		= @MV@
 RM		= @RM@
 RMF		= @RM@ -f
-MKDIR		= @MKDIR@
+MKDIR		= @MKDIR@ -p
 FIND		= @FIND@
 XARGS		= @XARGS@
 LDCONFIG	= @LDCONFIG@
@@ -145,20 +145,6 @@
 		@(if [ -d $(LIBDIR) ] && [ -w $(LIBDIR) ]; then \
 		    echo "$(INSTALL_LIB) $(LIB_STATIC) $(LIBDIR)"; \
 		    $(INSTALL_LIB) $(LIB_STATIC) $(LIBDIR); \
-		    if [ `uname` = "Linux" ]; then \
-			if test $(LIBDIR) = "/lib" || test $(LIBDIR) = "/usr/lib"; then \
-		    	    echo "" > /dev/null; \
-			elif grep -q $(LIBDIR) /etc/ld.so.conf > /dev/null 2>&1; then \
-		    	    echo "" > /dev/null; \
-			else \
-		    	    echo "Unable to find $(LIBDIR) in ld.so.conf. In order to use "; \
-		    	    echo "$(LIB_STATIC), you may need to add it or set LD_LIBRARY_PATH."; \
-			fi; \
-			if test -w /etc; then \
-			    echo "$(LDCONFIG)"; \
-			    $(LDCONFIG); \
-			fi; \
-		    fi ;\
 		fi \
 		)
 
@@ -171,18 +157,6 @@
 		$(RM) -f $(LIBDIR)/$(LIB_SHARED).$(LIBVERMAJOR) $(LIBDIR)/$(LIB_SHARED); \
 		$(LN_S) -f $(LIB_SHARED).$(LIBVER) $(LIBDIR)/$(LIB_SHARED).$(LIBVERMAJOR); \
 		$(LN_S) -f $(LIB_SHARED).$(LIBVERMAJOR) $(LIBDIR)/$(LIB_SHARED); \
-		if test `uname` = "Linux"; then \
-		   if test $(LIBDIR) = "/lib" || test $(LIBDIR) = "/usr/lib"; then \
-		     echo "" > /dev/null; \
-		   elif grep -q $(LIBDIR) /etc/ld.so.conf > /dev/null 2>&1; then \
-		     echo "" > /dev/null; \
-		   else \
-		     echo "Unable to find $(LIBDIR) in ld.so.conf. In order to use "; \
-		     echo "$(LIB_SHARED), you may need to add it or set LD_LIBRARY_PATH."; \
-		   fi; \
-		   echo "$(LDCONFIG)"; \
-		   $(LDCONFIG); \
-		 fi \
 		)
 
 install.cyg:	mkdir
@@ -397,8 +371,8 @@
 	$(LN_S) -f $(LIB_SHARED).$(LIBVER) $(LIB_SHARED).$(LIBVERMAJOR)
 
 $(LIB_SHARED).$(LIBVER): $(LIB_OBJS) $(LIB_INCS) config.h
-	$(CC) -shared -Wl,-soname,$(LIB_SHARED).$(LIBVERMAJOR) -o $(LIB_SHARED).$(LIBVER) \
-	 $(LIB_OBJS)
+	$(CC) -shared $(USER_LD_FLAGS) -Wl,-soname,$(LIB_SHARED).$(LIBVERMAJOR) -o $(LIB_SHARED).$(LIBVER) \
+	 $(LIB_OBJS) $(LIBRARIES)
 
 install.man:
 		@if [ -d doc/man ] ; then \
diff -Naur libAfterImage-1.20/aclocal.m4 root/graf2d/asimage/src/libAfterImage/aclocal.m4
--- libAfterImage-1.20/aclocal.m4	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/aclocal.m4	2018-12-08 08:18:38.000000000 +0100
@@ -27,7 +27,7 @@
 
 dnl AC_LIB_PREFIX adds to the CPPFLAGS and LDFLAGS the flags that are needed
 dnl to access previously installed libraries. The basic assumption is that
-dnl a user will want packages to use other packages he previously installed
+dnl a user will want packages to use other packages they previously installed
 dnl with the same --prefix option.
 dnl This macro is not needed if only AC_LIB_LINKFLAGS is used to locate
 dnl libraries, but is otherwise very convenient.
@@ -226,7 +226,7 @@
 
   dnl Add $INC[]NAME to CPPFLAGS before performing the following checks,
   dnl because if the user has installed lib[]Name and not disabled its use
-  dnl via --without-lib[]Name-prefix, he wants to use it.
+  dnl via --without-lib[]Name-prefix, they want to use it.
   ac_save_CPPFLAGS="$CPPFLAGS"
   AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)
 
diff -Naur libAfterImage-1.20/afterbase.c root/graf2d/asimage/src/libAfterImage/afterbase.c
--- libAfterImage-1.20/afterbase.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/afterbase.c	2018-12-08 08:18:38.000000000 +0100
@@ -64,9 +64,9 @@
 #endif
 
 #ifdef _WIN32
-#include "win32/afterbase.h"
 #include <io.h>
 #include <windows.h>
+#include "win32/afterbase.h"
 #define access _access
 #else
 #include "afterbase.h"
@@ -88,7 +88,7 @@
 	do
 	{	/* Save our program name - for error messages */
 		register int i = 1 ;                   /* we don't use standard strrchr since there
-												* seems to be some wierdness in
+												* seems to be some weirdness in
 												* CYGWIN implementation of it. */
 		asim_ApplicationName =  temp ;
 		while( temp[i] && temp[i] != '/' ) ++i ;
@@ -705,7 +705,8 @@
 				num = asim_parse_math(str + 1, &ptr, size);
             else if (*str == '$') 
 			{
-            	for (ptr = (char*)str + 1 ; *ptr && !isspace(*ptr) && *ptr != '+' && *ptr != '-' && *ptr != '*' && *ptr != '!' && *ptr != '/' && *ptr != ')' ; ptr++);
+            	for (ptr = (char*)str + 1 ; *ptr && !isspace(*ptr) && *ptr != '+' && *ptr != '-' && *ptr != '*' && *ptr != '!' && *ptr != '/' && *ptr != ')' ; ptr++)
+            	   ;
                	num = asim_asxml_var_nget((char*)str + 1, ptr - (str + 1));
             }else 
 				num = strtod(str, &ptr);
@@ -1278,7 +1279,7 @@
 		{
 			int i = 0; 
 			/* Fill in the fields using stat() */
-			do{ p[i] = e->d_name[i]; ++i ; }while(  e->d_name[i] && i < PATH_MAX ); 
+			do{ p[i] = e->d_name[i]; ++i ; }while(  i < PATH_MAX && e->d_name[i] );
 			p[i] ='\0' ;
 			if (stat (filename, &stat_info) != -1)
 			{	
diff -Naur libAfterImage-1.20/afterbase.h root/graf2d/asimage/src/libAfterImage/afterbase.h
--- libAfterImage-1.20/afterbase.h	1970-01-01 01:00:00.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/afterbase.h	2018-12-08 08:18:38.000000000 +0100
@@ -0,0 +1,41 @@
+#ifndef AFTERBASE_H_HEADER_INCLUDED
+#define AFTERBASE_H_HEADER_INCLUDED
+
+#define HAVE_AFTERBASE_FLAG 0
+
+#if 0
+# if 0
+#include <libAfterBase/astypes.h>
+#include <libAfterBase/audit.h>
+#include <libAfterBase/output.h>
+#include <libAfterBase/safemalloc.h>
+#include <libAfterBase/mystring.h>
+#include <libAfterBase/fs.h>
+#include <libAfterBase/parse.h>
+#include <libAfterBase/selfdiag.h>
+#include <libAfterBase/sleep.h>
+#include <libAfterBase/socket.h>
+#include <libAfterBase/trace.h>
+#include <libAfterBase/xml.h>
+# else
+#include "libAfterBase/astypes.h"
+#include "libAfterBase/audit.h"
+#include "libAfterBase/output.h"
+#include "libAfterBase/safemalloc.h"
+#include "libAfterBase/mystring.h"
+#include "libAfterBase/fs.h"
+#include "libAfterBase/parse.h"
+#include "libAfterBase/selfdiag.h"
+#include "libAfterBase/sleep.h"
+#include "libAfterBase/socket.h"
+#include "libAfterBase/trace.h"
+#include "libAfterBase/xml.h"
+# endif
+#else
+
+# include "asim_afterbase.h"
+
+#endif /* HAVE_AFTERBASE */
+
+#endif /* AFTERBASE_H_HEADER_INCLUDED */
+
diff -Naur libAfterImage-1.20/afterimage-config.in root/graf2d/asimage/src/libAfterImage/afterimage-config.in
--- libAfterImage-1.20/afterimage-config.in	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/afterimage-config.in	2018-12-08 08:18:38.000000000 +0100
@@ -115,11 +115,7 @@
         	libs="-lAfterBase $libs"
  	fi
  	libs="-lAfterImage $libs" 
-	if test "@libdir@" != "/usr/lib" ; then
-  		echo -L@libdir@ $libs
- 	else
-  		echo $libs
- 	fi
+        echo $libs
  else
         echo $libs
  fi
diff -Naur libAfterImage-1.20/afterimage.h root/graf2d/asimage/src/libAfterImage/afterimage.h
--- libAfterImage-1.20/afterimage.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/afterimage.h	2018-12-08 08:18:38.000000000 +0100
@@ -70,7 +70,7 @@
  * as well. Native X fonts look ugly as soon as you try to show any
  * decently sized text. That is supposed to be solved with said Render
  * extensions to XFree86, but as experiense has shown, things aren't as
- * easy as it looks, besides one wants his app to run well under any X
+ * easy as it looks, besides one wants one's app to run well under any X
  * Server. FreeType library provides a solution, but not always
  * available. Another problem is that if you keep all your images on the
  * client side, you want to draw text on client side as well.
diff -Naur libAfterImage-1.20/aftershow/.depend root/graf2d/asimage/src/libAfterImage/aftershow/.depend
--- libAfterImage-1.20/aftershow/.depend	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/aftershow/.depend	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-./aftershow.h:
-
-./xutil.o: \
-		../win32/config.h \
-		../config.h \
-		../afterbase.h \
-		../afterimage.h \
-		aftershow.h
-
-./aftershow.o: \
-		../win32/config.h \
-		../config.h \
-		../afterimage.h \
-		aftershow.h
-
-./aftershow_pipe.o: \
-		../win32/config.h \
-		../config.h \
-		../afterbase.h \
-		../afterimage.h \
-		aftershow.h
diff -Naur libAfterImage-1.20/aftershow/Makefile.in root/graf2d/asimage/src/libAfterImage/aftershow/Makefile.in
--- libAfterImage-1.20/aftershow/Makefile.in	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/aftershow/Makefile.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,164 +0,0 @@
-
-PROGS= aftershow aftershow_pipe
-
-AFTERSHOW_OBJS= aftershow.o xmlutil.o xutil.o
-
-AFTERSHOW_PIPE_OBJS= aftershow_pipe.o xutil.o
-
-CC		= @CC@
-CCFLAGS         = @CFLAGS@
-# -march=pentiumpro -mcpu=pentiumpro
-EXTRA_DEFINES	= @DEFINE_XLOCALE@
-
-RANLIB		= @RANLIB@
-AR		= ar clq
-CP		= @CP@
-MV		= @MV@
-RM		= @RM@
-RMF		= @RM@ -f
-MKDIR		= @MKDIR@
-FIND		= @FIND@
-XARGS		= @XARGS@
-LDCONFIG	= @LDCONFIG@
-
-INSTALL		= @INSTALL@
-INSTALL_PROGRAM	= @INSTALL@ -m 755
-INSTALL_DATA	= @INSTALL@ -m 644
-
-INCS_X		= @X_CFLAGS@
-INCS_PRIVATE    = 
-INCLUDES	= $(INCS_X) $(INCS_PRIVATE) -I..
-
-USER_LD_FLAGS	= @user_ldflags@
-LIBS_X		= @x_libs@
-LIBS_XEXTS	=
-LIBS_AFTERIMAGE = @AFTERIMAGE_APPS_LIBS@
-LIBRARIES	= $(USER_LD_FLAGS) $(LIBS_AFTERIMAGE) $(LIBS_X) $(LIBS_XEXTS)
-
-prefix          = @prefix@
-exec_prefix     = @exec_prefix@
-LIBDIR		= $(DESTDIR)@libdir@
-BIN_DIR		= $(DESTDIR)@bindir@
-MAN_DIR		= $(DESTDIR)@mandir@/man1
-AFTER_DIR	= @with_afterdir@
-
-# need this for dependancies :
-LIBAFTERIMAGE_PATH =..
-LIB_STATIC      = $(LIBAFTERIMAGE_PATH)/libAfterImage.a
-LIB_SHARED      = $(LIBAFTERIMAGE_PATH)/libAfterImage.so
-
-
-all:    $(PROGS)
-
-install.bin:	$(PROGS)
-		@echo "installing libAfterImage apps using command - "; \
-		if [ ! -d $(BIN_DIR) ] ; then 	$(MKDIR) -p $(BIN_DIR); fi; \
-		echo "    \"$(INSTALL_PROGRAM) <app> $(BIN_DIR)\" :"; \
-		for p in $(PROGS); do \
-			echo -n "$$p "; \
-	  		$(INSTALL_PROGRAM) $$p $(BIN_DIR); \
-		done; \
-		echo ""; echo "Done."; \
-
-install.man:
-		@if [ ! -d $(MAN_DIR) ] ; then 	$(MKDIR) -p $(MAN_DIR); fi; \
-		for f in *.man; do \
-		  echo $(INSTALL_DATA) $$f $(MAN_DIR)/`basename $$f`.1x; \
-		  $(INSTALL_DATA) $$f $(MAN_DIR)/`basename $$f`.1x; \
-		done
-
-uninstall.bin:
-		@for p in $(PROGS); do \
-			echo "$(RMF) $(BIN_DIR)/$$p"; \
-			$(RMF) $(BIN_DIR)/$$p; \
-		done
-
-uninstall.man:
-		$(RMF) $(AFTER_MAN_DIR)/$(PROGS).1x
-
-clean:
-		$(RMF) $(PROGS) *.o *~ *% *.bak \#* core
-
-distclean:
-		$(RMF) $(PROGS) *.o *~ *% *.bak \#* *.orig core Makefile
-
-indent:
-		@SRCS=`find . -name "*.c"`; \
-		if test "x$$SRCS" == "x"; then exit; fi; \
-		for i in $$SRCS; do \
-		  if (indent -di14 -ts4 -i4 -l100 -lc80 -bad -nbbb -bli0 -c48 -cd48 -ce -cli1 -ncs -nbs -nbbo -hnl < $$i > /tmp/$$i); then \
-		    echo "indent $$i"; \
-		    mv /tmp/$$i $$i; \
-		  fi; \
-		done
-
-deps:
-		@echo -n > .depend ; \
-		buf="" ; \
-		for f in `find . -name "*.h"` ; do \
-		  if test "x$$buf" != "x"; then \
-		      echo $$buf >>.depend ; \
-		      echo "" >>.depend ; \
-		  fi; \
-		  buf="$$f:"; \
-		  for d in `grep "#include \"" <$$f | awk -F \" '{print $$2}'`; do \
-		      if test "x$$buf" != "x"; then \
-		         echo $$buf \\ >>.depend ; \
-		      fi; \
-		      echo -n "		" >>.depend ; \
-		      buf="$$d "; \
-		  done; \
-		done; \
-		if test "x$$buf" != "x"; then \
-		  echo $$buf >>.depend ; \
-		  buf="" ; \
-		  echo "" >>.depend ; \
-		fi ; \
-		for file in `find . -name "*.c"` ; do \
-		  if test "x$$buf" != "x"; then \
-		      echo $$buf >>.depend ; \
-		      echo >>.depend ; \
-		  fi; \
-		  buf="."`echo $$file | awk -F . '{print $$2}'`".o:" ; \
-		  for d in `grep "#include \"" < $$file | awk -F \" '{print $$2}'`; do \
-		      if test "x$$buf" != "x"; then \
-		         echo $$buf \\ >>.depend ; \
-		      fi; \
-		      echo -n "		" >>.depend ; \
-		      buf="$$d "; \
-		  done; \
-		done; \
-		if test "x$$buf" != "x"; then \
-		  echo $$buf >>.depend ; \
-		fi
-
-aftershow: $(AFTERSHOW_OBJS) @LIBPROG@
-		$(CC) $(AFTERSHOW_OBJS) $(LIBRARIES) $(EXTRA_LIBRARIES) -o aftershow
-
-
-aftershow_pipe: $(AFTERSHOW_PIPE_OBJS) @LIBPROG@
-		$(CC) $(AFTERSHOW_PIPE_OBJS) $(LIBRARIES) $(EXTRA_LIBRARIES) -o aftershow_pipe
-
-
-.c.o:
-		$(CC) $(CCFLAGS) $(EXTRA_DEFINES) $(INCLUDES) $(EXTRA_INCLUDES) -c $*.c
-
-.c.s:
-		$(CC) $(CCFLAGS) $(EXTRA_DEFINES) $(INCLUDES) $(EXTRA_INCLUDES) -S $*.c
-
-.lo:	$*.c
-
-
-install:	install.bin
-
-uninstall:	uninstall.bin
-
-include .depend
-
-@LIBAFTERIMAGEFILES@
-
-$(LIBAFTERIMAGE_PATH)/libAfterImage.a: $(LIBAFTERIMAGE_OBJS) $(LIBAFTERIMAGE_INCS)
-		cd $(LIBAFTERIMAGE_PATH)/; ${MAKE} libAfterImage.a
-
-$(LIBAFTERIMAGE_PATH)/libAfterImage.so: $(LIBAFTERIMAGE_OBJS) $(LIBAFTERIMAGE_INCS)
-		cd $(LIBAFTERIMAGE_PATH)/; ${MAKE} libAfterImage.so
diff -Naur libAfterImage-1.20/aftershow/aftershow.c root/graf2d/asimage/src/libAfterImage/aftershow/aftershow.c
--- libAfterImage-1.20/aftershow/aftershow.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/aftershow/aftershow.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1017 +0,0 @@
-/*
- * Copyright (c) 2008 Sasha Vasko <sasha at aftercode.net>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#define LOCAL_DEBUG
-#undef DO_CLOCKING
-
-#ifdef _WIN32
-#include "../win32/config.h"
-#else
-#include "../config.h"
-#endif
-
-
-#include <string.h>
-#ifdef DO_CLOCKING
-#if TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# if HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif
-#endif
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#ifdef HAVE_STDLIB_H
-#include <stdlib.h>
-#endif
-#ifdef HAVE_STDARG_H
-#include <stdarg.h>
-#endif
-
-#include <errno.h>
-#include <sys/file.h>
-#include <sys/socket.h>
-#include <sys/un.h>							   /* for struct sockaddr_un */
-
-#ifdef _WIN32
-# include "../win32/afterbase.h"
-#else
-# include "../afterbase.h"
-#endif
-#include "../afterimage.h"
-
-#include "aftershow.h"
-
-/**********************************************************************************/
-/* main portion of AfterShow daemon                                               */
-/**********************************************************************************/
-
-Bool InitContext (AfterShowContext *context, int argc, char **argv);
-Bool ConnectGUI (AfterShowContext *context);
-Bool CheckInstance (AfterShowContext *context);
-Bool SetupComms (AfterShowContext *context);
-void HandleEvents (AfterShowContext *context);
-void ShutdownXScreen (AfterShowContext *ctx, int screen);
-void ShutdownWin32Screen (AfterShowContext *ctx, int screen);
-void ShutdownClient (AfterShowContext *ctx, int channel);
-void Shutdown (AfterShowContext *ctx);
-
-void show_usage (Bool short_form)
-{
-	printf( "AfterShow - AfterImage XML processing and display daemon.\n"
-			"Usage: aftershow [-h|--help] [-f] [-s] [-d|--display <display_string>]\n"
-			"  -h --help      - display this message;\n"
-			"  -f             - fork - go in background immidiately on startup;\n"
-			"  -s             - single screen mode - sirvice only the first screen of display;\n"
-			"  -d --display <display_string> - connect to X display specified by display_string;\n"
-			"  -V <level>     - set output verbosity level - 0 for no output;\n" );
-}
-
-
-int 
-main (int argc, char **argv)
-{
-	AfterShowContext context;
-	/* 
-	 * 1) Connect to windowing system
-	 * 2) Check for another instance running for the same user
-	 * 3) Create UD Socket
-	 * 4) Handle Events
-	 */
-	set_application_name(argv[0]);
-	set_output_threshold(0);  /* be real quiet by default ! */
-	
-	if (!InitContext(&context, argc, argv))
-		return EXIT_FAILURE;
-
-	if (!ConnectGUI(&context))
-		return EXIT_FAILURE;
-		
-	if (!CheckInstance(&context))
-	{
-		show_error( "Another instance is already running. Exiting!");
-		return EXIT_FAILURE;
-	}
-		
-	if (!SetupComms(&context))
-		return EXIT_FAILURE;
-
-	if (get_flags(context.flags, AfterShow_DoFork))
-    {
-		pid_t pid = fork ();
-		
-		if (pid < 0)
-        {
-        	show_error ("unable to fork daemon, aborting.");
-          	return EXIT_FAILURE;
-        }
-      	else if (pid > 0)
-        	_exit (EXIT_SUCCESS);
-    }
-
-	HandleEvents(&context);
-   	return EXIT_SUCCESS;
-}
-
-/**********************************************************************************
- * Implementation : 
- **********************************************************************************/
-Bool InitContext (AfterShowContext *ctx, int argc, char **argv)
-{
-	int i;
-	memset( ctx, 0x00, sizeof(AfterShowContext));
-	for (i = 1 ; i < argc ; ++i) 
-	{
-		if (argv[i][0] == '-')
-		{
-			if (argv[i][1] != '-') /* short option */
-			{
-				if (argv[i][2] == '\0')
-					switch (argv[i][1])
-					{
-						case 'h': 	show_usage(False); return False;
-						case 'f': 	set_flags(ctx->flags, AfterShow_DoFork); break;
-						case 's': 	set_flags(ctx->flags, AfterShow_SingleScreen); break;
-						case 'V': 	if (i + 1 < argc)
-										set_output_threshold(atoi(argv[++i]));
-									break;
-						case 'd': 	if (i + 1 < argc)
-									{
-										if (ctx->display) free (ctx->display);
-										ctx->display = strdup(argv[++i]);
-									}
-									break;
-						default :
-							show_error ("unrecognized option \"%s\"", argv[i]);
-							show_usage(False); 
-							return False;
-					}
-			}else /* long option */
-			{
-				if (strcmp(&(argv[i][2]), "help") == 0)
-				{ 
-					show_usage(False); return False; 
-				}else
-				{
-					show_error ("unrecognized option \"%s\"", argv[i]);
-					show_usage(False); 
-					return False;
-				}
-			}
-		}
-	}
-
-	return True;
-}
-
-Bool ConnectGUI (AfterShowContext *ctx)
-{
-#ifndef X_DISPLAY_MISSING
-	aftershow_connect_x_gui (ctx);
-#endif
-  /* TODO: add win32 code */
-
-	if (!ctx->gui.x.valid && !ctx->gui.win32.valid)
-		return False;
-
-	ctx->imman = create_generic_imageman(NULL);
-	ctx->fontman = 
-#ifndef X_DISPLAY_MISSING
-		create_generic_fontman(ctx->gui.x.dpy, NULL);
-#else
-		create_generic_fontman(NULL,NULL);
-#endif		
-	return True;
-}
-
-Bool CheckInstance (AfterShowContext *ctx)
-{
-#ifndef X_DISPLAY_MISSING
-	XEvent event;
-	int i = ctx->gui.x.screens_num;
-
-	/* must count down to get correct first_screen */	
-	while ( --i >= 0 )
-	{
-		char        tmp[64];
-        CARD32      data = 0xAAAAAAAA;
-		Window      old_selection_owner = None;
-		int 		tick_count;
-		AfterShowXScreen *scr = &(ctx->gui.x.screens[i]);
-		
-		/* intern selection atom */		
-		sprintf (tmp, "_AFTERSHOW_S%d", i);
-		scr->selection_window = XCreateSimpleWindow (ctx->gui.x.dpy, scr->root.w, 0, 0, 5, 5, 0, 0, None);
-		if (scr->selection_window)
-		{
-			scr->_XA_AFTERSHOW_S = XInternAtom (ctx->gui.x.dpy, tmp, False);
-			XSelectInput (ctx->gui.x.dpy, scr->selection_window, PropertyChangeMask);
-
-		   /* now we need to obtain a valid timestamp : */
-
-        	XChangeProperty (ctx->gui.x.dpy, scr->selection_window, scr->_XA_AFTERSHOW_S, scr->_XA_AFTERSHOW_S, 32, PropModeAppend, (unsigned char *)&data, 1);
-			XWindowEvent(ctx->gui.x.dpy, scr->selection_window, PropertyChangeMask, &event); 
-			scr->selection_time = event.xproperty.time;
-
-			old_selection_owner = XGetSelectionOwner (ctx->gui.x.dpy, scr->_XA_AFTERSHOW_S);
-			/* now we are ready to try and accure selection : */
-			show_progress( "Attempting to accure AfterShow selection on screen %d ...", i );
-			XSetSelectionOwner (ctx->gui.x.dpy, scr->_XA_AFTERSHOW_S, scr->selection_window, scr->selection_time);
-			XSync (ctx->gui.x.dpy, False);
-			/* give old owner 10 seconds to release selection : */
-			start_ticker(1);
-			for (tick_count = 0; tick_count < 100; tick_count++)
-			{
-    	    	Window present_owner = XGetSelectionOwner (ctx->gui.x.dpy, scr->_XA_AFTERSHOW_S);
-	        	if ( present_owner == scr->selection_window)
-				{
-					scr->do_service = True;
-					break;
-				}
-				wait_tick();
-			}
-
-			if (scr->do_service && old_selection_owner != None)
-			{
-				/* we need to wait for previous owner to shutdown, which
-				 * will be indicated by its selection window becoming invalid.
-				 */
-				tick_count = 0 ;
-				while (aftershow_validate_drawable( ctx, old_selection_owner))
-				{
-					wait_tick();
-					if (++tick_count  == 200)
-					{ /* if old owner failed to shutdown in 20 seconds -
-					   * then just kill it ! */
-						XKillClient (ctx->gui.x.dpy, old_selection_owner);
-						show_warning ("Previous AfterShow daemon failed to shutdown in allowed 60 seconds - killing it.");
-					}
-					if (tick_count > 300)
-					{
-						scr->do_service = False;
-						show_error("Previous AfterShow failed to shutdown in allowed 30 seconds - Something is terribly wrong - ignoring screen %d.", i );
-						break;
-					}
-				}
-			}
-			if (scr->do_service)
-			{
-				show_progress ("AfterShow selection on screen %d accured successfuly!", i);
-				scr->asv = create_asvisual (ctx->gui.x.dpy, scr->screen, DefaultDepth(ctx->gui.x.dpy, scr->screen), NULL);
-				ctx->gui.x.serviced_screens_num++;
-				ctx->gui.x.first_screen = i;
-			}else
-			{
-				if (scr->selection_window)
-				{
-					XDestroyWindow (ctx->gui.x.dpy, scr->selection_window);
-					scr->selection_window = None;
-				}
-			}
-		}
-	}
-#endif
-
-	return (ctx->gui.x.serviced_screens_num>0);
-}
-
-Bool SetupComms (AfterShowContext *ctx)
-{
-	char *path = getenv("TMPDIR");
-	if (path == NULL)
-		path = "/tmp";
-
-	if( access( path, W_OK ) != 0 )
-	    if( (path = getenv( "HOME" )) == NULL )
-			return False ;
-
-    ctx->socket_name = safemalloc (strlen(path) + 1 + 18 + 32 + 32 + 1);
-	sprintf (ctx->socket_name, "%s/aftershow-connect.%d.%d", path, getuid(), ctx->gui.x.first_screen);
-	show_progress ("Socket name set to \"%s\".", ctx->socket_name);
-	
-	ctx->min_fd = ctx->socket_fd = socket_listen (ctx->socket_name);
-
-#ifndef X_DISPLAY_MISSING
-	if (ctx->gui.x.valid)
-	{
-		int i;
-		if (ctx->gui.x.fd > ctx->socket_fd)
-			ctx->min_fd = ctx->gui.x.fd;
-		/* publish socket name as X property */
-		for ( i = 0; i < ctx->gui.x.screens_num; ++i)
-			if (ctx->gui.x.screens[i].do_service)
-				aftershow_set_string_property (	ctx, 
-												ctx->gui.x.screens[i].root.w, 
-												XInternAtom (ctx->gui.x.dpy, XA_AFTERSHOW_SOCKET_NAME, False), 
-												ctx->socket_name);
-	}
-#endif	
-		
-	/* determine max nuber of file descriptors we could have : */
-#ifdef _SC_OPEN_MAX
-	ctx->fd_width = sysconf (_SC_OPEN_MAX);
-#else
-	ctx->fd_width = getdtablesize ();
-#endif
-#ifdef FD_SETSIZE
-	if (ctx->fd_width > FD_SETSIZE)
-		ctx->fd_width = FD_SETSIZE;
-#endif
-
-	ctx->clients = safecalloc (ctx->fd_width, sizeof(AfterShowClient));
-	return (ctx->socket_fd > 0);
-}
-
-/*************************************************************************** 
- * Window management code : 
- **************************************************************************/
-/*************************************************************************** 
- * IO handling code : 
- **************************************************************************/
-void HandleXEvents (AfterShowContext *ctx);
-void AcceptConnection (AfterShowContext *ctx);
-void HandleInput (AfterShowContext *ctx, int client);
-void HandleOutput (AfterShowContext *ctx, int client);
-void HandleXML (AfterShowContext *ctx, int client);
-
-void 
-HandleEvents (AfterShowContext *ctx)
-{
-	while (ctx->gui.x.valid || ctx->gui.win32.valid)
-	{
-		fd_set  in_fdset, out_fdset;
-		int     retval;
-		int 	i = ctx->fd_width;
-		/* struct timeval tv; */
-		struct timeval *t = NULL;
-    	int           max_fd = ctx->min_fd;
-		AfterShowClient *clients = ctx->clients;
-		LOCAL_DEBUG_OUT( "waiting pipes%s", "");
-		FD_ZERO (&in_fdset);
-		FD_ZERO (&out_fdset);
-
-#ifndef X_DISPLAY_MISSING
-		if (ctx->gui.x.valid && ctx->gui.x.serviced_screens_num)
-		{
-			FD_SET (ctx->gui.x.fd, &in_fdset);
-			XSync (ctx->gui.x.dpy, False);
-		}
-#endif
-		FD_SET(ctx->socket_fd, &in_fdset);
-		for ( i = ctx->fd_width; --i >= 0; )
-			if (clients[i].fd > 0)
-			{
-				LOCAL_DEBUG_OUT("setting in_fdset for client %d", clients[i].fd);
-
-				FD_SET(clients[i].fd, &in_fdset);
-				if (clients[i].fd > max_fd)
-					max_fd = clients[i].fd;
-				if (clients[i].xml_output_buf->used > 0 || clients[i].xml_output_head)
-					FD_SET(clients[i].fd, &out_fdset);
-			}
-
-	    retval = PORTABLE_SELECT(min (max_fd + 1, ctx->fd_width),&in_fdset,&out_fdset,NULL,t);
-		LOCAL_DEBUG_OUT("SELECT RETURNED %d", retval);
-
-		if (retval > 0)
-		{	
-			if (FD_ISSET (ctx->socket_fd, &in_fdset))
-				AcceptConnection (ctx);
-			
-#ifndef X_DISPLAY_MISSING
-			if (FD_ISSET (ctx->gui.x.fd, &in_fdset))
-				HandleXEvents (ctx);
-#endif
-			
-			for (i = min(max_fd,ctx->fd_width); i >= 0; --i)
-				if (i != ctx->socket_fd)
-				{
-					if (FD_ISSET (i, &in_fdset))
-						HandleInput (ctx, i);
-					if (FD_ISSET (i, &out_fdset))
-						HandleOutput (ctx, i);
-				}
-		}
-
-		for (i = min(max_fd,ctx->fd_width); i >= 0; --i)
-			if (clients[i].xml_input_head)
-				HandleXML (ctx, i);
-	}
-}
-
-void 
-HandleXEvents (AfterShowContext *ctx)
-{
-#ifndef X_DISPLAY_MISSING
-	int events_count = XEventsQueued (ctx->gui.x.dpy, QueuedAfterReading);
-	AfterShowXScreen *scr;
-	AfterShowXWindow *window;
-	while (events_count > 0 && ctx->gui.x.valid)
-	{
-		XEvent e;	
-		XNextEvent (ctx->gui.x.dpy, &e);
-		--events_count;
-		switch (e.type)
-		{
-			case Expose :
-				if ((window = aftershow_XWindowID2XWindow (ctx, e.xexpose.window)) != NULL)
-				{
-					/* TODO: aggregate Expose events to a bigger area ! */
-					aftershow_ExposeXWindowArea (ctx, window, e.xexpose.x, e.xexpose.y,
-													e.xexpose.width + e.xexpose.x, 
-													e.xexpose.height + e.xexpose.y);
-				}
-				break;
-			case PropertyNotify: break;
-			case SelectionClear:	
-				if ((scr = aftershow_XWindowID2XScreen (ctx, e.xselectionclear.window)) != NULL)
-				{
-					if (e.xselectionclear.window == scr->selection_window 
-						&& e.xselectionclear.selection == scr->_XA_AFTERSHOW_S)
-					{ /* we can give up selection if time of the event
-					   * after time of us accuring the selection  and WE DON'T HAVE ANY 
-					   * ACTIVE CONNECTIONS OF THAT SCREEN! */
-						if (e.xselectionclear.time > scr->selection_time 
-							&& scr->windows->items_num <= 0)
-						{
-							ShutdownXScreen (ctx, scr->screen);
-							if (!ctx->gui.x.valid && !ctx->gui.win32.valid)
-									Shutdown (ctx);
-							continue;
-						}
-					}
-				}
-				break;
-		} 
-	}
-#endif	
-}
-
-void 
-AcceptConnection (AfterShowContext *ctx)
-{
-	int           fd;
-	unsigned int  len = sizeof (struct sockaddr_un);
-	struct sockaddr_un name;
-
-	fd = accept (ctx->socket_fd, (struct sockaddr *)&name, &len);
-
-	if (fd < 0 && errno != EWOULDBLOCK)
-        show_system_error("error accepting connection");
-
-	/* set non-blocking I/O mode */
-	if (fd >= 0)
-	{
-		if (fcntl (fd, F_SETFL, fcntl (fd, F_GETFL) | O_NONBLOCK) == -1)
-		{
-            show_system_error("unable to set non-blocking I/O for module socket");
-			close (fd);
-			fd = -1;
-		}
-	}
-	if (fd >= 0) 
-	{
-		if (fd < ctx->fd_width)
-		{
-			ctx->clients[fd].fd = fd;
-			ctx->clients[fd].xml_input_buf = safecalloc( 1, sizeof(ASXmlBuffer));
-			ctx->clients[fd].xml_output_buf = safecalloc( 1, sizeof(ASXmlBuffer));
-			show_progress( "accepted new connection with fd %d.", fd );
-		}else
-        {/* this should never happen, but just in case : */
-            show_error("too many connections!");
-			close (fd);
-            fd = -1 ;
-		}
-    }
-}
-
-void 
-HandleInput (AfterShowContext *ctx, int channel)
-{
-	AfterShowClient *client = &(ctx->clients[channel]);
-
-#define READ_BUF_SIZE	4096	
-	static char read_buf[READ_BUF_SIZE];
-	int bytes_in;
-	
-	errno = 0;
-	bytes_in = read (client->fd, &(read_buf[0]), READ_BUF_SIZE);
-
-	LOCAL_DEBUG_OUT ("%d bytes read from client %d, errno = %d", bytes_in, client->fd, errno);
-
-	if (bytes_in == 0)
-	{
-		if (errno != EINTR && errno != EAGAIN)
-			ShutdownClient (ctx, channel);
-	}else
-	{
-		int i = 0;
-		while (i < bytes_in) 
-		{
-			struct ASXmlBuffer *xb = client->xml_input_buf;
-			LOCAL_DEBUG_OUT ("i = %d, state = %d", i, xb->state);
-
-			while (xb->state >= 0 && i < bytes_in)
-			{
-				int spooled_count = spool_xml_tag (xb, &read_buf[i], bytes_in - i);
-				LOCAL_DEBUG_OUT ("i = %d, spooled_count = %d\n", i, spooled_count);
-				if (spooled_count <= 0)
-					++i;
-				else
-					i += spooled_count;
-
-				if( xb->state == ASXML_Start && xb->tags_count > 0 && xb->level == 0) 
-				{
-					xml_elem_t* doc;
-
-					add_xml_buffer_chars( xb, "", 1 );
-					LOCAL_DEBUG_OUT("buffer: [%s]", xb->buffer );
-
-					if ((doc = aftershow_parse_xml_doc(xb->buffer)) != NULL)
-						aftershow_add_tags_to_queue (doc, &(client->xml_input_head), &(client->xml_input_tail));
-					reset_xml_buffer( xb );
-				}
-			}
-			if (xb->state < 0)
-			{
-				xml_elem_t* err_xml = format_xml_buffer_state (xb);
-				aftershow_add_tags_to_queue (err_xml, &(client->xml_output_head), &(client->xml_output_tail));
-				reset_xml_buffer (xb);
-			}
-		}		   
-	}
-}
-
-void 
-HandleOutput (AfterShowContext *ctx, int channel)
-{
-	AfterShowClient *client = &(ctx->clients[channel]);
-	ASXmlBuffer *xb = client->xml_output_buf;
-	if (client->fd <= 0 || xb == NULL)
-		return;
-	while (client->xml_output_head || xb->used > 0)
-	{
-		xml_elem_t *tmp = client->xml_output_head;
-		if (xb->used > xb->current)
-		{
-			int bytes_out;
-
-			errno = 0;
-			bytes_out = write (client->fd, &(xb->buffer[xb->current]), xb->used - xb->current);
-			if (bytes_out == 0)
-			{
-				if (errno != EINTR && errno != EAGAIN)
-					ShutdownClient (ctx, channel);
-				return;
-			}
-			xb->current += bytes_out;
-			if (xb->used > xb->current)
-				return; /* can't write anymore - need to select to wait for data to be processed! */
-
-			reset_xml_buffer (xb);
-		}
-		if (tmp)
-		{
-			xml_tags2xml_buffer( tmp, xb, 1/* one tag at a time */, 
-								 -1/* no formatting with identing */ );
-			client->xml_output_head = tmp->next;
-			if (tmp->next == NULL || tmp == client->xml_output_tail)	
-				client->xml_output_tail = NULL;
-
-			tmp->next = NULL;
-			xml_elem_delete (NULL, tmp);		
-		}
-	}
-	
-}
-
-/* The XML has to be in the following format : 
- 
- <window id="window_id" [default=0|1] [screen="screen_no"] [geometry="geom_string] [parent="parent_window_id"]>
-   	possibly 0 or more child <window> tags 
-	<layer id="layer_id" x="x" y="y" width="width" height="height">
-		single image or composite tag
-	</layer>
-   	possibly 0 or more overlaping <Layer> tags 
- </window>
- 
- If encompasing <window> tag is missing - default client's window is assumed.
- If encompasing <layer> tag is missing - first layer of the window is assumed.
- 
-
-*/
-
-typedef struct AfterShowTagParams
-{
-	enum {AfterShowTag_Unknown = 0, AfterShowTag_Window, AfterShowTag_Layer, AfterShowTag_Image} type;
-	char *id;
-	int x, y, width, height;
-	char *window_id;
-	char *layer_id;
-}AfterShowTagParams;
-
-typedef struct AfterShowTagContext
-{
-	AfterShowClient 	*client;
-	
-	AfterShowMagicPtr 	window;
-	AfterShowMagicPtr 	layer;
-}AfterShowTagContext;
-
-void ParseTagParams (AfterShowContext *ctx, int channel, xml_elem_t *tag, AfterShowTagParams *params);
-xml_elem_t *HandleWindowTag (AfterShowContext *ctx, AfterShowTagContext *tag_ctx, xml_elem_t *window_tag, xml_elem_t *child_tag);
-
-void 
-HandleXML (AfterShowContext *ctx, int channel)
-{
-	AfterShowClient *client = &(ctx->clients[channel]);
-
-	/* the fun part ! */
-	while (client->xml_input_head)
-	{
-		xml_elem_t *container, *tag;
-		xml_elem_t *result = NULL;
-
-		container = tag = client->xml_output_head;
-		/* remove tag from the input queue */
-
-		client->xml_input_head = tag->next;
-		if (tag->next == NULL || tag == client->xml_input_tail)	
-			client->xml_input_tail = NULL;
-		tag->next = NULL;
-
-		/* now lets handle the tag ! */
-		while (tag && tag->tag_id == XML_CONTAINER_ID)	tag = tag->child;
-		
-		if (tag)
-		{
-			AfterShowTagContext tag_ctx ; 
-			memset( &tag_ctx, 0x00, sizeof(tag_ctx));
-			tag_ctx.client = client;
-			
-			if (tag->tag_id != AfterShow_window_ID)
-				result = HandleWindowTag( ctx, &tag_ctx, NULL, tag);
-			else
-				result = HandleWindowTag( ctx, &tag_ctx, tag, tag->child);
-		
-			if (result != NULL && client->fd > 0)
-				aftershow_add_tags_to_queue (result, &(client->xml_output_head), &(client->xml_output_tail));
-		}
-		
-		/* delete the tag */
-		xml_elem_delete (NULL, container);
-	}
-
-}
-
-AfterShowMagicPtr
-MakeDefaultWindowForClient(AfterShowContext *ctx, AfterShowClient *client, xml_elem_t *child_tag)
-{
-	AfterShowMagicPtr asmp = {NULL};
-#ifndef X_DISPLAY_MISSING
-	AfterShowXScreen *scr = &(ctx->gui.x.screens[client->default_screen]);
-	int default_width = 100, default_height = 100;
-	
-	asmp.xwindow = aftershow_create_x_window (ctx, &(scr->root), default_width, default_height);
-	XMapWindow( ctx->gui.x.dpy, asmp.xwindow->w);
-#endif
-	return asmp;
-}
-
-xml_elem_t *
-HandleWindowTag (AfterShowContext *ctx, AfterShowTagContext *tag_ctx, xml_elem_t *window_tag, xml_elem_t *child_tag)
-{
-	xml_elem_t *result = NULL;
-	AfterShowMagicPtr window;
-	if (window_tag == NULL)
-	{/* find or create the default window for the client */
-		if (tag_ctx->client->default_window.magic == NULL)
-			tag_ctx->client->default_window = MakeDefaultWindowForClient(ctx, tag_ctx->client, child_tag);
-			
-		window = tag_ctx->client->default_window ; 
-	}else
-	{/* either find existing window or create a new one */
-	
-	}
-	if (tag_ctx->window.magic == NULL)
-	{/* return error */
-	
-	}else		
-	{
-	
-	}
-	
-	return result;
-}
-
-#if 0
-
-xml_elem_t *
-HandleLayerTag (AfterShowContext *ctx, int channel, xml_elem_t *tag, AfterShowTagParams *params)
-{
-	xml_elem_t *result = NULL;
-	AfterShowClient *client = &(ctx->clients[channel]);
-
-	return result;
-}
-
-xml_elem_t *
-HandleImageTag (AfterShowContext *ctx, int channel, xml_elem_t *tag, AfterShowTagParams *params)
-{
-	AfterShowClient *client = GetClient(ctx, channel);
-	xml_elem_t *result = NULL;
-	ASImage *im = NULL;
-
-	if (client == NULL)
-		return NULL;
-	
-	im = compose_asimage_xml_from_doc(asv, client->imman, client->fontman, tag, ASFLAGS_EVERYTHING, False, None, NULL, -1, -1);
-
-	if( im ) 
-	{
-		/* Display the image. */
-/		RenderImage (ctx, client, im, params);
-		safe_asimage_destroy(im);
-	}					
-	/* printf("<success tag_count=%d/>\n", xb.tags_count ); */
-
-	return result;
-}
-
-
-ASMagic *client_id2object(AfterShowContext *ctx, int channel, const char *id)
-{
-	/* TODO : implement object search by name */
-	return NULL;
-}
-
-void ParseTagParams (AfterShowContext *ctx, int channel, xml_elem_t *tag, AfterShowTagParams *params)
-{
-	xml_elem_t *tmp, *parm = xml_parse_parm(tag->parm, NULL);
-	memset (params, 0x00, sizeof(AfterShowTagParams));
-	if (parm)
-	{
-		char *x_str = NULL, *y_str = NULL, *width_str = NULL, *height_str = NULL;
-		char *ref_id = NULL;
-		int ref_width = 0, ref_height = 0;
-		AfterShowMagicPtr ref_obj;
-		
-		if (strcmp(tag->tag, "window") == 0)
-			params->type = AfterShowTag_Window;
-		else if (strcmp(tag->tag, "layer") == 0)
-			params->type = AfterShowTag_Layer;
-		else
-			params->type = AfterShowTag_Image;
-						
-		for (tmp = parm ; tmp ; tmp = tmp->next)
-		{
-			if (!strcmp(tmp->tag, "x")) 			x_str = tmp->parm;
-			else if (!strcmp(tmp->tag, "y")) 		y_str = tmp->parm;
-			else if (!strcmp(tmp->tag, "width")) 	width_str = tmp->parm;
-			else if (!strcmp(tmp->tag, "height")) 	height_str = tmp->parm;
-			else if (!strcmp(tmp->tag, "refid")) 	ref_obj.magic = client_id2object(ctx, channel, tmp->parm);
-			else if (!strcmp(tmp->tag, "wid")) 		params->window_id = strdup(tmp->parm);
-			else if (!strcmp(tmp->tag, "lid")) 		params->layer_id = strdup(tmp->parm);
-			else if (!strcmp(tmp->tag, "id")) 		params->id = strdup(tmp->parm);
-		}
-		
-		if (ref_obj.magic)
-		{
-			if (ref_obj.magic->magic == MAGIC_ASIMAGE)
-			{
-				ref_width = ref_obj.asim->width;
-				ref_height = ref_obj.asim->height;
-			}else if (ref_obj.magic->magic == MAGIC_AFTERSHOW_X_WINDOW)
-			{
-				ref_width = ref_obj.xwindow->width;
-				ref_height = ref_obj.xwindow->height;
-			}else if (ref_obj.magic->magic == MAGIC_AFTERSHOW_X_LAYER)
-			{
-				ref_width = ref_obj.xlayer->width;
-				ref_height = ref_obj.xlayer->height;
-			}else
-			{
-				
-			}
-		}
-		if (x_str)	params->x = parse_math (x_str, NULL, ref_width);
-		if (y_str)	params->y = parse_math (y_str, NULL, ref_width);
-		if (width_str)	params->width = parse_math (width_str, NULL, ref_width);
-		if (height_str)	params->height = parse_math (height_str, NULL, ref_width);
-		
-		xml_elem_delete(NULL, parm);
-	}
-}
-
-AfterShowMagicPtr
-GetWindowForClient(AfterShowContext *ctx, AfterShowClient *client, 
-					const char *id, int default_width, int default_height)
-
-
-
-static inline AfterShowXScreen *GetWindowScreen (AfterShowXWindow *window) { return window->screen; };
-static inline AfterShowClient *GetClient (AfterShowContext *ctx, int channel)
-{
-	if (ctx->clients[channel].fd == 0)
-		return NULL;
-	return &(ctx->clients[channel]);
-}
-
-AfterShowMagicPtr
-GetWindowForClient(AfterShowContext *ctx, AfterShowClient *client, 
-					const char *id, int default_width, int default_height)
-{
-#ifndef X_DISPLAY_MISSING
-	AfterShowXWindow *window = NULL;
-	
-	if (client->default_window.magic)
-		if (client->default_window.magic->magic == MAGIC_AFTERSHOW_X_WINDOW)
-			window = client->default_window.xwindow;
-	if (id)
-	{
-		/* try and fetch window from the list by name */
-		
-	}
-	if (window == NULL)
-	{
-		AfterShowXScreen *scr = &(ctx->gui.x.screens[client->default_screen]);
-		window = aftershow_create_x_window (ctx, &(scr->root), default_width, default_height);
-		XMapWindow( ctx->gui.x.dpy, window->w);
-		
-		if (id)
-		{
-			/* store window for future reference under the id */
-		}
-		if (client->default_window.xwindow == NULL)
-			client->default_window.xwindow = window;
-	}
-	return (AfterShowMagicPtr)window;
-#else	
-	return NULL;
-#endif
-}
-
-AfterShowXLayer *
-GetLayerForClientWindow(AfterShowContext *ctx, AfterShowClient *client, 
-                        AfterShowXWindow *window, const char *id)
-{
-#ifndef X_DISPLAY_MISSING
-	AfterShowXLayer *layer = NULL;
-	
-	if (client->default_layer.magic)
-		if (client->default_layer.magic->magic == MAGIC_AFTERSHOW_X_LAYER)
-			layer = client->default_layer.xlayer;
-			
-	if (id)
-	{
-		/* try and fetch layer from the list by name */
-		
-	}
-	if (layer == NULL)
-	{
-		layer = aftershow_create_x_layer (ctx, window);
-		if (id)
-		{
-			/* store layer for future reference under the id */
-		}
-		if (client->default_layer.xlayer == NULL)
-			client->default_layer.xlayer = layer;
-	}
-	
-	return layer;
-#else	
-	return NULL;
-#endif
-}
-
-
-void RenderImage (AfterShowContext *ctx, AfterShowClient *client, ASImage *im, AfterShowTagParams *params)
-{
-#ifndef X_DISPLAY_MISSING
-	AfterShowXWindow *window = GetWindowForClient(ctx, client, params->window_id, im->width, im->height);
-	if (window != NULL)
-	{
-		AfterShowXLayer *layer = GetLayerForClientWindow(ctx, client, window, params->layer_id);
-		if (layer != NULL)
-		{
-			aftershow_ASImage2XLayer (ctx, window, layer, im, params->x, params->y);
-			/* if layer is the only one or synchronous rendering - blend it onto the window */
-			XClearArea( ctx->gui.x.dpy, window->w, 0, 0, 0, 0, True);
-		}
-	}
-#endif
-}
-
-#endif
-
-/*************************************************************************** 
- * final cleanup code : 
- **************************************************************************/
-void 
-ShutdownXScreen (AfterShowContext *ctx, int screen)
-{
-#ifndef X_DISPLAY_MISSING
-	if (ctx->gui.x.valid && screen >= 0 && screen < ctx->gui.x.screens_num)
-	{
-		AfterShowXScreen *scr = &(ctx->gui.x.screens[screen]);
-		if (scr->do_service)
-		{
-			/* close all windows */
-			/* unset event masks */
-			/* close selection window */
-			show_progress( "giving up AfterShow selection on screen %d. This screen is no longer serviced!", screen );
-			XSetSelectionOwner( ctx->gui.x.dpy, scr->_XA_AFTERSHOW_S, None, scr->selection_time);
-			XDestroyWindow (ctx->gui.x.dpy, scr->selection_window);
-			scr->selection_window = None;
-
-			/* destroy the visual */
-			destroy_asvisual (scr->asv, False);
-			scr->asv = NULL;
-			
-			/* mark screen as closed */
-			scr->do_service = False;
-			ctx->gui.x.serviced_screens_num--;
-			if (ctx->gui.x.serviced_screens_num <= 0)
-			{
-				ctx->gui.x.screens_num = 0;
-				ctx->gui.x.fd = -1;
-				XCloseDisplay (ctx->gui.x.dpy);
-				ctx->gui.x.dpy = NULL;
-				ctx->gui.x.valid = False;
-			}
-		}
-	}
-#endif
-}
-
-void 
-ShutdownWin32Screen (AfterShowContext *ctx, int screen)
-{
-
-}
-
-void 
-ShutdownClient (AfterShowContext *ctx, int channel)
-{
-	AfterShowClient *client = &(ctx->clients[channel]);
-
-	if (client->fd)
-	{
-		show_progress( "closing connection to client with fd %d.", client->fd );
-		close (client->fd);
-	}
-
-	if (client->xml_input_buf)
-	{
-		free_xml_buffer_resources (client->xml_input_buf);
-		free (client->xml_input_buf);
-	}
-
-	if (client->xml_output_buf)
-	{
-		free_xml_buffer_resources (client->xml_output_buf);
-		free (client->xml_output_buf);
-	}
-	
-	memset( client, 0x00, sizeof(AfterShowClient));		
-}
-
-
-void 
-Shutdown (AfterShowContext *ctx)
-{
-	int i;
-	for (i = 0 ; i < ctx->gui.x.screens_num && ctx->gui.x.valid; ++i)
-		ShutdownXScreen (ctx, i);
-
-	for (i = 0 ; i < ctx->gui.win32.screens_num && ctx->gui.win32.valid; ++i)
-		ShutdownWin32Screen (ctx, i);
-}
-
-
-/* ********************************************************************************/
-/* The end !!!! 																 */
-/* ********************************************************************************/
-
diff -Naur libAfterImage-1.20/aftershow/aftershow.h root/graf2d/asimage/src/libAfterImage/aftershow/aftershow.h
--- libAfterImage-1.20/aftershow/aftershow.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/aftershow/aftershow.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,209 +0,0 @@
-#ifndef AFTERSHOW_H_INCLUDED
-#define AFTERSHOW_H_INCLUDED
-
-#ifndef STDIN_FILENO
-# define STDIN_FILENO   0
-# define STDOUT_FILENO  1
-# define STDERR_FILENO  2
-#endif
-
-#if !defined (EACCESS) && defined(EAGAIN)
-# define EACCESS EAGAIN
-#endif
-
-#ifndef EXIT_SUCCESS            /* missing from <stdlib.h> */
-# define EXIT_SUCCESS           0       /* exit function success */
-# define EXIT_FAILURE           1       /* exit function failure */
-#endif
-
-
-#define MAGIC_AFTERSHOW_X_LAYER		0xAF501A73
-#define MAGIC_AFTERSHOW_X_WINDOW	0xAF50814D
-#define MAGIC_AFTERSHOW_X_SCREEN	0xAF503C4E
-#define MAGIC_AFTERSHOW_X_GUI		0xAF507201
-#define MAGIC_AFTERSHOW_WIN32_GUI	0xAF507232
-
-typedef struct AfterShowXLayer
-{
-
-	unsigned long magic;
-	int x, y, width, height;
-#ifndef X_DISPLAY_MISSING
-	Pixmap pmap;
-	int pmap_width, pmap_height;
-#endif
-}AfterShowXLayer;
-
-struct AfterShowXScreen;
-
-typedef struct AfterShowXWindow
-{
-	unsigned long magic;
-	int layers_num, default_layer;
-	AfterShowXLayer *layers;
-	struct AfterShowXScreen *screen;
-	
-#ifndef X_DISPLAY_MISSING
-	Window 	w;
-	int width, height;
-	Pixmap  back;
-	GC 		gc ;	
-	int 	depth;
-	int 	back_width, back_height;
-#endif
-}AfterShowXWindow;
-
-typedef struct AfterShowXScreen
-{
-	unsigned long magic;
-	Bool 		do_service;
-	int 		screen;
-
-	AfterShowXWindow root; /* not part of the above list */
-
-	ASHashTable *windows;
-
-#ifndef X_DISPLAY_MISSING
-	ASVisual   *asv;
-	Window 		selection_window;
-	Atom   		_XA_AFTERSHOW_S;
-	Time 		selection_time;
-	
-#endif
-}AfterShowXScreen;
-
-typedef struct AfterShowXGUI
-{
-	unsigned long magic;
-	Bool 		valid;
-	int 		screens_num;
-	int 		serviced_screens_num;
-	int 		first_screen;
-
-#ifndef X_DISPLAY_MISSING
-	Display    *dpy;
-	int 		fd;
-	AfterShowXScreen  *screens;
-#endif	
-}AfterShowXGUI;
-
-typedef struct AfterShowWin32GUI
-{
-	unsigned long magic;
-	Bool 		valid;
-	int 		screens_num;
-	int 		serviced_screens_num;
-	int 		first_screen;
-
-#ifdef WIN32
-	int 		root_width, root_height;
-#endif	
-}AfterShowWin32GUI;
-
-struct ASXmlBuffer;
-
-typedef union
-{
-	ASMagic 				*magic;
-	ASImage 				*asim;
-	AfterShowXLayer			*xlayer;
-	AfterShowXWindow		*xwindow;
-	AfterShowXScreen		*xscreen;
-	AfterShowXGUI			*xgui;
-	AfterShowWin32GUI		*win32gui;
-}AfterShowMagicPtr;
-
-typedef struct AfterShowClient
-{
-	int 				 fd;
-	struct ASXmlBuffer 	*xml_input_buf; 
-	struct xml_elem_t	*xml_input_head, *xml_input_tail;
-	struct xml_elem_t	*xml_output_head, *xml_output_tail;
-	struct ASXmlBuffer 	*xml_output_buf; 
-	
-	AfterShowMagicPtr 	 default_gui;		/* could be either x or win32 */
-	int 				 default_screen;
-	AfterShowMagicPtr 	 default_window;	/* could be either x or win32 */
-	ASImageManager 		 imman;				/* if NULL - use the shared one */
-	ASFontManager 		 fontman;			/* if NULL - use the shared one */
-}AfterShowClient;
-
-typedef struct AfterShowContext
-{
-#define AfterShow_DoFork		(0x01<<0)
-#define AfterShow_SingleScreen	(0x01<<1)
-	ASFlagType 	 flags;
-	
-	char   		*display;
-	
-	struct {
-		AfterShowXGUI  		x;
-		AfterShowWin32GUI	win32;
-	} gui;
-
-	char   		*socket_name;
-	int 		 socket_fd;
-	int 		 min_fd; /* max (socket_fd, x.fd) */
-	int 		 fd_width;	
-	
-	AfterShowClient	*clients; /* array of fd_width elements */
-
-	ASImageManager 	*imman;		/* shared image manager */
-	ASFontManager 	*fontman;	/* shared font manager */
-
-}AfterShowContext;
-
-
-
-
-/***** from xutil.c */
-#ifndef X_DISPLAY_MISSING
-
-#define XA_AFTERSHOW_SOCKET_NAME "_AFTERSHOW_SOCKET"
-
-AfterShowXWindow* aftershow_XWindowID2XWindow (AfterShowContext *ctx, Window w);
-AfterShowXScreen* aftershow_XWindowID2XScreen (AfterShowContext *ctx, Window w);
-
-Bool aftershow_connect_x_gui(AfterShowContext *ctx);
-
-Bool aftershow_get_drawable_size_and_depth ( AfterShowContext *ctx,
-											 Drawable d, 
-											 int *width_return, 
-											 int *height_return, 
-											 int *depth_return);
-Bool aftershow_validate_drawable (AfterShowContext *ctx, Drawable d);
-void aftershow_set_string_property (AfterShowContext *ctx, Window w, Atom property, char *data);
-char *aftershow_read_string_property (AfterShowContext *ctx, Window w, Atom property);
-AfterShowXWindow *aftershow_create_x_window (AfterShowContext *ctx, AfterShowXWindow *parent, int width, int height);
-AfterShowXLayer *aftershow_create_x_layer (AfterShowContext *ctx, AfterShowXWindow *window);
-Bool aftershow_ASImage2XLayer ( AfterShowContext *ctx, AfterShowXWindow *window, 
-								AfterShowXLayer *layer, ASImage *im,  int dst_x, int dst_y);
-void aftershow_ExposeXWindowArea (AfterShowContext *ctx, AfterShowXWindow *window, int left, int top, int right, int bottom);
-
-#endif
-
-/***** from xmlutil.c */
-
-typedef enum
-{
-	AfterShow_unknown_ID = 0,
-	AfterShow_x_ID,
-	AfterShow_y_ID,
-	AfterShow_id_ID,
-	AfterShow_layer_ID,
-	AfterShow_width_ID,
-	AfterShow_height_ID,
-	AfterShow_parent_ID,
-	AfterShow_screen_ID,	
-	AfterShow_window_ID,
-	AfterShow_geometry_ID,	
-	AfterShow_SUPPORTED_IDS
-
-}SupportedAfterShowXMLTagIDs;
-
-void aftershow_add_tags_to_queue( xml_elem_t* tags, xml_elem_t **phead, xml_elem_t **ptail);
-void aftershow_init_vocabulary (Bool free_resources);
-xml_elem_t *aftershow_parse_xml_doc (const char *doc);
-
-
-#endif /* AFTERSHOW_H_INCLUDED */
diff -Naur libAfterImage-1.20/aftershow/aftershow_pipe.c root/graf2d/asimage/src/libAfterImage/aftershow/aftershow_pipe.c
--- libAfterImage-1.20/aftershow/aftershow_pipe.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/aftershow/aftershow_pipe.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,299 +0,0 @@
-/*
- * Copyright (c) 2008 Sasha Vasko <sasha at aftercode.net>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/*********************************************************************************
- * Utility functions to handle X stuff
- *********************************************************************************/
-
-#ifdef _WIN32
-#include "../win32/config.h"
-#else
-#include "../config.h"
-#endif
-
-#define LOCAL_DEBUG
-
-#include <string.h>
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#ifdef HAVE_STDLIB_H
-#include <stdlib.h>
-#endif
-#include <errno.h>
-#include <sys/file.h>
-#include <sys/socket.h>
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "aftershow.h"
-
-Bool InitContext (AfterShowContext *context, int argc, char **argv);
-Bool ConnectGUI (AfterShowContext *context);
-Bool SetupComms (AfterShowContext *context);
-void HandleEvents (AfterShowContext *context);
-void Shutdown (AfterShowContext *ctx);
-
-void show_usage (Bool short_form)
-{
-	printf( "AfterShow Pipe - tool to redirect stdin and stdout to and from AfterShow - \n"
-			"                 AfterImage XML processing and display daemon.\n"
-			"Usage: aftershow_pipe [-h|--help] [-d|--display display_string] [-V level]\n"
-			"  -h --help      	- display this message;\n"
-			"  -d --display display_string - connect to X display specified by display_string;\n"
-			"  -V level     	- set output verbosity level - 0 for no output;\n" );
-}
-
-int main (int argc, char **argv)
-{
-	AfterShowContext context;
-	int cmd_start;
-	/* 
-	 * 1) Connect to windowing system
-	 * 2) Check for another instance running for the same user
-	 * 3) Create UD Socket
-	 * 4) Handle Events
-	 */
-	set_application_name(argv[0]);
-	set_output_threshold(5);  /* be real quiet by default ! */
-
-	for (cmd_start = 1 ; cmd_start < argc; cmd_start++)
-		if (strcmp(argv[cmd_start], "-c") ==0)
-			break;
-			
-	if (!InitContext(&context, argc, argv))
-		return EXIT_FAILURE;
-
-	if (!ConnectGUI(&context))
-		return EXIT_FAILURE;
-
-	if (!SetupComms(&context))
-	{
-		show_error( "AfterShow daemon is not available. Exiting!");
-		return EXIT_FAILURE;
-	}
-
-	if (cmd_start < argc-1)
-	{
-		dup2 (context.socket_fd, 0);
-		dup2 (context.socket_fd, 1);
-		// do exec without fork here
-	}else
-	{	/* we have to manually redirect io */
-		HandleEvents(&context);
-	}
-	close (context.socket_fd);		
-
-	return EXIT_SUCCESS;
-}
-
-/**********************************************************************************
- * Implementation : 
- **********************************************************************************/
-Bool InitContext (AfterShowContext *ctx, int argc, char **argv)
-{
-	int i;
-	memset( ctx, 0x00, sizeof(AfterShowContext));
-	set_flags(ctx->flags, AfterShow_SingleScreen); /* single screen always ! */
-	
-	for (i = 1 ; i < argc ; ++i) 
-	{
-		if (argv[i][0] == '-')
-		{
-			if (argv[i][1] != '-') /* short option */
-			{
-				if (argv[i][2] == '\0')
-					switch (argv[i][1])
-					{
-						case 'h': 	show_usage(False); return False;
-						case 'V': 	if (i + 1 < argc)
-										set_output_threshold(atoi(argv[++i]));
-									break;
-						case 'd': 	if (i + 1 < argc)
-									{
-										if (ctx->display) 
-											free (ctx->display);
-										ctx->display = strdup(argv[++i]);
-									}
-									break;
-						default :
-							show_error ("unrecognized option \"%s\"", argv[i]);
-							show_usage(False); 
-							return False;
-					}
-			}else /* long option */
-			{
-				if (strcmp(&(argv[i][2]), "help") == 0)
-				{ 
-					show_usage(False); return False; 
-				}else if (strcmp(&(argv[i][2]), "display") == 0)
-				{ 
-					if (i + 1 < argc)
-					{
-						if (ctx->display) 
-							free (ctx->display);
-						ctx->display = strdup(argv[++i]);
-					}				
-				}else
-				{
-					show_error ("unrecognized option \"%s\"", argv[i]);
-					show_usage(False); 
-					return False;
-				}
-			}
-		}
-	}
-	
-	return True;
-}
-
-Bool ConnectGUI (AfterShowContext *ctx)
-{
-#ifndef X_DISPLAY_MISSING
-	aftershow_connect_x_gui (ctx);
-#endif
-  /* TODO: add win32 code */
-
-	return 	(ctx->gui.x.valid || ctx->gui.win32.valid);
-}
-
-Bool SetupComms (AfterShowContext *ctx)
-{
-#ifndef X_DISPLAY_MISSING
- 	if (ctx->gui.x.valid)
-	{
-		/* get socket name from X property */
-	    ctx->socket_name = aftershow_read_string_property (ctx, 
-												ctx->gui.x.screens[0].root.wcv, 
-												XInternAtom (ctx->gui.x.dpy, XA_AFTERSHOW_SOCKET_NAME, False));
-	} 
-#endif
-	if (ctx->socket_name == NULL)
-		return False;
-		
-	show_progress ("Socket name set to \"%s\".", ctx->socket_name);
-	
-	ctx->min_fd = ctx->socket_fd = socket_connect_client (ctx->socket_name);
-	fcntl (ctx->socket_fd, F_SETFL, fcntl (ctx->socket_fd, F_GETFL) | O_NONBLOCK);
-
-	/* determine max nuber of file descriptors we could have : */
-#ifdef _SC_OPEN_MAX
-	ctx->fd_width = sysconf (_SC_OPEN_MAX);
-#else
-	ctx->fd_width = getdtablesize ();
-#endif
-#ifdef FD_SETSIZE
-	if (ctx->fd_width > FD_SETSIZE)
-		ctx->fd_width = FD_SETSIZE;
-#endif
-
-	ctx->clients = safecalloc (ctx->fd_width, sizeof(AfterShowClient));
-	return (ctx->socket_fd > 0);
-}
-
-void 
-HandleEvents (AfterShowContext *ctx)
-{
-#define IN_BUF_SIZE		16192
-#define OUT_BUF_SIZE	1024
-	char input_buf[IN_BUF_SIZE];
-	int input_size = 0;
-	Bool input_eof = False;
-	
-	while (ctx->gui.x.valid || ctx->gui.win32.valid)
-	{
-		fd_set  in_fdset, out_fdset;
-		int     retval;
-		int i;
-		FD_ZERO (&in_fdset);
-		FD_ZERO (&out_fdset);
-
-		LOCAL_DEBUG_OUT( "input_size = %d", input_size);
-		if (input_size > 0)
-		{
-			FD_SET(ctx->socket_fd, &out_fdset);
-		}else
-		{
-			FD_SET(0, &in_fdset);
-		}
-			
-		FD_SET(ctx->socket_fd, &in_fdset);
-
-		LOCAL_DEBUG_OUT( "waiting pipes%s", "");
-	    retval = PORTABLE_SELECT(ctx->socket_fd+1,&in_fdset,&out_fdset,NULL,NULL);
-		LOCAL_DEBUG_OUT( "result = %d", retval);
-
-		if (retval > 0)
-		{	
-			if (FD_ISSET (ctx->socket_fd, &in_fdset))
-			{
-				char *buf[OUT_BUF_SIZE];
-				int bytes_in;
-				errno = 0;
-				while ((bytes_in = read( ctx->socket_fd, &buf[0], OUT_BUF_SIZE)) > 0)
-					write( 1, &(buf[0]), bytes_in);
-				if (bytes_in > 0)
-					write( 1, "\n", 1);
-				if (bytes_in == 0 && errno != EINTR && errno != EAGAIN)
-				{
-					show_progress( "AfterShow Server has closed the connection. Exiting.");
-					return;
-				}
-				LOCAL_DEBUG_OUT( "bytes_in = %d, errno = %d", bytes_in, errno);				
-			}
-			if (FD_ISSET (ctx->socket_fd, &out_fdset))
-			{
-				/* write input buffer out to server */
-				int bytes_out;
-
-				errno = 0;
-				bytes_out = write (ctx->socket_fd, &(input_buf[0]), input_size);
-				LOCAL_DEBUG_OUT("%d bytes sent.", bytes_out);
-
-				if (bytes_out == 0 && errno != EINTR && errno != EAGAIN)
-				{
-					show_progress( "AfterShow Server has closed the connection. Exiting.");
-					return;
-				}
-				if (bytes_out > 0)
-				{
-					for (i = 0; i < input_size-bytes_out; ++i)
-						input_buf[i] = input_buf[i+bytes_out];
-					input_size -= bytes_out;	
-					if (input_size == 0 && input_eof)
-						return;
-				}
-			}
-			if (FD_ISSET (0, &in_fdset))
-			{
-				/* fill input buffer from stdin */
-				input_size = read( 0, &(input_buf[0]), IN_BUF_SIZE);
-				if (input_size == 0) /* EOF */
-					return;
-				input_eof = (input_buf[input_size-1] == EOF);
-				LOCAL_DEBUG_OUT("%d bytes read. eof = %d", input_size, input_eof);
-			}
-		}
-
-	}
-}
-
-/*********************************************************************************
- * The end !!!! 																 
- ********************************************************************************/
-
diff -Naur libAfterImage-1.20/aftershow/xmlutil.c root/graf2d/asimage/src/libAfterImage/aftershow/xmlutil.c
--- libAfterImage-1.20/aftershow/xmlutil.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/aftershow/xmlutil.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,89 +0,0 @@
-/*
- * Copyright (c) 2008 Sasha Vasko <sasha at aftercode.net>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/*********************************************************************************
- * Utility functions to handle X stuff
- *********************************************************************************/
-
-#ifdef _WIN32
-#include "../win32/config.h"
-#else
-#include "../config.h"
-#endif
-
-#undef LOCAL_DEBUG
-
-#include <string.h>
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "aftershow.h"
-
-ASHashTable *AfterShowVocabulary = NULL;
-
-void 
-aftershow_init_vocabulary (Bool free_resources)
-{
-	if (free_resources)
-	{
-		if (AfterShowVocabulary)
-			destroy_ashash (&AfterShowVocabulary);
-		return;
-	}
-	if (AfterShowVocabulary == NULL)
-	{
-		AfterShowVocabulary = create_ashash (7, casestring_hash_value, casestring_compare, string_destroy_without_data);
-#define REGISTER_AFTERSHOW_TAG(tag)	add_hash_item(AfterShowVocabulary,AS_HASHABLE(#tag),(void*)AfterShow_##tag##_ID)
-		REGISTER_AFTERSHOW_TAG(x);
-		REGISTER_AFTERSHOW_TAG(y);
-		REGISTER_AFTERSHOW_TAG(id);
-		REGISTER_AFTERSHOW_TAG(layer);
-		REGISTER_AFTERSHOW_TAG(width);
-		REGISTER_AFTERSHOW_TAG(height);
-		REGISTER_AFTERSHOW_TAG(parent);
-		REGISTER_AFTERSHOW_TAG(screen);
-		REGISTER_AFTERSHOW_TAG(window);
-		REGISTER_AFTERSHOW_TAG(geometry);
-#undef REGISTER_AFTERSHOW_TAG
-	}
-}
-
-xml_elem_t *
-aftershow_parse_xml_doc (const char *doc)
-{
-	if (AfterShowVocabulary == NULL)
-		aftershow_init_vocabulary (False);		
-	return xml_parse_doc (doc, AfterShowVocabulary);
-}
-
-
-void 
-aftershow_add_tags_to_queue( xml_elem_t* tags, xml_elem_t **phead, xml_elem_t **ptail)
-{
-	if (*phead == NULL)
-		*ptail = *phead = tags;
-	else
-		(*ptail)->next = tags;
-	
-	while ((*ptail)->next) *ptail = (*ptail)->next;
-}
-
-/*********************************************************************************
- * The end !!!! 																 
- ********************************************************************************/
-
diff -Naur libAfterImage-1.20/aftershow/xutil.c root/graf2d/asimage/src/libAfterImage/aftershow/xutil.c
--- libAfterImage-1.20/aftershow/xutil.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/aftershow/xutil.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,314 +0,0 @@
-/*
- * Copyright (c) 2008 Sasha Vasko <sasha at aftercode.net>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/*********************************************************************************
- * Utility functions to handle X stuff
- *********************************************************************************/
-
-#ifdef _WIN32
-#include "../win32/config.h"
-#else
-#include "../config.h"
-#endif
-
-#ifndef X_DISPLAY_MISSING
-
-#undef LOCAL_DEBUG
-
-#include <string.h>
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "aftershow.h"
-
-
-AfterShowXWindow* 
-aftershow_XWindowID2XWindow (AfterShowContext *ctx, Window w)
-{
-	ASHashData hdata = {0} ;
-	int i;
-	for (i = 0 ; i < ctx->gui.x.screens_num; ++i)
-	{
-        if (get_hash_item (ctx->gui.x.screens[i].windows, AS_HASHABLE(w), &hdata.vptr) == ASH_Success)
-		    return hdata.vptr;
-	}
-	return NULL;
-}
-
-
-
-AfterShowXScreen* 
-aftershow_XWindowID2XScreen (AfterShowContext *ctx, Window w)
-{
-	int i;
-	AfterShowXWindow* window = NULL;
-	for (i = 0 ; i < ctx->gui.x.screens_num; ++i)
-		if (w == ctx->gui.x.screens[i].selection_window)
-			return &(ctx->gui.x.screens[i]);
-
-	if ((window = aftershow_XWindowID2XWindow (ctx, w)) == NULL)
-		return NULL;
-		
-	return window->screen;
-}
-
-static void
-aftershow_setup_root_x_window (AfterShowContext *ctx, AfterShowXWindow *window)
-{
-	window->w = RootWindow(ctx->gui.x.dpy, window->screen->screen);
-	window->width = DisplayWidth (ctx->gui.x.dpy, window->screen->screen);
-	window->height = DisplayHeight (ctx->gui.x.dpy, window->screen->screen);
-	window->depth = DefaultDepth(ctx->gui.x.dpy, window->screen->screen);
-	
-	window->gc = DefaultGC(ctx->gui.x.dpy, window->screen->screen);
-	window->back = None;
-
-	if (window->back)
-		aftershow_get_drawable_size_and_depth (ctx, window->back, &(window->back_width), &(window->back_height), NULL);
-}
-
-Bool
-aftershow_connect_x_gui(AfterShowContext *ctx)
-{
-	if (!ctx->gui.x.valid)
-	{
-		int i;
-		AfterShowXScreen *scr;
-		ctx->gui.x.dpy = XOpenDisplay(ctx->display);
-		if (ctx->gui.x.dpy != NULL)
-		{
-			ctx->gui.x.fd = XConnectionNumber (ctx->gui.x.dpy);
-			ctx->gui.x.screens_num = get_flags(ctx->flags, AfterShow_SingleScreen)?1:ScreenCount (ctx->gui.x.dpy);	
-			ctx->gui.x.screens = scr = safecalloc(ctx->gui.x.screens_num, sizeof(AfterShowXScreen));
-
-			for (i = 0; i < ctx->gui.x.screens_num; ++i)
-			{
-				scr->screen = i;
-				scr->root.magic = MAGIC_AFTERSHOW_X_WINDOW;
-				scr->root.screen = scr;
-				aftershow_setup_root_x_window (ctx, &(scr->root));
-				scr->windows = create_ashash( 0, NULL, NULL, NULL ); 
-				++scr;
-			}
-			ctx->gui.x.first_screen = 0;
-			ctx->gui.x.valid = True;
-			show_progress( "X display \"%s\" connected. Servicing %d screens.", ctx->display?ctx->display:"", ctx->gui.x.screens_num);
-		}else
-		{
-			if (ctx->display)
-	        	show_error("failed to initialize X Window session for display \"%s\"", ctx->display);
-			else
-				show_error("failed to initialize X Window session for default display");
-		}
-	}
-
-	return ctx->gui.x.valid;
-}
-
-Bool
-aftershow_get_drawable_size_and_depth (AfterShowContext *ctx, Drawable d, int *width_return, int *height_return, int *depth_return)
-{
-	Window root;
-    int junk;
-	unsigned int ujunk, width, height, depth;
-
-    if (d != None)
-  		if (!XGetGeometry (ctx->gui.x.dpy, d, &root, &junk, &junk, &width, &height, &ujunk, &depth))
-			return False;	
-
-	if (width_return)
-		*width_return = width;
-	if (height_return)
-		*height_return = height;
-	if (depth_return)
-		*depth_return = depth;
-	return True;
-}
-
-static int
-nop_error_handler (Display * dpy, XErrorEvent * error)
-{
-	return 0;
-}
-
-
-Bool
-aftershow_validate_drawable (AfterShowContext *ctx, Drawable d)
-{
-	Window root;
-    int junk;
-	unsigned int ujunk ;
-	int (*oldXErrorHandler) (Display *, XErrorEvent *) = XSetErrorHandler (nop_error_handler);
-
-    if (d != None)
-  		if (!XGetGeometry (ctx->gui.x.dpy, d, &root, &junk, &junk, &ujunk, &ujunk, &ujunk, &ujunk))
-			d = None;
-
-	XSetErrorHandler (oldXErrorHandler);
-	return (d != None);
-}
-
-
-void
-aftershow_set_string_property (AfterShowContext *ctx, Window w, Atom property, char *data)
-{
-    if (w != None && property != None && data)
-	{
-		LOCAL_DEBUG_OUT( "setting property %lX on %lX to \"%s\"", property, w, data );
-        XChangeProperty (ctx->gui.x.dpy, w, property, XA_STRING, 8,
-                         PropModeReplace, (unsigned char *)data, strlen (data));
-    }
-}
-
-char * 
-aftershow_read_string_property (AfterShowContext *ctx, Window w, Atom property)
-{
-	char *res = NULL;
-    if (w != None && property != None)
-	{
-        int           actual_format;
-        Atom          actual_type;
-        unsigned long junk;
-		unsigned char *tmp = NULL;
-
-        if (XGetWindowProperty(ctx->gui.x.dpy, w, property, 0, ~0, False, AnyPropertyType, &actual_type,
-             &actual_format, &junk, &junk, &tmp) == Success)
-        {
-            if (actual_type == XA_STRING && actual_format == 8)
-				res = strdup((char*)tmp);
-            XFree (tmp);
-        }
-	}
-	return res;
-}
-
-
-AfterShowXWindow *
-aftershow_create_x_window (AfterShowContext *ctx, AfterShowXWindow *parent, int width, int height)
-{
-	AfterShowXWindow *window = safecalloc( 1, sizeof(AfterShowXWindow));
-	AfterShowXScreen *scr = parent->screen;
-	unsigned long attr_mask = CWEventMask ;
-	XSetWindowAttributes attr;
-
-	window->magic = MAGIC_AFTERSHOW_X_WINDOW;
-	window->screen = scr;
-	
-	attr.event_mask = ExposureMask;
-	
-	window->w = create_visual_window(scr->asv, parent->w, 0, 0, width, height, 0, 
-									 InputOutput, attr_mask, &attr);
-
-	add_hash_item (scr->windows, AS_HASHABLE(window->w), window);
-
-	window->width = width;
-	window->height = height;
-
-	window->back = create_visual_pixmap(scr->asv, window->w, width, height, 0);
-	window->gc = create_visual_gc(scr->asv, window->w, 0, NULL);	
-	window->depth = scr->asv->true_depth;
-	window->back_width = width;
-	window->back_height = height;
-	
-	return window;
-}
-
-AfterShowXLayer *
-aftershow_create_x_layer (AfterShowContext *ctx, AfterShowXWindow *window)
-{
-	AfterShowXLayer *layer = safecalloc( 1, sizeof(AfterShowXLayer));
-	layer->magic = MAGIC_AFTERSHOW_X_LAYER;
-	layer->width = window->width;
-	layer->height = window->height;
-	
-	return layer;
-}
-
-Bool aftershow_ASImage2XLayer ( AfterShowContext *ctx, AfterShowXWindow *window, 
-								AfterShowXLayer *layer, ASImage *im,  int dst_x, int dst_y)
-{ 
-	Bool success = False;
-	AfterShowXScreen *screen = window->screen;
-	XImage *xim = create_visual_scratch_ximage( screen->asv, im->width, im->height, window->depth);
-
-	if( subimage2ximage (screen->asv, im, 0, 0, xim)	)
-	{
-		int dst_width = im->width ;
-		int dst_height = im->height ;
-		if (layer->pmap == None)
-		{
-			layer->pmap = create_visual_pixmap(screen->asv, window->w, window->width, window->height, 0);
-			layer->pmap_width = window->width ;
-			layer->pmap_height = window->height;
-		}
-		if (dst_x < layer->pmap_width && dst_y < layer->pmap_height)
-		{
-			if (dst_width+dst_x > layer->pmap_width)
-				dst_width = layer->pmap_width - dst_x;
-			if (dst_height+dst_y > layer->pmap_height)
-				dst_height = layer->pmap_height - dst_y;
-			put_ximage( screen->asv, xim, layer->pmap, window->gc, 0, 0, dst_x, dst_y, dst_width, dst_height );	
-			success = True;
-		}
-	}
-	XDestroyImage( xim );				  
-	return success;
-}
-
-void 
-aftershow_ExposeXWindowArea (AfterShowContext *ctx, AfterShowXWindow *window, 
-						  	 int left, int top, int right, int bottom)
-{
-	int i;
-	
-	if (right > window->width)
-		right = window->width;
-	if (bottom > window->height)
-		bottom = window->height;
-	if (left >= right || top >= bottom)
-		return;
-	
-	for (i = 0 ; i < window->layers_num ; ++i)
-	{
-		AfterShowXLayer *layer = &(window->layers[i]);
-		if (layer->pmap)
-		{
-			int lx = (layer->x < left)?left - layer->x:0;
-			int ly = (layer->y < top)?top - layer->y:0;
-			int lw = layer->x + layer->width - lx - left;
-			int lh = layer->y + layer->height - ly - top;
-			if (lw > 0 && lh > 0)
-			{
-				if (left + lw > right)
-					lw = right - left;
-				if (top + lh > bottom)
-					lh = bottom - top;
-				
-				XCopyArea( ctx->gui.x.dpy, layer->pmap, window->w, window->gc, lx, ly, lw, lh, left, top);
-			}
-		}
-	}
-
-}
-
-
-#endif 
-/*********************************************************************************
- * The end !!!! 																 
- ********************************************************************************/
-
diff -Naur libAfterImage-1.20/apps/.cvsignore root/graf2d/asimage/src/libAfterImage/apps/.cvsignore
--- libAfterImage-1.20/apps/.cvsignore	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/.cvsignore	1970-01-01 01:00:00.000000000 +0100
@@ -1,9 +0,0 @@
-asview
-asview.jpg
-asscale
-asscale.jpg
-astile
-astile.jpg
-Makefile
-config.h
-.cvsignore
\ No newline at end of file
diff -Naur libAfterImage-1.20/apps/.depend root/graf2d/asimage/src/libAfterImage/apps/.depend
--- libAfterImage-1.20/apps/.depend	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/.depend	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-./common.h:
-
-./config.h:
-
-./ascompose.o: \
-		config.h \
-		../afterbase.h \
-		../afterimage.h \
-		common.h
-
-./asflip.o: \
-		config.h \
-		../afterbase.h \
-		../afterimage.h \
-		common.h
-
-./asgrad.o: \
-		config.h \
-		../afterbase.h \
-		../afterimage.h \
-		common.h
-
-./asi18n.o: \
-		config.h \
-		../afterbase.h \
-		../afterimage.h \
-		common.h \
-		../char2uni.h
-
-./asmerge.o: \
-		config.h \
-		../afterbase.h \
-		../afterimage.h \
-		common.h
-
-./asscale.o: \
-		config.h \
-		../afterbase.h \
-		../afterimage.h \
-		common.h
-
-./astext.o: \
-		config.h \
-		../afterbase.h \
-		../afterimage.h \
-		common.h
-
-./astile.o: \
-		config.h \
-		../afterbase.h \
-		../afterimage.h \
-		common.h
-
-./asvector.o: \
-		config.h \
-		../afterbase.h \
-		../afterimage.h \
-		common.h
-
-./asview.o: \
-		config.h \
-		../afterbase.h \
-		../afterimage.h \
-		common.h
-
-./asview_gl.o: \
-		config.h \
-		../afterbase.h \
-		../afterimage.h \
-		common.h
-
-./common.o: \
-		config.h \
-		../afterbase.h \
-		../afterimage.h
diff -Naur libAfterImage-1.20/apps/Makefile.in root/graf2d/asimage/src/libAfterImage/apps/Makefile.in
--- libAfterImage-1.20/apps/Makefile.in	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/Makefile.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,191 +0,0 @@
-
-PROGS= asview asscale astile asmerge asgrad asflip asi18n astext ascompose asvector ascheckttf
-
-
-CC		= @CC@
-CCFLAGS         = @CFLAGS@
-# -march=pentiumpro -mcpu=pentiumpro
-EXTRA_DEFINES	= @DEFINE_XLOCALE@
-
-RANLIB		= @RANLIB@
-AR		= ar clq
-CP		= @CP@
-MV		= @MV@
-RM		= @RM@
-RMF		= @RM@ -f
-MKDIR		= @MKDIR@
-FIND		= @FIND@
-XARGS		= @XARGS@
-LDCONFIG	= @LDCONFIG@
-
-INSTALL		= @INSTALL@
-INSTALL_PROGRAM	= @INSTALL@ -m 755
-INSTALL_DATA	= @INSTALL@ -m 644
-
-INCS_X		= @X_CFLAGS@
-INCS_PRIVATE    = 
-INCLUDES	= $(INCS_X) $(INCS_PRIVATE) -I..
-
-USER_LD_FLAGS	= @user_ldflags@
-LIBS_X		= @x_libs@
-LIBS_XEXTS	=
-LIBS_AFTERIMAGE = @AFTERIMAGE_APPS_LIBS@
-LIBRARIES	= $(USER_LD_FLAGS) $(LIBS_AFTERIMAGE) $(LIBS_X) $(LIBS_XEXTS)
-
-prefix          = @prefix@
-exec_prefix     = @exec_prefix@
-LIBDIR		= $(DESTDIR)@libdir@
-BIN_DIR		= $(DESTDIR)@bindir@
-MAN_DIR		= $(DESTDIR)@mandir@/man1
-AFTER_DIR	= @with_afterdir@
-
-# need this for dependancies :
-LIBAFTERIMAGE_PATH =..
-LIB_STATIC      = $(LIBAFTERIMAGE_PATH)/libAfterImage.a
-LIB_SHARED      = $(LIBAFTERIMAGE_PATH)/libAfterImage.so
-
-
-all:    $(PROGS)
-
-install.bin:	$(PROGS)
-		@echo "installing libAfterImage apps using command - "; \
-		if [ ! -d $(BIN_DIR) ] ; then 	$(MKDIR) -p $(BIN_DIR); fi; \
-		echo "    \"$(INSTALL_PROGRAM) <app> $(BIN_DIR)\" :"; \
-		for p in $(PROGS); do \
-			echo -n "$$p "; \
-	  		$(INSTALL_PROGRAM) $$p $(BIN_DIR); \
-		done; \
-		echo ""; echo "Done."; \
-
-install.man:
-		@if [ ! -d $(MAN_DIR) ] ; then 	$(MKDIR) -p $(MAN_DIR); fi; \
-		for f in *.man; do \
-		  echo $(INSTALL_DATA) $$f $(MAN_DIR)/`basename $$f`.3x; \
-		  $(INSTALL_DATA) $$f $(MAN_DIR)/`basename $$f`.3x; \
-		done
-
-uninstall.bin:
-		@for p in $(PROGS); do \
-			echo "$(RMF) $(BIN_DIR)/$$p"; \
-			$(RMF) $(BIN_DIR)/$$p; \
-		done
-
-uninstall.man:
-		$(RMF) $(AFTER_MAN_DIR)/$(PROGS).3x
-
-clean:
-		$(RMF) $(PROGS) *.o *~ *% *.bak \#* core
-
-distclean:
-		$(RMF) $(PROGS) *.o *~ *% *.bak \#* *.orig core Makefile
-
-indent:
-		@SRCS=`find . -name "*.c"`; \
-		if test "x$$SRCS" == "x"; then exit; fi; \
-		for i in $$SRCS; do \
-		  if (indent -di14 -ts4 -i4 -l100 -lc80 -bad -nbbb -bli0 -c48 -cd48 -ce -cli1 -ncs -nbs -nbbo -hnl < $$i > /tmp/$$i); then \
-		    echo "indent $$i"; \
-		    mv /tmp/$$i $$i; \
-		  fi; \
-		done
-
-deps:
-		@echo -n > .depend ; \
-		buf="" ; \
-		for f in `find . -name "*.h"` ; do \
-		  if test "x$$buf" != "x"; then \
-		      echo $$buf >>.depend ; \
-		      echo "" >>.depend ; \
-		  fi; \
-		  buf="$$f:"; \
-		  for d in `grep "#include \"" <$$f | awk -F \" '{print $$2}'`; do \
-		      if test "x$$buf" != "x"; then \
-		         echo $$buf \\ >>.depend ; \
-		      fi; \
-		      echo -n "		" >>.depend ; \
-		      buf="$$d "; \
-		  done; \
-		done; \
-		if test "x$$buf" != "x"; then \
-		  echo $$buf >>.depend ; \
-		  buf="" ; \
-		  echo "" >>.depend ; \
-		fi ; \
-		for file in `find . -name "*.c"` ; do \
-		  if test "x$$buf" != "x"; then \
-		      echo $$buf >>.depend ; \
-		      echo >>.depend ; \
-		  fi; \
-		  buf="."`echo $$file | awk -F . '{print $$2}'`".o:" ; \
-		  for d in `grep "#include \"" < $$file | awk -F \" '{print $$2}'`; do \
-		      if test "x$$buf" != "x"; then \
-		         echo $$buf \\ >>.depend ; \
-		      fi; \
-		      echo -n "		" >>.depend ; \
-		      buf="$$d "; \
-		  done; \
-		done; \
-		if test "x$$buf" != "x"; then \
-		  echo $$buf >>.depend ; \
-		fi
-
-asview: asview.o common.o @LIBPROG@
-		$(CC) asview.o common.o $(LIBRARIES) $(EXTRA_LIBRARIES) -o asview
-
-asview_gl: asview_gl.o common.o $(LIB_STATIC)
-		$(CC) asview_gl.o common.o $(LIBRARIES) $(EXTRA_LIBRARIES) -lGL -lGLU -o asview_gl
-
-asscale: asscale.o common.o @LIBPROG@
-		$(CC) asscale.o common.o $(LIBRARIES) $(EXTRA_LIBRARIES) -o asscale
-
-astile: astile.o common.o @LIBPROG@
-		$(CC) astile.o common.o $(LIBRARIES) $(EXTRA_LIBRARIES) -o astile
-
-asmerge: asmerge.o common.o @LIBPROG@
-		$(CC) asmerge.o common.o $(LIBRARIES) $(EXTRA_LIBRARIES) -o asmerge
-
-asgrad: asgrad.o common.o @LIBPROG@
-		$(CC) asgrad.o common.o $(LIBRARIES) $(EXTRA_LIBRARIES) -o asgrad
-
-asflip: asflip.o common.o @LIBPROG@
-		$(CC) asflip.o common.o $(LIBRARIES) $(EXTRA_LIBRARIES) -o asflip
-
-asi18n: asi18n.o common.o @LIBPROG@
-		$(CC) asi18n.o common.o $(LIBRARIES) $(EXTRA_LIBRARIES) -o asi18n
-
-astext: astext.o common.o @LIBPROG@
-		$(CC) astext.o common.o $(LIBRARIES) $(EXTRA_LIBRARIES) -o astext
-
-ascheckttf: ascheckttf.o @LIBPROG@
-		$(CC) ascheckttf.o $(LIBRARIES) $(EXTRA_LIBRARIES) -o ascheckttf
-
-ascompose: ascompose.o common.o @LIBPROG@
-		$(CC) ascompose.o common.o $(LIBRARIES) $(EXTRA_LIBRARIES) -o ascompose
-
-asvector: asvector.o common.o $(LIB_STATIC)
-		$(CC) asvector.o common.o $(LIBRARIES) $(EXTRA_LIBRARIES) -o asvector
-
-
-
-.c.o:
-		$(CC) $(CCFLAGS) $(EXTRA_DEFINES) $(INCLUDES) $(EXTRA_INCLUDES) -c $*.c
-
-.c.s:
-		$(CC) $(CCFLAGS) $(EXTRA_DEFINES) $(INCLUDES) $(EXTRA_INCLUDES) -S $*.c
-
-.lo:	$*.c
-
-
-install:	install.bin
-
-uninstall:	uninstall.bin
-
-include .depend
-
-@LIBAFTERIMAGEFILES@
-
-$(LIBAFTERIMAGE_PATH)/libAfterImage.a: $(LIBAFTERIMAGE_OBJS) $(LIBAFTERIMAGE_INCS)
-		cd $(LIBAFTERIMAGE_PATH)/; ${MAKE} libAfterImage.a
-
-$(LIBAFTERIMAGE_PATH)/libAfterImage.so: $(LIBAFTERIMAGE_OBJS) $(LIBAFTERIMAGE_INCS)
-		cd $(LIBAFTERIMAGE_PATH)/; ${MAKE} libAfterImage.so
diff -Naur libAfterImage-1.20/apps/README root/graf2d/asimage/src/libAfterImage/apps/README
--- libAfterImage-1.20/apps/README	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,48 +0,0 @@
-This directory contains 7 examples of what libAfterImage can do.
-This examples are not built automagically, since most users are not
-likely to need these. They are intended for developers primarily.
-
-Here is how to build examples in this directory :
-
-All of the examples require that libAfterImage is built first.
-As libAfterImage may utilize libAfterBase, for some of the low level
-tasks, it is recommended to build libAfterBase prior to anything
-else. After that libAfterImage has to be built and installed.
-Both of the above steps can be accomplished by simply doing :
-
-  ./configure ; make ; make install
-
-in respective directory.
-
-Once both libraries are installed we can proceed to compiling
-the examples. Top do that you will need to execute :
-
-  ./configure ; make
-
-in this directory. Easy. That should build all the examples.
-
-If something goes wrong and you need to update your system and
-repeat above commands, don't forget to remove config.cache, prior
-to running configure script.
-
-All the examples accept command line parameters, and description
-of those can be obtained by running example with -h option.
-Arguments are not required, and examples should display some
-sensible defaults.
-
-This set of examples comes with 3 test images and 1 TTF font
-file. Defaults are set to use this files.
-
-Note that you will not be able to see TTF font rendered if you do
-not have FreeType library version 2 installed.
-
-Thanks for using libAfterImage. Contributions and bug reports are
-always welcome. Please e-mail yours to <sashav at sprintmail dot com>,
-or any of the AfterStep mailing lists.
-
-
-ascompose
--------------------------------------------------------------------------------
-
-ascompose uses an XML input file to compose an image and display it. 
-For complete list of XML tags please see asimagexml man page.
diff -Naur libAfterImage-1.20/apps/ascheckttf.c root/graf2d/asimage/src/libAfterImage/apps/ascheckttf.c
--- libAfterImage-1.20/apps/ascheckttf.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/ascheckttf.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,145 +0,0 @@
-#include "config.h"
-
-#include <string.h>
-#include <stdlib.h>
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "common.h"
-
-/* Usage:  ascheckttf [-f font] [-s size] [-t text]|[--glyphs <listof unicodes>]
- */
-
-#define BEVEL_HI_WIDTH 20
-#define BEVEL_LO_WIDTH 30
-#define BEVEL_ADDON    (BEVEL_HI_WIDTH+BEVEL_LO_WIDTH)
-
-void usage()
-{
-	printf( "  Usage:   ascheckttf [-h] [-f font] [-s size] [-t text]|[--unicode <listof unicodes>]"
-			"[-S 3D_style] \n");
-	printf( "  Where: font - TrueType font's filename\n");
-	printf( "         size - size in points for TrueType fonts;\n");
-	printf( "         text - text;\n");
-	printf( "         unicode - comma separated list of unicode codes;\n");
-	printf( "         3D_style - 3D style of text. "
-			"One of the following:\n");
-	printf( "             0 - plain 2D tetx, 1 - embossed, 2 - sunken, "
-			"3 - shade above,\n");
-	printf( "             4 - shade below, 5 - embossed thick, "
-			"6 - sunken thick.\n");
-	printf( "             7 - ouline above, 8 - ouline below, "
-			"9 - full ouline.\n");
-
-
-}
-
-int main(int argc, char* argv[])
-{
-	char *font_name = NULL;
-	int size = 32 ;
-	char *unicode = NULL;
-	UNICODE_CHAR* uc_ptr = NULL;
- 	char *text = NULL;
-	
-	struct ASFontManager *fontman = NULL;
-	struct ASFont  *font = NULL;
-	int i ;
-	int text_margin = size/2 ;
-	char * font_path = NULL;
-	ASGlyph** glyphs = NULL;
-	
-	/* see ASView.1 : */
-	set_application_name( argv[0] );
-#if (HAVE_AFTERBASE_FLAG==1)
-	set_output_threshold(OUTPUT_LEVEL_DEBUG);
-#endif
-
-	if( argc == 1 )
-		usage();
-	else 
-		for (i = 1 ; i < argc ; i++)
-		{
-			if (strncmp( argv[i], "-h", 2 ) == 0)
-			{
-				usage();
-				return 0;
-			}
-
-			if (i+1 < argc)
-			{
-				if( strncmp( argv[i], "-f", 2 ) == 0 )
-					font_name = argv[i+1] ;
-				else if( strncmp( argv[i], "-s", 2 ) == 0 )
-				{
-					size = atoi(argv[i+1]);
-					text_margin = size/2 ;
-				}else if (strncmp( argv[i], "-t", 2 ) == 0)
-					text = argv[i+1] ;
-				else if (strncmp( argv[i], "--unicode", 9 ) == 0)
-					unicode = argv[i+1] ;
-			}
-		}
-
-	if (font_name == NULL)
-	{
-		show_error( "Font must be specified." );
-		usage();
-		return 1;
-	}
-
-	if (text == NULL && unicode == NULL)
-	{
-		show_error( "Either text or list of unicode must be specified." );
-		usage();
-		return 1;
-	}
-	
-	if( getenv("FONT_PATH") != NULL ) 
-	{
-		font_path = safemalloc( strlen(getenv("FONT_PATH"))+1+2+1);
-		sprintf( font_path, "%s:./", getenv("FONT_PATH") );
-		
-	}	 
-	
-	if( (fontman = create_font_manager( NULL, font_path, NULL )) != NULL )
-		font = get_asfont( fontman, font_name, 0, size, ASF_Freetype );
-
-	if( font == NULL )
-	{
-		show_error( "unable to load requested font \"%s\". ", font_name );
-		return 1;
-	}
-
-	if (text)
-	{
-		glyphs = get_text_glyph_list (text, font, ASCT_Char, 0);
-	}else /* unicode */
-	{
-		char *endp = unicode;
-
-		i = 0;
-		uc_ptr = safecalloc (strlen (unicode)+1, sizeof (UNICODE_CHAR));
-		while ((uc_ptr[i++] = strtol(endp, &endp, 0)) > 0)
-			if (*endp == ',' || *endp == ';') ++endp;
-
-		glyphs = get_text_glyph_list ((char*)uc_ptr, font, ASCT_Unicode, 0);
-		
-	}
-	for( i = 0 ; glyphs[i] ; ++i ) 
-	{
-		if (text)
-			printf ("0x%8.8X ", (unsigned int)text[i]);
-		else
-			printf ("0x%8.8X ", (unsigned int)uc_ptr[i]);
-			
-		if (glyphs[i] == &(font->default_glyph))
-			printf ("N 0 0\n");
-		else
-			printf ("Y %d %d\n", glyphs[i]->width, glyphs[i]->height);
-	}
-	
-	release_font( font );
-	destroy_font_manager( fontman, False );
-    return 0 ;
-}
diff -Naur libAfterImage-1.20/apps/ascompose.c root/graf2d/asimage/src/libAfterImage/apps/ascompose.c
--- libAfterImage-1.20/apps/ascompose.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/ascompose.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1205 +0,0 @@
-/*
- * Copyright (c) 2001 Sasha Vasko <sasha@aftercode.net>
- * Copyright (c) 2001 Eric Kowalski <eric@beancrock.net>
- * Copyright (c) 2001 Ethan Fisher <allanon@crystaltokyo.com>
- *
- * This module is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- */
-
-#include "config.h"
-
-#define LOCAL_DEBUG
-
-#include <ctype.h>
-#include <errno.h>
-#include <stdarg.h>
-#include <math.h>
-#include <stdio.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#if TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# if HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif
-
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "common.h"
-
-#if !defined(X_DISPLAY_MISSING)
-int asvisual_empty_XErrorHandler (Display * dpy, XErrorEvent * event);
-
-# if defined(SHAPE)
-#  include <X11/extensions/shape.h>
-# endif /* SHAPE */
-#endif /* X_DISPLAY_MISSING */
-
-
-
-/****h* libAfterImage/ascompose
- * NAME
- * ascompose is a tool to compose image(s) and display/save it based on
- * supplied XML input file.
- *
- * SYNOPSIS
- * ascompose -f file|-s string [-o file] [-t type] [-V]
- * ascompose -i include_file [-i more_include_file ... ]
- * 			 -f file|-s string [-o file] [-t type] [-V]
- * ascompose -f file|-s string [-o file] [-t type] [-V] [-n]
- * ascompose -f file|-s string [-o file] [-t type [-c compression_level]] 
- * 			 [-V] [-r]
- * ascompose [-h]
- * ascompose [-v]
- *
- * DESCRIPTION
- * ascompose reads supplied XML data, and manipulates image accordingly.
- * It could transform images from files of any supported file format,
- * draw gradients, render antialiased texturized text, perform
- * superimposition of arbitrary number of images, and save images into
- * files of any of supported output file formats.
- *
- * At any point, the result of any operation could be assigned a name,
- * and later on referenced under this name.
- *
- * At any point during the script processing, result of any operation
- * could be saved into a file of any supported file types.
- *
- * Internal image format is 32bit ARGB with 8bit per channel.
- *
- * Last image referenced, will be displayed in X window, unless -n option
- * is specified. If -r option is specified, then this image will be
- * displayed in root window of X display, effectively setting a background
- * for a desktop. If -o option is specified, this image will also be
- * saved into the file or requested type.
- *
- * ascompose can be compiled to not reference X Window System, thus
- * allowing it to be used on web servers and any other place. It does not
- * even require X libraries in that case.
- *
- * Supported file types for input are :
- * XPM   - via internal code, or libXpm library.
- * JPEG  - via libJpeg library.
- * PNG   - via libPNG library.
- * XCF   - via internal code. For now XCF support is not complete as it
- *         does not merge layers.
- * PPM/PNM - via internal code.
- * BMP, ICO, CUR - via internal code.
- * GIF   - via libungif library.
- * TIFF  - via libtiff library (including alpha channel support).
- * see libAfterImage/ASImageFileTypes for more.
- *
- * Supported file types for output :
- * XPM   - via internal code, or libXpm library.
- * JPEG  - via libJpeg library.
- * PNG   - via libPNG library.
- * GIF   - via libungif library.
- * TIFF  - via libtiff library (including alpha channel support).
- *
- * OPTIONS
- *    -h --help          display help and exit.
- *    -f --file file     an XML file to use as input.
- *    -s --string string an XML string to use as input.
- *    -n --no-display    don't display the last referenced image.
- *    -r --root-window   draw last referenced image image on root window.
- *    -o --output file   output last referenced image in to a file.
- *                       You should use -t to specify what file type to
- *                       use. Filenames are meaningless when it comes to
- *                       determining what file type to use.
- *    -t --type type     type of file to output to.
- *    -c --compress level compression level.
- *    -v --version       display version and exit.
- *    -V --verbose       increase verbosity. To increase verbosity level
- *                       use several of these, like: ascompose -V -V -V.
- *    -D --debug         maximum verbosity - show everything and
- *                       debug messages.
- *    -i --include file  include file as input prior to processing main 
- * 						 file.
- * PORTABILITY
- * ascompose could be used both with and without X window system. It has
- * been tested on most UNIX flavors on both 32 and 64 bit architecture.
- * It has also been tested under CYGWIN environment on Windows 95/NT/2000
- * USES
- * libAfterImage         all the image manipulation routines.
- * libAfterBase          Optionally. Misc data handling such as hash
- *                       tables and console io. Must be used when compiled
- *                       without X Window support.
- * libJPEG               JPEG image format support.
- * libPNG                PNG image format support.
- * libungif              GIF image format support.
- * libTIFF               TIFF image format support.
- * AUTHOR
- * Ethan Fisher          <allanon at crystaltokyo dot com>
- * Sasha Vasko           <sasha at aftercode dot net>
- * Eric Kowalski         <eric at beancrock dot net>
- *******/
-
-
-ASVisual *asv;
-int verbose = 0;
-
-void version(void) {
-	printf("ascompose version 1.2\n");
-}
-
-void usage(void) {
-	fprintf( stdout,
-		"Usage:\n"
-		"ascompose [options] [-f file|-|-s string] [-o file]"
-		"Available options :\n"
-		"  -h --help          display this help and exit\n"
-        "  -v --version       display version and exit\n"
-		" Input options : \n"
-		"  -f --file file     an XML file to use as input\n"
-		"  					  use '-' for filename to read input from STDIN\n"
-		"  -s --string string an XML string to use as input\n"
-		"  -i --include file  process file prior to processing other input\n"
-		" Output options : \n"
-#ifndef X_DISPLAY_MISSING
-		"  -g --geometry WxX+X+Y  set window geometry \n"
-		"  -T --title  title  set window's title\n"
-		"     --override      override window Manager's controls \n"
-		"                     (use for splash windows to avoid window frame)\n"
-		"     --center        center window on screen\n"
-		"     --topmost       raise window to the top\n"
-		"     --no-shape      do not shape window\n"
-		"  -n --no-display    don't display the final image\n"
-		"  -r --root-window   draw result image on root window\n"
-#endif /* X_DISPLAY_MISSING */
-		"  -o --output file   output to file\n"
-		"  -t --type type     type of file to output to\n"
-        "  -c --compress level compression level\n"
-		" Feedback options : \n"
-		"  -V --verbose       increase verbosity\n"
-		"  -q --quiet	      output as little information as possible\n"
-		"  -D --debug         show everything and debug messages\n"
-		" Interactive options : \n"
-		"  -I --interactive   run ascompose in interactive mode - tags are processed,\n" 
-		"                     as soon as they are closed.\n"
-		"     --timeout value time to wait in between displaying images\n"
-		"     --click-timeout seconds\n" 
-		"                     time to wait for user click before moving on. -1 - forever.\n"
-		"     --endless       endlessly loop through file or string\n"
-		"     --dont-clear    don't clear window before displaying next image\n"
-		" Note that when -I option is used in conjunction with input from\n" 
-		" string or a file - ascompose will endlesly loop through the contents\n"
-		" untill it is killed - usefull for slideshow type of activity.\n"
-		" When input comes from STDIN, then ascompose will loop untill Ctrl+D\n"
-		" is received (EOF).\n"
-		"\n"
-		"  -C --clipboard     run ascompose waiting for data being copied into clipboard,\n" 
-		"                     and displaying/processing it, if it is xml.\n"
-		" Examples: \n"
-		" To display image.jpg on root window : \n"
-		"   ascompose -r -s \"<img src=image.jpg/>\""
-		" To display image.jpg on root window scaling it to screen size: \n"
-		"   ascompose -r -s \"<scale width=$xroot.width height=proportional><img src=image.jpg/></scale>\"\n"
-	);
-}
-
-/****** libAfterImage/ascompose/sample
- * EXAMPLE
- * Here is the default script that gets executed by ascompose, if no
- * parameters are given :
- * SOURCE
- */
-#if 1
-static char* default_doc_str = "\
-<composite op=hue>\
-  <composite op=add>\
-    <scale width=512 height=proportional>\
-		<img id=rose src=rose512.jpg/></scale>\
-    <tile width=512 height=384><img src=back.xpm/></tile>\
-  </composite>\
-  <tile width=512 height=384><img src=fore.xpm/></tile>\
-</composite>\
-<printf format=\"original image width=%d\n\" var=\"rose.width\"/>\
-<printf format=\"original image height=%d\n\" var=\"rose.height\"/>\
-<printf format=\
-\"original image size in pixels=%d\n\" val=$rose.width*$rose.height/>";
-#else	
-static char* default_doc_str = "\
-  <composite op=add>\
-    <scale width=512 height=proportional>\
-		<img id=rose src=rose512.jpg/></scale>\
-    <tile width=512 height=384><img src=back.xpm/></tile>\
-  </composite>";
-#endif
-/*******/
-char *load_stdin();	
-
-typedef struct ASComposeWinProps
-{
-	Bool center ;
-
-	int geom_x, geom_y ;
-	unsigned int geom_width, geom_height ;
-	unsigned long geom_flags ;
-
-	Bool override_redirect ;
-	int timeout ;
-	int click_timeout ;
-	Bool on_top ;
-	const char *title ;
-	Bool no_shape ; 
-
-	Bool mapped ;
-	Bool dont_clear;
-	
-	int last_x, last_y ; 
-	unsigned int last_width, last_height ;
-	Pixmap last_root_pmap ; 
-	ASImage *last_root_im ;
-	
-	Pixmap canvas;
-	int canvas_width, canvas_height;
-}ASComposeWinProps;
-
-Window showimage(ASImage* im, Bool looping, Window main_window, ASComposeWinProps *props, int dst_x, int dst_y);
-Window make_main_window(Bool on_root, ASComposeWinProps *props);	
-
-int screen = 0, depth = 0;
-Display *dpy = NULL;
-
-int main(int argc, char** argv) {
-
-	ASImage* im = NULL;
-	char* doc_str = default_doc_str;
-	char* doc_file = NULL;
-	char* doc_save = NULL;
-	char* doc_save_type = NULL;
-    char *doc_compress = NULL ;
-	int i;
-	int display = 1, onroot = 0;
-	Bool quiet = False ;
-	enum
-	{
-		COMPOSE_Once = 0,
-		COMPOSE_Interactive,
-		COMPOSE_XClipboard
-	}compose_type = COMPOSE_Once ;
-	Bool endless_loop = False ; 
-	Window main_window = None ;
-	ASComposeWinProps main_window_props ;
-	
-	char* ascompose_locale ;
-	memset(&main_window_props, 0x00, sizeof( main_window_props));
-	main_window_props.click_timeout = -1;
-
-	/* see ASView.1 : */
-	set_application_name(argv[0]);
-	
-	ascompose_locale = mystrdup(getenv("LANG"));
-
-    if( ascompose_locale && strlen(ascompose_locale) > 0)
-    {
-    	as_set_charset( parse_charset_name( ascompose_locale ));
-    }else
-	{
-#ifdef I18N
-		show_warning ("LANG environment variable is not set - use -L \"locale\" command line option to define locale");
-#endif
-	}
-
-
-	/* scrap asvisual so we can work on include files ( not displaying anything ) */
-	asv = create_asvisual(NULL, 0, 32, NULL);
-
-	/* Parse command line. */
-	for (i = 1 ; i < argc ; i++) {
-		if (!strcmp(argv[i], "--help") || !strcmp(argv[i], "-h")) {
-			version();
-			usage();
-			exit(0);
-		} else if (!strcmp(argv[i], "--version") || !strcmp(argv[i], "-v")) {
-			version();
-			exit(0);
-		} else if (!strcmp(argv[i], "--quiet") || !strcmp(argv[i], "-q")) {
-			set_output_threshold(0);
-			verbose = 0; quiet = True ;
-		} else if (!strcmp(argv[i], "--verbose") || !strcmp(argv[i], "-V")) {
-			set_output_threshold(OUTPUT_VERBOSE_THRESHOLD);
-			verbose++;
-		} else if (!strcmp(argv[i], "--debug") || !strcmp(argv[i], "-D")) {
-			set_output_threshold(OUTPUT_LEVEL_DEBUG);
-			verbose+=2;
-		} else if ((!strcmp(argv[i], "--file") || !strcmp(argv[i], "-f")) && i < argc + 1) {
-			doc_file = argv[++i];
-		} else if ((!strcmp(argv[i], "--include") || !strcmp(argv[i], "-i")) && i < argc + 1) 
-		{
-			char *incl_str = load_file(argv[++i]);
-	  		if (!incl_str) 
-			{
-				fprintf(stderr, "Unable to load file [%s]: %s.\n", argv[i], strerror(errno));
-			}else
-			{
-				ASImage *im = compose_asimage_xml(asv, NULL, NULL, incl_str, ASFLAGS_EVERYTHING, verbose, None, NULL);
-				free( incl_str );
-				if( im )
-					destroy_asimage(&im);
-			}
-		} else if ((!strcmp(argv[i], "--string") || !strcmp(argv[i], "-s")) && i < argc + 1) {
-			doc_str = argv[++i];
-	   	} else if ((!strcmp(argv[i], "--output") || !strcmp(argv[i], "-o")) && i < argc + 1) {
-			doc_save = argv[++i];
-		} else if ((!strcmp(argv[i], "--type") || !strcmp(argv[i], "-t")) && i < argc + 1) {
-			doc_save_type = argv[++i];
-        } else if ((!strcmp(argv[i], "--compress") || !strcmp(argv[i], "-c")) && i < argc + 1) {
-            doc_compress = argv[++i];
-		} else if (!strcmp(argv[i], "--interactive") || !strcmp(argv[i], "-I")) {
-            compose_type = COMPOSE_Interactive ;
-		} else if (strcmp(argv[i], "--click-timeout") == 0 && i < argc + 1) {
-			main_window_props.click_timeout = strtod( argv[++i ], NULL );
-		} else if (strcmp(argv[i], "--timeout") == 0 && i < argc + 1) {
-			main_window_props.timeout = strtod( argv[++i ], NULL );
-		} else if (!strcmp(argv[i], "--endless")) {
-            endless_loop = True ;
-		} else if (!strcmp(argv[i], "--dont-clear")) {
-            main_window_props.dont_clear = True ;
-		}
-#ifndef X_DISPLAY_MISSING
-		  else if ((!strcmp(argv[i], "--geometry") || !strcmp(argv[i], "-g")) && i < argc + 1) {
-			main_window_props.geom_flags = XParseGeometry ( argv[++i], 
-															&main_window_props.geom_x,
-															&main_window_props.geom_y,
-                      					 					&main_window_props.geom_width, 
-															&main_window_props.geom_height);
-		} else if (strcmp(argv[i], "--override") == 0 ) {
-			main_window_props.override_redirect = True;
-		} else if ((!strcmp(argv[i], "--title") || !strcmp(argv[i], "-T")) && i < argc + 1) {
-			main_window_props.title = argv[++i];
-		} else if (strcmp(argv[i], "--center") == 0 ) {
-			main_window_props.center = True;
-		} else if (strcmp(argv[i], "--topmost") == 0 ) {
-			main_window_props.on_top = True;
-		} else if (strcmp(argv[i], "--no-shape") == 0 ) {
-			main_window_props.no_shape = True;
-		} else if (!strcmp(argv[i], "--clipboard") || !strcmp(argv[i], "-C")) {
-			compose_type = COMPOSE_XClipboard;
-		}   else if (!strcmp(argv[i], "--no-display") || !strcmp(argv[i], "-n")) {
-			display = 0;
-		} else if ((!strcmp(argv[i], "--root-window") || !strcmp(argv[i], "-r")) && i < argc + 1) {
-			onroot = 1;
-		}
-#endif /* X_DISPLAY_MISSING */
-	}
-	
-	destroy_asvisual( asv, False );
-	asv = NULL ;
-    
-	dpy = NULL ;
-#ifndef X_DISPLAY_MISSING
-    if( display )
-    {
-		LOCAL_DEBUG_OUT( "Opening display ...%s", "");
-        dpy = XOpenDisplay(NULL);
-		LOCAL_DEBUG_OUT( "Done: %p", dpy);
-		if( dpy )
-		{	
-        	_XA_WM_DELETE_WINDOW = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
-        	screen = DefaultScreen(dpy);
-        	depth = DefaultDepth(dpy, screen);
-		}
-    }
-#endif
-	if( dpy == NULL && doc_file == NULL && doc_str == default_doc_str )
-		doc_file = strdup("-");
-
-	/* Automagically determine the output type, if none was given. */
-	if (doc_save && !doc_save_type) {
-		doc_save_type = strrchr(doc_save, '.');
-		if (doc_save_type) doc_save_type++;
-	}
-
-	LOCAL_DEBUG_OUT( "Creating visual ...%s", "");
-	asv = create_asvisual(dpy, screen, depth, NULL);
-	LOCAL_DEBUG_OUT( "Done: %p", asv);
-
-	/* Load the document from file, if one was given. */
-	if( compose_type == COMPOSE_Once ) 
-	{	   
-		if (doc_file) {
-			if( strcmp( doc_file, "-") == 0 ) 
-				doc_str = load_stdin();
-			else
-				doc_str = load_file(doc_file);
-			if (!doc_str) 
-			{
-				show_error("Unable to load file [%s]: %s.\n", doc_file, strerror(errno));
-				exit(1);
-			}
-		}
-		
-		im = compose_asimage_xml(asv, NULL, NULL, doc_str, ASFLAGS_EVERYTHING, verbose, None, NULL);
-		/* Save the result image if desired. */
-		if (doc_save && doc_save_type) 
-		{
-        	if(!save_asimage_to_file(doc_save, im, doc_save_type, doc_compress, NULL, 0, 1)) 
-				show_error("Save failed.");
-			else
-				show_progress("Save successful.");
-		}
-		/* Display the image if desired. */
-		if (display && dpy)
-		{
-			showimage(im, False, make_main_window(onroot, &main_window_props), &main_window_props, 0, 0);
-			LOCAL_DEBUG_OUT( "Image %p displayed", im );
-		}
-		/* Done with the image, finally. */
-		if( im ) 
-		{	
-			safe_asimage_destroy( im );
-			im = NULL ;
-		}
-	}else if( compose_type == COMPOSE_Interactive )
-	{
-		FILE *fp = stdin ;
-		int doc_str_len = 0;
-		if (doc_file && strcmp( doc_file, "-") != 0 ) 
-			fp = fopen( doc_file, "rt" );
-		if( doc_str ) 
-			doc_str_len = strlen( doc_str );
-				   
-		if( fp != NULL || doc_str_len > 0 )
-		{
-			ASImageManager *my_imman = create_generic_imageman(NULL);
-			ASFontManager  *my_fontman = create_generic_fontman(asv->dpy, NULL);
-			int char_count = 0 ;
-			ASXmlBuffer xb ; 
-			
-			memset( &xb, 0x00, sizeof(xb));
-	 		
-			if (display && dpy) 
-				main_window = make_main_window( onroot, &main_window_props );
-
-			do
-			{
-				reset_xml_buffer( &xb );
-				if( fp ) 	  
-				{
-					int c ;
-					show_progress("Please enter your xml text :" );
-
-					while( (c = fgetc(fp)) != EOF ) 
-					{
-						char cc = c; 
-						while( xb.state >= 0 && spool_xml_tag( &xb, &cc, 1 ) <= 0)
-						{	
-							LOCAL_DEBUG_OUT("[%c] : state=%d, tags_count=%d, level = %d, tag_type = %d", 
-								             cc, xb.state, xb.tags_count, xb.level, xb.tag_type );
-						}
-						LOCAL_DEBUG_OUT("[%c] : state=%d, tags_count=%d, level = %d, tag_type = %d", 
-								        cc, xb.state, xb.tags_count, xb.level, xb.tag_type );
-
-						++char_count ;
-						if( ( xb.state == ASXML_Start && xb.tags_count > 0 && xb.level == 0) || 
-							  xb.state < 0 ) 
-							break;
-					}		   
-					if (c == EOF)
-					{	
-						if (fp != stdin && endless_loop) 
-						{	
-							fseek( fp, 0L, SEEK_SET );
-							char_count = 0 ;
-							if( xb.state == ASXML_Start && xb.tags_count == 0 ) 
-								continue;
-						}else if( xb.tags_count == 0 ) 
-							break;
-					}
-				}else
-				{
-					if( char_count >= doc_str_len ) 
-					{
-						if( !endless_loop ) 	  
-							break;
-						char_count = 0 ;
-					}
-					while( char_count < doc_str_len ) 
-					{
-						char_count += spool_xml_tag( &xb, &doc_str[char_count], doc_str_len - char_count );							   
-						if( ( xb.state == ASXML_Start && xb.tags_count > 0 && xb.level == 0) || 
-							  xb.state < 0 ) 
-							break;
-					}												   
-				}		 
-				if( xb.state == ASXML_Start && xb.tags_count > 0 && xb.level == 0 ) 
-				{
-					int dst_x = 0, dst_y = 0;
-					xml_elem_t* doc;
-
-					if( !display || dpy == NULL || !quiet ) 
-						printf("<success tag_count=%d/>\n", xb.tags_count );
-					
-					add_xml_buffer_chars( &xb, "", 1 );
-					LOCAL_DEBUG_OUT("buffer: [%s]", xb.buffer );
-
-					if ((doc = xml_parse_doc(xb.buffer, NULL)) != NULL)
-					{
-						xml_elem_t *tmp, *parm = doc->child?xml_parse_parm(doc->child->parm, NULL):NULL;
-						im = compose_asimage_xml_from_doc(asv, my_imman, my_fontman, doc, ASFLAGS_EVERYTHING, verbose, None, NULL, -1, -1);
-
-						if (parm)
-						{
-							for (tmp = parm ; tmp ; tmp = tmp->next)
-							{
-								if (!strcmp(tmp->tag, "x")) dst_x = parse_math(tmp->parm, NULL, 0);
-								else if (!strcmp(tmp->tag, "y")) dst_y = parse_math(tmp->parm, NULL, 0);
-							}
-							xml_elem_delete(NULL, parm);
-						}
-						xml_elem_delete(NULL, doc);
-					}
-					if( im ) 
-					{
-						/* Save the result image if desired. */
-						if (doc_save && doc_save_type) 
-						{
-        					if(!save_asimage_to_file(doc_save, im, doc_save_type, doc_compress, NULL, 0, 1)) 
-								show_error("Save failed.");
-							else
-								show_progress("Save successful.");
-						}
-						/* Display the image if desired. */
-						if (display && dpy) 
-							main_window = showimage(im, True, main_window, &main_window_props, dst_x, dst_y);
-
-						safe_asimage_destroy(im);
-						im = NULL ;
-					}					
-				}else if( fp == stdin && xb.state == ASXML_Start && xb.tags_count == 0 && xb.level == 0 ) 
-				{
-					if( !display || dpy == NULL || !quiet ) 
-						printf("<success tag_count=%d/>\n", xb.tags_count );						  
-					if (!endless_loop)
-						break;
-				}else
-				{
-					if( !display || dpy == NULL || !quiet ) 
-					{	
-						xml_elem_t *msg = format_xml_buffer_state (&xb);
-						if (msg)
-						{
-							xml_print(msg);
-							xml_elem_delete(NULL, msg);
-						}
-					}
-					if (!endless_loop)
-						break;
-				}
-			}while( !display || dpy == NULL || main_window != None);
-			if( xb.buffer )
-				free( xb.buffer );
-			destroy_image_manager(my_imman, False);
-			destroy_font_manager(my_fontman, False);
-		}
-		if( fp && fp != stdin ) 
-			fclose( fp );
-	}
-#ifndef X_DISPLAY_MISSING		  	
-	else if( compose_type == COMPOSE_XClipboard && dpy )
-	{
-		Atom clipboard_prop ;
-		ASXmlBuffer xb ; 
-		int nbytes = 0 ;
-		char *bytes = NULL ;
-		int char_count = 0 ;
-		ASImageManager *my_imman = create_generic_imageman(NULL);
-		ASFontManager  *my_fontman = create_generic_fontman(asv->dpy, NULL);
-			
-		memset( &xb, 0x00, sizeof(xb));
-		if (display) 
-			main_window = make_main_window( onroot, &main_window_props );
-		
-		XSelectInput( dpy, DefaultRootWindow(dpy), PropertyChangeMask );
-		clipboard_prop = XInternAtom( dpy, "CUT_BUFFER0", False );
-		while( main_window || !display ) 
-		{
-    		XEvent event ;
-			Bool show_next = False ;
-			
-			XNextEvent (dpy, &event);
-  			switch(event.type)
-			{
-				case PropertyNotify :
-					if( event.xproperty.atom == clipboard_prop ) 
-					{
-						if( bytes ) 
-							XFree(bytes);
-						bytes = XFetchBytes( dpy, &nbytes );
-						char_count = 0 ; 
-						show_next = True ;
-					}	 
-				    break ;
-	  			case ClientMessage:
-					if (event.xclient.format == 32 &&
-	  					event.xclient.data.l[0] == _XA_WM_DELETE_WINDOW)
-					{
-						if( main_window != DefaultRootWindow(dpy) )
-							XDestroyWindow( dpy, main_window );
-						XFlush( dpy );
-						main_window = None ;
-					}
-					break;
-				case ButtonPress:
-					if( nbytes > char_count ) 
-						show_next = True ;
-					else if( main_window != DefaultRootWindow(dpy) )
-						XUnmapWindow( dpy, main_window );
-					break;
-			}
-			if( show_next ) 
-			{
-				reset_xml_buffer( &xb );
-				while( char_count < nbytes ) 
-				{
-					char_count += spool_xml_tag( &xb, &bytes[char_count], nbytes - char_count );							   
-					if( ( xb.state == ASXML_Start && xb.tags_count > 0 && xb.level == 0) || 
-						xb.state < 0 ) 
-						break;
-				}												   
-				
-				if( xb.state == ASXML_Start && xb.tags_count > 0 && xb.level == 0 ) 
-				{
-					xml_elem_t* doc;
-					int dst_x = 0, dst_y = 0;
-					
-					add_xml_buffer_chars( &xb, "", 1 );
-					LOCAL_DEBUG_OUT("buffer: [%s]", xb.buffer );
-
-					if ((doc = xml_parse_doc(xb.buffer, NULL)) != NULL)
-					{
-						xml_elem_t *tmp, *parm = doc->child?xml_parse_parm(doc->child->parm, NULL):NULL;
-						im = compose_asimage_xml_from_doc(asv, my_imman, my_fontman, doc, ASFLAGS_EVERYTHING, verbose, None, NULL, -1, -1);
-						if (parm)
-						{
-							for (tmp = parm ; tmp ; tmp = tmp->next)
-							{
-								if (!strcmp(tmp->tag, "x")) dst_x = parse_math(tmp->parm, NULL, 0);
-								else if (!strcmp(tmp->tag, "y")) dst_y = parse_math(tmp->parm, NULL, 0);
-							}
-							xml_elem_delete(NULL, parm);
-						}
-						xml_elem_delete(NULL, doc);
-					}
-
-					if( im ) 
-					{
-						/* Save the result image if desired. */
-						if (doc_save && doc_save_type) 
-						{
-        					if(!save_asimage_to_file(doc_save, im, doc_save_type, doc_compress, NULL, 0, 1)) 
-								show_error("Save failed.");
-							else
-								show_progress("Save successful.");
-						}
-						/* Display the image if desired. */
-						if (display && dpy) 
-							main_window = showimage(im, True, main_window, &main_window_props, dst_x, dst_y);
-						safe_asimage_destroy(im);
-						im = NULL ;
-					}					
-				}
-			}	 
-		}	 
-
-		if( bytes ) 
-			XFree( bytes );
-		if( xb.buffer )
-			free( xb.buffer );
-		destroy_image_manager(my_imman, False);
-		destroy_font_manager(my_fontman, False);
-	}		 
-#endif
-	if (doc_file && doc_str && doc_str != default_doc_str) free(doc_str);
-
-#if !defined(X_DISPLAY_MISSING)    
-	if (main_window_props.canvas)
-		XFreePixmap(dpy, main_window_props.canvas); 
-	if( dpy )
-	{
-        XCloseDisplay (dpy);
-		dpy = NULL;
-	}
-#endif
-	LOCAL_DEBUG_OUT( "display Closed%s","");
-#ifdef DEBUG_ALLOCS
-	if (main_window_props.last_root_im)
-		safe_asimage_destroy(main_window_props.last_root_im);
-	asxml_var_cleanup();
-	LOCAL_DEBUG_OUT( "display Closed%s","");
-	custom_color_cleanup();
-	LOCAL_DEBUG_OUT( "display Closed%s","");
-    build_xpm_colormap( NULL );
-	LOCAL_DEBUG_OUT( "display Closed%s","");
-	flush_default_asstorage();
-	LOCAL_DEBUG_OUT( "display Closed%s","");
-//	destroy_asvisual( asv, False );
-	LOCAL_DEBUG_OUT( "display Closed%s","");
-    flush_ashash_memory_pool();
-	LOCAL_DEBUG_OUT( "display Closed%s","");
-	print_unfreed_mem();
-	print_asimage_registry();
-#endif
-
-	return 0;
-}
-
-Window 
-make_main_window(Bool onroot, ASComposeWinProps *props)	
-{
-	Window w = None ;
-#ifndef X_DISPLAY_MISSING		  
-	XSetWindowAttributes attributes;
-
-	if( onroot ) 
-	{	
-		w = DefaultRootWindow(dpy);
-		props->last_x = 0 ;
-		props->last_y = 0 ;
-		props->last_width = 0 ;
-		props->last_height = 0 ;
-	}else
-	{
-		attributes.override_redirect = props->override_redirect ; 
-		w = create_top_level_window( asv, DefaultRootWindow(dpy), 32, 32,
-				                        100, 30, 0, CWOverrideRedirect, &attributes, 
-										"ASCompose",
-										props->title );
-		props->last_x = 32 ;
-		props->last_y = 32 ;
-		props->last_width = 100 ;
-		props->last_height = 30 ;
-		XSelectInput (dpy, w, (StructureNotifyMask|ButtonPressMask|ButtonReleaseMask));
-	}	 
-	props->last_root_pmap = None ;
-	if( props->last_root_im ) 
-		safe_asimage_destroy(props->last_root_im);
-	props->last_root_im = NULL ; 
-		
-
-#endif	 
-	return w;
-}
-
-Bool
-set_root_pixmap_property(long pmap) /* Must have long type to work with XChangeProp on 64 bit machines !!!*/
-{
-#ifndef X_DISPLAY_MISSING		  
-	Window root = DefaultRootWindow(dpy);
-	char  *names[2] = {"_XROOTPMAP_ID", "ESETROOT_PMAP_ID"};
-	Atom  atoms[2];
-	int i;
-
-	if (XInternAtoms (dpy, &(names[0]), 2, True, &(atoms[0])) != 0)
-	{
-		Pixmap pmaps[2] = {0, 0};
-	    Atom type;
-    	int format;
-	    unsigned long nitems, after;
-		union 
-		{
-			unsigned char *uc_ptr ;
-			long 		  *long_ptr ;
-		}data;
-
-		for (i = 0 ; i < 2 ; ++i)
-			if (atoms[i])
-			{
-				LOCAL_DEBUG_OUT("atoms[%d] = %lX", i, atoms[i]);
-				data.long_ptr = NULL ;
-		        XGetWindowProperty(dpy, root, atoms[i], 0L, 1L, False, AnyPropertyType, &type, &format, &nitems, &after, &data.uc_ptr);
-				if (data.long_ptr == NULL)
-					break;
-				pmaps[i] = data.long_ptr[0] ;
-				LOCAL_DEBUG_OUT("pmaps[%d] = %lX", i, pmaps[i]);
-				if (format != 32 || nitems == 0 || pmaps[i] != pmaps[0] || type != XA_PIXMAP) 
-					break;
-			}
-		if (i>= 2 && pmaps[0] && pmaps[0] != pmap) 
-		{
-			/* XKillClient is a dangerous affair since properties may hold stale values tha are no longer valid */
-			int (*oldXErrorHandler) (Display *, XErrorEvent *) = XSetErrorHandler (asvisual_empty_XErrorHandler);
-			LOCAL_DEBUG_OUT("killing client for pmap %lX", pmaps[0]);
-           	XKillClient(dpy, pmaps[0]);
-			XSync(dpy, False);
-			XSetErrorHandler (oldXErrorHandler);
-		}
-    }
-	for (i = 0 ; i < 2 ; ++i)
-	{
-		if (!atoms[i])
-			if ( (atoms[i] = XInternAtom (dpy, names[i], False)) == None)
-				break;
-		LOCAL_DEBUG_OUT("Changing property %lX to pmap id %lX", atoms[i], pmap);
-    	XChangeProperty(dpy, root, atoms[i], XA_PIXMAP, 32, PropModeReplace, (unsigned char *) &pmap, 1);
-	}
-	if (i >= 2)
-	{
-		XSetCloseDownMode(dpy, RetainPermanent);
-		return True;
-	}
-#endif
-	return False;
-}
-
-Bool
-wait_x_timeout(int timeout)
-{
-#ifndef X_DISPLAY_MISSING		  
-	if (timeout < 0) /* wait forever */
-	{
-		XEvent evt;
-		XPeekEvent(dpy, &evt);
-		return True;
-	}else if (timeout > 0)
-	{
-		fd_set        in_fdset;
-		int x_fd = XConnectionNumber (dpy);
-		struct timeval tv;
-		struct timeval *t = NULL;
-		int retval = 0 ;
-			
-		FD_ZERO (&in_fdset);
-		FD_SET (x_fd, &in_fdset);
-		tv.tv_sec = timeout/1000 ;
-		tv.tv_usec = (timeout%1000)*1000;
-		t = &tv;
-		retval = PORTABLE_SELECT(x_fd+1,&in_fdset,NULL,NULL,t);
-		return (retval > 0);
-	}
-	
-	return XPending(dpy);
-#endif
-	return 0;	
-}
-
-Window showimage(ASImage* im, Bool looping, Window main_window, ASComposeWinProps *props, int dst_x, int dst_y ) 
-{
-#ifndef X_DISPLAY_MISSING
-	int x = 32, y = 32;
-	ASImage *orig_im = im ;
-	unsigned int width, height;
-	unsigned int shape_rects_count = 0;
-	XRectangle *shape_rects = NULL ;
-	Bool done = False ;
-	Window root = DefaultRootWindow(dpy);
-	int screen = DefaultScreen(dpy);
-	int root_w = DisplayWidth (dpy, screen);
-	int root_h = DisplayHeight (dpy, screen);
-	Pixmap saved_canvas = None;
-
-	if (im == NULL || main_window == None ) 
-		return None;
-
-	width = im->width + dst_x;
-	height = im->height + dst_y;
-	   
-	if( main_window != root)
-	{	
-		Bool move = True ;
-		
-		if( get_flags( props->geom_flags, WidthValue) && props->geom_width > 0  )
-			width = props->geom_width ;
-		if( get_flags( props->geom_flags, HeightValue)&& props->geom_height > 0  )
-			height = props->geom_height ;
-		
-		if( props->center ) 
-		{	
-			x = (root_w - width)/2;
-			y = (root_h - height)/2;
-		}else if( get_flags( props->geom_flags, XValue|YValue) )
-		{
-	 		x = props->geom_x ;
-			y = props->geom_y ;
-			if( get_flags( props->geom_flags, XNegative ) )
-				x = root_w - width + x ;
-			if( get_flags( props->geom_flags, YNegative ) )
-				y = root_h - height + y ;
-		}else 
-			move = False ;
-
-		if( move && (props->last_x != x || props->last_y != y))
-		{	
-			XMoveWindow( dpy, main_window, x, y );
-			props->last_x = x ;
-			props->last_y = y ;
-		}
-		if( props->last_width != width || props->last_height != height )
-		{	
-			XResizeWindow( dpy, main_window, width, height );
-			props->last_width = width ;
-			props->last_height = height ;
-			saved_canvas = props->canvas;
-			props->canvas = None; /* force resizng the pixmap !!! */
-		}
-	
-		if( !props->mapped ) 
-		{	
-			if( props->geom_flags != 0 ) 
-			{
-				XSizeHints hints ;
-				hints.flags = PWinGravity ; 
-				if( get_flags( props->geom_flags, WidthValue|HeightValue) )
-					hints.flags |= USSize ; 
-				if( get_flags( props->geom_flags, XValue|YValue) )
-					hints.flags |= USPosition ; 
-				hints.win_gravity = NorthWestGravity ;
-				if( get_flags( props->geom_flags, XNegative) && !get_flags( props->geom_flags, YNegative)  )
-					hints.win_gravity = NorthEastGravity ;
-				else if( !get_flags( props->geom_flags, XNegative) && get_flags( props->geom_flags, YNegative)  )
-					hints.win_gravity = SouthWestGravity ;
-				else if( get_flags( props->geom_flags, XNegative) && get_flags( props->geom_flags, YNegative)  )
-					hints.win_gravity = SouthEastGravity ;
-				XSetWMNormalHints( dpy, main_window, &hints );
-			}	 
-			XMapWindow( dpy, main_window);
-			props->mapped = True ;
-		}
-		if( props->on_top ) 
-			XRaiseWindow( dpy, main_window );
-		if( get_flags(get_asimage_chanmask(im), SCL_DO_ALPHA))
-		{	
-#ifdef SHAPE
-			if( !props->no_shape ) 
-				shape_rects = get_asimage_channel_rects( im, IC_ALPHA, 10, &shape_rects_count );
-#endif		   
-#if 1		
-			{		
-				unsigned int root_pmap_width, root_pmap_height;
-				Pixmap rp = GetRootPixmap(None);
-				ASImage *transp_im = NULL , *tmp ;
-				int root_x, root_y ; Window wdumm;
-				XTranslateCoordinates( dpy, main_window, root, 0, 0, &root_x, &root_y, &wdumm);
-					
-				if (rp) 
-				{
-					if( props->last_root_pmap != rp ||
-						props->last_root_im == NULL )   
-					{
-						if( props->last_root_im ) 
-							safe_asimage_destroy(props->last_root_im);
-						get_dpy_drawable_size(asv->dpy, rp, &root_pmap_width, &root_pmap_height);
-						transp_im = pixmap2asimage(asv, rp, 0, 0, root_pmap_width, root_pmap_height, 0xFFFFFFFF, False, 0);
-						props->last_root_pmap = rp ;
-						props->last_root_im = transp_im ;   
-					}else
-					{
-						width = props->last_root_im->width ; 
-						height = props->last_root_im->height ;
-						transp_im = props->last_root_im ;
-					}	 
-				}
-		
-				if( transp_im ) 
-				{   /* Build the layers first. */	
-					ASImageLayer *layers = create_image_layers( 2 );
-					
-					layers[0].im = transp_im ;
-					layers[0].clip_x = root_x+dst_x;
-					layers[0].clip_y = root_y+dst_y;
-					layers[0].clip_width = im->width ;
-					layers[0].clip_height = im->height ;
-					layers[1].im = im ;
-					layers[1].clip_width = im->width ;
-					layers[1].clip_height = im->height ;
-					tmp = merge_layers(asv, layers, 2, im->width, im->height, 
-									   get_flags( asv->glx_support, ASGLX_UseForImageTx )?ASA_ASImage:ASA_XImage, 0, ASIMAGE_QUALITY_DEFAULT);
-					if( tmp ) 
-						im = tmp ;
-					free( layers );
-				}		
-			}
-#endif
-		}		   
-	}
-
-	LOCAL_DEBUG_OUT("canvas pixmap set to %lX", props->canvas);
-
-	if (props->canvas == None)
-	{
-		int depth = 0;
-		int pmap_width = width;
-		int pmap_height = height;
-		GC gc = NULL;
-		if (main_window==root)
-		{
-			pmap_width = dst_x+im->width;
-			pmap_height = dst_x+im->height;
-			depth = DefaultDepth(dpy,screen);
-			gc = DefaultGC(dpy, screen);
-		}
-		props->canvas = create_visual_pixmap( asv, main_window, pmap_width, pmap_height, DefaultDepth(dpy,screen));
-		LOCAL_DEBUG_OUT("Created new canvas pixmap %lX", props->canvas);
-
-		if (gc == NULL)
-			gc = XCreateGC( dpy, main_window, 0, NULL);
-		
-		if (pmap_width != im->width || pmap_height != im->height)
-			XFillRectangle( dpy, props->canvas, gc, 0, 0, pmap_width, pmap_height);
-
-		if (saved_canvas)
-            XCopyArea (dpy, saved_canvas, props->canvas, gc, 
-			           0, 0, MIN(props->canvas_width,pmap_width), MIN(props->canvas_height,pmap_height), 
-					   0, 0);
-					   
-		if (gc != DefaultGC(dpy, screen))
-			XFreeGC (dpy, gc);
-
-		props->canvas_width = pmap_width;
-		props->canvas_height = pmap_height;
-	}
-	if (main_window==root)
-	{
-		XImage *xim = create_visual_scratch_ximage( asv, im->width, im->height, DefaultDepth(dpy,screen) );
-		if( subimage2ximage (asv, im, 0, 0, xim)	)
-		{	
-			put_ximage( asv, xim, props->canvas, DefaultGC(dpy,screen), 0, 0, dst_x, dst_y, im->width, im->height );	
-		}
-		XDestroyImage( xim );				   
-	}else
-	{
-		if( get_flags( asv->glx_support, ASGLX_UseForImageTx ) )
-			done = asimage2drawable_gl( asv, props->canvas, im, 0, 0, 0, 0, 
-										im->width, im->height, 
-				   						im->width, im->height, 
-										False );
-		if( !done ) 
-			asimage2drawable( asv, props->canvas, im, NULL, 0, 0, dst_x, dst_y, im->width, im->height, True);
-	}
-
-	if( im != orig_im ) 
-	{	
-		safe_asimage_destroy(im);
-		im = orig_im ;
-	}
-
-	XSetWindowBackgroundPixmap( dpy, main_window, props->canvas);
-	XClearWindow( dpy, main_window);
-	XFlush(dpy);
-	if (main_window == root && !looping)
-	{
-		if (set_root_pixmap_property(props->canvas))
-		{
-			props->canvas = None;
-			XSync(dpy,False);
-		}
-	}
-		
-	if (saved_canvas)
-	{
-		LOCAL_DEBUG_OUT("Freeing saved canvas pixmap %lX", saved_canvas);
-		XFreePixmap( dpy, saved_canvas);
-	}
-
-	if (main_window == root && !looping)
-		return root;
-	
-#if 1
-#ifdef SHAPE
-	if( shape_rects == NULL || shape_rects_count == 0 ) 
-		XShapeCombineMask( dpy, main_window, ShapeBounding, 0, 0, None, ShapeSet );
-	else
-	{	
-		XShapeCombineRectangles (dpy, main_window, ShapeBounding, 0, 0, shape_rects, shape_rects_count, ShapeUnion, Unsorted);
-		free( shape_rects );
-		shape_rects = NULL ;
-	}
-#endif		   
-#endif		   
-	XSync(dpy, False);
-	
-	while(main_window != None)
-  	{
-    	XEvent event ;
-		Bool do_close = False ;
-		
-		if ( props->timeout && !wait_x_timeout(props->timeout) )
-		{
-			if( looping ) 
-				return main_window;
-			do_close = True ;
-		}	 
-		if( !do_close ) 
-		{	
-			if (!XPending(dpy))
-				if (!wait_x_timeout(props->click_timeout))
-					if( looping ) 
-						return main_window;
-
-	    	XNextEvent (dpy, &event);
-  			switch(event.type)
-			{
-	  			case ClientMessage:
-			    	if (event.xclient.format == 32 &&
-	  			    	event.xclient.data.l[0] == _XA_WM_DELETE_WINDOW)
-					{
-						do_close = True ;
-					}
-					break;
-		  		case ButtonPress:
-					LOCAL_DEBUG_OUT( "ButtonPress: looping = %d", looping);
-					if( looping ) 
-						return main_window;
-					do_close = True ;
-					break;
-			}
-		}
-		if( do_close ) 
-		{
-			if( main_window != root )
-				XDestroyWindow( dpy, main_window );
-			XFlush( dpy );
-			main_window = None ;
-		}	 
-  	}
-	
-#endif /* X_DISPLAY_MISSING */
-	return main_window;
-}
-
-
-char *load_stdin()
-{
-#define BUFSIZE 512	
-	char buffer[BUFSIZE] ;
-	char *complete = safemalloc(8192) ; 
-	int complete_allocated = 8192 ;
-	int complete_curr = 0 ;
-	int len ;
-	
-	while( fgets( &buffer[0], BUFSIZE, stdin ) != NULL )
-	{
-		len = strlen( &buffer[0] );
-		if( complete_curr + len > complete_allocated ) 
-		{
-			complete_allocated+=len	  ;
-	 		complete = realloc( complete, complete_allocated );
-		}
-		memcpy( &complete[complete_curr], &buffer[0], len ); 	  
-		complete_curr += len ;
-	}		 
-	return complete;
-}	 
-
diff -Naur libAfterImage-1.20/apps/ascompose.man root/graf2d/asimage/src/libAfterImage/apps/ascompose.man
--- libAfterImage-1.20/apps/ascompose.man	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/ascompose.man	1970-01-01 01:00:00.000000000 +0100
@@ -1,142 +0,0 @@
-.\" Source: ascompose.c 
-.\" Generated with ROBODoc Version 3.2.3 (Jul 29 2001)
-.\" ROBODoc (c) 1994-2001 by Frans Slothouber and Jacco van Weert.
-.\" t
-.\" @(#)ascompose.c.3
-.TH ascompose.c 1 "Mon Feb 18 2002" ascompose.c 3
-.PM Generated from ascompose.c with ROBODoc v3.2.3 on Mon Feb 18 01:14:58 2002
-
-.SH libAfterImage/ascompose
-.SS\fB NAME\fP 
-.nf
-\fR  \fBascompose\fP is a tool to compose image(s) and display/\fBsave\fP it based on
- supplied XML input file\.
-
-\fP 
-.fi
-.SS\fB SYNOPSIS\fP 
-.nf
- \fBascompose\fP \-f file|\-s string [\-o file] [\-t type] [\-V]"
- \fBascompose\fP \-f file|\-s string [\-o file] [\-t type] [\-V]"
- \fBascompose\fP \-f file|\-s string [\-o file] [\-t type] [\-V] [\-n]"
- \fBascompose\fP \-f file|\-s string [\-o file] [\-t type] [\-V] [\-r]"
- \fBascompose\fP [\-h]
- \fBascompose\fP [\-v]
-
-
-.fi
-.SS\fB DESCRIPTION\fP 
-.nf
- \fBascompose\fP reads supplied XML data, and manipulates image accordingly\.
- It could transform images from files of any supported file format,
- draw gradients, render antialiased texturized \fBtext\fP, perform
- superimposition of arbitrary number of images, and \fBsave\fP images into
- files of any of supported output file formats\.
-
- At any point, the result of any operation could be assigned a name,
- and later on referenced under this name\.
-
- At any point during the script processing, result of any operation
- could be saved into a file of any supported file types\.
-
- Internal image format is 32bit ARGB with 8bit per channel\.
-
- Last image referenced, will be displayed in X \fBwindow\fP, unless \-n option
- is specified\. If \-r option is specified, then this image will be
- displayed in root \fBwindow\fP of X display, effectively setting a background
- for a desktop\. If \-o option is specified, this image will also be
- saved into the file or requested type\.
-
- \fBascompose\fP can be compiled to not reference X \fBWindow\fP System, thus
- allowing it to be used on web servers and any other place\. It does not
- even require X libraries in that case\.
-
- Supported file types for input are :
- XPM   \- via internal code, or libXpm library\.
- JPEG  \- via libJpeg library\.
- PNG   \- via libPNG library\.
- XCF   \- via internal code\. For now XCF support is not complete as it
-         does not merge layers\.
- PPM/PNM \- via internal code\.
- BMP, ICO, CUR \- via internal code\.
- GIF   \- via libungif library\.
- TIFF  \- via libtiff library (including \fBalpha\fP channel support)\.
- see \fBlibAfterImage\fP/\fBASImageFileTypes\fP for more\.
-
- Supported file types for output :
- XPM   \- via internal code, or libXpm library\.
- JPEG  \- via libJpeg library\.
- PNG   \- via libPNG library\.
- GIF   \- via libungif library\.
- TIFF  \- via libtiff library (including \fBalpha\fP channel support)\.
-
-
-.fi
-.SS\fB OPTIONS\fP 
-.nf
-    \-h \-\-help          display help and exit\.
-    \-f \-\-file file     an XML file to use as input\.
-    \-s \-\-string string an XML string to use as input\.
-    \-n \-\-no\-display    don't display the last referenced image\.
-    \-r \-\-root\-\fBwindow\fP   draw last referenced image image on root \fBwindow\fP\.
-    \-o \-\-output file   output last referenced image in to a file\.
-                       You should use \-t to specify what file type to
-                       use\. Filenames are meaningless when it comes to
-                       determining what file type to use\.
-    \-t \-\-type type     type of file to output to\.
-    \-v \-\-version       display version and exit\.
-    \-V \-\-verbose       increase \fBverbosity\fP\. To increase \fBverbosity\fP level
-                       use several of these, like: \fBascompose\fP \-V \-V \-V\.
-    \-D \-\-debug         maximum \fBverbosity\fP \- show everything and
-                       debug messages\.
-
-.fi
-.SS\fB PORTABILITY\fP 
-.nf
- \fBascompose\fP could be used both with and without X \fBwindow\fP system\. It has
- been tested on most UNIX flavors on both 32 and 64 bit architecture\.
- It has also been tested under CYGWIN environment on Windows 95/NT/2000
-
-.fi
-.SS\fB USES\fP 
-.nf
- \fBlibAfterImage\fP         all the image manipulation routines\.
- libAfterBase          Optionally\. Misc data handling such as hash
-                       tables and console io\. Must be used when compiled
-                       without X \fBWindow\fP support\.
- libJPEG               JPEG image format support\.
- libPNG                PNG image format support\.
- libungif              GIF image format support\.
- libTIFF               TIFF image format support\.
-
-.fi
-.SS\fB AUTHOR\fP 
-.nf
-\fB  Ethan Fisher          <allanon at crystaltokyo dot com>
- Sasha Vasko           <sasha at aftercode dot net>
- Eric Kowalski         <eric at beancrock dot net>
-\fP 
-.fi
-
-.PP
-.SH libAfterImage/ascompose/sample
-.SS\fB EXAMPLE\fP 
-.nf
- Here is the default script that gets executed by \fBascompose\fP, if no
- parameters are given :
-
-.fi
-.SS\fB SOURCE\fP 
-.nf
-    static char* default_doc_str = "\\
-    <\fBcomposite\fP op=hue>\\
-      <\fBcomposite\fP op=add>\\
-        <\fBscale\fP width=512 height=384><\fBimg\fP src=rose512\.jpg/></\fBscale\fP>\\
-        <\fBtile\fP width=512 height=384><\fBimg\fP src=back\.xpm/></\fBtile\fP>\\
-      </\fBcomposite\fP>\\
-      <\fBtile\fP width=512 height=384><\fBimg\fP src=fore\.xpm/></\fBtile\fP>\\
-    </\fBcomposite\fP>\\
-    ";
-.fi
-
-.PP
diff -Naur libAfterImage-1.20/apps/asflip.c root/graf2d/asimage/src/libAfterImage/apps/asflip.c
--- libAfterImage-1.20/apps/asflip.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/asflip.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,218 +0,0 @@
-#include "config.h"
-
-#include <string.h>
-#include <stdlib.h>
-
-/****h* libAfterImage/tutorials/ASFlip
- * NAME
- * ASFlip
- * SYNOPSIS
- * libAfterImage application for image rotation.
- * DESCRIPTION
- * New steps described in this tutorial are :
- * ASFlip.1. Flip value.
- * ASFlip.2. Rotating ASImage.
- * SEE ALSO
- * Tutorial 1: ASView  - explanation of basic steps needed to use
- *                       libAfterImage and some other simple things.
- * Tutorial 2: ASScale - image scaling basics.
- * Tutorial 3: ASTile  - image tiling and tinting.
- * Tutorial 4: ASMerge - scaling and blending of arbitrary number of
- *                       images.
- * Tutorial 5: ASGrad  - drawing multipoint linear gradients.
- * SOURCE
- */
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "common.h"
-
-void usage()
-{
-	printf( "Usage: asflip [-h]|[[-f flip]|[-m vertical] "
-			"[-g geom] image]");
-	printf( "\nWhere: image - is image filename\n");
-	printf( "       flip  - rotation angle in degrees. "
-			"90, 180 and 270 degrees supported\n");
-	printf( "       geom  - source image is tiled using this geometry, "
-			"prior to rotation\n");
-	printf( "       vertical - 1 - mirror image in vertical direction, "
-			"0 - horizontal\n");
-}
-
-int main(int argc, char* argv[])
-{
-	Display *dpy = NULL;
-	ASVisual *asv ;
-	int screen = 0 , depth = 0 ;
-	char *image_file = "rose512.jpg" ;
-	int flip = FLIP_VERTICAL;
-	Bool vertical = False, mirror = False ;
-	int tile_x, tile_y, geom_flags = 0;
-	unsigned int tile_width, tile_height ;
-	ASImage *im = NULL;
-	ASImage *flipped_im = NULL ;
-
-	/* see ASView.1 : */
-	set_application_name( argv[0] );
-
-	if( argc > 1 )
-	{
-		int i = 1 ;
-		if( strcmp( argv[1], "-h" ) == 0 )
-		{
-			usage();
-			return 0;
-		}
-		for( i = 1 ; i < argc ; i++ )
-		{
-			if( argv[i][0] == '-' && i < argc-1 )
-			{
-				switch(argv[i][1])
-				{
-					case 'm' :
-						mirror = True;
-						vertical = atoi(argv[i+1]) ;
-					    break ;
-					case 'f' :			/* see ASFlip.1 */
-						mirror = False;
-						flip = atoi(argv[i+1])/90 ;
-					    break ;
-					case 'g' :   		/* see ASTile.2 : */
-	    				geom_flags = XParseGeometry( argv[i+1],
-							                         &tile_x, &tile_y,
-		        				        			 &tile_width,
-													 &tile_height );
-					    break ;
-				}
-				++i ;
-			}else
-				image_file = argv[i] ;
-		}
-	}else
-		usage();
-
-#ifndef X_DISPLAY_MISSING
-    dpy = XOpenDisplay(NULL);
-	_XA_WM_DELETE_WINDOW = XInternAtom( dpy, "WM_DELETE_WINDOW", False);
-	screen = DefaultScreen(dpy);
-	depth = DefaultDepth( dpy, screen );
-#endif
-	/* see ASView.2 : */
-	im = file2ASImage( image_file, 0xFFFFFFFF, SCREEN_GAMMA, 0, getenv("IMAGE_PATH"), NULL );
-	if( im == NULL )
-		return 1;
-
-	/* Making sure tiling geometry is sane : */
-	if( !get_flags(geom_flags, XValue ) )
-		tile_x = 0 ;
-	if( !get_flags(geom_flags, YValue ) )
-		tile_y = 0 ;
-	if( !get_flags(geom_flags, WidthValue ) )
-	{
-		if( !mirror )
-			tile_width = (get_flags(flip,FLIP_VERTICAL))?
-						 	im->height:im->width ;
-		else
-			tile_width = im->width ;
-	}
-	if( !get_flags(geom_flags, HeightValue ) )
-	{
-		if( !mirror )
-			tile_height = (get_flags(flip,FLIP_VERTICAL))?
-							im->width:im->height;
-		else
-			tile_height = im->height ;
-	}
-	printf( "%s: tiling image \"%s\" to %dx%d%+d%+d and then "
-			"flipping it by %d degrees\n",
-		    get_application_name(), image_file,
-			tile_width, tile_height,tile_x, tile_y, flip*90 );
-
-	/* see ASView.3 : */
-	asv = create_asvisual( dpy, screen, depth, NULL );
-
-	/* see ASFlip.2 : */
-	if( !mirror )
-		flipped_im = flip_asimage( 	asv, im,
-			                       	tile_x, tile_y,
-									tile_width, tile_height,
-				       	 			flip,
-				                	ASA_ASImage, 0, 
-									ASIMAGE_QUALITY_DEFAULT );
-	else
-		flipped_im = mirror_asimage(asv, im,
-			                       	tile_x, tile_y,
-									tile_width, tile_height,
-				       	 			vertical,
-				                	ASA_ASImage, 0, 
-									ASIMAGE_QUALITY_DEFAULT );
-	destroy_asimage( &im );
-
-	if( flipped_im )
-	{
-#ifndef X_DISPLAY_MISSING
-		/* see ASView.4 : */
-		Window w = create_top_level_window( asv, DefaultRootWindow(dpy), 
-											32, 32,
-			  		      	                tile_width, tile_height, 
-											1, 0, NULL,
-											"ASFlip", image_file );
-		if( w != None )
-		{
-			Pixmap p ;
-
-		  	XMapRaised   (dpy, w);
-			/* see ASView.5 : */
-			p = asimage2pixmap( asv, DefaultRootWindow(dpy), flipped_im,
-					            NULL, True );
-			destroy_asimage( &flipped_im );
-			/* see common.c: set_window_background_and_free() : */
-			p = set_window_background_and_free( w, p );
-			/* see common.c: wait_closedown() : */
-		}
-		wait_closedown(w);
-		dpy = NULL;
-#else
-		/* writing result into the file */
-		ASImage2file( flipped_im, NULL, "asflip.jpg", ASIT_Jpeg, NULL );
-		destroy_asimage( &flipped_im );
-#endif
-	}
-    return 0 ;
-}
-/**************/
-/****f* libAfterImage/tutorials/ASFlip.1 [6.1]
- * SYNOPSIS
- * Step 1. Flip value.
- * DESCRIPTION
- * libAfterImage provides facility for rotating images in 90 degree
- * increments - flipping essentially. Accordingly flip parameter could
- * have 4 values - 0, -90, -180, -270 degrees.
- * EXAMPLE
- *     flip = atoi(argv[2])/90;
- * SEE ALSO
- * flip
- ********/
-/****f* libAfterImage/tutorials/ASFlip.2 [6.2]
- * SYNOPSIS
- * Step 2. Flipping ASImage.
- * DESCRIPTION
- * Flipping can actually be combined with offset and tiling. Original
- * image gets tiled to suplied rectangle, and then gets rotated to
- * requested degree.
- * EXAMPLE
- *  	flipped_im = flip_asimage(asv, im,
- * 			                      tile_x, tile_y,
- * 								  tile_width, tile_height,
- * 				       	 		  flip,
- * 				                  ASA_XImage,0, 
- * 								  ASIMAGE_QUALITY_DEFAULT );
- * 		destroy_asimage( &im );
- * NOTES
- * As far as we need to render rotated image right away - we set to_xim
- * parameter to True, so that image will be rotated into XImage. Right
- * after rotation is done - we can destroy original image.
- * SEE ALSO
- * flip_asimage()
- ********/
diff -Naur libAfterImage-1.20/apps/asgrad.c root/graf2d/asimage/src/libAfterImage/apps/asgrad.c
--- libAfterImage-1.20/apps/asgrad.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/asgrad.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,263 +0,0 @@
-#include "config.h"
-
-#include <string.h>
-#include <stdlib.h>
-
-
-/****h* libAfterImage/tutorials/ASGrad
- * NAME
- * ASGrad
- * SYNOPSIS
- * libAfterImage application for drawing multipoint linear gradients.
- * DESCRIPTION
- * New steps described in this tutorial are :
- * ASGrad.1. Building gradient specs.
- * ASGrad.2. Actual rendering gradient.
- * SEE ALSO
- * Tutorial 1: ASView  - explanation of basic steps needed to use
- *                       libAfterImage and some other simple things.
- * Tutorial 2: ASScale - image scaling basics.
- * Tutorial 3: ASTile  - image tiling and tinting.
- * Tutorial 4: ASMerge - scaling and blending of arbitrary number of
- *                       images.
- * SOURCE
- */
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "common.h"
-
-ARGB32 default_colors[] = {
-	0xFF000000,
-	0xFF700070,                                /* violet */
-	0xFF0000FF,                                /* blue   */
-	0xFF00FFFF,                                /* cyan   */
-	0xFF00FF00,
-	0XFFFFFF00,
-	0XFF700000,
-	0XFFFF0000,
-	0xFF8080A0,
-	0xFFE0E0FF,
-	0xFFa0a0FF,
-};
-double default_offsets[] = { 0, 0.1, 0.15, 0.20, 0.35, 0.45, 0.55, 0.50, 
-							 0.65, 0.8, 1.0} ;
-
-
-void usage()
-{
-	printf( "  Usage: asgrad -h | <geometry> <gradient_type> <color1> "
-			"<offset2> <color2> [ <offset3> <color3> ...]\n");
-	printf( "  Where: geometry - size of the resulting image and window;\n");
-	printf( "         gradient_type - One of the fiollowing values :\n");
-	printf( "            0 - linear   left-to-right gradient,\n");
-	printf( "            1 - diagonal lefttop-to-rightbottom,\n");
-	printf( "            2 - linear   top-to-bottom gradient,\n");
-	printf( "            3 - diagonal righttop-to-leftbottom;\n");
-	printf( "         offset   - floating point value from 0.0 to 1.0\n");
-}
-
-int main(int argc, char* argv[])
-{
-	Display *dpy = NULL;
-	ASVisual *asv ;
-	int screen = 0, depth = 0;
-	int dummy, geom_flags = 0;
-	unsigned int to_width, to_height ;
-	ASGradient grad ;
-	ASGradient default_grad = { 1, 11, &(default_colors[0]), 
-									   &(default_offsets[0])} ;
-	ASImage *grad_im = NULL;
-
-	/* see ASView.1 : */
-	set_application_name( argv[0] );
-#if (HAVE_AFTERBASE_FLAG==1)
-	set_output_threshold(OUTPUT_LEVEL_DEBUG);
-#endif
-
-	if( argc > 1 )
-	{
-	    if( strcmp( argv[1], "-h") == 0 )
-	    {
-			usage();
-			return 0;
-		}
-	    /* see ASScale.1 : */
-	    geom_flags = XParseGeometry( argv[1], &dummy, &dummy,
-		                             &to_width, &to_height );
-	}else
-		usage();
-	memset( &grad, 0x00, sizeof(ASGradient));
-
-#ifndef X_DISPLAY_MISSING
-    dpy = XOpenDisplay(NULL);
-	_XA_WM_DELETE_WINDOW = XInternAtom( dpy, "WM_DELETE_WINDOW", False);
-	screen = DefaultScreen(dpy);
-	depth = DefaultDepth( dpy, screen );
-#endif
-
-	if( argc >= 5 )
-	{
-		int i = 2;
-		/* see ASGrad.1 : */
-		grad.type = atoi( argv[2] );
-		grad.npoints = 0 ;
-		grad.color = safemalloc( ((argc-2)/2)*sizeof(ARGB32));
-		grad.offset = safemalloc( ((argc-2)/2)*sizeof(double));
-		while( ++i < argc )
-		{
-			if( grad.npoints > 0 )
-			{
-				if( i == argc-1 )
-					grad.offset[grad.npoints] = 1.0;
-				else
-					grad.offset[grad.npoints] = atof( argv[i] );
-				++i ;
-			}
-
-			/* see ASTile.1 : */
-			if( parse_argb_color( argv[i], &(grad.color[grad.npoints])) 
-				!= argv[i] )
-				if( grad.offset[grad.npoints] >= 0. && 
-					grad.offset[grad.npoints]<= 1.0 )
-					grad.npoints++ ;
-		}
-	}else
-	{
-		grad = default_grad ;
-		if( argc >= 3 )
-			grad.type = atoi( argv[2] );
-	}
-
-	if( grad.npoints <= 0 )
-	{
-		show_error( " not enough gradient points specified.");
-		return 1;
-	}
-
-	/* Making sure tiling geometry is sane : */
-#ifndef X_DISPLAY_MISSING
-	if( !get_flags(geom_flags, WidthValue ) )
-		to_width  = DisplayWidth(dpy, screen)*2/3 ;
-	if( !get_flags(geom_flags, HeightValue ) )
-		to_height = DisplayHeight(dpy, screen)*2/3 ;
-#else
-	if( !get_flags(geom_flags, WidthValue ) )
-		to_width  = 500 ;
-	if( !get_flags(geom_flags, HeightValue ) )
-		to_height = 500 ;
-#endif
-	printf( "%s: rendering gradient of type %d to %dx%d\n",
-			get_application_name(), grad.type&GRADIENT_TYPE_MASK, 
-			to_width, to_height );
-
-	/* see ASView.3 : */
-	asv = create_asvisual( dpy, screen, depth, NULL );
-	/* see ASGrad.2 : */
-	grad_im = make_gradient( asv, &grad, to_width, to_height,
-	        	             SCL_DO_ALL,
-#ifndef X_DISPLAY_MISSING
-							 ASA_XImage,
-#else
-							 ASA_ASImage,
-#endif
-							 0, ASIMAGE_QUALITY_DEFAULT );
-	if( grad_im )
-	{
-#ifndef X_DISPLAY_MISSING
-		/* see ASView.4 : */
-		Window w = create_top_level_window( asv,
-		                                    DefaultRootWindow(dpy), 32, 32,
-		                        			to_width, to_height, 1, 0, NULL,
-											"ASGradient", NULL );
-		if( w != None )
-		{
-			Pixmap p ;
-
-		  	XMapRaised   (dpy, w);
-			/* see ASView.5 : */
-			p = asimage2pixmap( asv, DefaultRootWindow(dpy), grad_im,
-					            NULL, True );
-			destroy_asimage( &grad_im );
-			/* see common.c: set_window_background_and_free() : */
-			p = set_window_background_and_free( w, p );
-			/* see common.c: wait_closedown() : */
-		}
-		wait_closedown(w);
-		dpy = NULL;
-#else
-		ASImage2file( grad_im, NULL, "asgrad.jpg", ASIT_Jpeg, NULL );
-		destroy_asimage( &grad_im );
-#endif
-	}
-    return 0 ;
-}
-/**************/
-
-/****f* libAfterImage/tutorials/ASGrad.1 [5.1]
- * SYNOPSIS
- * Step 1. Building gradient specs.
- * DESCRIPTION
- * Multipoint gradient is defined as set of color values with offsets
- * of each point from the beginning of the gradient on 1.0 scale.
- * Offsets of the first and last point in gradient should always be
- * 0. and 1.0 respectively, and other points should go in between.
- * For example 2 point gradient will have always offsets 0. and 1.0,
- * 3 points gradient will have 0. for first color, 1.0 for last color
- * and anything in between for middle color.
- * If offset is incorrect - point will be skipped at the time of
- * rendering.
- *
- * There are 4 types of gradients supported : horizontal, top-left to
- * bottom-right diagonal, vertical and top-right to bottom-left diagonal.
- * Any cilindrical gradient could be drawn as a 3 point gradient with
- * border colors being the same.
- *
- * Each gradient point has ARGB color, which means that it is possible
- * to draw gradients in alpha channel as well as RGB. That makes for
- * semitransparent gradients, fading gradients, etc.
- * EXAMPLE
- *  	grad.type = atoi( argv[2] );
- * 		grad.npoints = 0 ;
- * 		grad.color = safemalloc( ((argc-2)/2)*sizeof(ARGB32));
- * 		grad.offset = safemalloc( ((argc-2)/2)*sizeof(double));
- * 		while( ++i < argc )
- * 		{
- * 			if( grad.npoints > 0 )
- * 			{
- * 				if( i == argc-1 )
- * 					grad.offset[grad.npoints] = 1.0;
- * 				else
- * 					grad.offset[grad.npoints] = atof( argv[i] );
- * 				++i ;
- * 			}
- *  		if( parse_argb_color( argv[i], &(grad.color[grad.npoints]))
- *              != argv[i] )
- * 				if(grad.offset[grad.npoints] >= 0. &&
- *                 grad.offset[grad.npoints]<= 1.0 )
- * 					grad.npoints++ ;
- * 		}
- * SEE ALSO
- * ARGB32, parse_argb_color(), ASGradient
- ********/
-/****f* libAfterImage/tutorials/ASGrad.2 [5.2]
- * SYNOPSIS
- * Step 2. Actually rendering gradient.
- * DESCRIPTION
- * All that is needed to draw gradient is to call make_gradient(),
- * passing pointer to ASGradient structure, that describes gradient.
- * Naturally size of the gradient is needed too. Another parameter is
- * filter - that is a bit mask that allows to draw gradient using only a
- * subset of the channels, represented by set bits. SCL_DO_ALL means
- * that all 4 channels must be rendered.
- * make_gradient() creates ASImage of requested size and fills it with
- * gradient. Special techinque based on error diffusion is utilized to
- * avoid sharp steps between grades of colors when limited range of
- * colors is used for gradient.
- * EXAMPLE
- * 		grad_im = make_gradient( asv, &grad, to_width, to_height,
- * 		        	             SCL_DO_ALL,
- *  		                     ASA_XImage, 0, ASIMAGE_QUALITY_DEFAULT );
- * NOTES
- * make_gradient(), ASScanline, ASImage.
- ********/
diff -Naur libAfterImage-1.20/apps/asi18n.c root/graf2d/asimage/src/libAfterImage/apps/asi18n.c
--- libAfterImage-1.20/apps/asi18n.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/asi18n.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,286 +0,0 @@
-#include "config.h"
-
-#include <string.h>
-#include <stdlib.h>
-
-#define LOCAL_DEBUG 
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "common.h"
-#include "../char2uni.h"
-
-/* Usage:  astext [-f font] [-s size] [-t text] [-S 3D_style]
-                  [-c text_color] [-b background_color]
-                  [-T foreground_texture] [-B background_image]
-				  [-r foreground_resize_type] [-R background_resize_type]
- */
-
-#define BEVEL_HI_WIDTH 20
-#define BEVEL_LO_WIDTH 30
-#define BEVEL_ADDON    (BEVEL_HI_WIDTH+BEVEL_LO_WIDTH)
-
-void usage()
-{
-	printf( "  Usage:   astext [-h] [-f font] [-s size] [-t text] [-S 3D_style] \n");
-	printf( "                  [-c text_color] [-b background_color]\n");
-	printf( "                  [-T foreground_texture] [-B background_image]\n");
-	printf( "      			   [-r foreground_resize_type] [-R background_resize_type]\n");
-	printf( "  Where: font - TrueType font's filename or X font spec or alias;\n");
-	printf( "         size - size in points for TrueType fonts;\n");
-	printf( "         text - text to be drawn;\n");
-	printf( "         3D_style - 3D style of text. One of the following:\n");
-	printf( "             0 - plain 2D tetx, 1 - embossed, 2 - sunken, 3 - shade above,\n");
-	printf( "             4 - shade below, 5 - embossed thick 6 - sunken thick.\n");
-	printf( "         resize_type - tells how texture/image should be transformed to fit\n");
-	printf( "                       the text size. Could be: scale or tile. Default is tile\n");
-
-}
-
-int main(int argc, char* argv[])
-{
-	Display *dpy = NULL;
-	ASVisual *asv = NULL ;
-	int screen = 0, depth = 0;
-	char *font_name = "./test.ttf";
-	int size = 15 ;
-	char default_text[257] = {0xd0, 0x9d, 0x2e, 0xd0, 0x94, 0xd0, 0xbe, 0xd0, 0xb1, 0xd1, 0x80, 0xd0, 0xbe, 0xd1, 0x85, 0xd0, 0xbe, 0xd1, 0x82, 0xd0, 0xbe, 0xd0, 0xb2, 0xd0, 0xb0, 0x2c, 0x20, 0xd0, 0x92, 0x2e, 0xd0, 0x9f, 0xd1, 0x8f, 0xd1, 0x82, 0xd0, 0xbd, 0xd0, 0xb8, 0xd1, 0x86, 0xd0, 0xba, 0xd0, 0xb8, 0xd0, 0xb9, 0x2e, 0x20, 0xd0, 0x92, 0xd0, 0xb5, 0xd1, 0x81, 0xd0, 0xb5, 0xd0, 0xbb, 0xd1, 0x8b, 0xd0, 0xb5, 0x20, 0xd1, 0x80, 0xd0, 0xb5, 0xd0, 0xb1, 0xd1, 0x8f, 0xd1, 0x82, 0xd0, 0xb0, 0x20, 0x2d, 0x20, 0x4d, 0x6f, 0x7a, 0x69, 0x6c, 0x6c, 0x61, 0x20, 0x7b, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x20, 0x49, 0x44, 0x3a, 0x20, 0x32, 0x30, 0x30, 0x32, 0x30, 0x35, 0x32, 0x39, 0x31, 0x38, 0x7d, 0x00, 0x00, 0x00};
-	char *text = &default_text[0];
-	ARGB32 text_color = ARGB32_White, back_color = ARGB32_Black;
-	char *text_color_name = "#FFFFFFFF", *back_color_name = "#FF000000";
-	char *fore_image_file = "fore.xpm", *back_image_file = "back.xpm" ;
-	Bool scale_fore_image = False, scale_back_image = False ;
-	ASImage *fore_im = NULL, *back_im = NULL;
-	ASImage *text_im = NULL ;
-	ASText3DType type_3d = AST_ShadeBelow ;
-	struct ASFontManager *fontman = NULL;
-	struct ASFont  *font = NULL;
-	unsigned int width, height ;
-	int i;
-	int text_margin = size/2, text_height ;
-
-
-	/* see ASView.1 : */
-	set_application_name( argv[0] );
-#if (HAVE_AFTERBASE_FLAG==1)
-	set_output_threshold(OUTPUT_LEVEL_DEBUG);
-#endif
-
-#if 0
-	for( i = 0x21 ; i < 256 ;++i ) 
-	{
-		default_text[k++] = i ;
-		if( k%50 == 0 ) 
-			default_text[k++] = '\n' ;
-	}
-	default_text[i-0x21] = '\0' ;
-#endif	
-	if( argc == 1 )
-		usage();
-	else for( i = 1 ; i < argc ; i++ )
-	{
-		if( strncmp( argv[i], "-h", 2 ) == 0 )
-		{
-			usage();
-			return 0;
-		}
-		if( i+1 < argc )
-		{
-			if( strncmp( argv[i], "-l", 2 ) == 0 )
-			{
-				/* we need to set our charset here : */
-				as_set_charset( parse_charset_name( argv[i+1] ));
-			}else if( strncmp( argv[i], "-f", 2 ) == 0 )
-				font_name = argv[i+1] ;
-			else if( strncmp( argv[i], "-s", 2 ) == 0 )
-			{
-				size = atoi(argv[i+1]);
-				text_margin = size/2 ;
-			}else if( strncmp( argv[i], "-t", 2 ) == 0 )
-				text = argv[i+1] ;
-			else if( strncmp( argv[i], "-S", 2 ) == 0 )
-			{
-				type_3d = atoi(argv[i+1]);
-				if( type_3d >= AST_3DTypes )
-				{
-					show_error( "3D type is wrong. Using 2D Plain instead.");
-					type_3d = AST_Plain ;
-				}
-
-			}else if( strncmp( argv[i], "-c", 2 ) == 0 )
-				text_color_name = argv[i+1] ;
-			else if( strncmp( argv[i], "-b", 2 ) == 0 )
-				back_color_name = argv[i+1] ;
-			else if( strncmp( argv[i], "-T", 2 ) == 0 )
-				fore_image_file = argv[i+1] ;
-			else if( strncmp( argv[i], "-B", 2 ) == 0 )
-				back_image_file = argv[i+1] ;
-			else if( strncmp( argv[i], "-r", 2 ) == 0 )
-				scale_fore_image = (strcmp( argv[i+1], "scale") == 0);
-			else if( strncmp( argv[i], "-R", 2 ) == 0 )
-				scale_back_image = (strcmp( argv[i+1], "scale") == 0);
-		}
-	}
-
-	for( i = 0 ; text[i] ; ) 
-	{
-		LOCAL_DEBUG_OUT( "pos = %u, char = %c, code = %u, unicode = %lu/%u, raw = %4.4X(%lu)", i, text[i], (unsigned char)text[i], CHAR2UNICODE(text[i]), ((as_current_charset[((unsigned short)text[i])&0x007F])),as_current_charset[((unsigned int)text[i])&0x007F], (CARD32)as_current_charset[((unsigned int)text[i])&0x007F] );
-		++i ;
-	}
-#ifndef X_DISPLAY_MISSING
-    dpy = XOpenDisplay(NULL);
-	_XA_WM_DELETE_WINDOW = XInternAtom( dpy, "WM_DELETE_WINDOW", False);
-	screen = DefaultScreen(dpy);
-	depth = DefaultDepth( dpy, screen );
-#endif
-
-	/* see ASText.1 : */
-	if( (fontman = create_font_manager( dpy, getenv("FONT_PATH"), NULL )) != NULL )
-		font = get_asfont( fontman, font_name, 0, size, ASF_GuessWho );
-
-	if( font == NULL )
-	{
-		show_error( "unable to load requested font \"%s\". Falling back to \"fixed\".", font_name );
-		font = get_asfont( fontman, "fixed", 0, size, ASF_GuessWho );
-		if( font == NULL )
-		{
-			show_error( "font \"fixed\" is not available either. Aborting.");
-			return 1;
-		}
-	}
-
-	parse_argb_color( text_color_name, &text_color );
-	parse_argb_color( back_color_name, &back_color );
-
-	/* see ASView.3 : */
-	asv = create_asvisual( dpy, screen, depth, NULL );
-
-	/* see ASText.2 : */
-	/*set_asfont_glyph_spacing( font, 10, 40 );*/
-	get_utf8_text_size( text, font, type_3d, &width, &height );
-	/*get_text_size( text, font, type_3d, &width, &height );*/
-	if( fore_image_file )
-	{
-		ASImage *tmp = file2ASImage( fore_image_file, 0xFFFFFFFF,
-		               		         SCREEN_GAMMA, 0, getenv("IMAGE_PATH"), NULL );
-		if( tmp )
-		{
-			if( tmp->width != width || tmp->height != height )
-			{   /* see ASScale.2 : */
-				if( scale_fore_image )
-					fore_im = scale_asimage( asv, tmp, width, height,
-  					                         ASA_ASImage, 0, ASIMAGE_QUALITY_DEFAULT );
-				else
-					fore_im = tile_asimage( asv, tmp, 0, 0, width, height, 0,
-  					                         ASA_ASImage, 0, ASIMAGE_QUALITY_DEFAULT );
-				destroy_asimage( &tmp );
-			}else
-				fore_im = tmp ;
-		}
-	}
-	width  += text_margin*2 + BEVEL_ADDON;
-	height += text_margin*2 + BEVEL_ADDON;
-	if( back_image_file )
-	{ /* see ASView.2 : */
-		ASImage *tmp = file2ASImage( back_image_file, 0xFFFFFFFF,
-			                        SCREEN_GAMMA, 0, NULL );
-		if( tmp )
-		{
-			if( scale_back_image && (tmp->width != width || tmp->height != height) )
-			{   /* see ASScale.2 : */
-				back_im = scale_asimage( asv, tmp, width, height,
-				                         ASA_ASImage, 0, ASIMAGE_QUALITY_DEFAULT );
-				destroy_asimage( &tmp );
-			}else
-				back_im = tmp ;
-		}
-	}
-
-	/* see ASText.3 : */
-	text_im = draw_utf8_text( text, font, type_3d, 0 );
-	if( fore_im )
-	{
-		move_asimage_channel( fore_im, IC_ALPHA, text_im, IC_ALPHA );
-		destroy_asimage( &text_im );
-	}else
-		fore_im = text_im ;
-
-	/* see ASText.1 : */
-	text_height	= ((int)font->max_height-(int)font->max_ascend) ;
-	release_font( font );
-	destroy_font_manager( fontman, False );
-
-	if( fore_im )
-	{
-		ASImage *rendered_im ;
-		ASImageLayer layers[2] ;
-		ASImageBevel bevel = {0/*BEVEL_SOLID_INLINE*/, 0xFFDDDDDD, 0xFF555555, 0xFFFFFFFF, 0xFF777777, 0xFF222222,
-		                      BEVEL_HI_WIDTH, BEVEL_HI_WIDTH,
-							  BEVEL_LO_WIDTH, BEVEL_LO_WIDTH,
-							  BEVEL_HI_WIDTH, BEVEL_HI_WIDTH,
-							  BEVEL_LO_WIDTH, BEVEL_LO_WIDTH } ;
-
-		/* see ASText.4 : */
-		init_image_layers( &(layers[0]), 2 );
-		if( back_im )
-			back_im->back_color = back_color ;
-		fore_im->back_color = text_color ;
-		layers[0].im = back_im ;
-		layers[0].dst_x = 0 ;
-		layers[0].dst_y = 0 ;
-		layers[0].clip_width = width ;
-		layers[0].clip_height = height ;
-		layers[0].bevel = &bevel ;
-		layers[1].im = fore_im ;
-		layers[1].dst_x = text_margin+BEVEL_HI_WIDTH*2 ;
-		layers[1].dst_y = text_margin+MIN((int)text_margin,text_height)/2+BEVEL_HI_WIDTH*2;
-		layers[1].clip_width = fore_im->width ;
-		layers[1].clip_height = fore_im->height ;
-		rendered_im = merge_layers( asv, &(layers[0]), 2,
-									width+BEVEL_ADDON, height+BEVEL_ADDON,
-#ifndef X_DISPLAY_MISSING
-									ASA_XImage,
-#else
-									ASA_ASImage,
-#endif
-									0, ASIMAGE_QUALITY_DEFAULT);
-		destroy_asimage( &fore_im );
-		destroy_asimage( &back_im );
-
-		if( rendered_im )
-		{
-#ifndef X_DISPLAY_MISSING
-			Window w;
-			/* see ASView.4 : */
-			w = create_top_level_window( asv, DefaultRootWindow(dpy), 32, 32,
-			      		                 width+BEVEL_ADDON, height+BEVEL_ADDON,
-										 1, 0, NULL,
-										 "ASText", text );
-			if( w != None )
-			{
-				Pixmap p ;
-
-			  	XMapRaised   (dpy, w);
-
-				/* see ASView.5 : */
-				p = asimage2pixmap( asv, DefaultRootWindow(dpy), rendered_im,
-						            NULL, True );
-				destroy_asimage( &rendered_im );
-				/* see common.c: set_window_background_and_free() : */
-				p = set_window_background_and_free( w, p );
-				/* see common.c: wait_closedown() : */
-			}
-			wait_closedown(w);
-			dpy = NULL;
-#else
-			/* writing result into the file */
-			ASImage2file( rendered_im, NULL, "astext.jpg", ASIT_Jpeg, NULL );
-			destroy_asimage( &rendered_im );
-#endif
-		}
-	}
-
-    return 0 ;
-
-}
-
diff -Naur libAfterImage-1.20/apps/asmerge.c root/graf2d/asimage/src/libAfterImage/apps/asmerge.c
--- libAfterImage-1.20/apps/asmerge.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/asmerge.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,311 +0,0 @@
-#include "config.h"
-
-#include <string.h>
-#include <stdlib.h>
-
-
-/****h* libAfterImage/tutorials/ASMerge
- * NAME
- * ASMerge
- * SYNOPSIS
- * Scaling and blending of arbitrary number of images
- * using libAfterImage.
- * DESCRIPTION
- * We will attempt to interpret command line arguments as sequence of
- * image filenames, geometries and blending types. We'll then try and
- * load all the images, scaling first one to requested size, and
- * blending others at specifyed locations of the first image.
- * We then display the result in simple window.
- * After that we would want to wait, until user closes our window.
- *
- * New steps described in this tutorial are :
- * Step 1. Layers.
- * Step 2. Merging methods.
- * Step 3. Layer parameters.
- * Step 4. Actual blending of the set of images.
- * SEE ALSO
- * Tutorial 1: ASView  - explanation of basic steps needed to use
- *                       libAfterImage and some other simple things.
- * Tutorial 2: ASScale - image scaling basics.
- * Tutorial 3: ASTile  - image tiling and tinting
- * SOURCE
- */
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "common.h"
-
-char *burning_rose[] =
-{
-	"asmerge",
-	"rose512.jpg",
-	"add",
-	"back.xpm:512x386",
-	"hue",
-	"fore.xpm:512x386"
-};
-
-void usage()
-{
-	printf( "Usage: asmerge [-h]|[image op1 image1 [op2 image2 [...]]]\n");
-	printf( "Where: image  - is background image filename\n");
-	printf( "       image1 - is first overlay's filename\n");
-	printf( "       op1,op2,... - overlay operation."
-			" Supported operations are :\n");
-	list_scanline_merging( stdout,
-	        "         %-15.15s- %s\n");
-}
-
-int main(int argc, char* argv[])
-{
-	Display *dpy = NULL;
-	ASVisual *asv ;
-	int screen = 0, depth = 0;
-	int to_width = 1, to_height = 1;
-	ASImageLayer *layers ;
-	int layers_num = 0, i;
-	ASImage *merged_im ;
-
-	/* see ASView.1 : */
-	set_application_name( argv[0] );
-#if (HAVE_AFTERBASE_FLAG==1)
-	set_output_threshold(OUTPUT_LEVEL_DEBUG);
-#endif
-	if( argc == 2 && strncmp(argv[1],"-h", 2) == 0 )
-	{
-		usage();
-		return 0;
-	}
-	if( argc <= 3 )
-	{
-		show_error( "not enough arguments, please see usage:%s", " ");
-		usage() ;
-		printf( "Using the default, \"The Burning Rose\", composition :\n");
-		printf( "\n\trose512.jpg add back.xpm:512x386 hue "
-				"fore.xpm:512x386\n");
-		argv = &(burning_rose[0]) ;
-		argc = 6;
-	}
-
-#ifndef X_DISPLAY_MISSING
-	dpy = XOpenDisplay(NULL);
-	_XA_WM_DELETE_WINDOW = XInternAtom( dpy, "WM_DELETE_WINDOW", False);
-	screen = DefaultScreen(dpy);
-	depth = DefaultDepth( dpy, screen );
-#endif
-	/* see ASView.3 : */
-	asv = create_asvisual( dpy, screen, depth, NULL );
-
-	/* see ASMerge.1 : */
-	layers = safecalloc( argc/2, sizeof(ASImageLayer) );
-
-	for( i = 1 ; i < argc ; i++ )
-	{
-		int x = 0, y = 0;
-		unsigned int width, height ;
-		int geom_flags = 0 ;
-		char *separator;
-		char *filename ;
-		/* see ASMerge.2 */
-		if( i > 1 )
-		{
-			/* see blend_scanlines_name2func() : */
-			if((layers[layers_num].merge_scanlines =
-				 blend_scanlines_name2func( argv[i] )) == NULL )
-				continue ;
-			if( ++i >= argc )
-				break;
-		}
-		if( (separator = strchr( argv[i], ':' )) != NULL )
-		{   /* see ASTile.1 : */
-			geom_flags = XParseGeometry( separator+1, 
-										 &x, &y, &width, &height);
-			filename = mystrndup( argv[i], separator-argv[i] );
-		}else
-			filename = argv[i] ;
-		layers[layers_num].im = file2ASImage( filename, 0xFFFFFFFF,
-			                                  SCREEN_GAMMA, 100, getenv("IMAGE_PATH"), NULL );
-		if( filename != argv[i] )
-			free( filename );
-		if( layers[layers_num].im != NULL )
-		{
-		 	if( !get_flags(geom_flags, WidthValue) )
-		 		width = layers[layers_num].im->width  ;
-		 	if( !get_flags(geom_flags, HeightValue) )
-		 		height = layers[layers_num].im->height ;
-			/* see ASMerge.3 : */
-			if( layers[layers_num].merge_scanlines == NULL )
-				layers[layers_num].merge_scanlines =
-					alphablend_scanlines ;
-			layers[layers_num].clip_width = width ;
-			layers[layers_num].clip_height = height ;
-			if( layers_num > 0 )
-			{
-				layers[layers_num].dst_x = x ;
-				layers[layers_num].dst_y = y ;
-			}else
-			{
-				to_width = width ;
-				to_height = height ;
-				if( width != layers[layers_num].im->width ||
-				    height != layers[layers_num].im->height )
-				{
-					ASImage *scaled_bottom ;
-					/* see ASScale.2 : */
-					scaled_bottom = scale_asimage( asv, 
-												   layers[layers_num].im,
-											  	   width, height, 
-												   False, 100,
-											  	ASIMAGE_QUALITY_DEFAULT );
-					destroy_asimage( &(layers[layers_num].im) );
-					layers[layers_num].im = scaled_bottom ;
-				}
-			}
-			++layers_num ;
-		}
-	}
-
-	if( layers_num <= 0 )
-	{
-		show_error( "there is no images to merge. Aborting");
-		return 2;
-	}
-
-	/* see ASMerge.4 */
-	merged_im = merge_layers( asv, layers, layers_num,
-		                      to_width, to_height,
-#ifndef X_DISPLAY_MISSING
-							  ASA_XImage,
-#else
-							  ASA_ASImage,
-#endif
-							  0, ASIMAGE_QUALITY_DEFAULT );
-	while( --layers_num >= 0 )
-		destroy_asimage( &(layers[layers_num].im) );
-	free( layers );
-
-	if( merged_im )
-	{
-#ifndef X_DISPLAY_MISSING
-	/* see ASView.4 : */
-  		Window w = create_top_level_window( asv, DefaultRootWindow(dpy), 
-											32, 32,
-					                        to_width, to_height, 
-											1, 0, NULL,
-											"ASMerge", NULL );
-		if( w != None )
-		{
-			Pixmap p ;
-
-		  	XMapRaised   (dpy, w);
-			/* see ASView.5 : */
-			p = asimage2pixmap( asv, DefaultRootWindow(dpy), merged_im,
-			                NULL, True );
-
-			destroy_asimage( &merged_im );
-			/* see common.c: set_window_background_and_free() : */
-			p = set_window_background_and_free( w, p );
-			/* see common.c: wait_closedown() : */
-		}
-		wait_closedown(w);
-		dpy = NULL;
-#else
-		/* writing result into the file */
-		ASImage2file( merged_im, NULL, "asmerge.jpg", ASIT_Jpeg, NULL );
-		destroy_asimage( &merged_im );
-#endif
-	}
-#ifdef DEBUG_ALLOCS
-	build_xpm_colormap(NULL);
-	print_unfreed_mem();
-#endif
-	return 0 ;
-}
-/**************/
-
-/****f* libAfterImage/tutorials/ASMerge.1 [4.1]
- * SYNOPSIS
- * Step 1. Layers.
- * DESCRIPTION
- * libAfterImage performs blending/merging of different images, using
- * arrays of ASImageLayer structures, with first element representing
- * the bottommost image. Each structure specifies exact position on
- * resulting image where overlay should be blended to, tint of the
- * overlay, size, to which overlay should be tiled, overlay's origin,
- * and overlay's background color. Arbitrary number of layers can be
- * merged whithin single run.
- *
- * Accordingly all that is needed to merge bunch of images is to create
- * array of ASImageLayer structures and fill it up appropriately.
- * EXAMPLE
- *     layers = safecalloc( argc/2, sizeof(ASImageLayer) );
- ********/
-/****f* libAfterImage/tutorials/ASMerge.2 [4.2]
- * SYNOPSIS
- * Step 2. Merging methods.
- * DESCRIPTION
- * Each layer can be merged in using its own method. There are about 15
- * different methods implemented in libAfterImage, and user app can
- * implement other methods of its own. To specify method all that is
- * needed is to set merge_scanlines member of ASImageLayer to pointer
- * to the function, implementing specific method.
- *
- * libAfterImage provides facility to parse method name strings into
- * actuall function pointers. That could be used to simplifi scripting,
- * etc.
- * EXAMPLE
- * 	   if((layers[layers_num].merge_scanlines =
- * 	       blend_scanlines_name2func( argv[i] )) == NULL )
- * 		   continue ;
- * NOTE
- * All layers MUST have valid merge_scanlines pointer, even the
- * bottommost layer, despite the fact that it has nothing to be merged
- * with. If merge_scanlines is set to NULL - this layer will be ignored.
- * That could be used to turn on/off particular layers.
- ********/
-/****f* libAfterImage/tutorials/ASMerge.3 [4.3]
- * SYNOPSIS
- * Step 3. Layer parameters.
- * DESCRIPTION
- * Several ASImageLayer members are mandatory and cannot be set to 0.
- * Such as : im - image to be merged; clip_width, clip_height - this will
- * be used to tile the image; merge_scanlines - must be set to a pointer
- * to the function implementing merging method. If any of this is set
- * to 0  - then layer will be ignored. The rest of the parameters are
- * optional. Note thou that tint parameter will tint overlay's RGB
- * components and alpha component, as the result it could be used to
- * make opaque images - semitransparent.
- * EXAMPLE
- *     if( layers[layers_num].merge_scanlines == NULL )
- *         layers[layers_num].merge_scanlines =
- *             alphablend_scanlines ;
- *     layers[layers_num].clip_width = width ;
- *     layers[layers_num].clip_height = height ;
- *     if( layers_num > 0 )
- *     {
- *         layers[layers_num].dst_x = x ;
- *         layers[layers_num].dst_y = y ;
- *     }
- ********/
-/****f* libAfterImage/tutorials/ASMerge.4 [4.4]
- * SYNOPSIS
- * Step 4. Actual blending of the set of images.
- * DESCRIPTION
- * After set of layers has been prepared - it can be passed to
- * merge_layers() function, that will create new ASImage of specifyed
- * size, and then blend all the layers together to fill this image.
- * EXAMPLE
- * 		merged_im = merge_layers( asv, layers, layers_num,
- * 			                      to_width, to_height,
- * 			                      ASA_ASImage, 0, 
- * 								  ASIMAGE_QUALITY_DEFAULT );
- * 		while( --layers_num >= 0 )
- * 			destroy_asimage( &(layers[layers_num].im) );
- * 		free( layers );
- * NOTES
- * After we've blended layers - we no longer need ASImageLayer array.
- * So proceeding to clean it up, by destroying overlay AsImages first,
- * and then freeing array itself.
- * SEE ALSO
- * merge_asimage().
- ********/
diff -Naur libAfterImage-1.20/apps/asscale.c root/graf2d/asimage/src/libAfterImage/apps/asscale.c
--- libAfterImage-1.20/apps/asscale.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/asscale.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,233 +0,0 @@
-#include "config.h"
-
-#include <string.h>
-#include <stdlib.h>
-
-/****h* libAfterImage/tutorials/ASScale
- * NAME 
- * ASScale
- * SYNOPSIS
- * Simple program based on libAfterImage to scale an image.
- * DESCRIPTION
- * We will load image and scale it up to new size, specified as command
- * line arguments
- * We then display the result in simple window.
- * After that we would want to wait, until user closes our window.
- *
- * In this tutorial we will only explain new steps, not described in
- * previous tutorial. New steps described in this tutorial are :
- * ASScale.1. Parsing geometry spec.
- * ASScale.2. Scaling ASImage.
- * SEE ALSO
- * Tutorial 1: ASView - explanation of basic steps needed to use
- *                      libAfterImage and some other simple things.
- * SOURCE
- */
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "common.h"
-
-void usage()
-{
-	printf( "Usage: asscale [-h]|[image [WIDTH[xHEIGHT]]]\n");
-	printf( "Where: image - is image filename.\n");
-	printf( "       WIDTH - width to scale image to.( Naturally :)\n");
-	printf( "       HEIGHT- height to scale image to.\n");
-}
-
-int main(int argc, char* argv[])
-{
-	char *image_file = "rose512.jpg" ;
-	int dummy, geom_flags = 0;
-	unsigned int to_width, to_height ;
-	ASImage *im ;
-	int clip_x = 0, clip_y = 0, clip_width = 0, clip_height = 0 ;
-	int slice_x_start = 0, slice_x_end = 0, slice_y_start = 0, slice_y_end = 0 ;
-	Bool slice_scale = False ;
-	Display *dpy = NULL;
-
-	/* see ASView.1 : */
-	set_application_name( argv[0] );
-
-	if( argc > 1 )
-	{
-		int i = 2;
-		if( strncmp( argv[1], "-h", 2 ) == 0 )
-		{
-			usage();
-			return 0;
-		}
-		image_file = argv[1] ;
-		if( argc > 2 )   /* see ASScale.1 : */
-			geom_flags = XParseGeometry( argv[2], &dummy, &dummy,
-			                             &to_width, &to_height );
-	
-		while( ++i < argc )
-		{	
-			if( strncmp( argv[i], "-sx1", 4 ) == 0 && i+1 < argc )
-				slice_x_start = atoi(argv[++i]) ;
-			else if( strncmp( argv[i], "-sx2", 4 ) == 0 && i+1 < argc )
-				slice_x_end = atoi(argv[++i]) ;
-			else if( strncmp( argv[i], "-sy1", 4 ) == 0 && i+1 < argc )
-				slice_y_start = atoi(argv[++i]) ;
-			else if( strncmp( argv[i], "-sy2", 4 ) == 0 && i+1 < argc )
-				slice_y_end = atoi(argv[++i]) ;
-			else if( strncmp( argv[i], "-cx", 4 ) == 0 && i+1 < argc )
-				clip_x = atoi(argv[++i]) ;
-			else if( strncmp( argv[i], "-cy", 4 ) == 0 && i+1 < argc )
-				clip_y = atoi(argv[++i]) ;
-			else if( strncmp( argv[i], "-cwidth", 7 ) == 0 && i+1 < argc )
-				clip_width = atoi(argv[++i]) ;
-			else if( strncmp( argv[i], "-cheight", 8 ) == 0 && i+1 < argc )
-				clip_height = atoi(argv[++i]) ;
-			else if( strncmp( argv[i], "-ss", 3 ) == 0 )
-				slice_scale = True ;
-		}
-			   
-	
-	}else
-	{
-		show_warning( "no image file or scale geometry - defaults used:"
-					  " \"%s\" ",
-		              image_file );
-		usage();
-	}
-	/* see ASView.2 : */
-	im = file2ASImage( image_file, 0xFFFFFFFF, SCREEN_GAMMA, 0, getenv("IMAGE_PATH"), NULL );
-
-	if( im != NULL )
-	{
-		ASVisual *asv ;
-		ASImage *scaled_im ;
-		/* Making sure tiling geometry is sane : */
-		if( !get_flags(geom_flags, WidthValue ) )
-			to_width = im->width*2 ;
-		if( !get_flags(geom_flags, HeightValue ) )
-			to_height = im->height*2;
-		printf( "%s: scaling image \"%s\" to %dx%d by factor of %fx%f\n",
-			    get_application_name(), image_file, to_width, to_height,
-				(double)to_width/(double)(im->width),
-				(double)to_height/(double)(im->height) );
-
-#ifndef X_DISPLAY_MISSING
-		{
-			Window w ;
-			int screen, depth ;
-
-		    dpy = XOpenDisplay(NULL);
-			_XA_WM_DELETE_WINDOW = XInternAtom( dpy, 
-												"WM_DELETE_WINDOW", 
-												False);
-			screen = DefaultScreen(dpy);
-			depth = DefaultDepth( dpy, screen );
-			/* see ASView.3 : */
-			asv = create_asvisual( dpy, screen, depth, NULL );
-			/* see ASView.4 : */
-			w = create_top_level_window( asv, DefaultRootWindow(dpy), 
-										 32, 32,
-				                         to_width, to_height, 1, 0, NULL,
-										 "ASScale", image_file );
-			if( w != None )
-			{
-				Pixmap p ;
-
-		  		XMapRaised   (dpy, w);
-				/* see ASScale.2 : */
-				if( slice_x_start == 0 && slice_x_end == 0 && 
-					slice_y_start == 0 && slice_y_end == 0 )
-				{
-					scaled_im = scale_asimage2( asv, im,
-												clip_x, clip_y, clip_width, clip_height, 
-												to_width, to_height,
-					                       	ASA_XImage, 0, 
-										   	ASIMAGE_QUALITY_DEFAULT );
-				}else
-				{
-					scaled_im = slice_asimage2( asv, im, slice_x_start, slice_x_end, 
-											   slice_y_start, slice_y_end,
-											to_width, to_height, slice_scale,
-					                       	ASA_XImage, 0, 
-										   	ASIMAGE_QUALITY_DEFAULT );
-				}					   
-				destroy_asimage( &im );
-				/* see ASView.5 : */
-				p = asimage2pixmap(asv, DefaultRootWindow(dpy), scaled_im,
-					                NULL, True );
-				/* print_storage(NULL); */
-				destroy_asimage( &scaled_im );
-				/* see common.c: set_window_background_and_free() : */
-				p = set_window_background_and_free( w, p );
-			}
-			/* see common.c: wait_closedown() : */
-			wait_closedown(w);
-			dpy = NULL;			
-		}
-#else
-		asv = create_asvisual( NULL, 0, 0, NULL );
-		scaled_im = scale_asimage(asv, im, to_width, to_height,
-			                      ASA_ASImage, 0, 
-								  ASIMAGE_QUALITY_DEFAULT );
-		/* writing result into the file */
-		ASImage2file( scaled_im, NULL, "asscale.jpg", ASIT_Jpeg, NULL );
-		destroy_asimage( &scaled_im );
-		destroy_asimage( &im );
-#endif
-	}
-    return 0 ;
-}
-/**************/
-
-/****f* libAfterImage/tutorials/ASScale.1 [2.1]
- * SYNOPSIS
- * Step 1. Parsing the geometry.
- * DESCRIPTION
- * Geometry can be specified in WIDTHxHEIGHT+X+Y format. Accordingly we
- * use standard X function to parse it: XParseGeometry. Returned flags
- * tell us what values has been specified. Since we only need size -
- * we check if it is specified and if not - simply default it to twice
- * as big as original image. Accordingly we use dummy variable to pass
- * to XParseGeometry.
- * EXAMPLE
- *     geom_flags = XParseGeometry( argv[3], &dummy, &dummy,
- *                                  &to_width, &to_height );
- ********/
-/****f* libAfterImage/tutorials/ASScale.2 [2.2]
- * SYNOPSIS
- * Step 2. Actual scaling the image.
- * DESCRIPTION
- * scale_asimage() scales image both up and down, and is very easy to
- * use - just pass it new size. In this example we use default quality.
- * Default is equivalent to GOOD which should be sufficient in
- * most cases. Compression is set to 0 since we do not intend to store
- * image for long time. Even better - we don't need to store it at all -
- * all we need is XImage, so we can transfer it to the server easily.
- * That is why to_xim argument is set to ASA_XImage. As the result obtained
- * ASImage will not have any data in its buffers, but it will have
- * ximage member set to point to valid XImage. Subsequently we enjoy
- * that convenience, by setting use_cached to True in call to
- * asimage2pixmap. That ought to save us alot of processing.
- *
- * Scaling algorithm is rather sophisticated and is implementing 4 point
- * interpolation. Which basically means that we try to approximate each
- * missing point as an extension of the trend of 4 neighboring points -
- * two on each side. Closest neighbor's have more weight then outside
- * ones. 2D scaling is performed by scaling each scanline first, and
- * then interpolating missing scanlines.
- * Scaling down is somewhat skimpier, as it amounts to simple averaging
- * of the multiple pixels. All calculations are done in integer math on
- * per channel basis, and with precision 24.8 bits per channel per pixel.
- *
- * EXAMPLE
- *     scaled_im = scale_asimage( asv, im, to_width, to_height,
- * 	                           ASA_XImage, 0, ASIMAGE_QUALITY_DEFAULT );
- *     destroy_asimage( &im );
- * NOTES
- * Scaling image up to very large height is much slower then to same
- * width due to algorithm specifics. Yet even on inferior hardware it
- * yields decent speeds.
- * When we successfully scaled image - we no longer need the original -
- * getting rid of it so it does not clog memory.
- * SEE ALSO
- * scale_asimage().
- ********/
diff -Naur libAfterImage-1.20/apps/astext.c root/graf2d/asimage/src/libAfterImage/apps/astext.c
--- libAfterImage-1.20/apps/astext.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/astext.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,508 +0,0 @@
-#include "config.h"
-
-#include <string.h>
-#include <stdlib.h>
-
-/****h* libAfterImage/tutorials/ASText
- * NAME
- * ASText
- * SYNOPSIS
- * libAfterImage application for rendering texturized text.
- * DESCRIPTION
- * In this tutorial we will attempt to render arbitrary text in window,
- * with optional texturized background and foreground. We shall also
- * surround rendered text with beveled frame, creating an illusion of a
- * button.
- *
- * New steps described in this tutorial are :
- * ASText.1. Openning and closing fonts.
- * ASText.2. Approximating rendered text size.
- * ASText.3. Rendering texturized text.
- * ASText.4. Merging foreground and background with bevel.
- * SEE ALSO
- * Tutorial 1: ASView  - explanation of basic steps needed to use
- *                       libAfterImage and some other simple things.
- * Tutorial 2: ASScale - image scaling basics.
- * Tutorial 3: ASTile  - image tiling and tinting.
- * Tutorial 4: ASMerge - scaling and blending of arbitrary number of
- *                       images.
- * Tutorial 5: ASGrad  - drawing multipoint linear gradients.
- * Tutorial 6: ASFlip  - image rotation.
- * SOURCE
- */
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "common.h"
-
-/* Usage:  astext [-f font] [-s size] [-t text] [-S 3D_style]
-                  [-c text_color] [-b background_color]
-                  [-T foreground_texture] [-B background_image]
-				  [-r foreground_resize_type] [-R background_resize_type]
- */
-
-#define BEVEL_HI_WIDTH 20
-#define BEVEL_LO_WIDTH 30
-#define BEVEL_ADDON    (BEVEL_HI_WIDTH+BEVEL_LO_WIDTH)
-
-void usage()
-{
-	printf( "  Usage:   astext [-h] [-f font] [-s size] [-t text] "
-			"[-S 3D_style] \n");
-	printf( "                  [-c text_color] [-b background_color]\n");
-	printf( "                  [-T foreground_texture] "
-			"[-B background_image]\n");
-	printf( "      			   [-r foreground_resize_type] "
-			"[-R background_resize_type]\n");
-	printf( "      			   [-m ]\n");
-	printf( "  Where: font - TrueType font's filename or X font spec or "
-			"alias;\n");
-	printf( "         size - size in points for TrueType fonts;\n");
-	printf( "         text - text to be drawn;\n");
-	printf( "         3D_style - 3D style of text. "
-			"One of the following:\n");
-	printf( "             0 - plain 2D tetx, 1 - embossed, 2 - sunken, "
-			"3 - shade above,\n");
-	printf( "             4 - shade below, 5 - embossed thick, "
-			"6 - sunken thick.\n");
-	printf( "             7 - ouline above, 8 - ouline below, "
-			"9 - full ouline.\n");
-	printf( "         resize_type - tells how texture/image should be "
-			"transformed to fit\n");
-	printf( "         the text size. Could be: scale or tile." 
-			"Default is tile\n");
-	printf( "         -m make font monospaced. \n");
-
-
-}
-
-int main(int argc, char* argv[])
-{
-	Display *dpy = NULL;
-	ASVisual *asv = NULL ;
-	int screen = 0, depth = 0;
-	char *font_name = "test.ttf";
-	int size = 32 ;
-#if 0
-	char *text = "";  /* chinese */ 
-#else
- 	char *text = "Smart Brown Dog jumps\nOver The Lazy Fox,\n"
-				 "and falls into the ditch.";
-#endif
-	ARGB32 text_color = ARGB32_White, back_color = ARGB32_Black;
-	char *text_color_name = "#FFFFFFFF", *back_color_name = "#FF000000";
-	char *fore_image_file = "fore.xpm" ;
-	char *back_image_file = "back.xpm" ;
-	Bool scale_fore_image = False, scale_back_image = False ;
-	ASImage *fore_im = NULL, *back_im = NULL;
-	ASImage *text_im = NULL ;
-	struct ASFontManager *fontman = NULL;
-	struct ASFont  *font = NULL;
-	unsigned int width, height ;
-	int i ;
-	int text_margin = size/2 ;
-	Bool monospaced = False ;
-	char * font_path = NULL;
-	ASTextAttributes attr = {ASTA_VERSION_1, ASTA_UseTabStops, 
-							 AST_ShadeBelow, ASCT_UTF8, 8, 0, 
-							 NULL, 0, ARGB32_White };
-	
-	/* see ASView.1 : */
-	set_application_name( argv[0] );
-#if (HAVE_AFTERBASE_FLAG==1)
-	set_output_threshold(OUTPUT_LEVEL_DEBUG);
-#endif
-
-	if( argc == 1 )
-		usage();
-	else for( i = 1 ; i < argc ; i++ )
-	{
-		if( strncmp( argv[i], "-h", 2 ) == 0 )
-		{
-			usage();
-			return 0;
-		}
-		if( strncmp( argv[i], "-m", 2 ) == 0 )
-		{
-	   		monospaced = True ;
-		}else if( i+1 < argc )
-		{
-			if( strncmp( argv[i], "-f", 2 ) == 0 )
-				font_name = argv[i+1] ;
-			else if( strncmp( argv[i], "-s", 2 ) == 0 )
-			{
-				size = atoi(argv[i+1]);
-				text_margin = size/2 ;
-			}else if( strncmp( argv[i], "-t", 2 ) == 0 )
-				text = argv[i+1] ;
-			else if( strncmp( argv[i], "-S", 2 ) == 0 )
-			{
-				attr.type = atoi(argv[i+1]);
-				if( attr.type >= AST_3DTypes )
-				{
-					show_error( "3D type is wrong. "
-								"Using 2D Plain instead.");
-					attr.type = AST_Plain ;
-				}
-
-			}else if( strncmp( argv[i], "-c", 2 ) == 0 )
-				text_color_name = argv[i+1] ;
-			else if( strncmp( argv[i], "-b", 2 ) == 0 )
-				back_color_name = argv[i+1] ;
-			else if( strncmp( argv[i], "-T", 2 ) == 0 )
-				fore_image_file = argv[i+1] ;
-			else if( strncmp( argv[i], "-B", 2 ) == 0 )
-				back_image_file = argv[i+1] ;
-			else if( strncmp( argv[i], "-r", 2 ) == 0 )
-				scale_fore_image = (strcmp( argv[i+1], "scale") == 0);
-			else if( strncmp( argv[i], "-R", 2 ) == 0 )
-				scale_back_image = (strcmp( argv[i+1], "scale") == 0);
-		}
-	}
-
-
-#ifndef X_DISPLAY_MISSING
-    dpy = XOpenDisplay(NULL);
-	_XA_WM_DELETE_WINDOW = XInternAtom( dpy, "WM_DELETE_WINDOW", False);
-	screen = DefaultScreen(dpy);
-	depth = DefaultDepth( dpy, screen );
-#endif
-
-	/* see ASText.1 : */
-	if( getenv("FONT_PATH") != NULL ) 
-	{
-		font_path = safemalloc( strlen(getenv("FONT_PATH"))+1+2+1);
-		sprintf( font_path, "%s:./", getenv("FONT_PATH") );
-		
-	}	 
-	if( (fontman = create_font_manager( dpy, font_path, NULL )) != NULL )
-		font = get_asfont( fontman, font_name, 0, size, 
-						   ASF_GuessWho|(monospaced?ASF_Monospaced:0) );
-
-	if( font == NULL )
-	{
-		show_error( "unable to load requested font \"%s\". "
-					"Falling back to \"fixed\".", font_name );
-		font = get_asfont( fontman, "fixed", 0, size, ASF_GuessWho );
-		if( font == NULL )
-		{
-			show_error("font \"fixed\" is not available either. Aborting.");
-			return 1;
-		}
-	}
-
-	/*for( i = 0 ; i < 128 ; ++i ) 
-		print_asglyph( stderr, font, i); */
-
-	parse_argb_color( text_color_name, &text_color );
-	parse_argb_color( back_color_name, &back_color );
-
-	attr.fore_color = text_color ;
-	if( attr.type >= AST_OutlineAbove ) 
-		fore_image_file = NULL ;
-
-	/* see ASView.3 : */
-	asv = create_asvisual( dpy, screen, depth, NULL );
-
-	/* see ASText.2 : */
-	/*set_asfont_glyph_spacing( font, 10, 40 );*/
-    /*Simple way:get_text_size( text, font, attr.type, &width, &height ); */
-	/*Fancy way : */
-	get_fancy_text_size( text, font, &attr, &width, &height, 0, NULL );
-/* show_progress( "extimated text size = %dx%d", width, height ); */
-	
-	if( fore_image_file )
-	{
-		ASImage *tmp = file2ASImage( fore_image_file, 0xFFFFFFFF,
-		               		         SCREEN_GAMMA, 0, getenv("IMAGE_PATH"), NULL );
-		if( tmp )
-		{
-			if( tmp->width != width || tmp->height != height )
-			{   /* see ASScale.2 : */
-				if( scale_fore_image )
-					fore_im = scale_asimage( asv, tmp, width, height,
-  					                         ASA_ASImage, 0, 
-											 ASIMAGE_QUALITY_DEFAULT );
-				else
-					fore_im = tile_asimage( asv, tmp, 0, 0, 
-											width, height, 0,
-  					                        ASA_ASImage, 0, 
-											ASIMAGE_QUALITY_DEFAULT );
-				destroy_asimage( &tmp );
-			}else
-				fore_im = tmp ;
-		}else
-			fore_im = NULL ;
-	}
-	width  += text_margin*2 + BEVEL_ADDON;
-	height += text_margin*2 + BEVEL_ADDON;
-	if( back_image_file )
-	{ /* see ASView.2 : */
-		ASImage *tmp = file2ASImage( back_image_file, 0xFFFFFFFF,
-			                        SCREEN_GAMMA, 0, getenv("IMAGE_PATH"), NULL );
-		if( tmp )
-		{
-			if( scale_back_image && 
-				(tmp->width != width || tmp->height != height) )
-			{   /* see ASScale.2 : */
-				back_im = scale_asimage( asv, tmp, width, height,
-				                         ASA_ASImage, 0, 
-										 ASIMAGE_QUALITY_DEFAULT );
-				destroy_asimage( &tmp );
-			}else
-				back_im = tmp ;
-		}else
-			back_im = NULL ;
-	}
-
-	/* see ASText.3 : */
-    /* simple way : text_im = draw_text( text, font, attr.type, 0 ); */
-	text_im = draw_fancy_text( text, font, &attr, 0, 0 );
-	if( fore_im )
-	{
-		move_asimage_channel( fore_im, IC_ALPHA, text_im, IC_ALPHA );
-		destroy_asimage( &text_im );
-	}else
-		fore_im = text_im ;
-
-	/* see ASText.1 : */
-	release_font( font );
-	destroy_font_manager( fontman, False );
-
-	if( fore_im )
-	{
-		ASImage *rendered_im ;
-		ASImageLayer layers[2] ;
-		ASImageBevel bevel = {0/*BEVEL_SOLID_INLINE*/, 0xFFDDDDDD, 
-							  0xFF555555, 0xFFFFFFFF, 
-							  0xFF777777, 0xFF222222,
-		                      BEVEL_HI_WIDTH, BEVEL_HI_WIDTH,
-							  BEVEL_LO_WIDTH, BEVEL_LO_WIDTH,
-							  BEVEL_HI_WIDTH, BEVEL_HI_WIDTH,
-							  BEVEL_LO_WIDTH, BEVEL_LO_WIDTH } ;
-
-		/* see ASText.4 : */
-		init_image_layers( &(layers[0]), 2 );
-		if( back_im )
-			back_im->back_color = back_color ;
-		if( fore_im ) 
-			fore_im->back_color = text_color ;
-		layers[0].im = back_im ;
-		layers[0].dst_x = 0 ;
-		layers[0].dst_y = 0 ;
-		layers[0].clip_width = width ;
-		layers[0].clip_height = height ;
-		layers[0].bevel = &bevel ;
-		layers[1].im = fore_im ;
-		layers[1].dst_x = text_margin+BEVEL_HI_WIDTH*2 ;
-		layers[1].dst_y = text_margin+
-							MIN( (int)text_margin,
-								((int)font->max_height-
-								 (int)font->max_ascend))/2+
-								 BEVEL_HI_WIDTH*2;
-		if( fore_im ) 
-		{	
-			layers[1].clip_width = fore_im->width ;
-			layers[1].clip_height = fore_im->height ;
-		}
-		rendered_im = merge_layers( asv, &(layers[0]), 2,
-									width+BEVEL_ADDON, height+BEVEL_ADDON,
-#ifndef X_DISPLAY_MISSING
-									ASA_XImage,
-#else
-									ASA_ASImage,
-#endif
-									0, ASIMAGE_QUALITY_DEFAULT);
-		destroy_asimage( &fore_im );
-		destroy_asimage( &back_im );
-
-		if( rendered_im )
-		{
-#ifndef X_DISPLAY_MISSING
-			Window w;
-			/* see ASView.4 : */
-			w = create_top_level_window( asv, DefaultRootWindow(dpy), 
-										 32, 32,
-			      		                 width+BEVEL_ADDON, 
-										 height+BEVEL_ADDON,
-										 1, 0, NULL,
-										 "ASText", text );
-			if( w != None )
-			{
-				Pixmap p ;
-
-			  	XMapRaised   (dpy, w);
-
-				/* see ASView.5 : */
-				p = asimage2pixmap( asv, DefaultRootWindow(dpy), 
-									rendered_im, NULL, True );
-				destroy_asimage( &rendered_im );
-				/* see common.c: set_window_background_and_free() : */
-				p = set_window_background_and_free( w, p );
-				/* see common.c: wait_closedown() : */
-			}
-			wait_closedown(w);
-			dpy = NULL;
-#else
-			/* writing result into the file */
-			ASImage2file( rendered_im, NULL, "astext.jpg", ASIT_Jpeg, 
-						  NULL );
-			destroy_asimage( &rendered_im );
-#endif
-		}
-	}
-    return 0 ;
-}
-/**************/
-/****f* libAfterImage/tutorials/ASText.1 [7.1]
- * SYNOPSIS
- * Step 1. Openning and closing fonts.
- * DESCRIPTION
- * Before any text can be rendered using libAfterImage - desired font
- * has to be opened for use. Font opening process is two-step. At first
- * we need to create font manager ( ASFontManager ). That is done once,
- * and same font manager can be used throughout entire application. It
- * contains information about used external libraries, hash of opened
- * fonts, and some other info.
- *
- * When ASFontManager is created it could be used to obtain actuall fonts.
- * get_asfont() call is used to query cahce of the ASFontManager, to see
- * if the font has been loaded already, and if not - then it will load
- * the font and prepare it for drawing.
- *
- * EXAMPLE
- *     if( (fontman = create_font_manager( dpy, NULL, NULL )) != NULL )
- *         font = get_asfont( fontman, font_name, 0, size, ASF_GuessWho);
- *     if( font == NULL )
- *     {
- *         font = get_asfont( fontman, "fixed", 0, size, ASF_GuessWho );
- *         if( font == NULL )
- *         {
- *             show_error( "font \"fixed\" is not available either. 
- * 							Aborting.");
- *             return 1;
- *         }
- *     }
- *     ...
- *     destroy_font( font );
- *     destroy_font_manager( fontman, False );
- * SEE ALSO
- * create_font_manager(), get_asfont(), destroy_font(),
- * destroy_font_manager()
- ********/
-/****f* libAfterImage/tutorials/ASText.2 [7.2]
- * SYNOPSIS
- * Step 2. Approximating rendered text size.
- * DESCRIPTION
- * Prior to actually drawing the text it is usefull to estimate the size
- * of the image, that rendered text will occupy, So that window can be
- * created of appropriate size, and othe interface elements laid out
- * accordingly. get_text_size() could be used to obtain rendered text
- * size without actually drawing it.
- * EXAMPLE
- *     get_text_size( text, font, type_3d, &width, &height );
- *     if( fore_image_file )
- *     {
- *         ASImage *tmp = file2ASImage( fore_image_file, 0xFFFFFFFF,
- *                                      SCREEN_GAMMA, 0, NULL );
- *         if( tmp )
- *         {
- *             if( tmp->width != width || tmp->height != height )
- *             {
- *                 if( scale_fore_image )
- *                     fore_im = scale_asimage( asv, tmp, width, height,
- *                                              ASA_ASImage, 0,
- *                                              ASIMAGE_QUALITY_DEFAULT );
- *                 else
- *                     fore_im = tile_asimage( asv, tmp, 0, 0,
- *                                             width, height, 0,
- *                                             ASA_ASImage, 0,
- *                                             ASIMAGE_QUALITY_DEFAULT );
- *                 destroy_asimage( &tmp );
- *             }else
- *                 fore_im = tmp ;
- *         }
- *     }
- * NOTES
- * In this particular example we either tile or scale foreground texture
- * to fit the text. In order to texturize the text  - we need to use
- * rendered text as an alpha channel on texture image. That can easily
- * be done only if both images are the same size.
- * SEE ALSO
- * get_text_size(), scale_asimage(), tile_asimage(), ASText.3
- ********/
-/****f* libAfterImage/tutorials/ASText.3 [7.3]
- * SYNOPSIS
- * Step 3. Rendering texturized text.
- * DESCRIPTION
- * The most effective text texturization technique provided by
- * libAfterImage consists of substitution of the alpha channel of the
- * texture, with rendered text. That is possible since all the text is
- * rendered into alpha channel only. move_asimage_channel() call is used
- * to accomplish this operation. This call actually removes channel
- * data from the original image and stores it in destination image. If
- * there was something in destination image's channel  already - it will
- * be destroyed.
- * All kinds of nifty things could be done using this call, actually.
- * Like, for example, rendered text can be moved into green channel of
- * the texture, creating funky effect.
- * EXAMPLE
- *     text_im = draw_text( text, font, 0 );
- *     if( fore_im )
- *     {
- *         move_asimage_channel( fore_im, IC_ALPHA, text_im, IC_ALPHA );
- *         destroy_asimage( &text_im );
- *     }else
- *         fore_im = text_im ;
- * NOTES
- * move_asimage_channel() will only work if both images have exactly the
- * same size. It will do nothing otherwise.
- * SEE ALSO
- * draw_text(), move_asimage_channel()
- ********/
-/****f* libAfterImage/tutorials/ASText.4 [7.4]
- * SYNOPSIS
- * Step 4. Merging foreground and background with bevel.
- * DESCRIPTION
- * On this step we have 2 images ready for us - background and texturized
- * text. At this point we need to merge them together by alpha-blending
- * text over background (remeber - text is alpha-channel of foreground
- * texture). At the same time we would like to add some nice bevel border
- * around entire image. To accomplish that task all we have to do is setup
- * ASImageLayer structure for both background and foreground, and apply
- * merge_layers on them. When it is done - we no longer need original
- * images and we destroy them to free up some memory.
- * EXAMPLE
- *     ASImageLayer layers[2] ;
- *     ASImageBevel bevel = {0, 0xFFDDDDDD, 0xFF555555,
- *                              0xFFFFFFFF, 0xFF777777, 0xFF444444,
- *                           BEVEL_HI_WIDTH, BEVEL_HI_WIDTH,
- *                           BEVEL_LO_WIDTH, BEVEL_LO_WIDTH,
- *                           BEVEL_HI_WIDTH, BEVEL_HI_WIDTH,
- *                           BEVEL_LO_WIDTH, BEVEL_LO_WIDTH } ;
- *     memset( &(layers[0]), 0x00, sizeof(layers) );
- *     layers[0].im = back_im ;
- *     layers[0].clip_width = width ;
- *     layers[0].clip_height = height ;
- *     layers[0].merge_scanlines = alphablend_scanlines ;
- *     layers[0].bevel = &bevel ;
- *     layers[1].im = fore_im ;
- *     layers[1].dst_x = TEXT_MARGIN ;
- *     layers[1].dst_y = TEXT_MARGIN ;
- *     layers[1].clip_width = fore_im->width ;
- *     layers[1].clip_height = fore_im->height ;
- *     layers[1].back_color = text_color ;
- *     layers[1].merge_scanlines = alphablend_scanlines ;
- *     rendered_im = merge_layers( asv, &(layers[0]), 2,
- *                                 width+BEVEL_ADDON, height+BEVEL_ADDON,
- *                                 ASA_XImage, 0, ASIMAGE_QUALITY_DEFAULT);
- *     destroy_asimage( &fore_im );
- *     destroy_asimage( &back_im );
- * NOTES
- * We have to remember that outside bevel border will addup to the image
- * size, hence we have to use width+BEVEL_ADDON , height+BEVEL_ADDON as
- * desired image size.
- * SEE ALSO
- * ASImageLayer, ASImageBevel, merge_layers()
- ********/
-
diff -Naur libAfterImage-1.20/apps/astile.c root/graf2d/asimage/src/libAfterImage/apps/astile.c
--- libAfterImage-1.20/apps/astile.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/astile.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,262 +0,0 @@
-#include "config.h"
-
-#include <string.h>
-#include <stdlib.h>
-
-#if TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# if HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif
-
-/****h* libAfterImage/tutorials/ASTile
- * NAME
- * ASTile
- * SYNOPSIS
- * Simple program based on libAfterImage to tile and tint image.
- * DESCRIPTION
- * All we want to do here is to get image filename, tint color and
- * desired geometry from the command line. We then load this image, and
- * proceed on to tiling it based on parameters. Tiling geometry
- * specifies rectangular shape on limitless plane on which original
- * image is tiled. While we are at tiling the image we also tint it to
- * specified color, or to some random value derived from the current
- * time in seconds elapsed since 1971.
- * We then display the result in simple window.
- * After that we would want to wait, until user closes our window.
- *
- * In this tutorial we will only explain new steps, not described in
- * previous tutorial. New steps described in this tutorial are :
- * ASTile.1. Parsing ARGB32 tinting color.
- * ASTile.2. Parsing geometry spec.
- * ASTile.3. Tiling and tinting ASImage.
- * SEE ALSO
- * ASView - explanation of basic steps needed to use libAfterImage and
- *          some other simple things.
- * SOURCE
- */
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "common.h"
-
-void usage()
-{
-	printf( "Usage: astile [-h]|[[-g geometry][-t tint_color] image]\n");
-	printf( "Where: image    - source image filename.\n");
-	printf( "       geometry - width and height of the resulting image,\n");
-	printf( "                  and x, y of the origin of the tiling on "
-			"source image.\n");
-	printf( "       tint_color - color to tint image with.( defaults to "
-			"current time :)\n");
-}
-
-int main(int argc, char* argv[])
-{
-	Window w ;
-	Display *dpy = NULL;
-	ASVisual *asv ;
-	int screen = 0, depth = 0;
-	char *image_file = "rose512.jpg" ;
-	ARGB32 tint_color = time(NULL);
-	int tile_x, tile_y, geom_flags = 0;
-	unsigned int tile_width, tile_height ;
-	ASImage *im ;
-
-	/* see ASView.1 : */
-	set_application_name( argv[0] );
-
-#ifndef X_DISPLAY_MISSING
-	/* parse_argb_color can only be used after display is open,
-	   otherwise we are limited to colors defined as ARGB values : */
-  	dpy = XOpenDisplay(NULL);
-	_XA_WM_DELETE_WINDOW = XInternAtom( dpy, "WM_DELETE_WINDOW", False);
-	screen = DefaultScreen(dpy);
-	depth = DefaultDepth( dpy, screen );
-#endif
-
-	if( argc > 1 )
-	{
-		int i ;
-
-		if( strncmp( argv[1], "-h", 2 ) == 0 )
-		{
-			usage();
-			return 0;
-		}
-
-		for( i = 1 ; i < argc ; i++ )
-		{
-			if( argv[i][0] == '-' && i < argc-1 )
-			{
-				switch(argv[i][1])
-				{
-					case 't' :			/* see ASTile.1 : */
-						if( parse_argb_color( argv[i+1], &tint_color ) ==
-							argv[i+1] )
-							show_warning( "unable to parse tint color - "
-										  "default used: #%8.8lX",
-				            			  (unsigned long)tint_color );
-					    break ;
-					case 'g' :   		/* see ASTile.2 : */
-	    				geom_flags = XParseGeometry( argv[i+1],
-							                         &tile_x, &tile_y,
-		        				        			 &tile_width,
-													 &tile_height );
-					    break ;
-				}
-				++i ;
-			}else
-				image_file = argv[i] ;
-		}
-	}else
-	{
-		show_warning( "no image file or tint color specified - "
-					  "defaults used: \"%s\" #%8.8lX",
-		              image_file, (unsigned long)tint_color );
-		usage();
-	}
-
-	/* see ASView.2 : */
-	im = file2ASImage( image_file, 0xFFFFFFFF, SCREEN_GAMMA, 0, getenv("IMAGE_PATH"), NULL );
-
-	/* Making sure tiling geometry is sane : */
-	if( !get_flags(geom_flags, XValue ) )
-		tile_x = im->width/2 ;
-	if( !get_flags(geom_flags, YValue ) )
-		tile_y = im->height/2 ;
-	if( !get_flags(geom_flags, WidthValue ) )
-		tile_width = im->width*2 ;
-	if( !get_flags(geom_flags, HeightValue ) )
-		tile_height = im->height*2;
-	printf( "%s: tiling image \"%s\" to "
-			"%dx%d%+d%+d tinting with #%8.8lX\n",
-		    get_application_name(), image_file, tile_width, tile_height,
-			tile_x, tile_y, (unsigned long)tint_color );
-
-	if( im != NULL )
-	{
-		/* see ASView.3 : */
-		asv = create_asvisual( dpy, screen, depth, NULL );
-		w = None ;
-#ifndef X_DISPLAY_MISSING
-		/* see ASView.4 : */
-		w = create_top_level_window( asv, DefaultRootWindow(dpy), 32, 32,
-			                         tile_width, tile_height, 1, 0, NULL,
-									 "ASTile", image_file );
-		if( w != None )
-		{
-			Pixmap p ;
-			ASImage *tinted_im ;
-
-	  		XMapRaised   (dpy, w);
-			/* see ASTile.3 : */
-			tinted_im = tile_asimage( asv, im, tile_x, tile_y,
-				                      tile_width, tile_height,
-				                      tint_color, ASA_XImage, 0,
-									  ASIMAGE_QUALITY_TOP );
-			destroy_asimage( &im );
-			/* see ASView.5 : */
-			p = asimage2pixmap( asv, DefaultRootWindow(dpy), tinted_im,
-				                NULL, True );
-			destroy_asimage( &tinted_im );
-			/* see common.c: set_window_background_and_free() : */
-			p = set_window_background_and_free( w, p );
-		}
-		/* see common.c: wait_closedown() : */
-		wait_closedown(w);
-		dpy = NULL;		
-#else
-		{
-			ASImage *tinted_im ;
-			/* see ASTile.3 : */
-			tinted_im = tile_asimage( asv, im, tile_x, tile_y,
-				                      tile_width, tile_height,
-				                      tint_color, ASA_ASImage, 0,
-									  ASIMAGE_QUALITY_TOP );
-			destroy_asimage( &im );
-			/* writing result into the file */
-			ASImage2file( tinted_im, NULL, "astile.jpg", ASIT_Jpeg, NULL );
-			destroy_asimage( &tinted_im );
-		}
-#endif
-	}
-    return 0 ;
-}
-/**************/
-
-/****f* libAfterImage/tutorials/ASTile.1 [3.1]
- * SYNOPSIS
- * Step 1. Color parsing.
- * DESCRIPTION
- * libAfterImage utilizes function provided by libAfterBase for color
- * parsing. In case libAfterBase is unavailable - libAfterImage
- * includes its own copy of that function. This function differs from
- * standard XParseColor in a way that it allows for parsing of alpha
- * channel in addition to red, green and blue. It autodetects if value
- * include alpha channel or not, using the following logic:
- * If number of hex digits in color spec is divisible by 4 and is not
- * equal to 12 then first digits are treated as alpha channel.
- * In case named color is specified or now apha channel is specified
- * alpha value of 0xFF will be used, marking this color as solid.
- * EXAMPLE
- *     if( parse_argb_color( argv[i+1], &tint_color ) == argv[i+1] )
- * 	       show_warning( "unable to parse tint color - default used: #%8.8X",
- *                        tint_color );
- * NOTES
- * On success parse_argb_color returns pointer to the character
- * immidiately following color specification in original string.
- * Therefore test for returned value to be equal to original string will
- * can be used to detect error.
- * SEE ALSO
- * libAfterBase, parse_argb_color(), ARGB32
- *******/
-/****f* libAfterImage/tutorials/ASTile.2 [3.2]
- * SYNOPSIS
- * Step 2. Parsing the geometry.
- * DESCRIPTION
- * Geometry can be specified in WIDTHxHEIGHT+X+Y format. Accordingly we
- * use standard X function to parse it: XParseGeometry. Returned flags
- * tell us what values has been specified. We only have to fill the rest
- * with some sensible defaults. Default x is width/2, y is height/2, and
- * default size is same as image's width.
- * EXAMPLE
- *     geom_flags = XParseGeometry ( argv[i+1], &tile_x, &tile_y,
- *                                   &tile_width, &tile_height );
- * SEE ALSO
- * ASScale.1
- ********/
-/****f* libAfterImage/tutorials/ASTile.3 [3.3]
- * SYNOPSIS
- * Step 3. Actuall tiling of the image.
- * DESCRIPTION
- * Actuall tiling is quite simple - just call tile_asimage and it will
- * generate new ASImage containing tiled and tinted image. For the sake
- * of example we set quality to TOP, but normally GOOD quality is quite
- * sufficient, and is a default. Again, compression is set to 0 since we
- * do not intend to store image for long time. Even better we don't need
- * to store it at all - all we need is XImage, so we can transfer it to
- * the server easily. That is why to_xim argument is set to ASA_XImage.
- * As the result obtained ASImage will not have any data in its buffers,
- * but it will have ximage member set to point to valid XImage.
- * Subsequently we enjoy that convinience, by setting use_cached to True
- * in call to asimage2pixmap(). That ought to save us alot of processing.
- *
- * Tinting works in both directions - it can increase intensity of the
- * color or decrease it. If any particular channel of the tint_color is
- * greater then 127 then intensity is increased, otherwise its decreased.
- * EXAMPLE
- * tinted_im = tile_asimage( asv, im, tile_x, tile_y,
- *                         tile_width, tile_height,
- *                         tint_color,
- *                         ASA_XImage, 0, ASIMAGE_QUALITY_TOP );
- * destroy_asimage( &im );
- * NOTES
- * SEE ALSO
- * tile_asimage().
- ********/
diff -Naur libAfterImage-1.20/apps/asvector.c root/graf2d/asimage/src/libAfterImage/apps/asvector.c
--- libAfterImage-1.20/apps/asvector.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/asvector.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,156 +0,0 @@
-#include "config.h"
-
-#include <string.h>
-#include <stdlib.h>
-
-
-/****h* libAfterImage/tutorials/ASVector
- * NAME
- * ASVector
- * SYNOPSIS
- * libAfterImage application for drawing image representing array of 
- * floating point values ( scientiofic data ).
- * DESCRIPTION
- * SEE ALSO
- * Tutorial 1: ASView  - explanation of basic steps needed to use
- *                       libAfterImage and some other simple things.
- * Tutorial 2: ASScale - image scaling basics.
- * Tutorial 3: ASTile  - image tiling and tinting.
- * Tutorial 4: ASMerge - scaling and blending of arbitrary number of
- *                       images.
- * SOURCE
- */
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "common.h"
-
-#if 1
-CARD16 chan_alpha[] = {0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 
-								0xffff, 0xffff, 0xffff, 0xffff};
-CARD16 chan_red  [] = {0x0000, 0x7000, 0x0000, 0x0000, 0x0000, 
-								0xffff, 0xffff, 0x7000, 0xffff};
-CARD16 chan_green[] = {0x0000, 0x0000, 0x0000, 0xffff, 0xffff, 
-								0xffff, 0x0000, 0x0000, 0xffff};
-CARD16 chan_blue [] = {0x0000, 0x7000, 0xffff, 0xffff, 0x0000, 
-								0x0000, 0x0000, 0x0000, 0xffff};
-#else
-CARD16 chan_alpha[] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 
-								0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};
-CARD16 chan_red[] =   {0x0000, 0x0000, 0x0000, 0x0000, 0x8888, 
-								0xffff, 0xffff, 0xffff, 0xff00};
-CARD16 chan_green[]=  {0x0000, 0x0000, 0x8888, 0x8888, 0x0000, 
-								0x0000, 0x8888, 0x8888, 0xff00};
-CARD16 chan_blue[] =  {0xFFFF, 0x0000, 0xFFFF, 0x0000, 0xFFFF, 
-								0x0000, 0xffff, 0x0000, 0xff00};
-#endif
-
-double points[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8} ;
-
-
-void usage()
-{
-}
-
-int main(int argc, char* argv[])
-{
-	Display *dpy = NULL;
-	ASVisual *asv ;
-	int screen = 0, depth = 0;
-	unsigned int to_width= 200, to_height = 200;
-	ASVectorPalette  palette = { 9, &(points[0]), 
-								{&chan_blue[0], &chan_green[0], 
-								 &chan_red[0], &chan_alpha[0]}, 
-								 ARGB32_Black} ;
-	double vector[5 * 5] ;
-/*	double vector[200*200] ; */
-	ASImage *vect_im = NULL;
-	ASImage *temp_im = NULL;
-	int x, y ;
-
-	/* see ASView.1 : */
-	set_application_name( argv[0] );
-#if (HAVE_AFTERBASE_FLAG==1)
-	set_output_threshold(OUTPUT_LEVEL_DEBUG);
-#endif
-
-	for( y = 5 ; y > 0 ; --y ) 
-		for( x = 1 ; x <= 5 ; ++x ) 
-		  vector[(5-y)*5+x-1] = (y-1)+(x-1);
-#ifndef X_DISPLAY_MISSING
-    dpy = XOpenDisplay(NULL);
-	_XA_WM_DELETE_WINDOW = XInternAtom( dpy, "WM_DELETE_WINDOW", False);
-	screen = DefaultScreen(dpy);
-	depth = DefaultDepth( dpy, screen );
-#endif
-
-	/* see ASView.3 : */
-	asv = create_asvisual( dpy, screen, depth, NULL );
-	/* see ASGrad.2 : */
-	temp_im = create_asimage_from_vector( asv, &vector[0],
-							5, 5,
-/*						to_width, to_height,  */
-							&palette,
-#ifndef X_DISPLAY_MISSING
-							 ASA_XImage,
-#else
-							 ASA_ASImage,
-#endif
-							0, ASIMAGE_QUALITY_POOR );
-
-
-#if 0
-    vect_im = temp_im ;
-#else
-	vect_im = scale_asimage(asv, temp_im, to_width, to_height,
-                            ASA_ASImage, 100, ASIMAGE_QUALITY_POOR);
-#endif
-	if( vect_im )
-	{
-#ifndef X_DISPLAY_MISSING
-		/* see ASView.4 : */
-		Window w = create_top_level_window( asv,
-		                                    DefaultRootWindow(dpy), 
-											32, 32,
-		                        			to_width, to_height, 1, 0, 
-											NULL,
-											"ASVector", NULL );
-		if( w != None )
-		{
-			Pixmap p ;
-
-		  	XMapRaised   (dpy, w);
-			/* see ASView.5 : */
-			p = asimage2pixmap( asv, DefaultRootWindow(dpy), vect_im,
-					            NULL, True );
-//			destroy_asimage( &vect_im );
-			/* see common.c: set_window_background_and_free() : */
-			p = set_window_background_and_free( w, p );
-			/* see common.c: wait_closedown() : */
-		}
-		wait_closedown(w);
-		dpy = NULL;
-#endif
-		{
-			CARD8 * buffer ; 
-			int size ;		   
-	  		if( ASImage2PNGBuff( vect_im, &buffer, &size, NULL ) ) 
-			{
-				FILE * pf = fopen("asvector.png", "w" ) ; 
-				if( pf ) 
-				{
-					fwrite( buffer, size, 1, pf );
-					fclose(pf);
-				}	 
-				free( buffer );
-			}else
-				show_error( "failed to encode image as PNG"); 	 
-		}
-		ASImage2file( vect_im, NULL, "asvector_copy.png", ASIT_Png, NULL );
-		destroy_asimage( &vect_im );
-//#endif
-	}
-    return 0 ;
-}
-/**************/
-
diff -Naur libAfterImage-1.20/apps/asview.c root/graf2d/asimage/src/libAfterImage/apps/asview.c
--- libAfterImage-1.20/apps/asview.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/asview.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,294 +0,0 @@
-#include "config.h"
-
-#include <string.h>
-#include <stdlib.h>
-
-/****h* libAfterImage/tutorials/ASView
- * NAME
- * ASView
- * SYNOPSIS
- * Simple image viewer based on libAfterImage.
- * DESCRIPTION
- * All we want to do here is to get image filename from the command line,
- * then load this image, and display it in simple window.
- * After that we would want to wait, until user closes our window.
- * SOURCE
- */
-
-#define DO_CLOCKING
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "common.h"
-
-#ifdef DO_CLOCKING
-#if TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# if HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif
-#endif
-
-
-void usage()
-{
-	printf( "Usage: asview [-h]|[image]\n");
-	printf( "Where: image - filename of the image to display.\n");
-}
-
-
-int main(int argc, char* argv[])
-{
-	char *image_file = "rose512.jpg" ;
-	ASImage *im ;
-	ASVisual *asv ;
-	int screen = 0, depth = 24;
-	Display *dpy = NULL;
-
-	/* see ASView.1 : */
-	set_application_name( argv[0] );
-#if (HAVE_AFTERBASE_FLAG==1)
-	set_output_threshold(OUTPUT_LEVEL_DEBUG);
-#ifdef DEBUG_ALLOCS
-	fprintf( stderr, "have DEBUG_ALLOCS\n");
-#endif
-#ifdef AFTERBASE_DEBUG_ALLOCS
-	fprintf( stderr, "have AFTERBASE_DEBUG_ALLOCS\n");
-#endif
-#endif
-
-	if( argc > 1 )
-	{
-		if( strcmp( argv[1], "-h" ) == 0 )
-		{
-			usage();
-			return 0;
-		}
-		image_file = argv[1] ;
-	}else
-	{
-		show_warning( 	"Image filename was not specified. "
-						"Using default: \"%s\"", image_file );
-		usage();
-	}
-#ifndef X_DISPLAY_MISSING
-	dpy = XOpenDisplay(NULL);
-	XSynchronize (dpy, True);
-	_XA_WM_DELETE_WINDOW = XInternAtom( dpy, "WM_DELETE_WINDOW", 
-										False);
-	screen = DefaultScreen(dpy);
-	depth = DefaultDepth( dpy, screen );
-#endif	
-	/* see ASView.3 : */
-	asv = create_asvisual( dpy, screen, depth, NULL );
-	/* asv = create_asvisual_for_id( dpy, screen, depth, 0x28, None, NULL ); */
-
-	/* see ASView.2 : */
-	im = file2ASImage( image_file, 0xFFFFFFFF, SCREEN_GAMMA, 0, getenv("IMAGE_PATH"), NULL );
-
-	/* The following could be used to dump JPEG version of the image into
-	 * stdout : */
-	/* 	ASImage2file( im, NULL, NULL, ASIT_Jpeg, NULL ); 
-		ASImage2file( im, NULL, "asview.png", ASIT_Png, NULL );
-		ASImage2file( im, NULL, "asview.gif", ASIT_Gif, NULL );
-	*/
-
-	if( im != NULL )
-	{
-#ifndef X_DISPLAY_MISSING
-		Window w ;
-#if 0
-		/* test example for get_asimage_channel_rects() : */
-		XRectangle *rects ;	unsigned int rects_count =0; int i ;
-		rects = get_asimage_channel_rects( im, IC_ALPHA, 10, 
-											&rects_count );
-		fprintf( stderr, " %d rectangles generated : \n", rects_count );
-		for( i = 0 ; i < rects_count ; ++i )
-			fprintf( stderr, "\trect[%d]=%dx%d%+d%+d;\n", 
-					 i, rects[i].width, rects[i].height, 
-					 rects[i].x, rects[i].y );
-#endif
-
-
-#if 0		 
-		/* test example for fill_asimage : */
-		fill_asimage(asv, im, 0, 0, 50, 50, 0xFFFF0000);
-		fill_asimage(asv, im, 50, 50, 100, 50, 0xFFFF0000);
-		fill_asimage(asv, im, 0, 100, 200, 50, 0xFFFF0000);
-		fill_asimage(asv, im, 150, 0, 50, 50, 0xFFFF0000);
-#endif
-#if 0
-		/* test example for conversion to argb32 :*/
-		{
-			ASImage *tmp = tile_asimage( asv, im, 0, 0, im->width, im->height, TINT_NONE, ASA_ARGB32, 
-										  0, ASIMAGE_QUALITY_DEFAULT );	 
-			destroy_asimage( &im );
-			set_flags( tmp->flags, ASIM_DATA_NOT_USEFUL|ASIM_XIMAGE_NOT_USEFUL );
-			im = tmp ;
-		}		   
-#endif		   
-		/* see ASView.4 : */
-		w = create_top_level_window( asv, DefaultRootWindow(dpy), 32, 32,
-			                         im->width, im->height, 1, 0, NULL,
-									 "ASView", image_file );
-		if( w != None )
-		{
-			Pixmap p ;
-	  		
-			XMapRaised   (dpy, w);
-			XSync(dpy,False);
-			/* see ASView.5 : */
-	  		p = create_visual_pixmap( asv, DefaultRootWindow(dpy), im->width, im->height, 0 );
-	
-			{
-				START_TIME(started);
-				/* for( int i = 0 ; i < 100 ; ++i )  To test performance! */
-				asimage2drawable( asv, p, im, NULL, 0, 0, 0, 0, im->width, im->height, False);
-				SHOW_TIME("", started);
-			}
-			/* print_storage(NULL); */
-			destroy_asimage( &im );
-			/* see common.c:set_window_background_and_free(): */
-			p = set_window_background_and_free( w, p );
-		}
-		/* see common.c: wait_closedown() : */
-		wait_closedown(w);
-		dpy = NULL;
-		
-		/* no longer need this - lets clean it up :*/
-		destroy_asvisual( asv, False );
-		asv = NULL ;
-
-#else
-		/* writing result into the file */
-		ASImage2file( im, NULL, "asview.png", ASIT_Png, NULL );
-#endif
-	}
-
-#ifdef DEBUG_ALLOCS
-    /* different cleanups of static memory pools : */
-    flush_ashash_memory_pool();
-	asxml_var_cleanup();
-	custom_color_cleanup();
-    build_xpm_colormap( NULL );
-	flush_default_asstorage();
-	/* requires libAfterBase */
-	print_unfreed_mem();
-#endif
-
-    return 0 ;
-}
-/**************/
-
-/****f* libAfterImage/tutorials/ASView.1 [1.1]
- * SYNOPSIS
- * Step 1. Initialization.
- * DESCRIPTION
- * libAfterImage requires only 2 global things to be setup, and both of
- * those are inherited from libAfterBase: dpy - pointer to open X display-
- * naturally that is something we cannot live without; application name -
- * used in all the text output, such as error and warning messages and
- * also debugging messages if such are enabled.
- * The following two line are about all that is required to setup both
- * of this global variables :
- * EXAMPLE
- *     set_application_name( argv[0] );
- *     dpy = XOpenDisplay(NULL);
- * NOTES
- * First line is setting up application name from command line's
- * program name. Second opens up X display specified in DISPLAY env.
- * variable. Naturally based on application purpose different parameters
- * can be passed to these functions, such as some custom display string.
- * SEE ALSO
- * libAfterBase, set_application_name(), XOpenDisplay(), Display,
- *******/
-/****f* libAfterImage/tutorials/ASView.2 [1.2]
- * SYNOPSIS
- * Step 2. Loading image file.
- * DESCRIPTION
- * At this point we are ready to load image from file into memory. Since
- * libAfterImage does not use any X facilities to store image - we don't
- * have to create any window or anything else yet. Even dpy is optional
- * here - it will only be used to try and parse names of colors from
- * .XPM images.
- * EXAMPLE
- *     im = file2ASImage( image_file, 0xFFFFFFFF, SCREEN_GAMMA, 0, NULL);
- * NOTES
- * We used compression set to 0, as we do not intend to store
- * image in memory for any considerable amount of time, and we want to
- * avoid additional processing overhead related to image compression.
- * If image was loaded successfully, which is indicated by returned
- * pointer being not NULL, we can proceed to creation of the window and
- * displaying of the image.
- * SEE ALSO
- * file2ASImage()
- ********/
-/****f* libAfterImage/tutorials/ASView.3 [1.3]
- * SYNOPSIS
- * Step 3. Preparation of the visual.
- * DESCRIPTION
- * At this point we have to obtain Visual information, as window
- * creation is highly dependant on Visual being used. In fact when X
- * creates a window it ties it to a particular Visual, and all its
- * attributes, such as colormap, pixel values, pixmaps, etc. must be
- * associated with the same Visual. Accordingly we need to acquire
- * ASVisual structure, which is our abstraction layer from them naughty
- * X Visuals. :
- * EXAMPLE
- *     asv = create_asvisual( dpy, screen, depth, NULL );
- * NOTES
- * If any Window or Pixmap is created based on particular ASVisual, then
- * this ASVisual structure must not be destroyed untill all such
- * Windows and Pixmaps are destroyed.
- * SEE ALSO
- * See create_asvisual() for details.
- ********/
-/****f* libAfterImage/tutorials/ASView.4 [1.4]
- * SYNOPSIS
- * Step 4. Preparation of the window.
- * DESCRIPTION
- * Creation of top level window consists of several steps of its own:
- * a) create the window of desired size and placement
- * b) set ICCCM hints on the window
- * c) select appropriate events on the window
- * c) map the window.
- * First two steps has been moved out into create_top_level_window()
- * function.
- * EXAMPLE
- *     w = create_top_level_window( asv, DefaultRootWindow(dpy), 32, 32,
- *                                  im->width, im->height, 1, 0, NULL,
- *                                  "ASView" );
- *     if( w != None )
- *     {
- *         XSelectInput (dpy, w, (StructureNotifyMask | ButtonPress));
- *         XMapRaised   (dpy, w);
- *     }
- * NOTES
- * Map request should be made only for window that has all its hints set
- * up already, so that Window Manager can read them right away.
- * We want to map window as soon as possible so that User could see that
- * something really is going on, even before image is displayed.
- * SEE ALSO
- * ASImage, create_top_level_window()
- ********/
-/****f* libAfterImage/tutorials/ASView.5 [1.5]
- * SYNOPSIS
- * Step 5. Displaying the image.
- * DESCRIPTION
- * The simplest way to display image in the window is to convert it
- * into Pixmap, then set Window's background to this Pixmap, and,
- * at last, clear the window, so that background shows up.
- * EXAMPLE
- *  p = asimage2pixmap( asv, DefaultRootWindow(dpy), im, NULL, False );
- *  destroy_asimage( &im );
- * NOTES
- * We no longer need ASImage after we transfered it onto the Pixmap, so
- * we better destroy it to conserve resources.
- * SEE ALSO
- * asimage2pixmap(), destroy_asimage(), set_window_background_and_free()
- ********/
diff -Naur libAfterImage-1.20/apps/asview_gl.c root/graf2d/asimage/src/libAfterImage/apps/asview_gl.c
--- libAfterImage-1.20/apps/asview_gl.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/asview_gl.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,260 +0,0 @@
-#include "config.h"
-
-#include <string.h>
-#include <stdlib.h>
-
-/****h* libAfterImage/tutorials/ASView_GL
- * NAME
- * ASView_GL
- * SYNOPSIS
- * Simple image viewer based on libAfterImage, using OpenGL API to transfer image to X.
- * DESCRIPTION
- * All we want to do here is to get image filename from the command line,
- * then load this image, and display it in simple window.
- * After that we would want to wait, until user closes our window.
- * SOURCE
- */
-#define LOCAL_DEBUG
-#define DO_CLOCKING
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-#include "common.h"
-
-#ifdef DO_CLOCKING
-#if TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# if HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif
-#endif
-
-
-#include <GL/gl.h>
-#include <GL/glx.h>
-
-void usage()
-{
-	printf( "Usage: asview [-h]|[image]\n");
-	printf( "Where: image - filename of the image to display.\n");
-}
-
-void
-glbuf2GLXPixmap(ASVisual *asv, Pixmap p, GLXContext glctx, ASImage *im )
-{
-//    GLboolean bparam;
-	GLXPixmap glxp;
-	int glbuf_size = 3 * im->width * im->height;
-	CARD8 *glbuf = NULL;
-	ASImageDecoder *imdec  = NULL ;
-		
-	if ((imdec = start_image_decoding(asv, im, SCL_DO_COLOR, 0, 0, im->width, im->height, NULL)) != NULL )
-	{	 
-		int i, l = glbuf_size;
-		glbuf = safemalloc( glbuf_size );
-		for (i = 0; i < (int)im->height; i++)
-		{	
-			int k = im->width;
-			imdec->decode_image_scanline( imdec ); 
-			while( --k >= 0 ) 
-			{
-				glbuf[--l] = imdec->buffer.blue[k] ;
-				glbuf[--l] = imdec->buffer.green[k] ;
-				glbuf[--l] = imdec->buffer.red[k] ;
-			}	 
-		}
-		stop_image_decoding( &imdec );
-	}else
-		return;
-
-
-//	show_warning( "asimage2pmap");
-	//fprintf( stderr, "p = %lX, glxp = %lX, glctx = %p\n", p, glxp, glctx );
-	glxp = glXCreateGLXPixmap( dpy, &(asv->visual_info), p);
-
-	glXMakeCurrent (dpy, glxp, glctx);
-	//fprintf( stderr, "line = %d, glerror = %d\n", __LINE__, glGetError() );
-			
-	glDisable(GL_BLEND);		/* optimize pixel transfer rates */
-  	glDisable (GL_DEPTH_TEST);
-  	glDisable (GL_DITHER);
-  	glDisable (GL_FOG);
-  	glDisable (GL_LIGHTING);
-	
-	glViewport(-(im->width/2), -(im->height/2), im->width, im->height);
-
-	//glGetBooleanv (GL_DOUBLEBUFFER, &bparam);
-	//fprintf( stderr, "doublebuffer = %d\n", bparam );
-  	//if (bparam == GL_TRUE) 
-   	glDrawBuffer (GL_FRONT);
-
-	/* now put pixels on */
-//	glRasterPos3i( 0, 0, 0 );
-	//fprintf( stderr, "line = %d, glerror = %d\n", __LINE__, glGetError() );
-	//fprintf( stderr, "i = %d\n", i );
-//	show_warning( "glDrawPixels ...");
-	glDrawPixels( im->width, im->height, GL_RGB, GL_UNSIGNED_BYTE, glbuf );
-	free( glbuf );
-//	show_warning( "glDrawPixels  done");
-	glXMakeCurrent (dpy, None, NULL);	  
-	glXDestroyGLXPixmap( dpy, glxp);
-	glFinish(); 				   
-
-}
-
-
-int main(int argc, char* argv[])
-{
-	char *image_file = "rose512.jpg" ;
-	ASImage *im ;
-	/* see ASView.1 : */
-	set_application_name( argv[0] );
-#if (HAVE_AFTERBASE_FLAG==1)
-	set_output_threshold(OUTPUT_LEVEL_DEBUG);
-#endif
-
-	if( argc > 1 )
-	{
-		if( strcmp( argv[1], "-h" ) == 0 )
-		{
-			usage();
-			return 0;
-		}
-		image_file = argv[1] ;
-	}else
-	{
-		show_warning( 	"Image filename was not specified. "
-						"Using default: \"%s\"", image_file );
-		usage();
-	}
-	/* see ASView.2 : */
-	im = file2ASImage( image_file, 0xFFFFFFFF, SCREEN_GAMMA, 0, getenv("IMAGE_PATH"), NULL );
-
-	/* The following could be used to dump JPEG version of the image into
-	 * stdout : */
-	/* ASImage2file( im, NULL, NULL, ASIT_Jpeg, NULL ); */
-
-
-	if( im != NULL )
-	{
-#ifndef X_DISPLAY_MISSING
-		Window w = None;
-		ASVisual *asv ;
-		int screen, depth ;
-
-#if 0
-		XRectangle *rects ;	unsigned int rects_count =0; int i ;
-		rects = get_asimage_channel_rects( im, IC_ALPHA, 10, 
-											&rects_count );
-		fprintf( stderr, " %d rectangles generated : \n", rects_count );
-		for( i = 0 ; i < rects_count ; ++i )
-			fprintf( stderr, "\trect[%d]=%dx%d%+d%+d;\n", 
-					 i, rects[i].width, rects[i].height, 
-					 rects[i].x, rects[i].y );
-#endif
-
-	    dpy = XOpenDisplay(NULL);
-		XSynchronize (dpy, True);
-		if (! glXQueryExtension (dpy, NULL, NULL))
-		{	
-    		show_error("X server does not support OpenGL GLX extension");
-			return 0 ;
-		}
-		_XA_WM_DELETE_WINDOW = XInternAtom( dpy, "WM_DELETE_WINDOW", 
-											False);
-		screen = DefaultScreen(dpy);
-		depth = DefaultDepth( dpy, screen );
-		/* see ASView.3 : */
-		asv = create_asvisual( dpy, screen, depth, NULL );
-
-		/* test example for fill_asimage : */
-#if 0
-		fill_asimage(asv, im, 0, 0, 50, 50, 0xFFFF0000);
-		fill_asimage(asv, im, 50, 50, 100, 50, 0xFFFF0000);
-		fill_asimage(asv, im, 0, 100, 200, 50, 0xFFFF0000);
-		fill_asimage(asv, im, 150, 0, 50, 50, 0xFFFF0000);
-#endif
-		/* test example for conversion to argb32 :*/
-#if 0
-		{
-			ASImage *tmp = tile_asimage( asv, im, 0, 0, im->width, im->height, TINT_NONE, ASA_ARGB32, 
-										  0, ASIMAGE_QUALITY_DEFAULT );	 
-			destroy_asimage( &im );
-			set_flags( tmp->flags, ASIM_DATA_NOT_USEFUL|ASIM_XIMAGE_NOT_USEFUL );
-			im = tmp ;
-		}		   
-#endif		   
-		
-
-
-		/* see ASView.4 : */
-		w = create_top_level_window( asv, DefaultRootWindow(dpy), 32, 32,
-			                         im->width, im->height, 1, 0, NULL,
-									 "ASView - using OpenGL", image_file );
-		if( w != None )
-		{
-			Pixmap    p;
-			int i ;
-
-	  		XMapRaised   (dpy, w);
-			XSync(dpy,False);
-			//sleep_a_millisec(1000);
-			//XSync(dpy,False);
-			/* see ASView.5 : */
-//			show_warning( "asimage2pmap Done");
-			p = create_visual_pixmap( asv, DefaultRootWindow(dpy), im->width, im->height, 0 );
-
-			{
-				START_TIME(started);
-				time_t t = time(NULL);
-				for( i = 0 ; i < 100 ; ++i ) 
-				{
-#define DIRECT_TO_WIN 0
-#define USEXGL 1
-
-#if USEXGL
-# if !DIRECT_TO_WIN
-					asimage2drawable_gl( asv, p, im, 0, 0, 0, 0, im->width, 127/*im->height*/, im->width, im->height,  False );
-# else										
-					asimage2drawable_gl( asv, w, im, 0, 0, 0, 0, im->width, 128/*im->height*/, im->width, im->height,  True );
-# endif
-#else
-# if !DIRECT_TO_WIN
-					asimage2drawable( asv, p, im, NULL, 0, 0, 0, 0, im->width, im->height, False);
-# else
-					asimage2drawable( asv, w, im, NULL, 0, 0, 0, 0, im->width, im->height, False);
-# endif 						  
-#endif 						  
-					LOCAL_DEBUG_OUT ("timestamp%s","");
-          XSync(dpy, False);
-				}
-				SHOW_TIME("", started);
-				fprintf( stderr, "runtime = %ld sec\n", time(NULL)-t );
-			}
-			/* print_storage(NULL); */
-			destroy_asimage( &im );
-			/* see common.c:set_window_background_and_free(): */
-# if !DIRECT_TO_WIN      
-			p = set_window_background_and_free( w, p );
-#endif		
-    }
-    
-		/* see common.c: wait_closedown() : */
-		wait_closedown(w);
-
-#else
-		/* writing result into the file */
-		ASImage2file( im, NULL, "asview.jpg", ASIT_Jpeg, NULL );
-#endif
-	}
-
-    return 0 ;
-}
-/**************/
-
-
diff -Naur libAfterImage-1.20/apps/back.xpm root/graf2d/asimage/src/libAfterImage/apps/back.xpm
--- libAfterImage-1.20/apps/back.xpm	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/back.xpm	1970-01-01 01:00:00.000000000 +0100
@@ -1,80 +0,0 @@
-/* XPM */
-static char *magick[] = {
-/* columns rows colors chars-per-pixel */
-"64 64 10 1",
-"   c #4e4e4c",
-".  c #363634",
-"X  c #262624",
-"o  c #0e0e0c",
-"O  c #666664",
-"+  c #1a1a1c",
-"@  c #122e2c",
-"#  c #2e5654",
-"$  c #668684",
-"%  c #2e1214",
-/* pixels */
-" .X. .X... X  .. .. o ....... O......X  .X.+ .... O...X ..O.. ..",
-" XX  +... ..  .... .XO... O ..Xo+X...  ..  .   .O  X X. .... ...",
-".X   +X+. ... .....X@   . Ooo@.+  ..  .@ .oX++X. .X+X@...XX.@X..",
-". @...   .X@ +.. +..O O+X..+.....  . .++ .....   ....X...+#. . O",
-"  .... ..# .... ...X..O+.X.X+X.++ O .X.. .+... $.......+ . O   .",
-" ..O+ o.#..+X.... +   O+.# .+ O.O$ o+@X  +...#O +..+@.  .+  ....",
-" .. o   .o ..  o.X... O+.. + OOOO +#.   .. .#+..o..#O . ..Xo. ..",
-"..X.X..... +.  ..  . .OX+..o@o..+o+oo.. ....X. X.   ....X.O$ ...",
-"....#.. ..#..  .# +X+. .X+X+.O$oo.. O ..+.+...X. .....    #.+++o",
-"...+... +....  ..... X. X. .$ +o    +oX..XX X+ O...    +..X+X...",
-". .@X.. ..  X..#+.. ... +#   +.  ..++.OX..  .  ..  .+X+X..++.O..",
-" O+...X. . ... +X ...  .@..X.X +o+X . .    .+..X+.+..  . .    + ",
-" .X .  +.+.+ . ... ..+.#.@o++.X+.#  .#+X+++X.     .  O....  X + ",
-" ++X+....  ..X..     O O.. OO O O  ..X+.   +.  ..@+.@..... @+.+ ",
-" @.    XX#X.. #. ..+.XX.+.   . .  OO+. O   X. ..... O+ .  $X..X.",
-"....X+o+.    .+....X...  .++oo++X+XX....X..o. . .... X  .#.++ .+",
-"...   O   .+....    OO.#. ...  .X@.X.++.@. +O     .  ...# +.O ..",
-".. . .X+.+XX..#  ....+oX.....  ..  +.+   ..X ++. .    .OX. O .. ",
-"...+++X#OX.. ..+.+...@   ..+ ...# +.. ...  ..# . o+.X.+..XX+++o+",
-"+o.X... .+ O .X. X. ..O ...X..O@ .+ .o+........  +  X..OX.O...  ",
-"@.  #X  X  ++#+  .  + X+. +.X... ....X  ..o..  .X.     .+ .o.. X",
-"... .. . .+.  . .+.  .X. X  . ......O O#+X ..+++.O.. . .# X@ ..X",
-"O  ..  ..+. . X+. ....+  .... O o+  . .+..OO..O...+... . X+.  .X",
-".+. .O +X. ..  ..X+ X...#...+. .+  +. +.++..+ . O .O. ....  ..X.",
-"+.  o ..  #  O  .OO .$X. .   ..o+ O.+.. X. .X.@..+....   ....  O",
-".. X+.+...  ..X+..X+X++ .....#.oOOXXX.o..  ..#...X. .. ....+   .",
-" ..+ +...+..+++. XX #.X.+.+X... OX+.....+.. +..  O..+ +@....  ..",
-"..  O#OO$OO. .  .. .oX.  .. O   X+. . + o.. @. O+.+..## .. . .+o",
-"X...X+ .XX.X .. + ......X+ O .+.........X ....  .. ..X.++.. ++.O",
-".. ....++. .@..... #+. .....+o...  +@. +.    O  .... +..........",
-".  #.... ..@% +X.. .. O .  .+.   .#.O .X   .O ......OX+..+  .+. ",
-".  XX  O.+...  +.  . O ++..+@ .......X .   . .....  #.. ..O..X+ ",
-" O+.  XX+ .....X. O..+X.O.#+. ....+X+. . #.++++++.+X..++. ..++  ",
-"  ..+XO.....  .  O +X. ...X+.  + XX. O . ++.....  ....X. .. ..O#",
-".+@+.O.+ #.O @..+. + .....X. +X. +.O O+...  ...  #.X. .   ....O ",
-"....  .X++..+.. .  .#.. #+.  X. . .  oX#+.X..+  ....O.#... ...O ",
-"...  +X... ...... .X. ..+.. X..+. ...XOX...++.  . . .... X .....",
-" .. .X .   +. +...X.O.X..  .. . ..+ #+X+.  .O$+.....+.. .. + .#.",
-"... .+..O... .o . + .+ X.+.@.  .X  .X+  .....ooX .X.+.. +  .. .X",
-"o ....+O#oo. ..O.$+#.X.. +.+..+..O .     XX.+.. .X +.#O..O  #X++",
-" O. . . +o.. ...  ....  +. +XX...#Xo+.. .+. ... +.#+  O  X.+oX .",
-".+.. +.@.o O X+  ...o  X. X..... o+. O..+.  .  ..OO.  .X+.X.. ..",
-".@  ++ .X. O+.O . @X.O+.. . X.. ..O .O+.o.+@. .o+  . +XX. +O.+..",
-"@ O.+X#.X.O X. .. .. +o.  .+o.O.  .+. X#. #....X   +o+.. O+ .+ o",
-".. XX. . O .+XX.... ++.   o. $#o.+.....X..+  .+..#..X X.O#+OX+..",
-". .+. OO..X+.   ..@...   OX.#.% O ..O#.+ .X  +  +   XO@.  XOo. .",
-"  +   +.X+oX.. X #.  X.. .....  X.. ... ... .. X.   +..+ .+ +#..",
-" ..O o+O.X..  .@..+++. OO..#. .. X+.#.+.....+.X.O . + . O.. +.  ",
-"X.. .X$O..    @X..+ ... +++X.+o. X# O+.  ....O OO+. +..X..  .. .",
-"++..X   +..X .. O . .........+  X....+ .+.# .....o.....  .  o.XX",
-"o.O.  ........+..+X..   .. .    ..+X +.....o.+. .@. . .+.X..+ .+",
-".$O.#oX.o.  X.X..++o...@.X#X    X.. .+   ..+ .. @.+ ..X. .  + +#",
-"  ..+X. . .+.   . X O...+... +... .....+.. o. . + . ...#..  .#o.",
-". . ... ...+X... ..  ..+. O..X  +@#   X.O+#+O.. . o ..... . X.X.",
-".  .+.. ....  @+.. ..+    .o.. ..  ...  #o o .  #oX Oo  ..X + X ",
-" +..o.  +X . #XX .+. $O+++.+   . ......X+XO+O. ..+..O+O .. X#+X ",
-" ..XX. OoX @.+X   O$ ..+ .... X..++ .  . .O.X+O+.X.. .O +  .... ",
-".#+#..$.o  X  OO ..Xoooo+X.. O.+..   o .O+.+o  +. ...@ .X.X. X  ",
-" .... .+.OO. +..X+++....     ..X.. ...O.Xo..+O.. .o.#.O+@ ...+..",
-".+.  . ....o.  .+.. ....O+. o. X.#.   .X. .OXO....... X+X.+..  .",
-"X.   .XX.#   ..X.........X ..  @...O#.+. . O@ .+....  +.+..X. ..",
-".  .+ . .+. +..X . . .. X  + . +..  o+.OO+..+.+. O..  . .  . @..",
-"+. .  X.+. ..X. .  .   ..$+. + ... +X... o ..  .......X .... o..",
-"O .+ +.X. X..+ +.  X  #+ +X. .. .. . . O.o#X. o. X...#. .. # X. "
-};
diff -Naur libAfterImage-1.20/apps/common.c root/graf2d/asimage/src/libAfterImage/apps/common.c
--- libAfterImage-1.20/apps/common.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/common.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,212 +0,0 @@
-#include "config.h"
-
-#include <string.h>
-
-#include "../afterbase.h"
-#include "../afterimage.h"
-
-/****h* libAfterImage/tutorials/common.h
- * SYNOPSIS
- * Generic Xlib related functionality, common for all the tutorials.
- * SEE ALSO
- * libAfterImage,
- * ASView, ASScale, ASTile, ASMerge, ASGrad, ASFlip, ASText
- **************/
-
-/****v* libAfterImage/tutorials/_XA_WM_DELETE_WINDOW
- * NAME
- * _XA_WM_DELETE_WINDOW
- * SYNOPSIS
- * _XA_WM_DELETE_WINDOW - stores value of X Atom "WM_DELETE_WINDOW".
- * DESCRIPTION
- * In X all client's top level windows are managed by window manager.
- * That includes moving, resizing, decorating, focusing and closing of
- * windows. Interactions between window manager and client window are
- * governed by ICCCM specification.
- * All the parts of this specification are completely optional, but it
- * is recommended that the following minimum set of hints be supplied
- * for any client window:
- * Window's title(WM_NAME), iconified window title(WM_ICON_NAME), class
- * hint (WM_CLASS) and supported protocols (WM_PROTOCOLS). It is
- * recommended also that WM_DELETE_WINDOW protocol be supported, as
- * otherwise there are no way to safely close client window, but to
- * kill it.
- * All of the above mentioned hints are identified by atoms that have
- * standard preset values, except for WM_DELETE_WINDOW. As the result we
- * need to obtain WM_DELETE_WINDOW atoms ID explicitly. We use
- * _XA_WM_DELETE_WINDOW to store the ID of that atom, so it is accessible
- * anywhere from our application.
- * SOURCE
- */
-Atom _XA_WM_DELETE_WINDOW = None;
-/**************/
-
-/****f* libAfterImage/tutorials/create_top_level_window()
- * NAME
- * create_top_level_window()
- * SYNOPSIS
- * Window create_top_level_window( ASVisual *asv, Window root,
- *                                 int x, int y,
- *                                 unsigned int width,
- *                                 unsigned int height,
- *                                 unsigned int border_width,
- *                                 unsigned long attr_mask,
- *                                 XSetWindowAttributes *attr,
- *                                 char *app_class );
- * INPUTS
- * asv           - pointer to valid preinitialized ASVisual structure.
- * root          - root window of the screen on which to create window.
- * x, y          - desired position of the window
- * width, height - desired window size.
- * border_width  - desired initial border width of the window (may not
- *                 have any effect due to Window Manager intervention.
- * attr_mask     - mask of the attributes that has to be set on the
- *                 window
- * attr          - values of the attributes to be set.
- * app_class     - title of the application to be used as its window
- *                 Title and resources class.
- * RETURN VALUE
- * ID of the created window.
- * DESCRIPTION
- * create_top_level_window() is autyomating process of creating top
- * level application window. It creates window for specified ASVisual,
- * and then sets up basic ICCCM hints for that window, such as WM_NAME,
- * WM_ICON_NAME, WM_CLASS and WM_PROTOCOLS.
- * SOURCE
- */
-Window
-create_top_level_window( ASVisual *asv, Window root, int x, int y,
-                         unsigned int width, unsigned int height,
-						 unsigned int border_width, 
-						 unsigned long attr_mask,
-						 XSetWindowAttributes *attr, 
-						 const char *app_class, const char *app_name )
-{
- 	Window w = None;
-#ifndef X_DISPLAY_MISSING
-	char *tmp ;
-	XTextProperty name;
-	XClassHint class1;
-
-	w = create_visual_window(asv, root, x, y, width, height, border_width, 
-							 InputOutput, attr_mask, attr );
-
-	tmp = (app_name==NULL)?(char*)get_application_name():(char*)app_name;
-    XStringListToTextProperty (&tmp, 1, &name);
-
-    class1.res_name = tmp;	/* for future use */
-    class1.res_class = (char*)app_class;
-    XSetWMProtocols (asv->dpy, w, &_XA_WM_DELETE_WINDOW, 1);
-    XSetWMProperties (asv->dpy, w, &name, &name, NULL, 0, NULL, NULL, &class1);
-    /* final cleanup */
-    XFree ((char *) name.value);
-
-#endif /* X_DISPLAY_MISSING */
-	return w;
-}
-/**************/
-/****f* libAfterImage/tutorials/set_window_background_and_free()
- * NAME
- * set_window_background_and_free()
- * SYNOPSIS
- * Pixmap set_window_background_and_free( Window w, Pixmap p );
- * INPUTS
- * w - ID of the window background of which we need to set.
- * p - Pixmap to set background to.
- * RETURN VALUE
- * None on success. Pixmap ID of original Pixmap on failure.
- * DESCRIPTION
- * set_window_background_and_free() will set window's background to
- * specified Pixmap, Then refresh window contents so that background
- * is drawn by the server, flush all the requests to force it to be sent
- * to server to be processed as fast as possible.
- * NOTES
- * After Window's background has been set to Pixmap - X server makes
- * hidden copy of this Pixmap for later window refreshing. As the result
- * original Pixmap is no longer needed and can be freed to conserve
- * resources.
- * SOURCE
- */
-Pixmap
-set_window_background_and_free( Window w, Pixmap p )
-{
-#ifndef X_DISPLAY_MISSING
-	if( p != None && w != None )
-	{
-		Display *dpy = get_default_asvisual()->dpy;
-
-		if (dpy)
-		{
-			XSetWindowBackgroundPixmap( dpy, w, p );
-			XClearWindow( dpy, w );
-			XFlush( dpy );
-			XFreePixmap( dpy, p );
-			p = None ;
-		}
-	}
-#endif /* X_DISPLAY_MISSING */
-	return p ;
-}
-/**************/
-
-/****f* libAfterImage/tutorials/wait_closedown()
- * NAME
- * wait_closedown()
- * SYNOPSIS
- * void wait_closedown( Window w );
- * INPUTS
- * w - ID of the window from which to wait for events.
- * DESCRIPTION
- * User action requesting window to be closed is generally received
- * first by Window Manager. Window Manager is then handles it down to
- * the window by sending it ClientMessage event with first 32 bit word
- * of data set to the value of WM_DELETE_WINDOW Atom.
- * Accordingly, all client has to do is wait for such event from X server
- * and, when received, it should destroy its window and generally exit.
- *
- * NOTES
- * It is recommended that XFlush() is issued right after XDestroyWindow()
- * as Window Manager itself may attempt to do something with the window
- * until it receives DestroyNotify event.
- * SEE ALSO
- * ICCCM, Window
- * SOURCE
- */
-void
-wait_closedown( Window w )
-{
-#ifndef X_DISPLAY_MISSING
-	Display *dpy = get_default_asvisual()->dpy;
-
-    if(dpy)
-	{
-		if (w)
-		{
-			XSelectInput (dpy, w, ( StructureNotifyMask | 
-									ButtonPressMask|
-									ButtonReleaseMask));
-
-			while(w != None)
-  			{
-    			XEvent event ;
-
-		    	XNextEvent (dpy, &event);
-  				switch(event.type)
-				{
-	  				case ClientMessage:
-			    		if ((event.xclient.format != 32) ||
-	  			    		(event.xclient.data.l[0] != _XA_WM_DELETE_WINDOW))
-							break ;
-			  		case ButtonPress:
-						XDestroyWindow( dpy, w );
-						XFlush( dpy );
-						w = None ;
-						break ;
-				}
-	  		}
-		}
-    	XCloseDisplay (dpy);
-	}
-#endif
-}
-/**************/
diff -Naur libAfterImage-1.20/apps/common.h root/graf2d/asimage/src/libAfterImage/apps/common.h
--- libAfterImage-1.20/apps/common.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/common.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,16 +0,0 @@
-#ifndef AFTERIMAGE_COMMON_H_HEADER_INCLUDED
-#define AFTERIMAGE_COMMON_H_HEADER_INCLUDED
-
-extern Atom _XA_WM_DELETE_WINDOW;
-Window create_top_level_window( ASVisual *asv, Window root, int x, int y,
-	                            unsigned int width, unsigned int height,
-								unsigned int border_width,
-								unsigned long attr_mask,
-								XSetWindowAttributes *attr,
-								const char *app_class, const char *app_name );
-Pixmap set_window_background_and_free( Window w, Pixmap p );
-
-void wait_closedown( Window w );
-
-#endif
-
diff -Naur libAfterImage-1.20/apps/fore.xpm root/graf2d/asimage/src/libAfterImage/apps/fore.xpm
--- libAfterImage-1.20/apps/fore.xpm	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/fore.xpm	1970-01-01 01:00:00.000000000 +0100
@@ -1,348 +0,0 @@
-/* XPM */
-static char *17[] = {
-/* width height num_colors chars_per_pixel */
-"    96    96      245            2",
-/* colors */
-".. c #8c0e05",
-".# c #ec8e0c",
-".a c #cc5004",
-".b c #dc7204",
-".c c #d4ee52",
-".d c #e4f619",
-".e c #ac2e06",
-".f c #f4aa05",
-".g c #ec4e14",
-".h c #ec800c",
-".i c #f4e608",
-".j c #cc360c",
-".k c #dc5e0a",
-".l c #f4d606",
-".m c #f46e0c",
-".n c #ec5e0c",
-".o c #f4e62c",
-".p c #e4ee3e",
-".q c #dc4e0b",
-".r c #ec660c",
-".s c #f4f612",
-".t c #bc3f04",
-".u c #cc440a",
-".v c #ac2505",
-".w c #f4780c",
-".x c #f4f00b",
-".y c #d4f644",
-".z c #fcdc1d",
-".A c #f49409",
-".B c #bc3107",
-".C c #dc490b",
-".D c #ece209",
-".E c #dc570b",
-".F c #f4cf05",
-".G c #dcf12a",
-".H c #f4b406",
-".I c #fc800c",
-".J c #ccef69",
-".K c #fcbc0a",
-".L c #fc6913",
-".M c #dcf92a",
-".N c #9c1f04",
-".O c #f4711d",
-".P c #bc3706",
-".Q c #f4f026",
-".R c #cc4a0a",
-".S c #fc8c0b",
-".T c #f4e918",
-".U c #fc6214",
-".V c #e4f63f",
-".W c #ec681c",
-".X c #f4781c",
-".Y c #f4f018",
-".Z c #fca40b",
-".0 c #ecee27",
-".1 c #d45709",
-".2 c #ec7707",
-".3 c #fc9c0b",
-".4 c #e4670a",
-".5 c #f4f61f",
-".6 c #bc2704",
-".7 c #ec6014",
-".8 c #fce008",
-".9 c #ecf629",
-"#. c #9c1504",
-"## c #fcc809",
-"#a c #dcf240",
-"#b c #f4ae14",
-"#c c #f49214",
-"#d c #dc5715",
-"#e c #fc801c",
-"#f c #ec5a11",
-"#g c #fc710b",
-"#h c #e4f14e",
-"#i c #dc5014",
-"#j c #ac2a05",
-"#k c #fcc209",
-"#l c #ec700a",
-"#m c #f4860a",
-"#n c #fcd808",
-"#o c #f4680c",
-"#p c #d4450b",
-"#q c #fc780c",
-"#r c #fcd015",
-"#s c #fcb40a",
-"#t c #c43909",
-"#u c #cc4e14",
-"#v c #dc3e10",
-"#w c #ecc204",
-"#x c #bc460c",
-"#y c #dcf15c",
-"#z c #fcf026",
-"#A c #fc5a24",
-"#B c #e45f15",
-"#C c #dc4915",
-"#D c #e4f12a",
-"#E c #fc860b",
-"#F c #fc8c1c",
-"#G c #fca51d",
-"#H c #f45a11",
-"#I c #8c1604",
-"#J c #eced19",
-"#K c #fcac0b",
-"#L c #f4800b",
-"#M c #fce809",
-"#N c #cc3e09",
-"#O c #fcf70b",
-"#P c #c43e18",
-"#Q c #fcef0b",
-"#R c #d4f65c",
-"#S c #fc950b",
-"#T c #c43206",
-"#U c #f4e008",
-"#V c #e4580c",
-"#W c #fcd008",
-"#X c #d4f05f",
-"#Y c #fcbc14",
-"#Z c #e4f728",
-"#0 c #fce816",
-"#1 c #fcf017",
-"#2 c #fc9c14",
-"#3 c #f46216",
-"#4 c #fcc714",
-"#5 c #ec6f15",
-"#6 c #fcfe1c",
-"#7 c #ac360c",
-"#8 c #a42604",
-"#9 c #9c1a05",
-"a. c #fce21c",
-"a# c #ecf227",
-"aa c #d4f24f",
-"ab c #ecf213",
-"ac c #fc681d",
-"ad c #941204",
-"ae c #f48c0a",
-"af c #dced47",
-"ag c #ecf712",
-"ah c #f49c08",
-"ai c #fce926",
-"aj c #f4bc06",
-"ak c #b42608",
-"al c #dcf641",
-"am c #f4a408",
-"an c #fcf81c",
-"ao c #fc861c",
-"ap c #fcc214",
-"aq c #d44a0b",
-"ar c #b42a06",
-"as c #f4c205",
-"at c #d43e14",
-"au c #f4c805",
-"av c #d44f0b",
-"aw c #e46f09",
-"ax c #b42f08",
-"ay c #f4521c",
-"az c #e4600b",
-"aA c #f4600c",
-"aB c #ecf13d",
-"aC c #e4510b",
-"aD c #c43f09",
-"aE c #e44a0c",
-"aF c #a42005",
-"aG c #fc701d",
-"aH c #f4681d",
-"aI c #fc781c",
-"aJ c #fcac14",
-"aK c #fc9415",
-"aL c #e45814",
-"aM c #ecf254",
-"aN c #e45116",
-"aO c #d44f14",
-"aP c #e44618",
-"aQ c #8c1214",
-"aR c #cc3a14",
-"aS c #f4d614",
-"aT c #f46f14",
-"aU c #f4ea34",
-"aV c #ec6714",
-"aW c #cc4614",
-"aX c #ac2214",
-"aY c #f47814",
-"aZ c #dcf234",
-"a0 c #f4b214",
-"a1 c #fc8014",
-"a2 c #dcf634",
-"a3 c #bc3614",
-"a4 c #f4f034",
-"a5 c #fc8c14",
-"a6 c #fca414",
-"a7 c #ecee34",
-"a8 c #d45814",
-"a9 c #ec7a14",
-"b. c #e46814",
-"b# c #f4f62c",
-"ba c #bc2614",
-"bb c #fcdf14",
-"bc c #ecf734",
-"bd c #ec591c",
-"be c #fc7014",
-"bf c #fcd914",
-"bg c #f46814",
-"bh c #d44414",
-"bi c #fc7814",
-"bj c #fcb414",
-"bk c #c43714",
-"bl c #c44a0c",
-"bm c #e4f234",
-"bn c #f4561c",
-"bo c #941704",
-"bp c #f48014",
-"bq c #fcf614",
-"br c #c43014",
-"bs c #f4e014",
-"bt c #d4ee6c",
-"bu c #e4f634",
-"bv c #f48c14",
-"bw c #dcec54",
-"bx c #ecf61c",
-"by c #f49c14",
-"bz c #f4ba14",
-"bA c #dcf64c",
-"bB c #f4a414",
-"bC c #dcf655",
-"bD c #a41a04",
-"bE c #dcf250",
-"bF c #e4f21c",
-"bG c #cc4a14",
-"bH c #f48614",
-"bI c #fc8614",
-"bJ c #cc3e14",
-"bK c #ecf234",
-"bL c #ecf21c",
-"bM c #d44a14",
-"bN c #8c1204",
-"bO c #f4ae07",
-"bP c #f4ea07",
-"bQ c #cc3a09",
-"bR c #f4da07",
-"bS c #f4720c",
-"bT c #ec620c",
-"bU c #f4ea28",
-"bV c #e4f240",
-"bW c #dc520b",
-"bX c #ec6a0b",
-"bY c #f4fa10",
-/* pixels */
-"#W.K.Za5a1.Ia1.S.S#Sa6ahama6a6a6#KbO#s.Z.S.m#oaI.f#K#2a5#lazaz.7bSbSaT.7#VbWbWbWavaq.RaOaL#l#E#SamaK.I#g#qa1a1.waz.R#tbk.PaD.uaq.1bW.E.7.ObI#S.A.f#K.HbO#K#Ka6aKae#caK#K.K#####k.F#####W#W#n#W#4",
-".K#K#S.Sa1a1bIa5.S#Sa6.Z#K.Z.Z.3#K#K#K#KaK#q.w.Iam.Z#2bIbS#VaLaLaz.r#B.7.Eavavav.R.u#N#pavaz#L.SaJ#2.S.Ia1#Fa1#qazaq#t#t#t.u.uaO.EbWaL.7bea1aK.3#K#K#s#s#saJ.Z#Sa5.SaK.Z.K#W#n#W#n#n#r#W#n.l#W##",
-"#K#S.Sa1aIa1bIa5.S.3#K#s#s#K.Z#S.3.Z#K#KaK.Sae.3.Z.3aKa1bg#f.qaqav#i#d.E#iavaO#iaq.u#t.jbQavbXa1a6a6.3#SaKaKao#g#d.u.BbkaD.uaqav#V#B#f#3bga1.SaK.ZaJ#s.K.Kbj.Zah#E.Ia1#S#K#k.l#UbR#W#W#W#W.Fauaj",
-"#2a5.Ia1#ea1bI.S.3#Kap####.K#K#S.3.3.3.3#2aKam#s#K.Za5a1aH#f.qaq#C.q#ibW#ibWaNaLbW#p#N#t#T#NaLaG#S.3a6.Z#G#2ao#g.E#N.Bbk.uaqavbW.nbTbgbg.m#q#E#S.3#Kbj.K.K.K#sam.S.Ibea1#S.Kau#nau###Y.K#k.Kaj#K",
-"#2a5#EbIbIa5a5#S#K#kbf.8bf###K#S#S.S#SaK#2.Z#s###k#saKa1.L#3aLaNaNaCaL#Vaz.n#3#3#BaL#CbQ#T.jaq#B#LaKa6#KbO#Ga5#g#B#p#T#tbhbW.E#Vazbgbebia1.Ia5#2.Z#K#s.K#k#k.K#KahbIaI#ea5#K#s.K#s#Ka6a6aJ#s#s#K",
-"a6.3#2aKaKaK.3#2as#n#0#1#M##.Z.SbIa5a5a5a5a6##.8bf##.Z#EbiaHbgaVaA.r#l.w.w.wbibeaYaV#B.C#N#t#NbMaT#e#2aJ#sbOaK.IbTav#t#Naq.qbW#VbT#obi#Fa5#2a6aJ#s.K.Kasau###kaj#b#Ga5a5.3#K#K#K.3#SbIa5#2.Za6a6",
-"bj#KaJ.Z.Z.3a6aJ#rbb#Q#Q.8ap#2a1.Ia1bIbIa5#2##.8#M#W#s#Sa1bibibi#LbI#S.3.Z#2#S.Sa5.wbS#B#i.uaDaDaLaT#F.Z#s#sa6#SbS#V#p#paq.q.E.7#obSa1a5.3a6#sbj#k###W#W#W#W###k.K#s#K#K.K#k#k.K.3.Sa1.I.S.Z#K#K",
-".K.K#s#s#K#Kbj#Y#W.8#O#Q#n.KaKbe.m#qa1bia1.3#k.8#O.8.K.Za5.Ia1a1#2a6bjap#Y#Ya6.3#Sa5#eaT#Bav#NaDbJ#f.I.3#s#sbj#G#ebgaL#i#V#V.7aTacbSa1.A.3.f#s.K###W#n#n.8#n#n###W#####W.8#Q.8.za6aKa1.I#S#K#s.K",
-"auas#saJa6.3.Zbj#k#W.8#U#W#KbIaV.rbebibibiaKaJ#k#W###sa6#SbI.Sa5.S#S#s###n#W##.H.Zah#S#Ebi.7bW.uaDaq.7.S#s##.K#saK#mbS.n#V#V.4#5bibibI.S.3.Z.Z#Kaj.K#k#W#n#n#n#n#W###W#n#1.5.Q#J#nasbO#sas.F.F.l",
-"#W.K#s#2aK#S.3.Z.K###n.8##aJbpbT#BbSbi.I.IaK#K#saj#sa6#Sa5.IbIa5#FaK#K.H#k##.K.H.3.3.3aKa5bi.4.Eav.q#V.I.Z#k#k#Y.Z#2#LbSbT.n.7bga1a1a5#S.3am#s#s#s.Kas#####W#W#W#W#W#W.8bP.Y.5.Q#M#W###r.z#M#M.8",
-"#YaJ#2aKbI.Ia5aK.Z.K#W#W.K.3aT.q#V#5bI#S#S.3.Z.Z#K.Z#S#E.I#qa1a5aK#2#K#s.K.K#s.Z#2.3.3.Z#2aKbIa9.r#VaAbi.3.K###W#k#s.3.Sbi#obgaca1bIa5#2.Z#K#s#k###########k#####n#W#n.8#M.Y.x#1.8#n#Wbf#0#0.8#r",
-"a6aKbIa1aIbibi.I#S#K#####K.S#B#p.CaV.S.ZaJama6.Z#2#2a5bI#q.Ia1a5.Z#K#k#W#n#r.K#K#2.3.Z#K#KaJ#2aKa5.w.Lbia5#K#r.8#n##.K.ZaKbibeac#ga1#Fa5.3.Z#sap#Wbf#n#n#W#######n#n#n.8#Q.x#Q#1.Fauas#W#W##.K#K",
-"bI#LbibiaGbebgaV.I.3bj#Ya6a1#VbQ#pazbvaJ#YbjaJ#Ka6a6#2#S.S.S#SaK#s##.8#0#1a.#n#k.Z.Z.Z.Z#s#s#sbja6#2a5bIa5#K###M#M.8#W#kaJa5#qbibebe#ea1a5aKaJbj###n#M#1#M#U#n#W.l#n.8#M#Q.x#1#Q#W#k#s#K.Ham.A.S",
-"#L.Ia1#ebe.7#V.EbSa5aJaJ.3.w#Vatbhaz#ma6#Y#Y.K#k#s.K.K#s#K#Kbj#s.F.8#M.Y.s#1#0.8.K#s.Z.Z#K.K#k###k.K#s.Z.3.Z###M#1#1.8bf#4.Z#S.Ibibibi#ea1.S#S.Z#w.F.8#O#O#Q.i#U#W#n#n#M#1.Y.Y.T.8#k.Z#S#Sae.I#e",
-"#EbIbIa1biaz.qaqbTbp#2a6#S#qaz.q#C#V#l.3aJ#Y###W#W#n#n#n#n#W#W#r.8#M.xabbxbx.Y.T#n###K.Za6bj###n.8#n#n###s#K###n.5.Y.Y#0bb###K.3aKa5#Ea1a5aK.3.Z.H#k#n#M#O.x#Q.T#n#W#nbb.Y.Q.9.Q#M###2a5a1#qa1#e",
-"a5#SaKa5.w.kav.a#faY#2#2#S.IaVaLaNaC.r.Sa6.K#W#nbP#Q#O#1#M.8#n#n.8#M#1bx.9.9.Q.T#M#W#K#2#2#K#W.8#M#QbP.8#4#Y###na#bLbx.s#1bfap#Y#K.3#SaKaKa6.Z#Kbj.K#Wa..Y#1#1#0#n#n#WbR#Ja#bc.0#Q##.Za1a1bia1bI",
-"amah#SaKa1bTaq#P.a.4#E#S#Ebi#lbTa8av.q#f#e#2#s###n#M#M#Q#0#n#W#W#n#M#za##DbLa#.Y.x.8#Wbj.3am#s###M#1.x#JbP#M.8bRag#DbmbVaB.0#1#Q#Waj.f#KaJ#K.Hajasau#W.8#0#1.Qa##Q#n####bbbUbL#Z#M#k.3a5a1.S.3.Z",
-".K#Ka6aKa1.4.ubkaDaza1bI.IbiaTbg.1.u#N.C.7#L.3#K###W#n.8#n#W###k.8#0.Ya##Dbma#a#.s#0#r.Kam.Z#K#k.8#M.YbL.T#0#0#M.Y.YbmbV#abVa#.Y#nau#s#s#Y.K#k##auau#n.8#0#1.QbL#1.8#####W.T.Q.Y#M.Ka6aK.S.Z#K#s",
-"#W.K#K#2#FbX.u.6.P.EbS.I#qaV.7aV#i#p.P#t.u.4#LaKaJ#s###W.F.F####bRbP.QbVbV.V.VaBa#.Ya.###sam.Z#s#W.i.Q.9a#a4.QbK.Ya#bVbEbEbA#aal.8#W#k###4###W#n#n#n.8.8#Q#1.9a#.Y#0#nauaubs#1.Q.8#k.Za6.Z#s###W",
-"#n###s#2a5#5bM.6.Baqbgbe#o#VbW.q#C#N.Bax.Pav#3aIaK.Z###n#nbRbfbf.i.TbKbVbEbEbCbEbK.Q#Q#n.K#K#K#K#Wbb.Qa#bK.pbVbVa#aB#a#y#RaaalbV#M.8#W#W#W#W#n.8.8.8.8#M#M.Y.Ya#.9#zbbau.F.8#1#1.8as#KaJ#s##.8#M",
-".8#W#s.Za5bS#pakar.u.7be#f#p#t.PbQ#Taxax#t.u#f.U#c#K#W.8.Y.Qa4ai.T.QaBbEbE#X#y.c.pa##1#M#W.K#K#s###n#zbcbm.p#hafalbE#R#R#XbEbV.0#0#U.8.8.8.8#M.8#Q#M#M#Q#Q.Y.0.0bF#1#1#n#U#Man#1#nas#Kbj.K#W#Q#Q",
-".8#W#s.3a5bS#p.6akaD#V#3aL#tar.vararaxbkaDaq#faGamapa..Q#Zbubca7a#aB.Vaf#ybE#X.c.pbm.Y#Q.8##.K#s###n.Ya#a#.p.p#abEbA#R#X#R#ha7.Q.Y#1.T#M#M#M#Q#Q#Q#Q#Q#Q#1.Ya#.0.G.5#1#0.D.Q.Qa##M###sbj.K#W#M#Q",
-"#n#W#s.3a5aY#i.6axaD#VbTaNbkaF#9.N#8ax#t.u.E.wbI#s#rai.9#a.V.V#Dbmbc#hbEbE#ybEaa#h.p.9.Y#0#n######.8.T.Ya#.QbK.paBbVbEbEbE#abVbK.Q.Q.Y#1#Q#Qbq.x#1.Y#Q.x.Y.Y.Q.0#Da#.Q#za#bV#a#h#M.F#sbj#s#W#n.8",
-"#W#k#K.3a5aI#d#t.PaD.E.n#i.B.Nbo#Ibo.v.P#p.k#q#2#k#n#z#DaZalbVbmbmbVbVbEbwbCbC#a#hbV#DbY#1a.#W###W.8#Qab.s.Q.Q.0aUa7bVbEbEbEbVbV.0.0.Y.Y.x.s.Y.Y.Y#1.Y#1#1.Q#J#Dbua7a7a4aBaf.c#y#1#W.K#K#s#k#nbf",
-".KaJ.3#S.SbpbT.C#N.q#V#Vav#taF....ad.N#jaD.E.wao#s#kbf#M.sbYbY.5bLa##D#aaa.c.p.Q#D#D.Q.Q#1#Q.8#n#Q.x.Ybx.s.s#M#M#M#0.Qa#bV#abEbEa7#Dabab.s.Y#1.x.x.Y.x#1.Y.Q.0.0.d.0aibLal.J.Jal#Q.F.H#K#K.H.K#k",
-"#s#K#S.SaKbI#laCav#Vaz#V.E.u#j#.....#..v.PaqbTbi.A#K##bR.ibP.Y.xbL.Ya#bV#aalbm.0bLa#.Q.Q#Q#Q#M#M#M.Y.Q.Qab#Q.8.8.8.8.Ya#bmbmbVbV.pbmbL.x.Y#1.Y#Q.x.x#1.Y.T.YbL#J.9.0aibL#abt#Xbu#Mau#K#KbO.K###k",
-"#s.3aKa5a5a5a1bX.7bT#V#V#dbhaxaFadadboaFaxaD.E#o#L.3bj#r.8#0#1#0#1.Y.Ya#alal#Da#.s.Y.Y.T#Q#Q#Q#0.Y.Qa7a#.Q.i.8#n.8.8.T.YbcbVbVbV.pbVbL.Y.x#Q#Q#Q#Q#Q#Q.Y#Q.Y#Jaba#.Qai.Qal#ybEa7#W.K#Kbj.K#k##as",
-"#K.Za5a1a5aK#Fbp.OaTaz#V.q.u.B#8#9#.bD.v.BaDbW.7.I#2bj#r.8#M#0#M.8.8#0.Q.9bu#Z#J#Q#1.T#1.s.s.5.Y.p.paBaBbK.Q#0#0#M#0.QaBbV#abV#a.p.pbL.Y#1#M#Q#Q.x#Q#Q#Q#1#Q.Y.s.Q#z#1#J#ZbVa7.o#Y#K.Zbj#k#n#W##",
-".Ka6a5a1a1a5aK.S#eaI.mazav#N.Bax.vaF.var.B.u#iaHbpaKbj###W.8.8.8#W#W#n#0.Qa#.Y.Y#M.8#M#Q#Q.s.Y.0#a#a#Ral.V.9.Q#za7aB#h#y#y#XbEbC#hbm.Y#0.8.8#M#M#M#M#M#M#M#Q#Q.x#1#Q#M#J#Z.9.T#raJ.3#K#Y#W.8bf##",
-"#ka6#Fbi#qbI#S#2#ebiaTaz.qaD.Bax#jarax.B#P.u#BaH#EaK#K.K#####W########bf#0.Q.Y#Q#n#nbb#M#Q#1ab.0.yaaaabE#a#Z#D.0bV#h#X#X.J#XbEbEbV.0.Y.8.8#W#n.8#n.8#n.8.8#M#M#Q#M#Q#Q.Ybxab.8.K.3.3aJ###n#M#M#W",
-"###Ka5bebSa1#S#Sao#qbXbTbW.u.B.Baxax.Bbk.uavaz#la1a5a6#K.K.K#s#sbj#s#k##bb#0#M.8###W#n.8#Q#Q.Y.0#abEbEbEbVbm#D#D#a.caa#X#XafbV.V#Da##0.8#W###W#W#W#W#W#W#n#n.8.8#U#M#M.Y.9.x#WaJ.3a6.K#W.8#M#M#r",
-"###s#FaT#o.Ia5.3#Fbi#l#o#B.q#t.B.B.BbkaD#pavaz.m#ga1#S.3.Z.ZaJ#GaJ#K#s.K#W#n#n#n#k#####n#M#Q#1.Q.p#haM#hbVbca#a#alalbCbC#ybV.9.Q#Z.Q#M#n#W#k#k#######W###W#W#n.l#n#M#MaUa4#1###2.3a6#Y#n#U#M#M#W",
-"#k#K#SbS.7aHa1.S#eaG.7.7bT.naq#tax.P#t.u#pav#VbTbXbea1.S#S.3#2.Za6.Z#K#K#sap#k.K#K#saj#n.8.ibP#1.MaZ.p.p.0.sbLbL.M#D#D.Q.Y.Y.xab.s#Q.8#n#W#k.K.K#kaj.K.K#k.Kau###n#0.pa2.9#0.K.Z.f#s###W#n.8#n#W",
-"#k#s.3aYbgbgbi#E.I#l.7#B.r.razavaD.uaD#N#pbW#V.nbgbSbibIa5aK#S.3aK#2.Z.Z#K#s.K#s#K.f#s#W.8#M.Y#1#D#Da7bU.T.x#Q#0.Y.Y.TbsbsbbbR#U.i.8.8.8#n#W#W#4###k#s.K#s.K.K##.8.Tbma2.9#M.K#K#K.K###W#n#n#W#W",
-"###s.3bIaTaTbi.S.I#laz#V.7aVbg#5.nbW.C#p.qaNaL.n.7bgbSbi.I.IbIbI#E.SaK.3.Z#K#sbO.3.3.Z.K.8#Q.xaga#.YbU#M#M.8.8#n.8#W#W#4#k#Yas.K.F.F.8.8#QbPbf#r.K#s#K.Z#K#K#s#k#M.Y.G.G.Ybb.K#b#s#k###W#W#n#W##",
-"##.KaJ#F#eaI.S#S.S.wazaCaN#3bebiaIbebTaz#VaL#f.7.7bgbgaTbebe#gbi#qa1a5a5aKa6.Z.Za5a5#S#s#r#1.sbF.0.Q#Q#M.8#n####.K#s#s#K.Z#Ka6#K#s#k#W#Qan.5#0#n#k#K.Z.3#S.Z#s#Y.i.5.9.9#0#W#s#K.K#k#W#W#W#W#W##",
-"#k.K#KaK#F#F.3#K.Z.SbSaL.g#f.L#qa1bIa1aYaVaV.7bd.7.7aV#3aA#3.L.U.L#qbibIa5aK#S#Sa1a1#E#2###0an.d.0.Q#1#M#n###sbO#2#2.3.Z.3.Z#2.Za6#K#4a.anbY#1.8.K#s#Sa5a5aKa6#Ya.#1#1a.#n.K#s#s.K#####W#n#W#W##",
-"#k.K#K.Z#2a6bj#kapbj.A.w.7bgbe.I.S#SaKaK#L#lbT#fbTaz.7#VaL#V#f.naAacbebia1a5a5a5a1a1a1#Sbjbf#1bx#D#J#1.8##bjambyaK#2#2#2#2.3#2#Sa5aKaJ###0.Y.x.8#Y#K.Sa1#q.Iah.Zau#r#4bj#K.3.3#K#s.K#W#W#n#n#W#W",
-"#kap#s#K.Z#s###n#0.z.K.Za5#e#E.S.3.ZaJ.Z#2.IaT.nazaz.EbWav.CbW.EaL.7bgaT#gbia1a1a1#ea1aK#K###0.0.Q.Y#M#W.Ka6#2.3amamaJ#KaJ.3#S.SaI.I.S#s#W#0#M#M.K#K.Sbibe#L.A#K#K.Z.A#Lbi#qae.Z#s#k###W#n#n#n##",
-"#4#k#s#K.fbz#W#Mag#Q#M##aJ#2#S.3#KaJ#sbja6aKbi#o.k.EbWavaq.RavavbW#fbT.7bX#gbi#qa1aoao.S.3#kbb.T.Y.Y.8###K#2#S#S#s.K.K.Kbja6aKbHbg#g.w.3#k.8#M#M###KaK#e#e#Fa6#Y.3.S.2.7acaGa1#G#s#Y###W#n.8#W#W",
-"###k.K#sajasbR#Mag#J#0a.#n#W#kaj###Wauas.K.ZaoaHbW.Eaq.u#N#t#t.ubWavbWaLazbT.mbibv#S.3#Kaj#W#UbP#Q.8##.HbObOa0#k.D.l##.K#K.ZaKaIaVaz.4#L.3#Y#n.i###s.Z.f.Hau#Y#s.3.I#oaH#3aT#E.3#s#k#W#n#n#n#n.F",
-"#W#k.K.K.KaubR#Mag.Y.Q#1#0#M.8bf.8a..z#n#W#saKaY#V#Vaq#N#t.P.P.u.u.u.R.qbW#V#obia5.3#s###Wa.#0.YbPbRau#sbj#s#k#W#Q#n###s#K#2#FaIbT.E.E.rbI.Z##bR#n##.K.K#4#4ap#s#S#LbSaTaG.w.S.Z.K#k#W#n#n#n#W#W",
-"####.K#kap###n#Q#J.Y.Y.Yan#1#1#1#1an#z#0#n#k.3.I.rbTav#t.Baxax.PaD#taD.uaq.EaVbeaKa6#4bfbU.0a#.0.x#Uasbj#K#s###n#M#n#Y#K.3#SbIbi#3.E.R.qaVa5#K##bR#W####ap#YaJ.3bI#qbiaIa1.S.3#K.K###n#n#n#n#n##",
-"######ap###W#n#M#Q.Y.Q.Yab.x.x.Ya#a#bK#J.8#W.Z.SaYbSbW.Barararax.B.B.Bbk.u.qbgbi#S#Kbf.Ybxbca#.0.Ybs#4#K#K#s#k#W#n##aJ#S#S#Sa5bibg.E#Nat#iaT#S#sau#k.K#s.Z#S#L.2.O#5#qa1.S#S.Z#K.K###n.8.8.8#W#W",
-"#W##########.F.8#Q#1#zbU.Y.Y.s#1#DbmbV.9#0#W#KaKa1#e#B.P.v.v.v#jaxarar.Bbk.qaVbi.Z#k.8.Ybx.9b#bU#Q#W.K#K.Z.Z#sas.K#KaKa5bI#Ea1a1bg.E.uaR#C.n#E.Z#s#sbj#2#E.m.n#V.k.7aT#q.S.3.Z#K#Y#4bf.8.8#n#n#W",
-"##########au#n#n#1#zbUa4.Q.Y.Y#1.0bKbK.Qbs#k#2ao#E#F#5.P.vaFaF#8akakaX.BaDavbX.I#K#k#nbP.x.Y.T#n#W.K#K.Z.Z#Ka0bz#K.3a1bia1a1.I.IbSbT.E.q.gbT.I#SaJaJa6aKbe#HaEbhaO#ibT#g.I#S.3.Zbj#4#n.8#M.8#n#W",
-"#############n.8.YbUa7a7bmbL.Y#1.Y.Y.0.Qbs#s.Sbi.SaK.O.t#8.NaFaF.v.v.v.Bbk.EbS.S#K.K###n#nbf#W##.Z.3.3.3aJ#s.K.K#K.SbiaGaI#q#La1.I.w#laVaT#q#E.3.Za6.Za5#q#f#paD.u.RaL.7bi#E#2.ZaJ#k#n.8#M#M#n#W",
-"###########W#n.8bx#ZbVbV.V.9.Y.Y#Q#0.Y#1#n#s#Ebe.SaKbpaDaF#9aF.N.v.vaka3.u.k#q#Fbj#s#k###W##.K#saKa5#Sa6aJ.K.K##aJa5biacbea1a1a5a5a5bIbIa1.IaK#2.3a6amaK.IaAaO#xaD.u#i#fbga1aK.3#K#Y#n.8bP#M.8#W",
-"#W###k#k#####U#1#D.pafaf#abK.Q.xbP.i#n##bj.3.I.m.wbIa1.aaFad#9aF.N.e.P.uavbX.IaK.3#K.Kas#W#n#r.H.3#S#S.Z#Y###W.F#K#SbS#3.7#5a1#S.S#S#S#S.3#2#2#S.3#SaK#Ebi.7av#taD.P#N.qbgbi#S.3a6#Kau#U#Q#Q#UbR",
-"#W###k.K#k.F.8#Q#D#Dbubmbmb#.YbP#M#n.F#k#K#S#q#gbS#Fa5.1.vbo#..NaF.e.P.Raz.m.I#Ea5.3.K##.8#0#n##.Z.3.Z#K#Y#W#n#n#K#SbS#3.7aV.IaK#S.3.3.3aK.3aK#SaK.S#EbiaTazaqaD.P.P#N.CazbS#EaK.ZbOaj.l#M#Q.8#n",
-"#W#k.K.K.K#W.8#Qa#.Q.9a#.Y.Q#1.8#n#WajbO.3a5bibeaza1#Faz.e#.ad#9aF.v.B#p.E.r.w#q.Sa6ap#n#Q#O#M#n#s#K#K.K#4#r#n#n#s#S.w.7aL.r.wa5.3#2#2#2#S#2#S#SbIa1#q.m.7#V#p#N.P.P#t#pbW.rbpaK#K#K.K###n#n.8.8",
-"#4.K#s.K.K##.8#M.Y.Y.Y.x#Q#Ma.#nap.K#K.ZaKbIbe.L.ka1#F#5.t#9#.aFaXaXba#Tat#VaV.X.3bjbf.YbY#O#M#n.K.K.K.K##bf#n#nbj.3bS.naLaz.w.S#2a6a6.3aK#SaKa5a1bibg.n#VbMaW#P.P.PbQ.uaq.EbS#F#K#K#s.K###W#n#n",
-"#k#s#s#s.K###W#n#M#M#M#U.8#n#W##bj#K.Z#2a5#ebebg#Bbi#Fbi.R.vaFaFakakbr.j#p.k.X#F.K#n#MbY.s.i#W###s.K.K#k###Wbf#W#s.3aY.7aC#B#la1.3a6#2#2#SaKa5.S#ebi#oaL.C#p.uaD#t#t#t#N#pbWbX#e.Z#sbj#s#Y####au",
-"bj#s#KaJ#s.K###W.8.8.8#W####.K#sa6a6aKaK#Fa1aGbT#BaYa5.I.EaxbDbD.e#taq#V#o.I.3#K#W#n#M#M#n#4bjaJ#K.K.Kau###W#W##.K.3#q.7aL.Ebga1.3#2#2#2.SaKa5a5#ebibg#V.C.u#N#NaDaD#N#N.uav.7be.3aJbj#s.K.K##.K",
-"#K#Ka6a6#K#K#s###n#n#W.K.K#s#K.Z#2#SaKa5a1bibgbT#d#l.I.S#laDaFbD.e.P.CbT#q.S.Z#s.K#k#k#Y#s#2aK#F.Z#K#Y.K###W#Wau#s.Za1.7aN#V#5bi.3.3a6#S.S.SbI.Sa1bibg#V.q#p.uaD.u#N.uaW#p.q#Vbg.Sa6bj.K.K#k.K#s",
-"#Ka6.Za6.3.Zbjap#n#W#4.KaJaJa6.ZaKaK.S#Ea1biaV.4#VbX.SaK#ea8.P.vaF.vbk#C#BaY.#.A.Z#2.3#S.S.S.Ia1#SaJ.K#k#k#W###k.K.3a1#3aL.Ebgbi.3.3#2aK.S#EbI.IbI.w#5azbWaq#p.R.u.u.ubMbM.q#V.7#L#2.Kasau#k#saJ",
-"#s.Z#SaK.I.A.K#n#nauaj#Kah.3a6a6ahaKa1aIaIbg.4bT.EbX#E#S#S.w.1#tarax#T#pbWbg#ga1.S#E.IbibeaTbSaY#S.3#s#k###k#k#k#s.3#mbg#f#faVbi.A.3.ZaKa1bia1.I.Ia1.w.r#V.Eaq.ubl.Rav#i.E.E.E.4bS.Sbj###W##.K#s",
-"a0.3#SbI#mah#W.8#n#k#K.3#S.3a6amam.S.IbebeaVbTaz.EbX.I#SaK.Sa9.4#Bb.b.#5#Lbv#S.3.Z#S.Sa1#q.Lbebi.A.Z#s#k#k#k.Kap#s.ZbIaTaA.nbg.X.S.3.3aKa1bibia1.Ia1bi.mbT#d.q#p.R.uav#i.E.Eaz.r.m.SaJ#k#W#W###s",
-".H.Z.Sbi#E#K.8#M###K#S.S.I#S.ZbO.Z.A#q#gbgaV#V#V#V.rbia5#2#2#2#2aK#S.3.Z.Z#sbj.KbjaJ#2#Fbi#g#gbi#S.Z#s###kas.K.K#Ya6a5be#3.7bgaYa5.3#2aKa1bebebia1a1a1bi#o.7#V.qaqav.q.E.n#fbT.L.L.I.3.K#W#W#W#k",
-".Ka6#F#qaeap#M.ibj#S.Ibebia5#K.HaJae.w#o.7#B#VaC#f.7bS#ea5#2a6#K#K#K#s.H#s#s#saJ#sa6#2aKa1.I.Ia5.3a6.K#k###k.K#s.K.ZaKa1bgbT#obea5aK#2aKbi.LbeaG.IbIa1a1bibS.7#VaC#VazbXaTbg.L#3.L#qaK#s##bf#n.F",
-"#ka6#F#Eam.z#0bRaK.w.L.U.LbIa6.Ka6.SbSbT.7#daNaNaC#f.WbS#e#S.3.ZaJ#Y.K.K#s#K.Z#S#S#Sa5#F#Fa5a5#2#2aJ.K####.K.K#s#s#KaKa1#gbg#obSbI#S#2.S#q.rbgbg#qa1bI#Ea1a1be#3#3bgaYa1a5a1bi#gbebi.S.Zapbf#n.l",
-"#k#KaK#2bz#0#0#ka1.raA.U.LbiaK#GaK.I#o#f#daOav.C.qbW.7aHbSaY.I#S#2aJbj.K#saJ#2.S.I#g#qa1bIa5bybBa6bj.K####.K#s#s#s.Z.3bIaY#obgbe.I.S.3#S.wbTbTbg#qa1a5.S.SbIaIbS.Lbia5#Sa6a6aK#LbibIa5.Z#s#W#n.l",
-"###K.3#s.l#z#r#2aV#VbT.LbgaTbiaoa1bS.7#Vav.u.ubh#uavaLaL.n.7bg.O#m#2#s.K.K#YaJaKbe#o#o#oa1a5aK.3.Z#K.K#k#k#k#s#s#s.Z#2a5bibe#obe.I#Sa6#2#L#oaVbga1bIaK#S#Sa5bIbiaGa1#S#K#s#YaJ.3a5a5aK.3#K#k#W#n",
-"#W#s.Zap#U#1#Y.h#faC.raG.m.raVaH#l#o#faN.u#xaD.u.RaObWaCaCaCbdbd.I#2#s#k###4bjamaI#o#VaAbea1aK#Sah.Z#s#k#k.K.K#K#s#K#2aKa1be.Lbe.S#2aJa6a5aYaHaT#e#FaK.3.3aK#Ea1bi.IahbO#k#r#4#s#Fa5aK#S#K.K#W#n",
-"###k.Haj.8bfahazaq#V.mbibgbWaqaOavbW#iavaD#t.P.PaDaD.R#uaO.u.qaA.A#K#k##au#k.KbO.I.4.EaL.7#qa1a5.S#S.Z.H.K.K#s#s#K#K.Z#2#S.S#ma1am.K###k.Z#E#qbiaK.3#K.Z.3aKa1#q#gbi#e#2.K#W.8bfajam#S#2aJbz####",
-"#W#k.Haj#n#WaeaC#d.7bebi.n.u#taD.u.R.R.u#t.P.B.PaD.u.R#daOavaz#q#K#s#4#####k.K#Ka1#lbWbW.7bSa1#E.S.Saha6#s#s#s#K#K#K#K.Z.3#SaK#2.K#W.8#n.K.ZaKaK.Z#K#s#s#2a5.IbS.mbeaI#S#K#W.8#0###s.3#2aJ#Y####",
-"#W###s.K##.K#L.qaLaVbibe.E#tarar.PaDaDaD#t.B.P.P.u.u.qaN#VbT.w#S.K###W#####Y#s.ZbIaTbW#i#VbX#qa1.I#E.S#S#2#K#s#s#K#KbjaJ#K#KaJbjaS#0#1#M#W#s#KaJ.K#####s.Z#Fbi.mbX#obea1.3#k.8#1#0#r#K.3.Z#Y#k##",
-"#Wap#s#s#k#K#laP.EbTbe#o.q.B.v.vax.B#taD#t.P#taDbhaq#VaAbg.w#S#K#Wbf#W#W#k#Ya6#2bIaV.qaqbWbTaYa1#ebibia1.SaKa6aJ#Kbjbjbj#s.K#Yap#n.x#O#1#n#k.K.K#W#n#W.K#2#e#g#oaTaV.L#q.S#K#n#1.5a.###K.Z.K#k##",
-"###kaJ#s.K.Z#laPbWbT.m.7.uaraFaF.vax.P#t#t#t#N.uaO.E#obe#E#2#s##.8.8#n#W.K#sa6aK#qaVav.u.qaz.mbiaIbibibebi.IaKahaJaJbj#s#s.K#k##bb#M#Q#Q#n#####4.8#n#W#sa5bibg.rbgaVbg.L#q#S##bPab.Ybf#k#K#s#k##",
-"au.K#K#s.Kamaw#C.E.raT#BaD.v#.#9aFarax#taD.uaqbW#BbX.I.Sa6#s###n#M.8#n###kbj#2a5#qbTaqaW.R#VbgaIbiaIbebebebibpa5#2#2a6#K#s.K.K###W.8#M#n##.K.K#k.8#n##.Za1bgaA.n#3bTaz#obe#E#sa.bF.Y#z#n.K.K.K##",
-"##.KaJ#K#k#K.b#CaCaVbgaL.BbD#.bo.N.vax.PaD#p#V.7bg.IaK#K.K#4.8#M#Q#UbR#W#k#K.3.S#g.naq.u#p.EbTbe#q#gbeacbgbSbibi#E.S#2a6#K#s.K#k#W#n#n#Waj#s#s#s#W#4#sa5bS#3.7.4.Uaz.4aVacbi.Z#W.Q.0a#.T#W.K.Kap",
-"##.KaJbj#k.f.baqbWaVbg.q.B#9adbobDaFax#t.uav.7aHbia5.Z#s###n#M#O#Q#M#n#W#k#K#S#mbe.nbh.u.ubW.7.L#g#g.ObS.Wbgbe#g.w#EaK.3aJ#s.K#k#W#n#n#Waj#Ka0#Y.K#s.Z#m#3aAbgaTacbXawb.#3.L#S#k#za##Za#bb#k.Kap",
-"#w#s#sau#n#K.m#C#V.n.7avax#...bNboaF#j.P.u.EbT#gae.3.HaubR.i#M#M#M.8.l##.K#K#Sa1#o#V.RaDbJavbTaT#g#gbebeaT#gbgbe.w.w#E#S.3#s##.F.x#M.8#W.K#s.Z.Z#K.3bIaT.n.7bXbS#lbXbgacbgbX#m#G.8#z.p#D.YaS.K.K",
-"au#s#s.F.8#s#l#C.E.7bg.E.P#9bN#Ibo#9#8ax#t.uaCbg#q.S.Z.K##.8#M#M#n#n.F##.K#KaKaY.r#Vaq#NaDav.7#obebSbeaT#gaT#oaT#5aY#q.I.S.3.K###M#M.8#W.K#K.3#S#S#m.w#oaVbgaYa1.IaYbeaG#obXbpaK.F#z.p.Ga#.8##.K",
-"#w#s.KbR#0.KbS.CaL.7aV#i.PbD....adbo#9aF#j.B.uaL.UaG#F#2#s###n#U#W#W###k#s#K.SaY#o#V.RaDbJaq#VbgbSbebibebebgbg#o.r.rbg#obSae.Z#Y.8#M#M#n.Kam.Sa1a1.w#o.7bgbia1bIa5bIa1aIbi#o.wa1aubsbc.G.0#0#W#k",
-"aj#Y#kbs#1#k.hbWaL.7aV#V#taFadbN....adaFaraDaO.kbSbia5#2.Z.K#k###k#k#k.K#s.ZbIaT.n.EbhaDaDbG#VaVaGbeaGaGbgbg.rbgaz.7#3.7bT.w#S#K#W#W#n#W#s.3a1aIaGacbgaTbia1a5a5.S.Sa5bIa1#qbea1.H.zb##abm#z#naj",
-"bz#sap#0an#4#L#V#BaVbg.n.uak#9adaQadadarblaz.2#Eama6aJ#Kbj#s#s#K#sbj.K#s#s.3.Ibg#VbW.uaD#t.uaL.7aTbeaTaHbg.7bT.7#f.7#3aHaT#L#S.Z.K#####k#K.SbiaGacacbg.w#Ea5#S#S.S#Sa5aKbIa1bibiah#r.Qal.p#z#Maj",
-"#saJ#Y.D#6#W.S.7aL.r.mbTav.BaF#.adadaF#taz#q.S.3#Y###W#W#k#sa6#2#2aJaJ#s#K.3a1bg#VbW.u#t#t.ubW#fbgbgbgbg.7.n.7.n.naHaT#ea5#S.Z#s.K#s#s#K#S.Ibe.L#3bg.w#E#S.3.3aK#SaK.3#2#SbIbibeaK.K.Y.Vaf.Q#Mau",
-"#K#K#s.TbY#r#S#o.7bX#g.m.E#taraFboaF.P.CaVbi.S#S#Kap#n#n.F.K.Za5.SaKa6.Z#K.3bi#3bW.q.u#t.P#taq.E.7.7.7#VazaL.7.7.7aTa1aK.Z.K#k##.KaJ.Za5a5a1#gbXbgbS.S.3#K.Za6.3#2#2.Za6#2aKa1bi#e#s.iaMaf.5#M#4",
-".Za6#s.DbY#W#Sbe.Wbea1#q#3aO.Pax.e.PaqbdaHaTa1a5aK#s#W#M#M##a6a5.I.S#2.Z.ZaKa1#3aN#i.u#t.B.P#p.q.n.n.n#V#V#VaL.7aHbe.S.Z.K#W#nbR.K#KaKa1#ebi.wbSbSa1#2aJ#s#K#K#2aK#2.Z.Za6#2a5#eaI.Z#UaMbw.Y#Q#r",
-"aJ.3am##bf#kah#qbibi#qbibSazaq.u#N.uav.E.7#o#qa1.3.Z#s###n#W.Z.IbS.w.I#S.Z#2a1#3bWav.uaD#t.P#taW.1av.E.Eaz.EaL.7.4.w.I.Z##.8.8#r#s.Z#Sa1aIbebi#q.I.3#s###k.K.Z.3#S#S.3#K#s#K#S.IaG#S#WbUal.M.T##",
-"a6ah.Z.K###s#maGaIbibi#qbSaV#Vaq.CbW.1#BbTbe.Ia5.3.3#s###W###KaebS#qa1.S.3#Sa1aA.EbW#p.u#t.P#t.u.Ravav.E.EbW.EaL.4aT#e.3.K#W#W#k#Kah#Ebibibi#qbI.S.Z#k#####s.Z.3#S#2.3.f#s#s#2a1aG#S#kaUala2#0#r",
-"#K.Z.Z#s#s.AbS#AbibibIbI.IbSaV.7.naz.Eazbg#ga5#S#2#2#K.K#####K.SbSbia1#S.3aK.Ibg#Vav.uaD#t.B#t#P.u.u.Ravavavav.q#VaVaI.S.Z#s#K#G#S#E#qbibebia1a5.Zbj#r#W#k#s.Z#SaKaK.Z#K.K#s#2a5aG#E.Ka..V#Z.Y#W",
-"#k.K.K###saeaAay.m.Ia5a5.Sa1biaTbgaVazbT.La1aKa6.3a6.Z#K.K.K#K.3a1a1#Fa5#2#2bIbS#Vaq#paD#t.B.P.PaD.u.uaqav#p#p.q.q.7aGa1.Sa5a5bpbibSbe.Lbe#qa5aK#s#Y#W#W#k#K.3a5#S.3a6#K.K.Ka6a5#g.I#K.z.9#Z.Qbb",
-"#n.8.8bf#k.3.2#3.2#E#2.Z#2aKa5a1.L.r.raVbi.I.3.ZaJa6a6.Z#K#s#K.3a5#Fa5aK.3#2bIaIaL.q.u#NaDbk.P.PaDaD.u.u.u.u.uavaCaVbebibebgbT.k.7.7aA#3bgbS#EaK#s#k#W##.K#K.3a5#SaK.3#K.K.Ka6aKbebS#S#r.Q.9.Qa.",
-"#M.x.Y#1#W#K.Sbp#L.3a6aJaJaJaKbI#g#obgbebea5.3#K#KaJ.Z.3.Z#K#Ka6.3aKaK#S.3#SbIaY#Vav.u#NaD#t.P.B.P#t#taDbQaD#pbW.rbibI#qaAaE#paD.C#iaN.7.r.m.IaK#K.K###k#s.Z#2a5#S#2.3#s.K.Ka6#Sbe#oa5#4.Ya#a#.Y",
-".Y.Ybx#1#W#s.3aK.3.ZaJ#s#KaJ#2a5#gbeaTbeaGbI.3#s#s#K#2#S.3.3.Z#2#K.Za6.3.3.3a5biaz.q.u.u.uaD.P.P.P.Pbk#t#t#NavaLa1a5#S.I.n#v#T.eaD.u#iaLbTbX#qa5#K#s.K.K#K.Z#SaKaKaK.Z#K.K#k#K#SbibgaY.K#0a#a#.Y",
-"#z.0a#.i###s.3#S.Z#K#sbO#KaJaK.IbibiaGaGbe.I.3#s.K#sa6#S#S.3.Z#2#s#sa6.Z.3.3#FaIbg#VbWavaOaq.uaD.P.P.P.P#t.uaLaH.I.3.3#E.7atbk#7.PaDbMaLaz.r#qbI.Z#s#Y#s#K.ZaKa5aKaK.Z#s#k.K#KaKbi.7bi.K#M#Jbc.5",
-".d.xa.#4.Zae#Eao#S.3#sajaj#Ka6#2#S#m.wbeacbi.3#s.K.K.ZaKa1#E.3#s.H#s#s.Z.3.S.Ibi#laz#V#f#3aAbW.u.P.Bax.taD.u#Vbe.SbIa1aH#d#p#tax.PaD#u#i#V.rbSa1.3.Z#K#s#K.Z#S#S#S#S.Z#K.K.K#KaKbi.m.2.Z#r.Tagbx",
-".s#M#W.K.3.S.Ibi.I.S#S.Z#s#s#s#s.3#S#EbeaGbi#S#s#k.K#K#Sa1bI.3#K#s.K#s#K.3.SbI#q#o.rbTaTbibi.rbW.u.P.B.P#t#NbW.L.wbSaV.Eaq.uaD#tbl.uaqaL#VbT#qa1#S.Z.Z#K.Z.Z.3#S#S.3.Z#s.K.K#K.3bibS.wa6#rbP.Y.5",
-"#Q.8###K#S#E#q#gaGbea1#Sa6.K#k###s#K#S.Ibebi.S#K.K.K#KaKa1a1#S#K.K.K.K#K.3a5a1bebebg#5#La5a5#qbXavaD.Bax.B#t.u#Vaz.1.u.P.P.P.u.R.uav.qaL#VbT.ma1#S#S.Z#K.Z.Z#2#S.3#2a6#K.K.K#K#S#e#g.I.3##a..xan",
-"#M#n#k#K.3aKa1biaIaGaI#eaK.Zajau.K#s.Z.Sbibe.S.Z##.K#K#Sa1bi.S.Z.K#kbj.ZaKa1bi.L#3bgaY.S.3.3.SbiaLaqbkar.v.BaDavaO#Nar.v.var#PbM.qavaC#f.nbT#gaIbIaK#2a6.Z.3.3aK.3a6.Z#s.K.K#K.3aobia1.3.K.8#Q#1",
-".i#n##bja6#Fa5#e.I.I#e#ea5aK.Z#s#k.K#K#Sbi#qbI#2.K.KaJaKaIbi#F#2#s#sbj#2.Sa1aG.7#H.n#5#m#S.3#Sa5aTaz#p.Bak.B.u.EbM#t.vbDaF.v#t#pav.qaL#3bg#obebia5a5.3.3.Z.3.3#S.3a6a6#s#s#k#s.ZaKa5.S.3#k#n.8#0",
-".i#n#rbj#2a5bp.Iae.Sa5#Fa5.S#2aJ.K.K#s#2.Ibea1aK.K.KaJ#2biaGa1a5aJaJ#GaKbIbeaV.7#faL.7.w.S#S#2aK#qaVaq#t.B#tavb.aN#N#jaFaF.v.B#paqbW#Vbgbe#qbia1a5#S#2a6.Z.3#2aKah.Za6#K.K.K.K#K.Z.3#2#K#k#W.8.8",
-".8#n###KaK#Ea1bIae#SaK.3#S#2#2a6#s#sbja6a1bSbi#F.K#YbjaKbi.Lbea1#2aKaKbIbibg#BbW.EaCbd#3bia5aKa6.S.waz#p#p.q.rbS.7#p.P.e.eax#tataq#i#Vbgbi.wa1#F#S#2.Z.Z.Z.3aKaK.3.3a6#K.K###k.K#s#saJ#s###n#n#n",
-".8#W.K.Z.SbIa1aoa5a5#2a6.Z.Z.Z.Z#Kbjbj#GbI.m#qbI.K.KaJaKaYaA#o.w#Ea5a5bi.m.n#Vaq.EaNaNbnac.IaKa6#2bIaT#Bbdacbia1#oav.taxaxax#t#pbMaO#VaV#ga1a5aK#2a6#KaJ#K.3#2aK#S.3a6#K.K#####Yas.K#Yap#W#n#n#n"
-};
diff -Naur libAfterImage-1.20/apps/rose512.jpg root/graf2d/asimage/src/libAfterImage/apps/rose512.jpg
--- libAfterImage-1.20/apps/rose512.jpg	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/rose512.jpg	1970-01-01 01:00:00.000000000 +0100
@@ -1,477 +0,0 @@
- JFIF  H H   C  C  "               	
- H ! 1A"Q2aq#	BR$3bCr
-%&Sc45             	 B  ! 1AQ"aq2B#Rb$34rCS   ? (6.
-ks >OC+U`}`A)'( Q?=;#
- Ea@>.Y |AMTnUOo_l W]bU<~s*'5j GbR^ w(d  o=v p8
- n}BF(7sn;>hsARL'f+ iliTs
-?_phi}W={ nyl+so'>Sq~x"0`q $M |?~<_Ub+?{ |P>T<~~ =`[}`my4<'ZP	 $|5_&*AUo\~l#4 1+f $}*V_y?s[DlY|p~,Y4#o#&}oV,h|ZO? ?~PAp;48	yCmmF ?oYPc=(W#pC((E z^X),y??B0[) @x}deZ&r?=n7jW??,4WuM>C:Ea^`7k<q&4,f 7XD!"q$&N(0 X<D*$aVKECZ!5- p+^GdI$uX3bS#r ,h)~GB <~G<|i^EUdA~gHL?dz`(8@P"D"Wq@Q;R\&mVX(B
-oO##@~FH?CxUH9o^~W%#(
-4(sUR$vJ|p@`{x>y99%aLI lIuEGK^4^&{Ytv%vc	g:WCj~uk[5S`l];K(Vl}+K~;sA <QH@<"49cEJ&P-*Y YHGworjZ}3>y$_c8b`EtKA+` \C#<Ztck*"D&a\do]fC:6a nXA
-Np QfSCof@eBA" &,|S9T<xFoi2@38\S-Ngw+(i5!EgDln%s:Qb _ { ~1$m5`cG'BU<;>rJ[``}*28  !<V/6.0n
-~*#j\z!#qD W| ~|y=, w;7x6O?zOMQ/!t<Un7Zm57> =ATC5}#LMpx ~wiLNcN(g6l>k[{xMo5^8 #hnDUWzPH_?<~:ppT_=viXT)d
-	5&
-;R]M~*y<b_~ 	P	_+M`'zYy	P[ie7-5rM
-|W	AE=/xr+g nQR?7|n$y@8NmJ+nAF*< y<.NKi?~!X1(NWMu"zagLa"r:O4d r
-ud
->?k<VKdEZJ@(4E &Sk$*b='Lx!D$  #x<s Yz1#)'.&m)~CI[l<]~ T20Pr?q_`\+$5xmE@}').6DA6$Gko >Y8#h?[+S| ?SW or@q>~H5hD{ <g!f!YJ#, <hjpkif#[t?o'B	$-UUGITQC}zBS _Lk#U
-QyT5d_ r
--@*<E&6bNRV!mhUcVw<0k~>hWNN6 l>|} ,,qu|tSq<=,'<qjI Wsg`>@
-A$_cWN<#H?7sB#o=wB! ^<U$FE99ox}(Q$ * .<Y*$yf U5o7% b,e zXdwP$
-nqW^
-@Tb 7`WX	roAC@|4E&TfC\\F n
-T
-J}<u~Ncw6u_ Z<he)>^| Qvl_BlsH)b9G'B0y S '
-Y,nO^y$"?q0 i$ mY?Nxoa, <k.nLqW[c+(@1*hI49 
-F'vG +y_ ~ci#L?U?Q lm`$|~k< V ?
-[AM<&T' ,>	<CZ6RA?9$U>fW9 9f!d?r 0iglC@z) O~br 4&Wi%@>(~woq4A_P?zrkVD07u0Mqg?}d3F*`,X0UJJ;R5(	rmy^YUfF^OJ  }w)V_vZpdh~qk8ZcavHkq>~4=^3k:&On&i9&fbN I=X|)ouh6Ila}I;~\-+HY}CL#^3TRlj`)#X^"BA#ehpJ[*'R!QBI"_%=(]-[BK$k	P-us3]C ]>4q]nV\ qOG=A _GyvN.wqZLX9
-`VbPAbi}-PH#'=C}A]VZ? o0q$j=@#{n D}6b %);)n  VuO0L#ON4]'.\>K$d;?l  (hsvn.f~$1\)C!^|u;D;~tKV=9>E lz9E#<*gMog~sEfA:A@ujE{[CeZP(I
-42 #Rf~Ie|:w~<YBHZiZQ|Fg_~Y7aT@_=pXdioh^#OM_ t]V~R-uJD6F>qJc/lk=7pw};br1rU<tGOL=-P_20rZ?' -Y YD<Q#Vev]LEx6}g4J/BE;D$MJ66I"}	9%ped- v lFV&ei#L49c!p2_u_ h%&yg
-)87w[bOd,  7k E:TT	AAmr6*"6b<=ZGqS12[^UdE4Cf=z'pjX:&:Jfv3jH#;TQdcf;da>TU	$
-|	e1"H$I`Df _v'U)2nB
-u"NJ;PQ(:_M-$$W:?1q:vvpKw~j'L6(&p~p}]/mi>&&,3A(,:-YX2N%s?0H.{y&tB0A %m@JPRGE?E/`mT6M>	z6!<\?{c:q'y Vt<]%;.UJ8<H f<8<j <7~z*oo
-v8FTPg{ \7|xp~!N$?y)<Km5hxC1][%<]W:r	9@=x'~O$&YGl
-?cn$@`||}%pD4/8Mp$ogrijJ vX-y4> '{m@6~>Aw}G>9t) }"I$i`` Hl~E^<JX3#iS9]!hs Iw?4>(RdL
-j17X`#Bd!|x;	K<vE]hX>i;>Y4m`s9Er(d>o'? 1jWBmvI5I{<n"MI OO<`|? HQ|m~.}'#kdnqcBy@5V<|De,5|}j=?i2`a2  5?Y9)f AEW5K_$w<(ahtM#Z6[ @M;4O1!~/~MIad+{.Xh3.Q"Ee[m  syxy		*r)_~}8?!;|UsC:UQ	) p( <Ev-~:x7`|$5[_nWM Uqs#IWAWB3q 8g o *s\~(0?I|( Kj?~
-lVU%G s@t]V~GD|]8=n 
-@M 	YVX`+Gp"yqqOY	_um~u" ! _<DS' or%'v<W?D[|XG/WoD ^:h6<Gcp~|u ]V|ku )| =fo cOk zE<
-u#\?k Y\s Z u]yx*`|(yk<_,* ku7q <]>$}$8H ZLu x  nqtt8"gu} y|)fPj_Q>~ H<49>:	c*B
- ?| ,X~.k^E<n |=mPymxqkvk;K{><l-?,E^&VynqqI%D ' ^vW}/x\&iv##U<oA{o[agy$[#{WACC= Q [Ww/X~$6yd6 
-*yBxIQ c+"n+/Ye
-@v$ 'OQ#;<Y(63$L@",\"eRt	$vgcbD#CZc>(r:=$z~sC (2(rXW+
->Tz'dy _l2p `IYo"q?hFEAD$ SP\}cy AbS+]|pza2t8I@tJ0x\E@>6(Y
-\,%	 $!k.,Vl=z$a=s*XWsW%D|2Fhj?q7#g` v6Q<O3K3rGf*"C'/fLUKY
-+z.A_wRp)FO!{\,+aI"Q "~?er1ha<o4	QMXsK^Mh,Y1FFmk$}?;wT$$h[bm<.uoXzDXEmHGS<z4~\Y7`R]b>1j*]v>(3*N73my|}7#/\1nD06<-, GImM0y"`giLK>h`"TyDHO$c]C`I(A$[mZ }MlyCe4q|f- ve7A>zSrpErc,Wml0 iv941
-4o[y\0.lm71MNM=` =p mI{E{K[[r4<<Z$1,(w,UDdm7~:=CtXN9AT5uu%>~E8= p$A: _RPBA@,LKI[,x)w1
->|~6~GpNl9V}xsO|JEa6o+Ir.s_oH=^5\=>ehssuOgPb5VOIs78oiwJP d<Rh@/Uarl$l;H!. jE
-A+t)P~PYyxn}|G`Gr{e(<Yq@~%16czdMO
-gv;%;20Muc%D"rGP=Hp%ncXJ[ I'9|q;;
-jM65vk x\yx zp^OK_mmn_dbcwb`+A5hCPvl1.[@>C~zU-v?0)y;Al
-t=vVufwJ*d6gK;24" hw~b	0'5B_\MROV}T4l|:~x*C)f z{v^oz99pp>Gxd&g$ MYJ~2W9L?jO
-Tv-j}`l
-+BG;
-$V?K( nc>~zNZlmI?<N4 yAfwn]?0?_[&qK@'	90MbfaCb<rT1O	$ZKuq6Oz#P 'ir8q2W:U%*@)"0v<IbM(>EtJV
-M8PMn*(_B?7`}_|OE'qaW_U<_o4+}J
-J08E_nOl^y<GPmIVQU4y|y'K	k*XxO|Rm&0 iovs_=S~Dt/ox<_j$/e0wLDlm:@R_ DE~7]C~q[; 8a]G% D]lGUmf!GR- 1' \&nsK ~z(@A`hQ<U6}k~hX&|tMfxMX?LF5!D6'0\'mp;XP.^ >~O $Q$u|:(I;^F1Ml'D|ZEj/ ~.* p|Y5/D} <tUF
-@Z #
-I@
-.If?K5G,pI>@4'cp;X Zd}IF}  B(+d.sK E%	<~HKNS(2hsYJwr$>Hy_W[NfAe:(S|U'p>E)X`N8$EG7@<P  ?q+o 9_Bv0>|yyKc ]m~?o ~) s[9mm__>R8k+ _:j 9&  G>cAQ`D~z@E _BmH4O+oX7ay n& ?H  xp,}f2,?5B?k=k7d1<[w_~Ih|n.hxxn?z^"^k{U|6OPAO  H XPO >1!gm|E}?I4ZG>9 nx1+>.v6MEXqJx Wp0~q=Qt>>DnB\I;,-xP773R>q48QolHPhyy}}j$-c.HHa*)Wp<&S,1t(bO"SBMcK.E:Rw)P:D`*8J6%.	7='n
-)
-Hx
-Hfa*+nVKkdM>D'h*n9QLxYuv`{'EH <Fot\CPM*TznO/a?hdDCN:4	4^?M6:( <nZ]#Ul.d)Ay+ubVLRj52F?XBAg,/_|mc3Jw52>v*ks!rr7(#(o\Cj]TH*_u^=Fvik>l@,b}Gz.LQwgpHL8ulVL8VT$#5k<9A@mWE*Q tP4`km<*sivI$Nu@4N)T[na^8~<%dh Iv m'_:rzlmdN,Kn-T0BhB	#u*%
-3{i8] IU!PD	~UTR:luI"H 9fyD+W\6O'
- p<QQaiSk(nOVz.NG{pf?mvvI\sejc\S6.N2g^^<8F}Gj?pb>+MGL`qe UI*8yk (:J"$see.XQYI!a"7H#lJi2a1pODHTDQP /|Wl,W' pUqF6HIl.lv\Y"D'*TdSlG?DZ*
-&Dm+G&SO#I@T	;EQ6x>+{ Y7mk"1cH!K@7F O6ZK<#%.4|$ "pGzcmi3">}= mycF?Io#-&f?5wWaO EO5Z]0oe) Xj;a&_1~fM(`j'P11HU3uL<DB}?H{NjYK.<)HC_w{hS<5c$2O)>@
-on]B,7<9wipO*9t W@Uwaw66V|mk;O]n+#bBr#rjbP][\+k]
-P
-$@IJS7$:qn8D!BAE)h010?7}}! ~v | x~wn&W5	\\tfc7{%{sk35{3~]eYdrQ@U(Px|OD/_};T3UI1~ua;!R!W" {6 ?Cpq_ca)):$R$j]/4*De:-D$  $+|tcF "VWAJM>.^:2#Yzq?n &vY3{=hYvdg<QkRXi
-(9@x
-)q
-5ZryI>|6rmx]UAz4=v6Rl(m$ PuOI4{cKH$5Tx?u(hZbv6wl'<)3RrdGC+0Boob+c2{b:U_-5<GNcKR{NYFzmRkJX_	{68I	9
-])QM2:!@?5~I7Z+2RaA@wo{?/jTjJ|I<III Bnvw<=ou8u@r!vUWPrl4xS?cT5={@WuoJGmxzn6xfF &	I<1I"E.lKL`|| 8_BBj	)`W fm8x@0A	oEX~('-X v2H<ac+9F&YBTG " 3-):E'HX	~<_1y>n&jbtz0HnV3T>|X9^7 HK 	l
- oF<#h'v>QW
-x< F,vFccv  z.F`xc:#a1R4B,@&6P3h+/# R ($7lK'[7|y~c8w{Ey^MUY6l]s7~/Q&U1 !wwup+;@q5 n/2Ul!R@kq`O& ]UT&E76	%~l%A#tD|&KnRQ =wVV_g
-~sr$ W
-  Rl gW'bEqa@0JI]3\,T<x-#>PZ),(<_5^Q@:  l}D<|tRYJ-P< T|xLx%#??>XB R()^*^):FA]H"<BLV4|< AX+5?/^%2u =q. [P?~Bp	x"WE^f3'z1HGzcx>`"&@YScSHny |~xI<yAs8 _`CVh./<om/kteWi`lr	?,4o, (o;I + o]B-eiD*I4/P+If0pKW|o(k]PtUut rTLD-Gd2\4+[lF
-P>Y87' e
-IR\X TD&#c#ruBYrAE}7_Ga+NOvTZW };ByW4|F$u93M232+]X\LhUN	)wm*7q|ms4yCZ	ur5:!$	D{jRmS<YM6\r"/(%GUT 1yD_G2qsDL-j,lU 5|6Z\Q]FVX@2S	oub%{TC1\89=;\gtLCI$r/1|w\ei{\!hl7N;&d$,	myCQ#R>x@-}ao1EbBMy)hV5fY"nPIM2d)&	 wUd%SjJG$n	o~f@i3>D-zPJ!=Axb8xwx	$fG1Je%EmxzusDt2Ky5_ES\2H-c\CKz*(0HsbA$D6]p"EW:U"@R@"FHTtq[O/"N^m?E=3
-L@(
-W;=iRmkck	}#K,w}*hEDYFSIa|exf)!ZtXeHT<JlR6@W
-v+kfeR)jJ{gHM;V|y[.6s/N>OGLvR&X{>mx&?>luw=?T@a5-&M?Om' !oeq!hkRG\NOLNtJ];wVqJX750bzbjyno!9+U(iD#  P &I#gpKS GF
-`.m,vdb* |_x,fXrvK<_[ QtX}T"@?(O>@0.2Glr#e4}Toi
-{D87Ao*ZwU?alr.9%dWk^x&1aWb~Mp7#\QRSz"8e?SX67&~*f n-|x,6Ls{R:Zw6obv40@BD5,P#W1G%d?=L|T >z&PAF~kp	RnYyb-V<j\tV.ihJ#a0I_'$N#A{%S7XgiZa 9$HdAJo@2gaaeAU&lTcip
-~w':p;g1$X2]3P}y(<h!!'}K?||<|C	1e<Ma(Q~#1gJijPPB'd(2I=OSAjT)^-=R-:B)`9*E\&He9eZ^J?L>.P821RA;EUdu+rE,x\h92<Rcgw 5LOI"N1;TRcLhU{.Cp**$ PH*9keV8#@&(]xDACV?"jp(.QCv RHsIV*	"LxeR b:zmoRS]G4i%8$
-|J+d=o@=,L5%k5Da8 1##MFG>=2BuBMcRk2tv}<KXGx	zSi_n=``((&n^Kyj]C+NlLYi7(jQ|QF,93afaVLn[k,~A=\?zm9e;%z'p@lumi[=O_R;\BTJO5%0SHh>/I,4;@Jcy~lY	.@@fA!<Xg^?&8pj9)I4N/_U;[Ya?`,\ou3Q'^Ux8	f9i"]s()TS	L.mr@dx'>)ZBH(
-0	&,cbV[pV}C?~;%v*xi]Ufx&?;53tGxVhr 6),RGDdp}~ =Xd#f&9y|Bl8=^|%X tngl@X?W'HGcqj/O"| 
-W z$9-k$kYhx#f7dVO||xv`QB$$1(Uid(S
-?P;$RU= xOi 6,tI+e|~G< ^~ 7|_@-
-jPc>:\,$jU- kavUXoQ\pH7h 7$'x Oxm~fLwc$hLpjm[
-Z~tM`HJc.A Q\z~Y>]w~<scH8Va@7[siD'p6?@[<y$e7,$m9+wHeS' tw;Dj~>O `!1q]yILpOLxc`DA 	u`
-$.6#_5b,X5su vI>|U?z#ugYW?Yuf3ugYuxx	'y:fox y$q _A~ED_^(~-C .7m'A+gu1(og-l l|y+rFId4XIHK; Om*'_ >jz>N=v$iK+e~$u~5?;\e^LcWw^^jckzqhoZv2eQy#$|{7qmDPxHsjYMIHH&
-G>Ie R]pv^P
-*"G$>CLS\	F \5	1'(RWmhC"@A\S3#>wC>;\IiR%  MV|tul.wo []	u mp|c iKM 8n IyO4@c:,Z?L#%YYwcUx-G=:hVh07E Uh?z:5EN7l:BxM.DLqqeB@h0-l@H;YE_#o7oaS)fm(j q)A$(lX+H}sn@5{(--M,@M)XaRA&~(AzX_i@sC25xR@FcD3 ! I$ld\, :I9Ad+Ia;	D	#S;)TeR#76-.e^%]b/`zM]1L7#t@6TW&K2\&vbF
-kdjw1SABNdU"t>U|q,xFG. (|p$%AU%T4wG O%$# Q 'L,|(gU=ZBt$
-M8>D ~:J_`7,}qm<6 Aj:[agY&4yv=iR{k8loPE&-eaqSn>y{g+*@q|P4 MmIT%HWJ 1YxU/,$)*i
-@']^;OqMs!eUS7mVKVA7pi]ow
-&,M^&c4~^s2{]uKC=M$d XgEx2d#|3D!J
-GU;;s{A.nm"C)pd*]XL:	T(()Q0	o,r6,Se1TUHdJ^HJbgkk4R,,;GS'F&GcI445dK<[cX#L^\s4*EvH3=?*I1Pv* ]g\"	&s&JWw7ij
-AI>$(nANM+r7r(Q)R\HBty
-JMX}T\xccS:(Mn5R*,G4[=#1\yPx#<|Ugd7)~I+{	8^$I5
-[o	c`' !@#y68cG,K'tXEm^j2>:`v'yvWj7zOpfm,l63A-ROsfd66F<RH1c&`-Axl~w@~: vVB,J$@&s4V#8KsG!$@;H Z'9l\Sp	 \O<|f"	$X_ru	 S{D\\,; %bWeu}V5MnK>HP2vUD0Xz@r_+#i`6|X>LQTo~ohv@!\<lo75O]oCh	<9'Yr?0Se M$r!0@rxY]Ou9%FQQAepA" }F QQO1EZR} _zt;"m;Nl;@4O2j.$a}@Vvr>|)-#JEZ@J\e\-U>	]b$Xit~GWLKaL Ob$f89xiN?^X}FP*xCx :]Ol8dq+Q]14x'f[QLg?	Ue 5Z*nD2u<pWI$"v,pzTeu)Wx)3 ?/kpl.)'U"}'}:UU=v=}ZCL&LB	c/]'kw^`,FNg dqI|$g!''zz =k9:fdMi$8 lcj;#vPDlhMC;cdypzqhTq !N jQIIZ$H/gpc_WJ_N((6@'Q
-J|j	3;SN{u|L^3DL3Q(I,knfDqL#d~jViLs/b 2F`c*>l.~"cx$^ms/BJ?d#J 1;wO-d#w %IR,j< iUNou9V/M; *9)*:HM8j~\|>r8~;Wq}G>F=kpc\6ETI%@i}*=kj?e@UGqeOd2HmB@7fYe^U6&F+I 1Yp@kR)<&9LTY#5dSLtU jV<6~gz$_v cn ~B g.vo~OEfK,<qd-ln,{lWRr7SUcmOxO?!Nslk;sUyRxepD `</g6)0$5GW"n*^M"{A XM:J46@$m5q2Q ZPXPZoChY( D|X@<	 = }-%GlOmyB`c)y6=P)!V7^("^m~Bsb#ly}~hYaB.q/D,	
- ZpG |t#H>?qT\m;B@| _6IRVjnuD}78'55ddqoW=gYu%:1:f3:(]s}lI Xy9& n9W n4'??Y4-K_]34,W1'@@md+2sUZ)0HJG5"L HeUjrUH'$Z*7K~]S.#uDs(fAGe
-<XoK1_Kux8*	'[<|yOqdfjf6ndfS3f6O'%Pi6=Ql ]W^k-HoT\s )1	OQXO+KUgO #2 )
-$ad= c%yUE#M d>.HgEf@ES7oc&3ba ZT-L7HWhevdddwl#G\9Xad L%A`lh^F;rymF n\"Enb-|8VtXw0;@$6d$1>DJ<*
-#lA;!LvZ h nDF2 R68q(P:y" *0d}| I@?7z_ s#dA.,FxCH5\W[KQ)>|\=?Nnu;0/{Ia!Io?{\>liWSHH$/k|?XdfJq0js4IomyB]6 RGlrK
-lm_
-RO ',F)<>}_O,&QBtl}cidxMzhcuV
-E*;G }$y7D4}k
-^SRMVMEr7&:GG<GMGpdJ(EWa|y6Y&.J\A${rA 07Bjsl2#d MM{HstT!*iO[I:{hFMBCY'j4N#IkY<W'7lW>3M2j>.)"[5e
-MEM2IS": oHFI'`9m6L#V!5$]&uX_akk1$P<X6eI,F*mD2VFl:Mxm><G+mV~:NsBlF]vMy+FOCTuHuC	;avAQ#tI$is+\&.QIf\QLd[~hldbd~`Vt_)Me4|Q  &I-	ko'VmT
-kH?[ rdX6{bnfkvk/f3A+0rAXYh>zuw`aFsoN6Q}0Jx?HQ!&.E-*pgrvJ&A1Bx=63
-$EK
-KmAi@bqcv'/1<t{,0f_dl||7!4}zn>T ]])1{>m+*vwvwN%Lr;;TV,&<l"Azm_fooz:%L#P\24T[9B^m%%J@Z[f%AZ~`
-0_Qq6Rw!
-
-R	P "!`0`a`!KMq1UH|n;q9&e&PN]4 z4]Srn5.4k?/ae,.~=D++@^mk=krl. HO9fnw".P[.'PRdH7"`3{4yX.v(j<3Kz<-<[R.C*~y$~T#IR!A#{$G"X ,E|v;5F4M4pYBK~Hu8wT6DISmO:c8BPNuOSq/Wf`MX4<JC{|n;#JSd oy;s3H/$$_<e_mz].QcjvcL	*#='P aD}WGSm&L	WV#V	uPTH`ApPw,KO-'x`0d
-JSl</|4-dF6p #($/E9iKb@q"xq4:[nb(hZ3R9>HJS	2nX7)&=y'ta"*E},+	l
-ZacS}NBFCV7X$;})^,LjGH0d fy<MFX7X+K_UX-60Dqbt2(ir#$WU#0c+gQc>RLr;r%V,~]r
-{(($xM[~+v9]VG I ~Su2@
- sH9TuUDo`A; Lk]I,0*y-Ml<yL^2lTV-GSFk4c>3cAjhh,Zrd1IFYl wy~/S(yIQ[I?M|SW7`&>s<^z|G&cQBF,1$y3lO
-dk" xbA8Zzbe9kI,$p3( )$Z%s:}iIrQU B8;x4ESlb=}_\'tkx(]g3rcwfl;;8&B|FtH5-I*IRM<P?{;liA9$Yh=7X	"@
-; JRp$>s!WAAU]e4GW:\=( L.6gG
-;h
-8'?H6Oc >:-$Cr*-cEtbM`hGm74+(qR]Edy>G$CFIlM,>6E xp a" YnPS]HoX<p$a=L-l9-.||2T{
-$Fz.-dnk 7/jMYm `YnwN	$3o8I[$284lXtRFrk)P ev7`lP^_>
-YQN'7p?XGm?@ wPm_CH>|OC'rY%gIN
-|?oX>$)! n@V8Q<U?+[b_5WoNw<p	?n47 f@&  q@J}:}gY:c:1>:9&f3n_:<G  k oDHF}U^|1'fjZF>&^vvL.1y$v<Pk^rkOt#I<|LY420l7vV@
-~z '2[Cv.3@?AU\S8R$1'a#Vo#gyp-n2v:edsu`
-S;!$
- i
-IXzrS1[k>|SFiqg:uTk3 @%0Fc.Jf6[mx?}f1c*HOpn~x+uA&GhvR:nXlw-ues1/cAR8NCg|1$f/I`h2eF|19!ed*C%:eP wF$~<cHqNJ[D0-3 	])CJ!z>Q<q#k#
-Cn7V U|;!}=8IG@dp,#*[3Q<u;>n;?B
-BZiZ`6) iu-)E)[+ms_! \x`B(<[~E!Vzd{#Y*WE51AX@Xx/A$7d#hr0[[;~|+H=q yi+oQ'  MqgtPrr/T$
-k?c_J;2bGowF$znH)2(ye	I  ,+YnYhJbHRpc`b}.<C#MO-"<Dt0-
-5~y2fHt>?H9300@[A>kv/MM<=MLD&E7Ud$k8
-i9iVVb|3$m,rp9 `0#AhZ"D[ajR$ u845 5+oJ^	8!JJ#kMi^jG7(wlR
- I$~4x_K-3q%!@noIj|LG`I;6yt_gkn)$%,jQih SL*Hn'R$I\r;1r1rEA_R5u	S	> [_LK>wohSGAe=R~z'vi=zwnQ;KWw;KmSQ78nf<CJUed0nqv?qG+,3JIm[G#<uzOt,P)`x U~%m{RS/0P1kZuJP;og9\3ijAu4*<
-SzI * Lj&.X.p1ImbTmyL1c:M@,^p,x=$9 =n>\Ma}>?h07basr,]_*NH,
-AGF
-$Y	ZVP |E&@?qg<-HuM:$)`)$tZT	jeJcKDaD! (zI"}S2nbn OVE,h2-]W%31_jxX)?~GusW> 2;#'P(W\q`Mcv.`AqL)ZuL)+	JN(X[mJTZ}D%'RF:IIN(XvNw`nzv&~z3I<\M,XHD}.v.Z~v"EcG'#$_SIkT^*w=o6D~~or{aBd:n j0D6+6L.r#3 EP
-5F?AxJN-kAKjHIIC(!Z$JU!PR_]?ds/aN4YZ^l%-I*IR4&9)<|*j1"@TfTpi+<WGRDq02)+:
- Ry=f{5H#l% 4&h6NWg~rpaDU$A3~35O#not
-B)9ee+sm D
-6Oq'$?G@vQ 4fy+!g{9W$Z7MZSa6mGUS(pI FIT6N|[8,EU:H{_ <MO\.XDV4P	hvvXjC_f*Xc-[G[a+O$?VBA2P@IeU4\ &R`Mm @:$iN_i<Ok?MD`=bp?H"y)$FWW!?wJ1e<^Tw]GB>1%ymz7\Ei&>;I$Bwm<Te6Mab	E;@;6M `y,s33"{Y+5?,xAdc0T!P9; ]K3,'V_X<)$]<2cfq 40(}/7]cN}YyxjX{\}s5(..l,XWVNM1UOW*x$(TL^l;qT	J GBJO,MV~L1GHUD2Ekk`I< ||M:%8NQl*(xc@u(bHO>x~ ~<z4CJhI$@QN8UcR,8'9Jr;F-"g+AC=Y`t	ZB^]|1?k'R$F#U@`k6OGzwqqsr sCD8Q~{499Y%y6U5Zu;OZBAv7hnv38US-KQ-eOZm=1$"gS,LF;EQ5b2LQb-1#
-y, bEWrcb	 G'` Q?Kfu*
-xW_,)L(y7HR}QNHn>3w;>%%uGL%b*(`YBX+;I3#*V[ib>4?Mo qlr&Gxq 8OC8RE&\|X '`2'R.&]dhdsG+f $#:]~cyA.}:(0G_
-V 6W>Gwt=R z,; 2o 9rMO+ .*}}Q%EWn~{nW]m4!!YO_d^Jp"+k+nPn#A6Gnr/ |	;GO,){v2*}|lx#s!%v$}k&C}~[r -y<|hx~>?ON H2#svV&l6>cJ0$|4zqz[o?O\G*,
-6x<tBtHVj:7e{DY$A8*QXqwm,-P  #}[<_owD< @3#f5y-M5FNz ,<m,~jzWEM4]u<"m[RH<v$pv,Yy (E1Yug_?pLugYc1gXMsugYu4>"$_siv'+w'v^>&,dednCf6Am}z>v&gv&.b<]K.@VgdhikEWURxfSFP. XTl 0	pIuuC	05x0*&	 xnG{jz'2v`hn*@@G`O~*2#4waEI<*i,j$i&lp:Ay*5EP!o* ,<
-z>X+QI%J's&J;B:(Z R HphN$&/@|`I$I,C,@W9ji$1RV6F7(x#H<1Zpqb4zILy\O]q."<AuR.3 ;MR
-EE'&XWflK5_9:t4<O0d/M;7[% Hc	b?(#Xu<)A`	>LXl;V) @@3iiES--S;z}9:C:{qcXEUcMu`|XUJ6"RndG'"I;eO"12!vW/
-;wOgo?sjVR{YXCFp2WK]Z*Am c,ypYZK<4JO%(B}GLZSyCe'D0F}(!@D  OdA
-39I$6wCyr2!=OU.H 9)opx
-MJdFUk@)0y3\]koi		n tf-GB{SFpudpL1tT:o'?KJ%(Awz~j`j6~V~Ifh]C)?Kd^Z&ir>sff}i )wmsfOi.\)6\F9rEQ@$/]YVi%ulSm$4((IXNB947{8-T<PD
-	
-SglKPA3A_ v#TyQxCyVL=,]aQ;C,uO$uj,IK<@P9H`q?K7ye>Zfk2<1C1FQxxu<:}%I EM{IP=dIQggx{D *i7F *>yKwL+YitN+.D(E
-YI 
-5 C]'=2/{Ep5-7Uy.2f$1@%\<]cM ?@}k=6{o-G$8MqtmW.>5M[1g|fP,82OCM`UeRfY"!PB&REruv.-O$JmI)sv;)`^Eevr]U5
->Z-@*9}xa\I# $KO'jw_iy.xbl[dZHUr)d!Ek#.W)dvEDH\ |Y9MD[%$IsRP= TF)`7"CimG5MwGK|l|H&sFA}F;;[5_;mF`t=4~7zp5;oQ
-hva7)L@>9<&zQ98
-dFvV4 =V^+aTT 8kJh&B	'e<Yhf)JVRYe)IZHZ@,w_a9rpj)En3D-''Hv=hZrj: I2.&6V9Q6	4-15G}-RuBI<Eb7a0PuY/?  hZp<fYb8"t
-H[mQ -+
-B$)&Rru)+sWvAW,iR\L. ">=?3f[_f:fsE}P",1 ]:uHU{&I9	ct%n
-`bAU^;C#SmV5Y>hj0T#2T0b|P|MZKhZ8Y ~O!CS
-YC4.5w*TF&%0Jt$8g
-s;KA$I*iK!IYRB (
-M
-qsAG;1f mVJj}?9!19A\ IdtS\\#d:b25w7J>zI4i,b|I)^:19"@?yqCKvy=]@ m@u:<L915r62 WlgjAHA ]E$N9Q 
-e<GwZw3QhZlY$XcxswDPI4t&t;b"OG/$Ob`be1OjQ@<uvFfD6 Nm<PPj'>j^Q'jK"OU ,N6NKR5JmN\<[YvIpTE	F?aG@$\u&G;*/mnzty2(%EW\1,*Mwq*  '$:}S1nD0lZ7j> &O~bD\2w#yqUNimiN^dBe*(
-(G<:y'J+T]w;B/+TrN7HdVKd0R
-{_Xd,m$T)u C[owRaVtK6^?/(T$C&h$g{ -sS O71hk6Zwd ;#K/k:su&4$&5Co|~Xz q&wl;'ZW''=Sdh:\wX:fZ Wrjz{53hBa~PxfD.op| WLe  DdYVXNnis.>5jd$1r\VTq)Q9PF-<^z^NrLK,h% 	S;oX}LKH/lw6yGv"iAJ9"Re+sIh:oy#H4T(7wGC'+G|H.U@i@dR'"iV/ <C}}/qfDB, Q]+OqLp l V)J	
-=1)d*C{WwKvh~>LLA88LiYUkYG
-X$D<mMZ|^~G]% o[q;LQdf}blq&p`,
-IqH3{*H=bG&mntwgT` T;_r7|$1lWxk(&.ls[o86\RqcF 7 (9+w3lx2'+`{7IKSR[u<F)Hq!i Oy<>N7yAZ^%r"u(2GI^v7zv>v17L&$I GMRVDk@/ Q>OP=,\a7V\/yv#2hgchy0UMia>"T0m
-L~x"m$@ o5D<tbrY+h!}TyZ?VuAv7RrUfQ7[|5&)) y# L " MEH7QF+uhk_x L832s`|[-V.|@/G}5or!+R?rG8BB]xG9,~T'p >`w.e p@lQ<WK<'e -O9_
-_7^Cpj<nQB(xt#IFCx;|P<(LO#5&[lm1cug_?0OugYc1eW1gz+?kB~JAnzf4(>mWuq{/Ns{s\X;tRgx SX}l_d
-  uzK.tLl}Es BQ!\*log_Y<SO
-x  9of/)X ;x)sExIT(,V&+<{c/#=C$fC#Y#%[_oi1"9HhcBZPMf:J{QK^jTzB	 G[IZYdFRm?Q&q$P5wNN%NZdR\0 ASrPv\q,y5Vz;#Pk:VsZz>G@+4v$!4EPH4*c;UB~4j=:F&II""p8Y+)]Q@sR	QRS*DJ@1iAf i^lEg+$JBT.$;b&>+aDD(ZI:`fYUIlGH#w>8#<b`!29x6EleURQ:S;o )PJJQ6*UTa-[~O3+.yg91	acE=6umZldbFA@/cY42&rU;h~zW!ID-c(R RV9<377Yx;Mb4N0r*tc e@%wW7x|Qi\x#0<R ndgF.$/cRE*.trrBYF
-h?Ytu.iLyx}oN9u
-]Jcx?wM b Kn9IHPMO mse(>|?LYbbuy}P?`nwli1FHd1 .@(U|#Sh7UOFC_(Vvb{s` UcG2\S8iPQ&)#v@z=u:oww|~w>.n0fc,t8Q=o;^NDbE$*%_h/[tOM=?jyz-kz}\0p!})kWB}WTfxty%!P'@?'dFpkZIZJ!O*Ru6 $xv{U9[IeZ045JF6dy~!%D;GBD<=Eek92C0
-&\x?QmSoA?q'wqw+#b8Mu"Kacd<bn8&i#wXm$x Wl}'PspeL-4pRxHN.sjrnVPD6-R:vS|fwg9,LRw%]8*A>.;ZOjF>/:?cKU"PmEZR;kO^4ku<&+e
-<Yu.F4eT:1T}K]6PoX]r^e>~#N? eXScYJ:+(ZhhmAA& Q 2bznFC%-fmEMBFQ"F2NVYS+w,"Z,x*o^O]?-'TIM
- 610G>\,'jl.vUCCJYV<& F	p:
-62a T.7IQ=}_xI HZbRG"}Gp xztkbE>>DL2sd$eGhk&Vgc#+lt@#o<:mz'_X;QzzlJcfkLWd(=84.M't\LNY':H07>eB4@!0f^Zxj)N\QXBfIJSx) WT~a=Y !0uj*$Ibvore#22e;t$L'+] 5/0gP7gtTFAs\=/{V3@;MrfOdg4kdaTd+WY5|hN^rm6fnBXeH%_eZUC_-fS'(#;[Af*~B RV	 -	S H;saTd)%d:Cb$O; dPcQ$sd6F4IRx$:$RXYy+w~fNT%\hLfv!]Hv5_S p
-zjfG$f}v@ iBp2O)|$$	TI&z#e4etDG8a>XZqIFZM
-.O!o{7Mmj#{*He%CI</12F^,SF"+r@J_akcTHdV!|Ol3`%aP	SQG MPQ*?O[YI6f5haX}0(($"-$qFOz)Tpo6<R665DxMC@(( m	6Azn:cJ)"187c!e6 PV6fw	YF EToYh0~9Zc}R8QYyz;VAm{R7jgYKFXjd6u)I>|LwQs/,mi}f"1~{3:&ho4B:@r	L&Dx,6d7>@`!-XO$\mb%,FVG,X>:4\>!P;d\DnH/)j2kyy[ -Vs;,j9o#CdSe#w )i<r`I,:6OHhyX>,ce4-Y@ Q17#$omI<]JH$C#a0B$DlA+H,by{9HZ}z7svy/}f' !MkE5Hy#u_64^9zA>dZc>6~dE"#"H//Qs!&#*@m"7]s}P G#)8$}/fQidSJhJcHpLx S?%h~92H;@NJ?T &:iU	BSGd*-uE720dwM2"'yph?~'?WzUBXxa+#u[NG49xq:&BJ":%M>,wM[Ho #v@mTB@s1eyfBZIQ#NHc?im/?w"&\aGKcl7R StB]QG5.NuLgPd&8$
-#CU@li8)X<rMthgPSP1ERDG^>'u?fYTC5-%P;j
-)
-$	0#/JV
--?jMI@I $$RT)qh]5(>*D\[/QH yxSi3ZAm|ViL&s
-7M!YV%A)_wDt<s$|bqRc%6~|Po+I(4kJ?^U2s!BKScd 5@/9UB+q"d07nT@I#7rn~DvOzQYy>lcZXUqn<w?oq1%jJ"o_1"b$8ZMR1,]~*zMl
-,+=o%M1w (<$ZBAI @qXS+VLS)' y<|}v,^*Pu YUpG<\\l=G~p}I<=GV5)4
-#>-+6wTc5F<kYhm@ikF0LE>U;4^q %&B}#QP@$~_ lX~,yVp1VwTa#^{ XK<'c}%i0'ns1x76wYm4|xHtb8``suY;$)4?'KBo6c7@n7Yu|KugYu< a}g^ f5$v& 	bE8u V5/h?o@A%ou~tY8yc&|y8c+fHx%Aoz>>@Eb<G+4JHP~j|h=Yj> 375
- 9F)e,`H49x1\B?TtY 1$q$?y
-N ;y,8 x20z]b*] F{H$q+Onnw&H)Z@ya&W48{'^"|1aP"I#+sm|o6_]1);{AGqkS1	X1$TJ.9$Or]wdKTm;@X@Bh3}iYW$4%NKZSR }&9IQBk?IsQV,KGB
-6+@>bkVY$,95frV0f/}\	{[f4hBV5V|Yc+"y%D_c}xh E*I-Mtje {*9 <Hnq-LN i2<BBZoYrIDk#9,}}#hn@K%\I^ f$9Zn&8n6Tn*P "$L"m`"f@5
-ni ;H1vONe?p$yKjx4+gd1Ftm2`0osd74l_Shz$tlMwn5!s2t]rV"g3IU'lNzvVK3p"(2 lWg#f1m=hi2'2AuRBnmEF
-Lq_k[QQ|iZt-N!P&:B|=7]g>_%104b&&cv"LL+O5]u_wxvfvJ ?ZvD%?)%]co;#%RLCQBdVzv/dW~zYN?B6=yHj/c|CpjZ6A*-e$)-ILGN:r^{;Hqj	KMEB|JTA 
->t\s7Nb!,x} wiy`'tK&/m0pt|]'AkwOQS&DYPcX||eD)WSgW~& ^vF_rwn ?szpq&Ko,eJKW|CeT%0uQt"Pd)K"
-M$sCpg4h)TiqR
-[4jFu):+;cd	SQv?cG65nX!th[fR|?}{;v }k;D`{0Qy]jX4lixIg{ 3tw6LsL	`'xfG2@yI> RK i:YNTnR!m	!d$JlkW_Z+Kg'WX3%^d3bH=O8zag~.|>&$.F&WHdbTn5#A(uH2!:3X_s(Su)~<<6/{r\I%Yh?1f#.M?vt8$Rt"`@70l*R4$4*BvkI\c.ItL!mihn&VkBCvz,G4#O-$Cidz?|	t#];|rFv{[Rmjvz;Dczw=7.||RER-8^	JGU% y)K)i{$($z<
-x4W`B@PlR
-ZE{O&~<K[8EeLjq4r2?@ki].Z~,D;ByQ)?~M>"K <f6E?(#A_KR6|7l4OxZ#Qm=r#9e>]VJk*J|H0n$	X$A@Y6691Faip1Ddjt[+,A$(pq6	"DwG'P4w5\nF47Nb@  9;TtDC3,AM>"K?bqbDgI12&
- @6M*Q6&x0Rc7~ ZQ.U#pZ6qXF$Ok,|P>xa3"H5I" X'!A6?Ayby)	1ny/}Da1d*e|nC>010*|tQYC(8[U4:YdpP|,t
-jI3<K1cC.8L&5c9?eKPW'X"LeXP,6xV~*_i;0j8;~~+KZFU32*5w'	sPI>j	%1 81jeiqL]^0#a :a#Z6.qorlR.F9PX+0 7B};Ahu2%aBpG$?|x>+M17;2-0	|xf
-ZW&MH3{sq\,:ur<-?h|#(10, PGe2D,e1 "}? ),9@zp\lF,dCWs).M8#-*Y8JBl6khA%d=7)4+	- G!gk'(lxFURO c	.@om5_@`Lr[zHW 	
-':|31`gCI,;B3-6~ncfM} {cvKl^p;[L4-#
-]RV0R(aFt4C6V>Tn^zyv'rq#@Lpo~
-qpj=_mi=/yjXol7o}51b	yYdW_,I>><Jp_6Wr:fI#*$g)*rqVS%AE	ZUJR<bO~8EVR,BCpF7aT
-lrAd"C##Hl"ox1_Cn%TQljp8HO&N^/NWU>1`JyEy ^!1fa-ZYC+e$ZUfUPI,Y $A>@fp"<P6*EQ[(6	0yDg]vD2aIm&@h}1,WGP&@6*y4~NquUXY0dK/bl?X4*8jo@E TY#1V!]A~mA-FXRt~Ddf3@.w<;  WOSHp0N.1$}M, C+R,,oj^<xI 32q\5+Ooch|tH	Mlk DNx6T	i )k; /M-iGLxco_&}5m0.1g61E f,fZSg?UDV$4&Gv*
-/ Z|1`PcXO'<=uIKVl_i)b K%jh ~|];F.@a?Xt[sV
-7)<Yxwq1Tyo
-58JI}8T gb>TJjizeU6??%J8X2"'+=y	 @957<8a9[H]gYugYuf3q|G =f3"#< "V<}ynr.OR2 ~|vg_^~&YfV,c'Gp?slx<_i$FD9$z&7jn>62)A|<2P`x=c1J.L}'_&3'Xl!'
-QK'^f|pFaPC;miK},Mub){rs9Rhfq XF6q=UfUUS@KiZILj@BIyBB,=J L'QRH fc:2$14=c8r2r\@2wUbc4eT0wmSf5lucM^,$Y8p{3!f$Q G4gv&v,+J6y+fB"31GY8p^~:*1iZM<P2FM"PMU*,xZIX$0P} 3S,soC\a$P$H0 _WCx4h4rF$ 0T9chY"$LG=c3`,m{ycv"!LC3nmu^(qiRy&!Q'dSF8] \Fl!^FHeZ6~Nf&ilM2l2~4pB#qh0X@W@>~MXaQ	H>-[E
-Qx+5P?.P@*Q@"o+W	7"rp{{Dt}5X)#Qzg$RBc57C3MDW3V/(J+6x6]B#VBF|W4/BR ! f9M3J(SRYA-_=c~tL\]K~i:pM;hAH`	Xj#rx?kA:dYRR@}6"?Y[	;X<^v{w/hGf3dr$%
-U;boP)GTk4Eh(RBpJHq R$+>Em:7Bt$;gL? i|	.82e}LbXWT+s{?^h=9Vmaw6y3iM{gf,1fq\w	+3_FZR{s4G1Rok?)7T9~!f}/3A=o5vILS$;>Xf0'&M.j\oRTJi:YHB*1E'#LYKZ[o}*+J@LIZV'}Lv,ZGt,!1, cQhE`j d#wQ/nJqpv?RxLL'1c>N,H.S=sO>v6w,zDp#iC[(&GX_]]zi;jyx)li 7H#c#o&<uufs1V$)d!	5$9A6_,)(VP6fE*B?SR$Y{]Ouzy}^}?&_mMc(zHY UIt?V'H^3Nhi\d%Kp	G'kjSM,yY$fQED*kOiyzhzbIL0"i]Wvbi~0s	S!	8M6ufJu7%J%(8qJ%%	Et LO]>-29dM3\]_Y4u>E*~dk~ia4PedAj94.1xIWcI`FWCL uZ5g#jXO	fS 	sfb(e&I6|a,6)qEpr~u =r~2fZMzeAH:CZP%a(0]	koqi!E:UPSG j7m^:u3\\vwujq|z6 mQW0u{u6iC&*ef,&V^~XA6q)Y'g{cQ%OAIh	? djx04QDb!!,b&}MBr6Wol+K^FBT6	JV&.rbP>H)SD%10dXgpVHY^`PqSo~8u^Eht`rHMZv7rGcEr$cuuNVEs"$lZE~.7Z^T69	yp1.4yG"hH@=gT9eA\(Q	(JTTRFEp^o]R4S'\!+A2JTi` d8Z"Q4_9|Dq MGzgv$y N c$&Bcuv M*<Pn	* 2CC#h(%*FWWUTD&RBmRa6,s8An9!UH0rUTQxVlyj?d,K&T X&=^Ww$FdLPK#tKXN1(!Iy;?CNS{e991Hf,y1yhk7~ d)Uk dHT'x5ng5d%D\*<ZD:"Fx~I T#c
-)e3 2o<oz=/].'we:`7OI=1a2racFc6#
-#
-_ 0G9fTnZ^,  A'J6/^_s?-
-mnv~c1!*]x>|q]<>2yT[UQIi6od^2fGj	sD_?$t-!G/q$ Eh(/._i~N]R-4AGOQ |XFH	$IxvIG>G9U"Cch.C"qp:]Xu%XGu~ZB[ um		&;m6JY"m o{E"eg1j$2y}MOFc&&#PWbm6oU$a691E{~+h7L:JcDs;y[T<q%
-]\U}17$O0.=?l2~TyM+C a*jJ/}>.x&B?,D6K	l~dVPdrLO
-x=IZvdO*X8PF7TY`!7F()<B?PQ)	#E X~_5cz&n@;F=X
-iD|z#Oz4B]' IAR]7L?9@GUxPS[IKen&ckGx HzCuO]}13Gk u+	N|FY&.z 5)B
-W&R*`vOk-^i!h7	YII)Pe2Ub.mh~hc2YFY?ZVc'ndd6</dvX"LslJ^I0l~tplrmCP7r#Q;-
-VA/ypiqeW	MH$R.,)7Jbv>FIlh%ekOlATll\2LbF|$|~9Y;LwDH'r(quOnzII`<d$\~PF"tdQ{~l?8H"t0Y9bcTmSPXChU[tbPeA9anO<Q8)h!X+mc^/M
-JZ@'@u<e)SZ$ ?.~opci0dd)%uoH>'H<V\diMy~1/9Dd Fn-~xJS6^ Bp\/IypI  d=	8[-jn+0-vJL&i3jX}@2nm 72H RjT4I Rv/jVxotmX?#[:Pys#30Pl&$7}2Muq'}E	_ |x z3O,no9Ew`XE|WMB9; l4>9k<x4};*To^/, xn6G,'\x/?Yu|{u>N>22&c_'@$`^P>y'Eb*	9U<?=$OuP#Wu@ Q}	(w,~~+Ea5N`&<~~3{-;gT6{!~q.n.OPj+Ei(5uuyUM^$WRT/T"2p7N $Is&q29PQ $r.3O]E9	|||uN-UK\@*2z2V
-w::6ss\@l,*\*>O5Q:{D#"s_?6.:()@nba3Q|}Lm9HP@@~q{iZ7]N{2j8Hi*4,bYT 4(I[ yuXps2tm_I-/T7P1em<0b7]ZoTu=F',mqUpXf|dWc;Gu:`Qy$BuA2A,?3~f0A,B<4,%[[U|C0<uZ#;u Ej/U{.{),*o/?'Oc1a-|~ltCq.I y2w+ qm7ahh^vWz_$\4E%.F,mQL <FU;J8o<O-u4zGi`^`ci$piHV7fv<{jX*gtDAdYch?oMp*JBo- w*)XBPTl	IWRt J] $-jZPBXQ50;
-%	E$hr\q~zjf("g$~#W\vd!"Gig\J/I4I 8qCPyb_qlw	#mc2t)#>9Rwz7-F[X4<{[IdI1G4QJB`RFOWG[TI$cfbnR6ERPA(<$BTQq&8$SejI  NA'WWBM+7[;T.73A1!\VX3#~FO 7}7eh~b5s_vi%#!Su<G{{3G^OY=?KJp0#YVi"*[A~wL;a;w5dI2_#"YQh*]weq=EesMx* 
-Q_VF	CcN%j~/WJ#J}*:;wX/!}Q{G\r}I3H}hg2L  y?iaoT= 	LM?p_BIieh%@3@(~Zfm:MKdDAPNh9Zo:]|g*f
-&B`.mKP)R B * HpQ^I,.W1sWYShY]<[OtY wp~GApI?}h~.-?31P`	 ;~L N=)t]C[2uTl#}WN|L,_,  >@Ae]DQ`L`'ircc`CH8}i|U<NKI\BH%	qd$&T JQ${qittqZOtAuD+J4	JR N#=M:If%for4:sh6?oevZyp2"0.4!I3ef_qa4i0;^NNuC,y/ 9M7{3HVW;Y(srd
-%;.$ Pg6T?J %nl,$(p}SC" B4Q&;.!j@Z@j:n&L,e1\1A+mKy$q6bSY"%@I%o-4Mx#R?*r!Fl{]\.0#BHGV8YmVnyg-g4*BE_+w/vhR%:|J"J@ Fl`J0$Tm*jzcjAqcj;==t(u6&T'kA1][Oql(#cI,);(`#JtY4+LI!2d`GH U UVpHixf v,&,y/N#R
-.Iw}1[ITK56a xTAQ*ukS
-g;Bc8#Z5 @HePTyF5X	VhQE+pYpG$SDica>J"hnBX/Vjj~f\m;'P}791p@@T*#U;BuY.1Wg)"l,Dq6g-CIV62LURtCZ$#* :,v)R+PlJP NCi;Q_ovz}I, PM$sfLw3d,$cy.E15eM@"71I[7n<\?!6REAWeu,$r[bfI >qgz#D=7~8lc"%\ TpZ#5*dG+9-fZ'|= BOnvV^W~DI>kZ9fqq'#myKFNbb0E2#oCD
-"o?toK86ROP7Amf9RLTJD(o:KO@Bc{,kU<y^X/q*m'y`B@OPtkUD$wsfu uiO@IoG$JzZ
-/A6f9G/wMG#1$T7M _lO,X8 |F\Z%RAn<Q;/2FY%RE8 C]:=<D;<xRw.hn@
-_shP
-7$"/)Yi9GKy-oj$T\"#<|rR~Z4S'o "usu@
-
-H2>94iyDK?52m
-*T|_Ipv!<B	IgQKcQYDFsE4X9 A`so/)c}q	DHioh7T>GZE9
-!YC]pUUI=-lf?xDr7W],0U>r +wyt6.\`T`|daaE|"0gE:
-qgPiei3edwM\?*>zy>K4K2flu!o"N2}I (Oyblwhy'Lsku(?T}]n2I/:VSg51c5 p\g[T{I%uNn>8Y{2pldc3)N8 +BP, 6F&p	hy=&N.VviY6*~wMp6th> ]g@IR_0k+GXhE O<]KH3ITHL(#q?dL!t0MW=#d
-{? h<wJjjvsQ,@GAG{'}Ock3$6l $F Ck&*QLEjY	L2O9@N
-Dr Y:_o=a=>Dmr
-B ZVo|E!r `<R~? >\O%IKK,o"!zNhvI4(tt+E~KehVw]@2B&|,U5
-`3ix>T>I`}><J V]X; qbz
-Ojxnjy!$F =~?\Km1(HV
-^lHPX"yPv x< ,U@||}Iu6wl<[8 zj $a$guX" FC`G 8&B`6d()s[%*DOK{[(sU>x<XwnI?I&;1^OusMl(>,~P'OOOKbwozp{"n?<o/z&GrF4,k|[gp.x36_q6JG_6y
-$xz
-I1{xSN$'@4;lf pKfA^>\j ;E $5eXg64<&J"SL6EI'`eR]Y$6?z-v
-9($ *^s0Zv;boAze=_Q;W^qBmRT?I/.itt7,ZXZl|wgm$1%<)-[zfc{Lm;DKH:x (c5YI2g5X	IE5G]} GR1rulH#j_W=I'+5 q__mj=y7[CfcN.E
-YH _u(-&fwX1ap5xG*I$c\ >|X2*nR69 ]Q|}>N55eFCR$?\WEWt),XF HPhT1 n>61P 6xi	#z|Ii[2u<unF||b	;^>i:.:Bd Hu7Tqe,RPu)(:eo*!I~J'%$Fr{U_odRhw1ED,M?`Rfh&P =pE'?s)\ 
-)
-2+5nBW;MkG&D2)+%#n6vOqu2*\r8:cj8D!2R3 fcXnH(RaA@AFr6 M/JK$%*JT9AHn }G2OC^>&w",^9FCd,DN-Ll;Q|}T_J=I5-[+OkOizN/2t%;M<B|	0.)<Uog<a5}#SVu<^&`	De" 
-k;dTG E
- \[,P>RLm(*:X6.Y4f_J+2*3NG"w4YRZ?<f
-!#0c2`vCx6h~fsrtLdl3/cVrHHn2<C\,I5& @'A nsj7(@DI$%SdXNR4H5Am B_oPdD
-('mP# K~Q&n~?}8Z?Qf3{Hz=C?V 7'2}p2RNhi#07NquL%HI!FnR6[D};W +:H %
-uRRIHscZj{nv{[]Ude$$Dc fvu{x2szn6 I16H$*	efYd''"j nr
-TUSNLJ	6PMN:3*LT!J4|!"fx|t^?g#"&BVnb<g@8u4_E0-(|uC!^$0f~L ';gi)iRZ|	C@<y	?Z I!u *T/6{%,,x=&8F}w^/4ls9%?JSL!j0OY
-?@rcHfS[/udb?hlI$,y'h@+\rw'ir4-?Y(5(	2a=U?Q.\N"|`y U^Gy/"Xe|F"Ph%'}K4*]S+QNaAQ iI -e)
-DS))RwNHq2zv?z|mki]?J7cT4J1n(->RFw8/*
-r:Or,]F'|de11.F B7&O=64iTt@38cR3+MWX3ZqGLWdHH$@0^i\MJ!JTxZivH2I NQx1ufN}Iw-lTDOubgHq #g.I9.<nVB#8 Up(mQ]yqZI@&AlI>*=tUeF'N[1 (!#tnU*RUx?!e%5	q%	-	R9
-..KBhVGfcp|-{L$8KuHyXDR\DFB4aQ-\'^3hUYF~|WTFz'JH'I@,)RJH2A
-H|@6J&YEhXdt[)Kl=DWnHcC(Ea(0~"M2^qW<_;|y]$RLZk~q	FDs}20*[#g/Y*
-fl |-J|P%B7?b8=$o$Zq0-= RbDb5<<XMZ;/HI|EV$*$ 1/Ei82(vo|mB=CPyfjS
-IH>|G,tU=,>6> K{hr:F^av}|;c;Y;5?Obe~rMSf)m04AH;n*%[ek_ dea'{UiX3\=&D5}j$,(jIwHh	)} Y+	a+8m2G7j4c8995? XX{>I2>ynI1w,B)hSUW\=+c#v#n#GOTtg:<Pcm5)3(,[UG6OGrnWuU2K!o^k?Q$34F&4;W!!R>wQ_dK 4vk _ (G~JRX"KH CpmB.vX85HwL xM /Iy/ 9lomcQ	,Q:{wCF0"#dW$"+:t|oVLHs+@
-jy $rOAp\T$ $#JysQ#QTV)a$#{2Nk~<4?w*::$Z7aWPnhyFHMMT1a(*@+y]Eq5l9!%59e7PI ;F)6lrSO@[0"7&	&TJowiw^:v	0;U91fGM)$i$8U^[\_w777t)iu	o2M#4ls4?5S.Y -41$]2uC$440ym)$kq~pmeE)nRXH^N96KETOisu:@ i$n&fAlcbceddHD/KFQYUNO\lj+>.&OeFGy r5[LK
-dX~{al\|<eGjNhsDY7Z:za7o^z{+vVhpa\(y8/j1PmO+BC`wB42.PRZjI:GIg7~GQXt2p(h ,l~]ibDIHQmZH7~vcEiJ@wxAoaF6Pkgw3
-?Y, H</@TW-2@	@O3;(qG 
-@Xh5Pt`) [n oQgh#~i'tH^<QO?8ooU H%$H1]QC;r-7BrE$h ~
-/i;BKdX8>z'@}m@+'"A|c;^H4Bp4 JY0P?o"Jny?XJh="x?7gsD`k[47poxL@Yjy/h.71>5 %,Z#Uj~=
-YB~W.-(R6?J8?nll|IrXPFz Od'tPIB37:	61o8hFM) 2+mA_vTXjCB4l	}3MN`A  05}	ralN53 *Apm^@2M0Nv(xAt"w3:,4gI]	RT<]{7
-%,(>x"vc1yUY# m4 j?;;,+BBI9+J(z<n{Zlk5FA>)|qDn;	zBmG6GbYOim (U
-AZlx[F@H3yn!syUyH)hB%]u
- K*$Xm "~Yx>y[kind@%3;{[bv$(
-#Id4cNh,6il>LoySF1HTX%%RS,?eWw`F)|]~(C[X;?S$qx0f1 a%MY3!f} Ad_*$}du
-2/ XCt*6z~ 
-
-	""x6pqU. zJHYL!*#pI=9V>]e'~av{4NilEIHfEZ8:b,xy1j:7si.Veu<r)+L&cpW uufY/kw]7_oWuD1eypfszJ0Gk:F=0j0l->Hu(PNZA_>
-?qW+x
-q
-[ *Rn`OlnI lJ,M/tiy,1a6lr4&?foh!GlWq{017 y#f4%EI<oX*i[dy{m8Ey#
-??_SS.<X;SF2^|)2f'iN4cLAk)Yn2!*`&Im"\^5 NH2S) Xaa+%):B,SZqm!`+bfuFwOu"f\F|SP$9pc^J<|yA6vo5pcQQ30h!a,7LTPfOr2smo|uj>Y8,scc%M5| 9k<xi!o;~_mCGIlH%Q#|Yw'72;% v,u CzlZK*$"((=5 &/9/|v*.>=iRP=, :!wSk8nN+j]1 0LtHlFFM]"5 R!GT	
-Rp 6?e)*:t-6-tDOM8a8=U4y^4FQBbhQ!K oghz]ohje,IvPn=uC.JY_C1y]A'^dqJ^n%f/qYQ~6lm?\Y;KqjHYr0j@e#35eLu
-V $t %)R<$ iB=F	)T5tRGxN~G4z6i
-v{iz,%2Zyi =&c~2N,zC4O.F	HT$L*\.Q&/g.,012BTMu2HyY?>qka @#\/2wF)A;RD@m#s*PMGM4(Ay:%E?vkK7uwbWyjHm.I>E{ D~rsWFR F$YyA?= }rdw&j WcI{WQF>~>K<RC/ex}!T+]IYfA4e rN\iR$`92<Uy 8;Kp6)JA:tO<g"zkk.pUI=y<Tqdw6hz.;<s@!hLIjpy_}>+e{>8dIa't2
-cH#fel_{&MbLhy93U ..J6{OC\3&|!{j/&JJmHM,k]R-XCIT"zSGzV2zeamoa
-E6L:_o8 w %UDDKfwgtZVfndws2>v#\%W5Bh{m*e4-6KIfp  YX|%]^HRI5(H6@92rP2)T<)@TbTeN&=^x4Fgy w(( KIP m(DDhF,{Gq&	. Q Oj/L*L1x%[]I$M!	$#k4T s>(E}EWh".ocVuJ62.Nk" A/+:UM	734 ;BBXOhy}Du[,NM@.8[QRN"@f@'@iwHG:fw>.Vfclxq,lu-1}OA%
-m	 D[`nQQo|=1j:[5KZ%*U@#E0$;G6N,~S|J"<em0([sMQ [dFA3H
-XsuAyB^T$
- !}T1{!$,A]TFn,qR!cI#,q"Et/|z;SFz/FR&c*'t70@v(J7nPy$"}cU )A\~X>R9j@i^ wocC#IJ{Su+cKvNT.,\g1TOfD]xql&e_`#G\ C
-rAv~"uL@E$UN0RYvVsH4}
- @Z "y&gm96(qRoy$bq	GK4`#}
-2mg!, 7lb|eW}N@.IkIv\}Q"Dp$p*|" oqi$]@p"#cQ/ddP	^p/^B~:ibFTWTA0rz>@O#<?"	DcnwBp~Ek[$Iw4Sk`|CYy>|L%:H}0S
-KY5r!["y@D>aS{Q,S5qtTmQ1T\Xzxz^zi`Dh t %#	FA$s"LNU.S*&<3{X7:bJe`72Bg.iDQrB}lE{ -F}N>,cp\|w93[ ~zr'i3i,j
-, _pB /4l=d2R7Gi
-< .MIS@Qp]\ls|- z11Bj-ej}r	"	Uv:M7 vRUh<4chbKRllFT#+
-Xlkf5qz#L2l[10b'Y{Q\D$oCKiFqH$>	GdxWG '	+)W-5<XtIlXr	Lq,dbJC JwOlh?iID w@3K'j6sq;~(YU=7URES"1R}; l8:TEir=J;`_kZ0~o]2:6$m4>kK+4r_`'4<6(tK>|->9vc,m"Ea_rGKCxx6JdxNhj@kxaDo>G/wwnS%X[<aG,Uq`toT;B8Y25%F~OPHVlhZH":A-AzG6,8}YqD"IV"-qASgiH=PTA-MF^I=ZDB ;yc:2A|\fVMrMkb\`y;a5|sWnw3zfi >%H84MEvFu%K$
-hR< $S=,D vS8SFx5^yW7&=WC QBJ76Q]cOc @Ft|<*#}~JyJs6	;<s c!4(>z o2O
-P>#X~/$]1rP@7HX5 	n<,V>Mj$'s}EV^l_Aj* P(~$\qX YYVxBU( |<9emPhiqt.4Ah7BCuhu-/B(,)	,):nDr*:#?=cX!PyT
-ZrxYI;H TWq?M9@@f[
-Ob>~'AH2Tc"^@
-l\y_O<lV5o2NmzmCh=}%]U;lIf0i7	#/pePTHNp,&
-aVSyMlY6(XE-) P5U;O[|&6
-Ly'7=,-,cy";G5dU)3iTvm%n\KEDk!7xC~bTd- S`qU Tn:zRH&TyM<(Ga;67RKXid,8Gs42}Nx 
-Gg3HM1EJcH#2]6tCH^4	#h=7R5P &@,Y(wgj~=Mz{"c{ >vak> fhA7G;+Q{~!Pmn[JI#v&Vd6<M} ApiIZAa*I=aY&y:	;j
-vF&N<2bFr7?K8.>]M X7G5^v'cWjzigi,oS]S%
-,QHg)5l]I{RKuI[/\s^mWHK+{M<Y03cfaO49qG&Fv!:-,`5D
-/7LJWF	P'T^s $+" {Bn| hGgrM5Gv80"LtDWq_#NYV 3V 3bxEbH;{EcQy+H59QdML2Ja	Qxf-(EQ y~ :b e
-7PC^|Z]Cs$5P0AoC"	C;\{e
-l+w>tWuC%2R?>Ik,,}B$ ;QzoL
-.>zzK gIU#fz!JVH?I0cm+7?~:P,zM pB ms_E@}=(F<Q^Hk:>]Z[j>d\J?5edr{o$%JOv6/E'T.: Omlqf @0A#N6	"=#U*F%i)6eo'rAw"PB
-NRZMAfz9 L{~m3YR9`!7d-`0$Mk/tw'uM&>4;w!#/PjlKQ(ez-):6^:l'NF*hgR$1S7dux#M-/,a/w>B5?1Osx33u2i^UTu,!%I(;kR3w*#B?	%q6GIyphv}Xx
-EOlf
-j^8D-Xu
-+[#~@v=]6nDQcD2uH^"1I,<9V8kh f&w}&xG84:8\P)f.pPY[GWU;V C#$%$^%Q<NgkI]B
-}J2$k$(j2LEfvlwea$2 .rL*L[osm.kvgciZKHf689f$),U
-[=soB8Jf{~X&.-0F4/6m3QiXE&(^,d]5PaJ]2$AL$0BUjI-*H&o n_i]Srey#XfwD;E_t
-f%9eceSRwC&&$9yI&V||QG Qu*G5SK^2%LhU2,Wb#y\QWT$\X$I1;_`dUuIAH&;I0:f>P6Zcc^hXb.dco("B,
-	(u(j&H1U@`XnRA'<IehKr6Am79qf{]wB 	 !1{L``RP)!Dl>EG25CQ9yY+i$,X @A/}W~jt:OFl	eQ	\Y5]+iNpcT H Wu(WC%B&D[}LH82$,P4x[	w:_p@nl/o& C3 ]_"5]L.uWd$ VBF
-&Jv"f `!cUY&ovvCFHh Sl|v|%Y0gu_3^$f Gz70&=dJ
-t  8,@eF 8qJRo}~X=vdI6#0gV
-S<'o} 5Zn~,;=cSe3f.0i& #&aqDUz$U  703'e>=lM&f&699%"en) )Z=*7]7Xt|'\TXIrylb0 SS6Nq?>#juMh<PqT&8Y'Ue'!<n )R(n>zr`,~I= V-7?>d=kRjv~c@:p2MqJ	TbJ<mr~rJPXjH)(*&$_NX7Mt`@*.b@;s88^p)$#D5*Mojp	b%$y qTU34y$}B(P@7_ =^_O4Y1S$O!3~^YDY9p6@|   ?smMW;k|F&od8~H<qXWm!Vz);a3o6n	??]LvnCEc@;Tkxt:fG</$Av^@_;3i3%qiHb*25Df!IIHnH;)3
-:P$4Hr]lxTTRcV3%X-R1\`\A+Wuw _8@$?KUrQdYqNv)BD7+$S%<qf$+WwY^8t2=3W(\,	Q?dq 	W~?,RKn vl* heC%H"BWI }.%c/ 	$G,1*ci*T5gok$E@Z 2Aq8|TivWmm	!XM,	uuU wO&@?D^lnB';Wq\FSbu%U,w*aFebF1"oscQG4rn7m[KmfmjUNZZJV  ` bAL|
-w&D6Nnz1G`)`ve]uuu4{qp4u3Doi
-|{ oJ=B3Z52M.M;&&/4\bN5%Dw~A4\8!L,iW.40I K0{:nFKEJR|I ] ): #P]v]W 5)b*)TFP(
-?~ IxXFP2u!4  }?M7 W_gn1s_KaK\Ay|BbC}U:sBclv8<u|9FH9G G+`0 %JR$p#MonhFbE K!dMDJoP)A6
-C^h B?x
-<)UDN17+\U$Vl*	Ttz?9Ft EU~hbxH p[$9CU}j76lvW&d}+} sjO^FnOx$|7`WGyZC8WAy_&Ow_?)Sj##| }d}$/
-?Fb8?  B{Ll?Thq P-?827<(y>$$#"S 
-xOGMI% K
-Sb(_DZ% yjT4#o#d*,=X%>u><xl$mo07X#r}Pmm~ E6(<_&t>,  im. ~|yFm^PyXmOLJL<vbc*0*Q<QIsq6.K]pO<8FqbgK\ LHHNqCHdG>J)h}]/J;U? dR6N6n	?S~v^i@"&n'gwpb*6 35b(LN uEh$n[ 4M|hp"3>O)X
-9'dsr=+3O	}$?itEA;@p'F ux qdWZ3d{@ C>zP+0`GtE_Z8@{;pc@wL%E=aETwJb9\boE:=qL$V(q|_n/,chcD,J MU>>i#zpJ|F"WS=J;W+6;d5{|ZY[.rIT ]J$+dz(")r!>*6f7"y\_/7x_:FZ&F8[?hDgON05>^C9b2scC " F0 I#Lp
-<tf#hch[  A,gL`Y$pvr(W<S&k{jQ%S!J[A7DZ0^"uSU5i\$@ mdL&i_cbvzGa>i3H%YVYc,nDn6)<t{X8N$A>RA;xo?urvcw&]}~:3{~^D-0iDP?m~.Dv>:^#mY?}$)X_')F+}'dQ[]sUMjQPkZNKl<@+jCZOi V+P$	?7cI5
-}}< p?RJI7+[Q30>p(I\}cE#**cdDyg~=rcDR a7t=D;!I7_"e>VVX[|eE41gV)c)?N{xB9pU<5M~|4IU$15<>?~5M:VL"U5BNTO0hYx$*I|_Eqs,D5 lQ7@<TGgd,s1Yn?*)m2`A72d^o!$3 ,:&Sm21*t!PG/d7YH~,qL.~IRRt!b_+G>7rl]V^a"@%QAEpZ-rdm;,.?|yjeiO&bpN#%^:H}e`:'~I"9~`glI=3`lf@hA$Bxi}_A5S|7/X!~4P:6(:Qs?JQx,E$kTKbf'&,qK#\qf4I*X"l\8,[`PoCH-ETUGMj?K;4FCjUuF?t9#TPFH1&~19]-%2~{_xpa4dG0H8>9_qD`*@~<"K )E;,o4h7^r(	1TDA6#um:6${	9uK	2w6p7&f%z	YSa6B`B#>O^ELX	%5<Nqt\w%*Z*?=:_ezt3."c 2D#M-^
-Rby$>0Med&JbM}Qd!e#PDcd]?px"|irvtDrIdfgzQ,RfI,2E(*9!k) y
-kUR5#a< .csARaIHL& s10iX.&xziM13m*CX8O"<b E],m22UKf	 cB7);G5MWURJ:Y4aVx3HK,B-?P|}9[tlL.\f./m 1d9=QLU.(xpxBs\\\|y<RabUA)SUA*/;#CN 'NN%&'Q"BdF$Lg{*Nvmwn~5 =RvFol
-FjHiEU _djWmr{{;wD	pvX*PY)gCV YLzz^
-Zj^Z|iN)('2P}]84L:j\(uN((nqata[SRG8J	MN{gQ .jv6d.vv`T(@nsc7lj$S>=Y)9&#mEdTU~F+1HD4,bVSEOj`-h63QBBR\B"|qn5?Wk9F>O&.l#Qgq>d}N`Yrej:dK+K<MIX4[$
- @n*7aZ)hoH <-jXK4^aF:&ke&+qI&TTD<L MV\LHmB*n/{}uD)BB q0XR<q22*V`_{4;Z%x7!X5&KS5 RI:(2U13p~7=$#&<1Pv't%v@qSovDZHhLXPY?7N8*,@h48V	
-9 CrF"Kbed	*Y$XM5#HSR2X'*ybvS)A${9adG%/rohB[_xXM#Gb&4cc*av W UdJ~}9[ h ~u%bHC|Y[ RaVdsFJW	yZZw\O0$1YK]FpzN$lxl {%l67v5Xr'gn16C:aM  Vz^WyqR(RI4A]-TDZ"E 1ATS-Jh#aqIMu-3Wh}> V<r	B0k`bbY~YwMyhd
-1MDW!X	`O;YV1et^eX;0\}J|aIE@r9'Xx
-/@CZV`BI;V.M4I#3#C=5)<'XI:cM(>&e CT@1 U,@<> [0
-kQ(fG!JP>~<]z]KZV oz	)mL$mYq4/?2Z*i@/
-]?OG+w#brE)R,mHreO.v=:L"IU"k##hePI <zXxZR#iUUyGUbMMp/c$_>G	mq!q
-X x"x'pdqc:FHUw!>ns*~~<|
-9HLxf*YSx5u_#pz.	{*$#C<d; l8OFFSK-6 O#nmh)~gSg1R]M=7C#I$aIbky+gUb ~
-7 BQ@`z	r7
-1{se|?4\'@:Vu$mim$ (fHI82W	#NB^!EZUJX FmMt9
-PZr8?C-u!w2qQ8RLmU-h7
-vV^6 ^~73V?pvK$$gu'y3HBEy$ <:=vTE4 d!0U>< U fvC]F?T,f$ha,Kc >k$rc Um$=qD@|s59f4 )Nx}{UTI;[>F :|qo	vwx++H3)@wWIg.TVvRy^|r|tC#sTti uC~|L4S h Iq}=fZ&OXo;b>;kX	rG*=%o?Sqv8_=wfGjSe.]0<E=w66f.:)$7
-P_TZ  /V L5l,D$Q|O=xr$f*kaE
-	b-Y"BDo	$'J?.E6<Z^$KQ)w-CyirNvDaA>TE(oT;Z'G)s5MNow&RMETX?H
-)k3LH$B<jRbkE@B~%ZB='R:HHcW?>jO4h"/u&Ralm`VTD%#HZ?EY8~~T4^F{~E?`XEx%hl1(GG /PE&\ `|!}F6CHc-z/%8^HI<FEc`]3%IC,@(ZpDHnj&A}/QO3"7Ik6$ZTdH	p8q{xMt6|lg +VI4"Wn3Ky&Y?Hj}47;Wc]r
-t:T
-w<7spQ3,l 2Ebk	#
-L	Pr>~~gyv34BR@$@$;@=V2+]@RV3s>*,tj'	sH_tb<]4M&bA @d!jG&IlWmW-lEQ?EdcAQ$|LzpA~$JXASA?my bd*V1 2Yv7~z|aiq"zq"vW;>/PeA39HG1!j 	
-rWEW:HDM&-~I<5q+p%s~y|40F,}d5X >?o?& -|F4ZV
-gF\"Tnq=#jzZ_59Gl]mwrlUR?miMAG#<\X,AB G> 	[`%'Bn^>U9AhGf*$zC8i#@hd4Wu.d~X;5-#J*+/O4HcO72zVh5I"w&-.uVKt)"IQ	Z&-yrbFg{%@=tlNoC9}J,\|r10Anv*S>Dy9/o/[u=j=S@f\\~  TSbdy,cH%$(yT2r<\r
-QE5eB%CM
-
-'J:
-A1HGhe`">9%mH;T!TA;/&V\GdPIocvA.Y@{mh(j?J)}155-*@	0M}D\tsTS}G!F)}'|qKO.=)6 st]'%!DL><y O.YY%DrsMPVM~E24#Ly,sfXR.m=E=FsX4B-z8 vncg;EEuiLjF^L|xebrm u_ x&jQevw`gk+`jdg3&Tz'r*s5 D2$* H'c&~PJ'QL|DX"L8#+ ,;g qz4b#16 4,2^SxR(;DR)Av
-<][|0YLb&A&Kd/`y%0#ej@KTJSy@\h*,t-s3Vr	l{(l   (U"SpP3S5WRad6HH&F 152ls.C=ASFJoUV"1tkE
-e4'KA,2}aMFASq\k33*JU5%\2LIegk@IPH"` obKA_lHw|'A4O;AlE4%Z hLEe4g	W#pROC,I.  APxk|}<GU=VLI m]PRtLt?mhM,r	f+%XSe\'I;<~>kAG#^7B\oS?'i-".TR@ >C lMUZ{<  =4RO  3~vlyd5)[!#XXYx?t3db5\<(V95 F_I:v,X%2#<3}IZq"D.^IgU`A?V\SL)FyDc3: - ~`\hZHbH@o$ L_Sy]2aE8Nl1$|(jYZdSG!W&: %kav;@>|H@"\-'gs"Rou$9}_esS(Mmxi~<c75`@5(HFN!ie,(#F77z;ve+:IMBafPq>/\'.NqKjWx	'Bdk_B$@m6h-pIU;	1q@ q$1;vgnGR&VEs1wn]2e0	%S5" _6&G?>*IKy\kEGwVbX;bXVS&F_M!(H cckRJuJZY*2M$<k*~ .B>msTHOq/w1]#i`6?:UkC=t}KoujJ'A2	VMCp<VH \%x ~z&;.F) W7YjNa	E??MV%'tCyz[+m!c==o$PJlqO$'-!qPR~MrzQ
-SY&#|} U l~x+JHQ)O&ce@hj! FIeyoG TC]R8<x?%`U3o-V~x^8tT>{	 B3A#w4<5W_v!l!CArh@$|l/TlpIJbHge*I7@y!-].[HYfe b F-6 ',*8rR8B m~@|
-y<e9"|bmq&tul&gIMv(K
-Atow?vI	?	]-"@I oo	>v/++s"wM,p~TCY<`r].
-F
-R{G('-#(C`>+<eCH/pT 6(L<$GR@c;)XpAWUg*87cm"}Anp/%&M_gOn\dd TH)G( IQ% ^G"Hoixc&pb +%1`^M*	3F(HQh@}0fxWlu+ys6lx|-mrVBOWE{nFq>ycVQ'zqkgni*Q$"cG?i~:dUCh}[F2 ~![:DDy|SR)
-J\p[,"hZBzk63c(Q@INQYLyA.`i6l=B<3Kglp _kAn8RV9c|e\O;S"RR<F1B#U*-1G61[6?J5^,Lxw@d/ >ysn*h6QM/u' ~8I}u	@ZO6n?P)JOB)pm1:nI1DH|c9"R`(U<P{
-ZgrwvfOb 4v4&$NIYS{{Ca+_9F7;2@x`F6>SMf]i{kZ}D7(48:.zGZ$r&of'fmtR|rT$,/OFUE[j 	QPBb:|0e->*X8xF25+C>!,D$)L\I>'BnD3B nhe=dLd(4L)6*`	Q]wR'B^iLL<r,q_}j
-_R[U0A3^j>&N$JJCJ(@H% FC M^;NjI4YFaI|F!TGVe|?*[?7I9Y}BU@"1FLHFRIxRj"hN6Lxk#rN)gG.E))JFT^<
-,[Y9Y]ly\!1;Oqd012-pkI2oo,<I,#0#5(l1;m+ejaiZL)*#8(mh`lry#IbF#U Irn$X,q $4	/s>R3>^~!M[XxDc>Tcy=f$w&zF4E%0RY)T>d&N
-B0J2JaXeF`)x . j|(=nP<O<x9&6Gla'G_{9Iiv!	Ivsd4v	nUW!	 5!#N[H:R 6|$"9bTeRZ'uoQJ uh6LXP]T5srNi H	.7  = ek9koP)TH4<&IXFfYQczieP2q>?Xn:Vxq)0JE $<!Dj8u'Ha*!)0="A+H\'=CNS.Vi:*.d+*+	lmI"8? !ByUCza9e'
-"`,(stG Y_Z^Be".| GBGw3fhU3Lj\"49J(=UO+ >+?@< vm7|[]Hhd!4O9ytxf0%}-?8#bF). Wi^Pls	TGK^;}:LZia"/:!)Hf$WDJ:.6#,hFR8bG|HPM$sBMC
-i|Xp];q\orq)|OzCl+T!6<]Y+JDiL#`$l*T^IbLuvm	y(<W2bdA4: DrX"yJyH.i?J^.N)by%86P&Y{$mEYGE )B~<=:LsDE&c Gxw~jobC.Z?6"]vAeg_^{{W,=6V,^fV
-"JM4rng'cEjijyrXY~^#(Yu_>~vFkm5=GfE>=]"od(U c#N)QHRzhwI*6)>g`9F	!(ir#'.5|&jzX,^H +@5Z,X,(aaT1.Cch+m%m!3/bfLt)lHcv$2UKG*oK8)GYv#uGW<:ldd@]r=	xDJB4DQ;KN*d&hZ,J[N5%DO_vX;{&>r$jWlwQ6~3ebDRQ0BC5Y0|=\0IY$"ofhc\OIP2	+*h
-X;jh $=\L
-![:Nf ;#OAX>6)R\SmZLO)7\_dzaq!=7
-i\fy,v_rE*	+OG!" uzl=R5-Pmyt;0'=qU)p/*9'a6!(e$@}K_u0C>,C!rFrTWIj`xX2jmi %X0[n+x$%MH69.rd&$Z<X&\9uG#=1Tqf
-O>|LrEobD~h v>zwZVLs$O3NL9*"I&q=::&i|]&)XlulD
-;5{;La9BKtGwD$S:Ar4p*\JCfBtHSptZ G?7KMH=Y}32iW8qpCA"7 /woL +>lx['3\XFvX,rO;rV UF}O gp`A`7__k\Cw OM9yr2ddeeYssG-nXenr.c"'5$%kyI=(K:
-'@\ -giI+zA	J4V_^>{ }>c`>~t(iES.\Lvw-K-[>pR*$qiGO?O=F^v~f]v^SvM:PN) ;r:rJVmCcm`yby9n,E7*>1mzVkI#Qc@TFG*HIxO@FN`W
-PBbygbD<)3?usjT&E;l9S'>U&=>[*	::.]oJX$|;14'_0C>t@VSv Q5"30
-Exu agsBj>9.rnAI4I+	JO_k_x}%!
-%^cpWK{jZ|}ndsHW[Or]Av|9*%'n,\Y5<y)LrWnh4?7v-1^~1TF3Y	n(6~v[,Pq[|d4;-&{ -EtfY>i+I]U'8JK  !cUr>_v)sf\ws'fa*2~<I}.L7dFH ck HrbbIN@R*I|<tv@>)P pA"a_dLu&A]R`jNPMgR@9#
-$p8=q "l/jtT9y<YMW6,	 |_6lMv.RC
-Y6P E<~I-ou'd9`fd A^]E`&Ep!x`	pTy?=jX	:O"@I]oAn{yF6L]vhu xcY}j,uAH,'v P
-^bJI%$;Awu<~5ghO<=c
-*0ybj[qM~z dJ TBVkG49<<|r}4%UE~07\RLES42eO?PA$} pEy^8i%/ry?__!MnMcl;j Dhmq jQnVAM8*h^>_P};{{#Rl.tpaM|ygz/ 8J>6:Kn.[<,:O_CJJpw }r.J'4G(jJ<-`R]D@l
- 19 sp5 SXTvDeO2< X=u?vn&>>/oi1HdXQ<G scF`@6"3$xEeM-fU <j3qR; |]1|5*>;ai-*@c]
-x415+_e<?qX$-*a?kK0[mW~s T-^'B@!nFr  XqQnxpjyKyp@6Ic|D$R/u.HFSlH4n\>EFX W>O#8]Z gC#J W(4Q5azyLxEFg_?IZ-*[(r< _NaeTM%*bV}Uq%I=#@
-mQfvYP0;4~E@6o9CRjo_z.Ns~<q<D&& -QVEF Q 	<L,*=R& bD1{2U<HJ{)6JUF6Vi!.Pp$.<Uj|;Hv+EcUaKDc49 n+
-(p 'Ib#L
-GY9yu$B@|FulN<4D4$nI8k'r'!hvvv9&dx(d4+GLLbX,yI<P%gaT"tOjwf--(_`|edFrDyz-pt BbG=q}-${[O;[r#4cBe.%*kv:r|82l	PH}"4P8FgHRX< nxi2$Q<h7d}o< 6bIj:CyVV{ <	RTBI6+5Rlx"|C{j\LEfXxI>Rln
-w?Uzs(FY`]r8f*~'>>NNk(,j`E~:a/H:L#l
-)*JSxb8LH{K]K5\a/Fq)I7VB	SR{@}ori$_fQf;mqnH\\|C$I)$P.X~=+hKjd\''S0"8'ha $0ELr$m N0dhk.&J7)Ra@%I4Qgb
-C$rDx&k}1% C(|_i,QgwuKvqe49VKI<m?'
-Mg@"3cCeWh(HS)#je2O48rg 8LD9JMAyva]c?[DB9cH#.0WK;kE])+@ILFdH~hDV7?mg?xRMx?39SQ-<?nJ#s}F0$|{/.2HgsdEHt%TJG[*yiS%rw"9\,!qbXFh)txy<AYD@>;O1"cF1'BxtRTsi7
-Gm3u]K_7P2IP*&1+R4,Ag~uqaO#$ hm'ZwJ/;W@FGr9'Or)HvHm*RH(KAZ@~	7Z KSk|=
-jH%9W,P_~!K3S/Un|K]ib#1KC$Q^ ~,=_sOL4lL]3	>?^1+@5f]x3h}}w7tf88"<LRC]/gYS0gHITI0y:x#9]N	-4~m,J){_'C@3D"<-LUlL`w<Ay`iQI[<_md |UySj^z^daF.k$Qj[^jU3 *t* _5wCIR!<;!#-h	w(mK
-Zw\/n~lO/"}(siW&|
-8" di] V<q+h*GO"
-Xl of6XE=#0j		Ph-BGz.~ 74QG#fID=	4&Vi}h2/ FJ	@aF:]QpnNcbR<+UmU ]E)Z;48J!G$DYc6rl'ZOi8:l?]^( O?F\=KF32 rbE}//z)q"/kUMa6`,* sh3XH!eV,=&qUn){lq_i)&OOLbafE
-2gSFy~u]	_An\.|UntDm[2Q!oHk~vGHqJ$l^PS
-Id,yyGl|;WvpW<eIDW>l$>e\^'quAnmW~{D+QOw~/z.I#:K8iIHh+kv6Y~cvrKK2ct*R~XzD'`1lHU#j/$mP_d|_BNEA\LE,E@ww2<}e]d]*
-EJ^D'L_Zs
-n/7G[bS-HR3c(@8$=v}c6 x2"$8DH3?W|KV4?Htv93bE)V"|lX$%R=_,e}Wl	#YLH3 quJ9fc?If;~'vI{ ?q{IgJ\@OvtIJPVSU aZeK?RH)H*d6ObRBYqaUAW|PKRJ4p2JTHK+v XBY3fG7B[%q ut_ H-S;GE $|f%'s34l(7! l(~&Y_pl{7`V3OJ34"Z+HR/$A"K#Q;1a=i~>?5J ~d+H~\'f7e59[f 7RM"@YG;[W"yUUVRb6#.OPl,)&!`zW	-u&S$T		~ :9&YZ&v[;9O8g'LSyXO
- `AVkg;B\ G! \l&A> Cb5*p)<m<ZO'$cK"nT@+GC-c6
-Ud`4I=''V;pA0y,,zY*$M pzGz{n)s6\%<{z   ?<;NA1e#RTu[$L9a
-D9 `CAI3<h1h{J.y-S]'R#2 0Ps8j|F-Qf	,l,)?Y]}acf`fH$W'( 7U7+ zv~f<X;%,\r@KC>0;<l&(A$][^3k-Ym< bCVU7U7m {J)w;C;!N=<tI	#	_^]$0E7uy~y~2FX#2r>?\N;'2E6cy]pm>|EwgQ3#Rk	)IER<w>!1:BtYNi	d<k4:9  ^+&SWk) *9"4R/xL1 mhfD2f,?MChGG!TN??ox@U  y*3Ibavhi t2qa24*>~M?E};NWXtHmG.>yBQm"<yVt7}@`eNwU+l'I%5<{C@h XPxSHX v`lx_`8<|p6Q'=A~K+u<U$`	|)y|M UX[o<<x ns xnZF	X!1I$. vjq# RU$ ^yz[xx >UH*:iUQ|!nxSm UyEdqU ]E|qCXf6O?>HbR~9&&%$Xc .\w8sbBRf	WT:)BiU*c!Wk?Zw\sXi~8o&VOqXb2%O
-pD
-+
-DgV)v?rksmv@P!qB 
-ru yvx#.N $R<xC3aE^~|LkO
-7Da_?=0A/&]M#h
-h^pW"R '6<\%+~>`i.=W"F8|g'cJ$k-nx2B@ 1 n<-P_@OBArWk`X6y:[Li? [}1~
-L#o>XJ.SL%HJ@E2MqU>j(@15R<9$HdB"dY`SuL?^+:m**.pz>"vw\^zNI$lyym,XdgarsEKFPUV[^MReXivFDqd'?aFc2r5UH!(*!Sj;@@g<C}JREAR<ZMRTcyUV):F?kir&CcKnvk#I6B4X\75sX>JYmYl{L
-Tz20( Qsf/ ,m	FbA_pH/v,JRdA24%o6`sBG4$1m$2)R!*uaa~Wd,8e9eXwGgb$pZ F%) UA5PmIE`Dy5UIJt%[lc'q&VMg/{?N @`RMKh|;;&,Ls2)\Q"MHzR4<LxHCj WpL1u=;tLkaE	"H&/e!**;O>s~FZi~U(In	zuwxw
-,Jm=&5k,{$>%*qsyebM>t:f.~t$)',ch"Xmdmy~;7w=~Z~]C'Q(\/WzO&KM)H(
-.9/DHifuD8	7"zPD	2onS!I3?)!)])S] UM=L{kwm9k>.+ID97>Y9p" Ok/W0r$77Bus\y	#3lHf\-AN7,LD$hiTmO
-Q[+j%J+ 6Ge:
-BD^I2A)}Xs]=Ra)J)lPIB,civPR<n1Vfv7lXYOI9qcc*3vHZvWHet:}>*_b?z?R[q$Fr=F. <B'Z|&H]/0y l71H$*`]bH:2' R#axRPVo$$4YSm"  ]	"Gy*eF=B]H^I@E GUMUBZH"7$\E$^f7(	7D@Q6xu`3B1\}nv
-</Ym:U#\b7~E8* }esGc3l\)m'L$ Z+ Z=Jpx`n7`[ }HH$?)GA wpi";o}`O,Ex9]'dmJ5q_O\"K9;7mVrY1ZO?K<7yb`)>^t5OR@P$wy${ 4$]Ga^GM[x({,eB-f3xzb#7#xe<YR,x4mByX |D*z ic?fs,p2" vRG<?R|it.$Waxg_nT#aaQ^c#7#Z~Of?"
-R#o?bv~0Y.SD$@Lj`[x48;:T7/74dbA#em4o|u7W'!k1I*T bh$,>}O0soLixoRn(ygup?|nR&Mk,e|T5~@hsA501m.*|~8"dL	QeFMu<l>GVNA"4 (bfZ/b.\(XXBRvdxB~,Xrn(+67Q5E|FZ[Lq@>(@U,H&4 q~|qH E	w<|$Z_ \;A8zSh?Ry<K2
-+HK-(j mPQHKq @hpoy1Yh}U4>CAyz*IOhD0M$2A;  6,ELV})Z+<foChd_?U  _TQ]J" sP H }>xUs^7D69>||Tgecu(UAI	k<QXny-;V2.@TIo4 ' z$~xM;:uU|_>|)<E2td-1~W8r !MY* cPWpx+^?W vy{<\ a,#sp C Y<'S?/UuLI1 wx~]< !	I!km*{C@l"\7
-f)w
-WiP#0n#3?K5)ZN- p"cAx^yxk	?I.B$;7 ~I_}~z>XyQry6MuY-Vh+wlQ#9}m=\~y 6hmOY0_G C5'q?4O:4< up?<f0`	A< fn/#G$ qG ' pWE}2-v0P>||4`U@{~hA?Hd;vWx~:)2!#+q~W?=<md_	h~CtP721"WG #q|xCzY/8HR$cdR8\y9bBH7fyiJ	T/ K! R&:o1>
-fKrPh.QAM*bX7p9>E96) y!`gaijnj5L5;()apT~=s'lzoh>6Zh}G'I&Tb7 IxU+V <'~Q~zsq4a ljPNhe*mU=L'a$.)nHqI|\?	jl+_uOexl
-&!@G<pNqd,Zo~bdH$bq}Mqwd?xgq26FhLe%RxN\=$1EluUE=2?	up4CT:V>2xY}7`C<uY_dL
-ZXlo7 v'|}!.5i5an.gl>zWy1x	7-I68%42eW78I`@R 8ce,KVhr~ie.(!xZ(
-v@`_GE$<*Zmi<6MxR^{{iRv7=gV3e?VWwPC[ ;WUCYkmgf?` +fOE]F1#^"=7O;@ 5_KFL>t6>j
-\cHd+,= l3 5$s!T~ad{M2;4maRe1	K`(wY ?|P@ZCn% KpMs
-$)'m	ndTH~569"XGye=(bDodyC"Yq]( pUjXT'?5]K:A N>+3Dvs'zZyRdnTQ $Vp!yeA&H ;6* y6EAbuxP4hiP=Lqaj-}Fg_T#Y^d7Z HA6~
-1c"@?P5tB6e\)v`_$|Q,cwp)Atyx2 W~8HS$g>g*haoZLonx 7e7 YcT~ )@R\X(,cf_ix EqV.bD CITe;V?oliyu,m21pa0/")I%Ff4R$/tq?ee<2`jZBR" &zoki3N8I>qmC*i@AeDlU@8c
-$H!R-0*o?'I1M3p`L]/MJ f#]T\e}KUy C78.n r`Bf=7[h#& OhLd*\HHE;8 g
-m # '7|k=H/u{MGhIG6\}A;e@
-*#7L XPH$cp.W{Q :5!Oq&mbcs;mj$c	ZbqQ,$rk}]t|nQ`*vuGqD1AH#D32TH~@|t+"d@q\;xO4-yXHA<mm{!R@kLq8zc<x7]Te]r |f[O+iIyB i/F^' &v9*YcATDv)2T	g *(H|ybao^%DW/l3y(P[h$O[Mnc&1U&y@Xtm+!$j9#.H;@ 4><eq`,H.1Qb_O\T=Z[C5\E=1mDN"
-F)c{)wcdQ0Rc,CE}-`<zdhy>Cou[$nV6$rBYF'>o"OjhE @_%f\).19@D%NK\062QIWj,7{ 3#'qN(sz9\ -`m.l5~z54h /3!YL<1YL(<E
-Ti>mmlYz#D+`	m7|>z51UdxAr
-I$:r1$V1aT4[ty<HDyh2p66o H!#VmV#E
-#!Vsc Wt&x6FuX]QMl
-?nivU\0@jL@+P tyh}hlRr)pWSha,q%{o.^<UURLN5/mX `A$ m3?'ML;` Gd7? _ 8eis1n6P6iV2t\H$H 7pmpG5]!6R:Z<>oMN9{
-A;zy2C>|1/v.d#T*FZ#PZ"\R;~l3ak@^BqqmL|+@w@$='r]]65c\E@~Nc$#>$Xsr_6a	]A sD
-{r	~~,th* )dtzq4GJ+1mVrl>DM#&6 $@qk9R+X%D>C$~7`VThqF)V=U&fi1Pl7\XzkeU6j/$pwBf>{aKv_peQJ G_H9tc	)m'hYz>oum6l}D(X2R0h[+:X $?~]:`|Am7eOtI 33HeA>,OZ6=`q@I?`*)$Q6 q`|uP	~6A>/ 1*)/+G  m~*vL9q}'6>H> ZX }x$)n,Er	>>	&y<y|oh(n| g#4'qJ,Qx`/#,S
-y8 ~>C j_xa''h$Z={ r$AYSd`O?q;CP Q!~<H]77d1%^8C`1x^]6i?z5` z8Yhcq *tH`;k\ g(1S[Fcb0$sf?nHy)Cl>95\q5[9
-
-HVXpv9$N[p#	h}G0km`}eH n"7 v,<Q]_i6)'''EeVe$4BnEjEJ8lZ+9y^	A<f+@>I)j `y_>z	)<~|p\*.GLl&5]3HrFx::}pe9Q
-m5	x%eH/y*vg~vWli$i|]94sA?8v>gHmp1SaKTK2pr_QO~@<I_uW.ln5 O}@|E^_!y>kIHVrwM"*pr'xa))*s8R( ]:RB)
-O"A'~ p*zCom+=O7a0eV)$YR"d05_Y{Nhz+wn\\@r%mTE*HC^q3dmk[cLMJEu~#9?Xc/
-ps<#Mz uzs,;G2a< LL1w&BSq"
-vIJqdcSPq"o mS8E.:\)X PQcl|v9H7*$M ^&V;xDT&(d#P&($JlrQXsi=h;`jdER\lvVvA7w Rd	1,Rk0@jM4P7q*)PPtH*{[%\6"Q<8ZBUGTvCEYYVr"JRcZaDEBk+G1aw]>A9a34a!I#B]9d5d'LS3US\ 6(~sT"NFQv1I$LPj mCY Te2afD8rg89Z~&0HP~ejY _4J'u~:ul<tDz?gf^19I)[`_vMn%=5Hs<4xOTTJR2/r::fzoZ `vw63~OOI`qI,M<PCH,+ |~#d@wY:tWZfLY}h8)*h59kr3C[iN{K=*;;Yha! 5YDG11D%qiXcQ+dE8?A-TDII g)l#
-2NY`JTRN(F "B5l ,IWQ,bG4Be\X(y,H"\\6i(+V^((O/^4$fxb1-kV%)YH'p0
-cKJRPI7 a@*?OX$bN|"KfWi1#1?S&	1jVRd'sO#	Sny, Xf<x0,&iAE@BQS`pT,Hi)  `/hNR=fOwU:`v9Qf(v o!}6xPGd 7?Hz5`3%4V19,
-fO;q:O#"#!h3i-@T]MSttRP @6 )[S,Vt eE@..CE
-Fo u{M;/payK0uZacf6Jm`o&8Qm4RZ7s-MPhWVl\	>@t7ov`"fq=9YIdC]f YoD,WHeK@w.m7hQ T3YDi/}LE}y :Z~ HFx.=YXj
-Uqo#kuj2{@2@V-V6xGQy!dcJA<{C{o/cdb5aI~A"f30(e%j[c[*J/F=~sI+yEuk6m/_'Vh'[Ly 19Xw6 72:BjC$I|PrC$=0;H|mGpdCy ,X^ mWlY6xAT2e R2vS#ur42V#y\N^]A z	3M,OCBP>"]DNV,I` IkV{lM	v9Vz4~xsMSvnZ h XG5qY]"{zIXj%C)b*hs=-i2nG> $~~$,5[=@sE9"4*V~vP{R680=0>P+7	'q:L06~yV&2Q`J<G+MXS/Xh <J	r+BNs+95B;$PSCP|uc2P6JnWZ<hdXX(`j2@bp_pm#m	)-Xo['-WT&&dz5XsrH YF:..<2A/Mr0P^/p4E^a,8!;h
-5K25}&LhbV 9wTmoYW71
-dmH,dYXKIl<Eq]m7	>$^,rUu  o|nO2Ll+#H+-vj<|t*H` }E}H@g _0h&G$@>B[p~Au>mlQb~|7}o#1%B7~~GIPT7DjQ 
-_$h@XGo' J p6?
-!` rh4K3DYX%><;m6Q3oO/8F(P%.v[7dXYTno3h@.x XUB}rw8'ki`0<~l*I'>qH  "@$xm7?D< 6k`nN@ERN&\AQ6o uA<+?P"G^x7}< W}''s6#V5c|wrh|x~'PHu9jO_ <	7 **o]ly?A`j4	?o`j} qcyc@>>.+m<u,5?9u@(B(8?:,xsklM Z,X(^| sEso /u
-`N
-!7J"6tX$?[Cw
-@$},ll 9>kF7@WEY
-JW PDl&Jx)~9Iu-bEQ-+~UY7d+n}9 swMZ5nFEW. umV(r<_y@r\o#tctjI:K"P _Ps7`
-w r	< ?{:Uv"XU@diSn`| EpN^"]@&<
-*`#_ KxUx%VK; F 
-4x|_C`m'c_j@%_l	i7\{~W')XI n-Cz/pF0t~llt aTev-,;'?H0s]ZO$q&6V-,(|	#@~ TdcwRI1I'Iy{/u8'WR|obz.>ms*$vcce{EAXzKZ1HtLa^F>3[9h<VAUQT 4H( |_[IRoj(&9b{OPqBT7Q W)OMkG}[;z|N}WS3udh$d4U|b3=>z}buLqHb	$e_l}lU i**}_;Z}pC$g0YhHG|NR[J N'kJJJ$s2bM$cOL>&X|?UFiIaQ7;7*/EpI$S5}7{w|"-<(	_m_>/-MMI|>&?,RR bA"0c}7r{+~H +n ,~b>P, 5Y_x;$+*)|&u{zA/$ \.ba-SKT1.&mm1m\@:fn/'W(? Wd(&#z$n2ljyDcEXpyCB	uSwBF#rQ>o?56C)6Ixsm-}
-Wm`^XKW0?)!E84
-<7Nwd~A2K#m3x&
-~n=Ev.NLK0c
-4~9;L'."Hw1$ I:1Jj.;KMMa7v<Iy;,<'6.8\u"F*e6Hn gbwf.PGwB(jjZ.Lx58], N]N4,H7;<rX_zw9I[n>@6V_l{g!~V=N]Kv/=Z$ m?`{#0EWI% k7JrEmX"lWJ2K`=:4$: T{.Vj)%1N6|.D3+K g"g-*~}R|INCFI?dlXQbE%oxR`^6^Ih+LwI[nnqXruWN7  X	u"G*;v,@6M&:	QQ	Yx)k#D!R|O /}%FDG( a4V,$cHWHyPXHY$kn
-4@ NEt_r_]fD9N$"sWIon0']:n9	\Y6mYdRw7.-+i;.QB}2x2
-& I-n,*{x(#l?ma:C_<5V(_o*,bEVPJTv.-
-/l//T> IZ9:f(Di(K4^ B7f(
-+?'kSb;-hO0,{9=2c`,}_"W7gBK*&5G%O.~(UdNv	[S77=o&gb[X(7 @;7 XCz|,P
-8`!#9]N.|YrT1 _UM3Z-"PXQ&CB\~/RR+cc1mCB) '9nC!YR,s@  }sA+_U1 1o9A8rm9xX7w qV>r88|Q/;[ay<b_Vt<*l	Ao >y(Ef m`G$H$,7>Z|p9z~v1pmTK}@_Go$YEQ`|JiE48 G?,.>]l?|PBT(ljL,	A,0GXn7kj&@!!g!m7Xx& Y&&9e$x"Bn~>7 $Y?s8#PXmVdrA ,^*C3},IO Q+XHpo<@]~$Zm`j5}QMM|yaD}1
\ No newline at end of file
diff -Naur libAfterImage-1.20/apps/test.ttf root/graf2d/asimage/src/libAfterImage/apps/test.ttf
--- libAfterImage-1.20/apps/test.ttf	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/test.ttf	1970-01-01 01:00:00.000000000 +0100
@@ -1,545 +0,0 @@
-     0  OS/2y:4     Ncmap8    Jcvt $$E  8   fpgm^     dglyfr%    hdmxn  H  head_      6hhea8q  4   $hmtx    dkern
-w    loca G     hmaxp  X    namezk  x  postH    prep_!          K3_<      N    N>A            A_  >                             @ 
-                 `                 G       "\                     =  	    `  	  -  	  N  	  D~  	    	  8  	  JFrom Doug Miles' Black Chancery bitmap font. Outlines by Earl Allen & Doug Miles. Public domain. F r o m   D o u g   M i l e s '   B l a c k   C h a n c e r y   b i t m a p   f o n t .   O u t l i n e s   b y   E a r l   A l l e n   &   D o u g   M i l e s .   P u b l i c   d o m a i n .BlackChancery B l a c k C h a n c e r yRegular R e g u l a rAltsys Metamorphosis:BlackChancery A l t s y s   M e t a m o r p h o s i s : B l a c k C h a n c e r yBlackChancery B l a c k C h a n c e r yAltsys Metamorphosis:4/30/93 A l t s y s   M e t a m o r p h o s i s : 4 / 3 0 / 9 3BlackChancery B l a c k C h a n c e r y  @ ,vE %E#ah#h`D-,E %E#ah#h`D-,  8@68-,  @868-,Fv Gh#Fah X %#8%6e8Y-@AA@@  EvEhD F + F +F +F +F +F +F +	 F +
- F +F +F +F + F + F + F +F +F +F + F + F +F +F +F +F +F +F +F +F + F +!F +"F +#F +$ F +%F +&F +'F +(F +)F +*F ++F +,F +-F +.F +/F +0F +1F +2F +3F +4 F +5F +6F +7F +8F +9F +:F +;F +< F += F +> F +?F +EhDEhDEhDEhDEhD     4  A   =@A A@@   Fv/7 ?<?</<</<< <<10 +3!'!44A4'  :iJ 
-  1@ A  ]2x v?v?  99..10+.54>2#"&'>J :&@Ti6N.#
-L1i3a,fZ2	T/N   "  ! C@ @@@ xFv/7 v?<?</</< 99.10"+.5>32.5>32"		N		N"1$oC"1$oC   2 x   D@@
- @@
- @@ @
-A
-	9A @@@ @@@@
-@	@@@@@@@@7Fv/7 ?<?</////////////// /<<?<<......10 +#7#737#73733733#3##?#3 <4+A9! !F! !91+>6 ;F+F(;; V BBBB V ;;vV  n ( \@.A&A>
-A  "@@&&  @/Fv/7 ??/<<<1/ ?<?<? .10)+'5"&'532654'&'&5463572.#"(%U )U8#-A==B_2(g=2"7JYRP4dFN>#9,#$/>SDMO!N#  ,+c;PIY  0  # / ; G n@7@A39A ?A*$AE@#@@ @-@<0@	B@'@6# *5Fv/7 ?<<?<<///<// //.10H+2#"&5462#"&547654&'2#"&546%32654&#"32654&#"1+:*2+:'#C+N!3,0>'1+?    0E3=3J02<
-0	G2:5J0:4!?),%:)%<)+(9)  z + 7 C @F&/A/A	>	>	>/&A&AD	A;A AA/5A 8@#>@@&,@)@2@   #Fv/7 ??////// /?9999 9999 ...10D#+2>54&'2#"'&'#"&5467.546>54&#"3267.',@5F**M]oaCIB2U-(v_vP8(V 0(!5rg+G<=,F/,JC4#<!6g/nT+W>9%AuTM8F1DtJ&N(,nje(VP    v  -@ @ xFv/7 v??/< 9.10+.5>32v		N"1$oC  D   !@ 	@] x v?v?/ ..10+.5467C^NW#'#2odC,uo   'C   !@ 	@ ]x v?v?/ ..10+>54&+C^NW#'#2odC,uo  %    @v}qX*!22!!&!j>Aih@?7Anm9;AeC"!Aut2Q6@@?>DC@;ed@mh@jiML@]\  ]U!x}Fv/7 v?v?/<<<</<</<<</<</<<< ?<<<</<<?<<?<<<<<< 99 ..........10}+>5&52653"&#";2767&'&#"3633#4&#54'&'.'676=4'&'"#52653267.+"&'&'>732767.##4&#53367654'&'67632654&#"
-
-
-%,#
-!	
-	"%
-$,"%*"
-!
-	"#		$*&
-/#('$"!
-%,%	
-	"- 
- 		
-
--			 
-$-"*
-)%,%!"	
-
-#"'&   .  > F N V ^ f @I<3"W?<3G S	",	cA_A 6	A)(7,%e@a@/QI@UM]@YA@E@9%KO.YFv/7 ??/<<<///<<// ?<<<?? ..........10gY+2673267.#".#">54&+">54'&'32654&'"5432'"5432"5432'"54327"3254!3.+((,+6
-!6.'*.*7" 3)35,&
-&,+14)1"P*   -|  _  5@ @@ ]xFv/7 v?v?/ 9910+7>54&'>x42.!_04%A!+   O >  @ ] !x v?v? ..10 +7>7O~('xL&Q"   #  ` 	 !@   1x v??  9910
-+72.'>w6S%	=`.SE  &  6@ @@ @   Fv/7 ?<?<// .10+3#x22     -@AA @@	 	Fv/7 ??// 10	+2#"&54632654&#"R]TP`,.K*46A,4vW[wZZNH8QF  (     0@ 
-	@  Fv/7 ?<?/<<  ...10+#67654#">#?(6   $ L@"A%	AA @@@" Fv/7 ?<?/// <9 ..10%+223267#%47>54&#".546LY1Lo!5D?%2>0e@G4	"!%C8+^1,3/!"+#'7  " $ Q@%"	"A%A AAA@ Fv/7 ??</ /< ......10%+3632#"&532654&#">7#">HL^Y? !*5C=5@,*""[Q| oTJJI+,#hASe$)53   &   P@&AA @ @ Fv/7 ?<?//<< ?<<<< ...10+267##>=#6673j>'=(H/#+f$y
-
-y7x74  ' $ K@"  A%"AAA	@]	Fv/7 ?v?/ /?<?9...10%+7>32#"&532654&#"23267#"a3,_g|l]3v7:6bF'<,n&FX!zu/qaPjl_XSEnVB
-Q#      :@ AA@@  ]Fv/7 ?v?// /9.10 +>32#"&54632654&#"N`bF2\ev\ooHc<$0@?/E0L  eQY_yHEs04Ns>   7@A@	 @	]"Fv/7 ?v?/ ?<<...10+#"&5467!">;267.4"!T\())U=8-C>*D$y?\[ @IgAG  ~p  " . \@+	,,,,A&A A @)@#@@ Fv/7 ??///</ ?99 99.10/+2#"5467.546>54&#"32654&'JB2@3ew[8<'%\.D,.?* +W1!#DD%pO30/,\RLSFH*&I9W3c0U"65GOP$/XI$/    7@AA 
-
-@@ 8xFv/7 v??// .10+2>54&#""&546_Yx6\FR+3icq{kozf}v5%AWi\l   ( G   G@ 
-A A
-@ 1x
-Fv/7 v??/<< 9< 9910
-+2&'&'>2.'>|
-A8 ,
-
-AX-,GC	:-A
-"1.,  1| G   L@ 
- A 
-@@ xFv/7 v??// 999 9.10+2&'&'>>54&'>@2! 142.!GB
-	4 404%A!+   _ WE  I@@@   @@ &Fv/7 ?<?</<</ ..10+3#'5CC	    yr   :@ 		AA] (x v?v? /<?< 99 ...10+7>323267#"'>;267#"$FS-0"YED3(UD*(5"[GH1*+
-6q77	   9 V(  N@" @@@ @@ & Fv/7 ?<?</<<// ..10 +3#759KC		   +( . : _@-2/58/5)A;/A5
-A #A  @&@,@8@  5x,Fv/7 v??//<// ?9 9910;,+2326545&'#"&54767654&#""&5462#"&'>EqrU""2
-5B'1?;;@nNEO-5IVw4N.#
-LldQc- B'%7J-/DPCCO=ke]HAd#kGZ1	T/N  {s 1 : n@5#78@" A;5A;A	 A,A&8A2@@@)@/,&)Fv/7 ??//// ?/<..10;)+%"&54?#"&54>332654&#"3267#"&54632%32?"!:X8M'@]^ttCr)-Mgy$<0Gm,.?(5cwJZntt93:E{bq+x   ! * ]@)( "%%(A+A+AA%%@ ] "Fv/7 ?<v?/ /</99 9 .....10++#"'&'&'#"&5467&#">32>7.LkJGFl^'u-(*-#K*'&\!XQ3M.6KRQj1"osiushmDC5%-  % # 3 i@4 $'$A4A43A  'A*@-@0@@!@3$ !Fv/7 ??/</////< <?<<99.104!+72#"&'3467""&5462654&'>54&#,>,c/D0:XpzB"]JM5sryp@2Q|/* <+!sX_uAhp9Y"V~fD2tQ   [  0@AAA @   ??</  ...10+3&'&#"3267#"&546zCGGX`gxr%z%x78/\H]f   &  ) i@3A*A*A)A"
-A
-&@ @)@"@
- Fv/7 ?<?/</<// <?<99<.10*+%!#"&'467""&546!722>54&#$T%d=>Vu~< y<dC0@+!IxelCdzE,i,.  @ 9 o@7&" ."A:4A:A9.
-A  A%+*4@.1@7@ &%7Fv/7 ?<?///</< ?<<<<?9 ......10:7+7!&'&+>32654&#"3267!6765467""&546~eC
-A@FS1aG'*65Xc+1<2KTu\'s#::*=M,$!&)R"[X/o.
-
-%3_/C^_qqs/k   $ ( 2 i@1 
- 
-//A3A#A#&0/AA,A/@)@  ] Fv/7 ?v?// //<<?<<9 9 ......103 +#!267&'#"&546;.#"46323263265!"'}DQAq;#;upct,N2t}\xrHg2:w;D+,e~y^]WX  \J / U@)'!$$A0A0AA!	A A*@-@$  *-Fv/7 ??// ?<?9....100-+23.#"32654&#"46323267##"&5464 mmZoRo3X!iK8c$QI&<5(\FgXW&/0g
-&N)-}e   9 y@='. 4A:A	3&4*& 	@#@+*1@7  '&7Fv/7 ?<?<//<<</<< ? .......10:7+3>754&'!.#!>5!>54&#""&546+7I?"=<>9#!%4().M1+':6iNWoh7(;B01H!w	$'66&2_A2B)NY[{.^mz   m # K@"AA A
-
-@@!  !Fv/7 ?<?<//<< /<...10$!+!!654767#"32632#"&546Q['4[~_P>:HCWa&J+ A(O9h^Jxf#A|]wo    . R@&&A/A A	)A#&@ @,@  	Fv/7 ??<///<< /< ....10/+!#"&54633265467#"3267#"&546M,09j+4#"cws lUSF79S=Y`9'$R{W;e=&ar4-'vQLw>4O9|To    7 C m@72$%2ADAD$AD A9A,A A@A %(=@98! @)(@/@5  5Fv/7 ??<///<</ <? .....10D5+!32654&'4632#".'!>54&#""&546>54&+"(8TRyL?GeRg2$H57%luYgrE5)%LM
-2Oz#tN7!4'Ce;.>**&ehcmui4"		   n < ^@.!!A=A=A=+A 	A7A174'@('@@.@:  #:Fv/7 ??<///<< ? ...10=:+!32654&'>32#".+"6767654&#"3267#"&546o0tw2C0"Oq4B6.ZDD>?6i_5%JK>``,-#(%&%>?F[*aP,3jcMj0FK?gS}z " D Y@*<+$?AE AE+AE.A(5A A 8@B$@2
-  (+Fv/7 ?<<?<//  ........10E++267>32.#"#"'&'.'
-#"&532654&#"#.546EN&!)^,54>Fay]J5CLb=XS0i4(D{"#+=ev'@Aq"tEU1TT5I&(WrN +MaN~lP</.Zf   1 i@3		,A2A2A2A2A A&A ,")@/@@#"  "/Fv/7 ??/<</<</  ........102/+24&'33267#"
-'#>5.#""&546:mD>:(J4GnVGFE@9+I1'$aWZRqmPX,16'e!&-:(33*oVis'`v  !\[   -@AA @	@  	Fv/7 ??// 10	+2#"&54>32654.#"@}l3rV{  > @ p@7 @@4:AAAAAA4A A
-!10:%@*@7@="@*4@ 
-';=Fv/7 ??/<////< ??<9 ......10A=+632#"&532654&#.#"#"&5476765467""&5463?vZ8C-7NdRA)!7<88=&.lk%zvjj+"_h`=M'
-*~B(4>43=/9-$pXf0u  :  9 e@1*$0$0$*A:0AA-A'(7A !A3@@$@  ;Fv/7 ??/// ???99 9 ...10:+23267#"&'#"&5463267.#">32>54.#"276$sQ42jMh{7g5kO#,?"%@+[-"5|~aHH7R()=gR_( _#xCn   U 3 n@7
-/#
-A4)A4A4A#A/1 A7 )@ @&@,10@#0
-,Fv/7 ??/<////< ??<<9 ....104,+#3267#".'2654&#!>5467""&546372v&w=-nL)2:C,$_s}dsCHBK@fpc#8>-D: hZW0fX    * C@"AA "@
-@(@  "Fv/7 ??</// 9 ...10++!.#"#".546732654'&'&546KUY~]Y6j$	vmr$cUL:fJ">|(~2F- xTW0""7Sv  * > \@0, #)A<9876543210/ #AA&@@ @ 
-],Fv/7 ?v?/// ??<< .....10?,+#!2#"&54632>54&#"32654&#"46;
-:726=_~snIgB$H97pqwtkj/dO?2'mA4CbkaJ2H 6'JMk^q^b   o 4 j@5/A5
-AA!)(A /$@$
-@(@,@2  !22Fv/7 ??<///<</ <?< ....1052+332654&'32.#"#5#"&54>7#".546dxihb=m0!01%ToTq;~}7:N^~uQP5
-	 >34aq}.}aBq	sM]  Q , P@&'A-AA! A '@@ @$@*  ?*Fv/7 ??<//// <? ..10-*+332>54&#">32#"&5467#""&546/3M`QaRU>	R&3|TBoPge3W[9ozwXo]E;f  4 = [@+33A>(A .A8+@;5@1  " *x;Fv/7 v?<?<////< / ........10>;+!>7.'!>54&'!&.#"32654'#"&546S!7(%D3^5@P;oGciOJ/"?eQG'C
-L>=]#hP(	0&5?U'=caL=%(Dbi   9 3 i@2 $$. .A4A4A4A(A @@ @$+@1  %1Fv/7 ??//// 999 .......1041+27.'33267#".'#>7.#""&546:_
-!MPG;O!iXc?8&!
->]o8&1]LcT8EcUE\{0!:7T^WN[V|tNiS^(~Ss i ! H@
-A 
-
-@ 
-Fv/7 ?<?/<< 9 .........10"+2.#"!>=4.'!>[j-UKl876-/Qv?$TH_g?3"D1*""
-fm'x   2 e@0**$%@  $A3&%A0.- "AAA@@@  Fv/7 ??/// //?<<<.9 .103+	2#"&546324&#"32654&#"!">3!326Con}bUJqq:<11>:Qo%5~tyR! VdLt/f  %[   =@AA @   Fv/7 ?<?</<< <<....10 +3#3#%DD  .2  6@ @@@    Fv/7 ?<?<// .10 +3#.*E*2l   %[   ?@A A @@  Fv/7 ?<?</<<< <<10 +3#53#%CClb    pV  G@ @  A @@@ ]!Fv/7 ?<v?/// <.10	+#'##>.uv.Vuu   @
-  1 ?<?< ....10 +!!4(    f  @  'x v?? ..10	+"&5432#6`$J%      F@ A!A	A	@@  	Fv/7 ?<?</<</  ...10!+3267#"&=#"&546332675"	=3=T"5x 7K\4,%6=JPC1.o   ]  " C@ "AA
-@" @ 
-Fv/7 ??</<</< ?/..10#+>32#"&546;326=4&#"v2Z $qQ<IM?Z f@+!HSQ'4zguPc@Id:3X7Ab  {  0@AA A	A @  ??/ ..10+2.#"3267#"&546'V4	J'%/Y98(OFa63%
-6-8Q6`O=1hLs     ' N@&A(!AA%A@%$@  Fv/7 ?<?</<</ ? ...10(+%3267"&=#"&5463546;32675"	>3<U"5sLAY h 7K\:3.$6<LQCDHc:1.o      N@#
-
-A AAA @@ Fv/7 ??/ 9 9..10 +23267#"&54667654&#" '3,;%%A(`>YJ##5"#(,!"==rBt""9#'S9+   M@$  AA@ Fv/7 ?<?</<< ?<<<< .....10+#+>5#73546;#"271mHjE5M?O<1r."_AE6;1Mp+     % N@$#	 A&A	@#"@ @Fv/7 ??<//<</ 9 ...10&+#"&5467"&54637326532675"[C57#4aW^HG92+0; 7K\3wP?+V@KCGGPP90X=Z1.o   $ S@' "A%A"A@@  Fv/7 ?<?</<</<< ?/ 9..10%+327#"&=4&#"#46;>32]*7""!H8)N?Z f2[$Q0+bv&<He:TR(     " C@ A A	 @   Fv/7 ??/<<1 ? ..10# +2#"&54623267#"&54#">"<$ 1 (H$#(-&0!)&,'"B >   # I@!
-
-A$AAA !@ 
-Fv/7 ??/<< ? ..10$
-+2#"&532654#">72#"&546q&OL6ZG6$0+"<$6qqgOXbM1$#(-&    J@"A 
-A A@ @ Fv/7 ?<?</<< / .....10 +>;3267#"&'#46;v?d.\C.FZ0
-C!0]98)N?Z fFZT*<z&<He:     3@A
-A@   Fv/7 ??</<< ..10 +46;3267#"&5O?Z f)MHe:.E-'  : i@3+A;74A)A @10@'& + 87 @ #. Fv/7 ?<<?<</<<1/<</<< </< ..10;+4&#"#4#">32>32>32327#"=4&#"
-R;*&?'W0%%[. #6#:T9$i	%V07=@%=e225j") !.Kj%  / T@(A0A0!A
-@*' -! @$Fv/7 ?<?</<</<< / ....100+%327#"&574&#"#4#">32>32q#=!
-R;*&?'W0%?!&*!"i	%V07=@%=e22A.'      -@AA @@	 	Fv/7 ??// 10	+2#"&54632654&#"R]TO^,+K+66A,4vW\wZZRH8QF  & 3 N@$$$!0A *A-@
-3'@ x$Fv/7 v??</<</ ? ........104$+267632#"&'.#">54&#">32654&#"s	'1"Z2!D/#KD
-	JA)-5'"C J!"'mac
-%B
-
-1J+
-'N-b7JB?    ! D@	A@@ 	#xFv/7 v??</<</ ? ......10"+.#"465#"&546;32675"9)$7.@=T"5xW 7K\7"OC=JPC1.o { # A@!!A @ !Fv/7 ??</<< / .....10$!+267632>54&#"4#">h&'10L%9.	R5B-55:'"S$
-/E#!K!R   7 $ M@# AA"AA@	@ ]Fv/7 ?v?<// ?99.10%+.#"#"&53254.546323261 8%%WcLM*V<ERNA<6#?>DP49o4T>B>I?0   J  ?@
- 
-AA @]Fv/7 ?v?/<<  .....10+33267#"&5#>7R/+L';e/5E1?9x  + U@())'A,AA@@$#  )Fv/7 ?<?</<<</<< ? ...10,)+2326=4633267#"&=#"&=4&#">^!J5'	'U&/N+$62!M-#U! ,2;D1%#    B@
-A
-A@@ xFv/7 v??/ ?9 9.10+2.#">32>54&'>y>#/_(,;g-~')5Q1VI=	!]"K''3:   . ^@*),		&,	A&A5A",@ 5xFv/7 v??/ ?<?<9 9999 ...10/+2&'.#">32>7&'&'>32>54&'>:4uLK}Pg'T&(M		&(d2/(D g$."I	-MqD!*   ) ]@+'	""A*A*%A A@	@@" 'Fv/7 ??/// 99 .......10*'+2>54'33267#"&'#>7.#">c<E	6'5H2G+%=);N/(V&='0-'aBRF`K~()[GO	bOYf4   , T@&*!'$*$A-A!
-A*@@'@ Fv/7 ??// ?99 9 ...10-+23267#"&5467.#">32>54&'>zBH9/'+[<NH?9?L
-2U".)($T0 ;1N)4M83B5eK(-Y"G%)95   1 l@6,#$@,A2A2A%$A #"A
-	!(@/ Fv/7 ?<?</<< ?<<<<......102+33267+32767#%467#">;7#""&546C $2(L03""3))E=$@|5*Y/(2-18`4P"
-9{#8-   1*  :@
- A@@ ]
-#xFv/7 v?v?/< ...10+"&=4&#26=46*H)"5Cp""q'V*"XLL`#./JXZH!0  : t  @@   8 ?<?</<< 10 +3#:::b  @9  5@A@ ]#xFv/7 v?v?/< ...10+3"#67>7.'2""pD@,)HQq2#FZZK,.+SJ,)S'  %2  %@A A	 	9 ??  ....10+23267#"&#"> &"
-30!~!" 82C3>B0@   Gv " . : B v@8 A28;&,>>A;A35)A#A(A>&@,8@2>@/# Fv/7 ?<?</// /<?<?9999 9 .....10C+#"'&'&'#"&5467&#">32>72#"&54632#"&546&<V;98WIi ]'!%;#Jl3/
-aA);n$*<AAV'W^U\
-]T
-
-8e6+Y  G . : B t@7;/ A,/> >A5A) A(A>/@,8@&2@,>@#@ )
-Fv/7 ?<?//// /<?999 9 .......10C+#"'&'&'#"&5467&#">32>7.54632'2654&#"&$Ae<V;98WIi ]'!%;#?c .6'&70,A);n$*-<AAV'W^U\
-NN3!'65'$1(8e6+Y  :[ . i@2
-
-  ..-'&A/A#AA&@ .@ @*@ #"Fv/7 ??</</ ?<?<<9 9 ....10/+.546;&'&#"3267+72#"&'32654&+zw598EOqS}vaX c$1#@2@.`,-%m|G<IS)$*+%     7 @ @?=:%!  ,= !AA2AAA,
-A A$)(2@,/@5@8 %$5Fv/7 ?<?///</< ?<<<<?9 9 .........10A5+7!&'&+>32654&#"327!>5467""&546%2#676.5%$DT{&P8#+*GH(.!.%g<C^Iy5\$$6/?#!iB%Y%#".4DK[Z\&qVgmM;    > 1 C @G	8A"	;A ,ADADADADA >A2 ;A5&A A,")@/@@#"8 ]%/Fv/7 ?v?/<</<</ ???<99 .....10D/+24&'33267#"&'#>5.#""&546723267#"&#">W80.!<)/PW697v4.";'#MFFD[WP&	9*X! =CD[$&* zhh$.h*)!YEUZ iMm^,0A,.B  }   # / A@A'A-A 3$@	*@!@@	Fv/7 ??<//// ?<100	+2#"&54>72#"&5432#"&54632654&#"h4<nVt\oDj{ok   v 5 A M @B0AN
-AA"H<A6*)A 0%E@%
-@)@?@9K@E-@3B6"3Fv/7 ??</////<</ ?<<<?< ...10N3+332654&'32&'&#"#5#"&54>7#".546%2#"&54632#"&546^VSN2V'
-''hEnXDZ/fc,/?K=
-c\zA@+h1),LpYb%cN5[\>Jw
-
-   t   ) N@$' A*#A	A	 @'&@ 	Fv/7 ?<?/<<</  .......10*+3267#"&=#"&546372#67632675"	=3=T"5xA5 7K\4,%6=JPC$`%%Jf1.o   f   ) O@%' 'A*#A	A	 @'&@ 	Fv/7 ?<?/<</ ?< .....10*+3267#"&=#"&54637"&543232675"	=3=T"5x#6 7K\4,%6=JPC&`$J%1.o     " , Z@** #A-&A	A A	#@*)@  	Fv/7 ?<?/<</ 9 ........10-+3267#"&=#"&54637.#">732675"	=3=T"5xd&UZ*[)(Y 7K\4,%6=JPCJ**D=<1.o   =  " . 8 `@/ A96A2A	)AA	/@65@ @ ,@&#	Fv/7 ?<?<///<</ << ..109+3267#"&=#"&5463'2#"&54632#"&54632675"	=3=T"5xq	 7K\4,%6=JPC1.o   b  ( 2 g@2&&)  A30A,A	#A A>A	)@0/@ ]	Fv/7 ?<v?/<</ ??<9 ....103+3267#"&=#"&5463'23267#"&#">32675"	=3=T"5x}P'"	9*X! =	 7K\4,%6=JPC,/A,.B1.o    " , 8 b@1  A9&A	*A6A	 A60A#@*)@ 3@-@ 	Fv/7 ?<?///<</ ?< ..109+3267#"&=#"&5463'4632#"&32675"4&#"326	=3=T"5xj6'&77($7D 7K\4,%6=JPC'65''351.o   B{ . r@6&  . ..-'&A/AA#AA@*@ .	  @.#Fv/7 ??/1< ??<<99 9 ...10/+.54632.#"3267#72#"&'32654&+O-h'V4	J'%/Y98'K?$1#@2@eEs3%
-6-8Q6`O<2&$*+%   t   ( W@(
- 
-A)AA#A  &@&@Fv/7 ??/ ?9 9....10)+23267#"&54672#67667654&#" '3,;%%A(`>YJ5##5"#(,!"==rBt$`%%J""9#'S9+  f   ( W@(
- 
-A)AA#A  &@&@Fv/7 ??/ ?9 9....10)+23267#"&5467"&543267654&#" '3,;%%A(`>YJw#6x##5"#(,!"==rBt"a#J%""9#'S9+      + a@-
-)
-A,AAA&A #)@)@Fv/7 ??/ ?99 9 .....10,+23267#"&5467.#">767654&#" '3,;%%A(`>YJ&UZ*[)(Y##5"#(,!"==rBtF**D=<P""9#'S9+   =   ) 6 b@/
-**
-A7*A$AA1A .4@4@@'@!Fv/7 ??</// ?<9 9..107+23267#"&54672#"&5432#"&54667654&#" '3,;%%A(`>YJ##5"#(,!"==rBtO""9#'S9+   t   ?@ A 	@Fv/7 ??/<<1 ? ....10 +23267#"&54#">72#676z 1 (Hr50!)&,'"B$`%%J   f   ?@ A 	@Fv/7 ??/<<1 ? ....10 +23267#"&54#">7"&5432z 1 (HP#60!)&,'"B!`$J%    " M@"	 A-A A @ Fv/7 ??/<<1 ??9 ....10#+23267#"&54#">7.#">7z 1 (H&UZ*[)(Y0!)&,'"BE**D=<    =  ! - I@!(AA +@%@ 	@"Fv/7 ??</<<1// ?< ..10.+23267#"&54#">'2#"&5432#"&546z 1 (H
-0!)&,'"B  b / A q@86??ABAB!A$<A09A3>
-@*' -! @6]Fv/7 ?<v?/<</<< ???</9 .....10B+%327#"&574&#"#4#">32>3223267#"&#">q#=!
-R;*&?'W0%P'"	9*X! =?!&*!"i	%V07=@%=e22A.',/A,.B  t     7@ AA @@		Fv/7 ??// ?..10!	+2#"&54672#67632654&#"R]TO^5+K+66A,4vW\wZZ$`%%JRH8QF  f     7@ AA @@		Fv/7 ??// ?..10!	+2#"&5467"&543232654&#"R]TO^i#6+K+66A,4vW\wZZ!a#J%RH8QF     # E@	AA!A @@		Fv/7 ??// ?99 ..10$	+2#"&5467.#">732654&#"R]TO^&UZ*[))X+K+66A,4vW\wZZE**D=<RH8QF   =   # / A@A'A-A *@$@	@!@	Fv/7 ??<//// ?<100	+2#"&54672#"&54632#"&54632654&#"R]TO^	+K+66A,4vW\wZZRH8QF  b   ) M@$$	AA>!A'A $@@	]	Fv/7 ?v?// ???99 .10*	+2#"&546723267#"&#">32654&#"R]TO^P'"	9*X! =+K+66A,4vW\wZZ,/A,.BRH8QF t + 4 ]@,1.)1)' A5AA@@$#, )Fv/7 ?<?/<<</<< ? ........105)+2326=4633267#"&=#"&=4&#">%2#676^!J5'	'U&/N+$652!M-#U! ,2;D1%#$`%%J  f + 4 ]@,/,),)' A5AA@@$#1 )Fv/7 ?<?/<<</<< ? ........105)+2326=4633267#"&=#"&=4&#">7"&5432^!J5'	'U&/N+$6#62!M-#U! ,2;D1%# a#J%   + 7 k@42)2) ,A8'A,-A/A5A@@$#5 )Fv/7 ?<?/<<</<< ??9 ......108)+2326=4633267#"&=#"&=4&#">%.#">7^!J5'	'U&/N+$6&UZ*[))X2!M-#U! ,2;D1%#D**D=< : + 7 C l@5))' 2ADAA>2A,@@$#A@;/@58, )Fv/7 ?<?<///<<</<< <?< ...10D)+2326=4633267#"&=#"&=4&#">72#"&54632#"&546^!J5'	'U&/N+$6d
-2!M-#U! ,2;D1%#   Dh 0 T@%++(
-A".  %  @  Fv/7 ?<?/<<1 ?<<? ...101+#4&'>7#"&54632.54632>32#"&'*=
-	<
-
-<
-	=V" 	?  ?	 E   f*   -@AA @	@  '	Fv/7 ??// 10	+2#"&54632654&#",89*,56
-"!"!8),77+*8b "!  ,   W@,A 	A6@ @	Fv/7 ?<?</<</ ?<<?<< ...10+532&#267##5"&5463"*([/\1>V(*>ai#0(,,==H168<@@cf]k>LD   u I T @[&RO(	9,AU(A	ALABA3A&AR0+* AIH-,H@I@ *@+-@,@O@(E@0<@6?@6@J@#3 5#Fv/7 ?<?/////////<// ?<<?/ 99910U#+#32654&#"'632#"&'#"&54632&'#73.54632#"&54674&#"33267.#"Zm!4$0;)L"G&&=7* ^=sK<a((,&6U"3762C1$'50/,NB8-ZhKG#.
->2&	  vu / ; O@&#60&A A	)A A	@3@ 9@,@	 #Fv/7 ??//<// ?...10<#+7467.54632#"&#"#"&5463232654.7>54&*kE5q& .%U'(zQS[ +9+.Dz	e6d$=8RXE<!k"#78T?'(@``V1"t*#,;$!$
-(%  % fk  @	  ?? ..10	+2#"&546GW^I4k_aFGXL[FY  #h2  $ 0 U@'+AA%7#A @.@
-
-(@( 
-Fv/7 ??<</<1/<< ? ....101
-+>=".54>;!3254&#"2654&#")&LC*'7:7p,1		.+"-%;2*)Z95\("59k.VR$I-1S   @ d@/  3A0AA#6A03&)@ 9@->@)# )Fv/7 ??///<<< ?< 9 .....10A+.#"#"&'>323265&#"734632&#"&532654&'&546g!K$$)=8&>)NmBM)GA#)q7;e .
-E$Z$-Lk`H5DSW7l;NF(';*@+i  I  R @VG>6' DD D 9"-"'&P:JASDAPAJAA	5-"A;9'3)"&"@0@A@*)@ M@;:#"@-Fv/7 ??/<///</ ?<<??<999 99.....10S+%3267#"'#"&54632.'2654&##6=>7""&546372>54&#"326!33,)%MZ;v%:664H2W;'-26Qa`M=06*17tuu#G &/I}.&wO 382
-/@4,,EE4@@	-</7-m1'rAsuu     1 O@')A2AA	&A, A)#@/@ @	* Fv/7 ??///< ?<?102 +74632#"&2654&#"3&'&#"3267#"&546>ttuo{"$#,0F5OI<:=SXtkusuu=UEL/#.4``ct   .J ) E @w>%$'&@'(@CB+*A% A%?>/.A%9854A	$# A%/
-5(@ )	 65@87@ @E*@+B@DCED)(&% 76
-	+CFv/7 ?<?</</</<</<</<<<<<< <<<<<<.}.6...10FC+#"#526=#3#532>=4&+5373#4&+;#5327>5#"#53wZ^X	
-_GD`w		U nR U   " t  @ ,x v?? ..10	+2#6766t$`%%J   & = 
-  '@@@	 -	Fv/7 ?<?<// 10	+2#"&5432#"&546N=  -   @J @	
-@@A A
-(@@
-@ @].xFv/7 v?v?/</< ?<<?<<...10+3#3!'7#537#5!7[Iv+J[Iv,P@H@v,J@H@v,   ] E L @NB4$! $I +IIBAMAMLA FA9A/9A()A!  A?AE LF@<,+I@6@2
-
- Fv/7 ??///<<<< ?</?<</?999< 99 ........10M+>54&'#"&5467&#">32>7!&'&#'">32654&#"3267(HGf(u&1.*&l3;S?BA@FTl,1aF'+55Xc+1g8BE3.)"!`%x~}t	$+JL&t#::*-=M+%"%(R"[X0n.k^K'   !\[   ) ~@> 
-  !
-@ !! A AA$A@	@'@@!@ @
- 	Fv/7 ?<<?<<////// ??.99 9910*+#"'#7.54>327332654&	.#"uV2#SU@[2_)eBl%As&iGr.[_%$7/rV,*%%i'?),v  5 r   1 i@2% %%  A%AA"A
-A"@@++  @(".0Fv/7 ?<?</1 ?99 99102+32654&#".#"3267#"&54632>32#"'&##*4A<2%DZB+3B;/(?O!M/BZR@/GM1?\Q@.&$-F78CH./F76E?>>iOSg;A>>jNSg   ,    b@3	
-A+A  	@
-	 .Fv/7 ?<?</<<<<1 <?<<<10+%!5!'3##5#53532DDDDzzDz   ^ A @C%%.%946 .ABAB+AA65(A !<A6@454@ @ @9@)(! ?@ 1Fv/7 ?<?//<//< ?<<<<<999 ...10B+.#"3267#"&5463.546322367#3267#"&5#>54&#"H
-,"%/Y98(OFa6i!7a@HX");+N':R05;EP5'Q6`O=1hLs
-7(@3GVA%4F1?1>9;(2,0  N H @H,,5,@5AIAA2A8=</A(A( ACA$=@;<;@' @@@0/('@	@F@!$ 8Fv/7 ??////</< ??<<<<99 ...10I+.#"#"&53254&5463.546322367#3267#"&5#>54&#"1!0))RdKM)W1Goc*U<HX");+N':R3595I$,#@6DQ57lJ?J*eRC)
-7(8;GVA%4F1?1>8<-..2  I/. 0 u@:/.*$A1A1 A1-A,A@	0 @-@!@-+,0/'*Fv/7 ??</<</<</<< ?<<?9 .......101*+7326=3326=3#"&5#"'&'#"&5?/53$9L\/+15M:*@\G0{-*))	7>VVYS2A"$:Ye_   >{  + K@# 	)A A)A#	@ @&@ @ #5&Fv/7 ??// ?9.10,&+"32654&>574&#"#"&'4632#"&54632 4D+)5D+< @=)ME]DTjH,9]xe9>|[:C>YURF*lb>fVR{,   $(  p@,@@A	AA@@	Fv/7 ?<?</</ <<.%T.*0<*06 ...10+#.+	32673#!	!2j, jt;ze -XAiNQv?Uc   (  o@< A	A	 
-@@ 	
-	Fv/7 ?<?</<</<<<<<< <<10+#5!#3!53!3!5vXXXTiTp((((p((   8 @B4.*)
-A9A9A !A87 A0&%A09A)@*@@@%
-@@34Fv/7 ?<?</</<//<</ ?<<< .....109+327653#"&5?/#"&=332>5#"#4>326?+468/2M.9##*&+5Vf"/3u(T*:PLP|Nh:9^V"/*5/ Kl # -@A$A A 	 ?? ......10$+2#"&#"#"&54632274>$-9	+M+#.9,K%@b?rb>%>DT<pf>   2   ) w@>A A) AA"@
-@%@(@@@%()(@"
-Fv/7 ?<?/<<1/</<<< <<10*+%2653!5>54&#"!53;5.54632Q0(M[vbbvYO&2{vxZ&0{Zj}}jZz0&;fyxd;     & 3 k@2#	1  A4'AAA.A	$#A	+1@1 1@  	
-Fv/7 ?<?</<1 <<9 9..104+%#"&5463723267#"&'3267467#"67654&#""EL "5x7E+02&@(`>HP=$LTnU##5" +EDPC*"==W}0*"@p2{""9#'L+!<      ' }@<
- "  @  A(AA"A@	%@ @ @
-	Fv/7 ?<?<///</< ???.99 99 ...10(+#"'#7&546327332654&&#"Y#'T2(LV"2O+6',4\7\
-<Q;wZ1	H8#OF6=G  "/ - 9 s@814.74.(A:(A:.A4A"A @#@%@+@@+7@4] Fv/7 ?v?/<1/ ?9 9910:+"&547>54&#".'463232654&'2"&'>32fgGB -	0:#,8448a?8@-BMsk29+<aZISA)=$!0D(+=G<;F<UTL:?Vb?Ru/8,=   * 
-  1@ A] x v?v?  99..10 +667"&'>32 ;%AUh5
-K.#;1j3a,gX~3O0= R+ 
- g@*@	@A A		@ @
- @
-	5Fv/7 ?<?</</< <...10+##'73R9 =}]'0  & <  @-	@
-
- @A	@]
- 6xFv/7 v?<v?</<<1 /.-B-B-B-B.-B-B-B-B10+7'7'77'hBBBB<BBBB      ;@ A@
-@ xFv/7 v??/<</  ...10+2>54#">72#"&546rV^#C":$6<&T *$#(.&   e    :@	@ 
-]x	Fv/7 v?<v?</<< .....10	+'7'7**QQ*))RR)     e    :@	
-@  ]xFv/7 v?<v?</<< .....10+'7'7'7'EQQ***RV)--   6 _ 	   ;@  
- 1 ?<<?<<  9<<9<<....10+72.'>32.'>32.'>8SN:4 S"0
-
-57S5:_4T>L3T&G3T0L  G " + 3 _@+2&# #//2,A3A(A//@(  Fv/7 ?<?/ /<??99 9 .........104+#"'&'&'#"&5467&#">32>7"&5432&<V;98WIi ]'!%;#Jl3/#6VA);n$*<AAV'W^U\
-]TM;8e6+Y  G " 4 < n@4;2) 288;5A3/A# ,A&A(A88@) ] Fv/7 ?<v?/ /<????99 9 .........10=+#"'&'&'#"&5467&#">32>723267#"&#">&<V;98WIi ]'!%;#Jl3/P&"
-9*X"!<1A);n$*<AAV'W^U\
-]T,0A,.B8e6+Y  }   * F@! A A"A(A 3@	%@
-]	Fv/7 ?v?// ???..10+	+2#"&54>723267#"&#">32654&#"h49P'"	9*X! =unVt\oD|,0A,.B|{ok   s 3 @ n@8# =#AAA9:A*
-A  4A1 !A'&>=@7@-@ * -Fv/7 ??///<< ?<??<<<?9 .....10A-+7!&'&#'">32654&#"327!#"&54>3"32654&dC
-A@GRy 3`F&,66XZ240_=9Cds?I's#::*#>L,$"%)R".p.O~ 0O     ( 4 m@4) 3#3#)#A5 A5)AA0A A&A	-3#@3@	Fv/7 ?<?<// 999 9..105+%#"&546326323267#"&%32654&#"67654&#"bR*O^V0HBe'3,;%%AOx2B+K+66A,4A##5%$(F#)wZZ)&N,!"z(RH8QF""90R:.  ) g?  "@	 A	] !x v?v? /<..10 +7>323267#")"F6	"3!"JA47L)
-N&   G t>  $@ A]!x v?v? /<<..10+%#">3!267"'m6!*(M?6   &n   M@! @@@] xFv/7 v?<v?<// 9999.10+.5467.5467+'#	!+' "5#= &5#=",  +u   M@! @@@ ]xFv/7 v?<v?<// 9999.10+654&'>'654&'>+'$+''u5#<+5#<!+   n  3@ @] xFv/7 v?v?/ 99.10+.54676+' "5#=",  t  5@ @@  ]9xFv/7 v?v?/ 9910+654&'>?,&'5">!+  + ,    B@ AAA
-@
-:Fv/7 ??/<<<<1 /<<10+%2#"&5467!5!'2#"&546 !#1 !# #!,D"!!  ^   @1@@@  @  AA @@  ]xFv/7 v?v?// .Y9b9L?9p.9by9L9p.y.Y?10+77xxxN = , 7 C g@1 *!$;A$ADA!>3A-
-A;*@@'@0@6A@;8-Fv/7 ??</</// <?9 9 ...10D+23267#"&5467.#">32>54&'>'2#"&5432#"&546zBH9/'+[<NH?9?L
-2U".)($
-T0 ;1N)4M83B5eK(-Y"G%)95{ m  * 6 U@&	1&A A 
-	@4@.#@)+ Fv/7 ?<?<//</<< /<9 .......107+2.#"#>=4.'3>'2#"&5432#"&546HU;M{p,+%%@_]jKCBQ6%#{x#z,aU e     6@ @@ @
- Fv/7 ?<?<// .10++3WDQD   f q/8  ) `@+
-$ !A3'A$@ @]0xFv/7 v?<v?</<</<< /<<?<<9 ........10*+7.547'76327'#"''%4&#"326!(H'7=D5'F("(F'9;D5'HYCA[ZBA[ 1">8'H(""(H'5@<(G(##(G?]]?>^]   e   #@ @]x v?v?/< ..10+'7m))RR)    e   #@ @ ]x v?v?/< ..10+'7'EQQ*** v 2 w@>-"A3A3A3A 	A (%A!-,A/.@0,+/@  "!"Fv/7 ?<?/<<</<< ?<<<9...103"+2.#"32327#"5#+>323265#73546Kn%&A4 ! >:nGk*   F5nA 	'?&3@!;L,V&/6;1Yd  4 . n@7A/A",+AA @(&%@+@ 
-Fv/7 ?<?</<<</<< ?<<<<<<? ......10/+27#+>5#735463!#327#"&545467#"r
-71oFjE5kP6G,7V!
-#v."|CS&;1Pm '1,I7'l
-!J#  tHu Q l@2C1&O1=&C:A4#FALN=@. ) I7=@O=,27Fv/7 ??/<<<1/</< ?<</<<?? ........10R7+432>32#"&'>32#"&'#"5467#"&54632.'>7#"&54632.}0
-6		89	6
-2
-8	9;8	A4t:	)".;w5t</69y  G " . 6 f@/5)# )#225/A3&A,A(A22@, Fv/7 ?<?/ /<??99 9 ..........107+#"'&'&'#"&5467&#">32>7.#">7&<V;98WIi ]'!%;#Jl3/p"MQ%R%%NA);n$*<AAV'W^U\
-]T0*)8e6+Y    8 D @F&"?9 9 -?)"AE3AE<ABA-
-A A%*)3@-0@6@B &%6Fv/7 ?<?///</< ?<<<<?999 9 .........10E6+7!&'&+>32654&#"3267!>5467""&546%.#">726%%ESz%P8#+)GOy"'.!.%g<C^I"NP%R%%O]$$6/?#"iBIF'W%#".4DK[Z\&qVgm*0**  G " + 3 _@+2(% (//2,A3A(A//@#  Fv/7 ?<?/ /<??99 9 .........104+#"'&'&'#"&5467&#">32>72#676&<V;98WIi ]'!%;#Jl3/6LA);n$*<AAV'W^U\
-]T!M;8e6+Y   8 D P @F&"  -"AQ3AQK?A9A-
-A A%*)3B@<N@H@-0@6@E9&%6Fv/7 ?<?<///<///< ?<<<<?<9 9 .......10Q6+7!&'&+>32654&#"3267!>5467""&54672#"&54632#"&54626%%ESz%P8#+)GOy"'.!.%g<C^I	]$$6/?#"iBIF'W%#".4DK[Z\&qVgm
-
-   8 A @?<9&"  -9 "AB3ABA-
-A A%*)3@-0@6@> &%6Fv/7 ?<?///</< ?<<<<?9 9 .........10B6+7!&'&+>32654&#"3267!>5467""&546%"&543226%%ESz%P8#+)GOy"'.!.%g<C^I#6]$$6/?#"iBIF'W%#".4DK[Z\&qVgm%M;    # , T@')&) AA A
-
-@@!$ !Fv/7 ?<?//<< /?<<.....10-!+!#654767#"32632#"&546%2#676I )I
-eL@2/:6ENB6;4!>P-SL;`R4cJ`XM;   # / c@.**$-
-A'A-A A
-$
-@@!- !Fv/7 ?<?//<< /?<<9 ......100!+!#654767#"32632#"&546%.#">7I )I
-eL@2/:6ENo"NP%R%%O;4!>P-SL;`R4cJ`X*0**   # / ; _@.A6*A$A A
-
-@-@'9@3@!0$!Fv/7 ?<?<////<< /?<<<...10<!+!#654767#"32632#"&54672#"&54632#"&546I )I
-eL@2/:6EN	;4!>P-SL;`R4cJ`X
-
-   # , T@''$$ AA A
-
-@@!) !Fv/7 ?<?//<< /?<<.....10-!+!#654767#"32632#"&5467"&5432I )I
-eL@2/:6EN#6;4!>P-SL;`R4cJ`X%M;  }   ! 7@ AA 3@	@ 	Fv/7 ??// ?..10"	+2#"&54>72#67632654&#"h45nVt\oDM;v{ok   }   $ =@AA"A 3@	@ 	Fv/7 ??// ? ....10%	+2#"&54>%.#">732654&#"h4"OP%R%&OnVt\oD0**{ok   9  $ 6@" 	A%A   ] ?<v?  ........10%"+46232632#"&#"#"&546A=;DK+<!"$9*@:BECxRDO6V")5$F TXhF|  }   ! 7@ AA 3@	@ 	Fv/7 ??// ?..10"	+2#"&54>7"&543232654&#"h4#6nVt\oDM;{ok   
- 4 = q@9:7:/A>
-AA!)(A /$@$
-@(@,@25 !2Fv/7 ??///<</ ?<<?< .......10>2+332654&'32.#"#5#"&54>7#".546%2#676 _USO1W(
-%( hDoXDZ/ec+/?K5d\zA@+h0),LpYb%cN7X\>JM;     5 A }@?<<66
-0AB
-AA"9A?*)A 0%@%
-@)@-@3? "3Fv/7 ??///<</ ?<<?<9 .......10B3+332654&'32&'&#"#5#"&54>7#".546%.#">7^VSN2V'
-''hEnXDZ/fc,/?K"OP%R%%Oc\zA@+h1),LpYb%cN5[\>J*0**    5 > s@:66 0A?
-AA"*)A 0%@%
-@9)@-@3; "3Fv/7 ??//</<</ ?<<?< .....10?3+332654&'32&'&#"#5#"&54>7#".546%"&5432_USO1W'%( hDoXDZ/fc,/?K#6d\zA@+h0),LpYb%cN5[\>J%M;      5@A 	@ Fv/7 ??/<<1  ..10+23267#"&54#">z 1 (H0!)&,'"B   %V  #@ A		] -x v?v?  ...10+.#">7V&UZ*[)(Y**D=<   >b  '@A	A ],x v?v? ??..10+23267#"&#">P'"	9*X! =X,/A,.B   6A2  @
-   < ?<?< ....10+#532AV   +*f  !@		A ] $ ?v?  ...10+"&'32677G%!U-.LJ*T[21VY   N"   @@ 	$ ??/ 10+#"&546324%"02&#0z&22"&42   N2   -@A	A@ @		> Fv/7 ??// 10 +4632#"&74&#"326N6'&78'#8'65''46&  +     K@!
-  
-AA@@@
-Fv/7 ??</</ <<9 ..10
-+72#"&'32654&+73(5(F7H+1( //*L  6*$   !@	
-$x v?<?< ....10+>32'7>32'F	5	5%+G]%+G  6]     2@AA
- @@ 
-Fv/7 ??<// .10+3327#"&547,#""")"3%    \  #@	A 	] $x v?v?  ...10+.'3267*^,aV(] OE12FQ       d   d   d   d       >    L      \    
-p          `    D       l  $    R  :    Z    p    v  ~    z  ~                  !  "  #  $  %  &n  '  (  )  *f  +`  ,`  -0  .D  /H  /  0  1P  1  2  2r  2  2  3  4<  4  5  6:  6  7  8`  9  9  :l  :  ;  <  =8  >  >  ?v  @0  @  A  B(  C  C  D  E  FT  F  G  Gp  H  I  J  L  M`  N,  O  PR  Q   R  S
-  T  U  V  V  W  X  Y  ZB  Z  [  \n  ]  ^0  ^  _  `J  a  b  b  d  e,  f  f  g<  h  i  j  j  k  m  nj  p  pD  p  q  r  t   t  u  v  x  y  y  z  {^  ||  }  }          4        v        >    .  6        <                    T  V  H          f    x  h  l  @      <      :  `    6      &  j    n    H                                              	
- !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`a bcdefghijklmnopqrstuvwxyz{|}~            .   \ @   ~              1Sx    " & :!""""""""+"H"`"e%                  1Rx      & 9!""""""""+"H"`"d%                                                                                             \ $$$&***JT\|         	 
-                        ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a                       b c  d  e       f     g     h  j i k m l n  o q p r s u t v w x z y { } |    ~                                                   A 4          m :C  2    }     '= %3 .  -J O  # &  (         (  1 _ m 9P +     Q  N  E  n A 6 r !J       n *   % . %    r        >     J 
-^ 1  :^ @ %t t F                             f ,   % 0   .  " &% -h r ! 5% ,h X @ I > $7 %   2   "m % &F F  6   t t     ) G* *    }% +l O be f    v&] t  t         T        % >w 6 +F N[ N& g 6 6 m7  A _VIZr+F} e\' %< V J  qlZ <  ,A2Q \   I   A I     r  , @   ` /  L   } m   1                                                      Alts    A_  A_        	
- 			
-
-
- 
- 	
-			
-				
-	 	 	
-	
-	
-
-	
-	
-
-	
-		
-	 
- 		
-
-
-
-		
-					
-						  	
-		
-
-
-	
-			
-					
-	
-										
-
-
-  		
-	
-		
-	
-
-	
-	
-
-	
-			
-
-
-		
-	
-
-
-
-
-
-
-
-  
-			
-	
-	
-			
-
-
-
-
-			
-		
-
-	
-	
-
-	  
-				
-		
-
-	
-			
-
-				
-
-		
-
-
-  
-
-
-
-
-
-
-
-		
-
-
-						
-  	
-
-			
-
-		
-					
-
-
-
-	
-
-
-	
-	
-  																																		
-
-	
-	
-
-	
-	
-
-					  	
-		
-	
-
-												
-	
-														
-
-
-
-	
-	
-	
-	
-					  	
-
-			
-
-
-
-				
-
-
-
-								
-
-
-
-	
-
-
-
-
-
-
-										
-
-
-
-	
-		
-	
-
-
-
-
-
-	
-		  
-	
-
-		
-	
-			
-	
-
-	
-				
-
-
-		
-
-	
-
-
-
-
-
-
-					
-
-
-
-
-
-			
-	
-	
-
-
-
-
-	
-		  
-	
-
-
-	
-
-
-
-
-	
-		
-	
-
-
-
-
-
-		
-	
-
-
-
-
-
-
-
-
-
-		
-
-	
-		
-			  		
-
-
-
-
-	
-
-		
-
-
-
-
-
-
-
-	
-
-
-
-
-	
-
-	
-	
-	
-	
-        0  $  H %  0 &  ? '   (   )  *  +  + ,  \ -  4 .  f /   0   1  5 3  4  5  6  / 8  f 9  :  ;  e <  u =  : E  F  G   H  I  J   K  & L  0 M  + N  & O   P  " Q   R  S  T   U j X   Y  Z  [  ' \  ]  0      t      x  r  t  e             7 $ / $ I . $ o 0 $  $ $ 7 . % 0 % % 7 % s $ % 7 & 7 0 & $ 7 ' n . '  0 ' i 7 (  $ ( . ( 7 )  . ) @ 0 )  / ) # $ )  7 * O 0 *  $ * . + 0 +  7 +  $ + 7 ,  $ , . , . -+ $ - 7 - 8 0 - . . 0 .  7 .  $ . 0 /  . / M 7 /  / / ) 7 0  $ 0 N . 0 0 0  / 0 E $ 1 0 1 ( 7 1  . 1 7 2 6 0 2  . 2 . 3 $ 3 7 3  0 3  7 4 J 0 4  0 5  . 5 7 5  $ 5 7 6 O 0 6  / 6 6 . 6 Z $ 6 C 7 7 ] $ 7 $ . 7 @ / 7  0 7  0 8 * $ 8 7 8  . 8 . 9 $ 9 7 9  0 9  . : 0 : $ 7 :  $ : 0 ; ) . ; 7 ;  $ ; 7 <Z . < 3 $ < 0 < / < F 7 =  / = ? 0 = $ =  . = Y : D K D + D 5 D ) D 4 D 7 E  < E \ 0 E I 8 E  , E + E  3 E  : E  ) E ) ) F : F 5 F , F + F & F 5 G ) G & G + G 7 G , G : G I H , H ) H D H K H 5 H L H # Y H 4 H Z H : H + H & H 6 I + I  : I ] 7 I  , I  0 I  < I  $ I = I * I & I 3 I  ( I ) J $ J  < J  7 J : J 3 J + J < K o 7 K , K  3 K  8 K 2 : K  0 K N ) K 7 * K  / K 3 + K  6 L < L y 0 L  $ L = L 4 L & L * L ( L ) L % 7 L  : L  % L 5 L 0 3 L  8 L  K L + L  % M  : M v 8 M  2 M % & M - M  6 M $ M  + M  < M  7 M  ( M 0 M  = M  3 M 	 / N ) 8 N  < N x 0 N N * N   : N  % N 	 = N  7 N 3 N  & N  , N  + N  / O @ & O  * O   + O 	 : O  < O  0 O \ 3 O - I O 8 O % 7 O 3 P . 5 P  / P  % P  < P 3 8 P  + P 7 9 P  , P  ' P ) 0 P . ( P - P  2 P % ' Q ! 5 Q  2 Q $ , Q  8 Q  - Q  0 Q . 9 Q  3 Q . + Q 7 < Q 3 / Q  & R 3 R . R 1 R : R + R ; R 5 R , R 4 R K R = R % R $ R ) R = S 3 S . + S ) 0 S  - S   5 S  8 S  ' S ) , S  ) S % < S 7 9 S  : S   $ S 1 2 S % / S M ( S 3 T : T 1 T ) T 9 T + T 5 T = U ( U 3 U . 6 U ) U . + U ) 9 U  / U  2 U d U U B < U ( : U 	 0 U  , U 	 5 U  - U  ' U  8 U  3 V  0 V  : V * V  ( V  = V 	 + V  1 V 6 W = W 7 W  < W J 5 W  & W * W : W ) 3 W ( ) W  ; W . W & X = X ' X  ) X ) 5 X P : X F * X + X . < X I . X ; X 3 X . / X  ( X 6 X 2 X  9 X  - X  ) Y  5 Y  ; Y % Y - Y $ & Y , Y 	 ' Y % 2 Y % = Y / Y  6 Y * Y 0 Y + Y ) 9 Y ) 3 Y ) $ Y : Y  < Y . ( Y . Y ' Z . / Z  $ Z ; Z 2 Z % & Z 8 Z  0 Z ( Z . Z* 6 Z = Zu * Z 3 Z . - Z $ , Z 	 9 Z $ % Z + Z @ : Z % ) Z 2 < Z 8 5 Z ! ) [ 6 8 [  : [ ) 3 [ . , [ 	 2 [ % ( [ ' [ % - [ $ < [ @ ; [  / [  6 [ + [ ) 9 [ % & [   * [ 5 [  0 [ 3 9 \  , \ 	 3 \ . / \  $ \ 6 \ . \/ = \ 8 \  - \ % & \ 0 \ f 2 \ % V \ ) \   < \ - ; \ * \ ' \   ( \ % \ + \  : ] ; ]  * ] < ]  - ] 	 0 ] - , ]  ( ]  = ]  . ]  6 ] 	                                   	
- !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~spaceexclamquotedbl
-numbersigndollarpercent	ampersandquotesingle	parenleft
-parenrightasteriskpluscommahyphenperiodslashzeroonetwothreefourfivesixseveneightninecolon	semicolonlessequalgreaterquestionatABCDEFGHIJKLMNOPQRSTUVWXYZbracketleft	backslashbracketrightasciicircum
-underscoregraveabcdefghijklmnopqrstuvwxyz	braceleftbar
-braceright
-asciitilde	AdieresisAringCcedillaEacuteNtilde	Odieresis	Udieresisaacuteagraveacircumflex	adieresisatildearingccedillaeacuteegraveecircumflex	edieresisiacuteigraveicircumflex	idieresisntildeoacuteograveocircumflex	odieresisotildeuacuteugraveucircumflex	udieresisdaggerdegreecentsterlingsectionbullet	paragraph
-germandbls
-registered	copyright	trademarkacutedieresisnotequalAEOslashinfinity	plusminus	lessequalgreaterequalmupartialdiff	summationproductpiintegralOmegaaeoslashquestiondown
-exclamdownradicalapproxequalDeltaguillemotleftguillemotrightellipsisnbspaceAgraveAtildeOtildeOEoeendashemdashquotedblleftquotedblright	quoteleft
-quoterightdividelozenge	ydieresis	Ydieresisfractioncurrencyguilsinglleftguilsinglrightfifl	daggerdblAcircumflexEcircumflexAacute	EdieresisEgraveIacuteIcircumflex	IdieresisIgraveOacuteOcircumflexappleOgraveUacuteUcircumflexUgravedotlessi
-circumflextildemacronbreve	dotaccentringcedillahungarumlautogonekcaron
\ No newline at end of file
diff -Naur libAfterImage-1.20/apps/test.xml root/graf2d/asimage/src/libAfterImage/apps/test.xml
--- libAfterImage-1.20/apps/test.xml	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/test.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-<img id="back" src=back.xpm/>
-Preload images.
-<img id="fore" src=fore.xpm/>
-<img id="ice" src="/tmp/IceAlpha-0.5.png"/>
-<img id="redbrush" src="/tmp/RedbrushAlpha-0.5.png"/>
-<img id="root" src="xroot:"/>
-<img id="rose" src=rose512.jpg/>
-<img id="testimg" src="/tmp/testimg.jpg"/>
-
-"Burning Rose"
-<composite id="Burning Rose" op=hue>
-  <composite op=add>
-    <scale width=512 height=384><recall srcid=rose/></scale>
-    <tile width=512 height=384><recall srcid=back/></tile>
-  </composite>
-  <tile width=512 height=384><recall srcid=fore/></tile>
-</composite>
-
-"astext demo"
-<text id="tmp" fgimage="fore" font="test.ttf" point=32>Smart Brown Dog jumps
- Over The Lazy Fox,
- and falls into the ditch.</text>
-<bevel id="astext demo" color="#dfdfdfdf #df8f8f8f" border="10 10 10 10">
-  <composite>
-    <tile refid="tmp" width=100%+32 height=100%+32><recall srcid="back"/></tile>
-    <recall srcid="tmp" x="16" y="16"/>
-  </composite>
-</bevel>
-
-"AfterStep owns!"
-People can't seem to find the images to this one, and it's a strange 
-thing. :)  Anyway, they're on libAfterImage's screenshots page.  Here 
-are direct links, for the lazy:
-http://afterstep.sourceforge.net/afterimage/testimg.jpg
-http://afterstep.sourceforge.net/afterimage/RedbrushAlpha-0.5.png
-http://afterstep.sourceforge.net/afterimage/IceAlpha-0.5.png
-<crop height="512" width="640" id="AfterStep owns! text">
-<text point="32" fgcolor="#ffffffff" font="test.ttf" id="AfterStep owns! text mask">AfterStep  owns jjjijijiji you
-it owns your soul
-and all your relatives will pity you, when you discover just how devoted you are.</text>
-</crop>
-<composite id="AfterStep owns!">
-  <tile width="640" height="512"><img src="/tmp/testimg.jpg"/></tile>
-  <scale tint="#7fffffff" width="640" height="512"><img src="/tmp/RedbrushAlpha-0.5.png"/></scale>
-  <crop width="640" height="512"><scale width="910" height="600"><img src="/tmp/IceAlpha-0.5.png"/></scale></crop>
-  <recall tint="#7fffffff" x=20 y=150 srcid="AfterStep owns! text"/>
-  <bevel border="8 8 6 6" color="#dfdfdfdf #df8f8f8f" tint="#7fffffff" y="6" x="20">
-    <gradient offsets="0.0 0.125 0.25 0.5625 0.8 1.0" colors="#fe007fff #fe00ffff #fe007fff #ff0000ff #ff000000 #ffffff00" height="500" width="600" angle="90"></gradient>
-  </bevel>
-  <mirror tint="#7fffffff" x=20 y=300 dir="vertical"><recall srcid="AfterStep owns! text"/></mirror>
-</composite>
-
-My current testing XML.
-<composite id="test output">
-  <scale width="640" height="512"><recall srcid="testimg"/></scale>
-  <rotate angle=90><scale width="640" height="512"><recall srcid="redbrush"/></scale></rotate>
-  <scale width="640" height="512"><recall srcid="ice"/></scale>
-  <bevel color="#dfdfdfdf #df8f8f8f" border="8 8 6 6">
-    <gradient x=20 y=6 angle=90 width=600 height=500 tint="#7fffffff" colors="#ff007fff #7f00ffff #ff007fff #ff0000ff #ff000000 #ffffff00" offsets="0.0 0.125 0.25 0.5625 0.8 1.0"/>
-  </bevel>
-</composite>
-
-<recall srcid="Burning Rose"/>
-<recall srcid="astext demo"/>
-<recall srcid="test output"/>
-<recall srcid="AfterStep owns!"/>
diff -Naur libAfterImage-1.20/apps/xpm2png.sh root/graf2d/asimage/src/libAfterImage/apps/xpm2png.sh
--- libAfterImage-1.20/apps/xpm2png.sh	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/apps/xpm2png.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
-#/bin/sh
-if test "x$1" = "x" ; then
-  echo "Usage : xpm2png.sh <source_image> [<destination_image>] [alpha_blur_radius]";
-else
-  if test "x$2" = "x" ; then
-    out_fname="$1.png";
-    echo "Using output filename $out_fname"
-  else
-    out_fname=$2;
-  fi
-  if test "x$3" = "x" ; then
-    radius=3;
-    echo "Using default blur radius $radius"
-  else
-    radius=$3;
-  fi
-  ascompose -n -o $out_fname -t png -c 9 -s "<blur horz=$radius vert=$radius channels=\"a\"><img src=$1/> </blur>";
-fi
diff -Naur libAfterImage-1.20/asimage.c root/graf2d/asimage/src/libAfterImage/asimage.c
--- libAfterImage-1.20/asimage.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/asimage.c	2018-12-08 08:18:38.000000000 +0100
@@ -801,7 +801,8 @@
 size_t
 asimage_add_line_mono (ASImage * im, ColorPart color, CARD8 value, unsigned int y)
 {
-	if (AS_ASSERT(im) || color <0 || color >= IC_NUM_CHANNELS )
+   int colint = (int) color;
+	if (AS_ASSERT(im) || colint <0 || color >= IC_NUM_CHANNELS )
 		return 0;
 	if (y >= im->height)
 		return 0;
@@ -815,7 +816,8 @@
 size_t
 asimage_add_line (ASImage * im, ColorPart color, register CARD32 * data, unsigned int y)
 {
-	if (AS_ASSERT(im) || color <0 || color >= IC_NUM_CHANNELS )
+   int colint = (int) color;
+	if (AS_ASSERT(im) || colint <0 || color >= IC_NUM_CHANNELS )
 		return 0;
 	if (y >= im->height)
 		return 0;
@@ -858,7 +860,8 @@
 unsigned int
 asimage_print_line (ASImage * im, ColorPart color, unsigned int y, unsigned long verbosity)
 {
-	if (AS_ASSERT(im) || color < 0 || color >= IC_NUM_CHANNELS )
+   int colint = (int) color;
+	if (AS_ASSERT(im) || colint < 0 || color >= IC_NUM_CHANNELS )
 		return 0;
 	if (y >= im->height)
 		return 0;
diff -Naur libAfterImage-1.20/blender.c root/graf2d/asimage/src/libAfterImage/blender.c
--- libAfterImage-1.20/blender.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/blender.c	2018-12-08 08:18:38.000000000 +0100
@@ -319,9 +319,9 @@
   { "dissipate", 9, dissipate_scanlines, "randomly alpha-blend images"},
   { "hue", 3, hue_scanlines, "hue bottom image same as top image"  },
   { "lighten", 7, lighten_scanlines, "use highest color value from both images" },
-  { "overlay", 7, overlay_scanlines, "some wierd image overlaying(see GIMP)" },
+  { "overlay", 7, overlay_scanlines, "some weird image overlaying(see GIMP)" },
   { "saturate", 8, saturate_scanlines, "saturate bottom image same as top image"},
-  { "screen", 6, screen_scanlines, "another wierd image overlaying(see GIMP)" },
+  { "screen", 6, screen_scanlines, "another weird image overlaying(see GIMP)" },
   { "sub", 3, sub_scanlines, "color substraction with saturation" },
   { "tint", 4, tint_scanlines, "tinting image with image" },
   { "value", 5, value_scanlines, "value bottom image same as top image" },
diff -Naur libAfterImage-1.20/blender.h root/graf2d/asimage/src/libAfterImage/blender.h
--- libAfterImage-1.20/blender.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/blender.h	2018-12-08 08:18:38.000000000 +0100
@@ -197,9 +197,9 @@
  *                        value of top and bottom :
  *                        bottom = (bottom>top)?bottom:top;
  * NAME
- * screen_scanlines()   - some wierd merging algorithm taken from GIMP;
+ * screen_scanlines()   - some weird merging algorithm taken from GIMP;
  * NAME
- * overlay_scanlines()  - some wierd merging algorithm taken from GIMP;
+ * overlay_scanlines()  - some weird merging algorithm taken from GIMP;
  * NAME
  * hue_scanlines()      - substitute hue of bottom scanline with hue of
  *                        top scanline;
diff -Naur libAfterImage-1.20/bmp.c root/graf2d/asimage/src/libAfterImage/bmp.c
--- libAfterImage-1.20/bmp.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/bmp.c	2018-12-08 08:18:38.000000000 +0100
@@ -34,8 +34,14 @@
 
 #include "asimage.h"
 #include "imencdec.h"
+#include "import.h"
+#include "export.h"
 #include "bmp.h"
 
+/* from import.c : */
+FILE* open_image_file( const char *path );
+/* from export.c : */
+FILE* open_writable_image_file( const char *path );
 
 void 
 dib_data_to_scanline( ASScanline *buf, 
@@ -305,3 +311,365 @@
 	return im;
 }
 
+static size_t
+bmp_write32 (FILE *fp, CARD32 *data, int count)
+{
+  	size_t total = count;
+	if( count > 0 )
+	{
+#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
+		CARD8 *raw = (CARD8*)data ;
+#endif
+		count = 0 ;
+#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
+		while( count < total )
+		{
+			data[count] = (raw[0]<<24)|(raw[1]<<16)|(raw[2]<<8)|raw[3];
+			++count ;
+			raw += 4 ;
+		}
+#endif
+		total = fwrite((char*) data, sizeof (CARD8), total<<2, fp)>>2;
+	}
+	return total;
+}
+
+static size_t
+bmp_write16 (FILE *fp, CARD16 *data, int count)
+{
+  	size_t total = count;
+	if( count > 0 )
+	{
+#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
+		CARD8 *raw = (CARD8*)data ;
+#endif
+		count = 0 ;
+#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
+		while( count < total )
+		{
+			data[count] = (raw[0]<<16)|raw[1];
+			++count ;
+			raw += 2 ;
+		}
+#endif
+		total = fwrite((char*) data, sizeof (CARD8), total<<1, fp)>>1;
+	}
+	return total;
+}
+
+Bool
+ASImage2bmp ( ASImage *im, const char *path,  ASImageExportParams *params )
+{
+	Bool success = False;
+	FILE *outfile = NULL ;
+	START_TIME(started);
+
+	if ((outfile = open_writable_image_file( path )) != NULL)
+	{
+		void *bmbits ;
+		BITMAPINFO *bmi = ASImage2DBI( get_default_asvisual(), im, 0, 0, im->width, im->height, &bmbits, 0 );
+		if( bmi != NULL && bmbits != NULL ) 
+		{
+			BITMAPFILEHEADER bmh ;
+			int bits_size = (((bmi->bmiHeader.biWidth*3+3)/4)*4)*bmi->bmiHeader.biHeight;          /* DWORD aligned */
+
+			bmh.bfType = BMP_SIGNATURE;
+		    bmh.bfSize = 14+bmi->bmiHeader.biSize+bits_size; /* Specifies the size, in bytes, of the bitmap file */
+		    bmh.bfReserved1 = 0;
+			bmh.bfReserved2 = 0;
+		    bmh.bfOffBits = 14+bmi->bmiHeader.biSize; /* Specifies the offset, in bytes, 
+							   * from the BITMAPFILEHEADER structure to the bitmap bits */
+			/* writing off the header */
+			bmp_write16( outfile, &bmh.bfType, 1 );
+			bmp_write32( outfile, &bmh.bfSize, 3 );
+			/* writing off the bitmapinfo : */
+			bmp_write32( outfile, &bmi->bmiHeader.biSize, 1 );
+			bmp_write32( outfile, (CARD32*)&bmi->bmiHeader.biWidth, 2 );
+			bmp_write16( outfile, &bmi->bmiHeader.biPlanes, 2 );
+			/* bmi->bmiHeader.biCompression = 0 ; */
+			bmp_write32( outfile, &bmi->bmiHeader.biCompression, 6 );
+
+			/* writing off the bitmapbits */
+			if (fwrite( bmbits, sizeof(CARD8), bits_size, outfile ) == bits_size)
+				success = True;
+				
+			free( bmbits );
+			free( bmi );
+			
+		}
+		if (outfile != stdout)
+			fclose(outfile);
+	}
+	SHOW_TIME("image export",started);
+	return success;
+}
+
+/***********************************************************************************/
+/* Windows BMP file format :   									   				   */
+static size_t
+bmp_read32 (FILE *fp, CARD32 *data, int count)
+{
+  	size_t total = count;
+	if( count > 0 )
+	{
+#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
+		CARD8 *raw = (CARD8*)data ;
+#endif
+		total = fread((char*) data, sizeof (CARD8), count<<2, fp)>>2;
+		count = 0 ;
+#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
+		while( count < total )
+		{
+			data[count] = (raw[0]<<24)|(raw[1]<<16)|(raw[2]<<8)|raw[3];
+			++count ;
+			raw += 4 ;
+		}
+#endif
+	}
+	return total;
+}
+
+static size_t
+bmp_read16 (FILE *fp, CARD16 *data, int count)
+{
+  	size_t total = count;
+	if( count > 0 )
+	{
+#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
+		CARD8 *raw = (CARD8*)data ;
+#endif
+		total = fread((char*) data, sizeof (CARD8), count<<1, fp)>>1;
+		count = 0 ;
+#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
+		while( count < total )
+		{
+			data[count] = (raw[0]<<16)|raw[1];
+			++count ;
+			raw += 2 ;
+		}
+#endif
+	}
+	return total;
+}
+
+
+ASImage *
+read_bmp_image( FILE *infile, size_t data_offset, BITMAPINFOHEADER *bmp_info,
+				ASScanline *buf, CARD8 *gamma_table,
+				unsigned int width, unsigned int height,
+				Bool add_colormap, unsigned int compression )
+{
+	Bool success = False ;
+	CARD8 *cmap = NULL ;
+	int cmap_entries = 0, cmap_entry_size = 4, row_size ;
+	int y;
+	ASImage *im = NULL ;
+	CARD8 *data ;
+	int direction = -1 ;
+
+	if( bmp_read32( infile, &bmp_info->biSize, 1 ) )
+	{
+		if( bmp_info->biSize == 40 )
+		{/* long header */
+			bmp_read32( infile, (CARD32*)&bmp_info->biWidth, 2 );
+			bmp_read16( infile, &bmp_info->biPlanes, 2 );
+			bmp_info->biCompression = 1 ;
+			success = (bmp_read32( infile, &bmp_info->biCompression, 6 )==6);
+		}else
+		{
+			CARD16 dumm[2] ;
+			bmp_read16( infile, &dumm[0], 2 );
+			bmp_info->biWidth = dumm[0] ;
+			bmp_info->biHeight = dumm[1] ;
+			success = ( bmp_read16( infile, &bmp_info->biPlanes, 2 ) == 2 );
+			bmp_info->biCompression = 0 ;
+		}
+	}
+#ifdef LOCAL_DEBUG
+	fprintf( stderr, "bmp.info.biSize = %ld(0x%lX)\n", bmp_info->biSize, bmp_info->biSize );
+	fprintf( stderr, "bmp.info.biWidth = %ld\nbmp.info.biHeight = %ld\n",  bmp_info->biWidth,  bmp_info->biHeight );
+	fprintf( stderr, "bmp.info.biPlanes = %d\nbmp.info.biBitCount = %d\n", bmp_info->biPlanes, bmp_info->biBitCount );
+	fprintf( stderr, "bmp.info.biCompression = %ld\n", bmp_info->biCompression );
+	fprintf( stderr, "bmp.info.biSizeImage = %ld\n", bmp_info->biSizeImage );
+#endif
+	if( ((int)(bmp_info->biHeight)) < 0 )
+		direction = 1 ;
+	if( height == 0 )
+		height  = direction == 1 ? -((long)(bmp_info->biHeight)):bmp_info->biHeight ;
+	if( width == 0 )
+		width = bmp_info->biWidth ;
+
+	if( !success || bmp_info->biCompression != 0 ||
+		width > MAX_IMPORT_IMAGE_SIZE ||
+		height > MAX_IMPORT_IMAGE_SIZE )
+	{
+		return NULL;
+	}
+	if( bmp_info->biBitCount < 16 )
+		cmap_entries = 0x01<<bmp_info->biBitCount ;
+
+	if( bmp_info->biSize != 40 )
+		cmap_entry_size = 3;
+	if( cmap_entries )
+	{
+		size_t ret;
+		cmap = safemalloc( cmap_entries * cmap_entry_size );
+		ret = fread(cmap, sizeof (CARD8), cmap_entries * cmap_entry_size, infile);
+		if (ret != cmap_entries * cmap_entry_size) {
+         if (cmap) free(cmap);
+		   return NULL;
+	   }
+	}
+
+	if( add_colormap )
+		data_offset += cmap_entries*cmap_entry_size ;
+
+	fseek( infile, data_offset, SEEK_SET );
+	row_size = (width*bmp_info->biBitCount)>>3 ;
+	if( row_size == 0 )
+		row_size = 1 ;
+	else
+		row_size = (row_size+3)/4 ;            /* everything is aligned by 32 bits */
+	row_size *= 4 ;                            /* in bytes  */
+	data = safemalloc( row_size );
+
+	im = create_asimage( width,  height, compression );
+	/* Window BMP files are little endian  - we need to swap Red and Blue */
+	prepare_scanline( im->width, 0, buf, True );
+
+	y =( direction == 1 )?0:height-1 ;
+	while( y >= 0 && y < (int)height)
+	{
+		if( fread( data, sizeof (char), row_size, infile ) < (unsigned int)row_size )
+			break;
+ 		dib_data_to_scanline(buf, bmp_info, gamma_table, data, cmap, cmap_entry_size); 
+		asimage_add_line (im, IC_RED,   buf->red  , y);
+		asimage_add_line (im, IC_GREEN, buf->green, y);
+		asimage_add_line (im, IC_BLUE,  buf->blue , y);
+		y += direction ;
+	}
+	free( data );
+	if( cmap )
+		free( cmap );
+	return im ;
+}
+
+ASImage *
+bmp2ASImage( const char * path, ASImageImportParams *params )
+{
+	ASImage *im = NULL ;
+	/* More stuff */
+	FILE         *infile;					   /* source file */
+	ASScanline    buf;
+	BITMAPFILEHEADER  bmp_header ;
+	BITMAPINFOHEADER  bmp_info;
+	START_TIME(started);
+
+
+	if ((infile = open_image_file(path)) == NULL)
+		return NULL;
+
+	bmp_header.bfType = 0 ;
+	if( bmp_read16( infile, &bmp_header.bfType, 1 ) )
+		if( bmp_header.bfType == BMP_SIGNATURE )
+			if( bmp_read32( infile, &bmp_header.bfSize, 3 ) == 3 )
+				im = read_bmp_image( infile, bmp_header.bfOffBits, &bmp_info, &buf, params->gamma_table, 0, 0, False, params->compression );
+#ifdef LOCAL_DEBUG
+	fprintf( stderr, "bmp.header.bfType = 0x%X\nbmp.header.bfSize = %ld\nbmp.header.bfOffBits = %ld(0x%lX)\n",
+					  bmp_header.bfType, bmp_header.bfSize, bmp_header.bfOffBits, bmp_header.bfOffBits );
+#endif
+	if( im != NULL )
+		free_scanline( &buf, True );
+	else
+		show_error( "invalid or unsupported BMP format in image file \"%s\"", path );
+
+	fclose( infile );
+	SHOW_TIME("image loading",started);
+	return im ;
+}
+
+/***********************************************************************************/
+/* Windows ICO/CUR file format :   									   			   */
+
+ASImage *
+ico2ASImage( const char * path, ASImageImportParams *params )
+{
+	ASImage *im = NULL ;
+	/* More stuff */
+	FILE         *infile;					   /* source file */
+	ASScanline    buf;
+	int y, mask_bytes;
+    CARD8  *and_mask;
+	START_TIME(started);
+	struct IconDirectoryEntry {
+    	CARD8  bWidth;
+    	CARD8  bHeight;
+    	CARD8  bColorCount;
+    	CARD8  bReserved;
+    	CARD16  wPlanes;
+    	CARD16  wBitCount;
+    	CARD32 dwBytesInRes;
+    	CARD32 dwImageOffset;
+	};
+	struct ICONDIR {
+    	CARD16          idReserved;
+    	CARD16          idType;
+    	CARD16          idCount;
+	} icon_dir;
+   	struct IconDirectoryEntry  icon;
+	BITMAPINFOHEADER bmp_info;
+
+	if ((infile = open_image_file(path)) == NULL)
+		return NULL;
+
+	icon_dir.idType = 0 ;
+	if( bmp_read16( infile, &icon_dir.idReserved, 3 ) == 3)
+		if( icon_dir.idType == 1 || icon_dir.idType == 2)
+		{
+			size_t ret;
+			ret = fread( &(icon.bWidth), sizeof(CARD8),4,infile );
+                        if (ret != 4) return NULL;
+			bmp_read16( infile, &(icon.wPlanes), 2 );
+			if( bmp_read32( infile, &(icon.dwBytesInRes), 2 ) == 2 )
+			{
+				fseek( infile, icon.dwImageOffset, SEEK_SET );
+				im = read_bmp_image( infile, icon.dwImageOffset+40+(icon.bColorCount*4), &bmp_info, &buf, params->gamma_table,
+					                 icon.bWidth, icon.bHeight, (icon.bColorCount==0), params->compression );
+			}
+		}
+#ifdef LOCAL_DEBUG
+	fprintf( stderr, "icon.dir.idType = 0x%X\nicon.dir.idCount = %d\n",  icon_dir.idType, icon_dir.idCount );
+	fprintf( stderr, "icon[1].bWidth = %d(0x%X)\n",  icon.bWidth,  icon.bWidth );
+	fprintf( stderr, "icon[1].bHeight = %d(0x%X)\n",  icon.bHeight,  icon.bHeight );
+	fprintf( stderr, "icon[1].bColorCount = %d\n",  icon.bColorCount );
+	fprintf( stderr, "icon[1].dwImageOffset = %ld(0x%lX)\n",  icon.dwImageOffset,  icon.dwImageOffset );
+    fprintf( stderr, "icon[1].bmp_size = %ld\n",  icon.dwBytesInRes );
+    fprintf( stderr, "icon[1].dwBytesInRes = %ld\n",  icon.dwBytesInRes );
+#endif
+	if( im != NULL )
+	{
+        mask_bytes = ((icon.bWidth>>3)+3)/4 ;    /* everything is aligned by 32 bits */
+        mask_bytes *= 4 ;                      /* in bytes  */
+        and_mask = safemalloc( mask_bytes );
+        for( y = icon.bHeight-1 ; y >= 0 ; y-- )
+		{
+			int x ;
+            if( fread( and_mask, sizeof (CARD8), mask_bytes, infile ) < (unsigned int)mask_bytes )
+				break;
+			for( x = 0 ; x < icon.bWidth ; ++x )
+            {
+				buf.alpha[x] = (and_mask[x>>3]&(0x80>>(x&0x7)))? 0x0000 : 0x00FF ;
+            }
+			im->channels[IC_ALPHA][y]  = store_data( NULL, (CARD8*)buf.alpha, im->width*4, 
+													 ASStorage_32BitRLE|ASStorage_Bitmap, 0);
+		}
+        free( and_mask );
+		free_scanline( &buf, True );
+	}else
+		show_error( "invalid or unsupported ICO format in image file \"%s\"", path );
+
+	fclose( infile );
+	SHOW_TIME("image loading",started);
+	return im ;
+}
+
diff -Naur libAfterImage-1.20/char2uni.c root/graf2d/asimage/src/libAfterImage/char2uni.c
--- libAfterImage-1.20/char2uni.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/char2uni.c	2018-12-08 08:18:38.000000000 +0100
@@ -811,8 +811,8 @@
 		return CHARSET_ISO8859_1;
 	}else if( name[0] == 'I' || name[0] == 'i' ) /* ISO... or IBM819*/
 	{
-		if( name[1] == 'S' && name[1] == 's' )
-			if( name[2] == 'O' && name[2] == 'o' )
+		if( name[1] == 'S' || name[1] == 's' )
+			if( name[2] == 'O' || name[2] == 'o' )
 			{
 				int pos = ( name[3] == '-' || name[3] == '_' )?4:3 ;
 				if( name[pos] == '8' )
@@ -983,7 +983,8 @@
 as_set_charset( ASSupportedCharsets new_charset )
 {
 
-	if( new_charset < 0 || new_charset >= SUPPORTED_CHARSETS_NUM )
+   int ncs = (int) new_charset;
+   if( ncs < 0 || new_charset >= SUPPORTED_CHARSETS_NUM )
 		new_charset = CHARSET_ISO8859_1 ;
 
 	as_current_charset = _as_supported_charsets[new_charset] ;
diff -Naur libAfterImage-1.20/config.guess root/graf2d/asimage/src/libAfterImage/config.guess
--- libAfterImage-1.20/config.guess	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/config.guess	2018-12-08 08:18:38.000000000 +0100
@@ -1,13 +1,12 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+#   Copyright 1992-2015 Free Software Foundation, Inc.
 
-timestamp='2005-02-10'
+timestamp='2015-01-01'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
@@ -16,24 +15,22 @@
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+# along with this program; if not, see <http://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-# Originally written by Per Bothner <per@bothner.com>.
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
+#
+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
+# You can get the latest version of this script from:
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
 #
-# The plan is that this can be called by configure scripts if you
-# don't specify an explicit build system type.
+# Please send patches to <config-patches@gnu.org>.
+
 
 me=`echo "$0" | sed -e 's,.*/,,'`
 
@@ -53,8 +50,7 @@
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
-Free Software Foundation, Inc.
+Copyright 1992-2015 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -66,11 +62,11 @@
 while test $# -gt 0 ; do
   case $1 in
     --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit 0 ;;
+       echo "$timestamp" ; exit ;;
     --version | -v )
-       echo "$version" ; exit 0 ;;
+       echo "$version" ; exit ;;
     --help | --h* | -h )
-       echo "$usage"; exit 0 ;;
+       echo "$usage"; exit ;;
     -- )     # Stop option processing
        shift; break ;;
     - )	# Use stdin as input.
@@ -104,7 +100,7 @@
 trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
 trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
 : ${TMPDIR=/tmp} ;
- { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
  { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
  { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
  { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
@@ -123,7 +119,7 @@
 	;;
  ,,*)   CC_FOR_BUILD=$CC ;;
  ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac ;'
+esac ; set_cc_for_build= ;'
 
 # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
 # (ghazi@noc.rutgers.edu 1994-08-24)
@@ -136,12 +132,33 @@
 UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
+case "${UNAME_SYSTEM}" in
+Linux|GNU|GNU/*)
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	LIBC=gnu
+
+	eval $set_cc_for_build
+	cat <<-EOF > $dummy.c
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#else
+	LIBC=gnu
+	#endif
+	EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
+	;;
+esac
+
 # Note: order is significant - the case branches are not exclusive.
 
 case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
     *:NetBSD:*:*)
 	# NetBSD (nbsd) targets should (where applicable) match one or
-	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
 	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
 	# switched to ELF, *-*-netbsd* would select the old
 	# object file format.  This provides both forward
@@ -158,6 +175,7 @@
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
+	    sh5el) machine=sh5le-unknown ;;
 	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
@@ -166,7 +184,7 @@
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
-			| grep __ELF__ >/dev/null
+			| grep -q __ELF__
 		then
 		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
 		    # Return netbsd for either.  FIX?
@@ -176,7 +194,7 @@
 		fi
 		;;
 	    *)
-	        os=netbsd
+		os=netbsd
 		;;
 	esac
 	# The OS release
@@ -196,62 +214,34 @@
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
 	echo "${machine}-${os}${release}"
-	exit 0 ;;
-    amd64:OpenBSD:*:*)
-	echo x86_64-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    amiga:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    cats:OpenBSD:*:*)
-	echo arm-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    hp300:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    luna88k:OpenBSD:*:*)
-    	echo m88k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mac68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    macppc:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme88k:OpenBSD:*:*)
-	echo m88k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvmeppc:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sgi:OpenBSD:*:*)
-	echo mips64-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sun3:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
+    *:Bitrig:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-bitrig${UNAME_RELEASE}
+	exit ;;
     *:OpenBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
+	exit ;;
     *:ekkoBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
+    *:SolidBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
+	exit ;;
     macppc:MirBSD:*:*)
-	echo powerppc-unknown-mirbsd${UNAME_RELEASE}
-	exit 0 ;;
+	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
     *:MirBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     alpha:OSF1:*:*)
 	case $UNAME_RELEASE in
 	*4.0)
 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
 		;;
 	*5.*)
-	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
 		;;
 	esac
 	# According to Compaq, /usr/sbin/psrinfo has been available on
@@ -297,40 +287,46 @@
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
 	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	exit 0 ;;
+	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
+	exitcode=$?
+	trap '' 0
+	exit $exitcode ;;
     Alpha\ *:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# Should we change UNAME_MACHINE based on the output of uname instead
 	# of the specific Alpha model?
 	echo alpha-pc-interix
-	exit 0 ;;
+	exit ;;
     21064:Windows_NT:50:3)
 	echo alpha-dec-winnt3.5
-	exit 0 ;;
+	exit ;;
     Amiga*:UNIX_System_V:4.0:*)
 	echo m68k-unknown-sysv4
-	exit 0;;
+	exit ;;
     *:[Aa]miga[Oo][Ss]:*:*)
 	echo ${UNAME_MACHINE}-unknown-amigaos
-	exit 0 ;;
+	exit ;;
     *:[Mm]orph[Oo][Ss]:*:*)
 	echo ${UNAME_MACHINE}-unknown-morphos
-	exit 0 ;;
+	exit ;;
     *:OS/390:*:*)
 	echo i370-ibm-openedition
-	exit 0 ;;
+	exit ;;
     *:z/VM:*:*)
 	echo s390-ibm-zvmoe
-	exit 0 ;;
+	exit ;;
     *:OS400:*:*)
-        echo powerpc-ibm-os400
-	exit 0 ;;
+	echo powerpc-ibm-os400
+	exit ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
-	exit 0;;
+	exit ;;
+    arm*:riscos:*:*|arm*:RISCOS:*:*)
+	echo arm-unknown-riscos
+	exit ;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
 	echo hppa1.1-hitachi-hiuxmpp
-	exit 0;;
+	exit ;;
     Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
 	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
 	if test "`(/bin/universe) 2>/dev/null`" = att ; then
@@ -338,32 +334,51 @@
 	else
 		echo pyramid-pyramid-bsd
 	fi
-	exit 0 ;;
+	exit ;;
     NILE*:*:*:dcosx)
 	echo pyramid-pyramid-svr4
-	exit 0 ;;
+	exit ;;
     DRS?6000:unix:4.0:6*)
 	echo sparc-icl-nx6
-	exit 0 ;;
+	exit ;;
     DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
 	case `/usr/bin/uname -p` in
-	    sparc) echo sparc-icl-nx7 && exit 0 ;;
+	    sparc) echo sparc-icl-nx7; exit ;;
 	esac ;;
+    s390x:SunOS:*:*)
+	echo ${UNAME_MACHINE}-ibm-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
     sun4H:SunOS:5.*:*)
 	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
 	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
-    i86pc:SunOS:5.*:*)
-	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
+    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
+	echo i386-pc-auroraux${UNAME_RELEASE}
+	exit ;;
+    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
+	eval $set_cc_for_build
+	SUN_ARCH="i386"
+	# If there is a compiler, see if it is configured for 64-bit objects.
+	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
+	# This test works for both compilers.
+	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
+		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		grep IS_64BIT_ARCH >/dev/null
+	    then
+		SUN_ARCH="x86_64"
+	    fi
+	fi
+	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
 	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     sun4*:SunOS:*:*)
 	case "`/usr/bin/arch -k`" in
 	    Series*|S4*)
@@ -372,10 +387,10 @@
 	esac
 	# Japanese Language versions have a version number like `4.1.3-JL'.
 	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
-	exit 0 ;;
+	exit ;;
     sun3*:SunOS:*:*)
 	echo m68k-sun-sunos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
 	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
@@ -387,10 +402,10 @@
 		echo sparc-sun-sunos${UNAME_RELEASE}
 		;;
 	esac
-	exit 0 ;;
+	exit ;;
     aushp:SunOS:*:*)
 	echo sparc-auspex-sunos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     # The situation for MiNT is a little confusing.  The machine name
     # can be virtually everything (everything which is not
     # "atarist" or "atariste" at least should have a processor
@@ -400,41 +415,41 @@
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit 0 ;;
+	echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
 	echo m68k-atari-mint${UNAME_RELEASE}
-        exit 0 ;;
+	exit ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit 0 ;;
+	echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-        echo m68k-milan-mint${UNAME_RELEASE}
-        exit 0 ;;
+	echo m68k-milan-mint${UNAME_RELEASE}
+	exit ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-        echo m68k-hades-mint${UNAME_RELEASE}
-        exit 0 ;;
+	echo m68k-hades-mint${UNAME_RELEASE}
+	exit ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-        echo m68k-unknown-mint${UNAME_RELEASE}
-        exit 0 ;;
+	echo m68k-unknown-mint${UNAME_RELEASE}
+	exit ;;
     m68k:machten:*:*)
 	echo m68k-apple-machten${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     powerpc:machten:*:*)
 	echo powerpc-apple-machten${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     RISC*:Mach:*:*)
 	echo mips-dec-mach_bsd4.3
-	exit 0 ;;
+	exit ;;
     RISC*:ULTRIX:*:*)
 	echo mips-dec-ultrix${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     VAX*:ULTRIX*:*:*)
 	echo vax-dec-ultrix${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     2020:CLIX:*:* | 2430:CLIX:*:*)
 	echo clipper-intergraph-clix${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
@@ -458,35 +473,36 @@
 	  exit (-1);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c \
-	  && $dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
-	  && exit 0
+	$CC_FOR_BUILD -o $dummy $dummy.c &&
+	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`$dummy $dummyarg` &&
+	    { echo "$SYSTEM_NAME"; exit; }
 	echo mips-mips-riscos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     Motorola:PowerMAX_OS:*:*)
 	echo powerpc-motorola-powermax
-	exit 0 ;;
+	exit ;;
     Motorola:*:4.3:PL8-*)
 	echo powerpc-harris-powermax
-	exit 0 ;;
+	exit ;;
     Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
 	echo powerpc-harris-powermax
-	exit 0 ;;
+	exit ;;
     Night_Hawk:Power_UNIX:*:*)
 	echo powerpc-harris-powerunix
-	exit 0 ;;
+	exit ;;
     m88k:CX/UX:7*:*)
 	echo m88k-harris-cxux7
-	exit 0 ;;
+	exit ;;
     m88k:*:4*:R4*)
 	echo m88k-motorola-sysv4
-	exit 0 ;;
+	exit ;;
     m88k:*:3*:R3*)
 	echo m88k-motorola-sysv3
-	exit 0 ;;
+	exit ;;
     AViiON:dgux:*:*)
-        # DG/UX returns AViiON for all architectures
-        UNAME_PROCESSOR=`/usr/bin/uname -p`
+	# DG/UX returns AViiON for all architectures
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
 	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
 	then
 	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
@@ -499,29 +515,29 @@
 	else
 	    echo i586-dg-dgux${UNAME_RELEASE}
 	fi
- 	exit 0 ;;
+	exit ;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
 	echo m88k-dolphin-sysv3
-	exit 0 ;;
+	exit ;;
     M88*:*:R3*:*)
 	# Delta 88k system running SVR3
 	echo m88k-motorola-sysv3
-	exit 0 ;;
+	exit ;;
     XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
 	echo m88k-tektronix-sysv3
-	exit 0 ;;
+	exit ;;
     Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
 	echo m68k-tektronix-bsd
-	exit 0 ;;
+	exit ;;
     *:IRIX*:*:*)
 	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
-	exit 0 ;;
+	exit ;;
     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
-	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
-	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
+	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
+	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
     i*86:AIX:*:*)
 	echo i386-ibm-aix
-	exit 0 ;;
+	exit ;;
     ia64:AIX:*:*)
 	if [ -x /usr/bin/oslevel ] ; then
 		IBM_REV=`/usr/bin/oslevel`
@@ -529,7 +545,7 @@
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
 	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
-	exit 0 ;;
+	exit ;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
 		eval $set_cc_for_build
@@ -544,49 +560,54 @@
 			exit(0);
 			}
 EOF
-		$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
-		echo rs6000-ibm-aix3.2.5
+		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
+		then
+			echo "$SYSTEM_NAME"
+		else
+			echo rs6000-ibm-aix3.2.5
+		fi
 	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
 		echo rs6000-ibm-aix3.2.4
 	else
 		echo rs6000-ibm-aix3.2
 	fi
-	exit 0 ;;
-    *:AIX:*:[45])
+	exit ;;
+    *:AIX:*:[4567])
 	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
 	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
 	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
+	if [ -x /usr/bin/lslpp ] ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
 	else
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
 	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
-	exit 0 ;;
+	exit ;;
     *:AIX:*:*)
 	echo rs6000-ibm-aix
-	exit 0 ;;
+	exit ;;
     ibmrt:4.4BSD:*|romp-ibm:BSD:*)
 	echo romp-ibm-bsd4.4
-	exit 0 ;;
+	exit ;;
     ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
 	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
-	exit 0 ;;                           # report: romp-ibm BSD 4.3
+	exit ;;                             # report: romp-ibm BSD 4.3
     *:BOSX:*:*)
 	echo rs6000-bull-bosx
-	exit 0 ;;
+	exit ;;
     DPX/2?00:B.O.S.:*:*)
 	echo m68k-bull-sysv3
-	exit 0 ;;
+	exit ;;
     9000/[34]??:4.3bsd:1.*:*)
 	echo m68k-hp-bsd
-	exit 0 ;;
+	exit ;;
     hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
 	echo m68k-hp-bsd4.4
-	exit 0 ;;
+	exit ;;
     9000/[34678]??:HP-UX:*:*)
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	case "${UNAME_MACHINE}" in
@@ -595,52 +616,52 @@
 	    9000/[678][0-9][0-9])
 		if [ -x /usr/bin/getconf ]; then
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
-                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
-                    case "${sc_cpu_version}" in
-                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
-                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
-                      532)                      # CPU_PA_RISC2_0
-                        case "${sc_kernel_bits}" in
-                          32) HP_ARCH="hppa2.0n" ;;
-                          64) HP_ARCH="hppa2.0w" ;;
+		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+		    case "${sc_cpu_version}" in
+		      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
+		      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+		      532)                      # CPU_PA_RISC2_0
+			case "${sc_kernel_bits}" in
+			  32) HP_ARCH="hppa2.0n" ;;
+			  64) HP_ARCH="hppa2.0w" ;;
 			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
-                        esac ;;
-                    esac
+			esac ;;
+		    esac
 		fi
 		if [ "${HP_ARCH}" = "" ]; then
 		    eval $set_cc_for_build
-		    sed 's/^              //' << EOF >$dummy.c
+		    sed 's/^		//' << EOF >$dummy.c
+
+		#define _HPUX_SOURCE
+		#include <stdlib.h>
+		#include <unistd.h>
 
-              #define _HPUX_SOURCE
-              #include <stdlib.h>
-              #include <unistd.h>
-
-              int main ()
-              {
-              #if defined(_SC_KERNEL_BITS)
-                  long bits = sysconf(_SC_KERNEL_BITS);
-              #endif
-                  long cpu  = sysconf (_SC_CPU_VERSION);
-
-                  switch (cpu)
-              	{
-              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
-              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
-              	case CPU_PA_RISC2_0:
-              #if defined(_SC_KERNEL_BITS)
-              	    switch (bits)
-              		{
-              		case 64: puts ("hppa2.0w"); break;
-              		case 32: puts ("hppa2.0n"); break;
-              		default: puts ("hppa2.0"); break;
-              		} break;
-              #else  /* !defined(_SC_KERNEL_BITS) */
-              	    puts ("hppa2.0"); break;
-              #endif
-              	default: puts ("hppa1.0"); break;
-              	}
-                  exit (0);
-              }
+		int main ()
+		{
+		#if defined(_SC_KERNEL_BITS)
+		    long bits = sysconf(_SC_KERNEL_BITS);
+		#endif
+		    long cpu  = sysconf (_SC_CPU_VERSION);
+
+		    switch (cpu)
+			{
+			case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+			case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+			case CPU_PA_RISC2_0:
+		#if defined(_SC_KERNEL_BITS)
+			    switch (bits)
+				{
+				case 64: puts ("hppa2.0w"); break;
+				case 32: puts ("hppa2.0n"); break;
+				default: puts ("hppa2.0"); break;
+				} break;
+		#else  /* !defined(_SC_KERNEL_BITS) */
+			    puts ("hppa2.0"); break;
+		#endif
+			default: puts ("hppa1.0"); break;
+			}
+		    exit (0);
+		}
 EOF
 		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
@@ -648,9 +669,19 @@
 	esac
 	if [ ${HP_ARCH} = "hppa2.0w" ]
 	then
-	    # avoid double evaluation of $set_cc_for_build
-	    test -n "$CC_FOR_BUILD" || eval $set_cc_for_build
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E -) | grep __LP64__ >/dev/null
+	    eval $set_cc_for_build
+
+	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+	    # generating 64-bit code.  GNU and HP use different nomenclature:
+	    #
+	    # $ CC_FOR_BUILD=cc ./config.guess
+	    # => hppa2.0w-hp-hpux11.23
+	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
+	    # => hppa64-hp-hpux11.23
+
+	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+		grep -q __LP64__
 	    then
 		HP_ARCH="hppa2.0w"
 	    else
@@ -658,11 +689,11 @@
 	    fi
 	fi
 	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
-	exit 0 ;;
+	exit ;;
     ia64:HP-UX:*:*)
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	echo ia64-hp-hpux${HPUX_REV}
-	exit 0 ;;
+	exit ;;
     3050*:HI-UX:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
@@ -690,335 +721,345 @@
 	  exit (0);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
+	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
+		{ echo "$SYSTEM_NAME"; exit; }
 	echo unknown-hitachi-hiuxwe2
-	exit 0 ;;
+	exit ;;
     9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
 	echo hppa1.1-hp-bsd
-	exit 0 ;;
+	exit ;;
     9000/8??:4.3bsd:*:*)
 	echo hppa1.0-hp-bsd
-	exit 0 ;;
+	exit ;;
     *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
 	echo hppa1.0-hp-mpeix
-	exit 0 ;;
+	exit ;;
     hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
 	echo hppa1.1-hp-osf
-	exit 0 ;;
+	exit ;;
     hp8??:OSF1:*:*)
 	echo hppa1.0-hp-osf
-	exit 0 ;;
+	exit ;;
     i*86:OSF1:*:*)
 	if [ -x /usr/sbin/sysversion ] ; then
 	    echo ${UNAME_MACHINE}-unknown-osf1mk
 	else
 	    echo ${UNAME_MACHINE}-unknown-osf1
 	fi
-	exit 0 ;;
+	exit ;;
     parisc*:Lites*:*:*)
 	echo hppa1.1-hp-lites
-	exit 0 ;;
+	exit ;;
     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
 	echo c1-convex-bsd
-        exit 0 ;;
+	exit ;;
     C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
-        exit 0 ;;
+	exit ;;
     C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
 	echo c34-convex-bsd
-        exit 0 ;;
+	exit ;;
     C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
 	echo c38-convex-bsd
-        exit 0 ;;
+	exit ;;
     C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
 	echo c4-convex-bsd
-        exit 0 ;;
+	exit ;;
     CRAY*Y-MP:*:*:*)
 	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*[A-Z]90:*:*:*)
 	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
 	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
 	      -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*TS:*:*:*)
 	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*T3E:*:*:*)
 	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*SV1:*:*:*)
 	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     *:UNICOS/mp:*:*)
 	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
 	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
-        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-        exit 0 ;;
+	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
     5000:UNIX_System_V:4.*:*)
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
-        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-	exit 0 ;;
+	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
 	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     sparc*:BSD/OS:*:*)
 	echo sparc-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:BSD/OS:*:*)
 	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:FreeBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
-	exit 0 ;;
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	case ${UNAME_PROCESSOR} in
+	    amd64)
+		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	    *)
+		echo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	esac
+	exit ;;
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
-	exit 0 ;;
-    i*:MINGW*:*)
+	exit ;;
+    *:MINGW64*:*)
+	echo ${UNAME_MACHINE}-pc-mingw64
+	exit ;;
+    *:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
-	exit 0 ;;
+	exit ;;
+    *:MSYS*:*)
+	echo ${UNAME_MACHINE}-pc-msys
+	exit ;;
+    i*:windows32*:*)
+	# uname -m includes "-pc" on this system.
+	echo ${UNAME_MACHINE}-mingw32
+	exit ;;
     i*:PW*:*)
 	echo ${UNAME_MACHINE}-pc-pw32
-	exit 0 ;;
-    x86:Interix*:[34]*)
-	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
-	exit 0 ;;
+	exit ;;
+    *:Interix*:*)
+	case ${UNAME_MACHINE} in
+	    x86)
+		echo i586-pc-interix${UNAME_RELEASE}
+		exit ;;
+	    authenticamd | genuineintel | EM64T)
+		echo x86_64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	    IA64)
+		echo ia64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	esac ;;
     [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
 	echo i${UNAME_MACHINE}-pc-mks
-	exit 0 ;;
+	exit ;;
+    8664:Windows_NT:*)
+	echo x86_64-pc-mks
+	exit ;;
     i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
 	# UNAME_MACHINE based on the output of uname instead of i386?
 	echo i586-pc-interix
-	exit 0 ;;
+	exit ;;
     i*:UWIN*:*)
 	echo ${UNAME_MACHINE}-pc-uwin
-	exit 0 ;;
-    amd64:CYGWIN*:*:*)
+	exit ;;
+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
 	echo x86_64-unknown-cygwin
-	exit 0 ;;
+	exit ;;
     p*:CYGWIN*:*)
 	echo powerpcle-unknown-cygwin
-	exit 0 ;;
+	exit ;;
     prep*:SunOS:5.*:*)
 	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     *:GNU:*:*)
 	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
-	exit 0 ;;
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-${LIBC}`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
+	exit ;;
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
-	exit 0 ;;
+	exit ;;
+    aarch64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    aarch64_be:Linux:*:*)
+	UNAME_MACHINE=aarch64_be
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+	esac
+	objdump --private-headers /bin/sh | grep -q ld.so.1
+	if test "$?" = 0 ; then LIBC="gnulibc1" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    arc:Linux:*:* | arceb:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     arm*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	eval $set_cc_for_build
+	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_EABI__
+	then
+	    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	else
+	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+		| grep -q __ARM_PCS_VFP
+	    then
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabi
+	    else
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabihf
+	    fi
+	fi
+	exit ;;
+    avr32*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     cris:Linux:*:*)
-	echo cris-axis-linux-gnu
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
+	exit ;;
     crisv32:Linux:*:*)
-	echo crisv32-axis-linux-gnu
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
+	exit ;;
     frv:Linux:*:*)
-    	echo frv-unknown-linux-gnu
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    hexagon:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    i*86:Linux:*:*)
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
+	exit ;;
     ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
-    mips:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#undef CPU
-	#undef mips
-	#undef mipsel
-	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mipsel
-	#else
-	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips
-	#else
-	CPU=
-	#endif
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
-	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
-	;;
-    mips64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    mips:Linux:*:* | mips64:Linux:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#undef CPU
-	#undef mips64
-	#undef mips64el
+	#undef ${UNAME_MACHINE}
+	#undef ${UNAME_MACHINE}el
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mips64el
+	CPU=${UNAME_MACHINE}el
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips64
+	CPU=${UNAME_MACHINE}
 	#else
 	CPU=
 	#endif
 	#endif
 EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
-	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
 	;;
-    ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
-	exit 0 ;;
-    ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
-	exit 0 ;;
-    alpha:Linux:*:*)
-	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
-	  EV5)   UNAME_MACHINE=alphaev5 ;;
-	  EV56)  UNAME_MACHINE=alphaev56 ;;
-	  PCA56) UNAME_MACHINE=alphapca56 ;;
-	  PCA57) UNAME_MACHINE=alphapca56 ;;
-	  EV6)   UNAME_MACHINE=alphaev6 ;;
-	  EV67)  UNAME_MACHINE=alphaev67 ;;
-	  EV68*) UNAME_MACHINE=alphaev68 ;;
-        esac
-	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
-	exit 0 ;;
+    openrisc*:Linux:*:*)
+	echo or1k-unknown-linux-${LIBC}
+	exit ;;
+    or32:Linux:*:* | or1k*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    padre:Linux:*:*)
+	echo sparc-unknown-linux-${LIBC}
+	exit ;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	echo hppa64-unknown-linux-${LIBC}
+	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
+	  PA7*) echo hppa1.1-unknown-linux-${LIBC} ;;
+	  PA8*) echo hppa2.0-unknown-linux-${LIBC} ;;
+	  *)    echo hppa-unknown-linux-${LIBC} ;;
 	esac
-	exit 0 ;;
-    parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
+    ppc64:Linux:*:*)
+	echo powerpc64-unknown-linux-${LIBC}
+	exit ;;
+    ppc:Linux:*:*)
+	echo powerpc-unknown-linux-${LIBC}
+	exit ;;
+    ppc64le:Linux:*:*)
+	echo powerpc64le-unknown-linux-${LIBC}
+	exit ;;
+    ppcle:Linux:*:*)
+	echo powerpcle-unknown-linux-${LIBC}
+	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-ibm-linux-${LIBC}
+	exit ;;
     sh64*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    tile*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    vax:Linux:*:*)
+	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
+	exit ;;
     x86_64:Linux:*:*)
-	echo x86_64-unknown-linux-gnu
-	exit 0 ;;
-    i*86:Linux:*:*)
-	# The BFD linker knows what the default object file format is, so
-	# first see if it will tell us. cd to the root directory to prevent
-	# problems with other programs or directories called `ld' in the path.
-	# Set LC_ALL=C to ensure ld outputs messages in English.
-	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
-			 | sed -ne '/supported targets:/!d
-				    s/[ 	][ 	]*/ /g
-				    s/.*supported targets: *//
-				    s/ .*//
-				    p'`
-        case "$ld_supported_targets" in
-	  elf32-i386)
-		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
-		;;
-	  a.out-i386-linux)
-		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
-		exit 0 ;;
-	  coff-i386)
-		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
-		exit 0 ;;
-	  "")
-		# Either a pre-BFD a.out linker (linux-gnuoldld) or
-		# one that does not give us useful --help.
-		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
-		exit 0 ;;
-	esac
-	# Determine whether the default compiler is a.out or elf
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#include <features.h>
-	#ifdef __ELF__
-	# ifdef __GLIBC__
-	#  if __GLIBC__ >= 2
-	LIBC=gnu
-	#  else
-	LIBC=gnulibc1
-	#  endif
-	# else
-	LIBC=gnulibc1
-	# endif
-	#else
-	#ifdef __INTEL_COMPILER
-	LIBC=gnu
-	#else
-	LIBC=gnuaout
-	#endif
-	#endif
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
-	test x"${LIBC}" != x && echo "${UNAME_MACHINE}-pc-linux-${LIBC}" && exit 0
-	test x"${TENTATIVE}" != x && echo "${TENTATIVE}" && exit 0
-	;;
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    xtensa*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
 	# earlier versions are messed up and put the nodename in both
 	# sysname and nodename.
 	echo i386-sequent-sysv4
-	exit 0 ;;
+	exit ;;
     i*86:UNIX_SV:4.2MP:2.*)
-        # Unixware is an offshoot of SVR4, but it has its own version
-        # number series starting with 2...
-        # I am not positive that other SVR4 systems won't match this,
+	# Unixware is an offshoot of SVR4, but it has its own version
+	# number series starting with 2...
+	# I am not positive that other SVR4 systems won't match this,
 	# I just have to hope.  -- rms.
-        # Use sysv4.2uw... so that sysv4* matches it.
+	# Use sysv4.2uw... so that sysv4* matches it.
 	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
-	exit 0 ;;
+	exit ;;
     i*86:OS/2:*:*)
 	# If we were able to find `uname', then EMX Unix compatibility
 	# is probably installed.
 	echo ${UNAME_MACHINE}-pc-os2-emx
-	exit 0 ;;
+	exit ;;
     i*86:XTS-300:*:STOP)
 	echo ${UNAME_MACHINE}-unknown-stop
-	exit 0 ;;
+	exit ;;
     i*86:atheos:*:*)
 	echo ${UNAME_MACHINE}-unknown-atheos
-	exit 0 ;;
-	i*86:syllable:*:*)
+	exit ;;
+    i*86:syllable:*:*)
 	echo ${UNAME_MACHINE}-pc-syllable
-	exit 0 ;;
-    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
+	exit ;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
 	echo i386-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     i*86:*DOS:*:*)
 	echo ${UNAME_MACHINE}-pc-msdosdjgpp
-	exit 0 ;;
+	exit ;;
     i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
 	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
@@ -1026,15 +1067,16 @@
 	else
 		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
 	fi
-	exit 0 ;;
-    i*86:*:5:[78]*)
+	exit ;;
+    i*86:*:5:[678]*)
+	# UnixWare 7.x, OpenUNIX and OpenServer 6.
 	case `/bin/uname -X | grep "^Machine"` in
 	    *486*)	     UNAME_MACHINE=i486 ;;
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
 	esac
 	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
-	exit 0 ;;
+	exit ;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
@@ -1052,73 +1094,86 @@
 	else
 		echo ${UNAME_MACHINE}-pc-sysv32
 	fi
-	exit 0 ;;
+	exit ;;
     pc:*:*:*)
 	# Left here for compatibility:
-        # uname -m prints for DJGPP always 'pc', but it prints nothing about
-        # the processor, so we play safe by assuming i386.
-	echo i386-pc-msdosdjgpp
-        exit 0 ;;
+	# uname -m prints for DJGPP always 'pc', but it prints nothing about
+	# the processor, so we play safe by assuming i586.
+	# Note: whatever this is, it MUST be the same as what config.sub
+	# prints for the "djgpp" host, or else GDB configury will decide that
+	# this is a cross-build.
+	echo i586-pc-msdosdjgpp
+	exit ;;
     Intel:Mach:3*:*)
 	echo i386-pc-mach3
-	exit 0 ;;
+	exit ;;
     paragon:*:*:*)
 	echo i860-intel-osf1
-	exit 0 ;;
+	exit ;;
     i860:*:4.*:*) # i860-SVR4
 	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
 	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
 	else # Add other i860-SVR4 vendors below as they are discovered.
 	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
 	fi
-	exit 0 ;;
+	exit ;;
     mini*:CTIX:SYS*5:*)
 	# "miniframe"
 	echo m68010-convergent-sysv
-	exit 0 ;;
+	exit ;;
     mc68k:UNIX:SYSTEM5:3.51m)
 	echo m68k-convergent-sysv
-	exit 0 ;;
+	exit ;;
     M680?0:D-NIX:5.3:*)
 	echo m68k-diab-dnix
-	exit 0 ;;
+	exit ;;
     M68*:*:R3V[5678]*:*)
-	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
+	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
     3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
 	OS_REL=''
 	test -r /etc/.relid \
 	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
+	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
+	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
-        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-          && echo i486-ncr-sysv4 && exit 0 ;;
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4; exit; } ;;
+    NCR*:*:4.2:* | MPRAS*:*:4.2:*)
+	OS_REL='.3'
+	test -r /etc/.relid \
+	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
+	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
 	echo m68k-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     mc68030:UNIX_System_V:4.*:*)
 	echo m68k-atari-sysv4
-	exit 0 ;;
+	exit ;;
     TSUNAMI:LynxOS:2.*:*)
 	echo sparc-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     rs6000:LynxOS:2.*:*)
 	echo rs6000-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
-    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
+	exit ;;
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
 	echo powerpc-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     SM[BE]S:UNIX_SV:*:*)
 	echo mips-dde-sysv${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     RM*:ReliantUNIX-*:*:*)
 	echo mips-sni-sysv4
-	exit 0 ;;
+	exit ;;
     RM*:SINIX-*:*:*)
 	echo mips-sni-sysv4
-	exit 0 ;;
+	exit ;;
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
@@ -1126,69 +1181,109 @@
 	else
 		echo ns32k-sni-sysv
 	fi
-	exit 0 ;;
-    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
-                      # says <Richard.M.Bartel@ccMail.Census.GOV>
-        echo i586-unisys-sysv4
-        exit 0 ;;
+	exit ;;
+    PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+			# says <Richard.M.Bartel@ccMail.Census.GOV>
+	echo i586-unisys-sysv4
+	exit ;;
     *:UNIX_System_V:4*:FTX*)
 	# From Gerald Hewes <hewes@openmarket.com>.
 	# How about differentiating between stratus architectures? -djm
 	echo hppa1.1-stratus-sysv4
-	exit 0 ;;
+	exit ;;
     *:*:*:FTX*)
 	# From seanf@swdc.stratus.com.
 	echo i860-stratus-sysv4
-	exit 0 ;;
+	exit ;;
+    i*86:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo ${UNAME_MACHINE}-stratus-vos
+	exit ;;
     *:VOS:*:*)
 	# From Paul.Green@stratus.com.
 	echo hppa1.1-stratus-vos
-	exit 0 ;;
+	exit ;;
     mc68*:A/UX:*:*)
 	echo m68k-apple-aux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     news*:NEWS-OS:6*:*)
 	echo mips-sony-newsos6
-	exit 0 ;;
+	exit ;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
 	if [ -d /usr/nec ]; then
-	        echo mips-nec-sysv${UNAME_RELEASE}
+		echo mips-nec-sysv${UNAME_RELEASE}
 	else
-	        echo mips-unknown-sysv${UNAME_RELEASE}
+		echo mips-unknown-sysv${UNAME_RELEASE}
 	fi
-        exit 0 ;;
+	exit ;;
     BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
 	echo powerpc-be-beos
-	exit 0 ;;
+	exit ;;
     BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
 	echo powerpc-apple-beos
-	exit 0 ;;
+	exit ;;
     BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
 	echo i586-pc-beos
-	exit 0 ;;
+	exit ;;
+    BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
+	echo i586-pc-haiku
+	exit ;;
+    x86_64:Haiku:*:*)
+	echo x86_64-unknown-haiku
+	exit ;;
     SX-4:SUPER-UX:*:*)
 	echo sx4-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     SX-5:SUPER-UX:*:*)
 	echo sx5-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     SX-6:SUPER-UX:*:*)
 	echo sx6-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
+    SX-7:SUPER-UX:*:*)
+	echo sx7-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8:SUPER-UX:*:*)
+	echo sx8-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8R:SUPER-UX:*:*)
+	echo sx8r-nec-superux${UNAME_RELEASE}
+	exit ;;
     Power*:Rhapsody:*:*)
 	echo powerpc-apple-rhapsody${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:Rhapsody:*:*)
 	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	case $UNAME_PROCESSOR in
-	    *86) UNAME_PROCESSOR=i686 ;;
-	    unknown) UNAME_PROCESSOR=powerpc ;;
-	esac
+	eval $set_cc_for_build
+	if test "$UNAME_PROCESSOR" = unknown ; then
+	    UNAME_PROCESSOR=powerpc
+	fi
+	if test `echo "$UNAME_RELEASE" | sed -e 's/\..*//'` -le 10 ; then
+	    if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		    (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		    grep IS_64BIT_ARCH >/dev/null
+		then
+		    case $UNAME_PROCESSOR in
+			i386) UNAME_PROCESSOR=x86_64 ;;
+			powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		    esac
+		fi
+	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # Avoid executing cc on OS X 10.9, as it ships with a stub
+	    # that puts up a graphical alert prompting to install
+	    # developer tools.  Any system running Mac OS X 10.7 or
+	    # later (Darwin 11 and later) is required to have a 64-bit
+	    # processor. This is not true of the ARM version of Darwin
+	    # that Apple uses in portable devices.
+	    UNAME_PROCESSOR=x86_64
+	fi
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
 	if test "$UNAME_PROCESSOR" = "x86"; then
@@ -1196,25 +1291,28 @@
 		UNAME_MACHINE=pc
 	fi
 	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:QNX:*:4*)
 	echo i386-pc-qnx
-	exit 0 ;;
-    NSE-?:NONSTOP_KERNEL:*:*)
+	exit ;;
+    NEO-?:NONSTOP_KERNEL:*:*)
+	echo neo-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    NSE-*:NONSTOP_KERNEL:*:*)
 	echo nse-tandem-nsk${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     NSR-?:NONSTOP_KERNEL:*:*)
 	echo nsr-tandem-nsk${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:NonStop-UX:*:*)
 	echo mips-compaq-nonstopux
-	exit 0 ;;
+	exit ;;
     BS2000:POSIX*:*:*)
 	echo bs2000-siemens-sysv
-	exit 0 ;;
+	exit ;;
     DS/*:UNIX_System_V:*:*)
 	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:Plan9:*:*)
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
@@ -1225,193 +1323,55 @@
 	    UNAME_MACHINE="$cputype"
 	fi
 	echo ${UNAME_MACHINE}-unknown-plan9
-	exit 0 ;;
+	exit ;;
     *:TOPS-10:*:*)
 	echo pdp10-unknown-tops10
-	exit 0 ;;
+	exit ;;
     *:TENEX:*:*)
 	echo pdp10-unknown-tenex
-	exit 0 ;;
+	exit ;;
     KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
 	echo pdp10-dec-tops20
-	exit 0 ;;
+	exit ;;
     XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
 	echo pdp10-xkl-tops20
-	exit 0 ;;
+	exit ;;
     *:TOPS-20:*:*)
 	echo pdp10-unknown-tops20
-	exit 0 ;;
+	exit ;;
     *:ITS:*:*)
 	echo pdp10-unknown-its
-	exit 0 ;;
+	exit ;;
     SEI:*:*:SEIUX)
-        echo mips-sei-seiux${UNAME_RELEASE}
-	exit 0 ;;
+	echo mips-sei-seiux${UNAME_RELEASE}
+	exit ;;
     *:DragonFly:*:*)
 	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
-	exit 0 ;;
+	exit ;;
     *:*VMS:*:*)
-    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	UNAME_MACHINE=`(uname -p) 2>/dev/null`
 	case "${UNAME_MACHINE}" in
-	    A*) echo alpha-dec-vms && exit 0 ;;
-	    I*) echo ia64-dec-vms && exit 0 ;;
-	    V*) echo vax-dec-vms && exit 0 ;;
+	    A*) echo alpha-dec-vms ; exit ;;
+	    I*) echo ia64-dec-vms ; exit ;;
+	    V*) echo vax-dec-vms ; exit ;;
 	esac ;;
     *:XENIX:*:SysV)
 	echo i386-pc-xenix
-	exit 0 ;;
+	exit ;;
+    i*86:skyos:*:*)
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	exit ;;
+    i*86:rdos:*:*)
+	echo ${UNAME_MACHINE}-pc-rdos
+	exit ;;
+    i*86:AROS:*:*)
+	echo ${UNAME_MACHINE}-pc-aros
+	exit ;;
+    x86_64:VMkernel:*:*)
+	echo ${UNAME_MACHINE}-unknown-esx
+	exit ;;
 esac
 
-#echo '(No uname command or uname output not recognized.)' 1>&2
-#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
-
-eval $set_cc_for_build
-cat >$dummy.c <<EOF
-#ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
-#endif
-main ()
-{
-#if defined (sony)
-#if defined (MIPSEB)
-  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
-     I don't know....  */
-  printf ("mips-sony-bsd\n"); exit (0);
-#else
-#include <sys/param.h>
-  printf ("m68k-sony-newsos%s\n",
-#ifdef NEWSOS4
-          "4"
-#else
-	  ""
-#endif
-         ); exit (0);
-#endif
-#endif
-
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
-#endif
-
-#if defined (NeXT)
-#if !defined (__ARCHITECTURE__)
-#define __ARCHITECTURE__ "m68k"
-#endif
-  int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  if (version < 4)
-    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
-  else
-    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
-  exit (0);
-#endif
-
-#if defined (MULTIMAX) || defined (n16)
-#if defined (UMAXV)
-  printf ("ns32k-encore-sysv\n"); exit (0);
-#else
-#if defined (CMU)
-  printf ("ns32k-encore-mach\n"); exit (0);
-#else
-  printf ("ns32k-encore-bsd\n"); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (__386BSD__)
-  printf ("i386-pc-bsd\n"); exit (0);
-#endif
-
-#if defined (sequent)
-#if defined (i386)
-  printf ("i386-sequent-dynix\n"); exit (0);
-#endif
-#if defined (ns32000)
-  printf ("ns32k-sequent-dynix\n"); exit (0);
-#endif
-#endif
-
-#if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
-
-#endif
-
-#if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
-#endif
-
-#if defined (alliant) && defined (i860)
-  printf ("i860-alliant-bsd\n"); exit (0);
-#endif
-
-  exit (1);
-}
-EOF
-
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && $dummy && exit 0
-
-# Apollos put the system type in the environment.
-
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
-
-# Convex versions that predate uname can use getsysinfo(1)
-
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit 0 ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-	exit 0 ;;
-    c34*)
-	echo c34-convex-bsd
-	exit 0 ;;
-    c38*)
-	echo c38-convex-bsd
-	exit 0 ;;
-    c4*)
-	echo c4-convex-bsd
-	exit 0 ;;
-    esac
-fi
-
 cat >&2 <<EOF
 $0: unable to guess system type
 
@@ -1419,7 +1379,9 @@
 the operating system you are using. It is advised that you
 download the most up to date version of the config scripts from
 
-    ftp://ftp.gnu.org/pub/gnu/config/
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+and
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
 
 If the version you run ($0) is already up to date, please
 send the following data and any information you think might be
diff -Naur libAfterImage-1.20/config.h.in root/graf2d/asimage/src/libAfterImage/config.h.in
--- libAfterImage-1.20/config.h.in	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/config.h.in	2018-12-08 08:18:38.000000000 +0100
@@ -29,7 +29,7 @@
 #undef HAVE_FREETYPE_FREETYPE
 
 /* Define to 1 if you have the <ft2build.h> header file. */
-#undef HAVE_FT2BUILD_H
+#define HAVE_FT2BUILD_H
 
 /* Define if libgif/ungif is available */
 #undef HAVE_GIF
diff -Naur libAfterImage-1.20/config.sub root/graf2d/asimage/src/libAfterImage/config.sub
--- libAfterImage-1.20/config.sub	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/config.sub	2018-12-08 08:18:38.000000000 +0100
@@ -1,42 +1,40 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+#   Copyright 1992-2015 Free Software Foundation, Inc.
 
-timestamp='2005-02-10'
+timestamp='2015-01-01'
 
-# This file is (in principle) common to ALL GNU software.
-# The presence of a machine in this file suggests that SOME GNU software
-# can handle that machine.  It does not imply ALL GNU software can.
-#
-# This file is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330,
-# Boston, MA 02111-1307, USA.
-
+# along with this program; if not, see <http://www.gnu.org/licenses/>.
+#
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
+
 
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
+# Please send patches to <config-patches@gnu.org>.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
 # If it is invalid, we print an error message on stderr and exit with code 1.
 # Otherwise, we print the canonical config type on stdout and succeed.
 
+# You can get the latest version of this script from:
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+
 # This file is supposed to be the same for all GNU packages
 # and recognize all the CPU types, system types and aliases
 # that are meaningful with *any* GNU software.
@@ -70,8 +68,7 @@
 version="\
 GNU config.sub ($timestamp)
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
-Free Software Foundation, Inc.
+Copyright 1992-2015 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -83,11 +80,11 @@
 while test $# -gt 0 ; do
   case $1 in
     --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit 0 ;;
+       echo "$timestamp" ; exit ;;
     --version | -v )
-       echo "$version" ; exit 0 ;;
+       echo "$version" ; exit ;;
     --help | --h* | -h )
-       echo "$usage"; exit 0 ;;
+       echo "$usage"; exit ;;
     -- )     # Stop option processing
        shift; break ;;
     - )	# Use stdin as input.
@@ -99,7 +96,7 @@
     *local*)
        # First pass through any local machine types.
        echo $1
-       exit 0;;
+       exit ;;
 
     * )
        break ;;
@@ -118,11 +115,18 @@
 # Here we must recognize all the valid KERNEL-OS combinations.
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
-  nto-qnx* | linux-gnu* | linux-dietlibc | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | \
-  kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
+  nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
+  linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
+  knetbsd*-gnu* | netbsd*-gnu* | \
+  kopensolaris*-gnu* | \
+  storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
+  android-linux)
+    os=-linux-android
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`-unknown
+    ;;
   *)
     basic_machine=`echo $1 | sed 's/-[^-]*$//'`
     if [ $basic_machine != $1 ]
@@ -145,10 +149,13 @@
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray)
+	-apple | -axis | -knuth | -cray | -microblaze*)
 		os=
 		basic_machine=$1
 		;;
+	-bluegene*)
+		os=-cnk
+		;;
 	-sim | -cisco | -oki | -wec | -winbond)
 		os=
 		basic_machine=$1
@@ -163,13 +170,17 @@
 		os=-chorusos
 		basic_machine=$1
 		;;
- 	-chorusrdb)
- 		os=-chorusrdb
+	-chorusrdb)
+		os=-chorusrdb
 		basic_machine=$1
- 		;;
+		;;
 	-hiux*)
 		os=-hiuxwe2
 		;;
+	-sco6)
+		os=-sco5v6
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
 	-sco5)
 		os=-sco3.2v5
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
@@ -186,6 +197,10 @@
 		# Don't forget version if it is 3.2v4 or newer.
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
+	-sco5v6*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
 	-sco*)
 		os=-sco3.2v2
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
@@ -203,6 +218,12 @@
 	-isc*)
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
+	-lynx*178)
+		os=-lynxos178
+		;;
+	-lynx*5)
+		os=-lynxos5
+		;;
 	-lynx*)
 		os=-lynxos
 		;;
@@ -227,57 +248,113 @@
 	# Some are omitted here because they have special meanings below.
 	1750a | 580 \
 	| a29k \
+	| aarch64 | aarch64_be \
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
 	| am33_2.0 \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
-	| c4x | clipper \
+	| arc | arceb \
+	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
+	| avr | avr32 \
+	| be32 | be64 \
+	| bfin \
+	| c4x | c8051 | clipper \
 	| d10v | d30v | dlx | dsp16xx \
-	| fr30 | frv \
+	| epiphany \
+	| fido | fr30 | frv | ft32 \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+	| hexagon \
 	| i370 | i860 | i960 | ia64 \
 	| ip2k | iq2000 \
-	| m32r | m32rle | m68000 | m68k | m88k | maxq | mcore \
+	| k1om \
+	| le32 | le64 \
+	| lm32 \
+	| m32c | m32r | m32rle | m68000 | m68k | m88k \
+	| maxq | mb | microblaze | microblazeel | mcore | mep | metag \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
 	| mips16 \
 	| mips64 | mips64el \
-	| mips64vr | mips64vrel \
+	| mips64octeon | mips64octeonel \
 	| mips64orion | mips64orionel \
+	| mips64r5900 | mips64r5900el \
+	| mips64vr | mips64vrel \
 	| mips64vr4100 | mips64vr4100el \
 	| mips64vr4300 | mips64vr4300el \
 	| mips64vr5000 | mips64vr5000el \
+	| mips64vr5900 | mips64vr5900el \
 	| mipsisa32 | mipsisa32el \
 	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa32r6 | mipsisa32r6el \
 	| mipsisa64 | mipsisa64el \
 	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64r6 | mipsisa64r6el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipsr5900 | mipsr5900el \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
+	| moxie \
+	| mt \
 	| msp430 \
+	| nds32 | nds32le | nds32be \
+	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
-	| openrisc | or32 \
+	| open8 | or1k | or1knd | or32 \
 	| pdp10 | pdp11 | pj | pjl \
-	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
+	| powerpc | powerpc64 | powerpc64le | powerpcle \
 	| pyramid \
-	| sh | sh[1234] | sh[23]e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
+	| riscv32 | riscv64 \
+	| rl78 | rx \
+	| score \
+	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
-	| sparc | sparc64 | sparc86x | sparclet | sparclite | sparcv8 | sparcv9 | sparcv9b \
-	| strongarm \
-	| tahoe | thumb | tic4x | tic80 | tron \
-	| v850 | v850e \
+	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
+	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
+	| spu \
+	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
+	| ubicom32 \
+	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
+	| visium \
 	| we32k \
-	| x86 | xscale | xscalee[bl] | xstormy16 | xtensa \
-	| z8k)
+	| x86 | xc16x | xstormy16 | xtensa \
+	| z8k | z80)
 		basic_machine=$basic_machine-unknown
 		;;
-	m6811 | m68hc11 | m6812 | m68hc12)
-		# Motorola 68HC11/12.
+	c54x)
+		basic_machine=tic54x-unknown
+		;;
+	c55x)
+		basic_machine=tic55x-unknown
+		;;
+	c6x)
+		basic_machine=tic6x-unknown
+		;;
+	leon|leon[3-9])
+		basic_machine=sparc-$basic_machine
+		;;
+	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)
 		basic_machine=$basic_machine-unknown
 		os=-none
 		;;
 	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
 		;;
+	ms1)
+		basic_machine=mt-unknown
+		;;
+
+	strongarm | thumb | xscale)
+		basic_machine=arm-unknown
+		;;
+	xgate)
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
+	xscaleeb)
+		basic_machine=armeb-unknown
+		;;
+
+	xscaleel)
+		basic_machine=armel-unknown
+		;;
 
 	# We use `pc' rather than `unknown'
 	# because (1) that's what they normally are, and
@@ -293,60 +370,87 @@
 	# Recognize the basic CPU types with company name.
 	580-* \
 	| a29k-* \
+	| aarch64-* | aarch64_be-* \
 	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
 	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
-	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
-	| avr-* \
-	| bs2000-* \
-	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
-	| clipper-* | craynv-* | cydra-* \
+	| avr-* | avr32-* \
+	| be32-* | be64-* \
+	| bfin-* | bs2000-* \
+	| c[123]* | c30-* | [cjt]90-* | c4x-* \
+	| c8051-* | clipper-* | craynv-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
 	| elxsi-* \
-	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
+	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
+	| hexagon-* \
 	| i*86-* | i860-* | i960-* | ia64-* \
 	| ip2k-* | iq2000-* \
-	| m32r-* | m32rle-* \
+	| k1om-* \
+	| le32-* | le64-* \
+	| lm32-* \
+	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
+	| microblaze-* | microblazeel-* \
 	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
-	| mips64vr-* | mips64vrel-* \
+	| mips64octeon-* | mips64octeonel-* \
 	| mips64orion-* | mips64orionel-* \
+	| mips64r5900-* | mips64r5900el-* \
+	| mips64vr-* | mips64vrel-* \
 	| mips64vr4100-* | mips64vr4100el-* \
 	| mips64vr4300-* | mips64vr4300el-* \
 	| mips64vr5000-* | mips64vr5000el-* \
+	| mips64vr5900-* | mips64vr5900el-* \
 	| mipsisa32-* | mipsisa32el-* \
 	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa32r6-* | mipsisa32r6el-* \
 	| mipsisa64-* | mipsisa64el-* \
 	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64r6-* | mipsisa64r6el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipsr5900-* | mipsr5900el-* \
 	| mipstx39-* | mipstx39el-* \
 	| mmix-* \
+	| mt-* \
 	| msp430-* \
+	| nds32-* | nds32le-* | nds32be-* \
+	| nios-* | nios2-* | nios2eb-* | nios2el-* \
 	| none-* | np1-* | ns16k-* | ns32k-* \
+	| open8-* \
+	| or1k*-* \
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
-	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
+	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
 	| pyramid-* \
-	| romp-* | rs6000-* \
-	| sh-* | sh[1234]-* | sh[23]e-* | sh[34]eb-* | shbe-* \
+	| rl78-* | romp-* | rs6000-* | rx-* \
+	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
-	| sparc-* | sparc64-* | sparc86x-* | sparclet-* | sparclite-* \
-	| sparcv8-* | sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
-	| tahoe-* | thumb-* \
+	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
+	| sparclite-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \
+	| tahoe-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
+	| tile*-* \
 	| tron-* \
-	| v850-* | v850e-* | vax-* \
+	| ubicom32-* \
+	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
+	| vax-* \
+	| visium-* \
 	| we32k-* \
-	| x86-* | x86_64-* | xps100-* | xscale-* | xscalee[bl]-* \
-	| xstormy16-* | xtensa-* \
+	| x86-* | x86_64-* | xc16x-* | xps100-* \
+	| xstormy16-* | xtensa*-* \
 	| ymp-* \
-	| z8k-*)
+	| z8k-* | z80-*)
+		;;
+	# Recognize the basic CPU types without company name, with glob match.
+	xtensa*)
+		basic_machine=$basic_machine-unknown
 		;;
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
@@ -364,7 +468,7 @@
 		basic_machine=a29k-amd
 		os=-udi
 		;;
-    	abacus)
+	abacus)
 		basic_machine=abacus-unknown
 		;;
 	adobe68k)
@@ -410,6 +514,10 @@
 		basic_machine=m68k-apollo
 		os=-bsd
 		;;
+	aros)
+		basic_machine=i386-pc
+		os=-aros
+		;;
 	aux)
 		basic_machine=m68k-apple
 		os=-aux
@@ -418,10 +526,35 @@
 		basic_machine=ns32k-sequent
 		os=-dynix
 		;;
+	blackfin)
+		basic_machine=bfin-unknown
+		os=-linux
+		;;
+	blackfin-*)
+		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
+	bluegene*)
+		basic_machine=powerpc-ibm
+		os=-cnk
+		;;
+	c54x-*)
+		basic_machine=tic54x-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	c55x-*)
+		basic_machine=tic55x-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	c6x-*)
+		basic_machine=tic6x-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	c90)
 		basic_machine=c90-cray
 		os=-unicos
 		;;
+	cegcc)
+		basic_machine=arm-unknown
+		os=-cegcc
+		;;
 	convex-c1)
 		basic_machine=c1-convex
 		os=-bsd
@@ -450,8 +583,8 @@
 		basic_machine=craynv-cray
 		os=-unicosmp
 		;;
-	cr16c)
-		basic_machine=cr16c-unknown
+	cr16 | cr16-*)
+		basic_machine=cr16-unknown
 		os=-elf
 		;;
 	crds | unos)
@@ -489,6 +622,10 @@
 		basic_machine=m88k-motorola
 		os=-sysv3
 		;;
+	dicos)
+		basic_machine=i686-pc
+		os=-dicos
+		;;
 	djgpp)
 		basic_machine=i586-pc
 		os=-msdosdjgpp
@@ -604,7 +741,6 @@
 	i370-ibm* | ibm*)
 		basic_machine=i370-ibm
 		;;
-# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
 	i*86v32)
 		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv32
@@ -643,6 +779,17 @@
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
+	leon-*|leon[3-9]-*)
+		basic_machine=sparc-`echo $basic_machine | sed 's/-.*//'`
+		;;
+	m68knommu)
+		basic_machine=m68k-unknown
+		os=-linux
+		;;
+	m68knommu-*)
+		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
 	m88k-omron*)
 		basic_machine=m88k-omron
 		;;
@@ -654,10 +801,21 @@
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
+	microblaze*)
+		basic_machine=microblaze-xilinx
+		;;
+	mingw64)
+		basic_machine=x86_64-pc
+		os=-mingw64
+		;;
 	mingw32)
-		basic_machine=i386-pc
+		basic_machine=i686-pc
 		os=-mingw32
 		;;
+	mingw32ce)
+		basic_machine=arm-unknown
+		os=-mingw32ce
+		;;
 	miniframe)
 		basic_machine=m68000-convergent
 		;;
@@ -679,14 +837,29 @@
 		basic_machine=powerpc-unknown
 		os=-morphos
 		;;
+	moxiebox)
+		basic_machine=moxie-unknown
+		os=-moxiebox
+		;;
 	msdos)
 		basic_machine=i386-pc
 		os=-msdos
 		;;
+	ms1-*)
+		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
+		;;
+	msys)
+		basic_machine=i686-pc
+		os=-msys
+		;;
 	mvs)
 		basic_machine=i370-ibm
 		os=-mvs
 		;;
+	nacl)
+		basic_machine=le32-unknown
+		os=-nacl
+		;;
 	ncr3000)
 		basic_machine=i486-ncr
 		os=-sysv4
@@ -751,6 +924,12 @@
 	np1)
 		basic_machine=np1-gould
 		;;
+	neo-tandem)
+		basic_machine=neo-tandem
+		;;
+	nse-tandem)
+		basic_machine=nse-tandem
+		;;
 	nsr-tandem)
 		basic_machine=nsr-tandem
 		;;
@@ -758,9 +937,8 @@
 		basic_machine=hppa1.1-oki
 		os=-proelf
 		;;
-	or32 | or32-*)
+	openrisc | openrisc-*)
 		basic_machine=or32-unknown
-		os=-coff
 		;;
 	os400)
 		basic_machine=powerpc-ibm
@@ -782,6 +960,14 @@
 		basic_machine=i860-intel
 		os=-osf
 		;;
+	parisc)
+		basic_machine=hppa-unknown
+		os=-linux
+		;;
+	parisc-*)
+		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
 	pbd)
 		basic_machine=sparc-tti
 		;;
@@ -791,6 +977,12 @@
 	pc532 | pc532-*)
 		basic_machine=ns32k-pc532
 		;;
+	pc98)
+		basic_machine=i386-pc
+		;;
+	pc98-*)
+		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	pentium | p5 | k5 | k6 | nexgen | viac3)
 		basic_machine=i586-pc
 		;;
@@ -820,9 +1012,10 @@
 		;;
 	power)	basic_machine=power-ibm
 		;;
-	ppc)	basic_machine=powerpc-unknown
+	ppc | ppcbe)	basic_machine=powerpc-unknown
 		;;
-	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+	ppc-* | ppcbe-*)
+		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	ppcle | powerpclittle | ppc-le | powerpc-little)
 		basic_machine=powerpcle-unknown
@@ -847,6 +1040,14 @@
 		basic_machine=i586-unknown
 		os=-pw32
 		;;
+	rdos | rdos64)
+		basic_machine=x86_64-pc
+		os=-rdos
+		;;
+	rdos32)
+		basic_machine=i386-pc
+		os=-rdos
+		;;
 	rom68k)
 		basic_machine=m68k-rom68k
 		os=-coff
@@ -873,6 +1074,10 @@
 	sb1el)
 		basic_machine=mipsisa64sb1el-unknown
 		;;
+	sde)
+		basic_machine=mipsisa32-sde
+		os=-elf
+		;;
 	sei)
 		basic_machine=mips-sei
 		os=-seiux
@@ -884,6 +1089,9 @@
 		basic_machine=sh-hitachi
 		os=-hms
 		;;
+	sh5el)
+		basic_machine=sh5le-unknown
+		;;
 	sh64)
 		basic_machine=sh64-unknown
 		;;
@@ -905,6 +1113,9 @@
 		basic_machine=i860-stratus
 		os=-sysv4
 		;;
+	strongarm-* | thumb-*)
+		basic_machine=arm-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	sun2)
 		basic_machine=m68000-sun
 		;;
@@ -961,17 +1172,9 @@
 		basic_machine=t90-cray
 		os=-unicos
 		;;
-	tic54x | c54x*)
-		basic_machine=tic54x-unknown
-		os=-coff
-		;;
-	tic55x | c55x*)
-		basic_machine=tic55x-unknown
-		os=-coff
-		;;
-	tic6x | c6x*)
-		basic_machine=tic6x-unknown
-		os=-coff
+	tile*)
+		basic_machine=$basic_machine-unknown
+		os=-linux-gnu
 		;;
 	tx39)
 		basic_machine=mipstx39-unknown
@@ -1040,6 +1243,9 @@
 	xps | xps100)
 		basic_machine=xps100-honeywell
 		;;
+	xscale-* | xscalee[bl]-*)
+		basic_machine=`echo $basic_machine | sed 's/^xscale/arm/'`
+		;;
 	ymp)
 		basic_machine=ymp-cray
 		os=-unicos
@@ -1048,6 +1254,10 @@
 		basic_machine=z8k-unknown
 		os=-sim
 		;;
+	z80-*-coff)
+		basic_machine=z80-unknown
+		os=-sim
+		;;
 	none)
 		basic_machine=none-none
 		os=-none
@@ -1086,13 +1296,10 @@
 	we32k)
 		basic_machine=we32k-att
 		;;
-	sh3 | sh4 | sh[34]eb | sh[1234]le | sh[23]ele)
+	sh[1234] | sh[24]a | sh[24]aeb | sh[34]eb | sh[1234]le | sh[23]ele)
 		basic_machine=sh-unknown
 		;;
-	sh64)
-		basic_machine=sh64-unknown
-		;;
-	sparc | sparcv8 | sparcv9 | sparcv9b)
+	sparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)
 		basic_machine=sparc-sun
 		;;
 	cydra)
@@ -1136,9 +1343,12 @@
 if [ x"$os" != x"" ]
 then
 case $os in
-        # First match some system type aliases
-        # that might get confused with valid system types.
+	# First match some system type aliases
+	# that might get confused with valid system types.
 	# -solaris* is a basic system type, with this one exception.
+	-auroraux)
+		os=-auroraux
+		;;
 	-solaris1 | -solaris1.*)
 		os=`echo $os | sed -e 's|solaris1|sunos4|'`
 		;;
@@ -1159,26 +1369,31 @@
 	# Each alternative MUST END IN A *, to match a version number.
 	# -sysv* is not here because it comes later, after sysvr4.
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
-	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
-	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
+	      | -sym* | -kopensolaris* | -plan9* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* \
+	      | -aos* | -aros* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* | -openbsd* \
+	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
+	      | -bitrig* | -openbsd* | -solidbsd* \
 	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
 	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
-	      | -chorusos* | -chorusrdb* \
-	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -linux-uclibc* | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -chorusos* | -chorusrdb* | -cegcc* \
+	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
+	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
-	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly*)
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* | -tirtos*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
@@ -1196,7 +1411,7 @@
 		os=`echo $os | sed -e 's|nto|nto-qnx|'`
 		;;
 	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
-	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
 	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
 		;;
 	-mac*)
@@ -1217,7 +1432,7 @@
 	-opened*)
 		os=-openedition
 		;;
-        -os400*)
+	-os400*)
 		os=-os400
 		;;
 	-wince*)
@@ -1266,7 +1481,7 @@
 	-sinix*)
 		os=-sysv4
 		;;
-        -tpf*)
+	-tpf*)
 		os=-tpf
 		;;
 	-triton*)
@@ -1302,12 +1517,14 @@
 	-aros*)
 		os=-aros
 		;;
-	-kaos*)
-		os=-kaos
-		;;
 	-zvmoe)
 		os=-zvmoe
 		;;
+	-dicos*)
+		os=-dicos
+		;;
+	-nacl*)
+		;;
 	-none)
 		;;
 	*)
@@ -1330,6 +1547,12 @@
 # system, and we'll never get to this point.
 
 case $basic_machine in
+	score-*)
+		os=-elf
+		;;
+	spu-*)
+		os=-elf
+		;;
 	*-acorn)
 		os=-riscix1.2
 		;;
@@ -1339,9 +1562,24 @@
 	arm*-semi)
 		os=-aout
 		;;
-    c4x-* | tic4x-*)
-        os=-coff
-        ;;
+	c4x-* | tic4x-*)
+		os=-coff
+		;;
+	c8051-*)
+		os=-elf
+		;;
+	hexagon-*)
+		os=-elf
+		;;
+	tic54x-*)
+		os=-coff
+		;;
+	tic55x-*)
+		os=-coff
+		;;
+	tic6x-*)
+		os=-coff
+		;;
 	# This must come before the *-dec entry.
 	pdp10-*)
 		os=-tops20
@@ -1360,13 +1598,13 @@
 		;;
 	m68000-sun)
 		os=-sunos3
-		# This also exists in the configure program, but was not the
-		# default.
-		# os=-sunos4
 		;;
 	m68*-cisco)
 		os=-aout
 		;;
+	mep-*)
+		os=-elf
+		;;
 	mips*-cisco)
 		os=-elf
 		;;
@@ -1385,10 +1623,13 @@
 	*-be)
 		os=-beos
 		;;
+	*-haiku)
+		os=-haiku
+		;;
 	*-ibm)
 		os=-aix
 		;;
-    	*-knuth)
+	*-knuth)
 		os=-mmixware
 		;;
 	*-wec)
@@ -1493,7 +1734,7 @@
 			-sunos*)
 				vendor=sun
 				;;
-			-aix*)
+			-cnk*|-aix*)
 				vendor=ibm
 				;;
 			-beos*)
@@ -1556,7 +1797,7 @@
 esac
 
 echo $basic_machine$os
-exit 0
+exit
 
 # Local variables:
 # eval: (add-hook 'write-file-hooks 'time-stamp)
diff -Naur libAfterImage-1.20/configure root/graf2d/asimage/src/libAfterImage/configure
--- libAfterImage-1.20/configure	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/configure	2018-12-08 08:18:38.000000000 +0100
@@ -2724,7 +2724,9 @@
 
 		if test "x$GCC" = "xyes"; then
 	  if test -z "`echo $CFLAGS | grep '\-Wall' 2> /dev/null`" ; then
-  		CFLAGS="$CFLAGS -Wall"
+  		#CFLAGS="$CFLAGS -Wall"
+                #rdm No -Wall to silence unused warnings on Ubuntu.
+  		CFLAGS="$CFLAGS"
 	  fi
 	fi
 
@@ -2747,7 +2749,7 @@
 	  LDFLAGS="$LDFLAGS -pg"
 	fi
 		if test "x$enable_warn" = "xyes"; then
-	  CFLAGS="$CFLAGS -Wuninitialized -Wwrite-strings -Wcast-qual -Wbad-function-cast -Wpointer-arith -Wstrict-prototypes -Wmissing-prototypes -Wmissing-declarations -Wnested-externs -Wconversion -Wcomment -Wcast-align -Winline -Wshadow -Wredundant-decls"
+	  CFLAGS="$CFLAGS -Wuninitialized -Wwrite-strings -Wcast-qual -Wbad-function-cast -Wpointer-arith -Wstrict-prototypes -Wmissing-prototypes -Wmissing-declarations -Wnested-externs -Wconversion -Wcomment -Wcast-align -Wshadow -Wredundant-decls"
 	fi
 	# Find a good install program.  We prefer a C program (faster),
 # so one script is as good as another.  But avoid the broken or
@@ -3248,7 +3250,7 @@
 fi
 
 
-MMX_CFLAGS="-mmmx -Winline --param inline-unit-growth=10000 --param large-function-growth=10000"
+MMX_CFLAGS="-mmmx"
 have_mmx_intrinsics=no
 
 if test "x$enable_mmx_optimization" = "xyes"; then
@@ -3592,7 +3594,7 @@
     # GNU make sometimes prints "make[1]: Entering...", which would confuse us.
     eval `${MAKE-make} acfindx 2>/dev/null | grep -v make`
     # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
-    for ac_extension in a so sl; do
+    for ac_extension in a so sl dylib; do
       if test ! -f $ac_im_usrlibdir/libX11.$ac_extension &&
 	 test -f $ac_im_libdir/libX11.$ac_extension; then
 	ac_im_usrlibdir=$ac_im_libdir; break
@@ -3749,7 +3751,7 @@
 for ac_dir in `echo "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
 do
   # Don't even attempt the hair of trying to link an X program!
-  for ac_extension in a so sl; do
+  for ac_extension in a so sl dylib; do
     if test -r $ac_dir/libX11.$ac_extension; then
       ac_x_libraries=$ac_dir
       break 2
@@ -8606,7 +8608,9 @@
     have_ttf=yes
   fi
   if test "$have_ttf" = yes; then
+      if test "x$ttf_includes" = "xno"; then
 	  AFTERIMAGE_LIBS="`freetype-config --libs` $AFTERIMAGE_LIBS"
+      fi
   fi
 fi;
 
diff -Naur libAfterImage-1.20/configure.in root/graf2d/asimage/src/libAfterImage/configure.in
--- libAfterImage-1.20/configure.in	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/configure.in	2018-12-08 08:18:38.000000000 +0100
@@ -60,12 +60,9 @@
 dnl# AC_ARG_WITH(xpm_includes,   [  --with-xpm-includes=DIR  use libXpm includes in DIR( when builtin XPM handling is disabled )], xpm_includes="$withval", xpm_includes=no)
 
 dnl# standard libgif/ungif should not be used and considered obsolete!
-dnl# AC_ARG_WITH(ungif,		    [  --with-ungif             support Uncompressed GIF image format using libungif [no]],with_ungif="$withval",with_ungif=no)
-dnl# AC_ARG_WITH(gif,		    [  --with-gif               support GIF image format using libgif   [no]],with_gif="$withval",with_gif=no)
-dnl# AC_ARG_WITH(gif_includes,   [  --with-gif-includes=DIR  use GIF includes in DIR], gif_includes="$withval", gif_includes=no)
-with_ungif=no
-with_gif=no
-with_gif_includes=no
+AC_ARG_WITH(ungif,		    [  --with-ungif             support Uncompressed GIF image format using libungif [no]],with_ungif="$withval",with_ungif=no)
+AC_ARG_WITH(gif,		    [  --with-gif               support GIF image format using libgif   [no]],with_gif="$withval",with_gif=no)
+AC_ARG_WITH(gif_includes,   [  --with-gif-includes=DIR  use GIF includes in DIR], gif_includes="$withval", gif_includes=no)
 AC_ARG_WITH(builtin_gif,    [  --with-builtin-gif               support Uncompressed GIF image format using builtin libgif [yes]],with_builtin_gif="$withval",with_builtin_gif=yes)
 
 
@@ -219,7 +216,7 @@
 fi
 
 
-MMX_CFLAGS="-mmmx -Winline --param inline-unit-growth=10000 --param large-function-growth=10000"
+MMX_CFLAGS="-mmmx -Winline"
 have_mmx_intrinsics=no
 
 dnl# Check for MMX :
diff -Naur libAfterImage-1.20/export.c root/graf2d/asimage/src/libAfterImage/export.c
--- libAfterImage-1.20/export.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/export.c	2018-12-08 08:18:38.000000000 +0100
@@ -112,7 +112,7 @@
 #include "import.h"
 #include "export.h"
 #include "ascmap.h"
-#include "bmp.h"
+//#include "bmp.h"
 
 #ifdef jmpbuf
 #undef jmpbuf
@@ -147,6 +147,7 @@
 	int   filename_len, dirname_len = 0 ;
 	char *realfilename = NULL ;
 	Bool  res = False ;
+   int typei = (int) type;
 
 	if( im == NULL ) return False;
 
@@ -166,7 +167,7 @@
 		unix_path2dos_path( realfilename );
 #endif
 	}
-	if( type >= ASIT_Unknown || type < 0 )
+	if( type >= ASIT_Unknown || typei < 0 )
 		show_error( "Hmm, I don't seem to know anything about format you trying to write file \"%s\" in\n.\tPlease check the manual", realfilename );
    	else if( as_image_file_writers[type] )
    		res = as_image_file_writers[type](im, realfilename, params);
@@ -182,8 +183,8 @@
 /***********************************************************************************/
 /* Some helper functions :                                                         */
 
-static FILE*
-open_writeable_image_file( const char *path )
+FILE*
+open_writable_image_file( const char *path )
 {
 	FILE *fp = NULL;
 	if ( path )
@@ -289,7 +290,7 @@
            params = &defaults ;
         }
 
-	if ((outfile = open_writeable_image_file( path )) == NULL)
+	if ((outfile = open_writable_image_file( path )) == NULL)
 		return False;
 
     mapped_im = colormap_asimage( im, &cmap, params->xpm.max_colors, params->xpm.dither, params->xpm.opaque_threshold );
@@ -496,7 +497,7 @@
 	png_ptr = png_create_write_struct( PNG_LIBPNG_VER_STRING, NULL, NULL, NULL );
     if ( png_ptr != NULL )
     	if( (info_ptr = png_create_info_struct(png_ptr)) != NULL )
-			if( setjmp(png_ptr->jmpbuf) )
+			if( setjmp(png_jmpbuf(png_ptr)) )
 			{
 				png_destroy_info_struct(png_ptr, (png_infopp) &info_ptr);
 				info_ptr = NULL ;
@@ -647,7 +648,7 @@
 	if( im == NULL )
 		return False;
 	
-	if ((outfile = open_writeable_image_file( path )) == NULL)
+	if ((outfile = open_writable_image_file( path )) == NULL)
 		return False;
 
 	res = ASImage2png_int ( im, outfile, NULL, NULL, params );
@@ -764,7 +765,7 @@
            params = &defaults ;
         }
 
-	if ((outfile = open_writeable_image_file( path )) == NULL)
+	if ((outfile = open_writable_image_file( path )) == NULL)
 		return False;
 
 	if((imdec = start_image_decoding( NULL /* default visual */ , im,
@@ -925,100 +926,7 @@
 }
 
 /***********************************************************************************/
-/* Windows BMP file format :   									   				   */
-static size_t
-bmp_write32 (FILE *fp, CARD32 *data, int count)
-{
-  	size_t total = count;
-	if( count > 0 )
-	{
-#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
-		CARD8 *raw = (CARD8*)data ;
-#endif
-		count = 0 ;
-#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
-		while( count < total )
-		{
-			data[count] = (raw[0]<<24)|(raw[1]<<16)|(raw[2]<<8)|raw[3];
-			++count ;
-			raw += 4 ;
-		}
-#endif
-		total = fwrite((char*) data, sizeof (CARD8), total<<2, fp)>>2;
-	}
-	return total;
-}
-
-static size_t
-bmp_write16 (FILE *fp, CARD16 *data, int count)
-{
-  	size_t total = count;
-	if( count > 0 )
-	{
-#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
-		CARD8 *raw = (CARD8*)data ;
-#endif
-		count = 0 ;
-#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
-		while( count < total )
-		{
-			data[count] = (raw[0]<<16)|raw[1];
-			++count ;
-			raw += 2 ;
-		}
-#endif
-		total = fwrite((char*) data, sizeof (CARD8), total<<1, fp)>>1;
-	}
-	return total;
-}
-
-Bool
-ASImage2bmp ( ASImage *im, const char *path,  ASImageExportParams *params )
-{
-	Bool success = False;
-	FILE *outfile = NULL ;
-	START_TIME(started);
-
-	if ((outfile = open_writeable_image_file( path )) != NULL)
-	{
-		void *bmbits ;
-		BITMAPINFO *bmi = ASImage2DBI( get_default_asvisual(), im, 0, 0, im->width, im->height, &bmbits, 0 );
-		if( bmi != NULL && bmbits != NULL ) 
-		{
-			BITMAPFILEHEADER bmh ;
-			int bits_size = (((bmi->bmiHeader.biWidth*3+3)/4)*4)*bmi->bmiHeader.biHeight;          /* DWORD aligned */
-
-			bmh.bfType = BMP_SIGNATURE;
-		    bmh.bfSize = 14+bmi->bmiHeader.biSize+bits_size; /* Specifies the size, in bytes, of the bitmap file */
-		    bmh.bfReserved1 = 0;
-			bmh.bfReserved2 = 0;
-		    bmh.bfOffBits = 14+bmi->bmiHeader.biSize; /* Specifies the offset, in bytes, 
-							   * from the BITMAPFILEHEADER structure to the bitmap bits */
-			/* writing off the header */
-			bmp_write16( outfile, &bmh.bfType, 1 );
-			bmp_write32( outfile, &bmh.bfSize, 3 );
-			/* writing off the bitmapinfo : */
-			bmp_write32( outfile, &bmi->bmiHeader.biSize, 1 );
-			bmp_write32( outfile, (CARD32*)&bmi->bmiHeader.biWidth, 2 );
-			bmp_write16( outfile, &bmi->bmiHeader.biPlanes, 2 );
-			/* bmi->bmiHeader.biCompression = 0 ; */
-			bmp_write32( outfile, &bmi->bmiHeader.biCompression, 6 );
-
-			/* writing off the bitmapbits */
-			if (fwrite( bmbits, sizeof(CARD8), bits_size, outfile ) == bits_size)
-				success = True;
-				
-			free( bmbits );
-			free( bmi );
-			
-		}
-		if (outfile != stdout)
-			fclose(outfile);
-	}
-	SHOW_TIME("image export",started);
-	return success;
-}
-
+/* Windows BMP file format :   	see bmp.c								   				   */
 /***********************************************************************************/
 /* Windows ICO/CUR file format :   									   			   */
 Bool
@@ -1048,6 +956,9 @@
 	Bool new_image = True ;
 	START_TIME(started);
 	int cmap_size = 1;
+#if (GIFLIB_MAJOR>=5)
+	int errcode;
+#endif
 #define GIF_NETSCAPE_EXT_BYTES 3
 	unsigned char netscape_ext_bytes[GIF_NETSCAPE_EXT_BYTES] = { 0x1, 0x0, 0x0};
 #define GIF_GCE_BYTES 4	
@@ -1086,10 +997,18 @@
 
 	while( cmap_size < 256 && cmap_size < (int)cmap.count+(gce_bytes[0]&0x01) )
 		cmap_size = cmap_size<<1 ;
+#if (GIFLIB_MAJOR>=5)
+	if( (gif_cmap = GifMakeMapObject(cmap_size, NULL )) == NULL )
+#else
 	if( (gif_cmap = MakeMapObject(cmap_size, NULL )) == NULL )
+#endif
 	{
 		free( mapped_im );
+#if (GIFLIB_MAJOR>=5)
+		ASIM_PrintGifError(E_GIF_ERR_NOT_ENOUGH_MEM);
+#else
 		ASIM_PrintGifError();
+#endif
 		return False;
 	}
 	memcpy( &(gif_cmap->Colors[0]), &(cmap.entries[0]), MIN(cmap.count,(unsigned int)cmap_size)*3 );
@@ -1101,13 +1020,25 @@
 		SavedImage *images = NULL ;
 		int count = 0 ;
 		/* TODO: do something about multiimage files !!! */
+#if (GIFLIB_MAJOR>=5)
+		gif = open_gif_read(infile, &errcode);
+#else
 		gif = open_gif_read(infile);
+#endif
 		if( gif == NULL || get_gif_saved_images(gif, -1, &images, &count) == GIF_ERROR)
 		{
+#if (GIFLIB_MAJOR>=5)
+			ASIM_PrintGifError(errcode);
+#else
 			ASIM_PrintGifError();
+#endif
 			if( gif )
 			{
+#if (GIFLIB_MAJOR>=5)
+				DGifCloseFile(gif, &errcode);
+#else
 				DGifCloseFile(gif);
+#endif
 				gif = NULL ;
 			}
 			if (infile)
@@ -1123,14 +1054,22 @@
 			gif_src = *gif ;
 			gif->SColorMap = NULL ;
 			gif->Image.ColorMap = NULL ;
+#if (GIFLIB_MAJOR>=5)
+            DGifCloseFile(gif, &errcode);
+#else
 			DGifCloseFile(gif);
+#endif
 			gif = NULL;
 			fclose (infile);
 			infile = NULL;
-			outfile = open_writeable_image_file( path );
+			outfile = open_writable_image_file( path );
 
 			if (outfile)
+#if (GIFLIB_MAJOR>=5)
+				gif = EGifOpenFileHandle(fileno(outfile), &errcode);
+#else
 				gif = EGifOpenFileHandle(fileno(outfile));
+#endif
 				
 			if (gif)
 			{
@@ -1141,26 +1080,46 @@
 									   gif_src.SColorMap )) == GIF_OK )
 					status = write_gif_saved_images( gif, images, count );
 				if( status != GIF_OK )
+#if (GIFLIB_MAJOR>=5)
+					ASIM_PrintGifError(status);
+#else
 					ASIM_PrintGifError();
+#endif
 			}
 			if (gif_src.SColorMap)
 			{  /* we only want to save private colormap if it is any different from
 			    * screen colormap ( saves us  768 bytes per image ) */
 				if( gif_cmap->ColorCount == gif_src.SColorMap->ColorCount )
 					dont_save_cmap = ( memcmp( gif_cmap->Colors, gif_src.SColorMap->Colors, gif_cmap->ColorCount*sizeof(GifColorType)) == 0 );
+#if (GIFLIB_MAJOR>=5)
+				GifFreeMapObject(gif_src.SColorMap);
+#else
 				FreeMapObject(gif_src.SColorMap);
+#endif
 			}
 			if (gif)
 			{
 				EGifPutExtension(gif, GRAPHICS_EXT_FUNC_CODE, GIF_GCE_BYTES, &(gce_bytes[0]));
 				if( get_flags( params->gif.flags, EXPORT_ANIMATION_REPEATS ) )
 				{
+#if (GIFLIB_MAJOR>=5)
+					EGifPutExtensionLeader(gif, APPLICATION_EXT_FUNC_CODE);
+					EGifPutExtensionBlock(gif, 11, "NETSCAPE2.0");
+					EGifPutExtensionBlock(gif, GIF_NETSCAPE_EXT_BYTES, &(netscape_ext_bytes[0]));
+					EGifPutExtensionTrailer(gif);
+#else
 					EGifPutExtensionFirst(gif, APPLICATION_EXT_FUNC_CODE, 11, "NETSCAPE2.0");
 					EGifPutExtensionLast(gif, 0, GIF_NETSCAPE_EXT_BYTES, &(netscape_ext_bytes[0]));
+#endif
 				}
 				
+#if (GIFLIB_MAJOR>=5)
+				if( (errcode = EGifPutImageDesc(gif, 0, 0, im->width, im->height, false, (dont_save_cmap)?NULL:gif_cmap )) == GIF_ERROR )
+					ASIM_PrintGifError(errcode);
+#else
 				if( EGifPutImageDesc(gif, 0, 0, im->width, im->height, FALSE, (dont_save_cmap)?NULL:gif_cmap ) == GIF_ERROR )
 					ASIM_PrintGifError();
+#endif
 			}
 		}
 		free_gif_saved_images( images, count );
@@ -1169,27 +1128,49 @@
 	if (gif == NULL)
 	{
 		if (outfile == NULL)
-			outfile = open_writeable_image_file(path);
+			outfile = open_writable_image_file(path);
 			
 		if (outfile)
+        {
+#if (GIFLIB_MAJOR>=5)
+			gif = EGifOpenFileHandle(fileno(outfile), &errcode);
+			if (errcode != E_GIF_SUCCEEDED)
+				ASIM_PrintGifError(errcode);
+#else
 			if ((gif = EGifOpenFileHandle(fileno(outfile))) == NULL)
 				ASIM_PrintGifError();
+#endif
+        }
 	}
 
 	if( new_image && gif )
 	{
+#if (GIFLIB_MAJOR>=5)
+		if( (errcode = EGifPutScreenDesc(gif, im->width, im->height, cmap_size, 0, gif_cmap )) == GIF_ERROR )
+			ASIM_PrintGifError(errcode);
+#else
 		if( EGifPutScreenDesc(gif, im->width, im->height, cmap_size, 0, gif_cmap ) == GIF_ERROR )
 			ASIM_PrintGifError();
+#endif
 	
 		EGifPutExtension(gif, 0xf9, GIF_GCE_BYTES, &(gce_bytes[0]));
 	
+#if (GIFLIB_MAJOR>=5)
+		if( (errcode = EGifPutImageDesc(gif, 0, 0, im->width, im->height, false, NULL )) == GIF_ERROR )
+			ASIM_PrintGifError(errcode);
+#else
 		if( EGifPutImageDesc(gif, 0, 0, im->width, im->height, FALSE, NULL ) == GIF_ERROR )
 			ASIM_PrintGifError();
+#endif
 	}
 
 	if( gif_cmap )
 	{
+#if (GIFLIB_MAJOR>=5)
+		GifFreeMapObject(gif_cmap);
+#else
 		FreeMapObject(gif_cmap);
+#endif
 		gif_cmap = NULL ;
 	}
 	if( gif )
@@ -1203,12 +1184,23 @@
 			register int *src = mapped_im + x*y;
 	  	    while( --x >= 0 )
 	  			row_pointer[x] = src[x] ;
+#if (GIFLIB_MAJOR>=5)
+			if( (errcode = EGifPutLine(gif, row_pointer, im->width))  == GIF_ERROR)
+				ASIM_PrintGifError(errcode);
+#else
 			if( EGifPutLine(gif, row_pointer, im->width)  == GIF_ERROR)
 				ASIM_PrintGifError();
+#endif
 		}
 		free( row_pointer );
+#if (GIFLIB_MAJOR>=5)
+		EGifCloseFile(gif, &errcode);
+		if (errcode != E_GIF_SUCCEEDED)
+			ASIM_PrintGifError(errcode);
+#else
 		if (EGifCloseFile(gif) == GIF_ERROR)
 			ASIM_PrintGifError();
+#endif
 		gif = NULL;
 	}
 	free( mapped_im );
@@ -1240,7 +1232,7 @@
 ASImage2tiff( ASImage *im, const char *path, ASImageExportParams *params)
 {
 	TIFF *out;
-	static const ASTiffExportParams defaultsTiff = { ASIT_Tiff, 0, -1, TIFF_COMPRESSION_NONE, 100, 0 };
+	static const ASTiffExportParams defaultsTiff = { ASIT_Tiff, 0, (CARD32)-1, TIFF_COMPRESSION_NONE, 100, 0 };
         ASImageExportParams defaults;
 	uint16 photometric = PHOTOMETRIC_RGB;
 	tsize_t linebytes, scanline;
diff -Naur libAfterImage-1.20/imencdec.c root/graf2d/asimage/src/libAfterImage/imencdec.c
--- libAfterImage-1.20/imencdec.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/imencdec.c	2018-12-08 08:18:38.000000000 +0100
@@ -373,7 +373,7 @@
 
 		if( bevel->left_outline == 0 && bevel->right_outline == 0 &&
 			bevel->top_outline == 0 && bevel->bottom_outline == 0 &&
-			bevel->left_inline == 0 && bevel->left_inline == 0 &&
+			bevel->left_inline == 0 && bevel->right_inline == 0 &&
 			bevel->top_inline == 0 && bevel->bottom_inline == 0 )
 			imdec->bevel = bevel = NULL ;
 	}
@@ -504,6 +504,7 @@
                     int shift, int quality )
 {
 	register ASImageOutput *imout= NULL;
+   int formati = (int) format;
 
 	if( im != NULL )
 		if( im->magic != MAGIC_ASIMAGE )
@@ -517,7 +518,7 @@
 	if( AS_ASSERT(im) || AS_ASSERT(asv) )
 		return imout;
 
-	if( format < 0 || format == ASA_Vector || format >= ASA_Formats)
+   if( formati < 0 || format == ASA_Vector || format >= ASA_Formats)
 		return NULL;
 	if( asimage_format_handlers[format].check_create_asim_format )
 		if( !asimage_format_handlers[format].check_create_asim_format(asv, im, format) )
diff -Naur libAfterImage-1.20/import.c root/graf2d/asimage/src/libAfterImage/import.c
--- libAfterImage-1.20/import.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/import.c	2018-12-08 08:18:38.000000000 +0100
@@ -115,7 +115,6 @@
 
 #include "asimage.h"
 #include "imencdec.h"
-#include "bmp.h"
 #include "scanline.h"
 #include "ximage.h"
 #include "xcf.h"
@@ -929,7 +928,7 @@
 	return realfilename;
 }
 
-static FILE*
+FILE*
 open_image_file( const char *path )
 {
 	FILE *fp = NULL;
@@ -1251,7 +1250,7 @@
 			 * the normal method of doing things with libpng).  REQUIRED unless you
 			 * set up your own error handlers in the png_create_read_struct() earlier.
 			 */
-			if ( !setjmp (png_ptr->jmpbuf))
+			if ( !setjmp (png_jmpbuf(png_ptr)))
 			{
 				ASFlagType rgb_flags = ASStorage_RLEDiffCompress|ASStorage_32Bit ;
 
@@ -1468,7 +1467,7 @@
 
 static void asim_png_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
 {
-   ASImPNGReadBuffer *buf = (ASImPNGReadBuffer *)png_ptr->io_ptr;
+   ASImPNGReadBuffer *buf = (ASImPNGReadBuffer *)png_get_io_ptr(png_ptr);
    memcpy(data, buf->buffer, length);
    buf->buffer += length;
 }
@@ -1546,6 +1545,7 @@
 	 * working space (which is allocated as needed by the JPEG library).
 	 */
 	struct jpeg_decompress_struct cinfo;
+	void *temp_cinfo = NULL;
 	/* We use our private extension JPEG error handler.
 	 * Note that this struct must live as long as the main JPEG parameter
 	 * struct, to avoid dangling-pointer problems.
@@ -1653,7 +1653,8 @@
 		prepare_scanline( im->width, 0, &buf, False );
 
 	/* Make a one-row-high sample array that will go away when done with image */
-	buffer = cinfo.mem->alloc_sarray((j_common_ptr) &cinfo, JPOOL_IMAGE,
+	temp_cinfo = &cinfo;
+	buffer = cinfo.mem->alloc_sarray((j_common_ptr) temp_cinfo, JPOOL_IMAGE,
 									cinfo.output_width * cinfo.output_components, 1);
 
 	/* Step 6: while (scan lines remain to be read) */
@@ -1873,268 +1874,6 @@
 }
 
 /***********************************************************************************/
-/* Windows BMP file format :   									   				   */
-static size_t
-bmp_read32 (FILE *fp, CARD32 *data, int count)
-{
-  	size_t total = count;
-	if( count > 0 )
-	{
-#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
-		CARD8 *raw = (CARD8*)data ;
-#endif
-		total = fread((char*) data, sizeof (CARD8), count<<2, fp)>>2;
-		count = 0 ;
-#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
-		while( count < total )
-		{
-			data[count] = (raw[0]<<24)|(raw[1]<<16)|(raw[2]<<8)|raw[3];
-			++count ;
-			raw += 4 ;
-		}
-#endif
-	}
-	return total;
-}
-
-static size_t
-bmp_read16 (FILE *fp, CARD16 *data, int count)
-{
-  	size_t total = count;
-	if( count > 0 )
-	{
-#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
-		CARD8 *raw = (CARD8*)data ;
-#endif
-		total = fread((char*) data, sizeof (CARD8), count<<1, fp)>>1;
-		count = 0 ;
-#ifdef WORDS_BIGENDIAN                         /* BMPs are encoded as Little Endian */
-		while( count < total )
-		{
-			data[count] = (raw[0]<<16)|raw[1];
-			++count ;
-			raw += 2 ;
-		}
-#endif
-	}
-	return total;
-}
-
-
-ASImage *
-read_bmp_image( FILE *infile, size_t data_offset, BITMAPINFOHEADER *bmp_info,
-				ASScanline *buf, CARD8 *gamma_table,
-				unsigned int width, unsigned int height,
-				Bool add_colormap, unsigned int compression )
-{
-	Bool success = False ;
-	CARD8 *cmap = NULL ;
-	int cmap_entries = 0, cmap_entry_size = 4, row_size ;
-	int y;
-	ASImage *im = NULL ;
-	CARD8 *data ;
-	int direction = -1 ;
-
-	if( bmp_read32( infile, &bmp_info->biSize, 1 ) )
-	{
-		if( bmp_info->biSize == 40 )
-		{/* long header */
-			bmp_read32( infile, (CARD32*)&bmp_info->biWidth, 2 );
-			bmp_read16( infile, &bmp_info->biPlanes, 2 );
-			bmp_info->biCompression = 1 ;
-			success = (bmp_read32( infile, &bmp_info->biCompression, 6 )==6);
-		}else
-		{
-			CARD16 dumm[2] ;
-			bmp_read16( infile, &dumm[0], 2 );
-			bmp_info->biWidth = dumm[0] ;
-			bmp_info->biHeight = dumm[1] ;
-			success = ( bmp_read16( infile, &bmp_info->biPlanes, 2 ) == 2 );
-			bmp_info->biCompression = 0 ;
-		}
-	}
-#ifdef LOCAL_DEBUG
-	fprintf( stderr, "bmp.info.biSize = %ld(0x%lX)\n", bmp_info->biSize, bmp_info->biSize );
-	fprintf( stderr, "bmp.info.biWidth = %ld\nbmp.info.biHeight = %ld\n",  bmp_info->biWidth,  bmp_info->biHeight );
-	fprintf( stderr, "bmp.info.biPlanes = %d\nbmp.info.biBitCount = %d\n", bmp_info->biPlanes, bmp_info->biBitCount );
-	fprintf( stderr, "bmp.info.biCompression = %ld\n", bmp_info->biCompression );
-	fprintf( stderr, "bmp.info.biSizeImage = %ld\n", bmp_info->biSizeImage );
-#endif
-	if( ((int)(bmp_info->biHeight)) < 0 )
-		direction = 1 ;
-	if( height == 0 )
-		height  = direction == 1 ? -((long)(bmp_info->biHeight)):bmp_info->biHeight ;
-	if( width == 0 )
-		width = bmp_info->biWidth ;
-
-	if( !success || bmp_info->biCompression != 0 ||
-		width > MAX_IMPORT_IMAGE_SIZE ||
-		height > MAX_IMPORT_IMAGE_SIZE )
-	{
-		return NULL;
-	}
-	if( bmp_info->biBitCount < 16 )
-		cmap_entries = 0x01<<bmp_info->biBitCount ;
-
-	if( bmp_info->biSize != 40 )
-		cmap_entry_size = 3;
-	if( cmap_entries )
-	{
-		cmap = safemalloc( cmap_entries * cmap_entry_size );
-		fread(cmap, sizeof (CARD8), cmap_entries * cmap_entry_size, infile);
-	}
-
-	if( add_colormap )
-		data_offset += cmap_entries*cmap_entry_size ;
-
-	fseek( infile, data_offset, SEEK_SET );
-	row_size = (width*bmp_info->biBitCount)>>3 ;
-	if( row_size == 0 )
-		row_size = 1 ;
-	else
-		row_size = (row_size+3)/4 ;            /* everything is aligned by 32 bits */
-	row_size *= 4 ;                            /* in bytes  */
-	data = safemalloc( row_size );
-
-	im = create_asimage( width,  height, compression );
-	/* Window BMP files are little endian  - we need to swap Red and Blue */
-	prepare_scanline( im->width, 0, buf, True );
-
-	y =( direction == 1 )?0:height-1 ;
-	while( y >= 0 && y < (int)height)
-	{
-		if( fread( data, sizeof (char), row_size, infile ) < (unsigned int)row_size )
-			break;
- 		dib_data_to_scanline(buf, bmp_info, gamma_table, data, cmap, cmap_entry_size); 
-		asimage_add_line (im, IC_RED,   buf->red  , y);
-		asimage_add_line (im, IC_GREEN, buf->green, y);
-		asimage_add_line (im, IC_BLUE,  buf->blue , y);
-		y += direction ;
-	}
-	free( data );
-	if( cmap )
-		free( cmap );
-	return im ;
-}
-
-ASImage *
-bmp2ASImage( const char * path, ASImageImportParams *params )
-{
-	ASImage *im = NULL ;
-	/* More stuff */
-	FILE         *infile;					   /* source file */
-	ASScanline    buf;
-	BITMAPFILEHEADER  bmp_header ;
-	BITMAPINFOHEADER  bmp_info;
-	START_TIME(started);
-
-
-	if ((infile = open_image_file(path)) == NULL)
-		return NULL;
-
-	bmp_header.bfType = 0 ;
-	if( bmp_read16( infile, &bmp_header.bfType, 1 ) )
-		if( bmp_header.bfType == BMP_SIGNATURE )
-			if( bmp_read32( infile, &bmp_header.bfSize, 3 ) == 3 )
-				im = read_bmp_image( infile, bmp_header.bfOffBits, &bmp_info, &buf, params->gamma_table, 0, 0, False, params->compression );
-#ifdef LOCAL_DEBUG
-	fprintf( stderr, "bmp.header.bfType = 0x%X\nbmp.header.bfSize = %ld\nbmp.header.bfOffBits = %ld(0x%lX)\n",
-					  bmp_header.bfType, bmp_header.bfSize, bmp_header.bfOffBits, bmp_header.bfOffBits );
-#endif
-	if( im != NULL )
-		free_scanline( &buf, True );
-	else
-		show_error( "invalid or unsupported BMP format in image file \"%s\"", path );
-
-	fclose( infile );
-	SHOW_TIME("image loading",started);
-	return im ;
-}
-
-/***********************************************************************************/
-/* Windows ICO/CUR file format :   									   			   */
-
-ASImage *
-ico2ASImage( const char * path, ASImageImportParams *params )
-{
-	ASImage *im = NULL ;
-	/* More stuff */
-	FILE         *infile;					   /* source file */
-	ASScanline    buf;
-	int y, mask_bytes;
-    CARD8  *and_mask;
-	START_TIME(started);
-	struct IconDirectoryEntry {
-    	CARD8  bWidth;
-    	CARD8  bHeight;
-    	CARD8  bColorCount;
-    	CARD8  bReserved;
-    	CARD16  wPlanes;
-    	CARD16  wBitCount;
-    	CARD32 dwBytesInRes;
-    	CARD32 dwImageOffset;
-	};
-	struct ICONDIR {
-    	CARD16          idReserved;
-    	CARD16          idType;
-    	CARD16          idCount;
-	} icon_dir;
-   	struct IconDirectoryEntry  icon;
-	BITMAPINFOHEADER bmp_info;
-
-	if ((infile = open_image_file(path)) == NULL)
-		return NULL;
-
-	icon_dir.idType = 0 ;
-	if( bmp_read16( infile, &icon_dir.idReserved, 3 ) == 3)
-		if( icon_dir.idType == 1 || icon_dir.idType == 2)
-		{
-			fread( &(icon.bWidth), sizeof(CARD8),4,infile );
-			bmp_read16( infile, &(icon.wPlanes), 2 );
-			if( bmp_read32( infile, &(icon.dwBytesInRes), 2 ) == 2 )
-			{
-				fseek( infile, icon.dwImageOffset, SEEK_SET );
-				im = read_bmp_image( infile, icon.dwImageOffset+40+(icon.bColorCount*4), &bmp_info, &buf, params->gamma_table,
-					                 icon.bWidth, icon.bHeight, (icon.bColorCount==0), params->compression );
-			}
-		}
-#ifdef LOCAL_DEBUG
-	fprintf( stderr, "icon.dir.idType = 0x%X\nicon.dir.idCount = %d\n",  icon_dir.idType, icon_dir.idCount );
-	fprintf( stderr, "icon[1].bWidth = %d(0x%X)\n",  icon.bWidth,  icon.bWidth );
-	fprintf( stderr, "icon[1].bHeight = %d(0x%X)\n",  icon.bHeight,  icon.bHeight );
-	fprintf( stderr, "icon[1].bColorCount = %d\n",  icon.bColorCount );
-	fprintf( stderr, "icon[1].dwImageOffset = %ld(0x%lX)\n",  icon.dwImageOffset,  icon.dwImageOffset );
-    fprintf( stderr, "icon[1].bmp_size = %ld\n",  icon.dwBytesInRes );
-    fprintf( stderr, "icon[1].dwBytesInRes = %ld\n",  icon.dwBytesInRes );
-#endif
-	if( im != NULL )
-	{
-        mask_bytes = ((icon.bWidth>>3)+3)/4 ;    /* everything is aligned by 32 bits */
-        mask_bytes *= 4 ;                      /* in bytes  */
-        and_mask = safemalloc( mask_bytes );
-        for( y = icon.bHeight-1 ; y >= 0 ; y-- )
-		{
-			int x ;
-            if( fread( and_mask, sizeof (CARD8), mask_bytes, infile ) < (unsigned int)mask_bytes )
-				break;
-			for( x = 0 ; x < icon.bWidth ; ++x )
-            {
-				buf.alpha[x] = (and_mask[x>>3]&(0x80>>(x&0x7)))? 0x0000 : 0x00FF ;
-            }
-			im->channels[IC_ALPHA][y]  = store_data( NULL, (CARD8*)buf.alpha, im->width*4, 
-													 ASStorage_32BitRLE|ASStorage_Bitmap, 0);
-		}
-        free( and_mask );
-		free_scanline( &buf, True );
-	}else
-		show_error( "invalid or unsupported ICO format in image file \"%s\"", path );
-
-	fclose( infile );
-	SHOW_TIME("image loading",started);
-	return im ;
-}
-
-/***********************************************************************************/
 #ifdef HAVE_GIF		/* GIF GIF GIF GIF GIF GIF GIF GIF GIF GIF GIF GIF GIF GIF GIF GIF */
 
 int
@@ -2178,6 +1917,9 @@
 	int  		transparent = -1 ;
 	unsigned int  		y;
 	unsigned int		width = 0, height = 0;
+#if (GIFLIB_MAJOR>=5)
+	int errcode;
+#endif
 	ColorMapObject     *cmap = NULL ;
 
 	START_TIME(started);
@@ -2186,7 +1928,11 @@
 	
 	if ((fp = open_image_file(path)) == NULL)
 		return NULL;
+#if (GIFLIB_MAJOR>=5)
+	if( (gif = open_gif_read(fp, &errcode)) != NULL )
+#else
 	if( (gif = open_gif_read(fp)) != NULL )
+#endif
 	{
 		SavedImage	*sp = NULL ;
 		int count = 0 ;
@@ -2217,7 +1963,7 @@
 												   		((((unsigned int) sp->ExtensionBlocks[y].Bytes[GIF_GCE_DELAY_BYTE_HIGH])<<8)&0x00FF00);
 					}else if(  sp->ExtensionBlocks[y].Function == APPLICATION_EXT_FUNC_CODE && sp->ExtensionBlocks[y].ByteCount == 11 ) /* application extension */
 					{
-						if( strncmp(&(sp->ExtensionBlocks[y].Bytes[0]), "NETSCAPE2.0", 11 ) == 0 ) 
+						if( strncmp((const char*)(&sp->ExtensionBlocks[y].Bytes[0]), "NETSCAPE2.0", 11 ) == 0 ) 
 						{
 							++y ;
 							if( y < (unsigned int)sp->ExtensionBlockCount && sp->ExtensionBlocks[y].ByteCount == 3 )
@@ -2289,13 +2035,21 @@
 			}
 			free_gif_saved_images( sp, count );
 		}else if( status != GIF_OK ) 
+#if (GIFLIB_MAJOR>=5)
+			ASIM_PrintGifError(status);
+#else
 			ASIM_PrintGifError();
+#endif
 		else if( params->subimage == -1 )
 			show_error( "Image file \"%s\" does not have any valid image information.", path );
 		else
 			show_error( "Image file \"%s\" does not have subimage %d.", path, params->subimage );
 
+#if (GIFLIB_MAJOR>=5)
+		DGifCloseFile(gif, &errcode);
+#else
 		DGifCloseFile(gif);
+#endif
 		fclose( fp );
 	}
 	SHOW_TIME("image loading",started);
diff -Naur libAfterImage-1.20/libAfterImage.dsp root/graf2d/asimage/src/libAfterImage/libAfterImage.dsp
--- libAfterImage-1.20/libAfterImage.dsp	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libAfterImage.dsp	2018-12-08 08:18:38.000000000 +0100
@@ -241,6 +241,22 @@
 # End Source File
 # Begin Source File
 
+SOURCE=.\libjpeg\transupp.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libjpeg\jaricom.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libjpeg\jdarith.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libjpeg\jcarith.c
+# End Source File
+# Begin Source File
+
 SOURCE=.\libjpeg\jddctmgr.c
 # End Source File
 # Begin Source File
@@ -269,10 +285,6 @@
 # End Source File
 # Begin Source File
 
-SOURCE=.\libjpeg\jdphuff.c
-# End Source File
-# Begin Source File
-
 SOURCE=.\libjpeg\jdpostct.c
 # End Source File
 # Begin Source File
@@ -313,10 +325,6 @@
 # End Source File
 # Begin Source File
 
-SOURCE=.\libjpeg\jidctred.c
-# End Source File
-# Begin Source File
-
 SOURCE=.\libjpeg\jmemmgr.c
 # End Source File
 # Begin Source File
diff -Naur libAfterImage-1.20/libAfterImage.mak root/graf2d/asimage/src/libAfterImage/libAfterImage.mak
--- libAfterImage-1.20/libAfterImage.mak	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libAfterImage.mak	2018-12-08 08:18:38.000000000 +0100
@@ -90,6 +90,10 @@
 	"$(INTDIR)\jdatasrc.obj" \
 	"$(INTDIR)\jdcoefct.obj" \
 	"$(INTDIR)\jdcolor.obj" \
+	"$(INTDIR)\transupp.obj" \
+	"$(INTDIR)\jaricom.obj" \
+	"$(INTDIR)\jdarith.obj" \
+	"$(INTDIR)\jcarith.obj" \
 	"$(INTDIR)\jddctmgr.obj" \
 	"$(INTDIR)\jdhuff.obj" \
 	"$(INTDIR)\jdinput.obj" \
@@ -97,7 +101,6 @@
 	"$(INTDIR)\jdmarker.obj" \
 	"$(INTDIR)\jdmaster.obj" \
 	"$(INTDIR)\jdmerge.obj" \
-	"$(INTDIR)\jdphuff.obj" \
 	"$(INTDIR)\jdpostct.obj" \
 	"$(INTDIR)\jdsample.obj" \
 	"$(INTDIR)\jdtrans.obj" \
@@ -108,24 +111,11 @@
 	"$(INTDIR)\jidctflt.obj" \
 	"$(INTDIR)\jidctfst.obj" \
 	"$(INTDIR)\jidctint.obj" \
-	"$(INTDIR)\jidctred.obj" \
 	"$(INTDIR)\jmemmgr.obj" \
 	"$(INTDIR)\jmemnobs.obj" \
 	"$(INTDIR)\jquant1.obj" \
 	"$(INTDIR)\jquant2.obj" \
 	"$(INTDIR)\jutils.obj" \
-	"$(INTDIR)\adler32.obj" \
-	"$(INTDIR)\compress.obj" \
-	"$(INTDIR)\crc32.obj" \
-	"$(INTDIR)\deflate.obj" \
-	"$(INTDIR)\gzio.obj" \
-	"$(INTDIR)\infback.obj" \
-	"$(INTDIR)\inffast.obj" \
-	"$(INTDIR)\inflate.obj" \
-	"$(INTDIR)\inftrees.obj" \
-	"$(INTDIR)\trees.obj" \
-	"$(INTDIR)\uncompr.obj" \
-	"$(INTDIR)\zutil.obj" \
 	"$(INTDIR)\dgif_lib.obj" \
 	"$(INTDIR)\egif_lib.obj" \
 	"$(INTDIR)\gif_err.obj" \
@@ -223,6 +213,10 @@
 	"$(INTDIR)\jdatasrc.obj" \
 	"$(INTDIR)\jdcoefct.obj" \
 	"$(INTDIR)\jdcolor.obj" \
+	"$(INTDIR)\transupp.obj" \
+	"$(INTDIR)\jaricom.obj" \
+	"$(INTDIR)\jdarith.obj" \
+	"$(INTDIR)\jcarith.obj" \
 	"$(INTDIR)\jddctmgr.obj" \
 	"$(INTDIR)\jdhuff.obj" \
 	"$(INTDIR)\jdinput.obj" \
@@ -230,7 +224,6 @@
 	"$(INTDIR)\jdmarker.obj" \
 	"$(INTDIR)\jdmaster.obj" \
 	"$(INTDIR)\jdmerge.obj" \
-	"$(INTDIR)\jdphuff.obj" \
 	"$(INTDIR)\jdpostct.obj" \
 	"$(INTDIR)\jdsample.obj" \
 	"$(INTDIR)\jdtrans.obj" \
@@ -241,24 +234,11 @@
 	"$(INTDIR)\jidctflt.obj" \
 	"$(INTDIR)\jidctfst.obj" \
 	"$(INTDIR)\jidctint.obj" \
-	"$(INTDIR)\jidctred.obj" \
 	"$(INTDIR)\jmemmgr.obj" \
 	"$(INTDIR)\jmemnobs.obj" \
 	"$(INTDIR)\jquant1.obj" \
 	"$(INTDIR)\jquant2.obj" \
 	"$(INTDIR)\jutils.obj" \
-	"$(INTDIR)\adler32.obj" \
-	"$(INTDIR)\compress.obj" \
-	"$(INTDIR)\crc32.obj" \
-	"$(INTDIR)\deflate.obj" \
-	"$(INTDIR)\gzio.obj" \
-	"$(INTDIR)\infback.obj" \
-	"$(INTDIR)\inffast.obj" \
-	"$(INTDIR)\inflate.obj" \
-	"$(INTDIR)\inftrees.obj" \
-	"$(INTDIR)\trees.obj" \
-	"$(INTDIR)\uncompr.obj" \
-	"$(INTDIR)\zutil.obj" \
 	"$(INTDIR)\dgif_lib.obj" \
 	"$(INTDIR)\egif_lib.obj" \
 	"$(INTDIR)\gif_err.obj" \
@@ -328,7 +308,7 @@
 !IF EXISTS("libAfterImage.dep")
 !INCLUDE "libAfterImage.dep"
 !ELSE 
-!MESSAGE Warning: cannot find "libAfterImage.dep"
+!MESSAGE Cannot find "libAfterImage.dep"
 !ENDIF 
 !ENDIF 
 
@@ -556,6 +536,30 @@
 	$(CPP) $(CPP_PROJ) $(SOURCE)
 
 
+SOURCE=.\libjpeg\transupp.c
+
+"$(INTDIR)\transupp.obj" : $(SOURCE) "$(INTDIR)"
+	$(CPP) $(CPP_PROJ) $(SOURCE)
+
+
+SOURCE=.\libjpeg\jaricom.c
+
+"$(INTDIR)\jaricom.obj" : $(SOURCE) "$(INTDIR)"
+	$(CPP) $(CPP_PROJ) $(SOURCE)
+
+
+SOURCE=.\libjpeg\jdarith.c
+
+"$(INTDIR)\jdarith.obj" : $(SOURCE) "$(INTDIR)"
+	$(CPP) $(CPP_PROJ) $(SOURCE)
+
+
+SOURCE=.\libjpeg\jcarith.c
+
+"$(INTDIR)\jcarith.obj" : $(SOURCE) "$(INTDIR)"
+	$(CPP) $(CPP_PROJ) $(SOURCE)
+
+
 SOURCE=.\libjpeg\jddctmgr.c
 
 "$(INTDIR)\jddctmgr.obj" : $(SOURCE) "$(INTDIR)"
@@ -598,12 +602,6 @@
 	$(CPP) $(CPP_PROJ) $(SOURCE)
 
 
-SOURCE=.\libjpeg\jdphuff.c
-
-"$(INTDIR)\jdphuff.obj" : $(SOURCE) "$(INTDIR)"
-	$(CPP) $(CPP_PROJ) $(SOURCE)
-
-
 SOURCE=.\libjpeg\jdpostct.c
 
 "$(INTDIR)\jdpostct.obj" : $(SOURCE) "$(INTDIR)"
@@ -664,12 +662,6 @@
 	$(CPP) $(CPP_PROJ) $(SOURCE)
 
 
-SOURCE=.\libjpeg\jidctred.c
-
-"$(INTDIR)\jidctred.obj" : $(SOURCE) "$(INTDIR)"
-	$(CPP) $(CPP_PROJ) $(SOURCE)
-
-
 SOURCE=.\libjpeg\jmemmgr.c
 
 "$(INTDIR)\jmemmgr.obj" : $(SOURCE) "$(INTDIR)"
@@ -700,78 +692,6 @@
 	$(CPP) $(CPP_PROJ) $(SOURCE)
 
 
-SOURCE=.\zlib\adler32.c
-
-"$(INTDIR)\adler32.obj" : $(SOURCE) "$(INTDIR)"
-	$(CPP) $(CPP_PROJ) $(SOURCE)
-
-
-SOURCE=.\zlib\compress.c
-
-"$(INTDIR)\compress.obj" : $(SOURCE) "$(INTDIR)"
-	$(CPP) $(CPP_PROJ) $(SOURCE)
-
-
-SOURCE=.\zlib\crc32.c
-
-"$(INTDIR)\crc32.obj" : $(SOURCE) "$(INTDIR)"
-	$(CPP) $(CPP_PROJ) $(SOURCE)
-
-
-SOURCE=.\zlib\deflate.c
-
-"$(INTDIR)\deflate.obj" : $(SOURCE) "$(INTDIR)"
-	$(CPP) $(CPP_PROJ) $(SOURCE)
-
-
-SOURCE=.\zlib\gzio.c
-
-"$(INTDIR)\gzio.obj" : $(SOURCE) "$(INTDIR)"
-	$(CPP) $(CPP_PROJ) $(SOURCE)
-
-
-SOURCE=.\zlib\infback.c
-
-"$(INTDIR)\infback.obj" : $(SOURCE) "$(INTDIR)"
-	$(CPP) $(CPP_PROJ) $(SOURCE)
-
-
-SOURCE=.\zlib\inffast.c
-
-"$(INTDIR)\inffast.obj" : $(SOURCE) "$(INTDIR)"
-	$(CPP) $(CPP_PROJ) $(SOURCE)
-
-
-SOURCE=.\zlib\inflate.c
-
-"$(INTDIR)\inflate.obj" : $(SOURCE) "$(INTDIR)"
-	$(CPP) $(CPP_PROJ) $(SOURCE)
-
-
-SOURCE=.\zlib\inftrees.c
-
-"$(INTDIR)\inftrees.obj" : $(SOURCE) "$(INTDIR)"
-	$(CPP) $(CPP_PROJ) $(SOURCE)
-
-
-SOURCE=.\zlib\trees.c
-
-"$(INTDIR)\trees.obj" : $(SOURCE) "$(INTDIR)"
-	$(CPP) $(CPP_PROJ) $(SOURCE)
-
-
-SOURCE=.\zlib\uncompr.c
-
-"$(INTDIR)\uncompr.obj" : $(SOURCE) "$(INTDIR)"
-	$(CPP) $(CPP_PROJ) $(SOURCE)
-
-
-SOURCE=.\zlib\zutil.c
-
-"$(INTDIR)\zutil.obj" : $(SOURCE) "$(INTDIR)"
-	$(CPP) $(CPP_PROJ) $(SOURCE)
-
-
 SOURCE=.\libungif\dgif_lib.c
 
 "$(INTDIR)\dgif_lib.obj" : $(SOURCE) "$(INTDIR)"
diff -Naur libAfterImage-1.20/libjpeg/jchuff.c root/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c
--- libAfterImage-1.20/libjpeg/jchuff.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c	2018-12-08 08:18:38.000000000 +0100
@@ -157,7 +157,7 @@
  * This routine also performs some validation checks on the table.
  */
 
-LOCAL(void)
+GLOBAL(void)
 jpeg_make_c_derived_tbl (j_compress_ptr cinfo, boolean isDC, int tblno,
 			 c_derived_tbl ** pdtbl)
 {
@@ -1252,7 +1252,7 @@
  * So the extra complexity of an optimal algorithm doesn't seem worthwhile.
  */
 
-LOCAL(void)
+GLOBAL(void)
 jpeg_gen_optimal_table (j_compress_ptr cinfo, JHUFF_TBL * htbl, long freq[])
 {
 #define MAX_CLEN 32		/* assumed maximum initial code length */
@@ -1554,7 +1554,7 @@
  */
 
 GLOBAL(void)
-jinit_huff_encoder (j_compress_ptr cinfo)
+_jinit_huff_encoder (j_compress_ptr cinfo) /* SASHA*/
 {
   huff_entropy_ptr entropy;
   int i;
diff -Naur libAfterImage-1.20/libjpeg/jcmainct.c root/graf2d/asimage/src/libAfterImage/libjpeg/jcmainct.c
--- libAfterImage-1.20/libjpeg/jcmainct.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libjpeg/jcmainct.c	2018-12-08 08:18:38.000000000 +0100
@@ -68,32 +68,32 @@
 METHODDEF(void)
 start_pass_main (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr mainptr = (my_main_ptr) cinfo->main;
 
   /* Do nothing in raw-data mode. */
   if (cinfo->raw_data_in)
     return;
 
-  main->cur_iMCU_row = 0;	/* initialize counters */
-  main->rowgroup_ctr = 0;
-  main->suspended = FALSE;
-  main->pass_mode = pass_mode;	/* save mode for use by process_data */
+  mainptr->cur_iMCU_row = 0;	/* initialize counters */
+  mainptr->rowgroup_ctr = 0;
+  mainptr->suspended = FALSE;
+  mainptr->pass_mode = pass_mode;	/* save mode for use by process_data */
 
   switch (pass_mode) {
   case JBUF_PASS_THRU:
 #ifdef FULL_MAIN_BUFFER_SUPPORTED
-    if (main->whole_image[0] != NULL)
+    if (mainptr->whole_image[0] != NULL)
       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 #endif
-    main->pub.process_data = process_data_simple_main;
+    mainptr->pub.process_data = process_data_simple_main;
     break;
 #ifdef FULL_MAIN_BUFFER_SUPPORTED
   case JBUF_SAVE_SOURCE:
   case JBUF_CRANK_DEST:
   case JBUF_SAVE_AND_PASS:
-    if (main->whole_image[0] == NULL)
+    if (mainptr->whole_image[0] == NULL)
       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
-    main->pub.process_data = process_data_buffer_main;
+    mainptr->pub.process_data = process_data_buffer_main;
     break;
 #endif
   default:
@@ -114,46 +114,46 @@
 			  JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
 			  JDIMENSION in_rows_avail)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr mainptr = (my_main_ptr) cinfo->main;
 
-  while (main->cur_iMCU_row < cinfo->total_iMCU_rows) {
+  while (mainptr->cur_iMCU_row < cinfo->total_iMCU_rows) {
     /* Read input data if we haven't filled the main buffer yet */
-    if (main->rowgroup_ctr < (JDIMENSION) cinfo->min_DCT_v_scaled_size)
+    if (mainptr->rowgroup_ctr < (JDIMENSION) cinfo->min_DCT_v_scaled_size)
       (*cinfo->prep->pre_process_data) (cinfo,
 					input_buf, in_row_ctr, in_rows_avail,
-					main->buffer, &main->rowgroup_ctr,
+					mainptr->buffer, &mainptr->rowgroup_ctr,
 					(JDIMENSION) cinfo->min_DCT_v_scaled_size);
 
     /* If we don't have a full iMCU row buffered, return to application for
      * more data.  Note that preprocessor will always pad to fill the iMCU row
      * at the bottom of the image.
      */
-    if (main->rowgroup_ctr != (JDIMENSION) cinfo->min_DCT_v_scaled_size)
+    if (mainptr->rowgroup_ctr != (JDIMENSION) cinfo->min_DCT_v_scaled_size)
       return;
 
     /* Send the completed row to the compressor */
-    if (! (*cinfo->coef->compress_data) (cinfo, main->buffer)) {
+    if (! (*cinfo->coef->compress_data) (cinfo, mainptr->buffer)) {
       /* If compressor did not consume the whole row, then we must need to
        * suspend processing and return to the application.  In this situation
        * we pretend we didn't yet consume the last input row; otherwise, if
        * it happened to be the last row of the image, the application would
        * think we were done.
        */
-      if (! main->suspended) {
+      if (! mainptr->suspended) {
 	(*in_row_ctr)--;
-	main->suspended = TRUE;
+	mainptr->suspended = TRUE;
       }
       return;
     }
     /* We did finish the row.  Undo our little suspension hack if a previous
      * call suspended; then mark the main buffer empty.
      */
-    if (main->suspended) {
+    if (mainptr->suspended) {
       (*in_row_ctr)++;
-      main->suspended = FALSE;
+      mainptr->suspended = FALSE;
     }
-    main->rowgroup_ctr = 0;
-    main->cur_iMCU_row++;
+    mainptr->rowgroup_ctr = 0;
+    mainptr->cur_iMCU_row++;
   }
 }
 
@@ -170,25 +170,25 @@
 			  JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
 			  JDIMENSION in_rows_avail)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr mainptr = (my_main_ptr) cinfo->main;
   int ci;
   jpeg_component_info *compptr;
-  boolean writing = (main->pass_mode != JBUF_CRANK_DEST);
+  boolean writing = (mainptr->pass_mode != JBUF_CRANK_DEST);
 
-  while (main->cur_iMCU_row < cinfo->total_iMCU_rows) {
+  while (mainptr->cur_iMCU_row < cinfo->total_iMCU_rows) {
     /* Realign the virtual buffers if at the start of an iMCU row. */
-    if (main->rowgroup_ctr == 0) {
+    if (mainptr->rowgroup_ctr == 0) {
       for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 	   ci++, compptr++) {
-	main->buffer[ci] = (*cinfo->mem->access_virt_sarray)
-	  ((j_common_ptr) cinfo, main->whole_image[ci],
-	   main->cur_iMCU_row * (compptr->v_samp_factor * DCTSIZE),
+	mainptr->buffer[ci] = (*cinfo->mem->access_virt_sarray)
+	  ((j_common_ptr) cinfo, mainptr->whole_image[ci],
+	   mainptr->cur_iMCU_row * (compptr->v_samp_factor * DCTSIZE),
 	   (JDIMENSION) (compptr->v_samp_factor * DCTSIZE), writing);
       }
       /* In a read pass, pretend we just read some source data. */
       if (! writing) {
 	*in_row_ctr += cinfo->max_v_samp_factor * DCTSIZE;
-	main->rowgroup_ctr = DCTSIZE;
+	mainptr->rowgroup_ctr = DCTSIZE;
       }
     }
 
@@ -197,40 +197,40 @@
     if (writing) {
       (*cinfo->prep->pre_process_data) (cinfo,
 					input_buf, in_row_ctr, in_rows_avail,
-					main->buffer, &main->rowgroup_ctr,
+					mainptr->buffer, &mainptr->rowgroup_ctr,
 					(JDIMENSION) DCTSIZE);
       /* Return to application if we need more data to fill the iMCU row. */
-      if (main->rowgroup_ctr < DCTSIZE)
+      if (mainptr->rowgroup_ctr < DCTSIZE)
 	return;
     }
 
     /* Emit data, unless this is a sink-only pass. */
-    if (main->pass_mode != JBUF_SAVE_SOURCE) {
-      if (! (*cinfo->coef->compress_data) (cinfo, main->buffer)) {
+    if (mainptr->pass_mode != JBUF_SAVE_SOURCE) {
+      if (! (*cinfo->coef->compress_data) (cinfo, mainptr->buffer)) {
 	/* If compressor did not consume the whole row, then we must need to
 	 * suspend processing and return to the application.  In this situation
 	 * we pretend we didn't yet consume the last input row; otherwise, if
 	 * it happened to be the last row of the image, the application would
 	 * think we were done.
 	 */
-	if (! main->suspended) {
+	if (! mainptr->suspended) {
 	  (*in_row_ctr)--;
-	  main->suspended = TRUE;
+	  mainptr->suspended = TRUE;
 	}
 	return;
       }
       /* We did finish the row.  Undo our little suspension hack if a previous
        * call suspended; then mark the main buffer empty.
        */
-      if (main->suspended) {
+      if (mainptr->suspended) {
 	(*in_row_ctr)++;
-	main->suspended = FALSE;
+	mainptr->suspended = FALSE;
       }
     }
 
     /* If get here, we are done with this iMCU row.  Mark buffer empty. */
-    main->rowgroup_ctr = 0;
-    main->cur_iMCU_row++;
+    mainptr->rowgroup_ctr = 0;
+    mainptr->cur_iMCU_row++;
   }
 }
 
@@ -244,15 +244,15 @@
 GLOBAL(void)
 jinit_c_main_controller (j_compress_ptr cinfo, boolean need_full_buffer)
 {
-  my_main_ptr main;
+  my_main_ptr mainptr;
   int ci;
   jpeg_component_info *compptr;
 
-  main = (my_main_ptr)
+  mainptr = (my_main_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(my_main_controller));
-  cinfo->main = (struct jpeg_c_main_controller *) main;
-  main->pub.start_pass = start_pass_main;
+  cinfo->main = (struct jpeg_c_main_controller *) mainptr;
+  mainptr->pub.start_pass = start_pass_main;
 
   /* We don't need to create a buffer in raw-data mode. */
   if (cinfo->raw_data_in)
@@ -267,7 +267,7 @@
     /* Note we pad the bottom to a multiple of the iMCU height */
     for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 	 ci++, compptr++) {
-      main->whole_image[ci] = (*cinfo->mem->request_virt_sarray)
+      mainptr->whole_image[ci] = (*cinfo->mem->request_virt_sarray)
 	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
 	 compptr->width_in_blocks * compptr->DCT_h_scaled_size,
 	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
@@ -279,12 +279,12 @@
 #endif
   } else {
 #ifdef FULL_MAIN_BUFFER_SUPPORTED
-    main->whole_image[0] = NULL; /* flag for no virtual arrays */
+    mainptr->whole_image[0] = NULL; /* flag for no virtual arrays */
 #endif
     /* Allocate a strip buffer for each component */
     for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 	 ci++, compptr++) {
-      main->buffer[ci] = (*cinfo->mem->alloc_sarray)
+      mainptr->buffer[ci] = (*cinfo->mem->alloc_sarray)
 	((j_common_ptr) cinfo, JPOOL_IMAGE,
 	 compptr->width_in_blocks * compptr->DCT_h_scaled_size,
 	 (JDIMENSION) (compptr->v_samp_factor * compptr->DCT_v_scaled_size));
diff -Naur libAfterImage-1.20/libjpeg/jconfig.h root/graf2d/asimage/src/libAfterImage/libjpeg/jconfig.h
--- libAfterImage-1.20/libjpeg/jconfig.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libjpeg/jconfig.h	2018-12-08 08:18:38.000000000 +0100
@@ -3,8 +3,12 @@
 /* see jconfig.txt for explanations */
 
 #define HAVE_PROTOTYPES 1
-#define HAVE_UNSIGNED_CHAR 1
-#define HAVE_UNSIGNED_SHORT 1
+#ifndef HAVE_UNSIGNED_CHAR
+# define HAVE_UNSIGNED_CHAR 1
+#endif
+#ifndef HAVE_UNSIGNED_SHORT
+# define HAVE_UNSIGNED_SHORT 1
+#endif
 /* #undef void */
 /* #undef const */
 /* #undef CHAR_IS_UNSIGNED */
@@ -21,7 +25,7 @@
 #ifdef JPEG_INTERNALS
 
 /* #undef RIGHT_SHIFT_IS_UNSIGNED */
-#define INLINE __inline__
+/* #define INLINE __inline__ */
 /* These are for configuring the JPEG memory manager. */
 /* #undef DEFAULT_MAX_MEM */
 /* #undef NO_MKTEMP */
diff -Naur libAfterImage-1.20/libjpeg/jdhuff.c root/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c
--- libAfterImage-1.20/libjpeg/jdhuff.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c	2018-12-08 08:18:38.000000000 +0100
@@ -1506,7 +1506,7 @@
  */
 
 GLOBAL(void)
-jinit_huff_decoder (j_decompress_ptr cinfo)
+_jinit_huff_decoder (j_decompress_ptr cinfo) /*SASHA*/
 {
   huff_entropy_ptr entropy;
   int i;
diff -Naur libAfterImage-1.20/libjpeg/jdmainct.c root/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c
--- libAfterImage-1.20/libjpeg/jdmainct.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c	2018-12-08 08:18:38.000000000 +0100
@@ -159,7 +159,7 @@
  * This is done only once, not once per pass.
  */
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr mainptr = (my_main_ptr) cinfo->main;
   int ci, rgroup;
   int M = cinfo->min_DCT_v_scaled_size;
   jpeg_component_info *compptr;
@@ -168,10 +168,10 @@
   /* Get top-level space for component array pointers.
    * We alloc both arrays with one call to save a few cycles.
    */
-  main->xbuffer[0] = (JSAMPIMAGE)
+  mainptr->xbuffer[0] = (JSAMPIMAGE)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
-  main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;
+  mainptr->xbuffer[1] = mainptr->xbuffer[0] + cinfo->num_components;
 
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
@@ -184,9 +184,9 @@
       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
     xbuf += rgroup;		/* want one row group at negative offsets */
-    main->xbuffer[0][ci] = xbuf;
+    mainptr->xbuffer[0][ci] = xbuf;
     xbuf += rgroup * (M + 4);
-    main->xbuffer[1][ci] = xbuf;
+    mainptr->xbuffer[1][ci] = xbuf;
   }
 }
 
@@ -194,13 +194,13 @@
 LOCAL(void)
 make_funny_pointers (j_decompress_ptr cinfo)
 /* Create the funny pointer lists discussed in the comments above.
- * The actual workspace is already allocated (in main->buffer),
+ * The actual workspace is already allocated (in mainptr->buffer),
  * and the space for the pointer lists is allocated too.
  * This routine just fills in the curiously ordered lists.
  * This will be repeated at the beginning of each pass.
  */
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr mainptr = (my_main_ptr) cinfo->main;
   int ci, i, rgroup;
   int M = cinfo->min_DCT_v_scaled_size;
   jpeg_component_info *compptr;
@@ -210,10 +210,10 @@
        ci++, compptr++) {
     rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
       cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
-    xbuf0 = main->xbuffer[0][ci];
-    xbuf1 = main->xbuffer[1][ci];
+    xbuf0 = mainptr->xbuffer[0][ci];
+    xbuf1 = mainptr->xbuffer[1][ci];
     /* First copy the workspace pointers as-is */
-    buf = main->buffer[ci];
+    buf = mainptr->buffer[ci];
     for (i = 0; i < rgroup * (M + 2); i++) {
       xbuf0[i] = xbuf1[i] = buf[i];
     }
@@ -240,7 +240,7 @@
  * This changes the pointer list state from top-of-image to the normal state.
  */
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr mainptr = (my_main_ptr) cinfo->main;
   int ci, i, rgroup;
   int M = cinfo->min_DCT_v_scaled_size;
   jpeg_component_info *compptr;
@@ -250,8 +250,8 @@
        ci++, compptr++) {
     rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
       cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
-    xbuf0 = main->xbuffer[0][ci];
-    xbuf1 = main->xbuffer[1][ci];
+    xbuf0 = mainptr->xbuffer[0][ci];
+    xbuf1 = mainptr->xbuffer[1][ci];
     for (i = 0; i < rgroup; i++) {
       xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
       xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
@@ -269,7 +269,7 @@
  * Also sets rowgroups_avail to indicate number of nondummy row groups in row.
  */
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr mainptr = (my_main_ptr) cinfo->main;
   int ci, i, rgroup, iMCUheight, rows_left;
   jpeg_component_info *compptr;
   JSAMPARRAY xbuf;
@@ -286,12 +286,12 @@
      * so we need only do it once.
      */
     if (ci == 0) {
-      main->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
+      mainptr->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
     }
     /* Duplicate the last real sample row rgroup*2 times; this pads out the
      * last partial rowgroup and ensures at least one full rowgroup of context.
      */
-    xbuf = main->xbuffer[main->whichptr][ci];
+    xbuf = mainptr->xbuffer[mainptr->whichptr][ci];
     for (i = 0; i < rgroup * 2; i++) {
       xbuf[rows_left + i] = xbuf[rows_left-1];
     }
@@ -306,27 +306,27 @@
 METHODDEF(void)
 start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr mainptr = (my_main_ptr) cinfo->main;
 
   switch (pass_mode) {
   case JBUF_PASS_THRU:
     if (cinfo->upsample->need_context_rows) {
-      main->pub.process_data = process_data_context_main;
+      mainptr->pub.process_data = process_data_context_main;
       make_funny_pointers(cinfo); /* Create the xbuffer[] lists */
-      main->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
-      main->context_state = CTX_PREPARE_FOR_IMCU;
-      main->iMCU_row_ctr = 0;
+      mainptr->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
+      mainptr->context_state = CTX_PREPARE_FOR_IMCU;
+      mainptr->iMCU_row_ctr = 0;
     } else {
       /* Simple case with no context needed */
-      main->pub.process_data = process_data_simple_main;
+      mainptr->pub.process_data = process_data_simple_main;
     }
-    main->buffer_full = FALSE;	/* Mark buffer empty */
-    main->rowgroup_ctr = 0;
+    mainptr->buffer_full = FALSE;	/* Mark buffer empty */
+    mainptr->rowgroup_ctr = 0;
     break;
 #ifdef QUANT_2PASS_SUPPORTED
   case JBUF_CRANK_DEST:
     /* For last pass of 2-pass quantization, just crank the postprocessor */
-    main->pub.process_data = process_data_crank_post;
+    mainptr->pub.process_data = process_data_crank_post;
     break;
 #endif
   default:
@@ -346,14 +346,14 @@
 			  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
 			  JDIMENSION out_rows_avail)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr mainptr = (my_main_ptr) cinfo->main;
   JDIMENSION rowgroups_avail;
 
   /* Read input data if we haven't filled the main buffer yet */
-  if (! main->buffer_full) {
-    if (! (*cinfo->coef->decompress_data) (cinfo, main->buffer))
+  if (! mainptr->buffer_full) {
+    if (! (*cinfo->coef->decompress_data) (cinfo, mainptr->buffer))
       return;			/* suspension forced, can do nothing more */
-    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
+    mainptr->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
   }
 
   /* There are always min_DCT_scaled_size row groups in an iMCU row. */
@@ -364,14 +364,14 @@
    */
 
   /* Feed the postprocessor */
-  (*cinfo->post->post_process_data) (cinfo, main->buffer,
-				     &main->rowgroup_ctr, rowgroups_avail,
+  (*cinfo->post->post_process_data) (cinfo, mainptr->buffer,
+				     &mainptr->rowgroup_ctr, rowgroups_avail,
 				     output_buf, out_row_ctr, out_rows_avail);
 
   /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
-  if (main->rowgroup_ctr >= rowgroups_avail) {
-    main->buffer_full = FALSE;
-    main->rowgroup_ctr = 0;
+  if (mainptr->rowgroup_ctr >= rowgroups_avail) {
+    mainptr->buffer_full = FALSE;
+    mainptr->rowgroup_ctr = 0;
   }
 }
 
@@ -386,15 +386,15 @@
 			   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
 			   JDIMENSION out_rows_avail)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr mainptr = (my_main_ptr) cinfo->main;
 
   /* Read input data if we haven't filled the main buffer yet */
-  if (! main->buffer_full) {
+  if (! mainptr->buffer_full) {
     if (! (*cinfo->coef->decompress_data) (cinfo,
-					   main->xbuffer[main->whichptr]))
+					   mainptr->xbuffer[mainptr->whichptr]))
       return;			/* suspension forced, can do nothing more */
-    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
-    main->iMCU_row_ctr++;	/* count rows received */
+    mainptr->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
+    mainptr->iMCU_row_ctr++;	/* count rows received */
   }
 
   /* Postprocessor typically will not swallow all the input data it is handed
@@ -402,47 +402,47 @@
    * to exit and restart.  This switch lets us keep track of how far we got.
    * Note that each case falls through to the next on successful completion.
    */
-  switch (main->context_state) {
+  switch (mainptr->context_state) {
   case CTX_POSTPONED_ROW:
     /* Call postprocessor using previously set pointers for postponed row */
-    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
-			&main->rowgroup_ctr, main->rowgroups_avail,
+    (*cinfo->post->post_process_data) (cinfo, mainptr->xbuffer[mainptr->whichptr],
+			&mainptr->rowgroup_ctr, mainptr->rowgroups_avail,
 			output_buf, out_row_ctr, out_rows_avail);
-    if (main->rowgroup_ctr < main->rowgroups_avail)
+    if (mainptr->rowgroup_ctr < mainptr->rowgroups_avail)
       return;			/* Need to suspend */
-    main->context_state = CTX_PREPARE_FOR_IMCU;
+    mainptr->context_state = CTX_PREPARE_FOR_IMCU;
     if (*out_row_ctr >= out_rows_avail)
       return;			/* Postprocessor exactly filled output buf */
     /*FALLTHROUGH*/
   case CTX_PREPARE_FOR_IMCU:
     /* Prepare to process first M-1 row groups of this iMCU row */
-    main->rowgroup_ctr = 0;
-    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size - 1);
+    mainptr->rowgroup_ctr = 0;
+    mainptr->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size - 1);
     /* Check for bottom of image: if so, tweak pointers to "duplicate"
      * the last sample row, and adjust rowgroups_avail to ignore padding rows.
      */
-    if (main->iMCU_row_ctr == cinfo->total_iMCU_rows)
+    if (mainptr->iMCU_row_ctr == cinfo->total_iMCU_rows)
       set_bottom_pointers(cinfo);
-    main->context_state = CTX_PROCESS_IMCU;
+    mainptr->context_state = CTX_PROCESS_IMCU;
     /*FALLTHROUGH*/
   case CTX_PROCESS_IMCU:
     /* Call postprocessor using previously set pointers */
-    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
-			&main->rowgroup_ctr, main->rowgroups_avail,
+    (*cinfo->post->post_process_data) (cinfo, mainptr->xbuffer[mainptr->whichptr],
+			&mainptr->rowgroup_ctr, mainptr->rowgroups_avail,
 			output_buf, out_row_ctr, out_rows_avail);
-    if (main->rowgroup_ctr < main->rowgroups_avail)
+    if (mainptr->rowgroup_ctr < mainptr->rowgroups_avail)
       return;			/* Need to suspend */
     /* After the first iMCU, change wraparound pointers to normal state */
-    if (main->iMCU_row_ctr == 1)
+    if (mainptr->iMCU_row_ctr == 1)
       set_wraparound_pointers(cinfo);
     /* Prepare to load new iMCU row using other xbuffer list */
-    main->whichptr ^= 1;	/* 0=>1 or 1=>0 */
-    main->buffer_full = FALSE;
+    mainptr->whichptr ^= 1;	/* 0=>1 or 1=>0 */
+    mainptr->buffer_full = FALSE;
     /* Still need to process last row group of this iMCU row, */
     /* which is saved at index M+1 of the other xbuffer */
-    main->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 1);
-    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 2);
-    main->context_state = CTX_POSTPONED_ROW;
+    mainptr->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 1);
+    mainptr->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 2);
+    mainptr->context_state = CTX_POSTPONED_ROW;
   }
 }
 
@@ -475,15 +475,15 @@
 GLOBAL(void)
 jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
 {
-  my_main_ptr main;
+  my_main_ptr mainptr;
   int ci, rgroup, ngroups;
   jpeg_component_info *compptr;
 
-  main = (my_main_ptr)
+  mainptr = (my_main_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(my_main_controller));
-  cinfo->main = (struct jpeg_d_main_controller *) main;
-  main->pub.start_pass = start_pass_main;
+  cinfo->main = (struct jpeg_d_main_controller *) mainptr;
+  mainptr->pub.start_pass = start_pass_main;
 
   if (need_full_buffer)		/* shouldn't happen */
     ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
@@ -504,7 +504,7 @@
        ci++, compptr++) {
     rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
       cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
-    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
+    mainptr->buffer[ci] = (*cinfo->mem->alloc_sarray)
 			((j_common_ptr) cinfo, JPOOL_IMAGE,
 			 compptr->width_in_blocks * compptr->DCT_h_scaled_size,
 			 (JDIMENSION) (rgroup * ngroups));
diff -Naur libAfterImage-1.20/libjpeg/jidctred.c root/graf2d/asimage/src/libAfterImage/libjpeg/jidctred.c
--- libAfterImage-1.20/libjpeg/jidctred.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libjpeg/jidctred.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,398 +0,0 @@
-/*
- * jidctred.c
- *
- * Copyright (C) 1994-1998, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file contains inverse-DCT routines that produce reduced-size output:
- * either 4x4, 2x2, or 1x1 pixels from an 8x8 DCT block.
- *
- * The implementation is based on the Loeffler, Ligtenberg and Moschytz (LL&M)
- * algorithm used in jidctint.c.  We simply replace each 8-to-8 1-D IDCT step
- * with an 8-to-4 step that produces the four averages of two adjacent outputs
- * (or an 8-to-2 step producing two averages of four outputs, for 2x2 output).
- * These steps were derived by computing the corresponding values at the end
- * of the normal LL&M code, then simplifying as much as possible.
- *
- * 1x1 is trivial: just take the DC coefficient divided by 8.
- *
- * See jidctint.c for additional comments.
- */
-
-#define JPEG_INTERNALS
-#include "jinclude.h"
-#include "jpeglib.h"
-#include "jdct.h"		/* Private declarations for DCT subsystem */
-
-#ifdef IDCT_SCALING_SUPPORTED
-
-
-/*
- * This module is specialized to the case DCTSIZE = 8.
- */
-
-#if DCTSIZE != 8
-  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
-#endif
-
-
-/* Scaling is the same as in jidctint.c. */
-
-#if BITS_IN_JSAMPLE == 8
-#define CONST_BITS  13
-#define PASS1_BITS  2
-#else
-#define CONST_BITS  13
-#define PASS1_BITS  1		/* lose a little precision to avoid overflow */
-#endif
-
-/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
- * causing a lot of useless floating-point operations at run time.
- * To get around this we use the following pre-calculated constants.
- * If you change CONST_BITS you may want to add appropriate values.
- * (With a reasonable C compiler, you can just rely on the FIX() macro...)
- */
-
-#if CONST_BITS == 13
-#define FIX_0_211164243  ((INT32)  1730)	/* FIX(0.211164243) */
-#define FIX_0_509795579  ((INT32)  4176)	/* FIX(0.509795579) */
-#define FIX_0_601344887  ((INT32)  4926)	/* FIX(0.601344887) */
-#define FIX_0_720959822  ((INT32)  5906)	/* FIX(0.720959822) */
-#define FIX_0_765366865  ((INT32)  6270)	/* FIX(0.765366865) */
-#define FIX_0_850430095  ((INT32)  6967)	/* FIX(0.850430095) */
-#define FIX_0_899976223  ((INT32)  7373)	/* FIX(0.899976223) */
-#define FIX_1_061594337  ((INT32)  8697)	/* FIX(1.061594337) */
-#define FIX_1_272758580  ((INT32)  10426)	/* FIX(1.272758580) */
-#define FIX_1_451774981  ((INT32)  11893)	/* FIX(1.451774981) */
-#define FIX_1_847759065  ((INT32)  15137)	/* FIX(1.847759065) */
-#define FIX_2_172734803  ((INT32)  17799)	/* FIX(2.172734803) */
-#define FIX_2_562915447  ((INT32)  20995)	/* FIX(2.562915447) */
-#define FIX_3_624509785  ((INT32)  29692)	/* FIX(3.624509785) */
-#else
-#define FIX_0_211164243  FIX(0.211164243)
-#define FIX_0_509795579  FIX(0.509795579)
-#define FIX_0_601344887  FIX(0.601344887)
-#define FIX_0_720959822  FIX(0.720959822)
-#define FIX_0_765366865  FIX(0.765366865)
-#define FIX_0_850430095  FIX(0.850430095)
-#define FIX_0_899976223  FIX(0.899976223)
-#define FIX_1_061594337  FIX(1.061594337)
-#define FIX_1_272758580  FIX(1.272758580)
-#define FIX_1_451774981  FIX(1.451774981)
-#define FIX_1_847759065  FIX(1.847759065)
-#define FIX_2_172734803  FIX(2.172734803)
-#define FIX_2_562915447  FIX(2.562915447)
-#define FIX_3_624509785  FIX(3.624509785)
-#endif
-
-
-/* Multiply an INT32 variable by an INT32 constant to yield an INT32 result.
- * For 8-bit samples with the recommended scaling, all the variable
- * and constant values involved are no more than 16 bits wide, so a
- * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.
- * For 12-bit samples, a full 32-bit multiplication will be needed.
- */
-
-#if BITS_IN_JSAMPLE == 8
-#define MULTIPLY(var,const)  MULTIPLY16C16(var,const)
-#else
-#define MULTIPLY(var,const)  ((var) * (const))
-#endif
-
-
-/* Dequantize a coefficient by multiplying it by the multiplier-table
- * entry; produce an int result.  In this module, both inputs and result
- * are 16 bits or less, so either int or short multiply will work.
- */
-
-#define DEQUANTIZE(coef,quantval)  (((ISLOW_MULT_TYPE) (coef)) * (quantval))
-
-
-/*
- * Perform dequantization and inverse DCT on one block of coefficients,
- * producing a reduced-size 4x4 output block.
- */
-
-GLOBAL(void)
-jpeg_idct_4x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
-	       JCOEFPTR coef_block,
-	       JSAMPARRAY output_buf, JDIMENSION output_col)
-{
-  INT32 tmp0, tmp2, tmp10, tmp12;
-  INT32 z1, z2, z3, z4;
-  JCOEFPTR inptr;
-  ISLOW_MULT_TYPE * quantptr;
-  int * wsptr;
-  JSAMPROW outptr;
-  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
-  int ctr;
-  int workspace[DCTSIZE*4];	/* buffers data between passes */
-  SHIFT_TEMPS
-
-  /* Pass 1: process columns from input, store into work array. */
-
-  inptr = coef_block;
-  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
-  wsptr = workspace;
-  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
-    /* Don't bother to process column 4, because second pass won't use it */
-    if (ctr == DCTSIZE-4)
-      continue;
-    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
-	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*5] == 0 &&
-	inptr[DCTSIZE*6] == 0 && inptr[DCTSIZE*7] == 0) {
-      /* AC terms all zero; we need not examine term 4 for 4x4 output */
-      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
-      
-      wsptr[DCTSIZE*0] = dcval;
-      wsptr[DCTSIZE*1] = dcval;
-      wsptr[DCTSIZE*2] = dcval;
-      wsptr[DCTSIZE*3] = dcval;
-      
-      continue;
-    }
-    
-    /* Even part */
-    
-    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
-    tmp0 <<= (CONST_BITS+1);
-    
-    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
-    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
-
-    tmp2 = MULTIPLY(z2, FIX_1_847759065) + MULTIPLY(z3, - FIX_0_765366865);
-    
-    tmp10 = tmp0 + tmp2;
-    tmp12 = tmp0 - tmp2;
-    
-    /* Odd part */
-    
-    z1 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
-    z2 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
-    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
-    z4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
-    
-    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */
-	 + MULTIPLY(z2, FIX_1_451774981) /* sqrt(2) * (c3+c7) */
-	 + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */
-	 + MULTIPLY(z4, FIX_1_061594337); /* sqrt(2) * (c5+c7) */
-    
-    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */
-	 + MULTIPLY(z2, - FIX_0_601344887) /* sqrt(2) * (c5-c1) */
-	 + MULTIPLY(z3, FIX_0_899976223) /* sqrt(2) * (c3-c7) */
-	 + MULTIPLY(z4, FIX_2_562915447); /* sqrt(2) * (c1+c3) */
-
-    /* Final output stage */
-    
-    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp2, CONST_BITS-PASS1_BITS+1);
-    wsptr[DCTSIZE*3] = (int) DESCALE(tmp10 - tmp2, CONST_BITS-PASS1_BITS+1);
-    wsptr[DCTSIZE*1] = (int) DESCALE(tmp12 + tmp0, CONST_BITS-PASS1_BITS+1);
-    wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 - tmp0, CONST_BITS-PASS1_BITS+1);
-  }
-  
-  /* Pass 2: process 4 rows from work array, store into output array. */
-
-  wsptr = workspace;
-  for (ctr = 0; ctr < 4; ctr++) {
-    outptr = output_buf[ctr] + output_col;
-    /* It's not clear whether a zero row test is worthwhile here ... */
-
-#ifndef NO_ZERO_ROW_TEST
-    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 &&
-	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
-      /* AC terms all zero */
-      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
-				  & RANGE_MASK];
-      
-      outptr[0] = dcval;
-      outptr[1] = dcval;
-      outptr[2] = dcval;
-      outptr[3] = dcval;
-      
-      wsptr += DCTSIZE;		/* advance pointer to next row */
-      continue;
-    }
-#endif
-    
-    /* Even part */
-    
-    tmp0 = ((INT32) wsptr[0]) << (CONST_BITS+1);
-    
-    tmp2 = MULTIPLY((INT32) wsptr[2], FIX_1_847759065)
-	 + MULTIPLY((INT32) wsptr[6], - FIX_0_765366865);
-    
-    tmp10 = tmp0 + tmp2;
-    tmp12 = tmp0 - tmp2;
-    
-    /* Odd part */
-    
-    z1 = (INT32) wsptr[7];
-    z2 = (INT32) wsptr[5];
-    z3 = (INT32) wsptr[3];
-    z4 = (INT32) wsptr[1];
-    
-    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */
-	 + MULTIPLY(z2, FIX_1_451774981) /* sqrt(2) * (c3+c7) */
-	 + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */
-	 + MULTIPLY(z4, FIX_1_061594337); /* sqrt(2) * (c5+c7) */
-    
-    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */
-	 + MULTIPLY(z2, - FIX_0_601344887) /* sqrt(2) * (c5-c1) */
-	 + MULTIPLY(z3, FIX_0_899976223) /* sqrt(2) * (c3-c7) */
-	 + MULTIPLY(z4, FIX_2_562915447); /* sqrt(2) * (c1+c3) */
-
-    /* Final output stage */
-    
-    outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp2,
-					  CONST_BITS+PASS1_BITS+3+1)
-			    & RANGE_MASK];
-    outptr[3] = range_limit[(int) DESCALE(tmp10 - tmp2,
-					  CONST_BITS+PASS1_BITS+3+1)
-			    & RANGE_MASK];
-    outptr[1] = range_limit[(int) DESCALE(tmp12 + tmp0,
-					  CONST_BITS+PASS1_BITS+3+1)
-			    & RANGE_MASK];
-    outptr[2] = range_limit[(int) DESCALE(tmp12 - tmp0,
-					  CONST_BITS+PASS1_BITS+3+1)
-			    & RANGE_MASK];
-    
-    wsptr += DCTSIZE;		/* advance pointer to next row */
-  }
-}
-
-
-/*
- * Perform dequantization and inverse DCT on one block of coefficients,
- * producing a reduced-size 2x2 output block.
- */
-
-GLOBAL(void)
-jpeg_idct_2x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
-	       JCOEFPTR coef_block,
-	       JSAMPARRAY output_buf, JDIMENSION output_col)
-{
-  INT32 tmp0, tmp10, z1;
-  JCOEFPTR inptr;
-  ISLOW_MULT_TYPE * quantptr;
-  int * wsptr;
-  JSAMPROW outptr;
-  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
-  int ctr;
-  int workspace[DCTSIZE*2];	/* buffers data between passes */
-  SHIFT_TEMPS
-
-  /* Pass 1: process columns from input, store into work array. */
-
-  inptr = coef_block;
-  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
-  wsptr = workspace;
-  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
-    /* Don't bother to process columns 2,4,6 */
-    if (ctr == DCTSIZE-2 || ctr == DCTSIZE-4 || ctr == DCTSIZE-6)
-      continue;
-    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*3] == 0 &&
-	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*7] == 0) {
-      /* AC terms all zero; we need not examine terms 2,4,6 for 2x2 output */
-      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
-      
-      wsptr[DCTSIZE*0] = dcval;
-      wsptr[DCTSIZE*1] = dcval;
-      
-      continue;
-    }
-    
-    /* Even part */
-    
-    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
-    tmp10 = z1 << (CONST_BITS+2);
-    
-    /* Odd part */
-
-    z1 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
-    tmp0 = MULTIPLY(z1, - FIX_0_720959822); /* sqrt(2) * (c7-c5+c3-c1) */
-    z1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
-    tmp0 += MULTIPLY(z1, FIX_0_850430095); /* sqrt(2) * (-c1+c3+c5+c7) */
-    z1 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
-    tmp0 += MULTIPLY(z1, - FIX_1_272758580); /* sqrt(2) * (-c1+c3-c5-c7) */
-    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
-    tmp0 += MULTIPLY(z1, FIX_3_624509785); /* sqrt(2) * (c1+c3+c5+c7) */
-
-    /* Final output stage */
-    
-    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp0, CONST_BITS-PASS1_BITS+2);
-    wsptr[DCTSIZE*1] = (int) DESCALE(tmp10 - tmp0, CONST_BITS-PASS1_BITS+2);
-  }
-  
-  /* Pass 2: process 2 rows from work array, store into output array. */
-
-  wsptr = workspace;
-  for (ctr = 0; ctr < 2; ctr++) {
-    outptr = output_buf[ctr] + output_col;
-    /* It's not clear whether a zero row test is worthwhile here ... */
-
-#ifndef NO_ZERO_ROW_TEST
-    if (wsptr[1] == 0 && wsptr[3] == 0 && wsptr[5] == 0 && wsptr[7] == 0) {
-      /* AC terms all zero */
-      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
-				  & RANGE_MASK];
-      
-      outptr[0] = dcval;
-      outptr[1] = dcval;
-      
-      wsptr += DCTSIZE;		/* advance pointer to next row */
-      continue;
-    }
-#endif
-    
-    /* Even part */
-    
-    tmp10 = ((INT32) wsptr[0]) << (CONST_BITS+2);
-    
-    /* Odd part */
-
-    tmp0 = MULTIPLY((INT32) wsptr[7], - FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */
-	 + MULTIPLY((INT32) wsptr[5], FIX_0_850430095) /* sqrt(2) * (-c1+c3+c5+c7) */
-	 + MULTIPLY((INT32) wsptr[3], - FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */
-	 + MULTIPLY((INT32) wsptr[1], FIX_3_624509785); /* sqrt(2) * (c1+c3+c5+c7) */
-
-    /* Final output stage */
-    
-    outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp0,
-					  CONST_BITS+PASS1_BITS+3+2)
-			    & RANGE_MASK];
-    outptr[1] = range_limit[(int) DESCALE(tmp10 - tmp0,
-					  CONST_BITS+PASS1_BITS+3+2)
-			    & RANGE_MASK];
-    
-    wsptr += DCTSIZE;		/* advance pointer to next row */
-  }
-}
-
-
-/*
- * Perform dequantization and inverse DCT on one block of coefficients,
- * producing a reduced-size 1x1 output block.
- */
-
-GLOBAL(void)
-jpeg_idct_1x1 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
-	       JCOEFPTR coef_block,
-	       JSAMPARRAY output_buf, JDIMENSION output_col)
-{
-  int dcval;
-  ISLOW_MULT_TYPE * quantptr;
-  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
-  SHIFT_TEMPS
-
-  /* We hardly need an inverse DCT routine for this: just take the
-   * average pixel value, which is one-eighth of the DC coefficient.
-   */
-  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
-  dcval = DEQUANTIZE(coef_block[0], quantptr[0]);
-  dcval = (int) DESCALE((INT32) dcval, 3);
-
-  output_buf[0][output_col] = range_limit[dcval & RANGE_MASK];
-}
-
-#endif /* IDCT_SCALING_SUPPORTED */
diff -Naur libAfterImage-1.20/libjpeg/jmorecfg.h root/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h
--- libAfterImage-1.20/libjpeg/jmorecfg.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h	2018-12-08 08:18:38.000000000 +0100
@@ -233,7 +233,7 @@
  */
 
 #ifndef HAVE_BOOLEAN
-typedef int boolean;
+typedef unsigned char boolean;
 #endif
 #ifndef FALSE			/* in case these macros already exist */
 #define FALSE	0		/* values of boolean */
diff -Naur libAfterImage-1.20/libjpeg/jpegint.h root/graf2d/asimage/src/libAfterImage/libjpeg/jpegint.h
--- libAfterImage-1.20/libjpeg/jpegint.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libjpeg/jpegint.h	2018-12-08 08:18:38.000000000 +0100
@@ -301,7 +301,7 @@
 #define jinit_color_converter	jICColor
 #define jinit_downsampler	jIDownsampler
 #define jinit_forward_dct	jIFDCT
-#define jinit_huff_encoder	jIHEncoder
+#define _jinit_huff_encoder	jIHEncoder
 #define jinit_arith_encoder	jIAEncoder
 #define jinit_marker_writer	jIMWriter
 #define jinit_master_decompress	jIDMaster
@@ -349,7 +349,8 @@
 EXTERN(void) jinit_color_converter JPP((j_compress_ptr cinfo));
 EXTERN(void) jinit_downsampler JPP((j_compress_ptr cinfo));
 EXTERN(void) jinit_forward_dct JPP((j_compress_ptr cinfo));
-EXTERN(void) jinit_huff_encoder JPP((j_compress_ptr cinfo));
+EXTERN(void) _jinit_huff_encoder JPP((j_compress_ptr cinfo));
+#define jinit_huff_encoder _jinit_huff_encoder
 EXTERN(void) jinit_arith_encoder JPP((j_compress_ptr cinfo));
 EXTERN(void) jinit_marker_writer JPP((j_compress_ptr cinfo));
 /* Decompression module initialization routines */
@@ -362,7 +363,8 @@
 					  boolean need_full_buffer));
 EXTERN(void) jinit_input_controller JPP((j_decompress_ptr cinfo));
 EXTERN(void) jinit_marker_reader JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_huff_decoder JPP((j_decompress_ptr cinfo));
+EXTERN(void) _jinit_huff_decoder JPP((j_decompress_ptr cinfo));
+#define jinit_huff_decoder _jinit_huff_decoder
 EXTERN(void) jinit_arith_decoder JPP((j_decompress_ptr cinfo));
 EXTERN(void) jinit_inverse_dct JPP((j_decompress_ptr cinfo));
 EXTERN(void) jinit_upsampler JPP((j_decompress_ptr cinfo));
diff -Naur libAfterImage-1.20/libjpeg/jquant2.c root/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c
--- libAfterImage-1.20/libjpeg/jquant2.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c	2018-12-08 08:18:38.000000000 +0100
@@ -1171,7 +1171,7 @@
   int i;
 
   /* Only F-S dithering or no dithering is supported. */
-  /* If user asks for ordered dither, give him F-S. */
+  /* If user asks for ordered dither, give them F-S. */
   if (cinfo->dither_mode != JDITHER_NONE)
     cinfo->dither_mode = JDITHER_FS;
 
@@ -1289,7 +1289,7 @@
     cquantize->sv_colormap = NULL;
 
   /* Only F-S dithering or no dithering is supported. */
-  /* If user asks for ordered dither, give him F-S. */
+  /* If user asks for ordered dither, give them F-S. */
   if (cinfo->dither_mode != JDITHER_NONE)
     cinfo->dither_mode = JDITHER_FS;
 
diff -Naur libAfterImage-1.20/libpng/LICENSE root/graf2d/asimage/src/libAfterImage/libpng/LICENSE
--- libAfterImage-1.20/libpng/LICENSE	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/LICENSE	2018-12-08 08:18:38.000000000 +0100
@@ -8,20 +8,17 @@
 If you modify libpng you may insert additional notices immediately following
 this sentence.
 
-libpng versions 1.2.6, August 15, 2004, through 1.2.23, November 6, 2007, are
-Copyright (c) 2004, 2006-2007 Glenn Randers-Pehrson, and are
-distributed according to the same disclaimer and license as libpng-1.2.5
-with the following individual added to the list of Contributing Authors
+This code is released under the libpng license.
 
-   Cosmin Truta
-
-libpng versions 1.0.7, July 1, 2000, through 1.2.5 - October 3, 2002, are
-Copyright (c) 2000-2002 Glenn Randers-Pehrson, and are
-distributed according to the same disclaimer and license as libpng-1.0.6
-with the following individuals added to the list of Contributing Authors
+libpng versions 1.0.7, July 1, 2000, through 1.2.55, December 3, 2015, are
+Copyright (c) 2000-2002, 2004, 2006-2015 Glenn Randers-Pehrson, are
+derived from libpng-1.0.6, and are distributed according to the same
+disclaimer and license as libpng-1.0.6 with the following individuals
+added to the list of Contributing Authors:
 
    Simon-Pierre Cadieux
    Eric S. Raymond
+   Cosmin Truta
    Gilles Vollant
 
 and with the following additions to the disclaimer:
@@ -34,18 +31,20 @@
    the user.
 
 libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
-Copyright (c) 1998, 1999 Glenn Randers-Pehrson, and are
-distributed according to the same disclaimer and license as libpng-0.96,
-with the following individuals added to the list of Contributing Authors:
+Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from
+libpng-0.96, and are distributed according to the same disclaimer and
+license as libpng-0.96, with the following individuals added to the list
+of Contributing Authors:
 
    Tom Lane
    Glenn Randers-Pehrson
    Willem van Schaik
 
 libpng versions 0.89, June 1996, through 0.96, May 1997, are
-Copyright (c) 1996, 1997 Andreas Dilger
-Distributed according to the same disclaimer and license as libpng-0.88,
-with the following individuals added to the list of Contributing Authors:
+Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88,
+and are distributed according to the same disclaimer and license as
+libpng-0.88, with the following individuals added to the list of
+Contributing Authors:
 
    John Bowler
    Kevin Bracey
@@ -55,7 +54,7 @@
    Tom Tanner
 
 libpng versions 0.5, May 1995, through 0.88, January 1996, are
-Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
+Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
 
 For the purposes of this copyright and license, "Contributing Authors"
 is defined as the following set of individuals:
@@ -78,13 +77,13 @@
 source code, or portions hereof, for any purpose, without fee, subject
 to the following restrictions:
 
-1. The origin of this source code must not be misrepresented.
+  1. The origin of this source code must not be misrepresented.
 
-2. Altered versions must be plainly marked as such and must not
-   be misrepresented as being the original source.
+  2. Altered versions must be plainly marked as such and must not
+     be misrepresented as being the original source.
 
-3. This Copyright notice may not be removed or altered from any
-   source or altered source distribution.
+  3. This Copyright notice may not be removed or altered from any
+     source or altered source distribution.
 
 The Contributing Authors and Group 42, Inc. specifically permit, without
 fee, and encourage the use of this source code as a component to
@@ -92,18 +91,20 @@
 source code in a product, acknowledgment is not required but would be
 appreciated.
 
+END OF COPYRIGHT NOTICE, DISCLAIMER, and LICENSE.
 
 A "png_get_copyright" function is available, for convenient use in "about"
 boxes and the like:
 
-   printf("%s",png_get_copyright(NULL));
+   printf("%s", png_get_copyright(NULL));
 
 Also, the PNG logo (in PNG format, of course) is supplied in the
 files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
 
-Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is a
-certification mark of the Open Source Initiative.
+Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is
+a certification mark of the Open Source Initiative. OSI has not addressed
+the additional disclaimers inserted at version 1.0.7.
 
 Glenn Randers-Pehrson
 glennrp at users.sourceforge.net
-November 6, 2007
+December 3, 2015
diff -Naur libAfterImage-1.20/libpng/png.c root/graf2d/asimage/src/libAfterImage/libpng/png.c
--- libAfterImage-1.20/libpng/png.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/png.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,22 +1,27 @@
 
 /* png.c - location for general purpose libpng functions
  *
- * Last changed in libpng 1.2.21 October 4, 2007
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.54 [November 12, 2015]
+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
  */
 
 #define PNG_INTERNAL
 #define PNG_NO_EXTERN
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
 
 /* Generate a compiler error if there is an old png.h in the search path. */
-typedef version_1_2_23 Your_png_h_is_not_version_1_2_23;
+typedef version_1_2_55 Your_png_h_is_not_version_1_2_55;
 
 /* Version information for C files.  This had better match the version
- * string defined in png.h.  */
+ * string defined in png.h.
+ */
 
 #ifdef PNG_USE_GLOBAL_ARRAYS
 /* png_libpng_ver was changed to a function in version 1.0.5c */
@@ -53,18 +58,18 @@
 PNG_zTXt;
 
 #ifdef PNG_READ_SUPPORTED
-/* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
+/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
-/* start of interlace block */
+/* Start of interlace block */
 PNG_CONST int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
 
-/* offset to next interlace block */
+/* Offset to next interlace block */
 PNG_CONST int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
 
-/* start of interlace block in the y direction */
+/* Start of interlace block in the y direction */
 PNG_CONST int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
 
-/* offset to next interlace block in the y direction */
+/* Offset to next interlace block in the y direction */
 PNG_CONST int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
 
 /* Height of interlace block.  This is not currently used - if you need
@@ -73,7 +78,8 @@
 */
 
 /* Mask to determine which pixels are valid in a pass */
-PNG_CONST int FARDATA png_pass_mask[] = {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};
+PNG_CONST int FARDATA png_pass_mask[] =
+    {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};
 
 /* Mask to determine which pixels to overwrite while displaying */
 PNG_CONST int FARDATA png_pass_dsp_mask[]
@@ -92,8 +98,11 @@
 void PNGAPI
 png_set_sig_bytes(png_structp png_ptr, int num_bytes)
 {
-   if(png_ptr == NULL) return;
-   png_debug(1, "in png_set_sig_bytes\n");
+   png_debug(1, "in png_set_sig_bytes");
+
+   if (png_ptr == NULL)
+      return;
+
    if (num_bytes > 8)
       png_error(png_ptr, "Too many bytes for PNG signature.");
 
@@ -144,16 +153,21 @@
 #ifdef PNG_1_0_X
 voidpf PNGAPI
 #else
-voidpf /* private */
+voidpf /* PRIVATE */
 #endif
 png_zalloc(voidpf png_ptr, uInt items, uInt size)
 {
    png_voidp ptr;
-   png_structp p=(png_structp)png_ptr;
-   png_uint_32 save_flags=p->flags;
+   png_structp p;
+   png_uint_32 save_flags;
    png_uint_32 num_bytes;
 
-   if(png_ptr == NULL) return (NULL);
+   if (png_ptr == NULL)
+      return (NULL);
+
+   p=(png_structp)png_ptr;
+   save_flags=p->flags;
+
    if (items > PNG_UINT_32_MAX/size)
    {
      png_warning (p, "Potential overflow in png_zalloc()");
@@ -183,11 +197,11 @@
    return ((voidpf)ptr);
 }
 
-/* function to free memory for zlib */
+/* Function to free memory for zlib */
 #ifdef PNG_1_0_X
 void PNGAPI
 #else
-void /* private */
+void /* PRIVATE */
 #endif
 png_zfree(voidpf png_ptr, voidpf ptr)
 {
@@ -240,8 +254,11 @@
 {
    png_infop info_ptr;
 
-   png_debug(1, "in png_create_info_struct\n");
-   if(png_ptr == NULL) return (NULL);
+   png_debug(1, "in png_create_info_struct");
+
+   if (png_ptr == NULL)
+      return (NULL);
+
 #ifdef PNG_USER_MEM_SUPPORTED
    info_ptr = (png_infop)png_create_struct_2(PNG_STRUCT_INFO,
       png_ptr->malloc_fn, png_ptr->mem_ptr);
@@ -263,9 +280,12 @@
 png_destroy_info_struct(png_structp png_ptr, png_infopp info_ptr_ptr)
 {
    png_infop info_ptr = NULL;
-   if(png_ptr == NULL) return;
 
-   png_debug(1, "in png_destroy_info_struct\n");
+   png_debug(1, "in png_destroy_info_struct");
+
+   if (png_ptr == NULL)
+      return;
+
    if (info_ptr_ptr != NULL)
       info_ptr = *info_ptr_ptr;
 
@@ -302,19 +322,22 @@
 {
    png_infop info_ptr = *ptr_ptr;
 
-   if(info_ptr == NULL) return;
+   png_debug(1, "in png_info_init_3");
 
-   png_debug(1, "in png_info_init_3\n");
+   if (info_ptr == NULL)
+      return;
 
-   if(png_sizeof(png_info) > png_info_struct_size)
-     {
-       png_destroy_struct(info_ptr);
-       info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
-       *ptr_ptr = info_ptr;
-     }
+   if (png_sizeof(png_info) > png_info_struct_size)
+   {
+      png_destroy_struct(info_ptr);
+      info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
+      *ptr_ptr = info_ptr;
+      if (info_ptr == NULL)
+         return;
+   }
 
-   /* set everything to 0 */
-   png_memset(info_ptr, 0, png_sizeof (png_info));
+   /* Set everything to 0 */
+   png_memset(info_ptr, 0, png_sizeof(png_info));
 }
 
 #ifdef PNG_FREE_ME_SUPPORTED
@@ -322,12 +345,14 @@
 png_data_freer(png_structp png_ptr, png_infop info_ptr,
    int freer, png_uint_32 mask)
 {
-   png_debug(1, "in png_data_freer\n");
+   png_debug(1, "in png_data_freer");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
-   if(freer == PNG_DESTROY_WILL_FREE_DATA)
+
+   if (freer == PNG_DESTROY_WILL_FREE_DATA)
       info_ptr->free_me |= mask;
-   else if(freer == PNG_USER_WILL_FREE_DATA)
+   else if (freer == PNG_USER_WILL_FREE_DATA)
       info_ptr->free_me &= ~mask;
    else
       png_warning(png_ptr,
@@ -339,249 +364,251 @@
 png_free_data(png_structp png_ptr, png_infop info_ptr, png_uint_32 mask,
    int num)
 {
-   png_debug(1, "in png_free_data\n");
+   png_debug(1, "in png_free_data");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
-#if defined(PNG_TEXT_SUPPORTED)
-/* free text item num or (if num == -1) all text items */
+#ifdef PNG_TEXT_SUPPORTED
+   /* Free text item num or (if num == -1) all text items */
 #ifdef PNG_FREE_ME_SUPPORTED
-if ((mask & PNG_FREE_TEXT) & info_ptr->free_me)
+   if ((mask & PNG_FREE_TEXT) & info_ptr->free_me)
 #else
-if (mask & PNG_FREE_TEXT)
+   if (mask & PNG_FREE_TEXT)
 #endif
-{
-   if (num != -1)
-   {
-     if (info_ptr->text && info_ptr->text[num].key)
-     {
-         png_free(png_ptr, info_ptr->text[num].key);
-         info_ptr->text[num].key = NULL;
-     }
-   }
-   else
    {
-       int i;
-       for (i = 0; i < info_ptr->num_text; i++)
-           png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, i);
-       png_free(png_ptr, info_ptr->text);
-       info_ptr->text = NULL;
-       info_ptr->num_text=0;
+      if (num != -1)
+      {
+         if (info_ptr->text && info_ptr->text[num].key)
+         {
+            png_free(png_ptr, info_ptr->text[num].key);
+            info_ptr->text[num].key = NULL;
+         }
+      }
+      else
+      {
+         int i;
+         for (i = 0; i < info_ptr->num_text; i++)
+             png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, i);
+         png_free(png_ptr, info_ptr->text);
+         info_ptr->text = NULL;
+         info_ptr->num_text=0;
+      }
    }
-}
 #endif
 
-#if defined(PNG_tRNS_SUPPORTED)
-/* free any tRNS entry */
+#ifdef PNG_tRNS_SUPPORTED
+   /* Free any tRNS entry */
 #ifdef PNG_FREE_ME_SUPPORTED
-if ((mask & PNG_FREE_TRNS) & info_ptr->free_me)
+   if ((mask & PNG_FREE_TRNS) & info_ptr->free_me)
 #else
-if ((mask & PNG_FREE_TRNS) && (png_ptr->flags & PNG_FLAG_FREE_TRNS))
+   if ((mask & PNG_FREE_TRNS) && (png_ptr->flags & PNG_FLAG_FREE_TRNS))
 #endif
-{
-    png_free(png_ptr, info_ptr->trans);
-    info_ptr->valid &= ~PNG_INFO_tRNS;
+   {
+      png_free(png_ptr, info_ptr->trans);
+      info_ptr->trans = NULL;
+      info_ptr->valid &= ~PNG_INFO_tRNS;
 #ifndef PNG_FREE_ME_SUPPORTED
-    png_ptr->flags &= ~PNG_FLAG_FREE_TRNS;
+      png_ptr->flags &= ~PNG_FLAG_FREE_TRNS;
 #endif
-    info_ptr->trans = NULL;
-}
+   }
 #endif
 
-#if defined(PNG_sCAL_SUPPORTED)
-/* free any sCAL entry */
+#ifdef PNG_sCAL_SUPPORTED
+   /* Free any sCAL entry */
 #ifdef PNG_FREE_ME_SUPPORTED
-if ((mask & PNG_FREE_SCAL) & info_ptr->free_me)
+   if ((mask & PNG_FREE_SCAL) & info_ptr->free_me)
 #else
-if (mask & PNG_FREE_SCAL)
+   if (mask & PNG_FREE_SCAL)
 #endif
-{
+   {
 #if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
-    png_free(png_ptr, info_ptr->scal_s_width);
-    png_free(png_ptr, info_ptr->scal_s_height);
-    info_ptr->scal_s_width = NULL;
-    info_ptr->scal_s_height = NULL;
+      png_free(png_ptr, info_ptr->scal_s_width);
+      png_free(png_ptr, info_ptr->scal_s_height);
+      info_ptr->scal_s_width = NULL;
+      info_ptr->scal_s_height = NULL;
 #endif
-    info_ptr->valid &= ~PNG_INFO_sCAL;
-}
+      info_ptr->valid &= ~PNG_INFO_sCAL;
+   }
 #endif
 
-#if defined(PNG_pCAL_SUPPORTED)
-/* free any pCAL entry */
+#ifdef PNG_pCAL_SUPPORTED
+   /* Free any pCAL entry */
 #ifdef PNG_FREE_ME_SUPPORTED
-if ((mask & PNG_FREE_PCAL) & info_ptr->free_me)
+   if ((mask & PNG_FREE_PCAL) & info_ptr->free_me)
 #else
-if (mask & PNG_FREE_PCAL)
+   if (mask & PNG_FREE_PCAL)
 #endif
-{
-    png_free(png_ptr, info_ptr->pcal_purpose);
-    png_free(png_ptr, info_ptr->pcal_units);
-    info_ptr->pcal_purpose = NULL;
-    info_ptr->pcal_units = NULL;
-    if (info_ptr->pcal_params != NULL)
-    {
-        int i;
-        for (i = 0; i < (int)info_ptr->pcal_nparams; i++)
-        {
-          png_free(png_ptr, info_ptr->pcal_params[i]);
-          info_ptr->pcal_params[i]=NULL;
-        }
-        png_free(png_ptr, info_ptr->pcal_params);
-        info_ptr->pcal_params = NULL;
-    }
-    info_ptr->valid &= ~PNG_INFO_pCAL;
-}
+   {
+      png_free(png_ptr, info_ptr->pcal_purpose);
+      png_free(png_ptr, info_ptr->pcal_units);
+      info_ptr->pcal_purpose = NULL;
+      info_ptr->pcal_units = NULL;
+      if (info_ptr->pcal_params != NULL)
+         {
+            int i;
+            for (i = 0; i < (int)info_ptr->pcal_nparams; i++)
+            {
+               png_free(png_ptr, info_ptr->pcal_params[i]);
+               info_ptr->pcal_params[i] = NULL;
+            }
+            png_free(png_ptr, info_ptr->pcal_params);
+            info_ptr->pcal_params = NULL;
+         }
+      info_ptr->valid &= ~PNG_INFO_pCAL;
+   }
 #endif
 
-#if defined(PNG_iCCP_SUPPORTED)
-/* free any iCCP entry */
+#ifdef PNG_iCCP_SUPPORTED
+   /* Free any iCCP entry */
 #ifdef PNG_FREE_ME_SUPPORTED
-if ((mask & PNG_FREE_ICCP) & info_ptr->free_me)
+   if ((mask & PNG_FREE_ICCP) & info_ptr->free_me)
 #else
-if (mask & PNG_FREE_ICCP)
+   if (mask & PNG_FREE_ICCP)
 #endif
-{
-    png_free(png_ptr, info_ptr->iccp_name);
-    png_free(png_ptr, info_ptr->iccp_profile);
-    info_ptr->iccp_name = NULL;
-    info_ptr->iccp_profile = NULL;
-    info_ptr->valid &= ~PNG_INFO_iCCP;
-}
+   {
+      png_free(png_ptr, info_ptr->iccp_name);
+      png_free(png_ptr, info_ptr->iccp_profile);
+      info_ptr->iccp_name = NULL;
+      info_ptr->iccp_profile = NULL;
+      info_ptr->valid &= ~PNG_INFO_iCCP;
+   }
 #endif
 
-#if defined(PNG_sPLT_SUPPORTED)
-/* free a given sPLT entry, or (if num == -1) all sPLT entries */
+#ifdef PNG_sPLT_SUPPORTED
+   /* Free a given sPLT entry, or (if num == -1) all sPLT entries */
 #ifdef PNG_FREE_ME_SUPPORTED
-if ((mask & PNG_FREE_SPLT) & info_ptr->free_me)
+   if ((mask & PNG_FREE_SPLT) & info_ptr->free_me)
 #else
-if (mask & PNG_FREE_SPLT)
+   if (mask & PNG_FREE_SPLT)
 #endif
-{
-   if (num != -1)
    {
-      if(info_ptr->splt_palettes)
+      if (num != -1)
+      {
+         if (info_ptr->splt_palettes)
+         {
+            png_free(png_ptr, info_ptr->splt_palettes[num].name);
+            png_free(png_ptr, info_ptr->splt_palettes[num].entries);
+            info_ptr->splt_palettes[num].name = NULL;
+            info_ptr->splt_palettes[num].entries = NULL;
+         }
+      }
+      else
       {
-          png_free(png_ptr, info_ptr->splt_palettes[num].name);
-          png_free(png_ptr, info_ptr->splt_palettes[num].entries);
-          info_ptr->splt_palettes[num].name = NULL;
-          info_ptr->splt_palettes[num].entries = NULL;
+         if (info_ptr->splt_palettes_num)
+         {
+            int i;
+            for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)
+               png_free_data(png_ptr, info_ptr, PNG_FREE_SPLT, i);
+
+            png_free(png_ptr, info_ptr->splt_palettes);
+            info_ptr->splt_palettes = NULL;
+            info_ptr->splt_palettes_num = 0;
+         }
+         info_ptr->valid &= ~PNG_INFO_sPLT;
       }
    }
-   else
-   {
-       if(info_ptr->splt_palettes_num)
-       {
-         int i;
-         for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)
-            png_free_data(png_ptr, info_ptr, PNG_FREE_SPLT, i);
+#endif
 
-         png_free(png_ptr, info_ptr->splt_palettes);
-         info_ptr->splt_palettes = NULL;
-         info_ptr->splt_palettes_num = 0;
-       }
-       info_ptr->valid &= ~PNG_INFO_sPLT;
+#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
+   if (png_ptr->unknown_chunk.data)
+   {
+      png_free(png_ptr, png_ptr->unknown_chunk.data);
+      png_ptr->unknown_chunk.data = NULL;
    }
-}
-#endif
 
-#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
-  if(png_ptr->unknown_chunk.data)
-  {
-    png_free(png_ptr, png_ptr->unknown_chunk.data);
-    png_ptr->unknown_chunk.data = NULL;
-  }
 #ifdef PNG_FREE_ME_SUPPORTED
-if ((mask & PNG_FREE_UNKN) & info_ptr->free_me)
+   if ((mask & PNG_FREE_UNKN) & info_ptr->free_me)
 #else
-if (mask & PNG_FREE_UNKN)
+   if (mask & PNG_FREE_UNKN)
 #endif
-{
-   if (num != -1)
-   {
-       if(info_ptr->unknown_chunks)
-       {
-          png_free(png_ptr, info_ptr->unknown_chunks[num].data);
-          info_ptr->unknown_chunks[num].data = NULL;
-       }
-   }
-   else
    {
-       int i;
-
-       if(info_ptr->unknown_chunks_num)
-       {
-         for (i = 0; i < (int)info_ptr->unknown_chunks_num; i++)
-            png_free_data(png_ptr, info_ptr, PNG_FREE_UNKN, i);
+      if (num != -1)
+      {
+          if (info_ptr->unknown_chunks)
+          {
+             png_free(png_ptr, info_ptr->unknown_chunks[num].data);
+             info_ptr->unknown_chunks[num].data = NULL;
+          }
+      }
+      else
+      {
+         int i;
 
-         png_free(png_ptr, info_ptr->unknown_chunks);
-         info_ptr->unknown_chunks = NULL;
-         info_ptr->unknown_chunks_num = 0;
-       }
+         if (info_ptr->unknown_chunks_num)
+         {
+            for (i = 0; i < (int)info_ptr->unknown_chunks_num; i++)
+               png_free_data(png_ptr, info_ptr, PNG_FREE_UNKN, i);
+
+            png_free(png_ptr, info_ptr->unknown_chunks);
+            info_ptr->unknown_chunks = NULL;
+            info_ptr->unknown_chunks_num = 0;
+         }
+      }
    }
-}
 #endif
 
-#if defined(PNG_hIST_SUPPORTED)
-/* free any hIST entry */
+#ifdef PNG_hIST_SUPPORTED
+   /* Free any hIST entry */
 #ifdef PNG_FREE_ME_SUPPORTED
-if ((mask & PNG_FREE_HIST)  & info_ptr->free_me)
+   if ((mask & PNG_FREE_HIST)  & info_ptr->free_me)
 #else
-if ((mask & PNG_FREE_HIST) && (png_ptr->flags & PNG_FLAG_FREE_HIST))
+   if ((mask & PNG_FREE_HIST) && (png_ptr->flags & PNG_FLAG_FREE_HIST))
 #endif
-{
-    png_free(png_ptr, info_ptr->hist);
-    info_ptr->hist = NULL;
-    info_ptr->valid &= ~PNG_INFO_hIST;
+   {
+      png_free(png_ptr, info_ptr->hist);
+      info_ptr->hist = NULL;
+      info_ptr->valid &= ~PNG_INFO_hIST;
 #ifndef PNG_FREE_ME_SUPPORTED
-    png_ptr->flags &= ~PNG_FLAG_FREE_HIST;
+      png_ptr->flags &= ~PNG_FLAG_FREE_HIST;
 #endif
-}
+   }
 #endif
 
-/* free any PLTE entry that was internally allocated */
+   /* Free any PLTE entry that was internally allocated */
 #ifdef PNG_FREE_ME_SUPPORTED
-if ((mask & PNG_FREE_PLTE) & info_ptr->free_me)
+   if ((mask & PNG_FREE_PLTE) & info_ptr->free_me)
 #else
-if ((mask & PNG_FREE_PLTE) && (png_ptr->flags & PNG_FLAG_FREE_PLTE))
+   if ((mask & PNG_FREE_PLTE) && (png_ptr->flags & PNG_FLAG_FREE_PLTE))
 #endif
-{
-    png_zfree(png_ptr, info_ptr->palette);
-    info_ptr->palette = NULL;
-    info_ptr->valid &= ~PNG_INFO_PLTE;
+   {
+      png_zfree(png_ptr, info_ptr->palette);
+      info_ptr->palette = NULL;
+      info_ptr->valid &= ~PNG_INFO_PLTE;
 #ifndef PNG_FREE_ME_SUPPORTED
-    png_ptr->flags &= ~PNG_FLAG_FREE_PLTE;
+      png_ptr->flags &= ~PNG_FLAG_FREE_PLTE;
 #endif
-    info_ptr->num_palette = 0;
-}
+      info_ptr->num_palette = 0;
+   }
 
-#if defined(PNG_INFO_IMAGE_SUPPORTED)
-/* free any image bits attached to the info structure */
+#ifdef PNG_INFO_IMAGE_SUPPORTED
+   /* Free any image bits attached to the info structure */
 #ifdef PNG_FREE_ME_SUPPORTED
-if ((mask & PNG_FREE_ROWS) & info_ptr->free_me)
+   if ((mask & PNG_FREE_ROWS) & info_ptr->free_me)
 #else
-if (mask & PNG_FREE_ROWS)
+   if (mask & PNG_FREE_ROWS)
 #endif
-{
-    if(info_ptr->row_pointers)
-    {
-       int row;
-       for (row = 0; row < (int)info_ptr->height; row++)
-       {
-          png_free(png_ptr, info_ptr->row_pointers[row]);
-          info_ptr->row_pointers[row]=NULL;
-       }
-       png_free(png_ptr, info_ptr->row_pointers);
-       info_ptr->row_pointers=NULL;
-    }
-    info_ptr->valid &= ~PNG_INFO_IDAT;
-}
+   {
+      if (info_ptr->row_pointers)
+      {
+         int row;
+         for (row = 0; row < (int)info_ptr->height; row++)
+         {
+            png_free(png_ptr, info_ptr->row_pointers[row]);
+            info_ptr->row_pointers[row] = NULL;
+         }
+         png_free(png_ptr, info_ptr->row_pointers);
+         info_ptr->row_pointers = NULL;
+      }
+      info_ptr->valid &= ~PNG_INFO_IDAT;
+   }
 #endif
 
 #ifdef PNG_FREE_ME_SUPPORTED
-   if(num == -1)
-     info_ptr->free_me &= ~mask;
+   if (num == -1)
+      info_ptr->free_me &= ~mask;
    else
-     info_ptr->free_me &= ~(mask & ~PNG_FREE_MUL);
+      info_ptr->free_me &= ~(mask & ~PNG_FREE_MUL);
 #endif
 }
 
@@ -592,16 +619,16 @@
 void /* PRIVATE */
 png_info_destroy(png_structp png_ptr, png_infop info_ptr)
 {
-   png_debug(1, "in png_info_destroy\n");
+   png_debug(1, "in png_info_destroy");
 
    png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
 
-#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
+#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
    if (png_ptr->num_chunk_list)
    {
-       png_free(png_ptr, png_ptr->chunk_list);
-       png_ptr->chunk_list=NULL;
-       png_ptr->num_chunk_list=0;
+      png_free(png_ptr, png_ptr->chunk_list);
+      png_ptr->chunk_list = NULL;
+      png_ptr->num_chunk_list = 0;
    }
 #endif
 
@@ -616,12 +643,13 @@
 png_voidp PNGAPI
 png_get_io_ptr(png_structp png_ptr)
 {
-   if(png_ptr == NULL) return (NULL);
+   if (png_ptr == NULL)
+      return (NULL);
    return (png_ptr->io_ptr);
 }
 
 #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-#if !defined(PNG_NO_STDIO)
+#ifdef PNG_STDIO_SUPPORTED
 /* Initialize the default input/output functions for the PNG file.  If you
  * use your own read or write routines, you can call either png_set_read_fn()
  * or png_set_write_fn() instead of png_init_io().  If you have defined
@@ -631,13 +659,16 @@
 void PNGAPI
 png_init_io(png_structp png_ptr, png_FILE_p fp)
 {
-   png_debug(1, "in png_init_io\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_init_io");
+
+   if (png_ptr == NULL)
+      return;
+
    png_ptr->io_ptr = (png_voidp)fp;
 }
 #endif
 
-#if defined(PNG_TIME_RFC1123_SUPPORTED)
+#ifdef PNG_TIME_RFC1123_SUPPORTED
 /* Convert the supplied time into an RFC 1123 string suitable for use in
  * a "Creation Time" or other text-based time string.
  */
@@ -648,37 +679,39 @@
         {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
 
-   if(png_ptr == NULL) return (NULL);
+   if (png_ptr == NULL)
+      return (NULL);
+
    if (png_ptr->time_buffer == NULL)
    {
       png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*
          png_sizeof(char)));
    }
 
-#if defined(_WIN32_WCE)
+#ifdef _WIN32_WCE
    {
       wchar_t time_buf[29];
       wsprintf(time_buf, TEXT("%d %S %d %02d:%02d:%02d +0000"),
-          ptime->day % 32, short_months[(ptime->month - 1) % 12],
+          ptime->day % 32, short_months[(ptime->month - 1U) % 12],
         ptime->year, ptime->hour % 24, ptime->minute % 60,
           ptime->second % 61);
-      WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer, 29,
-          NULL, NULL);
+      WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer,
+          29, NULL, NULL);
    }
 #else
 #ifdef USE_FAR_KEYWORD
    {
       char near_time_buf[29];
-      png_snprintf6(near_time_buf,29,"%d %s %d %02d:%02d:%02d +0000",
-          ptime->day % 32, short_months[(ptime->month - 1) % 12],
+      png_snprintf6(near_time_buf, 29, "%d %s %d %02d:%02d:%02d +0000",
+          ptime->day % 32, short_months[(ptime->month - 1U) % 12],
           ptime->year, ptime->hour % 24, ptime->minute % 60,
           ptime->second % 61);
       png_memcpy(png_ptr->time_buffer, near_time_buf,
           29*png_sizeof(char));
    }
 #else
-   png_snprintf6(png_ptr->time_buffer,29,"%d %s %d %02d:%02d:%02d +0000",
-       ptime->day % 32, short_months[(ptime->month - 1) % 12],
+   png_snprintf6(png_ptr->time_buffer, 29, "%d %s %d %02d:%02d:%02d +0000",
+       ptime->day % 32, short_months[(ptime->month - 1U) % 12],
        ptime->year, ptime->hour % 24, ptime->minute % 60,
        ptime->second % 61);
 #endif
@@ -692,11 +725,24 @@
 png_charp PNGAPI
 png_get_copyright(png_structp png_ptr)
 {
-   png_ptr = png_ptr;  /* silence compiler warning about unused png_ptr */
-   return ((png_charp) "\n libpng version 1.2.23 - November 6, 2007\n\
-   Copyright (c) 1998-2007 Glenn Randers-Pehrson\n\
-   Copyright (c) 1996-1997 Andreas Dilger\n\
-   Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n");
+   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
+#ifdef PNG_STRING_COPYRIGHT
+      return PNG_STRING_COPYRIGHT
+#else
+#ifdef __STDC__
+   return ((png_charp) PNG_STRING_NEWLINE \
+     "libpng version 1.2.55 - December 3, 2015" PNG_STRING_NEWLINE \
+     "Copyright (c) 1998-2015 Glenn Randers-Pehrson" PNG_STRING_NEWLINE \
+     "Copyright (c) 1996-1997 Andreas Dilger" PNG_STRING_NEWLINE \
+     "Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc." \
+     PNG_STRING_NEWLINE);
+#else
+      return ((png_charp) "libpng version 1.2.55 - December 3, 2015\
+      Copyright (c) 1998-2015 Glenn Randers-Pehrson\
+      Copyright (c) 1996-1997 Andreas Dilger\
+      Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.");
+#endif
+#endif
 }
 
 /* The following return the library version as a short string in the
@@ -711,7 +757,7 @@
 png_get_libpng_ver(png_structp png_ptr)
 {
    /* Version of *.c files used when building libpng */
-   png_ptr = png_ptr;  /* silence compiler warning about unused png_ptr */
+   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
    return ((png_charp) PNG_LIBPNG_VER_STRING);
 }
 
@@ -719,7 +765,7 @@
 png_get_header_ver(png_structp png_ptr)
 {
    /* Version of *.h files used when building libpng */
-   png_ptr = png_ptr;  /* silence compiler warning about unused png_ptr */
+   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
    return ((png_charp) PNG_LIBPNG_VER_STRING);
 }
 
@@ -727,12 +773,16 @@
 png_get_header_version(png_structp png_ptr)
 {
    /* Returns longer string containing both version and date */
-   png_ptr = png_ptr;  /* silence compiler warning about unused png_ptr */
+   PNG_UNUSED(png_ptr) /* Silence compiler warning about unused png_ptr */
+#ifdef __STDC__
    return ((png_charp) PNG_HEADER_VERSION_STRING
 #ifndef PNG_READ_SUPPORTED
    "     (NO READ SUPPORT)"
 #endif
-   "\n");
+   PNG_STRING_NEWLINE);
+#else
+   return ((png_charp) PNG_HEADER_VERSION_STRING);
+#endif
 }
 
 #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
@@ -740,15 +790,15 @@
 int PNGAPI
 png_handle_as_unknown(png_structp png_ptr, png_bytep chunk_name)
 {
-   /* check chunk_name and return "keep" value if it's on the list, else 0 */
+   /* Check chunk_name and return "keep" value if it's on the list, else 0 */
    int i;
    png_bytep p;
-   if(png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list<=0)
+   if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list<=0)
       return 0;
-   p=png_ptr->chunk_list+png_ptr->num_chunk_list*5-5;
-   for (i = png_ptr->num_chunk_list; i; i--, p-=5)
+   p = png_ptr->chunk_list + png_ptr->num_chunk_list*5 - 5;
+   for (i = png_ptr->num_chunk_list; i; i--, p -= 5)
       if (!png_memcmp(chunk_name, p, 4))
-        return ((int)*(p+4));
+        return ((int)*(p + 4));
    return 0;
 }
 #endif
@@ -757,7 +807,8 @@
 int PNGAPI
 png_reset_zstream(png_structp png_ptr)
 {
-   if (png_ptr == NULL) return Z_STREAM_ERROR;
+   if (png_ptr == NULL)
+      return Z_STREAM_ERROR;
    return (inflateReset(&png_ptr->zstream));
 }
 #endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
@@ -772,12 +823,12 @@
 
 
 #if defined(PNG_READ_SUPPORTED) && defined(PNG_ASSEMBLER_CODE_SUPPORTED)
-#if !defined(PNG_1_0_X)
-/* this function was added to libpng 1.2.0 */
+#ifndef PNG_1_0_X
+/* This function was added to libpng 1.2.0 */
 int PNGAPI
 png_mmx_support(void)
 {
-   /* obsolete, to be removed from libpng-1.4.0 */
+   /* Obsolete, to be removed from libpng-1.4.0 */
     return -1;
 }
 #endif /* PNG_1_0_X */
@@ -790,9 +841,259 @@
 png_size_t PNGAPI
 png_convert_size(size_t size)
 {
-  if (size > (png_size_t)-1)
-     PNG_ABORT();  /* We haven't got access to png_ptr, so no png_error() */
-  return ((png_size_t)size);
+   if (size > (png_size_t)-1)
+      PNG_ABORT();  /* We haven't got access to png_ptr, so no png_error() */
+   return ((png_size_t)size);
 }
 #endif /* PNG_SIZE_T */
+
+/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) */
+#ifdef PNG_cHRM_SUPPORTED
+#ifdef PNG_CHECK_cHRM_SUPPORTED
+
+/*
+ *    Multiply two 32-bit numbers, V1 and V2, using 32-bit
+ *    arithmetic, to produce a 64 bit result in the HI/LO words.
+ *
+ *                  A B
+ *                x C D
+ *               ------
+ *              AD || BD
+ *        AC || CB || 0
+ *
+ *    where A and B are the high and low 16-bit words of V1,
+ *    C and D are the 16-bit words of V2, AD is the product of
+ *    A and D, and X || Y is (X << 16) + Y.
+*/
+
+void /* PRIVATE */
+png_64bit_product (long v1, long v2, unsigned long *hi_product,
+   unsigned long *lo_product)
+{
+   int a, b, c, d;
+   long lo, hi, x, y;
+
+   a = (v1 >> 16) & 0xffff;
+   b = v1 & 0xffff;
+   c = (v2 >> 16) & 0xffff;
+   d = v2 & 0xffff;
+
+   lo = b * d;                   /* BD */
+   x = a * d + c * b;            /* AD + CB */
+   y = ((lo >> 16) & 0xffff) + x;
+
+   lo = (lo & 0xffff) | ((y & 0xffff) << 16);
+   hi = (y >> 16) & 0xffff;
+
+   hi += a * c;                  /* AC */
+
+   *hi_product = (unsigned long)hi;
+   *lo_product = (unsigned long)lo;
+}
+
+int /* PRIVATE */
+png_check_cHRM_fixed(png_structp png_ptr,
+   png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,
+   png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,
+   png_fixed_point blue_x, png_fixed_point blue_y)
+{
+   int ret = 1;
+   unsigned long xy_hi,xy_lo,yx_hi,yx_lo;
+
+   png_debug(1, "in function png_check_cHRM_fixed");
+
+   if (png_ptr == NULL)
+      return 0;
+
+   if (white_x < 0 || white_y <= 0 ||
+         red_x < 0 ||   red_y <  0 ||
+       green_x < 0 || green_y <  0 ||
+        blue_x < 0 ||  blue_y <  0)
+   {
+      png_warning(png_ptr,
+        "Ignoring attempt to set negative chromaticity value");
+      ret = 0;
+   }
+   if (white_x > (png_fixed_point) PNG_UINT_31_MAX ||
+       white_y > (png_fixed_point) PNG_UINT_31_MAX ||
+         red_x > (png_fixed_point) PNG_UINT_31_MAX ||
+         red_y > (png_fixed_point) PNG_UINT_31_MAX ||
+       green_x > (png_fixed_point) PNG_UINT_31_MAX ||
+       green_y > (png_fixed_point) PNG_UINT_31_MAX ||
+        blue_x > (png_fixed_point) PNG_UINT_31_MAX ||
+        blue_y > (png_fixed_point) PNG_UINT_31_MAX )
+   {
+      png_warning(png_ptr,
+        "Ignoring attempt to set chromaticity value exceeding 21474.83");
+      ret = 0;
+   }
+   if (white_x > 100000L - white_y)
+   {
+      png_warning(png_ptr, "Invalid cHRM white point");
+      ret = 0;
+   }
+   if (red_x > 100000L - red_y)
+   {
+      png_warning(png_ptr, "Invalid cHRM red point");
+      ret = 0;
+   }
+   if (green_x > 100000L - green_y)
+   {
+      png_warning(png_ptr, "Invalid cHRM green point");
+      ret = 0;
+   }
+   if (blue_x > 100000L - blue_y)
+   {
+      png_warning(png_ptr, "Invalid cHRM blue point");
+      ret = 0;
+   }
+
+   png_64bit_product(green_x - red_x, blue_y - red_y, &xy_hi, &xy_lo);
+   png_64bit_product(green_y - red_y, blue_x - red_x, &yx_hi, &yx_lo);
+
+   if (xy_hi == yx_hi && xy_lo == yx_lo)
+   {
+      png_warning(png_ptr,
+         "Ignoring attempt to set cHRM RGB triangle with zero area");
+      ret = 0;
+   }
+
+   return ret;
+}
+#endif /* PNG_CHECK_cHRM_SUPPORTED */
+#endif /* PNG_cHRM_SUPPORTED */
+
+void /* PRIVATE */
+png_check_IHDR(png_structp png_ptr,
+   png_uint_32 width, png_uint_32 height, int bit_depth,
+   int color_type, int interlace_type, int compression_type,
+   int filter_type)
+{
+   int error = 0;
+
+   /* Check for width and height valid values */
+   if (width == 0)
+   {
+      png_warning(png_ptr, "Image width is zero in IHDR");
+      error = 1;
+   }
+
+   if (height == 0)
+   {
+      png_warning(png_ptr, "Image height is zero in IHDR");
+      error = 1;
+   }
+
+#ifdef PNG_SET_USER_LIMITS_SUPPORTED
+   if (width > png_ptr->user_width_max || width > PNG_USER_WIDTH_MAX)
+#else
+   if (width > PNG_USER_WIDTH_MAX)
+#endif
+   {
+      png_warning(png_ptr, "Image width exceeds user limit in IHDR");
+      error = 1;
+   }
+
+#ifdef PNG_SET_USER_LIMITS_SUPPORTED
+   if (height > png_ptr->user_height_max || height > PNG_USER_HEIGHT_MAX)
+#else
+   if (height > PNG_USER_HEIGHT_MAX)
+#endif
+   {
+      png_warning(png_ptr, "Image height exceeds user limit in IHDR");
+      error = 1;
+   }
+
+   if (width > PNG_UINT_31_MAX)
+   {
+      png_warning(png_ptr, "Invalid image width in IHDR");
+      error = 1;
+   }
+
+   if ( height > PNG_UINT_31_MAX)
+   {
+      png_warning(png_ptr, "Invalid image height in IHDR");
+      error = 1;
+   }
+
+   /* Check other values */
+   if (bit_depth != 1 && bit_depth != 2 && bit_depth != 4 &&
+       bit_depth != 8 && bit_depth != 16)
+   {
+      png_warning(png_ptr, "Invalid bit depth in IHDR");
+      error = 1;
+   }
+
+   if (color_type < 0 || color_type == 1 ||
+       color_type == 5 || color_type > 6)
+   {
+      png_warning(png_ptr, "Invalid color type in IHDR");
+      error = 1;
+   }
+
+   if (((color_type == PNG_COLOR_TYPE_PALETTE) && bit_depth > 8) ||
+       ((color_type == PNG_COLOR_TYPE_RGB ||
+         color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
+         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && bit_depth < 8))
+   {
+      png_warning(png_ptr, "Invalid color type/bit depth combination in IHDR");
+      error = 1;
+   }
+
+   if (interlace_type >= PNG_INTERLACE_LAST)
+   {
+      png_warning(png_ptr, "Unknown interlace method in IHDR");
+      error = 1;
+   }
+
+   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
+   {
+      png_warning(png_ptr, "Unknown compression method in IHDR");
+      error = 1;
+   }
+
+#ifdef PNG_MNG_FEATURES_SUPPORTED
+   /* Accept filter_method 64 (intrapixel differencing) only if
+    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
+    * 2. Libpng did not read a PNG signature (this filter_method is only
+    *    used in PNG datastreams that are embedded in MNG datastreams) and
+    * 3. The application called png_permit_mng_features with a mask that
+    *    included PNG_FLAG_MNG_FILTER_64 and
+    * 4. The filter_method is 64 and
+    * 5. The color_type is RGB or RGBA
+    */
+   if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) &&
+       png_ptr->mng_features_permitted)
+      png_warning(png_ptr, "MNG features are not allowed in a PNG datastream");
+
+   if (filter_type != PNG_FILTER_TYPE_BASE)
+   {
+      if (!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
+         (filter_type == PNG_INTRAPIXEL_DIFFERENCING) &&
+         ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) == 0) &&
+         (color_type == PNG_COLOR_TYPE_RGB ||
+         color_type == PNG_COLOR_TYPE_RGB_ALPHA)))
+      {
+         png_warning(png_ptr, "Unknown filter method in IHDR");
+         error = 1;
+      }
+
+      if (png_ptr->mode & PNG_HAVE_PNG_SIGNATURE)
+      {
+         png_warning(png_ptr, "Invalid filter method in IHDR");
+         error = 1;
+      }
+   }
+
+#else
+   if (filter_type != PNG_FILTER_TYPE_BASE)
+   {
+      png_warning(png_ptr, "Unknown filter method in IHDR");
+      error = 1;
+   }
+#endif
+
+   if (error == 1)
+      png_error(png_ptr, "Invalid IHDR data");
+}
 #endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
diff -Naur libAfterImage-1.20/libpng/png.h root/graf2d/asimage/src/libAfterImage/libpng/png.h
--- libAfterImage-1.20/libpng/png.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/png.h	2018-12-08 08:18:38.000000000 +0100
@@ -1,198 +1,19 @@
 
 /* png.h - header file for PNG reference library
  *
- * libpng version 1.2.23 - November 6, 2007
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * libpng version 1.2.55, December 3, 2015
+ *
+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
+ * This code is released under the libpng license (See LICENSE, below)
+ *
  * Authors and maintainers:
  *  libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
- *  libpng versions 0.89c, June 1996, through 0.96, May 1997: Andreas Dilger
- *  libpng versions 0.97, January 1998, through 1.2.23 - November 6, 2007: Glenn
+ *  libpng versions 0.89, June 1996, through 0.96, May 1997: Andreas Dilger
+ *  libpng versions 0.97, January 1998, through 1.2.55, December 3, 2015: Glenn
  *  See also "Contributing Authors", below.
- *
- * Note about libpng version numbers:
- *
- *    Due to various miscommunications, unforeseen code incompatibilities
- *    and occasional factors outside the authors' control, version numbering
- *    on the library has not always been consistent and straightforward.
- *    The following table summarizes matters since version 0.89c, which was
- *    the first widely used release:
- *
- *    source                 png.h  png.h  shared-lib
- *    version                string   int  version
- *    -------                ------ -----  ----------
- *    0.89c "1.0 beta 3"     0.89      89  1.0.89
- *    0.90  "1.0 beta 4"     0.90      90  0.90  [should have been 2.0.90]
- *    0.95  "1.0 beta 5"     0.95      95  0.95  [should have been 2.0.95]
- *    0.96  "1.0 beta 6"     0.96      96  0.96  [should have been 2.0.96]
- *    0.97b "1.00.97 beta 7" 1.00.97   97  1.0.1 [should have been 2.0.97]
- *    0.97c                  0.97      97  2.0.97
- *    0.98                   0.98      98  2.0.98
- *    0.99                   0.99      98  2.0.99
- *    0.99a-m                0.99      99  2.0.99
- *    1.00                   1.00     100  2.1.0 [100 should be 10000]
- *    1.0.0      (from here on, the   100  2.1.0 [100 should be 10000]
- *    1.0.1       png.h string is   10001  2.1.0
- *    1.0.1a-e    identical to the  10002  from here on, the shared library
- *    1.0.2       source version)   10002  is 2.V where V is the source code
- *    1.0.2a-b                      10003  version, except as noted.
- *    1.0.3                         10003
- *    1.0.3a-d                      10004
- *    1.0.4                         10004
- *    1.0.4a-f                      10005
- *    1.0.5 (+ 2 patches)           10005
- *    1.0.5a-d                      10006
- *    1.0.5e-r                      10100 (not source compatible)
- *    1.0.5s-v                      10006 (not binary compatible)
- *    1.0.6 (+ 3 patches)           10006 (still binary incompatible)
- *    1.0.6d-f                      10007 (still binary incompatible)
- *    1.0.6g                        10007
- *    1.0.6h                        10007  10.6h (testing xy.z so-numbering)
- *    1.0.6i                        10007  10.6i
- *    1.0.6j                        10007  2.1.0.6j (incompatible with 1.0.0)
- *    1.0.7beta11-14        DLLNUM  10007  2.1.0.7beta11-14 (binary compatible)
- *    1.0.7beta15-18           1    10007  2.1.0.7beta15-18 (binary compatible)
- *    1.0.7rc1-2               1    10007  2.1.0.7rc1-2 (binary compatible)
- *    1.0.7                    1    10007  (still compatible)
- *    1.0.8beta1-4             1    10008  2.1.0.8beta1-4
- *    1.0.8rc1                 1    10008  2.1.0.8rc1
- *    1.0.8                    1    10008  2.1.0.8
- *    1.0.9beta1-6             1    10009  2.1.0.9beta1-6
- *    1.0.9rc1                 1    10009  2.1.0.9rc1
- *    1.0.9beta7-10            1    10009  2.1.0.9beta7-10
- *    1.0.9rc2                 1    10009  2.1.0.9rc2
- *    1.0.9                    1    10009  2.1.0.9
- *    1.0.10beta1              1    10010  2.1.0.10beta1
- *    1.0.10rc1                1    10010  2.1.0.10rc1
- *    1.0.10                   1    10010  2.1.0.10
- *    1.0.11beta1-3            1    10011  2.1.0.11beta1-3
- *    1.0.11rc1                1    10011  2.1.0.11rc1
- *    1.0.11                   1    10011  2.1.0.11
- *    1.0.12beta1-2            2    10012  2.1.0.12beta1-2
- *    1.0.12rc1                2    10012  2.1.0.12rc1
- *    1.0.12                   2    10012  2.1.0.12
- *    1.1.0a-f                 -    10100  2.1.1.0a-f (branch abandoned)
- *    1.2.0beta1-2             2    10200  2.1.2.0beta1-2
- *    1.2.0beta3-5             3    10200  3.1.2.0beta3-5
- *    1.2.0rc1                 3    10200  3.1.2.0rc1
- *    1.2.0                    3    10200  3.1.2.0
- *    1.2.1beta1-4             3    10201  3.1.2.1beta1-4
- *    1.2.1rc1-2               3    10201  3.1.2.1rc1-2
- *    1.2.1                    3    10201  3.1.2.1
- *    1.2.2beta1-6            12    10202  12.so.0.1.2.2beta1-6
- *    1.0.13beta1             10    10013  10.so.0.1.0.13beta1
- *    1.0.13rc1               10    10013  10.so.0.1.0.13rc1
- *    1.2.2rc1                12    10202  12.so.0.1.2.2rc1
- *    1.0.13                  10    10013  10.so.0.1.0.13
- *    1.2.2                   12    10202  12.so.0.1.2.2
- *    1.2.3rc1-6              12    10203  12.so.0.1.2.3rc1-6
- *    1.2.3                   12    10203  12.so.0.1.2.3
- *    1.2.4beta1-3            13    10204  12.so.0.1.2.4beta1-3
- *    1.0.14rc1               13    10014  10.so.0.1.0.14rc1
- *    1.2.4rc1                13    10204  12.so.0.1.2.4rc1
- *    1.0.14                  10    10014  10.so.0.1.0.14
- *    1.2.4                   13    10204  12.so.0.1.2.4
- *    1.2.5beta1-2            13    10205  12.so.0.1.2.5beta1-2
- *    1.0.15rc1-3             10    10015  10.so.0.1.0.15rc1-3
- *    1.2.5rc1-3              13    10205  12.so.0.1.2.5rc1-3
- *    1.0.15                  10    10015  10.so.0.1.0.15
- *    1.2.5                   13    10205  12.so.0.1.2.5
- *    1.2.6beta1-4            13    10206  12.so.0.1.2.6beta1-4
- *    1.0.16                  10    10016  10.so.0.1.0.16
- *    1.2.6                   13    10206  12.so.0.1.2.6
- *    1.2.7beta1-2            13    10207  12.so.0.1.2.7beta1-2
- *    1.0.17rc1               10    10017  10.so.0.1.0.17rc1
- *    1.2.7rc1                13    10207  12.so.0.1.2.7rc1
- *    1.0.17                  10    10017  10.so.0.1.0.17
- *    1.2.7                   13    10207  12.so.0.1.2.7
- *    1.2.8beta1-5            13    10208  12.so.0.1.2.8beta1-5
- *    1.0.18rc1-5             10    10018  10.so.0.1.0.18rc1-5
- *    1.2.8rc1-5              13    10208  12.so.0.1.2.8rc1-5
- *    1.0.18                  10    10018  10.so.0.1.0.18
- *    1.2.8                   13    10208  12.so.0.1.2.8
- *    1.2.9beta1-3            13    10209  12.so.0.1.2.9beta1-3
- *    1.2.9beta4-11           13    10209  12.so.0.9[.0]
- *    1.2.9rc1                13    10209  12.so.0.9[.0]
- *    1.2.9                   13    10209  12.so.0.9[.0]
- *    1.2.10beta1-8           13    10210  12.so.0.10[.0]
- *    1.2.10rc1-3             13    10210  12.so.0.10[.0]
- *    1.2.10                  13    10210  12.so.0.10[.0]
- *    1.2.11beta1-4           13    10211  12.so.0.11[.0]
- *    1.0.19rc1-5             10    10019  10.so.0.19[.0]
- *    1.2.11rc1-5             13    10211  12.so.0.11[.0]
- *    1.0.19                  10    10019  10.so.0.19[.0]
- *    1.2.11                  13    10211  12.so.0.11[.0]
- *    1.0.20                  10    10020  10.so.0.20[.0]
- *    1.2.12                  13    10212  12.so.0.12[.0]
- *    1.2.13beta1             13    10213  12.so.0.13[.0]
- *    1.0.21                  10    10021  10.so.0.21[.0]
- *    1.2.13                  13    10213  12.so.0.13[.0]
- *    1.2.14beta1-2           13    10214  12.so.0.14[.0]
- *    1.0.22rc1               10    10022  10.so.0.22[.0]
- *    1.2.14rc1               13    10214  12.so.0.14[.0]
- *    1.0.22                  10    10022  10.so.0.22[.0]
- *    1.2.14                  13    10214  12.so.0.14[.0]
- *    1.2.15beta1-6           13    10215  12.so.0.15[.0]
- *    1.0.23rc1-5             10    10023  10.so.0.23[.0]
- *    1.2.15rc1-5             13    10215  12.so.0.15[.0]
- *    1.0.23                  10    10023  10.so.0.23[.0]
- *    1.2.15                  13    10215  12.so.0.15[.0]
- *    1.2.16beta1-2           13    10216  12.so.0.16[.0]
- *    1.2.16rc1               13    10216  12.so.0.16[.0]
- *    1.0.24                  10    10024  10.so.0.24[.0]
- *    1.2.16                  13    10216  12.so.0.16[.0]
- *    1.2.17beta1-2           13    10217  12.so.0.17[.0]
- *    1.0.25rc1               10    10025  10.so.0.25[.0]
- *    1.2.17rc1-3             13    10217  12.so.0.17[.0]
- *    1.0.25                  10    10025  10.so.0.25[.0]
- *    1.2.17                  13    10217  12.so.0.17[.0]
- *    1.0.26                  10    10026  10.so.0.26[.0]
- *    1.2.18                  13    10218  12.so.0.18[.0]
- *    1.2.19beta1-31          13    10219  12.so.0.19[.0]
- *    1.0.27rc1-6             10    10027  10.so.0.27[.0]
- *    1.2.19rc1-6             13    10219  12.so.0.19[.0]
- *    1.0.27                  10    10027  10.so.0.27[.0]
- *    1.2.19                  13    10219  12.so.0.19[.0]
- *    1.2.20beta01-04         13    10220  12.so.0.20[.0]
- *    1.0.28rc1-6             10    10028  10.so.0.28[.0]
- *    1.2.20rc1-6             13    10220  12.so.0.20[.0]
- *    1.0.28                  10    10028  10.so.0.28[.0]
- *    1.2.20                  13    10220  12.so.0.20[.0]
- *    1.2.21beta1-2           13    10221  12.so.0.21[.0]
- *    1.2.21rc1-3             13    10221  12.so.0.21[.0]
- *    1.0.29                  10    10029  10.so.0.29[.0]
- *    1.2.21                  13    10221  12.so.0.21[.0]
- *    1.2.22beta1-4           13    10222  12.so.0.22[.0]
- *    1.0.30rc1               10    10030  10.so.0.30[.0]
- *    1.2.22rc1               13    10222  12.so.0.22[.0]
- *    1.0.30                  10    10030  10.so.0.30[.0]
- *    1.2.22                  13    10222  12.so.0.22[.0]
- *    1.2.23beta01-05         13    10223  12.so.0.23[.0]
- *    1.2.23rc01              13    10223  12.so.0.23[.0]
- *    1.2.23                  13    10223  12.so.0.23[.0]
- *
- *    Henceforth the source version will match the shared-library major
- *    and minor numbers; the shared-library major version number will be
- *    used for changes in backward compatibility, as it is intended.  The
- *    PNG_LIBPNG_VER macro, which is not used within libpng but is available
- *    for applications, is an unsigned integer of the form xyyzz corresponding
- *    to the source version x.y.z (leading zeros in y and z).  Beta versions
- *    were given the previous public release number plus a letter, until
- *    version 1.0.6j; from then on they were given the upcoming public
- *    release number plus "betaNN" or "rcN".
- *
- *    Binary incompatibility exists only when applications make direct access
- *    to the info_ptr or png_ptr members through png.h, and the compiled
- *    application is loaded with a different version of the library.
- *
- *    DLLNUM will change each time there are forward or backward changes
- *    in binary compatibility (e.g., when a new feature is added).
- *
- * See libpng.txt or libpng.3 for more information.  The PNG specification
- * is available as a W3C Recommendation and as an ISO Specification,
- * <http://www.w3.org/TR/2003/REC-PNG-20031110/
  */
 
 /*
@@ -201,20 +22,17 @@
  * If you modify libpng you may insert additional notices immediately following
  * this sentence.
  *
- * libpng versions 1.2.6, August 15, 2004, through 1.2.23, November 6, 2007, are
- * Copyright (c) 2004, 2006-2007 Glenn Randers-Pehrson, and are
- * distributed according to the same disclaimer and license as libpng-1.2.5
- * with the following individual added to the list of Contributing Authors:
+ * This code is released under the libpng license.
  *
- *    Cosmin Truta
- *
- * libpng versions 1.0.7, July 1, 2000, through 1.2.5, October 3, 2002, are
- * Copyright (c) 2000-2002 Glenn Randers-Pehrson, and are
- * distributed according to the same disclaimer and license as libpng-1.0.6
- * with the following individuals added to the list of Contributing Authors:
+ * libpng versions 1.0.7, July 1, 2000, through 1.2.55, December 3, 2015, are
+ * Copyright (c) 2000-2002, 2004, 2006-2015 Glenn Randers-Pehrson, are
+ * derived from libpng-1.0.6, and are distributed according to the same
+ * disclaimer and license as libpng-1.0.6 with the following individuals
+ * added to the list of Contributing Authors:
  *
  *    Simon-Pierre Cadieux
  *    Eric S. Raymond
+ *    Cosmin Truta
  *    Gilles Vollant
  *
  * and with the following additions to the disclaimer:
@@ -227,18 +45,20 @@
  *    the user.
  *
  * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
- * Copyright (c) 1998, 1999, 2000 Glenn Randers-Pehrson, and are
- * distributed according to the same disclaimer and license as libpng-0.96,
- * with the following individuals added to the list of Contributing Authors:
+ * Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from
+ * libpng-0.96, and are distributed according to the same disclaimer and
+ * license as libpng-0.96, with the following individuals added to the list
+ * of Contributing Authors:
  *
  *    Tom Lane
  *    Glenn Randers-Pehrson
  *    Willem van Schaik
  *
  * libpng versions 0.89, June 1996, through 0.96, May 1997, are
- * Copyright (c) 1996, 1997 Andreas Dilger
- * Distributed according to the same disclaimer and license as libpng-0.88,
- * with the following individuals added to the list of Contributing Authors:
+ * Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88,
+ * and are distributed according to the same disclaimer and license as
+ * libpng-0.88, with the following individuals added to the list of
+ * Contributing Authors:
  *
  *    John Bowler
  *    Kevin Bracey
@@ -248,7 +68,7 @@
  *    Tom Tanner
  *
  * libpng versions 0.5, May 1995, through 0.88, January 1996, are
- * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * For the purposes of this copyright and license, "Contributing Authors"
  * is defined as the following set of individuals:
@@ -271,34 +91,37 @@
  * source code, or portions hereof, for any purpose, without fee, subject
  * to the following restrictions:
  *
- * 1. The origin of this source code must not be misrepresented.
+ *   1. The origin of this source code must not be misrepresented.
  *
- * 2. Altered versions must be plainly marked as such and
- * must not be misrepresented as being the original source.
+ *   2. Altered versions must be plainly marked as such and must not
+ *      be misrepresented as being the original source.
  *
- * 3. This Copyright notice may not be removed or altered from
- *    any source or altered source distribution.
+ *   3. This Copyright notice may not be removed or altered from any
+ *      source or altered source distribution.
  *
  * The Contributing Authors and Group 42, Inc. specifically permit, without
  * fee, and encourage the use of this source code as a component to
  * supporting the PNG file format in commercial products.  If you use this
  * source code in a product, acknowledgment is not required but would be
  * appreciated.
+ *
+ * END OF COPYRIGHT NOTICE, DISCLAIMER, and LICENSE.
  */
 
 /*
  * A "png_get_copyright" function is available, for convenient use in "about"
  * boxes and the like:
  *
- * printf("%s",png_get_copyright(NULL));
+ *    printf("%s", png_get_copyright(NULL));
  *
  * Also, the PNG logo (in PNG format, of course) is supplied in the
  * files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
  */
 
 /*
- * Libpng is OSI Certified Open Source Software.  OSI Certified is a
- * certification mark of the Open Source Initiative.
+ * Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is
+ * a certification mark of the Open Source Initiative. OSI has not addressed
+ * the additional disclaimers inserted at version 1.0.7.
  */
 
 /*
@@ -309,17 +132,89 @@
  * Thanks to Frank J. T. Wojcik for helping with the documentation.
  */
 
+/* Note about libpng version numbers:
+ *
+ *    Due to various miscommunications, unforeseen code incompatibilities
+ *    and occasional factors outside the authors' control, version numbering
+ *    on the library has not always been consistent and straightforward.
+ *    The following table summarizes matters since version 0.89c, which was
+ *    the first widely used release:
+ *
+ *    source                 png.h  png.h  shared-lib
+ *    version                string   int  version
+ *    -------                ------ -----  ----------
+ *    0.89c "1.0 beta 3"     0.89      89  1.0.89
+ *    0.90  "1.0 beta 4"     0.90      90  0.90  [should have been 2.0.90]
+ *    0.95  "1.0 beta 5"     0.95      95  0.95  [should have been 2.0.95]
+ *    0.96  "1.0 beta 6"     0.96      96  0.96  [should have been 2.0.96]
+ *    0.97b "1.00.97 beta 7" 1.00.97   97  1.0.1 [should have been 2.0.97]
+ *    0.97c                  0.97      97  2.0.97
+ *    0.98                   0.98      98  2.0.98
+ *    0.99                   0.99      98  2.0.99
+ *    0.99a-m                0.99      99  2.0.99
+ *    1.00                   1.00     100  2.1.0 [100 should be 10000]
+ *    1.0.0      (from here on, the   100  2.1.0 [100 should be 10000]
+ *    1.0.1       png.h string is   10001  2.1.0
+ *    1.0.1a-e    identical to the  10002  from here on, the shared library
+ *    1.0.2       source version)   10002  is 2.V where V is the source code
+ *    1.0.2a-b                      10003  version, except as noted.
+ *    1.0.3                         10003
+ *    1.0.3a-d                      10004
+ *    1.0.4                         10004
+ *    1.0.4a-f                      10005
+ *    1.0.5 (+ 2 patches)           10005
+ *    1.0.5a-d                      10006
+ *    1.0.5e-r                      10100 (not source compatible)
+ *    1.0.5s-v                      10006 (not binary compatible)
+ *    1.0.6 (+ 3 patches)           10006 (still binary incompatible)
+ *    1.0.6d-f                      10007 (still binary incompatible)
+ *    1.0.6g                        10007
+ *    1.0.6h                        10007  10.6h (testing xy.z so-numbering)
+ *    1.0.6i                        10007  10.6i
+ *    1.0.6j                        10007  2.1.0.6j (incompatible with 1.0.0)
+ *    1.0.7beta11-14        DLLNUM  10007  2.1.0.7beta11-14 (binary compatible)
+ *    1.0.7beta15-18           1    10007  2.1.0.7beta15-18 (binary compatible)
+ *    1.0.7rc1-2               1    10007  2.1.0.7rc1-2 (binary compatible)
+ *    1.0.7                    1    10007  (still compatible)
+ *    ...
+ *    1.0.19                  10    10019  10.so.0.19[.0]
+ *    ...
+ *    1.0.65                  10    10065  10.so.0.65[.0]
+ *    1.2.55                  13    10255  12.so.0.55[.0]
+ *
+ *    Henceforth the source version will match the shared-library major
+ *    and minor numbers; the shared-library major version number will be
+ *    used for changes in backward compatibility, as it is intended.  The
+ *    PNG_LIBPNG_VER macro, which is not used within libpng but is available
+ *    for applications, is an unsigned integer of the form xyyzz corresponding
+ *    to the source version x.y.z (leading zeros in y and z).  Beta versions
+ *    were given the previous public release number plus a letter, until
+ *    version 1.0.6j; from then on they were given the upcoming public
+ *    release number plus "betaNN" or "rcNN".
+ *
+ *    Binary incompatibility exists only when applications make direct access
+ *    to the info_ptr or png_ptr members through png.h, and the compiled
+ *    application is loaded with a different version of the library.
+ *
+ *    DLLNUM will change each time there are forward or backward changes
+ *    in binary compatibility (e.g., when a new feature is added).
+ *
+ * See libpng.txt or libpng.3 for more information.  The PNG specification
+ * is available as a W3C Recommendation and as an ISO Specification,
+ * <http://www.w3.org/TR/2003/REC-PNG-20031110/
+ */
+
 /*
  * Y2K compliance in libpng:
  * =========================
  *
- *    November 6, 2007
+ *    December 3, 2015
  *
  *    Since the PNG Development group is an ad-hoc body, we can't make
  *    an official declaration.
  *
  *    This is your unofficial assurance that libpng from version 0.71 and
- *    upward through 1.2.23 are Y2K compliant.  It is my belief that earlier
+ *    upward through 1.2.55 are Y2K compliant.  It is my belief that earlier
  *    versions were also Y2K compliant.
  *
  *    Libpng only has three year fields.  One is a 2-byte unsigned integer
@@ -375,9 +270,9 @@
  */
 
 /* Version information for png.h - this should match the version in png.c */
-#define PNG_LIBPNG_VER_STRING "1.2.23"
+#define PNG_LIBPNG_VER_STRING "1.2.55"
 #define PNG_HEADER_VERSION_STRING \
-   " libpng version 1.2.23 - November 6, 2007\n"
+   " libpng version 1.2.55 - December 3, 2015\n"
 
 #define PNG_LIBPNG_VER_SONUM   0
 #define PNG_LIBPNG_VER_DLLNUM  13
@@ -385,9 +280,10 @@
 /* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
 #define PNG_LIBPNG_VER_MAJOR   1
 #define PNG_LIBPNG_VER_MINOR   2
-#define PNG_LIBPNG_VER_RELEASE 23
+#define PNG_LIBPNG_VER_RELEASE 55
 /* This should match the numeric part of the final component of
- * PNG_LIBPNG_VER_STRING, omitting any leading zero: */
+ * PNG_LIBPNG_VER_STRING, omitting any leading zero:
+ */
 
 #define PNG_LIBPNG_VER_BUILD  0
 
@@ -397,7 +293,7 @@
 #define PNG_LIBPNG_BUILD_RC       3
 #define PNG_LIBPNG_BUILD_STABLE   4
 #define PNG_LIBPNG_BUILD_RELEASE_STATUS_MASK 7
-  
+
 /* Release-Specific Flags */
 #define PNG_LIBPNG_BUILD_PATCH    8 /* Can be OR'ed with
                                        PNG_LIBPNG_BUILD_STABLE only */
@@ -412,11 +308,12 @@
  * We must not include leading zeros.
  * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
  * version 1.0.0 was mis-numbered 100 instead of 10000).  From
- * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release */
-#define PNG_LIBPNG_VER 10223 /* 1.2.23 */
+ * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
+ */
+#define PNG_LIBPNG_VER 10255 /* 1.2.55 */
 
 #ifndef PNG_VERSION_INFO_ONLY
-/* include the compression library's header */
+/* Include the compression library's header */
 # ifdef _WIN32
 #  include "..\zlib\zlib.h"
 # else
@@ -424,7 +321,7 @@
 # endif
 #endif
 
-/* include all user configurable info, including optional assembler routines */
+/* Include all user configurable info, including optional assembler routines */
 #include "pngconf.h"
 
 /*
@@ -432,19 +329,19 @@
 /* Ref MSDN: Private as priority over Special
  * VS_FF_PRIVATEBUILD File *was not* built using standard release
  * procedures. If this value is given, the StringFileInfo block must
- * contain a PrivateBuild string. 
+ * contain a PrivateBuild string.
  *
  * VS_FF_SPECIALBUILD File *was* built by the original company using
  * standard release procedures but is a variation of the standard
  * file of the same version number. If this value is given, the
- * StringFileInfo block must contain a SpecialBuild string. 
+ * StringFileInfo block must contain a SpecialBuild string.
  */
 
-#if defined(PNG_USER_PRIVATEBUILD)
+#ifdef PNG_USER_PRIVATEBUILD
 #  define PNG_LIBPNG_BUILD_TYPE \
           (PNG_LIBPNG_BUILD_BASE_TYPE | PNG_LIBPNG_BUILD_PRIVATE)
 #else
-#  if defined(PNG_LIBPNG_SPECIALBUILD)
+#  ifdef PNG_LIBPNG_SPECIALBUILD
 #    define PNG_LIBPNG_BUILD_TYPE \
             (PNG_LIBPNG_BUILD_BASE_TYPE | PNG_LIBPNG_BUILD_SPECIAL)
 #  else
@@ -499,14 +396,14 @@
 #define png_write_status_ptr_NULL NULL
 #endif
 
-/* variables declared in png.c - only it needs to define PNG_NO_EXTERN */
+/* Variables declared in png.c - only it needs to define PNG_NO_EXTERN */
 #if !defined(PNG_NO_EXTERN) || defined(PNG_ALWAYS_EXTERN)
 /* Version information for C files, stored in png.c.  This had better match
  * the version above.
  */
 #ifdef PNG_USE_GLOBAL_ARRAYS
 PNG_EXPORT_VAR (PNG_CONST char) png_libpng_ver[18];
-  /* need room for 99.99.99beta99z */
+  /* Need room for 99.99.99beta99z */
 #else
 #define png_libpng_ver png_get_header_ver(NULL)
 #endif
@@ -625,7 +522,8 @@
 #endif
 
 /* Supported compression types for text in PNG files (tEXt, and zTXt).
- * The values of the PNG_TEXT_COMPRESSION_ defines should NOT be changed. */
+ * The values of the PNG_TEXT_COMPRESSION_ defines should NOT be changed.
+ */
 #define PNG_TEXT_COMPRESSION_NONE_WR -3
 #define PNG_TEXT_COMPRESSION_zTXt_WR -2
 #define PNG_TEXT_COMPRESSION_NONE    -1
@@ -652,7 +550,8 @@
 typedef png_time FAR * png_timep;
 typedef png_time FAR * FAR * png_timepp;
 
-#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
+#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED) || \
+ defined(PNG_HANDLE_AS_UNKNOWN_SUPPORTED)
 /* png_unknown_chunk is a structure to hold queued chunks for which there is
  * no specific support.  The idea is that we can use this to queue
  * up private chunks for output even though the library doesn't actually
@@ -714,26 +613,26 @@
  */
 typedef struct png_info_struct
 {
-   /* the following are necessary for every PNG file */
-   png_uint_32 width;       /* width of image in pixels (from IHDR) */
-   png_uint_32 height;      /* height of image in pixels (from IHDR) */
-   png_uint_32 valid;       /* valid chunk data (see PNG_INFO_ below) */
-   png_uint_32 rowbytes;    /* bytes needed to hold an untransformed row */
-   png_colorp palette;      /* array of color values (valid & PNG_INFO_PLTE) */
-   png_uint_16 num_palette; /* number of color entries in "palette" (PLTE) */
-   png_uint_16 num_trans;   /* number of transparent palette color (tRNS) */
-   png_byte bit_depth;      /* 1, 2, 4, 8, or 16 bits/channel (from IHDR) */
-   png_byte color_type;     /* see PNG_COLOR_TYPE_ below (from IHDR) */
+   /* The following are necessary for every PNG file */
+   png_uint_32 width PNG_DEPSTRUCT;       /* width of image in pixels (from IHDR) */
+   png_uint_32 height PNG_DEPSTRUCT;      /* height of image in pixels (from IHDR) */
+   png_uint_32 valid PNG_DEPSTRUCT;       /* valid chunk data (see PNG_INFO_ below) */
+   png_uint_32 rowbytes PNG_DEPSTRUCT;    /* bytes needed to hold an untransformed row */
+   png_colorp palette PNG_DEPSTRUCT;      /* array of color values (valid & PNG_INFO_PLTE) */
+   png_uint_16 num_palette PNG_DEPSTRUCT; /* number of color entries in "palette" (PLTE) */
+   png_uint_16 num_trans PNG_DEPSTRUCT;   /* number of transparent palette color (tRNS) */
+   png_byte bit_depth PNG_DEPSTRUCT;      /* 1, 2, 4, 8, or 16 bits/channel (from IHDR) */
+   png_byte color_type PNG_DEPSTRUCT;     /* see PNG_COLOR_TYPE_ below (from IHDR) */
    /* The following three should have been named *_method not *_type */
-   png_byte compression_type; /* must be PNG_COMPRESSION_TYPE_BASE (IHDR) */
-   png_byte filter_type;    /* must be PNG_FILTER_TYPE_BASE (from IHDR) */
-   png_byte interlace_type; /* One of PNG_INTERLACE_NONE, PNG_INTERLACE_ADAM7 */
+   png_byte compression_type PNG_DEPSTRUCT; /* must be PNG_COMPRESSION_TYPE_BASE (IHDR) */
+   png_byte filter_type PNG_DEPSTRUCT;    /* must be PNG_FILTER_TYPE_BASE (from IHDR) */
+   png_byte interlace_type PNG_DEPSTRUCT; /* One of PNG_INTERLACE_NONE, PNG_INTERLACE_ADAM7 */
 
    /* The following is informational only on read, and not used on writes. */
-   png_byte channels;       /* number of data channels per pixel (1, 2, 3, 4) */
-   png_byte pixel_depth;    /* number of bits per pixel */
-   png_byte spare_byte;     /* to align the data, and for future use */
-   png_byte signature[8];   /* magic bytes read by libpng from start of file */
+   png_byte channels PNG_DEPSTRUCT;       /* number of data channels per pixel (1, 2, 3, 4) */
+   png_byte pixel_depth PNG_DEPSTRUCT;    /* number of bits per pixel */
+   png_byte spare_byte PNG_DEPSTRUCT;     /* to align the data, and for future use */
+   png_byte signature[8] PNG_DEPSTRUCT;   /* magic bytes read by libpng from start of file */
 
    /* The rest of the data is optional.  If you are reading, check the
     * valid field to see if the information in these are valid.  If you
@@ -746,16 +645,16 @@
     * on which the image was created, normally in the range [1.0, 2.5].
     * Data is valid if (valid & PNG_INFO_gAMA) is non-zero.
     */
-   float gamma; /* gamma value of image, if (valid & PNG_INFO_gAMA) */
+   float gamma PNG_DEPSTRUCT; /* gamma value of image, if (valid & PNG_INFO_gAMA) */
 #endif
 
-#if defined(PNG_sRGB_SUPPORTED)
+#ifdef PNG_sRGB_SUPPORTED
     /* GR-P, 0.96a */
     /* Data valid if (valid & PNG_INFO_sRGB) non-zero. */
-   png_byte srgb_intent; /* sRGB rendering intent [0, 1, 2, or 3] */
+   png_byte srgb_intent PNG_DEPSTRUCT; /* sRGB rendering intent [0, 1, 2, or 3] */
 #endif
 
-#if defined(PNG_TEXT_SUPPORTED)
+#ifdef PNG_TEXT_SUPPORTED
    /* The tEXt, and zTXt chunks contain human-readable textual data in
     * uncompressed, compressed, and optionally compressed forms, respectively.
     * The data in "text" is an array of pointers to uncompressed,
@@ -764,26 +663,26 @@
     * unique, and the text string may be empty.  Any number of text chunks may
     * be in an image.
     */
-   int num_text; /* number of comments read/to write */
-   int max_text; /* current size of text array */
-   png_textp text; /* array of comments read/to write */
+   int num_text PNG_DEPSTRUCT; /* number of comments read/to write */
+   int max_text PNG_DEPSTRUCT; /* current size of text array */
+   png_textp text PNG_DEPSTRUCT; /* array of comments read/to write */
 #endif /* PNG_TEXT_SUPPORTED */
 
-#if defined(PNG_tIME_SUPPORTED)
+#ifdef PNG_tIME_SUPPORTED
    /* The tIME chunk holds the last time the displayed image data was
     * modified.  See the png_time struct for the contents of this struct.
     */
-   png_time mod_time;
+   png_time mod_time PNG_DEPSTRUCT;
 #endif
 
-#if defined(PNG_sBIT_SUPPORTED)
+#ifdef PNG_sBIT_SUPPORTED
    /* The sBIT chunk specifies the number of significant high-order bits
     * in the pixel data.  Values are in the range [1, bit_depth], and are
     * only specified for the channels in the pixel data.  The contents of
     * the low-order bits is not specified.  Data is valid if
     * (valid & PNG_INFO_sBIT) is non-zero.
     */
-   png_color_8 sig_bit; /* significant bits in color channels */
+   png_color_8 sig_bit PNG_DEPSTRUCT; /* significant bits in color channels */
 #endif
 
 #if defined(PNG_tRNS_SUPPORTED) || defined(PNG_READ_EXPAND_SUPPORTED) || \
@@ -797,8 +696,8 @@
     * single color specified that should be treated as fully transparent.
     * Data is valid if (valid & PNG_INFO_tRNS) is non-zero.
     */
-   png_bytep trans; /* transparent values for paletted image */
-   png_color_16 trans_values; /* transparent color for non-palette image */
+   png_bytep trans PNG_DEPSTRUCT; /* transparent values for paletted image */
+   png_color_16 trans_values PNG_DEPSTRUCT; /* transparent color for non-palette image */
 #endif
 
 #if defined(PNG_bKGD_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
@@ -808,38 +707,38 @@
     * in "background" are normally in the same color space/depth as the
     * pixel data.  Data is valid if (valid & PNG_INFO_bKGD) is non-zero.
     */
-   png_color_16 background;
+   png_color_16 background PNG_DEPSTRUCT;
 #endif
 
-#if defined(PNG_oFFs_SUPPORTED)
+#ifdef PNG_oFFs_SUPPORTED
    /* The oFFs chunk gives the offset in "offset_unit_type" units rightwards
     * and downwards from the top-left corner of the display, page, or other
     * application-specific co-ordinate space.  See the PNG_OFFSET_ defines
     * below for the unit types.  Valid if (valid & PNG_INFO_oFFs) non-zero.
     */
-   png_int_32 x_offset; /* x offset on page */
-   png_int_32 y_offset; /* y offset on page */
-   png_byte offset_unit_type; /* offset units type */
+   png_int_32 x_offset PNG_DEPSTRUCT; /* x offset on page */
+   png_int_32 y_offset PNG_DEPSTRUCT; /* y offset on page */
+   png_byte offset_unit_type PNG_DEPSTRUCT; /* offset units type */
 #endif
 
-#if defined(PNG_pHYs_SUPPORTED)
+#ifdef PNG_pHYs_SUPPORTED
    /* The pHYs chunk gives the physical pixel density of the image for
     * display or printing in "phys_unit_type" units (see PNG_RESOLUTION_
     * defines below).  Data is valid if (valid & PNG_INFO_pHYs) is non-zero.
     */
-   png_uint_32 x_pixels_per_unit; /* horizontal pixel density */
-   png_uint_32 y_pixels_per_unit; /* vertical pixel density */
-   png_byte phys_unit_type; /* resolution type (see PNG_RESOLUTION_ below) */
+   png_uint_32 x_pixels_per_unit PNG_DEPSTRUCT; /* horizontal pixel density */
+   png_uint_32 y_pixels_per_unit PNG_DEPSTRUCT; /* vertical pixel density */
+   png_byte phys_unit_type PNG_DEPSTRUCT; /* resolution type (see PNG_RESOLUTION_ below) */
 #endif
 
-#if defined(PNG_hIST_SUPPORTED)
+#ifdef PNG_hIST_SUPPORTED
    /* The hIST chunk contains the relative frequency or importance of the
     * various palette entries, so that a viewer can intelligently select a
     * reduced-color palette, if required.  Data is an array of "num_palette"
     * values in the range [0,65535]. Data valid if (valid & PNG_INFO_hIST)
     * is non-zero.
     */
-   png_uint_16p hist;
+   png_uint_16p hist PNG_DEPSTRUCT;
 #endif
 
 #ifdef PNG_cHRM_SUPPORTED
@@ -850,18 +749,18 @@
     * [0.0, 0.8].  Data valid if (valid & PNG_INFO_cHRM) non-zero.
     */
 #ifdef PNG_FLOATING_POINT_SUPPORTED
-   float x_white;
-   float y_white;
-   float x_red;
-   float y_red;
-   float x_green;
-   float y_green;
-   float x_blue;
-   float y_blue;
+   float x_white PNG_DEPSTRUCT;
+   float y_white PNG_DEPSTRUCT;
+   float x_red PNG_DEPSTRUCT;
+   float y_red PNG_DEPSTRUCT;
+   float x_green PNG_DEPSTRUCT;
+   float y_green PNG_DEPSTRUCT;
+   float x_blue PNG_DEPSTRUCT;
+   float y_blue PNG_DEPSTRUCT;
 #endif
 #endif
 
-#if defined(PNG_pCAL_SUPPORTED)
+#ifdef PNG_pCAL_SUPPORTED
    /* The pCAL chunk describes a transformation between the stored pixel
     * values and original physical data values used to create the image.
     * The integer range [0, 2^bit_depth - 1] maps to the floating-point
@@ -873,42 +772,43 @@
     * implemented, and for a description of the ASCII parameter strings.
     * Data values are valid if (valid & PNG_INFO_pCAL) non-zero.
     */
-   png_charp pcal_purpose;  /* pCAL chunk description string */
-   png_int_32 pcal_X0;      /* minimum value */
-   png_int_32 pcal_X1;      /* maximum value */
-   png_charp pcal_units;    /* Latin-1 string giving physical units */
-   png_charpp pcal_params;  /* ASCII strings containing parameter values */
-   png_byte pcal_type;      /* equation type (see PNG_EQUATION_ below) */
-   png_byte pcal_nparams;   /* number of parameters given in pcal_params */
+   png_charp pcal_purpose PNG_DEPSTRUCT;  /* pCAL chunk description string */
+   png_int_32 pcal_X0 PNG_DEPSTRUCT;      /* minimum value */
+   png_int_32 pcal_X1 PNG_DEPSTRUCT;      /* maximum value */
+   png_charp pcal_units PNG_DEPSTRUCT;    /* Latin-1 string giving physical units */
+   png_charpp pcal_params PNG_DEPSTRUCT;  /* ASCII strings containing parameter values */
+   png_byte pcal_type PNG_DEPSTRUCT;      /* equation type (see PNG_EQUATION_ below) */
+   png_byte pcal_nparams PNG_DEPSTRUCT;   /* number of parameters given in pcal_params */
 #endif
 
 /* New members added in libpng-1.0.6 */
 #ifdef PNG_FREE_ME_SUPPORTED
-   png_uint_32 free_me;     /* flags items libpng is responsible for freeing */
+   png_uint_32 free_me PNG_DEPSTRUCT;     /* flags items libpng is responsible for freeing */
 #endif
 
-#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
-   /* storage for unknown chunks that the library doesn't recognize. */
-   png_unknown_chunkp unknown_chunks;
-   png_size_t unknown_chunks_num;
+#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED) || \
+ defined(PNG_HANDLE_AS_UNKNOWN_SUPPORTED)
+   /* Storage for unknown chunks that the library doesn't recognize. */
+   png_unknown_chunkp unknown_chunks PNG_DEPSTRUCT;
+   png_size_t unknown_chunks_num PNG_DEPSTRUCT;
 #endif
 
-#if defined(PNG_iCCP_SUPPORTED)
+#ifdef PNG_iCCP_SUPPORTED
    /* iCCP chunk data. */
-   png_charp iccp_name;     /* profile name */
-   png_charp iccp_profile;  /* International Color Consortium profile data */
+   png_charp iccp_name PNG_DEPSTRUCT;     /* profile name */
+   png_charp iccp_profile PNG_DEPSTRUCT;  /* International Color Consortium profile data */
                             /* Note to maintainer: should be png_bytep */
-   png_uint_32 iccp_proflen;  /* ICC profile data length */
-   png_byte iccp_compression; /* Always zero */
+   png_uint_32 iccp_proflen PNG_DEPSTRUCT;  /* ICC profile data length */
+   png_byte iccp_compression PNG_DEPSTRUCT; /* Always zero */
 #endif
 
-#if defined(PNG_sPLT_SUPPORTED)
-   /* data on sPLT chunks (there may be more than one). */
-   png_sPLT_tp splt_palettes;
-   png_uint_32 splt_palettes_num;
+#ifdef PNG_sPLT_SUPPORTED
+   /* Data on sPLT chunks (there may be more than one). */
+   png_sPLT_tp splt_palettes PNG_DEPSTRUCT;
+   png_uint_32 splt_palettes_num PNG_DEPSTRUCT;
 #endif
 
-#if defined(PNG_sCAL_SUPPORTED)
+#ifdef PNG_sCAL_SUPPORTED
    /* The sCAL chunk describes the actual physical dimensions of the
     * subject matter of the graphic.  The chunk contains a unit specification
     * a byte value, and two ASCII strings representing floating-point
@@ -916,36 +816,36 @@
     * in the image.  This external representation is converted to double
     * here.  Data values are valid if (valid & PNG_INFO_sCAL) is non-zero.
     */
-   png_byte scal_unit;         /* unit of physical scale */
+   png_byte scal_unit PNG_DEPSTRUCT;         /* unit of physical scale */
 #ifdef PNG_FLOATING_POINT_SUPPORTED
-   double scal_pixel_width;    /* width of one pixel */
-   double scal_pixel_height;   /* height of one pixel */
+   double scal_pixel_width PNG_DEPSTRUCT;    /* width of one pixel */
+   double scal_pixel_height PNG_DEPSTRUCT;   /* height of one pixel */
 #endif
 #ifdef PNG_FIXED_POINT_SUPPORTED
-   png_charp scal_s_width;     /* string containing height */
-   png_charp scal_s_height;    /* string containing width */
+   png_charp scal_s_width PNG_DEPSTRUCT;     /* string containing height */
+   png_charp scal_s_height PNG_DEPSTRUCT;    /* string containing width */
 #endif
 #endif
 
-#if defined(PNG_INFO_IMAGE_SUPPORTED)
+#ifdef PNG_INFO_IMAGE_SUPPORTED
    /* Memory has been allocated if (valid & PNG_ALLOCATED_INFO_ROWS) non-zero */
    /* Data valid if (valid & PNG_INFO_IDAT) non-zero */
-   png_bytepp row_pointers;        /* the image bits */
+   png_bytepp row_pointers PNG_DEPSTRUCT;        /* the image bits */
 #endif
 
 #if defined(PNG_FIXED_POINT_SUPPORTED) && defined(PNG_gAMA_SUPPORTED)
-   png_fixed_point int_gamma; /* gamma of image, if (valid & PNG_INFO_gAMA) */
+   png_fixed_point int_gamma PNG_DEPSTRUCT; /* gamma of image, if (valid & PNG_INFO_gAMA) */
 #endif
 
 #if defined(PNG_cHRM_SUPPORTED) && defined(PNG_FIXED_POINT_SUPPORTED)
-   png_fixed_point int_x_white;
-   png_fixed_point int_y_white;
-   png_fixed_point int_x_red;
-   png_fixed_point int_y_red;
-   png_fixed_point int_x_green;
-   png_fixed_point int_y_green;
-   png_fixed_point int_x_blue;
-   png_fixed_point int_y_blue;
+   png_fixed_point int_x_white PNG_DEPSTRUCT;
+   png_fixed_point int_y_white PNG_DEPSTRUCT;
+   png_fixed_point int_x_red PNG_DEPSTRUCT;
+   png_fixed_point int_y_red PNG_DEPSTRUCT;
+   png_fixed_point int_x_green PNG_DEPSTRUCT;
+   png_fixed_point int_y_green PNG_DEPSTRUCT;
+   png_fixed_point int_x_blue PNG_DEPSTRUCT;
+   png_fixed_point int_y_blue PNG_DEPSTRUCT;
 #endif
 
 } png_info;
@@ -1098,10 +998,10 @@
     png_row_infop, png_bytep));
 #endif
 
-#if defined(PNG_USER_CHUNKS_SUPPORTED)
+#ifdef PNG_USER_CHUNKS_SUPPORTED
 typedef int (PNGAPI *png_user_chunk_ptr) PNGARG((png_structp, png_unknown_chunkp));
 #endif
-#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
+#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
 typedef void (PNGAPI *png_unknown_chunk_ptr) PNGARG((png_structp));
 #endif
 
@@ -1118,7 +1018,12 @@
 #define PNG_TRANSFORM_SWAP_ALPHA     0x0100    /* read and write */
 #define PNG_TRANSFORM_SWAP_ENDIAN    0x0200    /* read and write */
 #define PNG_TRANSFORM_INVERT_ALPHA   0x0400    /* read and write */
-#define PNG_TRANSFORM_STRIP_FILLER   0x0800    /* WRITE only */
+#define PNG_TRANSFORM_STRIP_FILLER   0x0800    /* write only, deprecated */
+/* Added to libpng-1.2.34 */
+#define PNG_TRANSFORM_STRIP_FILLER_BEFORE 0x0800  /* write only */
+#define PNG_TRANSFORM_STRIP_FILLER_AFTER  0x1000  /* write only */
+/* Added to libpng-1.2.41 */
+#define PNG_TRANSFORM_GRAY_TO_RGB   0x2000      /* read only */
 
 /* Flags for MNG supported features */
 #define PNG_FLAG_MNG_EMPTY_PLTE     0x01
@@ -1140,296 +1045,306 @@
 #ifdef PNG_SETJMP_SUPPORTED
    jmp_buf jmpbuf;            /* used in png_error */
 #endif
-   png_error_ptr error_fn;    /* function for printing errors and aborting */
-   png_error_ptr warning_fn;  /* function for printing warnings */
-   png_voidp error_ptr;       /* user supplied struct for error functions */
-   png_rw_ptr write_data_fn;  /* function for writing output data */
-   png_rw_ptr read_data_fn;   /* function for reading input data */
-   png_voidp io_ptr;          /* ptr to application struct for I/O functions */
+   png_error_ptr error_fn PNG_DEPSTRUCT;    /* function for printing errors and aborting */
+   png_error_ptr warning_fn PNG_DEPSTRUCT;  /* function for printing warnings */
+   png_voidp error_ptr PNG_DEPSTRUCT;       /* user supplied struct for error functions */
+   png_rw_ptr write_data_fn PNG_DEPSTRUCT;  /* function for writing output data */
+   png_rw_ptr read_data_fn PNG_DEPSTRUCT;   /* function for reading input data */
+   png_voidp io_ptr PNG_DEPSTRUCT;          /* ptr to application struct for I/O functions */
 
-#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
-   png_user_transform_ptr read_user_transform_fn; /* user read transform */
+#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
+   png_user_transform_ptr read_user_transform_fn PNG_DEPSTRUCT; /* user read transform */
 #endif
 
-#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
-   png_user_transform_ptr write_user_transform_fn; /* user write transform */
+#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
+   png_user_transform_ptr write_user_transform_fn PNG_DEPSTRUCT; /* user write transform */
 #endif
 
 /* These were added in libpng-1.0.2 */
-#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
+#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
 #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
     defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
-   png_voidp user_transform_ptr; /* user supplied struct for user transform */
-   png_byte user_transform_depth;    /* bit depth of user transformed pixels */
-   png_byte user_transform_channels; /* channels in user transformed pixels */
+   png_voidp user_transform_ptr PNG_DEPSTRUCT; /* user supplied struct for user transform */
+   png_byte user_transform_depth PNG_DEPSTRUCT;    /* bit depth of user transformed pixels */
+   png_byte user_transform_channels PNG_DEPSTRUCT; /* channels in user transformed pixels */
 #endif
 #endif
 
-   png_uint_32 mode;          /* tells us where we are in the PNG file */
-   png_uint_32 flags;         /* flags indicating various things to libpng */
-   png_uint_32 transformations; /* which transformations to perform */
-
-   z_stream zstream;          /* pointer to decompression structure (below) */
-   png_bytep zbuf;            /* buffer for zlib */
-   png_size_t zbuf_size;      /* size of zbuf */
-   int zlib_level;            /* holds zlib compression level */
-   int zlib_method;           /* holds zlib compression method */
-   int zlib_window_bits;      /* holds zlib compression window bits */
-   int zlib_mem_level;        /* holds zlib compression memory level */
-   int zlib_strategy;         /* holds zlib compression strategy */
-
-   png_uint_32 width;         /* width of image in pixels */
-   png_uint_32 height;        /* height of image in pixels */
-   png_uint_32 num_rows;      /* number of rows in current pass */
-   png_uint_32 usr_width;     /* width of row at start of write */
-   png_uint_32 rowbytes;      /* size of row in bytes */
-   png_uint_32 irowbytes;     /* size of current interlaced row in bytes */
-   png_uint_32 iwidth;        /* width of current interlaced row in pixels */
-   png_uint_32 row_number;    /* current row in interlace pass */
-   png_bytep prev_row;        /* buffer to save previous (unfiltered) row */
-   png_bytep row_buf;         /* buffer to save current (unfiltered) row */
-   png_bytep sub_row;         /* buffer to save "sub" row when filtering */
-   png_bytep up_row;          /* buffer to save "up" row when filtering */
-   png_bytep avg_row;         /* buffer to save "avg" row when filtering */
-   png_bytep paeth_row;       /* buffer to save "Paeth" row when filtering */
-   png_row_info row_info;     /* used for transformation routines */
-
-   png_uint_32 idat_size;     /* current IDAT size for read */
-   png_uint_32 crc;           /* current chunk CRC value */
-   png_colorp palette;        /* palette from the input file */
-   png_uint_16 num_palette;   /* number of color entries in palette */
-   png_uint_16 num_trans;     /* number of transparency values */
-   png_byte chunk_name[5];    /* null-terminated name of current chunk */
-   png_byte compression;      /* file compression type (always 0) */
-   png_byte filter;           /* file filter type (always 0) */
-   png_byte interlaced;       /* PNG_INTERLACE_NONE, PNG_INTERLACE_ADAM7 */
-   png_byte pass;             /* current interlace pass (0 - 6) */
-   png_byte do_filter;        /* row filter flags (see PNG_FILTER_ below ) */
-   png_byte color_type;       /* color type of file */
-   png_byte bit_depth;        /* bit depth of file */
-   png_byte usr_bit_depth;    /* bit depth of users row */
-   png_byte pixel_depth;      /* number of bits per pixel */
-   png_byte channels;         /* number of channels in file */
-   png_byte usr_channels;     /* channels at start of write */
-   png_byte sig_bytes;        /* magic bytes read/written from start of file */
+   png_uint_32 mode PNG_DEPSTRUCT;          /* tells us where we are in the PNG file */
+   png_uint_32 flags PNG_DEPSTRUCT;         /* flags indicating various things to libpng */
+   png_uint_32 transformations PNG_DEPSTRUCT; /* which transformations to perform */
+
+   z_stream zstream PNG_DEPSTRUCT;          /* pointer to decompression structure (below) */
+   png_bytep zbuf PNG_DEPSTRUCT;            /* buffer for zlib */
+   png_size_t zbuf_size PNG_DEPSTRUCT;      /* size of zbuf */
+   int zlib_level PNG_DEPSTRUCT;            /* holds zlib compression level */
+   int zlib_method PNG_DEPSTRUCT;           /* holds zlib compression method */
+   int zlib_window_bits PNG_DEPSTRUCT;      /* holds zlib compression window bits */
+   int zlib_mem_level PNG_DEPSTRUCT;        /* holds zlib compression memory level */
+   int zlib_strategy PNG_DEPSTRUCT;         /* holds zlib compression strategy */
+
+   png_uint_32 width PNG_DEPSTRUCT;         /* width of image in pixels */
+   png_uint_32 height PNG_DEPSTRUCT;        /* height of image in pixels */
+   png_uint_32 num_rows PNG_DEPSTRUCT;      /* number of rows in current pass */
+   png_uint_32 usr_width PNG_DEPSTRUCT;     /* width of row at start of write */
+   png_uint_32 rowbytes PNG_DEPSTRUCT;      /* size of row in bytes */
+#if 0 /* Replaced with the following in libpng-1.2.43 */
+   png_size_t irowbytes PNG_DEPSTRUCT;
+#endif
+/* Added in libpng-1.2.43 */
+#ifdef PNG_USER_LIMITS_SUPPORTED
+   /* Added in libpng-1.4.0: Total number of sPLT, text, and unknown
+    * chunks that can be stored (0 means unlimited).
+    */
+   png_uint_32 user_chunk_cache_max PNG_DEPSTRUCT;
+#endif
+   png_uint_32 iwidth PNG_DEPSTRUCT;        /* width of current interlaced row in pixels */
+   png_uint_32 row_number PNG_DEPSTRUCT;    /* current row in interlace pass */
+   png_bytep prev_row PNG_DEPSTRUCT;        /* buffer to save previous (unfiltered) row */
+   png_bytep row_buf PNG_DEPSTRUCT;         /* buffer to save current (unfiltered) row */
+#ifndef PNG_NO_WRITE_FILTER
+   png_bytep sub_row PNG_DEPSTRUCT;         /* buffer to save "sub" row when filtering */
+   png_bytep up_row PNG_DEPSTRUCT;          /* buffer to save "up" row when filtering */
+   png_bytep avg_row PNG_DEPSTRUCT;         /* buffer to save "avg" row when filtering */
+   png_bytep paeth_row PNG_DEPSTRUCT;       /* buffer to save "Paeth" row when filtering */
+#endif
+   png_row_info row_info PNG_DEPSTRUCT;     /* used for transformation routines */
+
+   png_uint_32 idat_size PNG_DEPSTRUCT;     /* current IDAT size for read */
+   png_uint_32 crc PNG_DEPSTRUCT;           /* current chunk CRC value */
+   png_colorp palette PNG_DEPSTRUCT;        /* palette from the input file */
+   png_uint_16 num_palette PNG_DEPSTRUCT;   /* number of color entries in palette */
+   png_uint_16 num_trans PNG_DEPSTRUCT;     /* number of transparency values */
+   png_byte chunk_name[5] PNG_DEPSTRUCT;    /* null-terminated name of current chunk */
+   png_byte compression PNG_DEPSTRUCT;      /* file compression type (always 0) */
+   png_byte filter PNG_DEPSTRUCT;           /* file filter type (always 0) */
+   png_byte interlaced PNG_DEPSTRUCT;       /* PNG_INTERLACE_NONE, PNG_INTERLACE_ADAM7 */
+   png_byte pass PNG_DEPSTRUCT;             /* current interlace pass (0 - 6) */
+   png_byte do_filter PNG_DEPSTRUCT;        /* row filter flags (see PNG_FILTER_ below ) */
+   png_byte color_type PNG_DEPSTRUCT;       /* color type of file */
+   png_byte bit_depth PNG_DEPSTRUCT;        /* bit depth of file */
+   png_byte usr_bit_depth PNG_DEPSTRUCT;    /* bit depth of users row */
+   png_byte pixel_depth PNG_DEPSTRUCT;      /* number of bits per pixel */
+   png_byte channels PNG_DEPSTRUCT;         /* number of channels in file */
+   png_byte usr_channels PNG_DEPSTRUCT;     /* channels at start of write */
+   png_byte sig_bytes PNG_DEPSTRUCT;        /* magic bytes read/written from start of file */
 
 #if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
 #ifdef PNG_LEGACY_SUPPORTED
-   png_byte filler;           /* filler byte for pixel expansion */
+   png_byte filler PNG_DEPSTRUCT;           /* filler byte for pixel expansion */
 #else
-   png_uint_16 filler;           /* filler bytes for pixel expansion */
+   png_uint_16 filler PNG_DEPSTRUCT;           /* filler bytes for pixel expansion */
 #endif
 #endif
 
-#if defined(PNG_bKGD_SUPPORTED)
-   png_byte background_gamma_type;
+#ifdef PNG_bKGD_SUPPORTED
+   png_byte background_gamma_type PNG_DEPSTRUCT;
 #  ifdef PNG_FLOATING_POINT_SUPPORTED
-   float background_gamma;
+   float background_gamma PNG_DEPSTRUCT;
 #  endif
-   png_color_16 background;   /* background color in screen gamma space */
-#if defined(PNG_READ_GAMMA_SUPPORTED)
-   png_color_16 background_1; /* background normalized to gamma 1.0 */
+   png_color_16 background PNG_DEPSTRUCT;   /* background color in screen gamma space */
+#ifdef PNG_READ_GAMMA_SUPPORTED
+   png_color_16 background_1 PNG_DEPSTRUCT; /* background normalized to gamma 1.0 */
 #endif
 #endif /* PNG_bKGD_SUPPORTED */
 
-#if defined(PNG_WRITE_FLUSH_SUPPORTED)
-   png_flush_ptr output_flush_fn;/* Function for flushing output */
-   png_uint_32 flush_dist;    /* how many rows apart to flush, 0 - no flush */
-   png_uint_32 flush_rows;    /* number of rows written since last flush */
+#ifdef PNG_WRITE_FLUSH_SUPPORTED
+   png_flush_ptr output_flush_fn PNG_DEPSTRUCT; /* Function for flushing output */
+   png_uint_32 flush_dist PNG_DEPSTRUCT;    /* how many rows apart to flush, 0 - no flush */
+   png_uint_32 flush_rows PNG_DEPSTRUCT;    /* number of rows written since last flush */
 #endif
 
 #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-   int gamma_shift;      /* number of "insignificant" bits 16-bit gamma */
+   int gamma_shift PNG_DEPSTRUCT;      /* number of "insignificant" bits 16-bit gamma */
 #ifdef PNG_FLOATING_POINT_SUPPORTED
-   float gamma;          /* file gamma value */
-   float screen_gamma;   /* screen gamma value (display_exponent) */
+   float gamma PNG_DEPSTRUCT;          /* file gamma value */
+   float screen_gamma PNG_DEPSTRUCT;   /* screen gamma value (display_exponent) */
 #endif
 #endif
 
 #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-   png_bytep gamma_table;     /* gamma table for 8-bit depth files */
-   png_bytep gamma_from_1;    /* converts from 1.0 to screen */
-   png_bytep gamma_to_1;      /* converts from file to 1.0 */
-   png_uint_16pp gamma_16_table; /* gamma table for 16-bit depth files */
-   png_uint_16pp gamma_16_from_1; /* converts from 1.0 to screen */
-   png_uint_16pp gamma_16_to_1; /* converts from file to 1.0 */
+   png_bytep gamma_table PNG_DEPSTRUCT;     /* gamma table for 8-bit depth files */
+   png_bytep gamma_from_1 PNG_DEPSTRUCT;    /* converts from 1.0 to screen */
+   png_bytep gamma_to_1 PNG_DEPSTRUCT;      /* converts from file to 1.0 */
+   png_uint_16pp gamma_16_table PNG_DEPSTRUCT; /* gamma table for 16-bit depth files */
+   png_uint_16pp gamma_16_from_1 PNG_DEPSTRUCT; /* converts from 1.0 to screen */
+   png_uint_16pp gamma_16_to_1 PNG_DEPSTRUCT; /* converts from file to 1.0 */
 #endif
 
 #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_sBIT_SUPPORTED)
-   png_color_8 sig_bit;       /* significant bits in each available channel */
+   png_color_8 sig_bit PNG_DEPSTRUCT;       /* significant bits in each available channel */
 #endif
 
 #if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
-   png_color_8 shift;         /* shift for significant bit tranformation */
+   png_color_8 shift PNG_DEPSTRUCT;         /* shift for significant bit tranformation */
 #endif
 
 #if defined(PNG_tRNS_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) \
  || defined(PNG_READ_EXPAND_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-   png_bytep trans;           /* transparency values for paletted files */
-   png_color_16 trans_values; /* transparency values for non-paletted files */
+   png_bytep trans PNG_DEPSTRUCT;           /* transparency values for paletted files */
+   png_color_16 trans_values PNG_DEPSTRUCT; /* transparency values for non-paletted files */
 #endif
 
-   png_read_status_ptr read_row_fn;   /* called after each row is decoded */
-   png_write_status_ptr write_row_fn; /* called after each row is encoded */
+   png_read_status_ptr read_row_fn PNG_DEPSTRUCT;   /* called after each row is decoded */
+   png_write_status_ptr write_row_fn PNG_DEPSTRUCT; /* called after each row is encoded */
 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-   png_progressive_info_ptr info_fn; /* called after header data fully read */
-   png_progressive_row_ptr row_fn;   /* called after each prog. row is decoded */
-   png_progressive_end_ptr end_fn;   /* called after image is complete */
-   png_bytep save_buffer_ptr;        /* current location in save_buffer */
-   png_bytep save_buffer;            /* buffer for previously read data */
-   png_bytep current_buffer_ptr;     /* current location in current_buffer */
-   png_bytep current_buffer;         /* buffer for recently used data */
-   png_uint_32 push_length;          /* size of current input chunk */
-   png_uint_32 skip_length;          /* bytes to skip in input data */
-   png_size_t save_buffer_size;      /* amount of data now in save_buffer */
-   png_size_t save_buffer_max;       /* total size of save_buffer */
-   png_size_t buffer_size;           /* total amount of available input data */
-   png_size_t current_buffer_size;   /* amount of data now in current_buffer */
-   int process_mode;                 /* what push library is currently doing */
-   int cur_palette;                  /* current push library palette index */
-
-#  if defined(PNG_TEXT_SUPPORTED)
-     png_size_t current_text_size;   /* current size of text input data */
-     png_size_t current_text_left;   /* how much text left to read in input */
-     png_charp current_text;         /* current text chunk buffer */
-     png_charp current_text_ptr;     /* current location in current_text */
+   png_progressive_info_ptr info_fn PNG_DEPSTRUCT; /* called after header data fully read */
+   png_progressive_row_ptr row_fn PNG_DEPSTRUCT;   /* called after each prog. row is decoded */
+   png_progressive_end_ptr end_fn PNG_DEPSTRUCT;   /* called after image is complete */
+   png_bytep save_buffer_ptr PNG_DEPSTRUCT;        /* current location in save_buffer */
+   png_bytep save_buffer PNG_DEPSTRUCT;            /* buffer for previously read data */
+   png_bytep current_buffer_ptr PNG_DEPSTRUCT;     /* current location in current_buffer */
+   png_bytep current_buffer PNG_DEPSTRUCT;         /* buffer for recently used data */
+   png_uint_32 push_length PNG_DEPSTRUCT;          /* size of current input chunk */
+   png_uint_32 skip_length PNG_DEPSTRUCT;          /* bytes to skip in input data */
+   png_size_t save_buffer_size PNG_DEPSTRUCT;      /* amount of data now in save_buffer */
+   png_size_t save_buffer_max PNG_DEPSTRUCT;       /* total size of save_buffer */
+   png_size_t buffer_size PNG_DEPSTRUCT;           /* total amount of available input data */
+   png_size_t current_buffer_size PNG_DEPSTRUCT;   /* amount of data now in current_buffer */
+   int process_mode PNG_DEPSTRUCT;                 /* what push library is currently doing */
+   int cur_palette PNG_DEPSTRUCT;                  /* current push library palette index */
+
+#  ifdef PNG_TEXT_SUPPORTED
+     png_size_t current_text_size PNG_DEPSTRUCT;   /* current size of text input data */
+     png_size_t current_text_left PNG_DEPSTRUCT;   /* how much text left to read in input */
+     png_charp current_text PNG_DEPSTRUCT;         /* current text chunk buffer */
+     png_charp current_text_ptr PNG_DEPSTRUCT;     /* current location in current_text */
 #  endif /* PNG_TEXT_SUPPORTED */
 #endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
 
 #if defined(__TURBOC__) && !defined(_Windows) && !defined(__FLAT__)
 /* for the Borland special 64K segment handler */
-   png_bytepp offset_table_ptr;
-   png_bytep offset_table;
-   png_uint_16 offset_table_number;
-   png_uint_16 offset_table_count;
-   png_uint_16 offset_table_count_free;
+   png_bytepp offset_table_ptr PNG_DEPSTRUCT;
+   png_bytep offset_table PNG_DEPSTRUCT;
+   png_uint_16 offset_table_number PNG_DEPSTRUCT;
+   png_uint_16 offset_table_count PNG_DEPSTRUCT;
+   png_uint_16 offset_table_count_free PNG_DEPSTRUCT;
 #endif
 
-#if defined(PNG_READ_DITHER_SUPPORTED)
-   png_bytep palette_lookup;         /* lookup table for dithering */
-   png_bytep dither_index;           /* index translation for palette files */
+#ifdef PNG_READ_DITHER_SUPPORTED
+   png_bytep palette_lookup PNG_DEPSTRUCT;         /* lookup table for dithering */
+   png_bytep dither_index PNG_DEPSTRUCT;           /* index translation for palette files */
 #endif
 
 #if defined(PNG_READ_DITHER_SUPPORTED) || defined(PNG_hIST_SUPPORTED)
-   png_uint_16p hist;                /* histogram */
-#endif
-
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-   png_byte heuristic_method;        /* heuristic for row filter selection */
-   png_byte num_prev_filters;        /* number of weights for previous rows */
-   png_bytep prev_filters;           /* filter type(s) of previous row(s) */
-   png_uint_16p filter_weights;      /* weight(s) for previous line(s) */
-   png_uint_16p inv_filter_weights;  /* 1/weight(s) for previous line(s) */
-   png_uint_16p filter_costs;        /* relative filter calculation cost */
-   png_uint_16p inv_filter_costs;    /* 1/relative filter calculation cost */
+   png_uint_16p hist PNG_DEPSTRUCT;                /* histogram */
 #endif
 
-#if defined(PNG_TIME_RFC1123_SUPPORTED)
-   png_charp time_buffer;            /* String to hold RFC 1123 time text */
+#ifdef PNG_TIME_RFC1123_SUPPORTED
+   png_charp time_buffer PNG_DEPSTRUCT;            /* String to hold RFC 1123 time text */
 #endif
 
 /* New members added in libpng-1.0.6 */
 
 #ifdef PNG_FREE_ME_SUPPORTED
-   png_uint_32 free_me;       /* flags items libpng is responsible for freeing */
+   png_uint_32 free_me PNG_DEPSTRUCT;   /* flags items libpng is responsible for freeing */
 #endif
 
-#if defined(PNG_USER_CHUNKS_SUPPORTED)
-   png_voidp user_chunk_ptr;
-   png_user_chunk_ptr read_user_chunk_fn; /* user read chunk handler */
+#ifdef PNG_USER_CHUNKS_SUPPORTED
+   png_voidp user_chunk_ptr PNG_DEPSTRUCT;
+   png_user_chunk_ptr read_user_chunk_fn PNG_DEPSTRUCT; /* user read chunk handler */
 #endif
 
-#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
-   int num_chunk_list;
-   png_bytep chunk_list;
+#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+   int num_chunk_list PNG_DEPSTRUCT;
+   png_bytep chunk_list PNG_DEPSTRUCT;
 #endif
 
 /* New members added in libpng-1.0.3 */
-#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
-   png_byte rgb_to_gray_status;
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
+   png_byte rgb_to_gray_status PNG_DEPSTRUCT;
    /* These were changed from png_byte in libpng-1.0.6 */
-   png_uint_16 rgb_to_gray_red_coeff;
-   png_uint_16 rgb_to_gray_green_coeff;
-   png_uint_16 rgb_to_gray_blue_coeff;
+   png_uint_16 rgb_to_gray_red_coeff PNG_DEPSTRUCT;
+   png_uint_16 rgb_to_gray_green_coeff PNG_DEPSTRUCT;
+   png_uint_16 rgb_to_gray_blue_coeff PNG_DEPSTRUCT;
 #endif
 
 /* New member added in libpng-1.0.4 (renamed in 1.0.9) */
 #if defined(PNG_MNG_FEATURES_SUPPORTED) || \
     defined(PNG_READ_EMPTY_PLTE_SUPPORTED) || \
     defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED)
-/* changed from png_byte to png_uint_32 at version 1.2.0 */
+/* Changed from png_byte to png_uint_32 at version 1.2.0 */
 #ifdef PNG_1_0_X
-   png_byte mng_features_permitted;
+   png_byte mng_features_permitted PNG_DEPSTRUCT;
 #else
-   png_uint_32 mng_features_permitted;
+   png_uint_32 mng_features_permitted PNG_DEPSTRUCT;
 #endif /* PNG_1_0_X */
 #endif
 
 /* New member added in libpng-1.0.7 */
 #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-   png_fixed_point int_gamma;
+   png_fixed_point int_gamma PNG_DEPSTRUCT;
 #endif
 
 /* New member added in libpng-1.0.9, ifdef'ed out in 1.0.12, enabled in 1.2.0 */
-#if defined(PNG_MNG_FEATURES_SUPPORTED)
-   png_byte filter_type;
+#ifdef PNG_MNG_FEATURES_SUPPORTED
+   png_byte filter_type PNG_DEPSTRUCT;
 #endif
 
-#if defined(PNG_1_0_X)
+#ifdef PNG_1_0_X
 /* New member added in libpng-1.0.10, ifdef'ed out in 1.2.0 */
-   png_uint_32 row_buf_size;
+   png_uint_32 row_buf_size PNG_DEPSTRUCT;
 #endif
 
 /* New members added in libpng-1.2.0 */
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
-#  if !defined(PNG_1_0_X)
-#    if defined(PNG_MMX_CODE_SUPPORTED)
-   png_byte     mmx_bitdepth_threshold;
-   png_uint_32  mmx_rowbytes_threshold;
+#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
+#  ifndef PNG_1_0_X
+#    ifdef PNG_MMX_CODE_SUPPORTED
+   png_byte     mmx_bitdepth_threshold PNG_DEPSTRUCT;
+   png_uint_32  mmx_rowbytes_threshold PNG_DEPSTRUCT;
 #    endif
-   png_uint_32  asm_flags;
+   png_uint_32  asm_flags PNG_DEPSTRUCT;
 #  endif
 #endif
 
 /* New members added in libpng-1.0.2 but first enabled by default in 1.2.0 */
 #ifdef PNG_USER_MEM_SUPPORTED
-   png_voidp mem_ptr;                /* user supplied struct for mem functions */
-   png_malloc_ptr malloc_fn;         /* function for allocating memory */
-   png_free_ptr free_fn;             /* function for freeing memory */
+   png_voidp mem_ptr PNG_DEPSTRUCT;            /* user supplied struct for mem functions */
+   png_malloc_ptr malloc_fn PNG_DEPSTRUCT;     /* function for allocating memory */
+   png_free_ptr free_fn PNG_DEPSTRUCT;         /* function for freeing memory */
 #endif
 
 /* New member added in libpng-1.0.13 and 1.2.0 */
-   png_bytep big_row_buf;         /* buffer to save current (unfiltered) row */
+   png_bytep big_row_buf PNG_DEPSTRUCT;        /* buffer to save current (unfiltered) row */
 
-#if defined(PNG_READ_DITHER_SUPPORTED)
+#ifdef PNG_READ_DITHER_SUPPORTED
 /* The following three members were added at version 1.0.14 and 1.2.4 */
-   png_bytep dither_sort;            /* working sort array */
-   png_bytep index_to_palette;       /* where the original index currently is */
-                                     /* in the palette */
-   png_bytep palette_to_index;       /* which original index points to this */
-                                     /* palette color */
+   png_bytep dither_sort PNG_DEPSTRUCT;        /* working sort array */
+   png_bytep index_to_palette PNG_DEPSTRUCT;   /* where the original index currently is */
+                                 /* in the palette */
+   png_bytep palette_to_index PNG_DEPSTRUCT;   /* which original index points to this */
+                                 /* palette color */
 #endif
 
 /* New members added in libpng-1.0.16 and 1.2.6 */
-   png_byte compression_type;
+   png_byte compression_type PNG_DEPSTRUCT;
 
-#ifdef PNG_SET_USER_LIMITS_SUPPORTED
-   png_uint_32 user_width_max;
-   png_uint_32 user_height_max;
+#ifdef PNG_USER_LIMITS_SUPPORTED
+   png_uint_32 user_width_max PNG_DEPSTRUCT;
+   png_uint_32 user_height_max PNG_DEPSTRUCT;
 #endif
 
 /* New member added in libpng-1.0.25 and 1.2.17 */
-#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
-   /* storage for unknown chunk that the library doesn't recognize. */
-   png_unknown_chunk unknown_chunk;
+#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
+   /* Storage for unknown chunk that the library doesn't recognize. */
+   png_unknown_chunk unknown_chunk PNG_DEPSTRUCT;
 #endif
+
+/* New members added in libpng-1.2.26 */
+  png_uint_32 old_big_row_buf_size PNG_DEPSTRUCT;
+  png_uint_32 old_prev_row_size PNG_DEPSTRUCT;
+
+/* New member added in libpng-1.2.30 */
+  png_charp chunkdata PNG_DEPSTRUCT;  /* buffer for reading chunk data */
+
+
 };
 
 
 /* This triggers a compiler error in png.c, if png.c and png.h
  * do not agree upon the version number.
  */
-typedef png_structp version_1_2_23;
+typedef png_structp version_1_2_55;
 
 typedef png_struct FAR * FAR * png_structpp;
 
@@ -1459,17 +1374,17 @@
 /* Simple signature checking function.  This is the same as calling
  * png_check_sig(sig, n) := !png_sig_cmp(sig, 0, n).
  */
-extern PNG_EXPORT(int,png_check_sig) PNGARG((png_bytep sig, int num));
+extern PNG_EXPORT(int,png_check_sig) PNGARG((png_bytep sig, int num)) PNG_DEPRECATED;
 
 /* Allocate and initialize png_ptr struct for reading, and any other memory. */
 extern PNG_EXPORT(png_structp,png_create_read_struct)
    PNGARG((png_const_charp user_png_ver, png_voidp error_ptr,
-   png_error_ptr error_fn, png_error_ptr warn_fn));
+   png_error_ptr error_fn, png_error_ptr warn_fn)) PNG_ALLOCATED;
 
 /* Allocate and initialize png_ptr struct for writing, and any other memory */
 extern PNG_EXPORT(png_structp,png_create_write_struct)
    PNGARG((png_const_charp user_png_ver, png_voidp error_ptr,
-   png_error_ptr error_fn, png_error_ptr warn_fn));
+   png_error_ptr error_fn, png_error_ptr warn_fn)) PNG_ALLOCATED;
 
 #ifdef PNG_WRITE_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_compression_buffer_size)
@@ -1489,11 +1404,11 @@
 extern PNG_EXPORT(png_structp,png_create_read_struct_2)
    PNGARG((png_const_charp user_png_ver, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
-   png_malloc_ptr malloc_fn, png_free_ptr free_fn));
+   png_malloc_ptr malloc_fn, png_free_ptr free_fn)) PNG_ALLOCATED;
 extern PNG_EXPORT(png_structp,png_create_write_struct_2)
    PNGARG((png_const_charp user_png_ver, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
-   png_malloc_ptr malloc_fn, png_free_ptr free_fn));
+   png_malloc_ptr malloc_fn, png_free_ptr free_fn)) PNG_ALLOCATED;
 #endif
 
 /* Write a PNG chunk - size, type, (optional) data, CRC. */
@@ -1513,11 +1428,12 @@
 
 /* Allocate and initialize the info structure */
 extern PNG_EXPORT(png_infop,png_create_info_struct)
-   PNGARG((png_structp png_ptr));
+   PNGARG((png_structp png_ptr)) PNG_ALLOCATED;
 
 #if defined(PNG_1_0_X) || defined (PNG_1_2_X)
 /* Initialize the info structure (old interface - DEPRECATED) */
-extern PNG_EXPORT(void,png_info_init) PNGARG((png_infop info_ptr));
+extern PNG_EXPORT(void,png_info_init) PNGARG((png_infop info_ptr))
+    PNG_DEPRECATED;
 #undef png_info_init
 #define png_info_init(info_ptr) png_info_init_3(&info_ptr,\
     png_sizeof(png_info));
@@ -1532,34 +1448,31 @@
 extern PNG_EXPORT(void,png_write_info) PNGARG((png_structp png_ptr,
    png_infop info_ptr));
 
-#ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
-/* read the information before the actual image data. */
+#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
+/* Read the information before the actual image data. */
 extern PNG_EXPORT(void,png_read_info) PNGARG((png_structp png_ptr,
    png_infop info_ptr));
 #endif
 
-#if defined(PNG_TIME_RFC1123_SUPPORTED)
+#ifdef PNG_TIME_RFC1123_SUPPORTED
 extern PNG_EXPORT(png_charp,png_convert_to_rfc1123)
    PNGARG((png_structp png_ptr, png_timep ptime));
 #endif
 
-#if !defined(_WIN32_WCE)
-/* "time.h" functions are not supported on WindowsCE */
-#if defined(PNG_WRITE_tIME_SUPPORTED)
-/* convert from a struct tm to png_time */
+#ifdef PNG_CONVERT_tIME_SUPPORTED
+/* Convert from a struct tm to png_time */
 extern PNG_EXPORT(void,png_convert_from_struct_tm) PNGARG((png_timep ptime,
    struct tm FAR * ttime));
 
-/* convert from time_t to png_time.  Uses gmtime() */
+/* Convert from time_t to png_time.  Uses gmtime() */
 extern PNG_EXPORT(void,png_convert_from_time_t) PNGARG((png_timep ptime,
    time_t ttime));
-#endif /* PNG_WRITE_tIME_SUPPORTED */
-#endif /* _WIN32_WCE */
+#endif /* PNG_CONVERT_tIME_SUPPORTED */
 
-#if defined(PNG_READ_EXPAND_SUPPORTED)
+#ifdef PNG_READ_EXPAND_SUPPORTED
 /* Expand data to 24-bit RGB, or 8-bit grayscale, with alpha if available. */
 extern PNG_EXPORT(void,png_set_expand) PNGARG((png_structp png_ptr));
-#if !defined(PNG_1_0_X)
+#ifndef PNG_1_0_X
 extern PNG_EXPORT(void,png_set_expand_gray_1_2_4_to_8) PNGARG((png_structp
   png_ptr));
 #endif
@@ -1567,7 +1480,8 @@
 extern PNG_EXPORT(void,png_set_tRNS_to_alpha) PNGARG((png_structp png_ptr));
 #if defined(PNG_1_0_X) || defined (PNG_1_2_X)
 /* Deprecated */
-extern PNG_EXPORT(void,png_set_gray_1_2_4_to_8) PNGARG((png_structp png_ptr));
+extern PNG_EXPORT(void,png_set_gray_1_2_4_to_8) PNGARG((png_structp
+    png_ptr)) PNG_DEPRECATED;
 #endif
 #endif
 
@@ -1576,12 +1490,12 @@
 extern PNG_EXPORT(void,png_set_bgr) PNGARG((png_structp png_ptr));
 #endif
 
-#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
 /* Expand the grayscale to 24-bit RGB if necessary. */
 extern PNG_EXPORT(void,png_set_gray_to_rgb) PNGARG((png_structp png_ptr));
 #endif
 
-#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
 /* Reduce RGB to grayscale. */
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 extern PNG_EXPORT(void,png_set_rgb_to_gray) PNGARG((png_structp png_ptr,
@@ -1596,7 +1510,7 @@
 extern PNG_EXPORT(void,png_build_grayscale_palette) PNGARG((int bit_depth,
    png_colorp palette));
 
-#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
+#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
 extern PNG_EXPORT(void,png_set_strip_alpha) PNGARG((png_structp png_ptr));
 #endif
 
@@ -1618,7 +1532,7 @@
 #define PNG_FILLER_BEFORE 0
 #define PNG_FILLER_AFTER 1
 /* Add an alpha byte to 8-bit Gray or 24-bit RGB images. */
-#if !defined(PNG_1_0_X)
+#ifndef PNG_1_0_X
 extern PNG_EXPORT(void,png_set_add_alpha) PNGARG((png_structp png_ptr,
    png_uint_32 filler, int flags));
 #endif
@@ -1656,7 +1570,7 @@
 extern PNG_EXPORT(void,png_set_invert_mono) PNGARG((png_structp png_ptr));
 #endif
 
-#if defined(PNG_READ_BACKGROUND_SUPPORTED)
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
 /* Handle alpha and tRNS by replacing with a background color. */
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 extern PNG_EXPORT(void,png_set_background) PNGARG((png_structp png_ptr,
@@ -1669,19 +1583,19 @@
 #define PNG_BACKGROUND_GAMMA_UNIQUE  3
 #endif
 
-#if defined(PNG_READ_16_TO_8_SUPPORTED)
-/* strip the second byte of information from a 16-bit depth file. */
+#ifdef PNG_READ_16_TO_8_SUPPORTED
+/* Strip the second byte of information from a 16-bit depth file. */
 extern PNG_EXPORT(void,png_set_strip_16) PNGARG((png_structp png_ptr));
 #endif
 
-#if defined(PNG_READ_DITHER_SUPPORTED)
+#ifdef PNG_READ_DITHER_SUPPORTED
 /* Turn on dithering, and reduce the palette to the number of colors available. */
 extern PNG_EXPORT(void,png_set_dither) PNGARG((png_structp png_ptr,
    png_colorp palette, int num_palette, int maximum_colors,
    png_uint_16p histogram, int full_dither));
 #endif
 
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
 /* Handle gamma correction. Screen_gamma=(display_exponent) */
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 extern PNG_EXPORT(void,png_set_gamma) PNGARG((png_structp png_ptr,
@@ -1695,85 +1609,85 @@
 /* Permit or disallow empty PLTE (0: not permitted, 1: permitted) */
 /* Deprecated and will be removed.  Use png_permit_mng_features() instead. */
 extern PNG_EXPORT(void,png_permit_empty_plte) PNGARG((png_structp png_ptr,
-   int empty_plte_permitted));
+   int empty_plte_permitted)) PNG_DEPRECATED;
 #endif
 #endif
 
-#if defined(PNG_WRITE_FLUSH_SUPPORTED)
+#ifdef PNG_WRITE_FLUSH_SUPPORTED
 /* Set how many lines between output flushes - 0 for no flushing */
 extern PNG_EXPORT(void,png_set_flush) PNGARG((png_structp png_ptr, int nrows));
 /* Flush the current PNG output buffer */
 extern PNG_EXPORT(void,png_write_flush) PNGARG((png_structp png_ptr));
 #endif
 
-/* optional update palette with requested transformations */
+/* Optional update palette with requested transformations */
 extern PNG_EXPORT(void,png_start_read_image) PNGARG((png_structp png_ptr));
 
-/* optional call to update the users info structure */
+/* Optional call to update the users info structure */
 extern PNG_EXPORT(void,png_read_update_info) PNGARG((png_structp png_ptr,
    png_infop info_ptr));
 
 #ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
-/* read one or more rows of image data. */
+/* Read one or more rows of image data. */
 extern PNG_EXPORT(void,png_read_rows) PNGARG((png_structp png_ptr,
    png_bytepp row, png_bytepp display_row, png_uint_32 num_rows));
 #endif
 
 #ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
-/* read a row of data. */
+/* Read a row of data. */
 extern PNG_EXPORT(void,png_read_row) PNGARG((png_structp png_ptr,
    png_bytep row,
    png_bytep display_row));
 #endif
 
 #ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
-/* read the whole image into memory at once. */
+/* Read the whole image into memory at once. */
 extern PNG_EXPORT(void,png_read_image) PNGARG((png_structp png_ptr,
    png_bytepp image));
 #endif
 
-/* write a row of image data */
+/* Write a row of image data */
 extern PNG_EXPORT(void,png_write_row) PNGARG((png_structp png_ptr,
    png_bytep row));
 
-/* write a few rows of image data */
+/* Write a few rows of image data */
 extern PNG_EXPORT(void,png_write_rows) PNGARG((png_structp png_ptr,
    png_bytepp row, png_uint_32 num_rows));
 
-/* write the image data */
+/* Write the image data */
 extern PNG_EXPORT(void,png_write_image) PNGARG((png_structp png_ptr,
    png_bytepp image));
 
-/* writes the end of the PNG file. */
+/* Writes the end of the PNG file. */
 extern PNG_EXPORT(void,png_write_end) PNGARG((png_structp png_ptr,
    png_infop info_ptr));
 
 #ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
-/* read the end of the PNG file. */
+/* Read the end of the PNG file. */
 extern PNG_EXPORT(void,png_read_end) PNGARG((png_structp png_ptr,
    png_infop info_ptr));
 #endif
 
-/* free any memory associated with the png_info_struct */
+/* Free any memory associated with the png_info_struct */
 extern PNG_EXPORT(void,png_destroy_info_struct) PNGARG((png_structp png_ptr,
    png_infopp info_ptr_ptr));
 
-/* free any memory associated with the png_struct and the png_info_structs */
+/* Free any memory associated with the png_struct and the png_info_structs */
 extern PNG_EXPORT(void,png_destroy_read_struct) PNGARG((png_structpp
    png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr));
 
-/* free all memory used by the read (old method - NOT DLL EXPORTED) */
+/* Free all memory used by the read (old method - NOT DLL EXPORTED) */
 extern void png_read_destroy PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_infop end_info_ptr));
+   png_infop end_info_ptr)) PNG_DEPRECATED;
 
-/* free any memory associated with the png_struct and the png_info_structs */
+/* Free any memory associated with the png_struct and the png_info_structs */
 extern PNG_EXPORT(void,png_destroy_write_struct)
    PNGARG((png_structpp png_ptr_ptr, png_infopp info_ptr_ptr));
 
-/* free any memory used in png_ptr struct (old method - NOT DLL EXPORTED) */
-extern void png_write_destroy PNGARG((png_structp png_ptr));
+/* Free any memory used in png_ptr struct (old method - NOT DLL EXPORTED) */
+extern void png_write_destroy PNGARG((png_structp png_ptr)) PNG_DEPRECATED;
 
-/* set the libpng method of handling chunk CRC errors */
+/* Set the libpng method of handling chunk CRC errors */
 extern PNG_EXPORT(void,png_set_crc_action) PNGARG((png_structp png_ptr,
    int crit_action, int ancil_action));
 
@@ -1801,7 +1715,7 @@
  * header file (zlib.h) for an explination of the compression functions.
  */
 
-/* set the filtering method(s) used by libpng.  Currently, the only valid
+/* Set the filtering method(s) used by libpng.  Currently, the only valid
  * value for "method" is 0.
  */
 extern PNG_EXPORT(void,png_set_filter) PNGARG((png_structp png_ptr, int method,
@@ -1831,35 +1745,7 @@
 #define PNG_FILTER_VALUE_PAETH 4
 #define PNG_FILTER_VALUE_LAST  5
 
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED) /* EXPERIMENTAL */
-/* The "heuristic_method" is given by one of the PNG_FILTER_HEURISTIC_
- * defines, either the default (minimum-sum-of-absolute-differences), or
- * the experimental method (weighted-minimum-sum-of-absolute-differences).
- *
- * Weights are factors >= 1.0, indicating how important it is to keep the
- * filter type consistent between rows.  Larger numbers mean the current
- * filter is that many times as likely to be the same as the "num_weights"
- * previous filters.  This is cumulative for each previous row with a weight.
- * There needs to be "num_weights" values in "filter_weights", or it can be
- * NULL if the weights aren't being specified.  Weights have no influence on
- * the selection of the first row filter.  Well chosen weights can (in theory)
- * improve the compression for a given image.
- *
- * Costs are factors >= 1.0 indicating the relative decoding costs of a
- * filter type.  Higher costs indicate more decoding expense, and are
- * therefore less likely to be selected over a filter with lower computational
- * costs.  There needs to be a value in "filter_costs" for each valid filter
- * type (given by PNG_FILTER_VALUE_LAST), or it can be NULL if you aren't
- * setting the costs.  Costs try to improve the speed of decompression without
- * unduly increasing the compressed image size.
- *
- * A negative weight or cost indicates the default value is to be used, and
- * values in the range [0.0, 1.0) indicate the value is to remain unchanged.
- * The default values for both weights and costs are currently 1.0, but may
- * change if good general weighting/cost heuristics can be found.  If both
- * the weights and costs are set to 1.0, this degenerates the WEIGHTED method
- * to the UNWEIGHTED method, but with added encoding time/computation.
- */
+#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED) /* DEPRECATED */
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 extern PNG_EXPORT(void,png_set_filter_heuristics) PNGARG((png_structp png_ptr,
    int heuristic_method, int num_weights, png_doublep filter_weights,
@@ -1867,9 +1753,7 @@
 #endif
 #endif /*  PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */
 
-/* Heuristic used for row filter selection.  These defines should NOT be
- * changed.
- */
+/* The following are no longer used and will be removed from libpng-1.7: */
 #define PNG_FILTER_HEURISTIC_DEFAULT    0  /* Currently "UNWEIGHTED" */
 #define PNG_FILTER_HEURISTIC_UNWEIGHTED 1  /* Used by libpng < 0.95 */
 #define PNG_FILTER_HEURISTIC_WEIGHTED   2  /* Experimental feature */
@@ -1906,7 +1790,7 @@
  * more information.
  */
 
-#if !defined(PNG_NO_STDIO)
+#ifdef PNG_STDIO_SUPPORTED
 /* Initialize the input/output for the PNG file to the default functions. */
 extern PNG_EXPORT(void,png_init_io) PNGARG((png_structp png_ptr, png_FILE_p fp));
 #endif
@@ -1929,6 +1813,11 @@
  * If buffered output is not used, then output_flush_fn can be set to NULL.
  * If PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile time
  * output_flush_fn will be ignored (and thus can be NULL).
+ * It is probably a mistake to use NULL for output_flush_fn if
+ * write_data_fn is not also NULL unless you have built libpng with
+ * PNG_WRITE_FLUSH_SUPPORTED undefined, because in this case libpng's
+ * default flush function, which uses the standard *FILE structure, will
+ * be used.
  */
 extern PNG_EXPORT(void,png_set_write_fn) PNGARG((png_structp png_ptr,
    png_voidp io_ptr, png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn));
@@ -1993,15 +1882,15 @@
    png_progressive_info_ptr info_fn, png_progressive_row_ptr row_fn,
    png_progressive_end_ptr end_fn));
 
-/* returns the user pointer associated with the push read functions */
+/* Returns the user pointer associated with the push read functions */
 extern PNG_EXPORT(png_voidp,png_get_progressive_ptr)
    PNGARG((png_structp png_ptr));
 
-/* function to be called when data becomes available */
+/* Function to be called when data becomes available */
 extern PNG_EXPORT(void,png_process_data) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_bytep buffer, png_size_t buffer_size));
 
-/* function that combines rows.  Not very much different than the
+/* Function that combines rows.  Not very much different than the
  * png_combine_row() call.  Is this even used?????
  */
 extern PNG_EXPORT(void,png_progressive_combine_row) PNGARG((png_structp png_ptr,
@@ -2009,20 +1898,20 @@
 #endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
 
 extern PNG_EXPORT(png_voidp,png_malloc) PNGARG((png_structp png_ptr,
-   png_uint_32 size));
+   png_uint_32 size)) PNG_ALLOCATED;
 
-#if defined(PNG_1_0_X)
+#ifdef PNG_1_0_X
 #  define png_malloc_warn png_malloc
 #else
 /* Added at libpng version 1.2.4 */
 extern PNG_EXPORT(png_voidp,png_malloc_warn) PNGARG((png_structp png_ptr,
-   png_uint_32 size));
+   png_uint_32 size)) PNG_ALLOCATED;
 #endif
 
-/* frees a pointer allocated by png_malloc() */
+/* Frees a pointer allocated by png_malloc() */
 extern PNG_EXPORT(void,png_free) PNGARG((png_structp png_ptr, png_voidp ptr));
 
-#if defined(PNG_1_0_X)
+#ifdef PNG_1_0_X
 /* Function to allocate memory for zlib. */
 extern PNG_EXPORT(voidpf,png_zalloc) PNGARG((voidpf png_ptr, uInt items,
    uInt size));
@@ -2036,11 +1925,12 @@
    png_infop info_ptr, png_uint_32 free_me, int num));
 #ifdef PNG_FREE_ME_SUPPORTED
 /* Reassign responsibility for freeing existing data, whether allocated
- * by libpng or by the application */
+ * by libpng or by the application
+ */
 extern PNG_EXPORT(void,png_data_freer) PNGARG((png_structp png_ptr,
    png_infop info_ptr, int freer, png_uint_32 mask));
 #endif
-/* assignments for png_data_freer */
+/* Assignments for png_data_freer */
 #define PNG_DESTROY_WILL_FREE_DATA 1
 #define PNG_SET_WILL_FREE_DATA 1
 #define PNG_USER_WILL_FREE_DATA 2
@@ -2061,16 +1951,16 @@
 
 #ifdef PNG_USER_MEM_SUPPORTED
 extern PNG_EXPORT(png_voidp,png_malloc_default) PNGARG((png_structp png_ptr,
-   png_uint_32 size));
+   png_uint_32 size)) PNG_ALLOCATED;
 extern PNG_EXPORT(void,png_free_default) PNGARG((png_structp png_ptr,
    png_voidp ptr));
 #endif
 
 extern PNG_EXPORT(png_voidp,png_memcpy_check) PNGARG((png_structp png_ptr,
-   png_voidp s1, png_voidp s2, png_uint_32 size));
+   png_voidp s1, png_voidp s2, png_uint_32 size)) PNG_DEPRECATED;
 
 extern PNG_EXPORT(png_voidp,png_memset_check) PNGARG((png_structp png_ptr,
-   png_voidp s1, int value, png_uint_32 size));
+   png_voidp s1, int value, png_uint_32 size)) PNG_DEPRECATED;
 
 #if defined(USE_FAR_KEYWORD)  /* memory model conversion function */
 extern void *png_far_to_near PNGARG((png_structp png_ptr,png_voidp ptr,
@@ -2080,14 +1970,14 @@
 #ifndef PNG_NO_ERROR_TEXT
 /* Fatal error in PNG image of libpng - can't continue */
 extern PNG_EXPORT(void,png_error) PNGARG((png_structp png_ptr,
-   png_const_charp error_message));
+   png_const_charp error_message)) PNG_NORETURN;
 
 /* The same, but the chunk name is prepended to the error string. */
 extern PNG_EXPORT(void,png_chunk_error) PNGARG((png_structp png_ptr,
-   png_const_charp error_message));
+   png_const_charp error_message)) PNG_NORETURN;
 #else
 /* Fatal error in PNG image of libpng - can't continue */
-extern PNG_EXPORT(void,png_err) PNGARG((png_structp png_ptr));
+extern PNG_EXPORT(void,png_err) PNGARG((png_structp png_ptr)) PNG_NORETURN;
 #endif
 
 #ifndef PNG_NO_WARNINGS
@@ -2122,13 +2012,15 @@
 extern PNG_EXPORT(png_uint_32,png_get_rowbytes) PNGARG((png_structp png_ptr,
 png_infop info_ptr));
 
-#if defined(PNG_INFO_IMAGE_SUPPORTED)
+#ifdef PNG_INFO_IMAGE_SUPPORTED
 /* Returns row_pointers, which is an array of pointers to scanlines that was
-returned from png_read_png(). */
+ * returned from png_read_png().
+ */
 extern PNG_EXPORT(png_bytepp,png_get_rows) PNGARG((png_structp png_ptr,
 png_infop info_ptr));
 /* Set row_pointers, which is an array of pointers to scanlines for use
-by png_write_png(). */
+ * by png_write_png().
+ */
 extern PNG_EXPORT(void,png_set_rows) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_bytepp row_pointers));
 #endif
@@ -2196,17 +2088,17 @@
 extern PNG_EXPORT(png_bytep,png_get_signature) PNGARG((png_structp png_ptr,
 png_infop info_ptr));
 
-#if defined(PNG_bKGD_SUPPORTED)
+#ifdef PNG_bKGD_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_bKGD) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_color_16p *background));
 #endif
 
-#if defined(PNG_bKGD_SUPPORTED)
+#ifdef PNG_bKGD_SUPPORTED
 extern PNG_EXPORT(void,png_set_bKGD) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_color_16p background));
 #endif
 
-#if defined(PNG_cHRM_SUPPORTED)
+#ifdef PNG_cHRM_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_cHRM) PNGARG((png_structp png_ptr,
    png_infop info_ptr, double *white_x, double *white_y, double *red_x,
@@ -2222,7 +2114,7 @@
 #endif
 #endif
 
-#if defined(PNG_cHRM_SUPPORTED)
+#ifdef PNG_cHRM_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 extern PNG_EXPORT(void,png_set_cHRM) PNGARG((png_structp png_ptr,
    png_infop info_ptr, double white_x, double white_y, double red_x,
@@ -2237,7 +2129,7 @@
 #endif
 #endif
 
-#if defined(PNG_gAMA_SUPPORTED)
+#ifdef PNG_gAMA_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_gAMA) PNGARG((png_structp png_ptr,
    png_infop info_ptr, double *file_gamma));
@@ -2246,7 +2138,7 @@
    png_infop info_ptr, png_fixed_point *int_file_gamma));
 #endif
 
-#if defined(PNG_gAMA_SUPPORTED)
+#ifdef PNG_gAMA_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 extern PNG_EXPORT(void,png_set_gAMA) PNGARG((png_structp png_ptr,
    png_infop info_ptr, double file_gamma));
@@ -2255,12 +2147,12 @@
    png_infop info_ptr, png_fixed_point int_file_gamma));
 #endif
 
-#if defined(PNG_hIST_SUPPORTED)
+#ifdef PNG_hIST_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_hIST) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_uint_16p *hist));
 #endif
 
-#if defined(PNG_hIST_SUPPORTED)
+#ifdef PNG_hIST_SUPPORTED
 extern PNG_EXPORT(void,png_set_hIST) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_uint_16p hist));
 #endif
@@ -2275,36 +2167,36 @@
    int color_type, int interlace_method, int compression_method,
    int filter_method));
 
-#if defined(PNG_oFFs_SUPPORTED)
+#ifdef PNG_oFFs_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_oFFs) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_int_32 *offset_x, png_int_32 *offset_y,
    int *unit_type));
 #endif
 
-#if defined(PNG_oFFs_SUPPORTED)
+#ifdef PNG_oFFs_SUPPORTED
 extern PNG_EXPORT(void,png_set_oFFs) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_int_32 offset_x, png_int_32 offset_y,
    int unit_type));
 #endif
 
-#if defined(PNG_pCAL_SUPPORTED)
+#ifdef PNG_pCAL_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_pCAL) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_charp *purpose, png_int_32 *X0, png_int_32 *X1,
    int *type, int *nparams, png_charp *units, png_charpp *params));
 #endif
 
-#if defined(PNG_pCAL_SUPPORTED)
+#ifdef PNG_pCAL_SUPPORTED
 extern PNG_EXPORT(void,png_set_pCAL) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_charp purpose, png_int_32 X0, png_int_32 X1,
    int type, int nparams, png_charp units, png_charpp params));
 #endif
 
-#if defined(PNG_pHYs_SUPPORTED)
+#ifdef PNG_pHYs_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_pHYs) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type));
 #endif
 
-#if defined(PNG_pHYs_SUPPORTED)
+#ifdef PNG_pHYs_SUPPORTED
 extern PNG_EXPORT(void,png_set_pHYs) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_uint_32 res_x, png_uint_32 res_y, int unit_type));
 #endif
@@ -2315,53 +2207,53 @@
 extern PNG_EXPORT(void,png_set_PLTE) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_colorp palette, int num_palette));
 
-#if defined(PNG_sBIT_SUPPORTED)
+#ifdef PNG_sBIT_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_sBIT) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_color_8p *sig_bit));
 #endif
 
-#if defined(PNG_sBIT_SUPPORTED)
+#ifdef PNG_sBIT_SUPPORTED
 extern PNG_EXPORT(void,png_set_sBIT) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_color_8p sig_bit));
 #endif
 
-#if defined(PNG_sRGB_SUPPORTED)
+#ifdef PNG_sRGB_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_sRGB) PNGARG((png_structp png_ptr,
    png_infop info_ptr, int *intent));
 #endif
 
-#if defined(PNG_sRGB_SUPPORTED)
+#ifdef PNG_sRGB_SUPPORTED
 extern PNG_EXPORT(void,png_set_sRGB) PNGARG((png_structp png_ptr,
    png_infop info_ptr, int intent));
 extern PNG_EXPORT(void,png_set_sRGB_gAMA_and_cHRM) PNGARG((png_structp png_ptr,
    png_infop info_ptr, int intent));
 #endif
 
-#if defined(PNG_iCCP_SUPPORTED)
+#ifdef PNG_iCCP_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_iCCP) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_charpp name, int *compression_type,
    png_charpp profile, png_uint_32 *proflen));
    /* Note to maintainer: profile should be png_bytepp */
 #endif
 
-#if defined(PNG_iCCP_SUPPORTED)
+#ifdef PNG_iCCP_SUPPORTED
 extern PNG_EXPORT(void,png_set_iCCP) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_charp name, int compression_type,
    png_charp profile, png_uint_32 proflen));
    /* Note to maintainer: profile should be png_bytep */
 #endif
 
-#if defined(PNG_sPLT_SUPPORTED)
+#ifdef PNG_sPLT_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_sPLT) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_sPLT_tpp entries));
 #endif
 
-#if defined(PNG_sPLT_SUPPORTED)
+#ifdef PNG_sPLT_SUPPORTED
 extern PNG_EXPORT(void,png_set_sPLT) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_sPLT_tp entries, int nentries));
 #endif
 
-#if defined(PNG_TEXT_SUPPORTED)
+#ifdef PNG_TEXT_SUPPORTED
 /* png_get_text also returns the number of text chunks in *num_text */
 extern PNG_EXPORT(png_uint_32,png_get_text) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_textp *text_ptr, int *num_text));
@@ -2375,37 +2267,37 @@
  *  they will never be NULL pointers.
  */
 
-#if defined(PNG_TEXT_SUPPORTED)
+#ifdef PNG_TEXT_SUPPORTED
 extern PNG_EXPORT(void,png_set_text) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_textp text_ptr, int num_text));
 #endif
 
-#if defined(PNG_tIME_SUPPORTED)
+#ifdef PNG_tIME_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_tIME) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_timep *mod_time));
 #endif
 
-#if defined(PNG_tIME_SUPPORTED)
+#ifdef PNG_tIME_SUPPORTED
 extern PNG_EXPORT(void,png_set_tIME) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_timep mod_time));
 #endif
 
-#if defined(PNG_tRNS_SUPPORTED)
+#ifdef PNG_tRNS_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_tRNS) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_bytep *trans, int *num_trans,
    png_color_16p *trans_values));
 #endif
 
-#if defined(PNG_tRNS_SUPPORTED)
+#ifdef PNG_tRNS_SUPPORTED
 extern PNG_EXPORT(void,png_set_tRNS) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_bytep trans, int num_trans,
    png_color_16p trans_values));
 #endif
 
-#if defined(PNG_tRNS_SUPPORTED)
+#ifdef PNG_tRNS_SUPPORTED
 #endif
 
-#if defined(PNG_sCAL_SUPPORTED)
+#ifdef PNG_sCAL_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 extern PNG_EXPORT(png_uint_32,png_get_sCAL) PNGARG((png_structp png_ptr,
    png_infop info_ptr, int *unit, double *width, double *height));
@@ -2417,7 +2309,7 @@
 #endif
 #endif /* PNG_sCAL_SUPPORTED */
 
-#if defined(PNG_sCAL_SUPPORTED)
+#ifdef PNG_sCAL_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 extern PNG_EXPORT(void,png_set_sCAL) PNGARG((png_structp png_ptr,
    png_infop info_ptr, int unit, double width, double height));
@@ -2429,8 +2321,8 @@
 #endif
 #endif /* PNG_sCAL_SUPPORTED || PNG_WRITE_sCAL_SUPPORTED */
 
-#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
-/* provide a list of chunks and how they are to be handled, if the built-in
+#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+/* Provide a list of chunks and how they are to be handled, if the built-in
    handling or default unknown chunk handling is not desired.  Any chunks not
    listed will be handled in the default manner.  The IHDR and IEND chunks
    must not be listed.
@@ -2441,6 +2333,10 @@
 */
 extern PNG_EXPORT(void, png_set_keep_unknown_chunks) PNGARG((png_structp
    png_ptr, int keep, png_bytep chunk_list, int num_chunks));
+PNG_EXPORT(int,png_handle_as_unknown) PNGARG((png_structp png_ptr, png_bytep
+   chunk_name));
+#endif
+#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
 extern PNG_EXPORT(void, png_set_unknown_chunks) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_unknown_chunkp unknowns, int num_unknowns));
 extern PNG_EXPORT(void, png_set_unknown_chunk_location)
@@ -2448,18 +2344,15 @@
 extern PNG_EXPORT(png_uint_32,png_get_unknown_chunks) PNGARG((png_structp
    png_ptr, png_infop info_ptr, png_unknown_chunkpp entries));
 #endif
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-PNG_EXPORT(int,png_handle_as_unknown) PNGARG((png_structp png_ptr, png_bytep
-   chunk_name));
-#endif
 
 /* Png_free_data() will turn off the "valid" flag for anything it frees.
-   If you need to turn it off for a chunk that your application has freed,
-   you can use png_set_invalid(png_ptr, info_ptr, PNG_INFO_CHNK); */
+ * If you need to turn it off for a chunk that your application has freed,
+ * you can use png_set_invalid(png_ptr, info_ptr, PNG_INFO_CHNK);
+ */
 extern PNG_EXPORT(void, png_set_invalid) PNGARG((png_structp png_ptr,
    png_infop info_ptr, int mask));
 
-#if defined(PNG_INFO_IMAGE_SUPPORTED)
+#ifdef PNG_INFO_IMAGE_SUPPORTED
 /* The "params" pointer is currently not used and is for future expansion. */
 extern PNG_EXPORT(void, png_read_png) PNGARG((png_structp png_ptr,
                         png_infop info_ptr,
@@ -2481,34 +2374,90 @@
 #if !defined(PNG_DEBUG_FILE) && defined(_MSC_VER)
 #include <crtdbg.h>
 #if (PNG_DEBUG > 1)
-#define png_debug(l,m)  _RPT0(_CRT_WARN,m)
-#define png_debug1(l,m,p1)  _RPT1(_CRT_WARN,m,p1)
-#define png_debug2(l,m,p1,p2) _RPT2(_CRT_WARN,m,p1,p2)
+#ifndef _DEBUG
+#  define _DEBUG
+#endif
+#ifndef png_debug
+#define png_debug(l,m)  _RPT0(_CRT_WARN,m PNG_STRING_NEWLINE)
+#endif
+#ifndef png_debug1
+#define png_debug1(l,m,p1)  _RPT1(_CRT_WARN,m PNG_STRING_NEWLINE,p1)
+#endif
+#ifndef png_debug2
+#define png_debug2(l,m,p1,p2) _RPT2(_CRT_WARN,m PNG_STRING_NEWLINE,p1,p2)
+#endif
 #endif
 #else /* PNG_DEBUG_FILE || !_MSC_VER */
 #ifndef PNG_DEBUG_FILE
 #define PNG_DEBUG_FILE stderr
 #endif /* PNG_DEBUG_FILE */
+
 #if (PNG_DEBUG > 1)
-#define png_debug(l,m) \
-{ \
-     int num_tabs=l; \
-     fprintf(PNG_DEBUG_FILE,"%s"m,(num_tabs==1 ? "\t" : \
-       (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":"")))); \
-}
-#define png_debug1(l,m,p1) \
-{ \
-     int num_tabs=l; \
-     fprintf(PNG_DEBUG_FILE,"%s"m,(num_tabs==1 ? "\t" : \
-       (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))),p1); \
-}
-#define png_debug2(l,m,p1,p2) \
-{ \
-     int num_tabs=l; \
-     fprintf(PNG_DEBUG_FILE,"%s"m,(num_tabs==1 ? "\t" : \
-       (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))),p1,p2); \
-}
+/* Note: ["%s"m PNG_STRING_NEWLINE] probably does not work on non-ISO
+ * compilers.
+ */
+#  ifdef __STDC__
+#    ifndef png_debug
+#      define png_debug(l,m) \
+       { \
+       int num_tabs=l; \
+       fprintf(PNG_DEBUG_FILE,"%s" m PNG_STRING_NEWLINE,(num_tabs==1 ? "\t" : \
+         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":"")))); \
+       }
+#    endif
+#    ifndef png_debug1
+#      define png_debug1(l,m,p1) \
+       { \
+       int num_tabs=l; \
+       fprintf(PNG_DEBUG_FILE,"%s" m PNG_STRING_NEWLINE,(num_tabs==1 ? "\t" : \
+         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))),p1); \
+       }
+#    endif
+#    ifndef png_debug2
+#      define png_debug2(l,m,p1,p2) \
+       { \
+       int num_tabs=l; \
+       fprintf(PNG_DEBUG_FILE,"%s" m PNG_STRING_NEWLINE,(num_tabs==1 ? "\t" : \
+         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))),p1,p2); \
+       }
+#    endif
+#  else /* __STDC __ */
+#    ifndef png_debug
+#      define png_debug(l,m) \
+       { \
+       int num_tabs=l; \
+       char format[256]; \
+       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
+         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
+         m,PNG_STRING_NEWLINE); \
+       fprintf(PNG_DEBUG_FILE,format); \
+       }
+#    endif
+#    ifndef png_debug1
+#      define png_debug1(l,m,p1) \
+       { \
+       int num_tabs=l; \
+       char format[256]; \
+       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
+         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
+         m,PNG_STRING_NEWLINE); \
+       fprintf(PNG_DEBUG_FILE,format,p1); \
+       }
+#    endif
+#    ifndef png_debug2
+#      define png_debug2(l,m,p1,p2) \
+       { \
+       int num_tabs=l; \
+       char format[256]; \
+       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
+         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
+         m,PNG_STRING_NEWLINE); \
+       fprintf(PNG_DEBUG_FILE,format,p1,p2); \
+       }
+#    endif
+#  endif /* __STDC __ */
 #endif /* (PNG_DEBUG > 1) */
+
 #endif /* _MSC_VER */
 #endif /* (PNG_DEBUG > 0) */
 #endif /* PNG_DEBUG */
@@ -2539,8 +2488,8 @@
 #define PNG_HANDLE_CHUNK_ALWAYS       3
 
 /* Added to version 1.2.0 */
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
-#if defined(PNG_MMX_CODE_SUPPORTED)
+#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
+#ifdef PNG_MMX_CODE_SUPPORTED
 #define PNG_ASM_FLAG_MMX_SUPPORT_COMPILED  0x01  /* not user-settable */
 #define PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU    0x02  /* not user-settable */
 #define PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  0x04
@@ -2568,7 +2517,7 @@
 #define PNG_SELECT_WRITE  2
 #endif /* PNG_MMX_CODE_SUPPORTED */
 
-#if !defined(PNG_1_0_X)
+#ifndef PNG_1_0_X
 /* pngget.c */
 extern PNG_EXPORT(png_uint_32,png_get_mmx_flagmask)
    PNGARG((int flag_select, int *compilerID));
@@ -2600,20 +2549,20 @@
 
 #endif /* PNG_1_0_X */
 
-#if !defined(PNG_1_0_X)
+#ifndef PNG_1_0_X
 /* png.c, pnggccrd.c, or pngvcrd.c */
 extern PNG_EXPORT(int,png_mmx_support) PNGARG((void));
+#endif /* PNG_1_0_X */
 #endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
 
 /* Strip the prepended error numbers ("#nnn ") from error and warning
- * messages before passing them to the error or warning handler. */
+ * messages before passing them to the error or warning handler.
+ */
 #ifdef PNG_ERROR_NUMBERS_SUPPORTED
 extern PNG_EXPORT(void,png_set_strip_error_numbers) PNGARG((png_structp
    png_ptr, png_uint_32 strip_mode));
 #endif
 
-#endif /* PNG_1_0_X */
-
 /* Added at libpng-1.2.6 */
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
 extern PNG_EXPORT(void,png_set_user_limits) PNGARG((png_structp
@@ -2623,8 +2572,9 @@
 extern PNG_EXPORT(png_uint_32,png_get_user_height_max) PNGARG((png_structp
    png_ptr));
 #endif
-
-/* Maintainer: Put new public prototypes here ^, in libpng.3, and project defs */
+/* Maintainer: Put new public prototypes here ^, in libpng.3, and in
+ * project defs
+ */
 
 #ifdef PNG_READ_COMPOSITE_NODIV_SUPPORTED
 /* With these routines we avoid an integer divide, which will be slower on
@@ -2653,7 +2603,7 @@
                         (png_uint_32)(alpha)) + (png_uint_32)32768L);        \
        (composite) = (png_uint_16)((temp + (temp >> 16)) >> 16); }
 
-#else  /* standard method using integer division */
+#else  /* Standard method using integer division */
 
 #  define png_composite(composite, fg, alpha, bg)                            \
      (composite) = (png_byte)(((png_uint_16)(fg) * (png_uint_16)(alpha) +    \
@@ -2675,7 +2625,7 @@
  * routine also assumes we are using two's complement format for negative
  * values, which is almost certainly true.
  */
-#if defined(PNG_READ_BIG_ENDIAN_SUPPORTED)
+#ifdef PNG_READ_BIG_ENDIAN_SUPPORTED
 #  define png_get_uint_32(buf) ( *((png_uint_32p) (buf)))
 #  define png_get_uint_16(buf) ( *((png_uint_16p) (buf)))
 #  define png_get_int_32(buf)  ( *((png_int_32p)  (buf)))
@@ -2721,7 +2671,7 @@
 #define PNG_AFTER_IDAT              0x08 /* Have complete zlib datastream */
 #define PNG_HAVE_IEND               0x10
 
-#if defined(PNG_INTERNAL)
+#ifdef PNG_INTERNAL
 
 /* More modes of operation.  Note that after an init, mode is set to
  * zero automatically when the structure is created.
@@ -2736,7 +2686,7 @@
 #define PNG_HAVE_PNG_SIGNATURE    0x1000
 #define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000 /* Have another chunk after IDAT */
 
-/* flags for the transformations the PNG library does on the image data */
+/* Flags for the transformations the PNG library does on the image data */
 #define PNG_BGR                0x0001
 #define PNG_INTERLACE          0x0002
 #define PNG_PACK               0x0004
@@ -2764,13 +2714,14 @@
                        /*    0x800000L     Unused */
 #define PNG_ADD_ALPHA       0x1000000L  /* Added to libpng-1.2.7 */
 #define PNG_EXPAND_tRNS     0x2000000L  /* Added to libpng-1.2.9 */
-                       /*   0x4000000L  unused */
+#define PNG_PREMULTIPLY_ALPHA 0x4000000L  /* Added to libpng-1.2.41 */
+                                          /* by volker */
                        /*   0x8000000L  unused */
                        /*  0x10000000L  unused */
                        /*  0x20000000L  unused */
                        /*  0x40000000L  unused */
 
-/* flags for png_create_struct */
+/* Flags for png_create_struct */
 #define PNG_STRUCT_PNG   0x0001
 #define PNG_STRUCT_INFO  0x0002
 
@@ -2780,7 +2731,7 @@
 #define PNG_COST_SHIFT 3
 #define PNG_COST_FACTOR (1<<(PNG_COST_SHIFT))
 
-/* flags for the png_ptr->flags rather than declaring a byte for each one */
+/* Flags for the png_ptr->flags rather than declaring a byte for each one */
 #define PNG_FLAG_ZLIB_CUSTOM_STRATEGY     0x0001
 #define PNG_FLAG_ZLIB_CUSTOM_LEVEL        0x0002
 #define PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL    0x0004
@@ -2822,7 +2773,7 @@
 #define PNG_FLAG_CRC_MASK           (PNG_FLAG_CRC_ANCILLARY_MASK | \
                                      PNG_FLAG_CRC_CRITICAL_MASK)
 
-/* save typing and make code easier to understand */
+/* Save typing and make code easier to understand */
 
 #define PNG_COLOR_DIST(c1, c2) (abs((int)((c1).red) - (int)((c2).red)) + \
    abs((int)((c1).green) - (int)((c2).green)) + \
@@ -2835,15 +2786,16 @@
     (( ((width) * ((png_uint_32)(pixel_bits))) + 7) >> 3) )
 
 /* PNG_OUT_OF_RANGE returns true if value is outside the range
-   ideal-delta..ideal+delta.  Each argument is evaluated twice.
-   "ideal" and "delta" should be constants, normally simple
-   integers, "value" a variable. Added to libpng-1.2.6 JB */
+ * ideal-delta..ideal+delta.  Each argument is evaluated twice.
+ * "ideal" and "delta" should be constants, normally simple
+ * integers, "value" a variable. Added to libpng-1.2.6 JB
+ */
 #define PNG_OUT_OF_RANGE(value, ideal, delta) \
         ( (value) < (ideal)-(delta) || (value) > (ideal)+(delta) )
 
-/* variables declared in png.c - only it needs to define PNG_NO_EXTERN */
+/* Variables declared in png.c - only it needs to define PNG_NO_EXTERN */
 #if !defined(PNG_NO_EXTERN) || defined(PNG_ALWAYS_EXTERN)
-/* place to hold the signature string for a PNG file. */
+/* Place to hold the signature string for a PNG file. */
 #ifdef PNG_USE_GLOBAL_ARRAYS
    PNG_EXPORT_VAR (PNG_CONST png_byte FARDATA) png_sig[8];
 #else
@@ -2904,7 +2856,8 @@
 /* Initialize png_ptr struct for reading, and allocate any other memory.
  * (old interface - DEPRECATED - use png_create_read_struct instead).
  */
-extern PNG_EXPORT(void,png_read_init) PNGARG((png_structp png_ptr));
+extern PNG_EXPORT(void,png_read_init) PNGARG((png_structp png_ptr))
+    PNG_DEPRECATED;
 #undef png_read_init
 #define png_read_init(png_ptr) png_read_init_3(&png_ptr, \
     PNG_LIBPNG_VER_STRING,  png_sizeof(png_struct));
@@ -2922,7 +2875,8 @@
 /* Initialize png_ptr struct for writing, and allocate any other memory.
  * (old interface - DEPRECATED - use png_create_write_struct instead).
  */
-extern PNG_EXPORT(void,png_write_init) PNGARG((png_structp png_ptr));
+extern PNG_EXPORT(void,png_write_init) PNGARG((png_structp png_ptr))
+    PNG_DEPRECATED;
 #undef png_write_init
 #define png_write_init(png_ptr) png_write_init_3(&png_ptr, \
     PNG_LIBPNG_VER_STRING, png_sizeof(png_struct));
@@ -2935,102 +2889,107 @@
     png_info_size));
 
 /* Allocate memory for an internal libpng struct */
-PNG_EXTERN png_voidp png_create_struct PNGARG((int type));
+PNG_EXTERN png_voidp png_create_struct PNGARG((int type)) PNG_PRIVATE;
 
 /* Free memory from internal libpng struct */
-PNG_EXTERN void png_destroy_struct PNGARG((png_voidp struct_ptr));
+PNG_EXTERN void png_destroy_struct PNGARG((png_voidp struct_ptr)) PNG_PRIVATE;
 
 PNG_EXTERN png_voidp png_create_struct_2 PNGARG((int type, png_malloc_ptr
-  malloc_fn, png_voidp mem_ptr));
+  malloc_fn, png_voidp mem_ptr)) PNG_PRIVATE;
 PNG_EXTERN void png_destroy_struct_2 PNGARG((png_voidp struct_ptr,
-   png_free_ptr free_fn, png_voidp mem_ptr));
+   png_free_ptr free_fn, png_voidp mem_ptr)) PNG_PRIVATE;
 
 /* Free any memory that info_ptr points to and reset struct. */
 PNG_EXTERN void png_info_destroy PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
+   png_infop info_ptr)) PNG_PRIVATE;
 
 #ifndef PNG_1_0_X
 /* Function to allocate memory for zlib. */
-PNG_EXTERN voidpf png_zalloc PNGARG((voidpf png_ptr, uInt items, uInt size));
+PNG_EXTERN voidpf png_zalloc PNGARG((voidpf png_ptr, uInt items,
+   uInt size)) PNG_PRIVATE;
 
 /* Function to free memory for zlib */
-PNG_EXTERN void png_zfree PNGARG((voidpf png_ptr, voidpf ptr));
+PNG_EXTERN void png_zfree PNGARG((voidpf png_ptr, voidpf ptr)) PNG_PRIVATE;
 
 #ifdef PNG_SIZE_T
 /* Function to convert a sizeof an item to png_sizeof item */
-   PNG_EXTERN png_size_t PNGAPI png_convert_size PNGARG((size_t size));
+   PNG_EXTERN png_size_t PNGAPI png_convert_size PNGARG((size_t size))
+      PNG_PRIVATE;
 #endif
 
 /* Next four functions are used internally as callbacks.  PNGAPI is required
- * but not PNG_EXPORT.  PNGAPI added at libpng version 1.2.3. */
+ * but not PNG_EXPORT.  PNGAPI added at libpng version 1.2.3.
+ */
 
 PNG_EXTERN void PNGAPI png_default_read_data PNGARG((png_structp png_ptr,
-   png_bytep data, png_size_t length));
+   png_bytep data, png_size_t length)) PNG_PRIVATE;
 
 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
 PNG_EXTERN void PNGAPI png_push_fill_buffer PNGARG((png_structp png_ptr,
-   png_bytep buffer, png_size_t length));
+   png_bytep buffer, png_size_t length)) PNG_PRIVATE;
 #endif
 
 PNG_EXTERN void PNGAPI png_default_write_data PNGARG((png_structp png_ptr,
-   png_bytep data, png_size_t length));
+   png_bytep data, png_size_t length)) PNG_PRIVATE;
 
-#if defined(PNG_WRITE_FLUSH_SUPPORTED)
-#if !defined(PNG_NO_STDIO)
-PNG_EXTERN void PNGAPI png_default_flush PNGARG((png_structp png_ptr));
+#ifdef PNG_WRITE_FLUSH_SUPPORTED
+#ifdef PNG_STDIO_SUPPORTED
+PNG_EXTERN void PNGAPI png_default_flush PNGARG((png_structp png_ptr))
+   PNG_PRIVATE;
 #endif
 #endif
 #else /* PNG_1_0_X */
 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
 PNG_EXTERN void png_push_fill_buffer PNGARG((png_structp png_ptr,
-   png_bytep buffer, png_size_t length));
+   png_bytep buffer, png_size_t length)) PNG_PRIVATE;
 #endif
 #endif /* PNG_1_0_X */
 
 /* Reset the CRC variable */
-PNG_EXTERN void png_reset_crc PNGARG((png_structp png_ptr));
+PNG_EXTERN void png_reset_crc PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 
 /* Write the "data" buffer to whatever output you are using. */
 PNG_EXTERN void png_write_data PNGARG((png_structp png_ptr, png_bytep data,
-   png_size_t length));
+   png_size_t length)) PNG_PRIVATE;
 
 /* Read data from whatever input you are using into the "data" buffer */
 PNG_EXTERN void png_read_data PNGARG((png_structp png_ptr, png_bytep data,
-   png_size_t length));
+   png_size_t length)) PNG_PRIVATE;
 
 /* Read bytes into buf, and update png_ptr->crc */
 PNG_EXTERN void png_crc_read PNGARG((png_structp png_ptr, png_bytep buf,
-   png_size_t length));
+   png_size_t length)) PNG_PRIVATE;
 
 /* Decompress data in a chunk that uses compression */
 #if defined(PNG_zTXt_SUPPORTED) || defined(PNG_iTXt_SUPPORTED) || \
     defined(PNG_iCCP_SUPPORTED) || defined(PNG_sPLT_SUPPORTED)
-PNG_EXTERN png_charp png_decompress_chunk PNGARG((png_structp png_ptr,
-   int comp_type, png_charp chunkdata, png_size_t chunklength,
-   png_size_t prefix_length, png_size_t *data_length));
+PNG_EXTERN void png_decompress_chunk PNGARG((png_structp png_ptr,
+   int comp_type, png_size_t chunklength,
+   png_size_t prefix_length, png_size_t *data_length)) PNG_PRIVATE;
 #endif
 
 /* Read "skip" bytes, read the file crc, and (optionally) verify png_ptr->crc */
-PNG_EXTERN int png_crc_finish PNGARG((png_structp png_ptr, png_uint_32 skip));
+PNG_EXTERN int png_crc_finish PNGARG((png_structp png_ptr, png_uint_32 skip)
+   PNG_PRIVATE);
 
 /* Read the CRC from the file and compare it to the libpng calculated CRC */
-PNG_EXTERN int png_crc_error PNGARG((png_structp png_ptr));
+PNG_EXTERN int png_crc_error PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 
 /* Calculate the CRC over a section of data.  Note that we are only
  * passing a maximum of 64K on systems that have this as a memory limit,
  * since this is the maximum buffer size we can specify.
  */
 PNG_EXTERN void png_calculate_crc PNGARG((png_structp png_ptr, png_bytep ptr,
-   png_size_t length));
+   png_size_t length)) PNG_PRIVATE;
 
-#if defined(PNG_WRITE_FLUSH_SUPPORTED)
-PNG_EXTERN void png_flush PNGARG((png_structp png_ptr));
+#ifdef PNG_WRITE_FLUSH_SUPPORTED
+PNG_EXTERN void png_flush PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 #endif
 
-/* simple function to write the signature */
-PNG_EXTERN void png_write_sig PNGARG((png_structp png_ptr));
+/* Simple function to write the signature */
+PNG_EXTERN void png_write_sig PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 
-/* write various chunks */
+/* Write various chunks */
 
 /* Write the IHDR chunk, and update the png_struct with the necessary
  * information.
@@ -3038,481 +2997,498 @@
 PNG_EXTERN void png_write_IHDR PNGARG((png_structp png_ptr, png_uint_32 width,
    png_uint_32 height,
    int bit_depth, int color_type, int compression_method, int filter_method,
-   int interlace_method));
+   int interlace_method)) PNG_PRIVATE;
 
 PNG_EXTERN void png_write_PLTE PNGARG((png_structp png_ptr, png_colorp palette,
-   png_uint_32 num_pal));
+   png_uint_32 num_pal)) PNG_PRIVATE;
 
 PNG_EXTERN void png_write_IDAT PNGARG((png_structp png_ptr, png_bytep data,
-   png_size_t length));
+   png_size_t length)) PNG_PRIVATE;
 
-PNG_EXTERN void png_write_IEND PNGARG((png_structp png_ptr));
+PNG_EXTERN void png_write_IEND PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 
-#if defined(PNG_WRITE_gAMA_SUPPORTED)
+#ifdef PNG_WRITE_gAMA_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_EXTERN void png_write_gAMA PNGARG((png_structp png_ptr, double file_gamma));
+PNG_EXTERN void png_write_gAMA PNGARG((png_structp png_ptr, double file_gamma))
+    PNG_PRIVATE;
 #endif
 #ifdef PNG_FIXED_POINT_SUPPORTED
-PNG_EXTERN void png_write_gAMA_fixed PNGARG((png_structp png_ptr, png_fixed_point
-    file_gamma));
+PNG_EXTERN void png_write_gAMA_fixed PNGARG((png_structp png_ptr,
+    png_fixed_point file_gamma)) PNG_PRIVATE;
 #endif
 #endif
 
-#if defined(PNG_WRITE_sBIT_SUPPORTED)
+#ifdef PNG_WRITE_sBIT_SUPPORTED
 PNG_EXTERN void png_write_sBIT PNGARG((png_structp png_ptr, png_color_8p sbit,
-   int color_type));
+   int color_type)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_cHRM_SUPPORTED)
+#ifdef PNG_WRITE_cHRM_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 PNG_EXTERN void png_write_cHRM PNGARG((png_structp png_ptr,
    double white_x, double white_y,
    double red_x, double red_y, double green_x, double green_y,
-   double blue_x, double blue_y));
+   double blue_x, double blue_y)) PNG_PRIVATE;
 #endif
 #ifdef PNG_FIXED_POINT_SUPPORTED
 PNG_EXTERN void png_write_cHRM_fixed PNGARG((png_structp png_ptr,
    png_fixed_point int_white_x, png_fixed_point int_white_y,
    png_fixed_point int_red_x, png_fixed_point int_red_y, png_fixed_point
    int_green_x, png_fixed_point int_green_y, png_fixed_point int_blue_x,
-   png_fixed_point int_blue_y));
+   png_fixed_point int_blue_y)) PNG_PRIVATE;
 #endif
 #endif
 
-#if defined(PNG_WRITE_sRGB_SUPPORTED)
+#ifdef PNG_WRITE_sRGB_SUPPORTED
 PNG_EXTERN void png_write_sRGB PNGARG((png_structp png_ptr,
-   int intent));
+   int intent)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_iCCP_SUPPORTED)
+#ifdef PNG_WRITE_iCCP_SUPPORTED
 PNG_EXTERN void png_write_iCCP PNGARG((png_structp png_ptr,
    png_charp name, int compression_type,
-   png_charp profile, int proflen));
+   png_charp profile, int proflen)) PNG_PRIVATE;
    /* Note to maintainer: profile should be png_bytep */
 #endif
 
-#if defined(PNG_WRITE_sPLT_SUPPORTED)
+#ifdef PNG_WRITE_sPLT_SUPPORTED
 PNG_EXTERN void png_write_sPLT PNGARG((png_structp png_ptr,
-   png_sPLT_tp palette));
+   png_sPLT_tp palette)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_tRNS_SUPPORTED)
+#ifdef PNG_WRITE_tRNS_SUPPORTED
 PNG_EXTERN void png_write_tRNS PNGARG((png_structp png_ptr, png_bytep trans,
-   png_color_16p values, int number, int color_type));
+   png_color_16p values, int number, int color_type)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_bKGD_SUPPORTED)
+#ifdef PNG_WRITE_bKGD_SUPPORTED
 PNG_EXTERN void png_write_bKGD PNGARG((png_structp png_ptr,
-   png_color_16p values, int color_type));
+   png_color_16p values, int color_type)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_hIST_SUPPORTED)
+#ifdef PNG_WRITE_hIST_SUPPORTED
 PNG_EXTERN void png_write_hIST PNGARG((png_structp png_ptr, png_uint_16p hist,
-   int num_hist));
+   int num_hist)) PNG_PRIVATE;
 #endif
 
 #if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_pCAL_SUPPORTED) || \
     defined(PNG_WRITE_iCCP_SUPPORTED) || defined(PNG_WRITE_sPLT_SUPPORTED)
 PNG_EXTERN png_size_t png_check_keyword PNGARG((png_structp png_ptr,
-   png_charp key, png_charpp new_key));
+   png_charp key, png_charpp new_key)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_tEXt_SUPPORTED)
+#ifdef PNG_WRITE_tEXt_SUPPORTED
 PNG_EXTERN void png_write_tEXt PNGARG((png_structp png_ptr, png_charp key,
-   png_charp text, png_size_t text_len));
+   png_charp text, png_size_t text_len)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_zTXt_SUPPORTED)
+#ifdef PNG_WRITE_zTXt_SUPPORTED
 PNG_EXTERN void png_write_zTXt PNGARG((png_structp png_ptr, png_charp key,
-   png_charp text, png_size_t text_len, int compression));
+   png_charp text, png_size_t text_len, int compression)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_iTXt_SUPPORTED)
+#ifdef PNG_WRITE_iTXt_SUPPORTED
 PNG_EXTERN void png_write_iTXt PNGARG((png_structp png_ptr,
    int compression, png_charp key, png_charp lang, png_charp lang_key,
-   png_charp text));
+   png_charp text)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_TEXT_SUPPORTED)  /* Added at version 1.0.14 and 1.2.4 */
+#ifdef PNG_TEXT_SUPPORTED  /* Added at version 1.0.14 and 1.2.4 */
 PNG_EXTERN int png_set_text_2 PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_textp text_ptr, int num_text));
+   png_infop info_ptr, png_textp text_ptr, int num_text)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_oFFs_SUPPORTED)
+#ifdef PNG_WRITE_oFFs_SUPPORTED
 PNG_EXTERN void png_write_oFFs PNGARG((png_structp png_ptr,
-   png_int_32 x_offset, png_int_32 y_offset, int unit_type));
+   png_int_32 x_offset, png_int_32 y_offset, int unit_type)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_pCAL_SUPPORTED)
+#ifdef PNG_WRITE_pCAL_SUPPORTED
 PNG_EXTERN void png_write_pCAL PNGARG((png_structp png_ptr, png_charp purpose,
    png_int_32 X0, png_int_32 X1, int type, int nparams,
-   png_charp units, png_charpp params));
+   png_charp units, png_charpp params)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_pHYs_SUPPORTED)
+#ifdef PNG_WRITE_pHYs_SUPPORTED
 PNG_EXTERN void png_write_pHYs PNGARG((png_structp png_ptr,
    png_uint_32 x_pixels_per_unit, png_uint_32 y_pixels_per_unit,
-   int unit_type));
+   int unit_type)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_tIME_SUPPORTED)
+#ifdef PNG_WRITE_tIME_SUPPORTED
 PNG_EXTERN void png_write_tIME PNGARG((png_structp png_ptr,
-   png_timep mod_time));
+   png_timep mod_time)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_sCAL_SUPPORTED)
+#ifdef PNG_WRITE_sCAL_SUPPORTED
 #if defined(PNG_FLOATING_POINT_SUPPORTED) && !defined(PNG_NO_STDIO)
 PNG_EXTERN void png_write_sCAL PNGARG((png_structp png_ptr,
-   int unit, double width, double height));
+   int unit, double width, double height)) PNG_PRIVATE;
 #else
 #ifdef PNG_FIXED_POINT_SUPPORTED
 PNG_EXTERN void png_write_sCAL_s PNGARG((png_structp png_ptr,
-   int unit, png_charp width, png_charp height));
+   int unit, png_charp width, png_charp height)) PNG_PRIVATE;
 #endif
 #endif
 #endif
 
 /* Called when finished processing a row of data */
-PNG_EXTERN void png_write_finish_row PNGARG((png_structp png_ptr));
+PNG_EXTERN void png_write_finish_row PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 
 /* Internal use only.   Called before first row of data */
-PNG_EXTERN void png_write_start_row PNGARG((png_structp png_ptr));
+PNG_EXTERN void png_write_start_row PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 
-#if defined(PNG_READ_GAMMA_SUPPORTED)
-PNG_EXTERN void png_build_gamma_table PNGARG((png_structp png_ptr));
+#ifdef PNG_READ_GAMMA_SUPPORTED
+PNG_EXTERN void png_build_gamma_table PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 #endif
 
-/* combine a row of data, dealing with alpha, etc. if requested */
+/* Combine a row of data, dealing with alpha, etc. if requested */
 PNG_EXTERN void png_combine_row PNGARG((png_structp png_ptr, png_bytep row,
-   int mask));
+   int mask)) PNG_PRIVATE;
 
-#if defined(PNG_READ_INTERLACING_SUPPORTED)
-/* expand an interlaced row */
+#ifdef PNG_READ_INTERLACING_SUPPORTED
+/* Expand an interlaced row */
 /* OLD pre-1.0.9 interface:
 PNG_EXTERN void png_do_read_interlace PNGARG((png_row_infop row_info,
-   png_bytep row, int pass, png_uint_32 transformations));
+   png_bytep row, int pass, png_uint_32 transformations)) PNG_PRIVATE;
  */
-PNG_EXTERN void png_do_read_interlace PNGARG((png_structp png_ptr));
+PNG_EXTERN void png_do_read_interlace PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 #endif
 
 /* GRR TO DO (2.0 or whenever):  simplify other internal calling interfaces */
 
-#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
-/* grab pixels out of a row for an interlaced pass */
+#ifdef PNG_WRITE_INTERLACING_SUPPORTED
+/* Grab pixels out of a row for an interlaced pass */
 PNG_EXTERN void png_do_write_interlace PNGARG((png_row_infop row_info,
-   png_bytep row, int pass));
+   png_bytep row, int pass)) PNG_PRIVATE;
 #endif
 
-/* unfilter a row */
+/* Unfilter a row */
 PNG_EXTERN void png_read_filter_row PNGARG((png_structp png_ptr,
-   png_row_infop row_info, png_bytep row, png_bytep prev_row, int filter));
+   png_row_infop row_info, png_bytep row, png_bytep prev_row,
+   int filter)) PNG_PRIVATE;
 
 /* Choose the best filter to use and filter the row data */
 PNG_EXTERN void png_write_find_filter PNGARG((png_structp png_ptr,
-   png_row_infop row_info));
+   png_row_infop row_info)) PNG_PRIVATE;
 
 /* Write out the filtered row. */
 PNG_EXTERN void png_write_filtered_row PNGARG((png_structp png_ptr,
-   png_bytep filtered_row));
-/* finish a row while reading, dealing with interlacing passes, etc. */
+   png_bytep filtered_row)) PNG_PRIVATE;
+/* Finish a row while reading, dealing with interlacing passes, etc. */
 PNG_EXTERN void png_read_finish_row PNGARG((png_structp png_ptr));
 
-/* initialize the row buffers, etc. */
-PNG_EXTERN void png_read_start_row PNGARG((png_structp png_ptr));
-/* optional call to update the users info structure */
+/* Initialize the row buffers, etc. */
+PNG_EXTERN void png_read_start_row PNGARG((png_structp png_ptr)) PNG_PRIVATE;
+/* Optional call to update the users info structure */
 PNG_EXTERN void png_read_transform_info PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
+   png_infop info_ptr)) PNG_PRIVATE;
 
-/* these are the functions that do the transformations */
-#if defined(PNG_READ_FILLER_SUPPORTED)
+/* These are the functions that do the transformations */
+#ifdef PNG_READ_FILLER_SUPPORTED
 PNG_EXTERN void png_do_read_filler PNGARG((png_row_infop row_info,
-   png_bytep row, png_uint_32 filler, png_uint_32 flags));
+   png_bytep row, png_uint_32 filler, png_uint_32 flags)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED)
+#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
 PNG_EXTERN void png_do_read_swap_alpha PNGARG((png_row_infop row_info,
-   png_bytep row));
+   png_bytep row)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
+#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
 PNG_EXTERN void png_do_write_swap_alpha PNGARG((png_row_infop row_info,
-   png_bytep row));
+   png_bytep row)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
+#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
 PNG_EXTERN void png_do_read_invert_alpha PNGARG((png_row_infop row_info,
-   png_bytep row));
+   png_bytep row)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
+#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
 PNG_EXTERN void png_do_write_invert_alpha PNGARG((png_row_infop row_info,
-   png_bytep row));
+   png_bytep row)) PNG_PRIVATE;
 #endif
 
 #if defined(PNG_WRITE_FILLER_SUPPORTED) || \
     defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
 PNG_EXTERN void png_do_strip_filler PNGARG((png_row_infop row_info,
-   png_bytep row, png_uint_32 flags));
+   png_bytep row, png_uint_32 flags)) PNG_PRIVATE;
 #endif
 
 #if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
-PNG_EXTERN void png_do_swap PNGARG((png_row_infop row_info, png_bytep row));
+PNG_EXTERN void png_do_swap PNGARG((png_row_infop row_info,
+    png_bytep row)) PNG_PRIVATE;
 #endif
 
 #if defined(PNG_READ_PACKSWAP_SUPPORTED) || defined(PNG_WRITE_PACKSWAP_SUPPORTED)
-PNG_EXTERN void png_do_packswap PNGARG((png_row_infop row_info, png_bytep row));
+PNG_EXTERN void png_do_packswap PNGARG((png_row_infop row_info,
+    png_bytep row)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
 PNG_EXTERN int png_do_rgb_to_gray PNGARG((png_structp png_ptr, png_row_infop
-   row_info, png_bytep row));
+   row_info, png_bytep row)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
 PNG_EXTERN void png_do_gray_to_rgb PNGARG((png_row_infop row_info,
-   png_bytep row));
+   png_bytep row)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_PACK_SUPPORTED)
-PNG_EXTERN void png_do_unpack PNGARG((png_row_infop row_info, png_bytep row));
+#ifdef PNG_READ_PACK_SUPPORTED
+PNG_EXTERN void png_do_unpack PNGARG((png_row_infop row_info,
+    png_bytep row)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_SHIFT_SUPPORTED)
+#ifdef PNG_READ_SHIFT_SUPPORTED
 PNG_EXTERN void png_do_unshift PNGARG((png_row_infop row_info, png_bytep row,
-   png_color_8p sig_bits));
+   png_color_8p sig_bits)) PNG_PRIVATE;
 #endif
 
 #if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
-PNG_EXTERN void png_do_invert PNGARG((png_row_infop row_info, png_bytep row));
+PNG_EXTERN void png_do_invert PNGARG((png_row_infop row_info,
+    png_bytep row)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_16_TO_8_SUPPORTED)
-PNG_EXTERN void png_do_chop PNGARG((png_row_infop row_info, png_bytep row));
+#ifdef PNG_READ_16_TO_8_SUPPORTED
+PNG_EXTERN void png_do_chop PNGARG((png_row_infop row_info,
+    png_bytep row)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_DITHER_SUPPORTED)
+#ifdef PNG_READ_DITHER_SUPPORTED
 PNG_EXTERN void png_do_dither PNGARG((png_row_infop row_info,
-   png_bytep row, png_bytep palette_lookup, png_bytep dither_lookup));
+   png_bytep row, png_bytep palette_lookup,
+    png_bytep dither_lookup)) PNG_PRIVATE;
 
-#  if defined(PNG_CORRECT_PALETTE_SUPPORTED)
+#  ifdef PNG_CORRECT_PALETTE_SUPPORTED
 PNG_EXTERN void png_correct_palette PNGARG((png_structp png_ptr,
-   png_colorp palette, int num_palette));
+   png_colorp palette, int num_palette)) PNG_PRIVATE;
 #  endif
 #endif
 
 #if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
-PNG_EXTERN void png_do_bgr PNGARG((png_row_infop row_info, png_bytep row));
+PNG_EXTERN void png_do_bgr PNGARG((png_row_infop row_info,
+    png_bytep row)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_PACK_SUPPORTED)
+#ifdef PNG_WRITE_PACK_SUPPORTED
 PNG_EXTERN void png_do_pack PNGARG((png_row_infop row_info,
-   png_bytep row, png_uint_32 bit_depth));
+   png_bytep row, png_uint_32 bit_depth)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_WRITE_SHIFT_SUPPORTED)
+#ifdef PNG_WRITE_SHIFT_SUPPORTED
 PNG_EXTERN void png_do_shift PNGARG((png_row_infop row_info, png_bytep row,
-   png_color_8p bit_depth));
+   png_color_8p bit_depth)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_BACKGROUND_SUPPORTED)
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
+#ifdef PNG_READ_GAMMA_SUPPORTED
 PNG_EXTERN void png_do_background PNGARG((png_row_infop row_info, png_bytep row,
    png_color_16p trans_values, png_color_16p background,
    png_color_16p background_1,
    png_bytep gamma_table, png_bytep gamma_from_1, png_bytep gamma_to_1,
    png_uint_16pp gamma_16, png_uint_16pp gamma_16_from_1,
-   png_uint_16pp gamma_16_to_1, int gamma_shift));
+   png_uint_16pp gamma_16_to_1, int gamma_shift)) PNG_PRIVATE;
 #else
 PNG_EXTERN void png_do_background PNGARG((png_row_infop row_info, png_bytep row,
-   png_color_16p trans_values, png_color_16p background));
+   png_color_16p trans_values, png_color_16p background)) PNG_PRIVATE;
 #endif
 #endif
 
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
 PNG_EXTERN void png_do_gamma PNGARG((png_row_infop row_info, png_bytep row,
    png_bytep gamma_table, png_uint_16pp gamma_16_table,
-   int gamma_shift));
+   int gamma_shift)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_EXPAND_SUPPORTED)
+#ifdef PNG_READ_EXPAND_SUPPORTED
 PNG_EXTERN void png_do_expand_palette PNGARG((png_row_infop row_info,
-   png_bytep row, png_colorp palette, png_bytep trans, int num_trans));
+   png_bytep row, png_colorp palette, png_bytep trans,
+   int num_trans)) PNG_PRIVATE;
 PNG_EXTERN void png_do_expand PNGARG((png_row_infop row_info,
-   png_bytep row, png_color_16p trans_value));
+   png_bytep row, png_color_16p trans_value)) PNG_PRIVATE;
 #endif
 
 /* The following decodes the appropriate chunks, and does error correction,
  * then calls the appropriate callback for the chunk if it is valid.
  */
 
-/* decode the IHDR chunk */
+/* Decode the IHDR chunk */
 PNG_EXTERN void png_handle_IHDR PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 PNG_EXTERN void png_handle_PLTE PNGARG((png_structp png_ptr, png_infop info_ptr,
    png_uint_32 length));
 PNG_EXTERN void png_handle_IEND PNGARG((png_structp png_ptr, png_infop info_ptr,
    png_uint_32 length));
 
-#if defined(PNG_READ_bKGD_SUPPORTED)
+#ifdef PNG_READ_bKGD_SUPPORTED
 PNG_EXTERN void png_handle_bKGD PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_cHRM_SUPPORTED)
+#ifdef PNG_READ_cHRM_SUPPORTED
 PNG_EXTERN void png_handle_cHRM PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_gAMA_SUPPORTED)
+#ifdef PNG_READ_gAMA_SUPPORTED
 PNG_EXTERN void png_handle_gAMA PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_hIST_SUPPORTED)
+#ifdef PNG_READ_hIST_SUPPORTED
 PNG_EXTERN void png_handle_hIST PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_iCCP_SUPPORTED)
+#ifdef PNG_READ_iCCP_SUPPORTED
 extern void png_handle_iCCP PNGARG((png_structp png_ptr, png_infop info_ptr,
    png_uint_32 length));
 #endif /* PNG_READ_iCCP_SUPPORTED */
 
-#if defined(PNG_READ_iTXt_SUPPORTED)
+#ifdef PNG_READ_iTXt_SUPPORTED
 PNG_EXTERN void png_handle_iTXt PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_oFFs_SUPPORTED)
+#ifdef PNG_READ_oFFs_SUPPORTED
 PNG_EXTERN void png_handle_oFFs PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_pCAL_SUPPORTED)
+#ifdef PNG_READ_pCAL_SUPPORTED
 PNG_EXTERN void png_handle_pCAL PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_pHYs_SUPPORTED)
+#ifdef PNG_READ_pHYs_SUPPORTED
 PNG_EXTERN void png_handle_pHYs PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_sBIT_SUPPORTED)
+#ifdef PNG_READ_sBIT_SUPPORTED
 PNG_EXTERN void png_handle_sBIT PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_sCAL_SUPPORTED)
+#ifdef PNG_READ_sCAL_SUPPORTED
 PNG_EXTERN void png_handle_sCAL PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_sPLT_SUPPORTED)
+#ifdef PNG_READ_sPLT_SUPPORTED
 extern void png_handle_sPLT PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif /* PNG_READ_sPLT_SUPPORTED */
 
-#if defined(PNG_READ_sRGB_SUPPORTED)
+#ifdef PNG_READ_sRGB_SUPPORTED
 PNG_EXTERN void png_handle_sRGB PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_tEXt_SUPPORTED)
+#ifdef PNG_READ_tEXt_SUPPORTED
 PNG_EXTERN void png_handle_tEXt PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_tIME_SUPPORTED)
+#ifdef PNG_READ_tIME_SUPPORTED
 PNG_EXTERN void png_handle_tIME PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_tRNS_SUPPORTED)
+#ifdef PNG_READ_tRNS_SUPPORTED
 PNG_EXTERN void png_handle_tRNS PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_READ_zTXt_SUPPORTED)
+#ifdef PNG_READ_zTXt_SUPPORTED
 PNG_EXTERN void png_handle_zTXt PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
+   png_uint_32 length)) PNG_PRIVATE;
 #endif
 
 PNG_EXTERN void png_handle_unknown PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 length));
+   png_infop info_ptr, png_uint_32 length)) PNG_PRIVATE;
 
 PNG_EXTERN void png_check_chunk_name PNGARG((png_structp png_ptr,
-   png_bytep chunk_name));
+   png_bytep chunk_name)) PNG_PRIVATE;
 
-/* handle the transformations for reading and writing */
-PNG_EXTERN void png_do_read_transformations PNGARG((png_structp png_ptr));
-PNG_EXTERN void png_do_write_transformations PNGARG((png_structp png_ptr));
+/* Handle the transformations for reading and writing */
+PNG_EXTERN void png_do_read_transformations
+   PNGARG((png_structp png_ptr)) PNG_PRIVATE;
+PNG_EXTERN void png_do_write_transformations
+   PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 
-PNG_EXTERN void png_init_read_transformations PNGARG((png_structp png_ptr));
+PNG_EXTERN void png_init_read_transformations
+   PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 
 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
 PNG_EXTERN void png_push_read_chunk PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
+   png_infop info_ptr)) PNG_PRIVATE;
 PNG_EXTERN void png_push_read_sig PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-PNG_EXTERN void png_push_check_crc PNGARG((png_structp png_ptr));
+   png_infop info_ptr)) PNG_PRIVATE;
+PNG_EXTERN void png_push_check_crc PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 PNG_EXTERN void png_push_crc_skip PNGARG((png_structp png_ptr,
-   png_uint_32 length));
-PNG_EXTERN void png_push_crc_finish PNGARG((png_structp png_ptr));
-PNG_EXTERN void png_push_save_buffer PNGARG((png_structp png_ptr));
+   png_uint_32 length)) PNG_PRIVATE;
+PNG_EXTERN void png_push_crc_finish PNGARG((png_structp png_ptr)) PNG_PRIVATE;
+PNG_EXTERN void png_push_save_buffer PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 PNG_EXTERN void png_push_restore_buffer PNGARG((png_structp png_ptr,
-   png_bytep buffer, png_size_t buffer_length));
-PNG_EXTERN void png_push_read_IDAT PNGARG((png_structp png_ptr));
+   png_bytep buffer, png_size_t buffer_length)) PNG_PRIVATE;
+PNG_EXTERN void png_push_read_IDAT PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 PNG_EXTERN void png_process_IDAT_data PNGARG((png_structp png_ptr,
-   png_bytep buffer, png_size_t buffer_length));
-PNG_EXTERN void png_push_process_row PNGARG((png_structp png_ptr));
+   png_bytep buffer, png_size_t buffer_length)) PNG_PRIVATE;
+PNG_EXTERN void png_push_process_row PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 PNG_EXTERN void png_push_handle_unknown PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 length));
+   png_infop info_ptr, png_uint_32 length)) PNG_PRIVATE;
 PNG_EXTERN void png_push_have_info PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
+   png_infop info_ptr)) PNG_PRIVATE;
 PNG_EXTERN void png_push_have_end PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-PNG_EXTERN void png_push_have_row PNGARG((png_structp png_ptr, png_bytep row));
+   png_infop info_ptr)) PNG_PRIVATE;
+PNG_EXTERN void png_push_have_row PNGARG((png_structp png_ptr,
+   png_bytep row)) PNG_PRIVATE;
 PNG_EXTERN void png_push_read_end PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
+   png_infop info_ptr)) PNG_PRIVATE;
 PNG_EXTERN void png_process_some_data PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-PNG_EXTERN void png_read_push_finish_row PNGARG((png_structp png_ptr));
-#if defined(PNG_READ_tEXt_SUPPORTED)
+   png_infop info_ptr)) PNG_PRIVATE;
+PNG_EXTERN void png_read_push_finish_row
+   PNGARG((png_structp png_ptr)) PNG_PRIVATE;
+#ifdef PNG_READ_tEXt_SUPPORTED
 PNG_EXTERN void png_push_handle_tEXt PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 length));
+   png_infop info_ptr, png_uint_32 length)) PNG_PRIVATE;
 PNG_EXTERN void png_push_read_tEXt PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
+   png_infop info_ptr)) PNG_PRIVATE;
 #endif
-#if defined(PNG_READ_zTXt_SUPPORTED)
+#ifdef PNG_READ_zTXt_SUPPORTED
 PNG_EXTERN void png_push_handle_zTXt PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 length));
+   png_infop info_ptr, png_uint_32 length)) PNG_PRIVATE;
 PNG_EXTERN void png_push_read_zTXt PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
+   png_infop info_ptr)) PNG_PRIVATE;
 #endif
-#if defined(PNG_READ_iTXt_SUPPORTED)
+#ifdef PNG_READ_iTXt_SUPPORTED
 PNG_EXTERN void png_push_handle_iTXt PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 length));
+   png_infop info_ptr, png_uint_32 length)) PNG_PRIVATE;
 PNG_EXTERN void png_push_read_iTXt PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
+   png_infop info_ptr)) PNG_PRIVATE;
 #endif
 
 #endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
 
 #ifdef PNG_MNG_FEATURES_SUPPORTED
 PNG_EXTERN void png_do_read_intrapixel PNGARG((png_row_infop row_info,
-   png_bytep row));
+   png_bytep row)) PNG_PRIVATE;
 PNG_EXTERN void png_do_write_intrapixel PNGARG((png_row_infop row_info,
-   png_bytep row));
+   png_bytep row)) PNG_PRIVATE;
 #endif
 
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
-#if defined(PNG_MMX_CODE_SUPPORTED)
+#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
+#ifdef PNG_MMX_CODE_SUPPORTED
 /* png.c */ /* PRIVATE */
-PNG_EXTERN void png_init_mmx_flags PNGARG((png_structp png_ptr));
+PNG_EXTERN void png_init_mmx_flags PNGARG((png_structp png_ptr)) PNG_PRIVATE;
 #endif
 #endif
 
+
+/* The following six functions will be exported in libpng-1.4.0. */
 #if defined(PNG_INCH_CONVERSIONS) && defined(PNG_FLOATING_POINT_SUPPORTED)
 PNG_EXTERN png_uint_32 png_get_pixels_per_inch PNGARG((png_structp png_ptr,
 png_infop info_ptr));
@@ -3529,12 +3505,43 @@
 PNG_EXTERN float png_get_y_offset_inches PNGARG((png_structp png_ptr,
 png_infop info_ptr));
 
-#if defined(PNG_pHYs_SUPPORTED)
+#ifdef PNG_pHYs_SUPPORTED
 PNG_EXTERN png_uint_32 png_get_pHYs_dpi PNGARG((png_structp png_ptr,
 png_infop info_ptr, png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type));
 #endif /* PNG_pHYs_SUPPORTED */
 #endif  /* PNG_INCH_CONVERSIONS && PNG_FLOATING_POINT_SUPPORTED */
 
+/* Read the chunk header (length + type name) */
+PNG_EXTERN png_uint_32 png_read_chunk_header
+   PNGARG((png_structp png_ptr)) PNG_PRIVATE;
+
+/* Added at libpng version 1.2.34 */
+#ifdef PNG_cHRM_SUPPORTED
+PNG_EXTERN int png_check_cHRM_fixed PNGARG((png_structp png_ptr,
+   png_fixed_point int_white_x, png_fixed_point int_white_y,
+   png_fixed_point int_red_x, png_fixed_point int_red_y, png_fixed_point
+   int_green_x, png_fixed_point int_green_y, png_fixed_point int_blue_x,
+   png_fixed_point int_blue_y)) PNG_PRIVATE;
+#endif
+
+#ifdef PNG_cHRM_SUPPORTED
+#ifdef PNG_CHECK_cHRM_SUPPORTED
+/* Added at libpng version 1.2.34 */
+PNG_EXTERN void png_64bit_product PNGARG((long v1, long v2,
+   unsigned long *hi_product, unsigned long *lo_product)) PNG_PRIVATE;
+#endif
+#endif
+
+/* Added at libpng version 1.2.41 */
+PNG_EXTERN void png_check_IHDR PNGARG((png_structp png_ptr,
+   png_uint_32 width, png_uint_32 height, int bit_depth,
+   int color_type, int interlace_type, int compression_type,
+   int filter_type)) PNG_PRIVATE;
+
+/* Added at libpng version 1.2.41 */
+PNG_EXTERN png_voidp png_calloc PNGARG((png_structp png_ptr,
+   png_uint_32 size));
+
 /* Maintainer: Put new private prototypes here ^ and in libpngpf.3 */
 
 #endif /* PNG_INTERNAL */
@@ -3544,5 +3551,5 @@
 #endif
 
 #endif /* PNG_VERSION_INFO_ONLY */
-/* do not put anything past this line */
+/* Do not put anything past this line */
 #endif /* PNG_H */
diff -Naur libAfterImage-1.20/libpng/pngconf.h root/graf2d/asimage/src/libAfterImage/libpng/pngconf.h
--- libAfterImage-1.20/libpng/pngconf.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngconf.h	2018-12-08 08:18:38.000000000 +0100
@@ -1,14 +1,17 @@
 
 /* pngconf.h - machine configurable file for libpng
  *
- * libpng version 1.2.23 - November 6, 2007
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * libpng version 1.2.55, December 3, 2015
+ *
+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- */
-
-/* Any machine specific code is near the front of this file, so if you
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
+ * Any machine specific code is near the front of this file, so if you
  * are configuring libpng for a machine, you may want to read the section
  * starting here down to where it starts to typedef png_color, png_text,
  * and png_info.
@@ -19,7 +22,7 @@
 
 #define PNG_1_2_X
 
-/* 
+/*
  * PNG_USER_CONFIG has to be defined on the compiler command line. This
  * includes the resource compiler for Windows DLL configurations.
  */
@@ -39,7 +42,7 @@
 
 /*
  * Added at libpng-1.2.8
- *  
+ *
  * If you create a private DLL you need to define in "pngusr.h" the followings:
  * #define PNG_USER_PRIVATEBUILD <Describes by whom and why this version of
  *        the DLL was built>
@@ -50,8 +53,8 @@
  *        number and must match your private DLL name>
  *  e.g. // private DLL "libpng13gx.dll"
  *       #define PNG_USER_DLLFNAME_POSTFIX "gx"
- * 
- * The following macros are also at your disposal if you want to complete the 
+ *
+ * The following macros are also at your disposal if you want to complete the
  * DLL VERSIONINFO structure.
  * - PNG_USER_VERSIONINFO_COMMENTS
  * - PNG_USER_VERSIONINFO_COMPANYNAME
@@ -83,6 +86,18 @@
 #endif
 /* End of material added at libpng-1.2.19/1.2.21 */
 
+/* Added at libpng-1.2.51 (ported from 1.4.6) */
+#ifndef PNG_UNUSED
+/* Unused formal parameter warnings are silenced using the following macro
+ * which is expected to have no bad effects on performance (optimizing
+ * compilers will probably remove it entirely).  Note that if you replace
+ * it with something other than whitespace, you must include the terminating
+ * semicolon.
+ */
+#  define PNG_UNUSED(param) (void)param;
+#endif
+/* End of material added to libpng-1.4.6 */
+
 /* This is the size of the compression buffer, and thus the size of
  * an IDAT chunk.  Make this whatever size you feel is best for your
  * machine.  One of these will be allocated per png_struct.  When this
@@ -112,8 +127,33 @@
 #  define PNG_WRITE_SUPPORTED
 #endif
 
+/* Enabled in 1.2.41. */
+#ifdef PNG_ALLOW_BENIGN_ERRORS
+#  define png_benign_error png_warning
+#  define png_chunk_benign_error png_chunk_warning
+#else
+#  ifndef PNG_BENIGN_ERRORS_SUPPORTED
+#    define png_benign_error png_error
+#    define png_chunk_benign_error png_chunk_error
+#  endif
+#endif
+
+/* Added in libpng-1.2.41 */
+#if !defined(PNG_NO_WARNINGS) && !defined(PNG_WARNINGS_SUPPORTED)
+#  define PNG_WARNINGS_SUPPORTED
+#endif
+
+#if !defined(PNG_NO_ERROR_TEXT) && !defined(PNG_ERROR_TEXT_SUPPORTED)
+#  define PNG_ERROR_TEXT_SUPPORTED
+#endif
+
+#if !defined(PNG_NO_CHECK_cHRM) && !defined(PNG_CHECK_cHRM_SUPPORTED)
+#  define PNG_CHECK_cHRM_SUPPORTED
+#endif
+
 /* Enabled by default in 1.2.0.  You can disable this if you don't need to
-   support PNGs that are embedded in MNG datastreams */
+ * support PNGs that are embedded in MNG datastreams
+ */
 #if !defined(PNG_1_0_X) && !defined(PNG_NO_MNG_FEATURES)
 #  ifndef PNG_MNG_FEATURES_SUPPORTED
 #    define PNG_MNG_FEATURES_SUPPORTED
@@ -147,9 +187,9 @@
  * 'Cygwin' defines/defaults:
  *   PNG_BUILD_DLL -- (ignored) building the dll
  *   (no define)   -- (ignored) building an application, linking to the dll
- *   PNG_STATIC    -- (ignored) building the static lib, or building an 
+ *   PNG_STATIC    -- (ignored) building the static lib, or building an
  *                    application that links to the static lib.
- *   ALL_STATIC    -- (ignored) building various static libs, or building an 
+ *   ALL_STATIC    -- (ignored) building various static libs, or building an
  *                    application that links to the static libs.
  * Thus,
  * a cygwin user should define either PNG_BUILD_DLL or PNG_STATIC, and
@@ -162,57 +202,57 @@
  *   PNG_BUILD_DLL
  *   PNG_STATIC
  *   (nothing) == PNG_USE_DLL
- * 
+ *
  * CYGWIN (2002-01-20): The preceding is now obsolete. With the advent
- *   of auto-import in binutils, we no longer need to worry about 
+ *   of auto-import in binutils, we no longer need to worry about
  *   __declspec(dllexport) / __declspec(dllimport) and friends.  Therefore,
  *   we don't need to worry about PNG_STATIC or ALL_STATIC when it comes
- *   to __declspec() stuff.  However, we DO need to worry about 
+ *   to __declspec() stuff.  However, we DO need to worry about
  *   PNG_BUILD_DLL and PNG_STATIC because those change some defaults
  *   such as CONSOLE_IO and whether GLOBAL_ARRAYS are allowed.
  */
-#if defined(__CYGWIN__)
-#  if defined(ALL_STATIC)
-#    if defined(PNG_BUILD_DLL)
+#ifdef __CYGWIN__
+#  ifdef ALL_STATIC
+#    ifdef PNG_BUILD_DLL
 #      undef PNG_BUILD_DLL
 #    endif
-#    if defined(PNG_USE_DLL)
+#    ifdef PNG_USE_DLL
 #      undef PNG_USE_DLL
 #    endif
-#    if defined(PNG_DLL)
+#    ifdef PNG_DLL
 #      undef PNG_DLL
 #    endif
-#    if !defined(PNG_STATIC)
+#    ifndef PNG_STATIC
 #      define PNG_STATIC
 #    endif
 #  else
-#    if defined (PNG_BUILD_DLL)
-#      if defined(PNG_STATIC)
+#    ifdef PNG_BUILD_DLL
+#      ifdef PNG_STATIC
 #        undef PNG_STATIC
 #      endif
-#      if defined(PNG_USE_DLL)
+#      ifdef PNG_USE_DLL
 #        undef PNG_USE_DLL
 #      endif
-#      if !defined(PNG_DLL)
+#      ifndef PNG_DLL
 #        define PNG_DLL
 #      endif
 #    else
-#      if defined(PNG_STATIC)
-#        if defined(PNG_USE_DLL)
+#      ifdef PNG_STATIC
+#        ifdef PNG_USE_DLL
 #          undef PNG_USE_DLL
 #        endif
-#        if defined(PNG_DLL)
+#        ifdef PNG_DLL
 #          undef PNG_DLL
 #        endif
 #      else
-#        if !defined(PNG_USE_DLL)
+#        ifndef PNG_USE_DLL
 #          define PNG_USE_DLL
 #        endif
-#        if !defined(PNG_DLL)
+#        ifndef PNG_DLL
 #          define PNG_DLL
 #        endif
-#      endif  
-#    endif  
+#      endif
+#    endif
 #  endif
 #endif
 
@@ -229,10 +269,16 @@
  * #define PNG_NO_STDIO
  */
 
-#if defined(_WIN32_WCE)
+#if !defined(PNG_NO_STDIO) && !defined(PNG_STDIO_SUPPORTED)
+#  define PNG_STDIO_SUPPORTED
+#endif
+
+#ifdef _WIN32_WCE
 #  include <windows.h>
    /* Console I/O functions are not supported on WindowsCE */
 #  define PNG_NO_CONSOLE_IO
+   /* abort() may not be supported on some/all Windows CE platforms */
+#  define PNG_ABORT() exit(-1)
 #  ifdef PNG_DEBUG
 #    undef PNG_DEBUG
 #  endif
@@ -256,12 +302,16 @@
 #      endif
 #    endif
 #  else
-#    if !defined(_WIN32_WCE)
+#    ifndef _WIN32_WCE
 /* "stdio.h" functions are not supported on WindowsCE */
 #      include <stdio.h>
 #    endif
 #  endif
 
+#if !(defined PNG_NO_CONSOLE_IO) && !defined(PNG_CONSOLE_IO_SUPPORTED)
+#  define PNG_CONSOLE_IO_SUPPORTED
+#endif
+
 /* This macro protects us against machines that don't have function
  * prototypes (ie K&R style headers).  If your compiler does not handle
  * function prototypes, define this macro and use the included ansi2knr.
@@ -312,28 +362,38 @@
 #ifdef PNG_SETJMP_SUPPORTED
 /* This is an attempt to force a single setjmp behaviour on Linux.  If
  * the X config stuff didn't define _BSD_SOURCE we wouldn't need this.
+ *
+ * You can bypass this test if you know that your application uses exactly
+ * the same setjmp.h that was included when libpng was built.  Only define
+ * PNG_SKIP_SETJMP_CHECK while building your application, prior to the
+ * application's '#include "png.h"'. Don't define PNG_SKIP_SETJMP_CHECK
+ * while building a separate libpng library for general use.
  */
 
-#  ifdef __linux__
-#    ifdef _BSD_SOURCE
-#      define PNG_SAVE_BSD_SOURCE
-#      undef _BSD_SOURCE
-#    endif
-#    ifdef _SETJMP_H
-     /* If you encounter a compiler error here, see the explanation
-      * near the end of INSTALL.
-      */
-         __png.h__ already includes setjmp.h;
-         __dont__ include it again.;
-#    endif
-#  endif /* __linux__ */
+#  ifndef PNG_SKIP_SETJMP_CHECK
+#    ifdef __linux__
+#      ifdef _BSD_SOURCE
+#        define PNG_SAVE_BSD_SOURCE
+#        undef _BSD_SOURCE
+#      endif
+#      ifdef _SETJMP_H
+       /* If you encounter a compiler error here, see the explanation
+        * near the end of INSTALL.
+        */
+           __pngconf.h__ in libpng already includes setjmp.h;
+           __dont__ include it again.;
+#      endif
+#    endif /* __linux__ */
+#  endif /* PNG_SKIP_SETJMP_CHECK */
 
    /* include setjmp.h for error handling */
 #  include <setjmp.h>
 
 #  ifdef __linux__
 #    ifdef PNG_SAVE_BSD_SOURCE
-#      define _BSD_SOURCE
+#      ifndef _BSD_SOURCE
+#        define _BSD_SOURCE
+#      endif
 #      undef PNG_SAVE_BSD_SOURCE
 #    endif
 #  endif /* __linux__ */
@@ -363,8 +423,8 @@
  * them inside an appropriate ifdef/endif pair for portability.
  */
 
-#if defined(PNG_FLOATING_POINT_SUPPORTED)
-#  if defined(MACOS)
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+#  ifdef MACOS
      /* We need to check that <math.h> hasn't already been included earlier
       * as it seems it doesn't agree with <fp.h>, yet we should really use
       * <fp.h> if possible.
@@ -475,7 +535,7 @@
  * iTXt support was added.  iTXt support was turned off by default through
  * libpng-1.2.x, to support old apps that malloc the png_text structure
  * instead of calling png_set_text() and letting libpng malloc it.  It
- * was turned on by default in libpng-1.3.0.
+ * will be turned on by default in libpng-1.4.0.
  */
 
 #if defined(PNG_1_0_X) || defined (PNG_1_2_X)
@@ -509,6 +569,7 @@
 #  define PNG_NO_FREE_ME
 #  define PNG_NO_READ_UNKNOWN_CHUNKS
 #  define PNG_NO_WRITE_UNKNOWN_CHUNKS
+#  define PNG_NO_HANDLE_AS_UNKNOWN
 #  define PNG_NO_READ_USER_CHUNKS
 #  define PNG_NO_READ_iCCP
 #  define PNG_NO_WRITE_iCCP
@@ -538,7 +599,7 @@
 #  define PNG_FREE_ME_SUPPORTED
 #endif
 
-#if defined(PNG_READ_SUPPORTED)
+#ifdef PNG_READ_SUPPORTED
 
 #if !defined(PNG_READ_TRANSFORMS_NOT_SUPPORTED) && \
       !defined(PNG_NO_READ_TRANSFORMS)
@@ -602,11 +663,20 @@
 #  endif
 #endif /* PNG_READ_TRANSFORMS_SUPPORTED */
 
+/* PNG_PROGRESSIVE_READ_NOT_SUPPORTED is deprecated. */
 #if !defined(PNG_NO_PROGRESSIVE_READ) && \
- !defined(PNG_PROGRESSIVE_READ_SUPPORTED) /* if you don't do progressive   */
-#  define PNG_PROGRESSIVE_READ_SUPPORTED  /* reading.  This is not talking */
-#endif                            /* about interlacing capability!  You'll */
-           /* still have interlacing unless you change the following line: */
+ !defined(PNG_PROGRESSIVE_READ_NOT_SUPPORTED)  /* if you don't do progressive */
+#  define PNG_PROGRESSIVE_READ_SUPPORTED     /* reading.  This is not talking */
+#endif                               /* about interlacing capability!  You'll */
+            /* still have interlacing unless you change the following define: */
+#define PNG_READ_INTERLACING_SUPPORTED /* required for PNG-compliant decoders */
+
+/* PNG_NO_SEQUENTIAL_READ_SUPPORTED is deprecated. */
+#if !defined(PNG_NO_SEQUENTIAL_READ) && \
+    !defined(PNG_SEQUENTIAL_READ_SUPPORTED) && \
+    !defined(PNG_NO_SEQUENTIAL_READ_SUPPORTED)
+#  define PNG_SEQUENTIAL_READ_SUPPORTED
+#endif
 
 #define PNG_READ_INTERLACING_SUPPORTED /* required in PNG-compliant decoders */
 
@@ -626,7 +696,7 @@
 
 #endif /* PNG_READ_SUPPORTED */
 
-#if defined(PNG_WRITE_SUPPORTED)
+#ifdef PNG_WRITE_SUPPORTED
 
 # if !defined(PNG_WRITE_TRANSFORMS_NOT_SUPPORTED) && \
     !defined(PNG_NO_WRITE_TRANSFORMS)
@@ -658,9 +728,11 @@
 #  ifndef PNG_NO_WRITE_SWAP_ALPHA
 #    define PNG_WRITE_SWAP_ALPHA_SUPPORTED
 #  endif
+#ifndef PNG_1_0_X
 #  ifndef PNG_NO_WRITE_INVERT_ALPHA
 #    define PNG_WRITE_INVERT_ALPHA_SUPPORTED
 #  endif
+#endif
 #  ifndef PNG_NO_WRITE_USER_TRANSFORM
 #    define PNG_WRITE_USER_TRANSFORM_SUPPORTED
 #  endif
@@ -729,7 +801,7 @@
 #  define PNG_EASY_ACCESS_SUPPORTED
 #endif
 
-/* PNG_ASSEMBLER_CODE was enabled by default in version 1.2.0 
+/* PNG_ASSEMBLER_CODE was enabled by default in version 1.2.0
  * and removed from version 1.2.20.  The following will be removed
  * from libpng-1.4.0
 */
@@ -752,7 +824,7 @@
 #    endif
 #  endif
 
-#  if defined(__APPLE__)
+#  ifdef __APPLE__
 #    if !defined(PNG_MMX_CODE_SUPPORTED) && !defined(PNG_NO_MMX_CODE)
 #      define PNG_NO_MMX_CODE
 #    endif
@@ -771,21 +843,29 @@
 #endif
 /* end of obsolete code to be removed from libpng-1.4.0 */
 
-#if !defined(PNG_1_0_X)
+/* Added at libpng-1.2.0 */
+#ifndef PNG_1_0_X
 #if !defined(PNG_NO_USER_MEM) && !defined(PNG_USER_MEM_SUPPORTED)
 #  define PNG_USER_MEM_SUPPORTED
 #endif
 #endif /* PNG_1_0_X */
 
 /* Added at libpng-1.2.6 */
-#if !defined(PNG_1_0_X)
-#ifndef PNG_SET_USER_LIMITS_SUPPORTED
-#if !defined(PNG_NO_SET_USER_LIMITS) && !defined(PNG_SET_USER_LIMITS_SUPPORTED)
-#  define PNG_SET_USER_LIMITS_SUPPORTED
-#endif
-#endif
+#ifndef PNG_1_0_X
+#  ifndef PNG_SET_USER_LIMITS_SUPPORTED
+#    ifndef PNG_NO_SET_USER_LIMITS
+#      define PNG_SET_USER_LIMITS_SUPPORTED
+#    endif
+#  endif
 #endif /* PNG_1_0_X */
 
+/* Added at libpng-1.0.53 and 1.2.43 */
+#ifndef PNG_USER_LIMITS_SUPPORTED
+#  ifndef PNG_NO_USER_LIMITS
+#    define PNG_USER_LIMITS_SUPPORTED
+#  endif
+#endif
+
 /* Added at libpng-1.0.16 and 1.2.6.  To accept all valid PNGS no matter
  * how large, set these limits to 0x7fffffffL
  */
@@ -796,6 +876,33 @@
 #  define PNG_USER_HEIGHT_MAX 1000000L
 #endif
 
+/* Added at libpng-1.2.43.  To accept all valid PNGs no matter
+ * how large, set these two limits to 0.
+ */
+#ifndef PNG_USER_CHUNK_CACHE_MAX
+#  define PNG_USER_CHUNK_CACHE_MAX 32765
+#endif
+
+/* Added at libpng-1.2.43 */
+#ifndef PNG_USER_CHUNK_MALLOC_MAX
+#  define PNG_USER_CHUNK_MALLOC_MAX 8000000
+#endif
+
+#ifndef PNG_LITERAL_SHARP
+#  define PNG_LITERAL_SHARP 0x23
+#endif
+#ifndef PNG_LITERAL_LEFT_SQUARE_BRACKET
+#  define PNG_LITERAL_LEFT_SQUARE_BRACKET 0x5b
+#endif
+#ifndef PNG_LITERAL_RIGHT_SQUARE_BRACKET
+#  define PNG_LITERAL_RIGHT_SQUARE_BRACKET 0x5d
+#endif
+
+/* Added at libpng-1.2.34 */
+#ifndef PNG_STRING_NEWLINE
+#define PNG_STRING_NEWLINE "\n"
+#endif
+
 /* These are currently experimental features, define them if you want */
 
 /* very little testing */
@@ -820,6 +927,11 @@
 #define PNG_NO_POINTER_INDEXING
 */
 
+#if !defined(PNG_NO_POINTER_INDEXING) && \
+    !defined(PNG_POINTER_INDEXING_SUPPORTED)
+#  define PNG_POINTER_INDEXING_SUPPORTED
+#endif
+
 /* These functions are turned off by default, as they will be phased out. */
 /*
 #define  PNG_USELESS_TESTS_SUPPORTED
@@ -923,14 +1035,22 @@
 #  define PNG_READ_zTXt_SUPPORTED
 #  define PNG_zTXt_SUPPORTED
 #endif
+#ifndef PNG_NO_READ_OPT_PLTE
+#  define PNG_READ_OPT_PLTE_SUPPORTED /* only affects support of the */
+#endif                      /* optional PLTE chunk in RGB and RGBA images */
+#if defined(PNG_READ_iTXt_SUPPORTED) || defined(PNG_READ_tEXt_SUPPORTED) || \
+    defined(PNG_READ_zTXt_SUPPORTED)
+#  define PNG_READ_TEXT_SUPPORTED
+#  define PNG_TEXT_SUPPORTED
+#endif
+
+#endif /* PNG_READ_ANCILLARY_CHUNKS_SUPPORTED */
+
 #ifndef PNG_NO_READ_UNKNOWN_CHUNKS
 #  define PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
 #  ifndef PNG_UNKNOWN_CHUNKS_SUPPORTED
 #    define PNG_UNKNOWN_CHUNKS_SUPPORTED
 #  endif
-#  ifndef PNG_NO_HANDLE_AS_UNKNOWN
-#    define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-#  endif
 #endif
 #if !defined(PNG_NO_READ_USER_CHUNKS) && \
      defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
@@ -943,17 +1063,14 @@
 #    undef PNG_NO_HANDLE_AS_UNKNOWN
 #  endif
 #endif
-#ifndef PNG_NO_READ_OPT_PLTE
-#  define PNG_READ_OPT_PLTE_SUPPORTED /* only affects support of the */
-#endif                      /* optional PLTE chunk in RGB and RGBA images */
-#if defined(PNG_READ_iTXt_SUPPORTED) || defined(PNG_READ_tEXt_SUPPORTED) || \
-    defined(PNG_READ_zTXt_SUPPORTED)
-#  define PNG_READ_TEXT_SUPPORTED
-#  define PNG_TEXT_SUPPORTED
-#endif
 
-#endif /* PNG_READ_ANCILLARY_CHUNKS_SUPPORTED */
+#ifndef PNG_NO_HANDLE_AS_UNKNOWN
+#  ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+#    define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+#  endif
+#endif
 
+#ifdef PNG_WRITE_SUPPORTED
 #ifdef PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED
 
 #ifdef PNG_NO_WRITE_TEXT
@@ -1065,17 +1182,6 @@
 #    define PNG_zTXt_SUPPORTED
 #  endif
 #endif
-#ifndef PNG_NO_WRITE_UNKNOWN_CHUNKS
-#  define PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-#  ifndef PNG_UNKNOWN_CHUNKS_SUPPORTED
-#    define PNG_UNKNOWN_CHUNKS_SUPPORTED
-#  endif
-#  ifndef PNG_NO_HANDLE_AS_UNKNOWN
-#     ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-#       define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-#     endif
-#  endif
-#endif
 #if defined(PNG_WRITE_iTXt_SUPPORTED) || defined(PNG_WRITE_tEXt_SUPPORTED) || \
     defined(PNG_WRITE_zTXt_SUPPORTED)
 #  define PNG_WRITE_TEXT_SUPPORTED
@@ -1084,8 +1190,37 @@
 #  endif
 #endif
 
+#ifdef PNG_WRITE_tIME_SUPPORTED
+#  ifndef PNG_NO_CONVERT_tIME
+#    ifndef _WIN32_WCE
+/*   The "tm" structure is not supported on WindowsCE */
+#      ifndef PNG_CONVERT_tIME_SUPPORTED
+#        define PNG_CONVERT_tIME_SUPPORTED
+#      endif
+#   endif
+#  endif
+#endif
+
 #endif /* PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED */
 
+#if !defined(PNG_NO_WRITE_FILTER) && !defined(PNG_WRITE_FILTER_SUPPORTED)
+#  define PNG_WRITE_FILTER_SUPPORTED
+#endif
+
+#ifndef PNG_NO_WRITE_UNKNOWN_CHUNKS
+#  define PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
+#  ifndef PNG_UNKNOWN_CHUNKS_SUPPORTED
+#    define PNG_UNKNOWN_CHUNKS_SUPPORTED
+#  endif
+#endif
+
+#ifndef PNG_NO_HANDLE_AS_UNKNOWN
+#  ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+#    define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+#  endif
+#endif
+#endif /* PNG_WRITE_SUPPORTED */
+
 /* Turn this off to disable png_read_png() and
  * png_write_png() and leave the row_pointers member
  * out of the info structure.
@@ -1094,12 +1229,10 @@
 #  define PNG_INFO_IMAGE_SUPPORTED
 #endif
 
-/* need the time information for reading tIME chunks */
-#if defined(PNG_tIME_SUPPORTED)
-#  if !defined(_WIN32_WCE)
+/* Need the time information for converting tIME chunks */
+#ifdef PNG_CONVERT_tIME_SUPPORTED
      /* "time.h" functions are not supported on WindowsCE */
 #    include <time.h>
-#  endif
 #endif
 
 /* Some typedefs to get us started.  These should be safe on most of the
@@ -1121,10 +1254,10 @@
    change (I'm not sure if you will or not, so I thought I'd be safe) */
 #ifdef PNG_SIZE_T
    typedef PNG_SIZE_T png_size_t;
-#  define png_sizeof(x) png_convert_size(sizeof (x))
+#  define png_sizeof(x) png_convert_size(sizeof(x))
 #else
    typedef size_t png_size_t;
-#  define png_sizeof(x) sizeof (x)
+#  define png_sizeof(x) sizeof(x)
 #endif
 
 /* The following is needed for medium model support.  It cannot be in the
@@ -1168,8 +1301,8 @@
  */
 
 /* MSC Medium model */
-#if defined(FAR)
-#  if defined(M_I86MM)
+#ifdef FAR
+#  ifdef M_I86MM
 #    define USE_FAR_KEYWORD
 #    define FARDATA FAR
 #    include <dos.h>
@@ -1202,7 +1335,7 @@
 typedef png_fixed_point FAR * png_fixed_point_p;
 
 #ifndef PNG_NO_STDIO
-#if defined(_WIN32_WCE)
+#ifdef _WIN32_WCE
 typedef HANDLE                png_FILE_p;
 #else
 typedef FILE                * png_FILE_p;
@@ -1231,7 +1364,7 @@
 
 #if defined(PNG_1_0_X) || defined(PNG_1_2_X)
 /* SPC -  Is this stuff deprecated? */
-/* It'll be removed as of libpng-1.3.0 - GR-P */
+/* It'll be removed as of libpng-1.4.0 - GR-P */
 /* libpng typedefs for types in zlib. If zlib changes
  * or another compression library is used, then change these.
  * Eliminates need to change all the source files.
@@ -1266,17 +1399,17 @@
  * When building a static lib, default to no GLOBAL ARRAYS, but allow
  * command-line override
  */
-#if defined(__CYGWIN__)
-#  if !defined(PNG_STATIC)
-#    if defined(PNG_USE_GLOBAL_ARRAYS)
+#ifdef __CYGWIN__
+#  ifndef PNG_STATIC
+#    ifdef PNG_USE_GLOBAL_ARRAYS
 #      undef PNG_USE_GLOBAL_ARRAYS
 #    endif
-#    if !defined(PNG_USE_LOCAL_ARRAYS)
+#    ifndef PNG_USE_LOCAL_ARRAYS
 #      define PNG_USE_LOCAL_ARRAYS
 #    endif
 #  else
 #    if defined(PNG_USE_LOCAL_ARRAYS) || defined(PNG_NO_GLOBAL_ARRAYS)
-#      if defined(PNG_USE_GLOBAL_ARRAYS)
+#      ifdef PNG_USE_GLOBAL_ARRAYS
 #        undef PNG_USE_GLOBAL_ARRAYS
 #      endif
 #    endif
@@ -1299,12 +1432,12 @@
 #  endif
 #endif
 
-#if defined(__CYGWIN__)
+#ifdef __CYGWIN__
 #  undef PNGAPI
 #  define PNGAPI __cdecl
 #  undef PNG_IMPEXP
 #  define PNG_IMPEXP
-#endif  
+#endif
 
 /* If you define PNGAPI, e.g., with compiler option "-DPNGAPI=__stdcall",
  * you may get warnings regarding the linkage of png_zalloc and png_zfree.
@@ -1340,7 +1473,7 @@
 #     define PNG_IMPEXP
 #  endif
 
-#  if !defined(PNG_IMPEXP)
+#  ifndef PNG_IMPEXP
 
 #     define PNG_EXPORT_TYPE1(type,symbol)  PNG_IMPEXP type PNGAPI symbol
 #     define PNG_EXPORT_TYPE2(type,symbol)  type PNG_IMPEXP PNGAPI symbol
@@ -1351,7 +1484,7 @@
 #           define PNG_EXPORT PNG_EXPORT_TYPE1
 #        else
 #           define PNG_EXPORT PNG_EXPORT_TYPE2
-#           if defined(PNG_BUILD_DLL)
+#           ifdef PNG_BUILD_DLL
 #              define PNG_IMPEXP __export
 #           else
 #              define PNG_IMPEXP /*__import */ /* doesn't exist AFAIK in
@@ -1361,8 +1494,8 @@
 #        endif
 #     endif
 
-#     if !defined(PNG_IMPEXP)
-#        if defined(PNG_BUILD_DLL)
+#     ifndef PNG_IMPEXP
+#        ifdef PNG_BUILD_DLL
 #           define PNG_IMPEXP __declspec(dllexport)
 #        else
 #           define PNG_IMPEXP __declspec(dllimport)
@@ -1408,6 +1541,70 @@
 #  endif
 #endif
 
+#ifdef PNG_PEDANTIC_WARNINGS
+#  ifndef PNG_PEDANTIC_WARNINGS_SUPPORTED
+#    define PNG_PEDANTIC_WARNINGS_SUPPORTED
+#  endif
+#endif
+
+#ifdef PNG_PEDANTIC_WARNINGS_SUPPORTED
+/* Support for compiler specific function attributes.  These are used
+ * so that where compiler support is available incorrect use of API
+ * functions in png.h will generate compiler warnings.  Added at libpng
+ * version 1.2.41.
+ */
+#  ifdef __GNUC__
+#    ifndef PNG_USE_RESULT
+#      define PNG_USE_RESULT __attribute__((__warn_unused_result__))
+#    endif
+#    ifndef PNG_NORETURN
+#      define PNG_NORETURN   __attribute__((__noreturn__))
+#    endif
+#    ifndef PNG_ALLOCATED
+#      define PNG_ALLOCATED  __attribute__((__malloc__))
+#    endif
+
+    /* This specifically protects structure members that should only be
+     * accessed from within the library, therefore should be empty during
+     * a library build.
+     */
+#    ifndef PNG_DEPRECATED
+#      define PNG_DEPRECATED __attribute__((__deprecated__))
+#    endif
+#    ifndef PNG_DEPSTRUCT
+#      define PNG_DEPSTRUCT  __attribute__((__deprecated__))
+#    endif
+#    ifndef PNG_PRIVATE
+#      if 0 /* Doesn't work so we use deprecated instead*/
+#        define PNG_PRIVATE \
+          __attribute__((warning("This function is not exported by libpng.")))
+#      else
+#        define PNG_PRIVATE \
+          __attribute__((__deprecated__))
+#      endif
+#    endif /* PNG_PRIVATE */
+#  endif /* __GNUC__ */
+#endif /* PNG_PEDANTIC_WARNINGS */
+
+#ifndef PNG_DEPRECATED
+#  define PNG_DEPRECATED  /* Use of this function is deprecated */
+#endif
+#ifndef PNG_USE_RESULT
+#  define PNG_USE_RESULT  /* The result of this function must be checked */
+#endif
+#ifndef PNG_NORETURN
+#  define PNG_NORETURN    /* This function does not return */
+#endif
+#ifndef PNG_ALLOCATED
+#  define PNG_ALLOCATED   /* The result of the function is new memory */
+#endif
+#ifndef PNG_DEPSTRUCT
+#  define PNG_DEPSTRUCT   /* Access to this struct member is deprecated */
+#endif
+#ifndef PNG_PRIVATE
+#  define PNG_PRIVATE     /* This is a private libpng function */
+#endif
+
 /* User may want to use these so they are not in PNG_INTERNAL. Any library
  * functions that are passed far data must be model independent.
  */
@@ -1423,8 +1620,8 @@
    (LIBPNG_WAS_COMPILED_WITH__PNG_SETJMP_NOT_SUPPORTED)
 #endif
 
-#if defined(USE_FAR_KEYWORD)  /* memory model independent fns */
-/* use this to make far-to-near assignments */
+#ifdef USE_FAR_KEYWORD  /* memory model independent fns */
+/* Use this to make far-to-near assignments */
 #  define CHECK   1
 #  define NOCHECK 0
 #  define CVT_PTR(ptr) (png_far_to_near(png_ptr,ptr,CHECK))
@@ -1434,7 +1631,7 @@
 #  define png_memcmp  _fmemcmp    /* SJT: added */
 #  define png_memcpy  _fmemcpy
 #  define png_memset  _fmemset
-#else /* use the usual functions */
+#else /* Use the usual functions */
 #  define CVT_PTR(ptr)         (ptr)
 #  define CVT_PTR_NOCHECK(ptr) (ptr)
 #  ifndef PNG_NO_SNPRINTF
@@ -1452,7 +1649,8 @@
       * sprintf instead of snprintf exposes your application to accidental
       * or malevolent buffer overflows.  If you don't have snprintf()
       * as a general rule you should provide one (you can get one from
-      * Portable OpenSSH). */
+      * Portable OpenSSH).
+      */
 #    define png_snprintf(s1,n,fmt,x1) sprintf(s1,fmt,x1)
 #    define png_snprintf2(s1,n,fmt,x1,x2) sprintf(s1,fmt,x1,x2)
 #    define png_snprintf6(s1,n,fmt,x1,x2,x3,x4,x5,x6) \
diff -Naur libAfterImage-1.20/libpng/pngerror.c root/graf2d/asimage/src/libAfterImage/libpng/pngerror.c
--- libAfterImage-1.20/libpng/pngerror.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngerror.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,12 +1,15 @@
 
 /* pngerror.c - stub functions for i/o and memory allocation
  *
- * Last changed in libpng 1.2.22 [November 6, 2007]
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.51 [February 6, 2014]
+ * Copyright (c) 1998-2014 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
  * This file provides a location for all error handling.  Users who
  * need special error handling are expected to write replacement functions
  * and use png_set_error_fn() to use those functions.  See the instructions
@@ -14,24 +17,25 @@
  */
 
 #define PNG_INTERNAL
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
-
 #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
+
 static void /* PRIVATE */
 png_default_error PNGARG((png_structp png_ptr,
-  png_const_charp error_message));
-#ifndef PNG_NO_WARNINGS
+  png_const_charp error_message)) PNG_NORETURN;
+#ifdef PNG_WARNINGS_SUPPORTED
 static void /* PRIVATE */
 png_default_warning PNGARG((png_structp png_ptr,
   png_const_charp warning_message));
-#endif /* PNG_NO_WARNINGS */
+#endif /* PNG_WARNINGS_SUPPORTED */
 
 /* This function is called whenever there is a fatal error.  This function
  * should not be changed.  If there is a need to handle errors differently,
  * you should supply a replacement error function and use png_set_error_fn()
  * to replace the error function at run-time.
  */
-#ifndef PNG_NO_ERROR_TEXT
+#ifdef PNG_ERROR_TEXT_SUPPORTED
 void PNGAPI
 png_error(png_structp png_ptr, png_const_charp error_message)
 {
@@ -42,30 +46,31 @@
      if (png_ptr->flags&
        (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))
      {
-       if (*error_message == '#')
+       if (*error_message == PNG_LITERAL_SHARP)
        {
+           /* Strip "#nnnn " from beginning of error message. */
            int offset;
-           for (offset=1; offset<15; offset++)
-              if (*(error_message+offset) == ' ')
+           for (offset = 1; offset<15; offset++)
+              if (error_message[offset] == ' ')
                   break;
            if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)
            {
               int i;
-              for (i=0; i<offset-1; i++)
-                 msg[i]=error_message[i+1];
-              msg[i]='\0';
-              error_message=msg;
+              for (i = 0; i < offset - 1; i++)
+                 msg[i] = error_message[i + 1];
+              msg[i - 1] = '\0';
+              error_message = msg;
            }
            else
-              error_message+=offset;
+              error_message += offset;
        }
        else
        {
            if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)
            {
-              msg[0]='0';
-              msg[1]='\0';
-              error_message=msg;
+              msg[0] = '0';
+              msg[1] = '\0';
+              error_message = msg;
            }
        }
      }
@@ -82,16 +87,21 @@
 void PNGAPI
 png_err(png_structp png_ptr)
 {
+   /* Prior to 1.2.45 the error_fn received a NULL pointer, expressed
+    * erroneously as '\0', instead of the empty string "".  This was
+    * apparently an error, introduced in libpng-1.2.20, and png_default_error
+    * will crash in this case.
+    */
    if (png_ptr != NULL && png_ptr->error_fn != NULL)
-      (*(png_ptr->error_fn))(png_ptr, '\0');
+      (*(png_ptr->error_fn))(png_ptr, "");
 
    /* If the custom handler doesn't exist, or if it returns,
       use the default handler, which will not return. */
-   png_default_error(png_ptr, '\0');
+   png_default_error(png_ptr, "");
 }
-#endif /* PNG_NO_ERROR_TEXT */
+#endif /* PNG_ERROR_TEXT_SUPPORTED */
 
-#ifndef PNG_NO_WARNINGS
+#ifdef PNG_WARNINGS_SUPPORTED
 /* This function is called whenever there is a non-fatal error.  This function
  * should not be changed.  If there is a need to handle warnings differently,
  * you should supply a replacement warning function and use
@@ -108,21 +118,31 @@
      (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))
 #endif
      {
-       if (*warning_message == '#')
+       if (*warning_message == PNG_LITERAL_SHARP)
        {
-           for (offset=1; offset<15; offset++)
-              if (*(warning_message+offset) == ' ')
+           for (offset = 1; offset < 15; offset++)
+              if (warning_message[offset] == ' ')
                   break;
        }
      }
-     if (png_ptr != NULL && png_ptr->warning_fn != NULL)
-        (*(png_ptr->warning_fn))(png_ptr, warning_message+offset);
    }
+   if (png_ptr != NULL && png_ptr->warning_fn != NULL)
+      (*(png_ptr->warning_fn))(png_ptr, warning_message + offset);
    else
-      png_default_warning(png_ptr, warning_message+offset);
+      png_default_warning(png_ptr, warning_message + offset);
 }
-#endif /* PNG_NO_WARNINGS */
+#endif /* PNG_WARNINGS_SUPPORTED */
 
+#ifdef PNG_BENIGN_ERRORS_SUPPORTED
+void PNGAPI
+png_benign_error(png_structp png_ptr, png_const_charp error_message)
+{
+  if (png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN)
+    png_warning(png_ptr, error_message);
+  else
+    png_error(png_ptr, error_message);
+}
+#endif
 
 /* These utilities are used internally to build an error message that relates
  * to the current chunk.  The chunk name comes from png_ptr->chunk_name,
@@ -137,8 +157,7 @@
 };
 
 #define PNG_MAX_ERROR_TEXT 64
-
-#if !defined(PNG_NO_WARNINGS) || !defined(PNG_NO_ERROR_TEXT)
+#if defined(PNG_WARNINGS_SUPPORTED) || defined(PNG_ERROR_TEXT_SUPPORTED)
 static void /* PRIVATE */
 png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp
    error_message)
@@ -150,10 +169,10 @@
       int c = png_ptr->chunk_name[iin++];
       if (isnonalpha(c))
       {
-         buffer[iout++] = '[';
+         buffer[iout++] = PNG_LITERAL_LEFT_SQUARE_BRACKET;
          buffer[iout++] = png_digit[(c & 0xf0) >> 4];
          buffer[iout++] = png_digit[c & 0x0f];
-         buffer[iout++] = ']';
+         buffer[iout++] = PNG_LITERAL_RIGHT_SQUARE_BRACKET;
       }
       else
       {
@@ -167,8 +186,13 @@
    {
       buffer[iout++] = ':';
       buffer[iout++] = ' ';
-      png_memcpy(buffer+iout, error_message, PNG_MAX_ERROR_TEXT);
-      buffer[iout+PNG_MAX_ERROR_TEXT-1] = '\0';
+
+      iin = 0;
+      while (iin < PNG_MAX_ERROR_TEXT-1 && error_message[iin] != '\0')
+         buffer[iout++] = error_message[iin++];
+
+      /* iin < PNG_MAX_ERROR_TEXT, so the following is safe: */
+      buffer[iout] = '\0';
    }
 }
 
@@ -186,9 +210,9 @@
    }
 }
 #endif /* PNG_READ_SUPPORTED */
-#endif /* !defined(PNG_NO_WARNINGS) || !defined(PNG_NO_ERROR_TEXT) */
+#endif /* PNG_WARNINGS_SUPPORTED || PNG_ERROR_TEXT_SUPPORTED */
 
-#ifndef PNG_NO_WARNINGS
+#ifdef PNG_WARNINGS_SUPPORTED
 void PNGAPI
 png_chunk_warning(png_structp png_ptr, png_const_charp warning_message)
 {
@@ -201,8 +225,20 @@
      png_warning(png_ptr, msg);
    }
 }
-#endif /* PNG_NO_WARNINGS */
+#endif /* PNG_WARNINGS_SUPPORTED */
 
+#ifdef PNG_READ_SUPPORTED
+#ifdef PNG_BENIGN_ERRORS_SUPPORTED
+void PNGAPI
+png_chunk_benign_error(png_structp png_ptr, png_const_charp error_message)
+{
+  if (png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN)
+    png_chunk_warning(png_ptr, error_message);
+  else
+    png_chunk_error(png_ptr, error_message);
+}
+#endif
+#endif /* PNG_READ_SUPPORTED */
 
 /* This is the default error handling function.  Note that replacements for
  * this function MUST NOT RETURN, or the program will likely crash.  This
@@ -212,30 +248,39 @@
 static void /* PRIVATE */
 png_default_error(png_structp png_ptr, png_const_charp error_message)
 {
-#ifndef PNG_NO_CONSOLE_IO
+#ifdef PNG_CONSOLE_IO_SUPPORTED
 #ifdef PNG_ERROR_NUMBERS_SUPPORTED
-   if (*error_message == '#')
+   if (*error_message == PNG_LITERAL_SHARP)
    {
+     /* Strip "#nnnn " from beginning of error message. */
      int offset;
      char error_number[16];
-     for (offset=0; offset<15; offset++)
+     for (offset = 0; offset<15; offset++)
      {
-         error_number[offset] = *(error_message+offset+1);
-         if (*(error_message+offset) == ' ')
+         error_number[offset] = error_message[offset + 1];
+         if (error_message[offset] == ' ')
              break;
      }
-     if((offset > 1) && (offset < 15))
+     if ((offset > 1) && (offset < 15))
      {
-       error_number[offset-1]='\0';
-       fprintf(stderr, "libpng error no. %s: %s\n", error_number,
-          error_message+offset);
+       error_number[offset - 1] = '\0';
+       fprintf(stderr, "libpng error no. %s: %s",
+          error_number, error_message + offset + 1);
+       fprintf(stderr, PNG_STRING_NEWLINE);
      }
      else
-       fprintf(stderr, "libpng error: %s, offset=%d\n", error_message,offset);
+     {
+       fprintf(stderr, "libpng error: %s, offset=%d",
+          error_message, offset);
+       fprintf(stderr, PNG_STRING_NEWLINE);
+     }
    }
    else
 #endif
-   fprintf(stderr, "libpng error: %s\n", error_message);
+   {
+      fprintf(stderr, "libpng error: %s", error_message);
+      fprintf(stderr, PNG_STRING_NEWLINE);
+   }
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
@@ -245,21 +290,21 @@
    {
       jmp_buf jmpbuf;
       png_memcpy(jmpbuf, png_ptr->jmpbuf, png_sizeof(jmp_buf));
-      longjmp(jmpbuf, 1);
+     longjmp(jmpbuf,1);
    }
 #  else
    longjmp(png_ptr->jmpbuf, 1);
 #  endif
    }
-#else
-   PNG_ABORT();
 #endif
-#ifdef PNG_NO_CONSOLE_IO
-   error_message = error_message; /* make compiler happy */
+   /* Here if not setjmp support or if png_ptr is null. */
+   PNG_ABORT();
+#ifndef PNG_CONSOLE_IO_SUPPORTED
+   PNG_UNUSED(error_message) /* Make compiler happy */
 #endif
 }
 
-#ifndef PNG_NO_WARNINGS
+#ifdef PNG_WARNINGS_SUPPORTED
 /* This function is called when there is a warning, but the library thinks
  * it can continue anyway.  Replacement functions don't have to do anything
  * here if you don't want them to.  In the default configuration, png_ptr is
@@ -268,36 +313,44 @@
 static void /* PRIVATE */
 png_default_warning(png_structp png_ptr, png_const_charp warning_message)
 {
-#ifndef PNG_NO_CONSOLE_IO
+#ifdef PNG_CONSOLE_IO_SUPPORTED
 #  ifdef PNG_ERROR_NUMBERS_SUPPORTED
-   if (*warning_message == '#')
+   if (*warning_message == PNG_LITERAL_SHARP)
    {
      int offset;
      char warning_number[16];
-     for (offset=0; offset<15; offset++)
+     for (offset = 0; offset < 15; offset++)
      {
-        warning_number[offset]=*(warning_message+offset+1);
-        if (*(warning_message+offset) == ' ')
+        warning_number[offset] = warning_message[offset + 1];
+        if (warning_message[offset] == ' ')
             break;
      }
-     if((offset > 1) && (offset < 15))
+     if ((offset > 1) && (offset < 15))
      {
-       warning_number[offset-1]='\0';
-       fprintf(stderr, "libpng warning no. %s: %s\n", warning_number,
-          warning_message+offset);
+       warning_number[offset + 1] = '\0';
+       fprintf(stderr, "libpng warning no. %s: %s",
+          warning_number, warning_message + offset);
+       fprintf(stderr, PNG_STRING_NEWLINE);
      }
      else
-       fprintf(stderr, "libpng warning: %s\n", warning_message);
+     {
+       fprintf(stderr, "libpng warning: %s",
+          warning_message);
+       fprintf(stderr, PNG_STRING_NEWLINE);
+     }
    }
    else
 #  endif
-     fprintf(stderr, "libpng warning: %s\n", warning_message);
+   {
+     fprintf(stderr, "libpng warning: %s", warning_message);
+     fprintf(stderr, PNG_STRING_NEWLINE);
+   }
 #else
-   warning_message = warning_message; /* make compiler happy */
+   PNG_UNUSED(warning_message) /* Make compiler happy */
 #endif
-   png_ptr = png_ptr; /* make compiler happy */
+   PNG_UNUSED(png_ptr) /* Make compiler happy */
 }
-#endif /* PNG_NO_WARNINGS */
+#endif /* PNG_WARNINGS_SUPPORTED */
 
 /* This function is called when the application wants to use another method
  * of handling errors and warnings.  Note that the error function MUST NOT
@@ -333,7 +386,7 @@
 void PNGAPI
 png_set_strip_error_numbers(png_structp png_ptr, png_uint_32 strip_mode)
 {
-   if(png_ptr != NULL)
+   if (png_ptr != NULL)
    {
      png_ptr->flags &=
        ((~(PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))&strip_mode);
diff -Naur libAfterImage-1.20/libpng/pngget.c root/graf2d/asimage/src/libAfterImage/libpng/pngget.c
--- libAfterImage-1.20/libpng/pngget.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngget.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,16 +1,20 @@
 
 /* pngget.c - retrieval of values from info struct
  *
- * Last changed in libpng 1.2.15 January 5, 2007
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.53 [February 26, 2015]
+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
  */
 
 #define PNG_INTERNAL
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
-
 #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
 
 png_uint_32 PNGAPI
@@ -18,6 +22,7 @@
 {
    if (png_ptr != NULL && info_ptr != NULL)
       return(info_ptr->valid & flag);
+
    else
       return(0);
 }
@@ -27,30 +32,31 @@
 {
    if (png_ptr != NULL && info_ptr != NULL)
       return(info_ptr->rowbytes);
+
    else
       return(0);
 }
 
-#if defined(PNG_INFO_IMAGE_SUPPORTED)
+#ifdef PNG_INFO_IMAGE_SUPPORTED
 png_bytepp PNGAPI
 png_get_rows(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
       return(info_ptr->row_pointers);
+
    else
       return(0);
 }
 #endif
 
 #ifdef PNG_EASY_ACCESS_SUPPORTED
-/* easy access to info, added in libpng-0.99 */
+/* Easy access to info, added in libpng-0.99 */
 png_uint_32 PNGAPI
 png_get_image_width(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-   {
       return info_ptr->width;
-   }
+
    return (0);
 }
 
@@ -58,9 +64,8 @@
 png_get_image_height(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-   {
       return info_ptr->height;
-   }
+
    return (0);
 }
 
@@ -68,9 +73,8 @@
 png_get_bit_depth(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-   {
       return info_ptr->bit_depth;
-   }
+
    return (0);
 }
 
@@ -78,9 +82,8 @@
 png_get_color_type(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-   {
       return info_ptr->color_type;
-   }
+
    return (0);
 }
 
@@ -88,9 +91,8 @@
 png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-   {
       return info_ptr->filter_type;
-   }
+
    return (0);
 }
 
@@ -98,9 +100,8 @@
 png_get_interlace_type(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-   {
       return info_ptr->interlace_type;
-   }
+
    return (0);
 }
 
@@ -108,9 +109,8 @@
 png_get_compression_type(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-   {
       return info_ptr->compression_type;
-   }
+
    return (0);
 }
 
@@ -118,13 +118,16 @@
 png_get_x_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-#if defined(PNG_pHYs_SUPPORTED)
+#ifdef PNG_pHYs_SUPPORTED
    if (info_ptr->valid & PNG_INFO_pHYs)
    {
-      png_debug1(1, "in %s retrieval function\n", "png_get_x_pixels_per_meter");
-      if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
+      png_debug1(1, "in %s retrieval function", "png_get_x_pixels_per_meter");
+
+      if (info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
           return (0);
-      else return (info_ptr->x_pixels_per_unit);
+
+      else
+          return (info_ptr->x_pixels_per_unit);
    }
 #else
    return (0);
@@ -136,13 +139,16 @@
 png_get_y_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-#if defined(PNG_pHYs_SUPPORTED)
+#ifdef PNG_pHYs_SUPPORTED
    if (info_ptr->valid & PNG_INFO_pHYs)
    {
-      png_debug1(1, "in %s retrieval function\n", "png_get_y_pixels_per_meter");
-      if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
+      png_debug1(1, "in %s retrieval function", "png_get_y_pixels_per_meter");
+
+      if (info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
           return (0);
-      else return (info_ptr->y_pixels_per_unit);
+
+      else
+          return (info_ptr->y_pixels_per_unit);
    }
 #else
    return (0);
@@ -154,14 +160,17 @@
 png_get_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-#if defined(PNG_pHYs_SUPPORTED)
+#ifdef PNG_pHYs_SUPPORTED
    if (info_ptr->valid & PNG_INFO_pHYs)
    {
-      png_debug1(1, "in %s retrieval function\n", "png_get_pixels_per_meter");
-      if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER ||
+      png_debug1(1, "in %s retrieval function", "png_get_pixels_per_meter");
+
+      if (info_ptr->phys_unit_type != PNG_RESOLUTION_METER ||
          info_ptr->x_pixels_per_unit != info_ptr->y_pixels_per_unit)
           return (0);
-      else return (info_ptr->x_pixels_per_unit);
+
+      else
+          return (info_ptr->x_pixels_per_unit);
    }
 #else
    return (0);
@@ -174,18 +183,21 @@
 png_get_pixel_aspect_ratio(png_structp png_ptr, png_infop info_ptr)
    {
    if (png_ptr != NULL && info_ptr != NULL)
-#if defined(PNG_pHYs_SUPPORTED)
+#ifdef PNG_pHYs_SUPPORTED
+
    if (info_ptr->valid & PNG_INFO_pHYs)
    {
-      png_debug1(1, "in %s retrieval function\n", "png_get_aspect_ratio");
+      png_debug1(1, "in %s retrieval function", "png_get_aspect_ratio");
+
       if (info_ptr->x_pixels_per_unit == 0)
          return ((float)0.0);
+
       else
          return ((float)((float)info_ptr->y_pixels_per_unit
             /(float)info_ptr->x_pixels_per_unit));
    }
 #else
-   return (0.0);
+      return (0.0);
 #endif
    return ((float)0.0);
 }
@@ -195,16 +207,20 @@
 png_get_x_offset_microns(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-#if defined(PNG_oFFs_SUPPORTED)
+#ifdef PNG_oFFs_SUPPORTED
+
    if (info_ptr->valid & PNG_INFO_oFFs)
    {
-      png_debug1(1, "in %s retrieval function\n", "png_get_x_offset_microns");
-      if(info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
+      png_debug1(1, "in %s retrieval function", "png_get_x_offset_microns");
+
+      if (info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
           return (0);
-      else return (info_ptr->x_offset);
+
+      else
+          return (info_ptr->x_offset);
    }
 #else
-   return (0);
+      return (0);
 #endif
    return (0);
 }
@@ -213,13 +229,17 @@
 png_get_y_offset_microns(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-#if defined(PNG_oFFs_SUPPORTED)
+
+#ifdef PNG_oFFs_SUPPORTED
    if (info_ptr->valid & PNG_INFO_oFFs)
    {
-      png_debug1(1, "in %s retrieval function\n", "png_get_y_offset_microns");
-      if(info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
+      png_debug1(1, "in %s retrieval function", "png_get_y_offset_microns");
+
+      if (info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
           return (0);
-      else return (info_ptr->y_offset);
+
+      else
+          return (info_ptr->y_offset);
    }
 #else
    return (0);
@@ -231,13 +251,17 @@
 png_get_x_offset_pixels(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-#if defined(PNG_oFFs_SUPPORTED)
+
+#ifdef PNG_oFFs_SUPPORTED
    if (info_ptr->valid & PNG_INFO_oFFs)
    {
-      png_debug1(1, "in %s retrieval function\n", "png_get_x_offset_microns");
-      if(info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
+      png_debug1(1, "in %s retrieval function", "png_get_x_offset_microns");
+
+      if (info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
           return (0);
-      else return (info_ptr->x_offset);
+
+      else
+          return (info_ptr->x_offset);
    }
 #else
    return (0);
@@ -249,13 +273,17 @@
 png_get_y_offset_pixels(png_structp png_ptr, png_infop info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-#if defined(PNG_oFFs_SUPPORTED)
+
+#ifdef PNG_oFFs_SUPPORTED
    if (info_ptr->valid & PNG_INFO_oFFs)
    {
-      png_debug1(1, "in %s retrieval function\n", "png_get_y_offset_microns");
-      if(info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
+      png_debug1(1, "in %s retrieval function", "png_get_y_offset_microns");
+
+      if (info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
           return (0);
-      else return (info_ptr->y_offset);
+
+      else
+          return (info_ptr->y_offset);
    }
 #else
    return (0);
@@ -299,7 +327,7 @@
      *.00003937);
 }
 
-#if defined(PNG_pHYs_SUPPORTED)
+#ifdef PNG_pHYs_SUPPORTED
 png_uint_32 PNGAPI
 png_get_pHYs_dpi(png_structp png_ptr, png_infop info_ptr,
    png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
@@ -308,7 +336,8 @@
 
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
    {
-      png_debug1(1, "in %s retrieval function\n", "pHYs");
+      png_debug1(1, "in %s retrieval function", "pHYs");
+
       if (res_x != NULL)
       {
          *res_x = info_ptr->x_pixels_per_unit;
@@ -323,7 +352,7 @@
       {
          *unit_type = (int)info_ptr->phys_unit_type;
          retval |= PNG_INFO_pHYs;
-         if(*unit_type == 1)
+         if (*unit_type == 1)
          {
             if (res_x != NULL) *res_x = (png_uint_32)(*res_x * .0254 + .50);
             if (res_y != NULL) *res_y = (png_uint_32)(*res_y * .0254 + .50);
@@ -357,7 +386,7 @@
       return (NULL);
 }
 
-#if defined(PNG_bKGD_SUPPORTED)
+#ifdef PNG_bKGD_SUPPORTED
 png_uint_32 PNGAPI
 png_get_bKGD(png_structp png_ptr, png_infop info_ptr,
    png_color_16p *background)
@@ -365,7 +394,8 @@
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD)
       && background != NULL)
    {
-      png_debug1(1, "in %s retrieval function\n", "bKGD");
+      png_debug1(1, "in %s retrieval function", "bKGD");
+
       *background = &(info_ptr->background);
       return (PNG_INFO_bKGD);
    }
@@ -373,7 +403,7 @@
 }
 #endif
 
-#if defined(PNG_cHRM_SUPPORTED)
+#ifdef PNG_cHRM_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 png_uint_32 PNGAPI
 png_get_cHRM(png_structp png_ptr, png_infop info_ptr,
@@ -382,7 +412,8 @@
 {
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
    {
-      png_debug1(1, "in %s retrieval function\n", "cHRM");
+      png_debug1(1, "in %s retrieval function", "cHRM");
+
       if (white_x != NULL)
          *white_x = (double)info_ptr->x_white;
       if (white_y != NULL)
@@ -411,9 +442,10 @@
    png_fixed_point *red_y, png_fixed_point *green_x, png_fixed_point *green_y,
    png_fixed_point *blue_x, png_fixed_point *blue_y)
 {
+   png_debug1(1, "in %s retrieval function", "cHRM");
+
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
    {
-      png_debug1(1, "in %s retrieval function\n", "cHRM");
       if (white_x != NULL)
          *white_x = info_ptr->int_x_white;
       if (white_y != NULL)
@@ -437,15 +469,16 @@
 #endif
 #endif
 
-#if defined(PNG_gAMA_SUPPORTED)
+#ifdef PNG_gAMA_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 png_uint_32 PNGAPI
 png_get_gAMA(png_structp png_ptr, png_infop info_ptr, double *file_gamma)
 {
+   png_debug1(1, "in %s retrieval function", "gAMA");
+
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
       && file_gamma != NULL)
    {
-      png_debug1(1, "in %s retrieval function\n", "gAMA");
       *file_gamma = (double)info_ptr->gamma;
       return (PNG_INFO_gAMA);
    }
@@ -457,10 +490,11 @@
 png_get_gAMA_fixed(png_structp png_ptr, png_infop info_ptr,
     png_fixed_point *int_file_gamma)
 {
+   png_debug1(1, "in %s retrieval function", "gAMA");
+
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
       && int_file_gamma != NULL)
    {
-      png_debug1(1, "in %s retrieval function\n", "gAMA");
       *int_file_gamma = info_ptr->int_gamma;
       return (PNG_INFO_gAMA);
    }
@@ -469,14 +503,15 @@
 #endif
 #endif
 
-#if defined(PNG_sRGB_SUPPORTED)
+#ifdef PNG_sRGB_SUPPORTED
 png_uint_32 PNGAPI
 png_get_sRGB(png_structp png_ptr, png_infop info_ptr, int *file_srgb_intent)
 {
+   png_debug1(1, "in %s retrieval function", "sRGB");
+
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB)
       && file_srgb_intent != NULL)
    {
-      png_debug1(1, "in %s retrieval function\n", "sRGB");
       *file_srgb_intent = (int)info_ptr->srgb_intent;
       return (PNG_INFO_sRGB);
    }
@@ -484,20 +519,22 @@
 }
 #endif
 
-#if defined(PNG_iCCP_SUPPORTED)
+#ifdef PNG_iCCP_SUPPORTED
 png_uint_32 PNGAPI
 png_get_iCCP(png_structp png_ptr, png_infop info_ptr,
              png_charpp name, int *compression_type,
              png_charpp profile, png_uint_32 *proflen)
 {
+   png_debug1(1, "in %s retrieval function", "iCCP");
+
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP)
       && name != NULL && profile != NULL && proflen != NULL)
    {
-      png_debug1(1, "in %s retrieval function\n", "iCCP");
       *name = info_ptr->iccp_name;
       *profile = info_ptr->iccp_profile;
-      /* compression_type is a dummy so the API won't have to change
-         if we introduce multiple compression types later. */
+      /* Compression_type is a dummy so the API won't have to change
+       * if we introduce multiple compression types later.
+       */
       *proflen = (int)info_ptr->iccp_proflen;
       *compression_type = (int)info_ptr->iccp_compression;
       return (PNG_INFO_iCCP);
@@ -506,7 +543,7 @@
 }
 #endif
 
-#if defined(PNG_sPLT_SUPPORTED)
+#ifdef PNG_sPLT_SUPPORTED
 png_uint_32 PNGAPI
 png_get_sPLT(png_structp png_ptr, png_infop info_ptr,
              png_sPLT_tpp spalettes)
@@ -520,14 +557,15 @@
 }
 #endif
 
-#if defined(PNG_hIST_SUPPORTED)
+#ifdef PNG_hIST_SUPPORTED
 png_uint_32 PNGAPI
 png_get_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_16p *hist)
 {
+   png_debug1(1, "in %s retrieval function", "hIST");
+
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST)
       && hist != NULL)
    {
-      png_debug1(1, "in %s retrieval function\n", "hIST");
       *hist = info_ptr->hist;
       return (PNG_INFO_hIST);
    }
@@ -542,54 +580,48 @@
    int *filter_type)
 
 {
-   if (png_ptr != NULL && info_ptr != NULL && width != NULL && height != NULL &&
-      bit_depth != NULL && color_type != NULL)
-   {
-      png_debug1(1, "in %s retrieval function\n", "IHDR");
-      *width = info_ptr->width;
-      *height = info_ptr->height;
-      *bit_depth = info_ptr->bit_depth;
-      if (info_ptr->bit_depth < 1 || info_ptr->bit_depth > 16)
-        png_error(png_ptr, "Invalid bit depth");
-      *color_type = info_ptr->color_type;
-      if (info_ptr->color_type > 6)
-        png_error(png_ptr, "Invalid color type");
-      if (compression_type != NULL)
-         *compression_type = info_ptr->compression_type;
-      if (filter_type != NULL)
-         *filter_type = info_ptr->filter_type;
-      if (interlace_type != NULL)
-         *interlace_type = info_ptr->interlace_type;
-
-      /* check for potential overflow of rowbytes */
-      if (*width == 0 || *width > PNG_UINT_31_MAX)
-        png_error(png_ptr, "Invalid image width");
-      if (*height == 0 || *height > PNG_UINT_31_MAX)
-        png_error(png_ptr, "Invalid image height");
-      if (info_ptr->width > (PNG_UINT_32_MAX
-                 >> 3)      /* 8-byte RGBA pixels */
-                 - 64       /* bigrowbuf hack */
-                 - 1        /* filter byte */
-                 - 7*8      /* rounding of width to multiple of 8 pixels */
-                 - 8)       /* extra max_pixel_depth pad */
-      {
-         png_warning(png_ptr,
-            "Width too large for libpng to process image data.");
-      }
-      return (1);
-   }
-   return (0);
+   png_debug1(1, "in %s retrieval function", "IHDR");
+
+   if (png_ptr == NULL || info_ptr == NULL || width == NULL ||
+       height == NULL || bit_depth == NULL || color_type == NULL)
+      return (0);
+
+   *width = info_ptr->width;
+   *height = info_ptr->height;
+   *bit_depth = info_ptr->bit_depth;
+   *color_type = info_ptr->color_type;
+
+   if (compression_type != NULL)
+      *compression_type = info_ptr->compression_type;
+
+   if (filter_type != NULL)
+      *filter_type = info_ptr->filter_type;
+
+   if (interlace_type != NULL)
+      *interlace_type = info_ptr->interlace_type;
+
+   /* This is redundant if we can be sure that the info_ptr values were all
+    * assigned in png_set_IHDR().  We do the check anyhow in case an
+    * application has ignored our advice not to mess with the members
+    * of info_ptr directly.
+    */
+   png_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,
+       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,
+       info_ptr->compression_type, info_ptr->filter_type);
+
+   return (1);
 }
 
-#if defined(PNG_oFFs_SUPPORTED)
+#ifdef PNG_oFFs_SUPPORTED
 png_uint_32 PNGAPI
 png_get_oFFs(png_structp png_ptr, png_infop info_ptr,
    png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type)
 {
+   png_debug1(1, "in %s retrieval function", "oFFs");
+
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs)
       && offset_x != NULL && offset_y != NULL && unit_type != NULL)
    {
-      png_debug1(1, "in %s retrieval function\n", "oFFs");
       *offset_x = info_ptr->x_offset;
       *offset_y = info_ptr->y_offset;
       *unit_type = (int)info_ptr->offset_unit_type;
@@ -599,17 +631,18 @@
 }
 #endif
 
-#if defined(PNG_pCAL_SUPPORTED)
+#ifdef PNG_pCAL_SUPPORTED
 png_uint_32 PNGAPI
 png_get_pCAL(png_structp png_ptr, png_infop info_ptr,
    png_charp *purpose, png_int_32 *X0, png_int_32 *X1, int *type, int *nparams,
    png_charp *units, png_charpp *params)
 {
+   png_debug1(1, "in %s retrieval function", "pCAL");
+
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL)
-      && purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&
-      nparams != NULL && units != NULL && params != NULL)
+       && purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&
+       nparams != NULL && units != NULL && params != NULL)
    {
-      png_debug1(1, "in %s retrieval function\n", "pCAL");
       *purpose = info_ptr->pcal_purpose;
       *X0 = info_ptr->pcal_X0;
       *X1 = info_ptr->pcal_X1;
@@ -623,14 +656,14 @@
 }
 #endif
 
-#if defined(PNG_sCAL_SUPPORTED)
+#ifdef PNG_sCAL_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 png_uint_32 PNGAPI
 png_get_sCAL(png_structp png_ptr, png_infop info_ptr,
              int *unit, double *width, double *height)
 {
     if (png_ptr != NULL && info_ptr != NULL &&
-       (info_ptr->valid & PNG_INFO_sCAL))
+        (info_ptr->valid & PNG_INFO_sCAL))
     {
         *unit = info_ptr->scal_unit;
         *width = info_ptr->scal_pixel_width;
@@ -646,7 +679,7 @@
              int *unit, png_charpp width, png_charpp height)
 {
     if (png_ptr != NULL && info_ptr != NULL &&
-       (info_ptr->valid & PNG_INFO_sCAL))
+        (info_ptr->valid & PNG_INFO_sCAL))
     {
         *unit = info_ptr->scal_unit;
         *width = info_ptr->scal_s_width;
@@ -659,27 +692,30 @@
 #endif
 #endif
 
-#if defined(PNG_pHYs_SUPPORTED)
+#ifdef PNG_pHYs_SUPPORTED
 png_uint_32 PNGAPI
 png_get_pHYs(png_structp png_ptr, png_infop info_ptr,
    png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
 {
    png_uint_32 retval = 0;
 
+   png_debug1(1, "in %s retrieval function", "pHYs");
+
    if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_pHYs))
    {
-      png_debug1(1, "in %s retrieval function\n", "pHYs");
       if (res_x != NULL)
       {
          *res_x = info_ptr->x_pixels_per_unit;
          retval |= PNG_INFO_pHYs;
       }
+
       if (res_y != NULL)
       {
          *res_y = info_ptr->y_pixels_per_unit;
          retval |= PNG_INFO_pHYs;
       }
+
       if (unit_type != NULL)
       {
          *unit_type = (int)info_ptr->phys_unit_type;
@@ -694,26 +730,28 @@
 png_get_PLTE(png_structp png_ptr, png_infop info_ptr, png_colorp *palette,
    int *num_palette)
 {
+   png_debug1(1, "in %s retrieval function", "PLTE");
+
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_PLTE)
        && palette != NULL)
    {
-      png_debug1(1, "in %s retrieval function\n", "PLTE");
       *palette = info_ptr->palette;
       *num_palette = info_ptr->num_palette;
-      png_debug1(3, "num_palette = %d\n", *num_palette);
+      png_debug1(3, "num_palette = %d", *num_palette);
       return (PNG_INFO_PLTE);
    }
    return (0);
 }
 
-#if defined(PNG_sBIT_SUPPORTED)
+#ifdef PNG_sBIT_SUPPORTED
 png_uint_32 PNGAPI
 png_get_sBIT(png_structp png_ptr, png_infop info_ptr, png_color_8p *sig_bit)
 {
+   png_debug1(1, "in %s retrieval function", "sBIT");
+
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT)
       && sig_bit != NULL)
    {
-      png_debug1(1, "in %s retrieval function\n", "sBIT");
       *sig_bit = &(info_ptr->sig_bit);
       return (PNG_INFO_sBIT);
    }
@@ -721,20 +759,23 @@
 }
 #endif
 
-#if defined(PNG_TEXT_SUPPORTED)
+#ifdef PNG_TEXT_SUPPORTED
 png_uint_32 PNGAPI
 png_get_text(png_structp png_ptr, png_infop info_ptr, png_textp *text_ptr,
    int *num_text)
 {
    if (png_ptr != NULL && info_ptr != NULL && info_ptr->num_text > 0)
    {
-      png_debug1(1, "in %s retrieval function\n",
+      png_debug1(1, "in %s retrieval function",
          (png_ptr->chunk_name[0] == '\0' ? "text"
              : (png_const_charp)png_ptr->chunk_name));
+
       if (text_ptr != NULL)
          *text_ptr = info_ptr->text;
+
       if (num_text != NULL)
          *num_text = info_ptr->num_text;
+
       return ((png_uint_32)info_ptr->num_text);
    }
    if (num_text != NULL)
@@ -743,14 +784,15 @@
 }
 #endif
 
-#if defined(PNG_tIME_SUPPORTED)
+#ifdef PNG_tIME_SUPPORTED
 png_uint_32 PNGAPI
 png_get_tIME(png_structp png_ptr, png_infop info_ptr, png_timep *mod_time)
 {
+   png_debug1(1, "in %s retrieval function", "tIME");
+
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME)
        && mod_time != NULL)
    {
-      png_debug1(1, "in %s retrieval function\n", "tIME");
       *mod_time = &(info_ptr->mod_time);
       return (PNG_INFO_tIME);
    }
@@ -758,7 +800,7 @@
 }
 #endif
 
-#if defined(PNG_tRNS_SUPPORTED)
+#ifdef PNG_tRNS_SUPPORTED
 png_uint_32 PNGAPI
 png_get_tRNS(png_structp png_ptr, png_infop info_ptr,
    png_bytep *trans, int *num_trans, png_color_16p *trans_values)
@@ -766,7 +808,8 @@
    png_uint_32 retval = 0;
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
    {
-      png_debug1(1, "in %s retrieval function\n", "tRNS");
+      png_debug1(1, "in %s retrieval function", "tRNS");
+
       if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
       {
           if (trans != NULL)
@@ -774,6 +817,7 @@
              *trans = info_ptr->trans;
              retval |= PNG_INFO_tRNS;
           }
+
           if (trans_values != NULL)
              *trans_values = &(info_ptr->trans_values);
       }
@@ -784,10 +828,11 @@
              *trans_values = &(info_ptr->trans_values);
              retval |= PNG_INFO_tRNS;
           }
-          if(trans != NULL)
+
+          if (trans != NULL)
              *trans = NULL;
       }
-      if(num_trans != NULL)
+      if (num_trans != NULL)
       {
          *num_trans = info_ptr->num_trans;
          retval |= PNG_INFO_tRNS;
@@ -797,7 +842,7 @@
 }
 #endif
 
-#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
+#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
 png_uint_32 PNGAPI
 png_get_unknown_chunks(png_structp png_ptr, png_infop info_ptr,
              png_unknown_chunkpp unknowns)
@@ -811,7 +856,7 @@
 }
 #endif
 
-#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
 png_byte PNGAPI
 png_get_rgb_to_gray_status (png_structp png_ptr)
 {
@@ -819,7 +864,7 @@
 }
 #endif
 
-#if defined(PNG_USER_CHUNKS_SUPPORTED)
+#ifdef PNG_USER_CHUNKS_SUPPORTED
 png_voidp PNGAPI
 png_get_user_chunk_ptr(png_structp png_ptr)
 {
@@ -827,64 +872,66 @@
 }
 #endif
 
-#ifdef PNG_WRITE_SUPPORTED
 png_uint_32 PNGAPI
 png_get_compression_buffer_size(png_structp png_ptr)
 {
    return (png_uint_32)(png_ptr? png_ptr->zbuf_size : 0L);
 }
-#endif
 
 #ifdef PNG_ASSEMBLER_CODE_SUPPORTED
 #ifndef PNG_1_0_X
-/* this function was added to libpng 1.2.0 and should exist by default */
+/* This function was added to libpng 1.2.0 and should exist by default */
 png_uint_32 PNGAPI
 png_get_asm_flags (png_structp png_ptr)
 {
-    /* obsolete, to be removed from libpng-1.4.0 */
-    return (png_ptr? 0L: 0L);
+    /* Obsolete, to be removed from libpng-1.4.0 */
+    PNG_UNUSED(png_ptr)
+    return 0L;
 }
 
-/* this function was added to libpng 1.2.0 and should exist by default */
+/* This function was added to libpng 1.2.0 and should exist by default */
 png_uint_32 PNGAPI
 png_get_asm_flagmask (int flag_select)
 {
-    /* obsolete, to be removed from libpng-1.4.0 */
-    flag_select=flag_select;
+    /* Obsolete, to be removed from libpng-1.4.0 */
+    PNG_UNUSED(flag_select)
     return 0L;
 }
 
     /* GRR:  could add this:   && defined(PNG_MMX_CODE_SUPPORTED) */
-/* this function was added to libpng 1.2.0 */
+/* This function was added to libpng 1.2.0 */
 png_uint_32 PNGAPI
 png_get_mmx_flagmask (int flag_select, int *compilerID)
 {
-    /* obsolete, to be removed from libpng-1.4.0 */
-    flag_select=flag_select;
+    /* Obsolete, to be removed from libpng-1.4.0 */
+    PNG_UNUSED(flag_select)
     *compilerID = -1;   /* unknown (i.e., no asm/MMX code compiled) */
     return 0L;
 }
 
-/* this function was added to libpng 1.2.0 */
+/* This function was added to libpng 1.2.0 */
 png_byte PNGAPI
 png_get_mmx_bitdepth_threshold (png_structp png_ptr)
 {
-    /* obsolete, to be removed from libpng-1.4.0 */
-    return (png_ptr? 0: 0);
+    /* Obsolete, to be removed from libpng-1.4.0 */
+    PNG_UNUSED(png_ptr)
+    return 0L;
 }
 
-/* this function was added to libpng 1.2.0 */
+/* This function was added to libpng 1.2.0 */
 png_uint_32 PNGAPI
 png_get_mmx_rowbytes_threshold (png_structp png_ptr)
 {
-    /* obsolete, to be removed from libpng-1.4.0 */
-    return (png_ptr? 0L: 0L);
+    /* Obsolete, to be removed from libpng-1.4.0 */
+    PNG_UNUSED(png_ptr)
+    return 0L;
 }
 #endif /* ?PNG_1_0_X */
 #endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */
 
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
-/* these functions were added to libpng 1.2.6 */
+/* These functions were added to libpng 1.2.6 but not enabled
+* by default. They will be enabled in libpng-1.4.0 */
 png_uint_32 PNGAPI
 png_get_user_width_max (png_structp png_ptr)
 {
@@ -896,6 +943,5 @@
     return (png_ptr? png_ptr->user_height_max : 0);
 }
 #endif /* ?PNG_SET_USER_LIMITS_SUPPORTED */
- 
 
 #endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff -Naur libAfterImage-1.20/libpng/pngmem.c root/graf2d/asimage/src/libAfterImage/libpng/pngmem.c
--- libAfterImage-1.20/libpng/pngmem.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngmem.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,12 +1,15 @@
 
 /* pngmem.c - stub functions for memory allocation
  *
- * Last changed in libpng 1.2.13 November 13, 2006
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.41 [February 25, 2010]
+ * Copyright (c) 1998-2010 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
  * This file provides a location for all memory allocation.  Users who
  * need special memory handling are expected to supply replacement
  * functions for png_malloc() and png_free(), and to use
@@ -15,13 +18,13 @@
  */
 
 #define PNG_INTERNAL
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
-
 #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
 
 /* Borland DOS special memory handler */
 #if defined(__TURBOC__) && !defined(_Windows) && !defined(__FLAT__)
-/* if you change this, be sure to change the one in png.h also */
+/* If you change this, be sure to change the one in png.h also */
 
 /* Allocate memory for a png_struct.  The malloc and memset can be replaced
    by a single call to calloc() if this is thought to improve performance. */
@@ -41,14 +44,14 @@
    png_voidp struct_ptr;
 
    if (type == PNG_STRUCT_INFO)
-     size = png_sizeof(png_info);
+      size = png_sizeof(png_info);
    else if (type == PNG_STRUCT_PNG)
-     size = png_sizeof(png_struct);
+      size = png_sizeof(png_struct);
    else
-     return (png_get_copyright(NULL));
+      return (png_get_copyright(NULL));
 
 #ifdef PNG_USER_MEM_SUPPORTED
-   if(malloc_fn != NULL)
+   if (malloc_fn != NULL)
    {
       png_struct dummy_struct;
       png_structp png_ptr = &dummy_struct;
@@ -57,7 +60,7 @@
    }
    else
 #endif /* PNG_USER_MEM_SUPPORTED */
-      struct_ptr = (png_voidp)farmalloc(size);
+   struct_ptr = (png_voidp)farmalloc(size);
    if (struct_ptr != NULL)
       png_memset(struct_ptr, 0, size);
    return (struct_ptr);
@@ -80,7 +83,7 @@
    if (struct_ptr != NULL)
    {
 #ifdef PNG_USER_MEM_SUPPORTED
-      if(free_fn != NULL)
+      if (free_fn != NULL)
       {
          png_struct dummy_struct;
          png_structp png_ptr = &dummy_struct;
@@ -112,6 +115,16 @@
  * result, we would be truncating potentially larger memory requests
  * (which should cause a fatal error) and introducing major problems.
  */
+png_voidp /* PRIVATE */
+png_calloc(png_structp png_ptr, png_uint_32 size)
+{
+   png_voidp ret;
+
+   ret = (png_malloc(png_ptr, size));
+   if (ret != NULL)
+      png_memset(ret,0,(png_size_t)size);
+   return (ret);
+}
 
 png_voidp PNGAPI
 png_malloc(png_structp png_ptr, png_uint_32 size)
@@ -122,10 +135,10 @@
       return (NULL);
 
 #ifdef PNG_USER_MEM_SUPPORTED
-   if(png_ptr->malloc_fn != NULL)
-       ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
+   if (png_ptr->malloc_fn != NULL)
+      ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
    else
-       ret = (png_malloc_default(png_ptr, size));
+      ret = (png_malloc_default(png_ptr, size));
    if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
        png_error(png_ptr, "Out of memory!");
    return (ret);
@@ -150,12 +163,12 @@
 #endif
 
    if (size != (size_t)size)
-     ret = NULL;
+      ret = NULL;
    else if (size == (png_uint_32)65536L)
    {
       if (png_ptr->offset_table == NULL)
       {
-         /* try to see if we need to do any of this fancy stuff */
+         /* Try to see if we need to do any of this fancy stuff */
          ret = farmalloc(size);
          if (ret == NULL || ((png_size_t)ret & 0xffff))
          {
@@ -171,7 +184,7 @@
                ret = NULL;
             }
 
-            if(png_ptr->zlib_window_bits > 14)
+            if (png_ptr->zlib_window_bits > 14)
                num_blocks = (int)(1 << (png_ptr->zlib_window_bits - 14));
             else
                num_blocks = 1;
@@ -188,7 +201,7 @@
             {
 #ifndef PNG_USER_MEM_SUPPORTED
                if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-                  png_error(png_ptr, "Out Of Memory."); /* Note "O" and "M" */
+                  png_error(png_ptr, "Out Of Memory."); /* Note "O", "M" */
                else
                   png_warning(png_ptr, "Out Of Memory.");
 #endif
@@ -210,13 +223,13 @@
 
             png_ptr->offset_table = table;
             png_ptr->offset_table_ptr = farmalloc(num_blocks *
-               png_sizeof (png_bytep));
+               png_sizeof(png_bytep));
 
             if (png_ptr->offset_table_ptr == NULL)
             {
 #ifndef PNG_USER_MEM_SUPPORTED
                if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-                  png_error(png_ptr, "Out Of memory."); /* Note "O" and "M" */
+                  png_error(png_ptr, "Out Of memory."); /* Note "O", "m" */
                else
                   png_warning(png_ptr, "Out Of memory.");
 #endif
@@ -270,9 +283,10 @@
    return (ret);
 }
 
-/* free a pointer allocated by png_malloc().  In the default
-   configuration, png_ptr is not used, but is passed in case it
-   is needed.  If ptr is NULL, return without taking any action. */
+/* Free a pointer allocated by png_malloc().  In the default
+ * configuration, png_ptr is not used, but is passed in case it
+ * is needed.  If ptr is NULL, return without taking any action.
+ */
 void PNGAPI
 png_free(png_structp png_ptr, png_voidp ptr)
 {
@@ -285,7 +299,8 @@
       (*(png_ptr->free_fn))(png_ptr, ptr);
       return;
    }
-   else png_free_default(png_ptr, ptr);
+   else
+      png_free_default(png_ptr, ptr);
 }
 
 void PNGAPI
@@ -293,7 +308,8 @@
 {
 #endif /* PNG_USER_MEM_SUPPORTED */
 
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL || ptr == NULL)
+      return;
 
    if (png_ptr->offset_table != NULL)
    {
@@ -353,7 +369,7 @@
       return (NULL);
 
 #ifdef PNG_USER_MEM_SUPPORTED
-   if(malloc_fn != NULL)
+   if (malloc_fn != NULL)
    {
       png_struct dummy_struct;
       png_structp png_ptr = &dummy_struct;
@@ -369,7 +385,7 @@
    struct_ptr = (png_voidp)farmalloc(size);
 #else
 # if defined(_MSC_VER) && defined(MAXSEG_64K)
-   struct_ptr = (png_voidp)halloc(size,1);
+   struct_ptr = (png_voidp)halloc(size, 1);
 # else
    struct_ptr = (png_voidp)malloc(size);
 # endif
@@ -398,7 +414,7 @@
    if (struct_ptr != NULL)
    {
 #ifdef PNG_USER_MEM_SUPPORTED
-      if(free_fn != NULL)
+      if (free_fn != NULL)
       {
          png_struct dummy_struct;
          png_structp png_ptr = &dummy_struct;
@@ -420,10 +436,22 @@
 }
 
 /* Allocate memory.  For reasonable files, size should never exceed
-   64K.  However, zlib may allocate more then 64K if you don't tell
-   it not to.  See zconf.h and png.h for more information.  zlib does
-   need to allocate exactly 64K, so whatever you call here must
-   have the ability to do that. */
+ * 64K.  However, zlib may allocate more then 64K if you don't tell
+ * it not to.  See zconf.h and png.h for more information.  zlib does
+ * need to allocate exactly 64K, so whatever you call here must
+ * have the ability to do that.
+ */
+
+png_voidp /* PRIVATE */
+png_calloc(png_structp png_ptr, png_uint_32 size)
+{
+   png_voidp ret;
+
+   ret = (png_malloc(png_ptr, size));
+   if (ret != NULL)
+      png_memset(ret,0,(png_size_t)size);
+   return (ret);
+}
 
 png_voidp PNGAPI
 png_malloc(png_structp png_ptr, png_uint_32 size)
@@ -434,10 +462,10 @@
    if (png_ptr == NULL || size == 0)
       return (NULL);
 
-   if(png_ptr->malloc_fn != NULL)
-       ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
+   if (png_ptr->malloc_fn != NULL)
+      ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
    else
-       ret = (png_malloc_default(png_ptr, size));
+      ret = (png_malloc_default(png_ptr, size));
    if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
        png_error(png_ptr, "Out of Memory!");
    return (ret);
@@ -456,7 +484,7 @@
    if (size > (png_uint_32)65536L)
    {
 #ifndef PNG_USER_MEM_SUPPORTED
-      if(png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
+      if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
          png_error(png_ptr, "Cannot Allocate > 64K");
       else
 #endif
@@ -464,23 +492,23 @@
    }
 #endif
 
- /* Check for overflow */
+   /* Check for overflow */
 #if defined(__TURBOC__) && !defined(__FLAT__)
- if (size != (unsigned long)size)
-   ret = NULL;
- else
-   ret = farmalloc(size);
+   if (size != (unsigned long)size)
+      ret = NULL;
+   else
+      ret = farmalloc(size);
 #else
 # if defined(_MSC_VER) && defined(MAXSEG_64K)
- if (size != (unsigned long)size)
-   ret = NULL;
- else
-   ret = halloc(size, 1);
+   if (size != (unsigned long)size)
+      ret = NULL;
+   else
+      ret = halloc(size, 1);
 # else
- if (size != (size_t)size)
-   ret = NULL;
- else
-   ret = malloc((size_t)size);
+   if (size != (size_t)size)
+      ret = NULL;
+   else
+      ret = malloc((size_t)size);
 # endif
 #endif
 
@@ -493,7 +521,8 @@
 }
 
 /* Free a pointer allocated by png_malloc().  If ptr is NULL, return
-   without taking any action. */
+ * without taking any action.
+ */
 void PNGAPI
 png_free(png_structp png_ptr, png_voidp ptr)
 {
@@ -506,7 +535,8 @@
       (*(png_ptr->free_fn))(png_ptr, ptr);
       return;
    }
-   else png_free_default(png_ptr, ptr);
+   else
+      png_free_default(png_ptr, ptr);
 }
 void PNGAPI
 png_free_default(png_structp png_ptr, png_voidp ptr)
@@ -529,7 +559,7 @@
 
 #endif /* Not Borland DOS special memory handler */
 
-#if defined(PNG_1_0_X)
+#ifdef PNG_1_0_X
 #  define png_malloc_warn png_malloc
 #else
 /* This function was added at libpng version 1.2.3.  The png_malloc_warn()
@@ -542,9 +572,10 @@
 {
    png_voidp ptr;
    png_uint_32 save_flags;
-   if(png_ptr == NULL) return (NULL);
+   if (png_ptr == NULL)
+      return (NULL);
 
-   save_flags=png_ptr->flags;
+   save_flags = png_ptr->flags;
    png_ptr->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;
    ptr = (png_voidp)png_malloc((png_structp)png_ptr, size);
    png_ptr->flags=save_flags;
@@ -560,7 +591,7 @@
 
    size = (png_size_t)length;
    if ((png_uint_32)size != length)
-      png_error(png_ptr,"Overflow in png_memcpy_check.");
+      png_error(png_ptr, "Overflow in png_memcpy_check.");
 
    return(png_memcpy (s1, s2, size));
 }
@@ -573,7 +604,7 @@
 
    size = (png_size_t)length;
    if ((png_uint_32)size != length)
-      png_error(png_ptr,"Overflow in png_memset_check.");
+      png_error(png_ptr, "Overflow in png_memset_check.");
 
    return (png_memset (s1, value, size));
 
@@ -587,10 +618,11 @@
 png_set_mem_fn(png_structp png_ptr, png_voidp mem_ptr, png_malloc_ptr
   malloc_fn, png_free_ptr free_fn)
 {
-   if(png_ptr != NULL) {
-   png_ptr->mem_ptr = mem_ptr;
-   png_ptr->malloc_fn = malloc_fn;
-   png_ptr->free_fn = free_fn;
+   if (png_ptr != NULL)
+   {
+      png_ptr->mem_ptr = mem_ptr;
+      png_ptr->malloc_fn = malloc_fn;
+      png_ptr->free_fn = free_fn;
    }
 }
 
@@ -601,7 +633,8 @@
 png_voidp PNGAPI
 png_get_mem_ptr(png_structp png_ptr)
 {
-   if(png_ptr == NULL) return (NULL);
+   if (png_ptr == NULL)
+      return (NULL);
    return ((png_voidp)png_ptr->mem_ptr);
 }
 #endif /* PNG_USER_MEM_SUPPORTED */
diff -Naur libAfterImage-1.20/libpng/pngpread.c root/graf2d/asimage/src/libAfterImage/libpng/pngpread.c
--- libAfterImage-1.20/libpng/pngpread.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngpread.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,19 +1,22 @@
 
 /* pngpread.c - read a png file in push mode
  *
- * Last changed in libpng 1.2.22 [November 6, 2007]
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.44 [June 26, 2010]
+ * Copyright (c) 1998-2010 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
  */
 
 #define PNG_INTERNAL
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
-
 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
 
-/* push model modes */
+/* Push model modes */
 #define PNG_READ_SIG_MODE   0
 #define PNG_READ_CHUNK_MODE 1
 #define PNG_READ_IDAT_MODE  2
@@ -28,7 +31,9 @@
 png_process_data(png_structp png_ptr, png_infop info_ptr,
    png_bytep buffer, png_size_t buffer_size)
 {
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL || info_ptr == NULL)
+      return;
+
    png_push_restore_buffer(png_ptr, buffer, buffer_size);
 
    while (png_ptr->buffer_size)
@@ -43,7 +48,9 @@
 void /* PRIVATE */
 png_process_some_data(png_structp png_ptr, png_infop info_ptr)
 {
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL)
+      return;
+
    switch (png_ptr->process_mode)
    {
       case PNG_READ_SIG_MODE:
@@ -51,42 +58,25 @@
          png_push_read_sig(png_ptr, info_ptr);
          break;
       }
+
       case PNG_READ_CHUNK_MODE:
       {
          png_push_read_chunk(png_ptr, info_ptr);
          break;
       }
+
       case PNG_READ_IDAT_MODE:
       {
          png_push_read_IDAT(png_ptr);
          break;
       }
-#if defined(PNG_READ_tEXt_SUPPORTED)
-      case PNG_READ_tEXt_MODE:
-      {
-         png_push_read_tEXt(png_ptr, info_ptr);
-         break;
-      }
-#endif
-#if defined(PNG_READ_zTXt_SUPPORTED)
-      case PNG_READ_zTXt_MODE:
-      {
-         png_push_read_zTXt(png_ptr, info_ptr);
-         break;
-      }
-#endif
-#if defined(PNG_READ_iTXt_SUPPORTED)
-      case PNG_READ_iTXt_MODE:
-      {
-         png_push_read_iTXt(png_ptr, info_ptr);
-         break;
-      }
-#endif
+
       case PNG_SKIP_MODE:
       {
          png_push_crc_finish(png_ptr);
          break;
       }
+
       default:
       {
          png_ptr->buffer_size = 0;
@@ -114,7 +104,7 @@
 
    png_push_fill_buffer(png_ptr, &(info_ptr->signature[num_checked]),
       num_to_check);
-   png_ptr->sig_bytes = (png_byte)(png_ptr->sig_bytes+num_to_check);
+   png_ptr->sig_bytes = (png_byte)(png_ptr->sig_bytes + num_to_check);
 
    if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check))
    {
@@ -141,58 +131,59 @@
       PNG_CONST PNG_IDAT;
       PNG_CONST PNG_IEND;
       PNG_CONST PNG_PLTE;
-#if defined(PNG_READ_bKGD_SUPPORTED)
+#ifdef PNG_READ_bKGD_SUPPORTED
       PNG_CONST PNG_bKGD;
 #endif
-#if defined(PNG_READ_cHRM_SUPPORTED)
+#ifdef PNG_READ_cHRM_SUPPORTED
       PNG_CONST PNG_cHRM;
 #endif
-#if defined(PNG_READ_gAMA_SUPPORTED)
+#ifdef PNG_READ_gAMA_SUPPORTED
       PNG_CONST PNG_gAMA;
 #endif
-#if defined(PNG_READ_hIST_SUPPORTED)
+#ifdef PNG_READ_hIST_SUPPORTED
       PNG_CONST PNG_hIST;
 #endif
-#if defined(PNG_READ_iCCP_SUPPORTED)
+#ifdef PNG_READ_iCCP_SUPPORTED
       PNG_CONST PNG_iCCP;
 #endif
-#if defined(PNG_READ_iTXt_SUPPORTED)
+#ifdef PNG_READ_iTXt_SUPPORTED
       PNG_CONST PNG_iTXt;
 #endif
-#if defined(PNG_READ_oFFs_SUPPORTED)
+#ifdef PNG_READ_oFFs_SUPPORTED
       PNG_CONST PNG_oFFs;
 #endif
-#if defined(PNG_READ_pCAL_SUPPORTED)
+#ifdef PNG_READ_pCAL_SUPPORTED
       PNG_CONST PNG_pCAL;
 #endif
-#if defined(PNG_READ_pHYs_SUPPORTED)
+#ifdef PNG_READ_pHYs_SUPPORTED
       PNG_CONST PNG_pHYs;
 #endif
-#if defined(PNG_READ_sBIT_SUPPORTED)
+#ifdef PNG_READ_sBIT_SUPPORTED
       PNG_CONST PNG_sBIT;
 #endif
-#if defined(PNG_READ_sCAL_SUPPORTED)
+#ifdef PNG_READ_sCAL_SUPPORTED
       PNG_CONST PNG_sCAL;
 #endif
-#if defined(PNG_READ_sRGB_SUPPORTED)
+#ifdef PNG_READ_sRGB_SUPPORTED
       PNG_CONST PNG_sRGB;
 #endif
-#if defined(PNG_READ_sPLT_SUPPORTED)
+#ifdef PNG_READ_sPLT_SUPPORTED
       PNG_CONST PNG_sPLT;
 #endif
-#if defined(PNG_READ_tEXt_SUPPORTED)
+#ifdef PNG_READ_tEXt_SUPPORTED
       PNG_CONST PNG_tEXt;
 #endif
-#if defined(PNG_READ_tIME_SUPPORTED)
+#ifdef PNG_READ_tIME_SUPPORTED
       PNG_CONST PNG_tIME;
 #endif
-#if defined(PNG_READ_tRNS_SUPPORTED)
+#ifdef PNG_READ_tRNS_SUPPORTED
       PNG_CONST PNG_tRNS;
 #endif
-#if defined(PNG_READ_zTXt_SUPPORTED)
+#ifdef PNG_READ_zTXt_SUPPORTED
       PNG_CONST PNG_zTXt;
 #endif
 #endif /* PNG_USE_LOCAL_ARRAYS */
+
    /* First we make sure we have enough data for the 4 byte chunk name
     * and the 4 byte chunk length before proceeding with decoding the
     * chunk data.  To fully decode each of these chunks, we also make
@@ -210,25 +201,31 @@
       }
 
       png_push_fill_buffer(png_ptr, chunk_length, 4);
-      png_ptr->push_length = png_get_uint_31(png_ptr,chunk_length);
+      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);
       png_reset_crc(png_ptr);
       png_crc_read(png_ptr, png_ptr->chunk_name, 4);
+      png_check_chunk_name(png_ptr, png_ptr->chunk_name);
       png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
    }
 
    if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
-     if(png_ptr->mode & PNG_AFTER_IDAT)
+     if (png_ptr->mode & PNG_AFTER_IDAT)
         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;
 
    if (!png_memcmp(png_ptr->chunk_name, png_IHDR, 4))
    {
+      if (png_ptr->push_length != 13)
+         png_error(png_ptr, "Invalid IHDR length");
+
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_IHDR(png_ptr, info_ptr, png_ptr->push_length);
    }
+
    else if (!png_memcmp(png_ptr->chunk_name, png_IEND, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -236,11 +233,13 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_IEND(png_ptr, info_ptr, png_ptr->push_length);
 
       png_ptr->process_mode = PNG_READ_DONE_MODE;
       png_push_have_end(png_ptr, info_ptr);
    }
+
 #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
    else if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name))
    {
@@ -249,20 +248,26 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
          png_ptr->mode |= PNG_HAVE_IDAT;
+
       png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
+
       if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
          png_ptr->mode |= PNG_HAVE_PLTE;
+
       else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
       {
          if (!(png_ptr->mode & PNG_HAVE_IHDR))
             png_error(png_ptr, "Missing IHDR before IDAT");
+
          else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
                   !(png_ptr->mode & PNG_HAVE_PLTE))
             png_error(png_ptr, "Missing PLTE before IDAT");
       }
    }
+
 #endif
    else if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
    {
@@ -273,23 +278,26 @@
       }
       png_handle_PLTE(png_ptr, info_ptr, png_ptr->push_length);
    }
+
    else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
    {
       /* If we reach an IDAT chunk, this means we have read all of the
        * header chunks, and we can start reading the image (or if this
        * is called after the image has been read - we have an error).
        */
-     if (!(png_ptr->mode & PNG_HAVE_IHDR))
-       png_error(png_ptr, "Missing IHDR before IDAT");
-     else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
-         !(png_ptr->mode & PNG_HAVE_PLTE))
-       png_error(png_ptr, "Missing PLTE before IDAT");
+
+      if (!(png_ptr->mode & PNG_HAVE_IHDR))
+         png_error(png_ptr, "Missing IHDR before IDAT");
+
+      else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
+          !(png_ptr->mode & PNG_HAVE_PLTE))
+         png_error(png_ptr, "Missing PLTE before IDAT");
 
       if (png_ptr->mode & PNG_HAVE_IDAT)
       {
          if (!(png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))
-           if (png_ptr->push_length == 0)
-              return;
+            if (png_ptr->push_length == 0)
+               return;
 
          if (png_ptr->mode & PNG_AFTER_IDAT)
             png_error(png_ptr, "Too many IDAT's found");
@@ -299,11 +307,14 @@
       png_ptr->mode |= PNG_HAVE_IDAT;
       png_ptr->process_mode = PNG_READ_IDAT_MODE;
       png_push_have_info(png_ptr, info_ptr);
-      png_ptr->zstream.avail_out = (uInt)png_ptr->irowbytes;
+      png_ptr->zstream.avail_out =
+          (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,
+          png_ptr->iwidth) + 1;
       png_ptr->zstream.next_out = png_ptr->row_buf;
       return;
    }
-#if defined(PNG_READ_gAMA_SUPPORTED)
+
+#ifdef PNG_READ_gAMA_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_gAMA, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -311,10 +322,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_gAMA(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_sBIT_SUPPORTED)
+#ifdef PNG_READ_sBIT_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_sBIT, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -322,10 +335,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_sBIT(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_cHRM_SUPPORTED)
+#ifdef PNG_READ_cHRM_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_cHRM, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -333,10 +348,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_cHRM(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_sRGB_SUPPORTED)
+#ifdef PNG_READ_sRGB_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_sRGB, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -344,10 +361,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_sRGB(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_iCCP_SUPPORTED)
+#ifdef PNG_READ_iCCP_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_iCCP, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -355,10 +374,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_iCCP(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_sPLT_SUPPORTED)
+#ifdef PNG_READ_sPLT_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_sPLT, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -366,10 +387,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_sPLT(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_tRNS_SUPPORTED)
+#ifdef PNG_READ_tRNS_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_tRNS, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -377,10 +400,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_tRNS(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_bKGD_SUPPORTED)
+#ifdef PNG_READ_bKGD_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_bKGD, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -388,10 +413,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_bKGD(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_hIST_SUPPORTED)
+#ifdef PNG_READ_hIST_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_hIST, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -399,10 +426,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_hIST(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_pHYs_SUPPORTED)
+#ifdef PNG_READ_pHYs_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_pHYs, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -410,10 +439,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_pHYs(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_oFFs_SUPPORTED)
+#ifdef PNG_READ_oFFs_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_oFFs, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -421,10 +452,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_oFFs(png_ptr, info_ptr, png_ptr->push_length);
    }
 #endif
-#if defined(PNG_READ_pCAL_SUPPORTED)
+
+#ifdef PNG_READ_pCAL_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_pCAL, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -432,10 +465,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_pCAL(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_sCAL_SUPPORTED)
+#ifdef PNG_READ_sCAL_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_sCAL, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -443,10 +478,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_sCAL(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_tIME_SUPPORTED)
+#ifdef PNG_READ_tIME_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_tIME, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -454,10 +491,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
+
       png_handle_tIME(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_tEXt_SUPPORTED)
+#ifdef PNG_READ_tEXt_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_tEXt, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -465,10 +504,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
-      png_push_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);
+
+      png_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_zTXt_SUPPORTED)
+#ifdef PNG_READ_zTXt_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_zTXt, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -476,10 +517,12 @@
          png_push_save_buffer(png_ptr);
          return;
       }
-      png_push_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);
+
+      png_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
-#if defined(PNG_READ_iTXt_SUPPORTED)
+#ifdef PNG_READ_iTXt_SUPPORTED
    else if (!png_memcmp(png_ptr->chunk_name, png_iTXt, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -487,8 +530,10 @@
          png_push_save_buffer(png_ptr);
          return;
       }
-      png_push_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
+
+      png_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
    }
+
 #endif
    else
    {
@@ -497,7 +542,7 @@
          png_push_save_buffer(png_ptr);
          return;
       }
-      png_push_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
+      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
    }
 
    png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
@@ -563,7 +608,9 @@
 {
    png_bytep ptr;
 
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL)
+      return;
+
    ptr = buffer;
    if (png_ptr->save_buffer_size)
    {
@@ -587,6 +634,7 @@
 
       if (length < png_ptr->current_buffer_size)
          save_size = length;
+
       else
          save_size = png_ptr->current_buffer_size;
 
@@ -604,7 +652,7 @@
    {
       if (png_ptr->save_buffer_ptr != png_ptr->save_buffer)
       {
-         png_size_t i,istop;
+         png_size_t i, istop;
          png_bytep sp;
          png_bytep dp;
 
@@ -627,13 +675,22 @@
       {
         png_error(png_ptr, "Potential overflow of save_buffer");
       }
+
       new_max = png_ptr->save_buffer_size + png_ptr->current_buffer_size + 256;
       old_buffer = png_ptr->save_buffer;
-      png_ptr->save_buffer = (png_bytep)png_malloc(png_ptr,
+      png_ptr->save_buffer = (png_bytep)png_malloc_warn(png_ptr,
          (png_uint_32)new_max);
-      png_memcpy(png_ptr->save_buffer, old_buffer, png_ptr->save_buffer_size);
-      png_free(png_ptr, old_buffer);
-      png_ptr->save_buffer_max = new_max;
+      if (png_ptr->save_buffer == NULL)
+      {
+        png_free(png_ptr, old_buffer);
+        png_error(png_ptr, "Insufficient memory for save_buffer");
+      }
+      else
+      {
+        png_memcpy(png_ptr->save_buffer, old_buffer, png_ptr->save_buffer_size);
+        png_free(png_ptr, old_buffer);
+        png_ptr->save_buffer_max = new_max;
+      }
    }
    if (png_ptr->current_buffer_size)
    {
@@ -673,7 +730,7 @@
       }
 
       png_push_fill_buffer(png_ptr, chunk_length, 4);
-      png_ptr->push_length = png_get_uint_31(png_ptr,chunk_length);
+      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);
       png_reset_crc(png_ptr);
       png_crc_read(png_ptr, png_ptr->chunk_name, 4);
       png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
@@ -695,16 +752,18 @@
       if (png_ptr->idat_size < (png_uint_32)png_ptr->save_buffer_size)
       {
          save_size = (png_size_t)png_ptr->idat_size;
-         /* check for overflow */
-         if((png_uint_32)save_size != png_ptr->idat_size)
+
+         /* Check for overflow */
+         if ((png_uint_32)save_size != png_ptr->idat_size)
             png_error(png_ptr, "save_size overflowed in pngpread");
       }
       else
          save_size = png_ptr->save_buffer_size;
 
       png_calculate_crc(png_ptr, png_ptr->save_buffer_ptr, save_size);
-      if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
-         png_process_IDAT_data(png_ptr, png_ptr->save_buffer_ptr, save_size);
+
+      png_process_IDAT_data(png_ptr, png_ptr->save_buffer_ptr, save_size);
+
       png_ptr->idat_size -= save_size;
       png_ptr->buffer_size -= save_size;
       png_ptr->save_buffer_size -= save_size;
@@ -717,16 +776,17 @@
       if (png_ptr->idat_size < (png_uint_32)png_ptr->current_buffer_size)
       {
          save_size = (png_size_t)png_ptr->idat_size;
-         /* check for overflow */
-         if((png_uint_32)save_size != png_ptr->idat_size)
+
+         /* Check for overflow */
+         if ((png_uint_32)save_size != png_ptr->idat_size)
             png_error(png_ptr, "save_size overflowed in pngpread");
       }
       else
          save_size = png_ptr->current_buffer_size;
 
       png_calculate_crc(png_ptr, png_ptr->current_buffer_ptr, save_size);
-      if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
-        png_process_IDAT_data(png_ptr, png_ptr->current_buffer_ptr, save_size);
+
+      png_process_IDAT_data(png_ptr, png_ptr->current_buffer_ptr, save_size);
 
       png_ptr->idat_size -= save_size;
       png_ptr->buffer_size -= save_size;
@@ -751,57 +811,101 @@
 png_process_IDAT_data(png_structp png_ptr, png_bytep buffer,
    png_size_t buffer_length)
 {
-   int ret;
-
-   if ((png_ptr->flags & PNG_FLAG_ZLIB_FINISHED) && buffer_length)
-      png_error(png_ptr, "Extra compression data");
-
+   /* The caller checks for a non-zero buffer length. */
+   if (!(buffer_length > 0) || buffer == NULL)
+      png_error(png_ptr, "No IDAT data (internal error)");
+
+   /* This routine must process all the data it has been given
+    * before returning, calling the row callback as required to
+    * handle the uncompressed results.
+    */
    png_ptr->zstream.next_in = buffer;
    png_ptr->zstream.avail_in = (uInt)buffer_length;
-   for(;;)
+
+   /* Keep going until the decompressed data is all processed
+    * or the stream marked as finished.
+    */
+   while (png_ptr->zstream.avail_in > 0 &&
+	  !(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
    {
-      ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
-      if (ret != Z_OK)
+      int ret;
+
+      /* We have data for zlib, but we must check that zlib
+       * has somewhere to put the results.  It doesn't matter
+       * if we don't expect any results -- it may be the input
+       * data is just the LZ end code.
+       */
+      if (!(png_ptr->zstream.avail_out > 0))
       {
-         if (ret == Z_STREAM_END)
-         {
-            if (png_ptr->zstream.avail_in)
-               png_error(png_ptr, "Extra compressed data");
-            if (!(png_ptr->zstream.avail_out))
-            {
-               png_push_process_row(png_ptr);
-            }
+         png_ptr->zstream.avail_out =
+             (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,
+             png_ptr->iwidth) + 1;
+         png_ptr->zstream.next_out = png_ptr->row_buf;
+      }
 
-            png_ptr->mode |= PNG_AFTER_IDAT;
-            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
-            break;
-         }
-         else if (ret == Z_BUF_ERROR)
-            break;
-         else
-            png_error(png_ptr, "Decompression Error");
+      /* Using Z_SYNC_FLUSH here means that an unterminated
+       * LZ stream can still be handled (a stream with a missing
+       * end code), otherwise (Z_NO_FLUSH) a future zlib
+       * implementation might defer output and, therefore,
+       * change the current behavior.  (See comments in inflate.c
+       * for why this doesn't happen at present with zlib 1.2.5.)
+       */
+      ret = inflate(&png_ptr->zstream, Z_SYNC_FLUSH);
+
+      /* Check for any failure before proceeding. */
+      if (ret != Z_OK && ret != Z_STREAM_END)
+      {
+	 /* Terminate the decompression. */
+	 png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
+
+         /* This may be a truncated stream (missing or
+	  * damaged end code).  Treat that as a warning.
+	  */
+         if (png_ptr->row_number >= png_ptr->num_rows ||
+	     png_ptr->pass > 6)
+	    png_warning(png_ptr, "Truncated compressed data in IDAT");
+	 else
+	    png_error(png_ptr, "Decompression error in IDAT");
+
+	 /* Skip the check on unprocessed input */
+         return;
       }
-      if (!(png_ptr->zstream.avail_out))
+
+      /* Did inflate output any data? */
+      if (png_ptr->zstream.next_out != png_ptr->row_buf)
       {
-         if ((
-#if defined(PNG_READ_INTERLACING_SUPPORTED)
-             png_ptr->interlaced && png_ptr->pass > 6) ||
-             (!png_ptr->interlaced &&
-#endif
-             png_ptr->row_number == png_ptr->num_rows))
+	 /* Is this unexpected data after the last row?
+	  * If it is, artificially terminate the LZ output
+	  * here.
+	  */
+         if (png_ptr->row_number >= png_ptr->num_rows ||
+	     png_ptr->pass > 6)
          {
-           if (png_ptr->zstream.avail_in)
-             png_warning(png_ptr, "Too much data in IDAT chunks");
-           png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
-           break;
-         }
-         png_push_process_row(png_ptr);
-         png_ptr->zstream.avail_out = (uInt)png_ptr->irowbytes;
-         png_ptr->zstream.next_out = png_ptr->row_buf;
+	    /* Extra data. */
+	    png_warning(png_ptr, "Extra compressed data in IDAT");
+            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
+	    /* Do no more processing; skip the unprocessed
+	     * input check below.
+	     */
+            return;
+	 }
+
+	 /* Do we have a complete row? */
+	 if (png_ptr->zstream.avail_out == 0)
+	    png_push_process_row(png_ptr);
       }
-      else
-         break;
+
+      /* And check for the end of the stream. */
+      if (ret == Z_STREAM_END)
+	 png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
    }
+
+   /* All the data should have been processed, if anything
+    * is left at this point we have bytes of IDAT data
+    * after the zlib end code.
+    */
+   if (png_ptr->zstream.avail_in > 0)
+      png_warning(png_ptr, "Extra compression data");
 }
 
 void /* PRIVATE */
@@ -817,8 +921,8 @@
        png_ptr->row_info.width);
 
    png_read_filter_row(png_ptr, &(png_ptr->row_info),
-      png_ptr->row_buf + 1, png_ptr->prev_row + 1,
-      (int)(png_ptr->row_buf[0]));
+       png_ptr->row_buf + 1, png_ptr->prev_row + 1,
+       (int)(png_ptr->row_buf[0]));
 
    png_memcpy_check(png_ptr, png_ptr->prev_row, png_ptr->row_buf,
       png_ptr->rowbytes + 1);
@@ -826,14 +930,14 @@
    if (png_ptr->transformations || (png_ptr->flags&PNG_FLAG_STRIP_ALPHA))
       png_do_read_transformations(png_ptr);
 
-#if defined(PNG_READ_INTERLACING_SUPPORTED)
-   /* blow up interlaced rows to full size */
+#ifdef PNG_READ_INTERLACING_SUPPORTED
+   /* Blow up interlaced rows to full size */
    if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))
    {
       if (png_ptr->pass < 6)
 /*       old interface (pre-1.0.9):
          png_do_read_interlace(&(png_ptr->row_info),
-            png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations);
+             png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations);
  */
          png_do_read_interlace(png_ptr);
 
@@ -845,9 +949,10 @@
             for (i = 0; i < 8 && png_ptr->pass == 0; i++)
             {
                png_push_have_row(png_ptr, png_ptr->row_buf + 1);
-               png_read_push_finish_row(png_ptr); /* updates png_ptr->pass */
+               png_read_push_finish_row(png_ptr); /* Updates png_ptr->pass */
             }
-            if (png_ptr->pass == 2) /* pass 1 might be empty */
+
+            if (png_ptr->pass == 2) /* Pass 1 might be empty */
             {
                for (i = 0; i < 4 && png_ptr->pass == 2; i++)
                {
@@ -855,6 +960,7 @@
                   png_read_push_finish_row(png_ptr);
                }
             }
+
             if (png_ptr->pass == 4 && png_ptr->height <= 4)
             {
                for (i = 0; i < 2 && png_ptr->pass == 4; i++)
@@ -863,13 +969,16 @@
                   png_read_push_finish_row(png_ptr);
                }
             }
+
             if (png_ptr->pass == 6 && png_ptr->height <= 4)
             {
-                png_push_have_row(png_ptr, png_bytep_NULL);
+                  png_push_have_row(png_ptr, png_bytep_NULL);
                 png_read_push_finish_row(png_ptr);
             }
+
             break;
          }
+
          case 1:
          {
             int i;
@@ -878,7 +987,8 @@
                png_push_have_row(png_ptr, png_ptr->row_buf + 1);
                png_read_push_finish_row(png_ptr);
             }
-            if (png_ptr->pass == 2) /* skip top 4 generated rows */
+
+            if (png_ptr->pass == 2) /* Skip top 4 generated rows */
             {
                for (i = 0; i < 4 && png_ptr->pass == 2; i++)
                {
@@ -886,22 +996,27 @@
                   png_read_push_finish_row(png_ptr);
                }
             }
+
             break;
          }
+
          case 2:
          {
             int i;
+
             for (i = 0; i < 4 && png_ptr->pass == 2; i++)
             {
                png_push_have_row(png_ptr, png_ptr->row_buf + 1);
                png_read_push_finish_row(png_ptr);
             }
+
             for (i = 0; i < 4 && png_ptr->pass == 2; i++)
             {
-               png_push_have_row(png_ptr, png_bytep_NULL);
+                  png_push_have_row(png_ptr, png_bytep_NULL);
                png_read_push_finish_row(png_ptr);
             }
-            if (png_ptr->pass == 4) /* pass 3 might be empty */
+
+            if (png_ptr->pass == 4) /* Pass 3 might be empty */
             {
                for (i = 0; i < 2 && png_ptr->pass == 4; i++)
                {
@@ -909,17 +1024,21 @@
                   png_read_push_finish_row(png_ptr);
                }
             }
+
             break;
          }
+
          case 3:
          {
             int i;
+
             for (i = 0; i < 4 && png_ptr->pass == 3; i++)
             {
                png_push_have_row(png_ptr, png_ptr->row_buf + 1);
                png_read_push_finish_row(png_ptr);
             }
-            if (png_ptr->pass == 4) /* skip top two generated rows */
+
+            if (png_ptr->pass == 4) /* Skip top two generated rows */
             {
                for (i = 0; i < 2 && png_ptr->pass == 4; i++)
                {
@@ -927,50 +1046,62 @@
                   png_read_push_finish_row(png_ptr);
                }
             }
+
             break;
          }
+
          case 4:
          {
             int i;
+
             for (i = 0; i < 2 && png_ptr->pass == 4; i++)
             {
                png_push_have_row(png_ptr, png_ptr->row_buf + 1);
                png_read_push_finish_row(png_ptr);
             }
+
             for (i = 0; i < 2 && png_ptr->pass == 4; i++)
             {
-               png_push_have_row(png_ptr, png_bytep_NULL);
+                  png_push_have_row(png_ptr, png_bytep_NULL);
                png_read_push_finish_row(png_ptr);
             }
-            if (png_ptr->pass == 6) /* pass 5 might be empty */
+
+            if (png_ptr->pass == 6) /* Pass 5 might be empty */
             {
-               png_push_have_row(png_ptr, png_bytep_NULL);
+                  png_push_have_row(png_ptr, png_bytep_NULL);
                png_read_push_finish_row(png_ptr);
             }
+
             break;
          }
+
          case 5:
          {
             int i;
+
             for (i = 0; i < 2 && png_ptr->pass == 5; i++)
             {
                png_push_have_row(png_ptr, png_ptr->row_buf + 1);
                png_read_push_finish_row(png_ptr);
             }
-            if (png_ptr->pass == 6) /* skip top generated row */
+
+            if (png_ptr->pass == 6) /* Skip top generated row */
             {
-               png_push_have_row(png_ptr, png_bytep_NULL);
+                  png_push_have_row(png_ptr, png_bytep_NULL);
                png_read_push_finish_row(png_ptr);
             }
+
             break;
          }
          case 6:
          {
             png_push_have_row(png_ptr, png_ptr->row_buf + 1);
             png_read_push_finish_row(png_ptr);
+
             if (png_ptr->pass != 6)
                break;
-            png_push_have_row(png_ptr, png_bytep_NULL);
+
+                  png_push_have_row(png_ptr, png_bytep_NULL);
             png_read_push_finish_row(png_ptr);
          }
       }
@@ -987,18 +1118,18 @@
 png_read_push_finish_row(png_structp png_ptr)
 {
 #ifdef PNG_USE_LOCAL_ARRAYS
-   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
+   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
-   /* start of interlace block */
+   /* Start of interlace block */
    PNG_CONST int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
 
-   /* offset to next interlace block */
+   /* Offset to next interlace block */
    PNG_CONST int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
 
-   /* start of interlace block in the y direction */
+   /* Start of interlace block in the y direction */
    PNG_CONST int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
 
-   /* offset to next interlace block in the y direction */
+   /* Offset to next interlace block in the y direction */
    PNG_CONST int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
 
    /* Height of interlace block.  This is not currently used - if you need
@@ -1011,6 +1142,7 @@
    if (png_ptr->row_number < png_ptr->num_rows)
       return;
 
+#ifdef PNG_READ_INTERLACING_SUPPORTED
    if (png_ptr->interlaced)
    {
       png_ptr->row_number = 0;
@@ -1026,6 +1158,7 @@
 
          if (png_ptr->pass > 7)
             png_ptr->pass--;
+
          if (png_ptr->pass >= 7)
             break;
 
@@ -1034,9 +1167,6 @@
             png_pass_start[png_ptr->pass]) /
             png_pass_inc[png_ptr->pass];
 
-         png_ptr->irowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,
-            png_ptr->iwidth) + 1;
-
          if (png_ptr->transformations & PNG_INTERLACE)
             break;
 
@@ -1047,486 +1177,7 @@
 
       } while (png_ptr->iwidth == 0 || png_ptr->num_rows == 0);
    }
-}
-
-#if defined(PNG_READ_tEXt_SUPPORTED)
-void /* PRIVATE */
-png_push_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
-   length)
-{
-   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
-      {
-         png_error(png_ptr, "Out of place tEXt");
-         info_ptr = info_ptr; /* to quiet some compiler warnings */
-      }
-
-#ifdef PNG_MAX_MALLOC_64K
-   png_ptr->skip_length = 0;  /* This may not be necessary */
-
-   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */
-   {
-      png_warning(png_ptr, "tEXt chunk too large to fit in memory");
-      png_ptr->skip_length = length - (png_uint_32)65535L;
-      length = (png_uint_32)65535L;
-   }
-#endif
-
-   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
-         (png_uint_32)(length+1));
-   png_ptr->current_text[length] = '\0';
-   png_ptr->current_text_ptr = png_ptr->current_text;
-   png_ptr->current_text_size = (png_size_t)length;
-   png_ptr->current_text_left = (png_size_t)length;
-   png_ptr->process_mode = PNG_READ_tEXt_MODE;
-}
-
-void /* PRIVATE */
-png_push_read_tEXt(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr->buffer_size && png_ptr->current_text_left)
-   {
-      png_size_t text_size;
-
-      if (png_ptr->buffer_size < png_ptr->current_text_left)
-         text_size = png_ptr->buffer_size;
-      else
-         text_size = png_ptr->current_text_left;
-      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
-      png_ptr->current_text_left -= text_size;
-      png_ptr->current_text_ptr += text_size;
-   }
-   if (!(png_ptr->current_text_left))
-   {
-      png_textp text_ptr;
-      png_charp text;
-      png_charp key;
-      int ret;
-
-      if (png_ptr->buffer_size < 4)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_crc_finish(png_ptr);
-
-#if defined(PNG_MAX_MALLOC_64K)
-      if (png_ptr->skip_length)
-         return;
-#endif
-
-      key = png_ptr->current_text;
-
-      for (text = key; *text; text++)
-         /* empty loop */ ;
-
-      if (text < key + png_ptr->current_text_size)
-         text++;
-
-      text_ptr = (png_textp)png_malloc(png_ptr,
-         (png_uint_32)png_sizeof(png_text));
-      text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;
-      text_ptr->key = key;
-#ifdef PNG_iTXt_SUPPORTED
-      text_ptr->lang = NULL;
-      text_ptr->lang_key = NULL;
-#endif
-      text_ptr->text = text;
-
-      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-      png_free(png_ptr, key);
-      png_free(png_ptr, text_ptr);
-      png_ptr->current_text = NULL;
-
-      if (ret)
-        png_warning(png_ptr, "Insufficient memory to store text chunk.");
-   }
-}
-#endif
-
-#if defined(PNG_READ_zTXt_SUPPORTED)
-void /* PRIVATE */
-png_push_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
-   length)
-{
-   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
-      {
-         png_error(png_ptr, "Out of place zTXt");
-         info_ptr = info_ptr; /* to quiet some compiler warnings */
-      }
-
-#ifdef PNG_MAX_MALLOC_64K
-   /* We can't handle zTXt chunks > 64K, since we don't have enough space
-    * to be able to store the uncompressed data.  Actually, the threshold
-    * is probably around 32K, but it isn't as definite as 64K is.
-    */
-   if (length > (png_uint_32)65535L)
-   {
-      png_warning(png_ptr, "zTXt chunk too large to fit in memory");
-      png_push_crc_skip(png_ptr, length);
-      return;
-   }
-#endif
-
-   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
-       (png_uint_32)(length+1));
-   png_ptr->current_text[length] = '\0';
-   png_ptr->current_text_ptr = png_ptr->current_text;
-   png_ptr->current_text_size = (png_size_t)length;
-   png_ptr->current_text_left = (png_size_t)length;
-   png_ptr->process_mode = PNG_READ_zTXt_MODE;
-}
-
-void /* PRIVATE */
-png_push_read_zTXt(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr->buffer_size && png_ptr->current_text_left)
-   {
-      png_size_t text_size;
-
-      if (png_ptr->buffer_size < (png_uint_32)png_ptr->current_text_left)
-         text_size = png_ptr->buffer_size;
-      else
-         text_size = png_ptr->current_text_left;
-      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
-      png_ptr->current_text_left -= text_size;
-      png_ptr->current_text_ptr += text_size;
-   }
-   if (!(png_ptr->current_text_left))
-   {
-      png_textp text_ptr;
-      png_charp text;
-      png_charp key;
-      int ret;
-      png_size_t text_size, key_size;
-
-      if (png_ptr->buffer_size < 4)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_crc_finish(png_ptr);
-
-      key = png_ptr->current_text;
-
-      for (text = key; *text; text++)
-         /* empty loop */ ;
-
-      /* zTXt can't have zero text */
-      if (text >= key + png_ptr->current_text_size)
-      {
-         png_ptr->current_text = NULL;
-         png_free(png_ptr, key);
-         return;
-      }
-
-      text++;
-
-      if (*text != PNG_TEXT_COMPRESSION_zTXt) /* check compression byte */
-      {
-         png_ptr->current_text = NULL;
-         png_free(png_ptr, key);
-         return;
-      }
-
-      text++;
-
-      png_ptr->zstream.next_in = (png_bytep )text;
-      png_ptr->zstream.avail_in = (uInt)(png_ptr->current_text_size -
-         (text - key));
-      png_ptr->zstream.next_out = png_ptr->zbuf;
-      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-
-      key_size = text - key;
-      text_size = 0;
-      text = NULL;
-      ret = Z_STREAM_END;
-
-      while (png_ptr->zstream.avail_in)
-      {
-         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
-         if (ret != Z_OK && ret != Z_STREAM_END)
-         {
-            inflateReset(&png_ptr->zstream);
-            png_ptr->zstream.avail_in = 0;
-            png_ptr->current_text = NULL;
-            png_free(png_ptr, key);
-            png_free(png_ptr, text);
-            return;
-         }
-         if (!(png_ptr->zstream.avail_out) || ret == Z_STREAM_END)
-         {
-            if (text == NULL)
-            {
-               text = (png_charp)png_malloc(png_ptr,
-                  (png_uint_32)(png_ptr->zbuf_size - png_ptr->zstream.avail_out
-                     + key_size + 1));
-               png_memcpy(text + key_size, png_ptr->zbuf,
-                  png_ptr->zbuf_size - png_ptr->zstream.avail_out);
-               png_memcpy(text, key, key_size);
-               text_size = key_size + png_ptr->zbuf_size -
-                  png_ptr->zstream.avail_out;
-               *(text + text_size) = '\0';
-            }
-            else
-            {
-               png_charp tmp;
-
-               tmp = text;
-               text = (png_charp)png_malloc(png_ptr, text_size +
-                  (png_uint_32)(png_ptr->zbuf_size - png_ptr->zstream.avail_out
-                   + 1));
-               png_memcpy(text, tmp, text_size);
-               png_free(png_ptr, tmp);
-               png_memcpy(text + text_size, png_ptr->zbuf,
-                  png_ptr->zbuf_size - png_ptr->zstream.avail_out);
-               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;
-               *(text + text_size) = '\0';
-            }
-            if (ret != Z_STREAM_END)
-            {
-               png_ptr->zstream.next_out = png_ptr->zbuf;
-               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-            }
-         }
-         else
-         {
-            break;
-         }
-
-         if (ret == Z_STREAM_END)
-            break;
-      }
-
-      inflateReset(&png_ptr->zstream);
-      png_ptr->zstream.avail_in = 0;
-
-      if (ret != Z_STREAM_END)
-      {
-         png_ptr->current_text = NULL;
-         png_free(png_ptr, key);
-         png_free(png_ptr, text);
-         return;
-      }
-
-      png_ptr->current_text = NULL;
-      png_free(png_ptr, key);
-      key = text;
-      text += key_size;
-
-      text_ptr = (png_textp)png_malloc(png_ptr,
-          (png_uint_32)png_sizeof(png_text));
-      text_ptr->compression = PNG_TEXT_COMPRESSION_zTXt;
-      text_ptr->key = key;
-#ifdef PNG_iTXt_SUPPORTED
-      text_ptr->lang = NULL;
-      text_ptr->lang_key = NULL;
-#endif
-      text_ptr->text = text;
-
-      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-      png_free(png_ptr, key);
-      png_free(png_ptr, text_ptr);
-
-      if (ret)
-        png_warning(png_ptr, "Insufficient memory to store text chunk.");
-   }
-}
-#endif
-
-#if defined(PNG_READ_iTXt_SUPPORTED)
-void /* PRIVATE */
-png_push_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
-   length)
-{
-   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
-      {
-         png_error(png_ptr, "Out of place iTXt");
-         info_ptr = info_ptr; /* to quiet some compiler warnings */
-      }
-
-#ifdef PNG_MAX_MALLOC_64K
-   png_ptr->skip_length = 0;  /* This may not be necessary */
-
-   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */
-   {
-      png_warning(png_ptr, "iTXt chunk too large to fit in memory");
-      png_ptr->skip_length = length - (png_uint_32)65535L;
-      length = (png_uint_32)65535L;
-   }
-#endif
-
-   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
-         (png_uint_32)(length+1));
-   png_ptr->current_text[length] = '\0';
-   png_ptr->current_text_ptr = png_ptr->current_text;
-   png_ptr->current_text_size = (png_size_t)length;
-   png_ptr->current_text_left = (png_size_t)length;
-   png_ptr->process_mode = PNG_READ_iTXt_MODE;
-}
-
-void /* PRIVATE */
-png_push_read_iTXt(png_structp png_ptr, png_infop info_ptr)
-{
-
-   if (png_ptr->buffer_size && png_ptr->current_text_left)
-   {
-      png_size_t text_size;
-
-      if (png_ptr->buffer_size < png_ptr->current_text_left)
-         text_size = png_ptr->buffer_size;
-      else
-         text_size = png_ptr->current_text_left;
-      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
-      png_ptr->current_text_left -= text_size;
-      png_ptr->current_text_ptr += text_size;
-   }
-   if (!(png_ptr->current_text_left))
-   {
-      png_textp text_ptr;
-      png_charp key;
-      int comp_flag;
-      png_charp lang;
-      png_charp lang_key;
-      png_charp text;
-      int ret;
-
-      if (png_ptr->buffer_size < 4)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_crc_finish(png_ptr);
-
-#if defined(PNG_MAX_MALLOC_64K)
-      if (png_ptr->skip_length)
-         return;
-#endif
-
-      key = png_ptr->current_text;
-
-      for (lang = key; *lang; lang++)
-         /* empty loop */ ;
-
-      if (lang < key + png_ptr->current_text_size - 3)
-         lang++;
-
-      comp_flag = *lang++;
-      lang++;     /* skip comp_type, always zero */
-
-      for (lang_key = lang; *lang_key; lang_key++)
-         /* empty loop */ ;
-      lang_key++;        /* skip NUL separator */
-
-      text=lang_key;
-      if (lang_key < key + png_ptr->current_text_size - 1)
-      {
-        for (; *text; text++)
-           /* empty loop */ ;
-      }
-
-      if (text < key + png_ptr->current_text_size)
-         text++;
-
-      text_ptr = (png_textp)png_malloc(png_ptr,
-         (png_uint_32)png_sizeof(png_text));
-      text_ptr->compression = comp_flag + 2;
-      text_ptr->key = key;
-      text_ptr->lang = lang;
-      text_ptr->lang_key = lang_key;
-      text_ptr->text = text;
-      text_ptr->text_length = 0;
-      text_ptr->itxt_length = png_strlen(text);
-
-      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-      png_ptr->current_text = NULL;
-
-      png_free(png_ptr, text_ptr);
-      if (ret)
-        png_warning(png_ptr, "Insufficient memory to store iTXt chunk.");
-   }
-}
-#endif
-
-/* This function is called when we haven't found a handler for this
- * chunk.  If there isn't a problem with the chunk itself (ie a bad chunk
- * name or a critical chunk), the chunk is (currently) silently ignored.
- */
-void /* PRIVATE */
-png_push_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32
-   length)
-{
-   png_uint_32 skip=0;
-   png_check_chunk_name(png_ptr, png_ptr->chunk_name);
-
-   if (!(png_ptr->chunk_name[0] & 0x20))
-   {
-#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
-     if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
-          PNG_HANDLE_CHUNK_ALWAYS
-#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
-          && png_ptr->read_user_chunk_fn == NULL
-#endif
-        )
-#endif
-        png_chunk_error(png_ptr, "unknown critical chunk");
-
-     info_ptr = info_ptr; /* to quiet some compiler warnings */
-   }
-
-#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
-   if (png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)
-   {
-#ifdef PNG_MAX_MALLOC_64K
-      if (length > (png_uint_32)65535L)
-      {
-          png_warning(png_ptr, "unknown chunk too large to fit in memory");
-          skip = length - (png_uint_32)65535L;
-          length = (png_uint_32)65535L;
-      }
-#endif
-      png_memcpy((png_charp)png_ptr->unknown_chunk.name,
-                 (png_charp)png_ptr->chunk_name, 
-                 png_sizeof(png_ptr->unknown_chunk.name));
-      png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name)-1]='\0';
-
-      png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr, length);
-      png_ptr->unknown_chunk.size = (png_size_t)length;
-      png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
-#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
-      if(png_ptr->read_user_chunk_fn != NULL)
-      {
-         /* callback to user unknown chunk handler */
-         int ret;
-         ret = (*(png_ptr->read_user_chunk_fn))
-           (png_ptr, &png_ptr->unknown_chunk);
-         if (ret < 0)
-            png_chunk_error(png_ptr, "error in user chunk");
-         if (ret == 0)
-         {
-            if (!(png_ptr->chunk_name[0] & 0x20))
-               if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
-                    PNG_HANDLE_CHUNK_ALWAYS)
-                  png_chunk_error(png_ptr, "unknown critical chunk");
-            png_set_unknown_chunks(png_ptr, info_ptr,
-               &png_ptr->unknown_chunk, 1);
-         }
-      }
-#else
-      png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
-#endif
-      png_free(png_ptr, png_ptr->unknown_chunk.data);
-      png_ptr->unknown_chunk.data = NULL;
-   }
-   else
-#endif
-      skip=length;
-   png_push_crc_skip(png_ptr, skip);
+#endif /* PNG_READ_INTERLACING_SUPPORTED */
 }
 
 void /* PRIVATE */
@@ -1559,7 +1210,10 @@
    PNG_CONST int FARDATA png_pass_dsp_mask[7] =
       {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff};
 #endif
-   if(png_ptr == NULL) return;
+
+   if (png_ptr == NULL)
+      return;
+
    if (new_row != NULL)    /* new_row must == png_ptr->row_buf here. */
       png_combine_row(png_ptr, old_row, png_pass_dsp_mask[png_ptr->pass]);
 }
@@ -1569,7 +1223,9 @@
    png_progressive_info_ptr info_fn, png_progressive_row_ptr row_fn,
    png_progressive_end_ptr end_fn)
 {
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL)
+      return;
+
    png_ptr->info_fn = info_fn;
    png_ptr->row_fn = row_fn;
    png_ptr->end_fn = end_fn;
@@ -1580,7 +1236,9 @@
 png_voidp PNGAPI
 png_get_progressive_ptr(png_structp png_ptr)
 {
-   if(png_ptr == NULL) return (NULL);
+   if (png_ptr == NULL)
+      return (NULL);
+
    return png_ptr->io_ptr;
 }
 #endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
diff -Naur libAfterImage-1.20/libpng/pngread.c root/graf2d/asimage/src/libAfterImage/libpng/pngread.c
--- libAfterImage-1.20/libpng/pngread.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngread.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,20 +1,23 @@
 
 /* pngread.c - read a PNG file
  *
- * Last changed in libpng 1.2.20 September 7, 2007
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.53 [February 26, 2015]
+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
  * This file contains routines that an application calls directly to
  * read a PNG file or stream.
  */
 
 #define PNG_INTERNAL
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
-
-#if defined(PNG_READ_SUPPORTED)
+#ifdef PNG_READ_SUPPORTED
 
 /* Create a PNG structure for reading, and allocate any memory needed. */
 png_structp PNGAPI
@@ -27,7 +30,9 @@
       warn_fn, png_voidp_NULL, png_malloc_ptr_NULL, png_free_ptr_NULL));
 }
 
-/* Alternate create PNG structure for reading, and allocate any memory needed. */
+/* Alternate create PNG structure for reading, and allocate any memory
+ * needed.
+ */
 png_structp PNGAPI
 png_create_read_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
@@ -35,6 +40,9 @@
 {
 #endif /* PNG_USER_MEM_SUPPORTED */
 
+#ifdef PNG_SETJMP_SUPPORTED
+   volatile
+#endif
    png_structp png_ptr;
 
 #ifdef PNG_SETJMP_SUPPORTED
@@ -45,7 +53,8 @@
 
    int i;
 
-   png_debug(1, "in png_create_read_struct\n");
+   png_debug(1, "in png_create_read_struct");
+
 #ifdef PNG_USER_MEM_SUPPORTED
    png_ptr = (png_structp)png_create_struct_2(PNG_STRUCT_PNG,
       (png_malloc_ptr)malloc_fn, (png_voidp)mem_ptr);
@@ -55,10 +64,12 @@
    if (png_ptr == NULL)
       return (NULL);
 
-   /* added at libpng-1.2.6 */
-#ifdef PNG_SET_USER_LIMITS_SUPPORTED
-   png_ptr->user_width_max=PNG_USER_WIDTH_MAX;
-   png_ptr->user_height_max=PNG_USER_HEIGHT_MAX;
+   /* Added at libpng-1.2.6 */
+#ifdef PNG_USER_LIMITS_SUPPORTED
+   png_ptr->user_width_max = PNG_USER_WIDTH_MAX;
+   png_ptr->user_height_max = PNG_USER_HEIGHT_MAX;
+   /* Added at libpng-1.2.43 and 1.4.0 */
+   png_ptr->user_chunk_cache_max = PNG_USER_CHUNK_CACHE_MAX;
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
@@ -69,7 +80,7 @@
 #endif
    {
       png_free(png_ptr, png_ptr->zbuf);
-      png_ptr->zbuf=NULL;
+      png_ptr->zbuf = NULL;
 #ifdef PNG_USER_MEM_SUPPORTED
       png_destroy_struct_2((png_voidp)png_ptr,
          (png_free_ptr)free_fn, (png_voidp)mem_ptr);
@@ -79,9 +90,9 @@
       return (NULL);
    }
 #ifdef USE_FAR_KEYWORD
-   png_memcpy(png_ptr->jmpbuf,jmpbuf,png_sizeof(jmp_buf));
-#endif
+   png_memcpy(png_ptr->jmpbuf, jmpbuf, png_sizeof(jmp_buf));
 #endif
+#endif /* PNG_SETJMP_SUPPORTED */
 
 #ifdef PNG_USER_MEM_SUPPORTED
    png_set_mem_fn(png_ptr, mem_ptr, malloc_fn, free_fn);
@@ -89,47 +100,59 @@
 
    png_set_error_fn(png_ptr, error_ptr, error_fn, warn_fn);
 
-   i=0;
-   do
+   if (user_png_ver != NULL)
    {
-     if(user_png_ver[i] != png_libpng_ver[i])
-        png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
-   } while (png_libpng_ver[i++]);
+      int found_dots = 0;
+      i = -1;
 
-   if (png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH)
-   {
-     /* Libpng 0.90 and later are binary incompatible with libpng 0.89, so
-      * we must recompile any applications that use any older library version.
-      * For versions after libpng 1.0, we will be compatible, so we need
-      * only check the first digit.
-      */
-     if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||
-         (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||
-         (user_png_ver[0] == '0' && user_png_ver[2] < '9'))
-     {
-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
-        char msg[80];
-        if (user_png_ver)
-        {
-          png_snprintf(msg, 80,
-             "Application was compiled with png.h from libpng-%.20s",
-             user_png_ver);
-          png_warning(png_ptr, msg);
-        }
-        png_snprintf(msg, 80,
+      do
+      {
+         i++;
+         if (user_png_ver[i] != PNG_LIBPNG_VER_STRING[i])
+            png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
+         if (user_png_ver[i] == '.')
+            found_dots++;
+      } while (found_dots < 2 && user_png_ver[i] != 0 &&
+            PNG_LIBPNG_VER_STRING[i] != 0);
+   }
+   else
+         png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
+
+
+    if (png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH)
+    {
+       /* Libpng 0.90 and later are binary incompatible with libpng 0.89, so
+       * we must recompile any applications that use any older library version.
+       * For versions after libpng 1.0, we will be compatible, so we need
+       * only check the first digit.
+       */
+      if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||
+          (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||
+          (user_png_ver[0] == '0' && user_png_ver[2] < '9'))
+      {
+#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
+         char msg[80];
+         if (user_png_ver)
+         {
+           png_snprintf(msg, 80,
+              "Application was compiled with png.h from libpng-%.20s",
+              user_png_ver);
+           png_warning(png_ptr, msg);
+         }
+         png_snprintf(msg, 80,
              "Application  is  running with png.c from libpng-%.20s",
-           png_libpng_ver);
-        png_warning(png_ptr, msg);
+             png_libpng_ver);
+         png_warning(png_ptr, msg);
 #endif
 #ifdef PNG_ERROR_NUMBERS_SUPPORTED
-        png_ptr->flags=0;
+         png_ptr->flags = 0;
 #endif
-        png_error(png_ptr,
-           "Incompatible libpng version in application and library");
-     }
+         png_error(png_ptr,
+            "Incompatible libpng version in application and library");
+      }
    }
 
-   /* initialize zbuf - compression buffer */
+   /* Initialize zbuf - compression buffer */
    png_ptr->zbuf_size = PNG_ZBUF_SIZE;
    png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
      (png_uint_32)png_ptr->zbuf_size);
@@ -137,14 +160,17 @@
    png_ptr->zstream.zfree = png_zfree;
    png_ptr->zstream.opaque = (voidpf)png_ptr;
 
-   switch (inflateInit(&png_ptr->zstream))
-   {
-     case Z_OK: /* Do nothing */ break;
-     case Z_MEM_ERROR:
-     case Z_STREAM_ERROR: png_error(png_ptr, "zlib memory error"); break;
-     case Z_VERSION_ERROR: png_error(png_ptr, "zlib version error"); break;
-     default: png_error(png_ptr, "Unknown zlib error");
-   }
+      switch (inflateInit(&png_ptr->zstream))
+      {
+         case Z_OK: /* Do nothing */ break;
+         case Z_MEM_ERROR:
+         case Z_STREAM_ERROR: png_error(png_ptr, "zlib memory error");
+            break;
+         case Z_VERSION_ERROR: png_error(png_ptr, "zlib version error");
+            break;
+         default: png_error(png_ptr, "Unknown zlib error");
+      }
+
 
    png_ptr->zstream.next_out = png_ptr->zbuf;
    png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
@@ -152,25 +178,27 @@
    png_set_read_fn(png_ptr, png_voidp_NULL, png_rw_ptr_NULL);
 
 #ifdef PNG_SETJMP_SUPPORTED
-/* Applications that neglect to set up their own setjmp() and then encounter
-   a png_error() will longjmp here.  Since the jmpbuf is then meaningless we
-   abort instead of returning. */
+/* Applications that neglect to set up their own setjmp() and then
+   encounter a png_error() will longjmp here.  Since the jmpbuf is
+   then meaningless we abort instead of returning. */
 #ifdef USE_FAR_KEYWORD
    if (setjmp(jmpbuf))
-      PNG_ABORT();
-   png_memcpy(png_ptr->jmpbuf,jmpbuf,png_sizeof(jmp_buf));
+       PNG_ABORT();
+   png_memcpy(png_ptr->jmpbuf, jmpbuf, png_sizeof(jmp_buf));
 #else
    if (setjmp(png_ptr->jmpbuf))
-      PNG_ABORT();
-#endif
+       PNG_ABORT();
 #endif
+#endif /* PNG_SETJMP_SUPPORTED */
+
    return (png_ptr);
 }
 
 #if defined(PNG_1_0_X) || defined(PNG_1_2_X)
 /* Initialize PNG structure for reading, and allocate any memory needed.
-   This interface is deprecated in favour of the png_create_read_struct(),
-   and it will disappear as of libpng-1.3.0. */
+ * This interface is deprecated in favour of the png_create_read_struct(),
+ * and it will disappear as of libpng-1.3.0.
+ */
 #undef png_read_init
 void PNGAPI
 png_read_init(png_structp png_ptr)
@@ -184,13 +212,14 @@
    png_size_t png_struct_size, png_size_t png_info_size)
 {
    /* We only come here via pre-1.0.12-compiled applications */
-   if(png_ptr == NULL) return;
-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
-   if(png_sizeof(png_struct) > png_struct_size ||
+   if (png_ptr == NULL)
+      return;
+#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
+   if (png_sizeof(png_struct) > png_struct_size ||
       png_sizeof(png_info) > png_info_size)
    {
       char msg[80];
-      png_ptr->warning_fn=NULL;
+      png_ptr->warning_fn = NULL;
       if (user_png_ver)
       {
         png_snprintf(msg, 80,
@@ -204,24 +233,26 @@
       png_warning(png_ptr, msg);
    }
 #endif
-   if(png_sizeof(png_struct) > png_struct_size)
-     {
-       png_ptr->error_fn=NULL;
+   if (png_sizeof(png_struct) > png_struct_size)
+   {
+      png_ptr->error_fn = NULL;
 #ifdef PNG_ERROR_NUMBERS_SUPPORTED
-       png_ptr->flags=0;
+      png_ptr->flags = 0;
 #endif
-       png_error(png_ptr,
-       "The png struct allocated by the application for reading is too small.");
-     }
-   if(png_sizeof(png_info) > png_info_size)
-     {
-       png_ptr->error_fn=NULL;
+      png_error(png_ptr,
+      "The png struct allocated by the application for reading is"
+      " too small.");
+   }
+   if (png_sizeof(png_info) > png_info_size)
+   {
+      png_ptr->error_fn = NULL;
 #ifdef PNG_ERROR_NUMBERS_SUPPORTED
-       png_ptr->flags=0;
+      png_ptr->flags = 0;
 #endif
-       png_error(png_ptr,
-         "The info struct allocated by application for reading is too small.");
-     }
+      png_error(png_ptr,
+        "The info struct allocated by application for reading is"
+        " too small.");
+   }
    png_read_init_3(&png_ptr, user_png_ver, png_struct_size);
 }
 #endif /* PNG_1_0_X || PNG_1_2_X */
@@ -234,57 +265,60 @@
    jmp_buf tmp_jmp;  /* to save current jump buffer */
 #endif
 
-   int i=0;
+   int i = 0;
 
    png_structp png_ptr=*ptr_ptr;
 
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL)
+      return;
 
    do
    {
-     if(user_png_ver[i] != png_libpng_ver[i])
-     {
+      if (user_png_ver == NULL || user_png_ver[i] != png_libpng_ver[i])
+      {
 #ifdef PNG_LEGACY_SUPPORTED
-       png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
+        png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
 #else
-       png_ptr->warning_fn=NULL;
-       png_warning(png_ptr,
-        "Application uses deprecated png_read_init() and should be recompiled.");
-       break;
+        png_ptr->warning_fn = NULL;
+        png_warning(png_ptr,
+         "Application uses deprecated png_read_init() and should be"
+         " recompiled.");
+        break;
 #endif
-     }
+      }
    } while (png_libpng_ver[i++]);
 
-   png_debug(1, "in png_read_init_3\n");
+   png_debug(1, "in png_read_init_3");
 
 #ifdef PNG_SETJMP_SUPPORTED
-   /* save jump buffer and error functions */
-   png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof (jmp_buf));
+   /* Save jump buffer and error functions */
+   png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));
 #endif
 
-   if(png_sizeof(png_struct) > png_struct_size)
-     {
-       png_destroy_struct(png_ptr);
-       *ptr_ptr = (png_structp)png_create_struct(PNG_STRUCT_PNG);
-       png_ptr = *ptr_ptr;
-     }
+   if (png_sizeof(png_struct) > png_struct_size)
+   {
+      png_destroy_struct(png_ptr);
+      *ptr_ptr = (png_structp)png_create_struct(PNG_STRUCT_PNG);
+      png_ptr = *ptr_ptr;
+   }
 
-   /* reset all variables to 0 */
-   png_memset(png_ptr, 0, png_sizeof (png_struct));
+   /* Reset all variables to 0 */
+   png_memset(png_ptr, 0, png_sizeof(png_struct));
 
 #ifdef PNG_SETJMP_SUPPORTED
-   /* restore jump buffer */
-   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof (jmp_buf));
+   /* Restore jump buffer */
+   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));
 #endif
 
-   /* added at libpng-1.2.6 */
+   /* Added at libpng-1.2.6 */
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
-   png_ptr->user_width_max=PNG_USER_WIDTH_MAX;
-   png_ptr->user_height_max=PNG_USER_HEIGHT_MAX;
+   png_ptr->user_width_max = PNG_USER_WIDTH_MAX;
+   png_ptr->user_height_max = PNG_USER_HEIGHT_MAX;
 #endif
 
-   /* initialize zbuf - compression buffer */
+   /* Initialize zbuf - compression buffer */
    png_ptr->zbuf_size = PNG_ZBUF_SIZE;
+   png_ptr->zstream.zalloc = png_zalloc;
    png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
      (png_uint_32)png_ptr->zbuf_size);
    png_ptr->zstream.zalloc = png_zalloc;
@@ -293,11 +327,11 @@
 
    switch (inflateInit(&png_ptr->zstream))
    {
-     case Z_OK: /* Do nothing */ break;
-     case Z_MEM_ERROR:
-     case Z_STREAM_ERROR: png_error(png_ptr, "zlib memory"); break;
-     case Z_VERSION_ERROR: png_error(png_ptr, "zlib version"); break;
-     default: png_error(png_ptr, "Unknown zlib error");
+      case Z_OK: /* Do nothing */ break;
+      case Z_STREAM_ERROR: png_error(png_ptr, "zlib memory error"); break;
+      case Z_VERSION_ERROR: png_error(png_ptr, "zlib version error");
+          break;
+      default: png_error(png_ptr, "Unknown zlib error");
    }
 
    png_ptr->zstream.next_out = png_ptr->zbuf;
@@ -306,7 +340,7 @@
    png_set_read_fn(png_ptr, png_voidp_NULL, png_rw_ptr_NULL);
 }
 
-#ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
+#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
 /* Read the information before the actual image data.  This has been
  * changed in v0.90 to allow reading a file that already has the magic
  * bytes read from the stream.  You can tell libpng how many bytes have
@@ -318,8 +352,11 @@
 void PNGAPI
 png_read_info(png_structp png_ptr, png_infop info_ptr)
 {
-   if(png_ptr == NULL) return;
-   png_debug(1, "in png_read_info\n");
+   png_debug(1, "in png_read_info");
+ 
+   if (png_ptr == NULL || info_ptr == NULL)
+      return;
+ 
    /* If we haven't checked all of the PNG signature bytes, do so now. */
    if (png_ptr->sig_bytes < 8)
    {
@@ -341,97 +378,88 @@
          png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
    }
 
-   for(;;)
+   for (;;)
    {
 #ifdef PNG_USE_LOCAL_ARRAYS
       PNG_CONST PNG_IHDR;
       PNG_CONST PNG_IDAT;
       PNG_CONST PNG_IEND;
       PNG_CONST PNG_PLTE;
-#if defined(PNG_READ_bKGD_SUPPORTED)
+#ifdef PNG_READ_bKGD_SUPPORTED
       PNG_CONST PNG_bKGD;
 #endif
-#if defined(PNG_READ_cHRM_SUPPORTED)
+#ifdef PNG_READ_cHRM_SUPPORTED
       PNG_CONST PNG_cHRM;
 #endif
-#if defined(PNG_READ_gAMA_SUPPORTED)
+#ifdef PNG_READ_gAMA_SUPPORTED
       PNG_CONST PNG_gAMA;
 #endif
-#if defined(PNG_READ_hIST_SUPPORTED)
+#ifdef PNG_READ_hIST_SUPPORTED
       PNG_CONST PNG_hIST;
 #endif
-#if defined(PNG_READ_iCCP_SUPPORTED)
+#ifdef PNG_READ_iCCP_SUPPORTED
       PNG_CONST PNG_iCCP;
 #endif
-#if defined(PNG_READ_iTXt_SUPPORTED)
+#ifdef PNG_READ_iTXt_SUPPORTED
       PNG_CONST PNG_iTXt;
 #endif
-#if defined(PNG_READ_oFFs_SUPPORTED)
+#ifdef PNG_READ_oFFs_SUPPORTED
       PNG_CONST PNG_oFFs;
 #endif
-#if defined(PNG_READ_pCAL_SUPPORTED)
+#ifdef PNG_READ_pCAL_SUPPORTED
       PNG_CONST PNG_pCAL;
 #endif
-#if defined(PNG_READ_pHYs_SUPPORTED)
+#ifdef PNG_READ_pHYs_SUPPORTED
       PNG_CONST PNG_pHYs;
 #endif
-#if defined(PNG_READ_sBIT_SUPPORTED)
+#ifdef PNG_READ_sBIT_SUPPORTED
       PNG_CONST PNG_sBIT;
 #endif
-#if defined(PNG_READ_sCAL_SUPPORTED)
+#ifdef PNG_READ_sCAL_SUPPORTED
       PNG_CONST PNG_sCAL;
 #endif
-#if defined(PNG_READ_sPLT_SUPPORTED)
+#ifdef PNG_READ_sPLT_SUPPORTED
       PNG_CONST PNG_sPLT;
 #endif
-#if defined(PNG_READ_sRGB_SUPPORTED)
+#ifdef PNG_READ_sRGB_SUPPORTED
       PNG_CONST PNG_sRGB;
 #endif
-#if defined(PNG_READ_tEXt_SUPPORTED)
+#ifdef PNG_READ_tEXt_SUPPORTED
       PNG_CONST PNG_tEXt;
 #endif
-#if defined(PNG_READ_tIME_SUPPORTED)
+#ifdef PNG_READ_tIME_SUPPORTED
       PNG_CONST PNG_tIME;
 #endif
-#if defined(PNG_READ_tRNS_SUPPORTED)
+#ifdef PNG_READ_tRNS_SUPPORTED
       PNG_CONST PNG_tRNS;
 #endif
-#if defined(PNG_READ_zTXt_SUPPORTED)
+#ifdef PNG_READ_zTXt_SUPPORTED
       PNG_CONST PNG_zTXt;
 #endif
 #endif /* PNG_USE_LOCAL_ARRAYS */
-      png_byte chunk_length[4];
-      png_uint_32 length;
-
-      png_read_data(png_ptr, chunk_length, 4);
-      length = png_get_uint_31(png_ptr,chunk_length);
-
-      png_reset_crc(png_ptr);
-      png_crc_read(png_ptr, png_ptr->chunk_name, 4);
-
-      png_debug2(0, "Reading %s chunk, length=%lu.\n", png_ptr->chunk_name,
-         length);
+      png_uint_32 length = png_read_chunk_header(png_ptr);
+      PNG_CONST png_bytep chunk_name = png_ptr->chunk_name;
 
       /* This should be a binary subdivision search or a hash for
        * matching the chunk name rather than a linear search.
        */
-      if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
-        if(png_ptr->mode & PNG_AFTER_IDAT)
+      if (!png_memcmp(chunk_name, png_IDAT, 4))
+        if (png_ptr->mode & PNG_AFTER_IDAT)
           png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;
 
-      if (!png_memcmp(png_ptr->chunk_name, png_IHDR, 4))
+      if (!png_memcmp(chunk_name, png_IHDR, 4))
          png_handle_IHDR(png_ptr, info_ptr, length);
-      else if (!png_memcmp(png_ptr->chunk_name, png_IEND, 4))
+      else if (!png_memcmp(chunk_name, png_IEND, 4))
          png_handle_IEND(png_ptr, info_ptr, length);
 #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-      else if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name))
+      else if (png_handle_as_unknown(png_ptr, chunk_name))
       {
-         if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
+         if (!png_memcmp(chunk_name, png_IDAT, 4))
             png_ptr->mode |= PNG_HAVE_IDAT;
          png_handle_unknown(png_ptr, info_ptr, length);
-         if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
+         if (!png_memcmp(chunk_name, png_PLTE, 4))
             png_ptr->mode |= PNG_HAVE_PLTE;
-         else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
+         else if (!png_memcmp(chunk_name, png_IDAT, 4))
          {
             if (!(png_ptr->mode & PNG_HAVE_IHDR))
                png_error(png_ptr, "Missing IHDR before IDAT");
@@ -442,9 +470,9 @@
          }
       }
 #endif
-      else if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
+      else if (!png_memcmp(chunk_name, png_PLTE, 4))
          png_handle_PLTE(png_ptr, info_ptr, length);
-      else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
+      else if (!png_memcmp(chunk_name, png_IDAT, 4))
       {
          if (!(png_ptr->mode & PNG_HAVE_IHDR))
             png_error(png_ptr, "Missing IHDR before IDAT");
@@ -456,95 +484,98 @@
          png_ptr->mode |= PNG_HAVE_IDAT;
          break;
       }
-#if defined(PNG_READ_bKGD_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_bKGD, 4))
+#ifdef PNG_READ_bKGD_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_bKGD, 4))
          png_handle_bKGD(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_cHRM_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_cHRM, 4))
+#ifdef PNG_READ_cHRM_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_cHRM, 4))
          png_handle_cHRM(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_gAMA_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_gAMA, 4))
+#ifdef PNG_READ_gAMA_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_gAMA, 4))
          png_handle_gAMA(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_hIST_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_hIST, 4))
+#ifdef PNG_READ_hIST_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_hIST, 4))
          png_handle_hIST(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_oFFs_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_oFFs, 4))
+#ifdef PNG_READ_oFFs_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_oFFs, 4))
          png_handle_oFFs(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_pCAL_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_pCAL, 4))
+#ifdef PNG_READ_pCAL_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_pCAL, 4))
          png_handle_pCAL(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_sCAL_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_sCAL, 4))
+#ifdef PNG_READ_sCAL_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_sCAL, 4))
          png_handle_sCAL(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_pHYs_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_pHYs, 4))
+#ifdef PNG_READ_pHYs_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_pHYs, 4))
          png_handle_pHYs(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_sBIT_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_sBIT, 4))
+#ifdef PNG_READ_sBIT_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_sBIT, 4))
          png_handle_sBIT(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_sRGB_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_sRGB, 4))
+#ifdef PNG_READ_sRGB_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_sRGB, 4))
          png_handle_sRGB(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_iCCP_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_iCCP, 4))
+#ifdef PNG_READ_iCCP_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_iCCP, 4))
          png_handle_iCCP(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_sPLT_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_sPLT, 4))
+#ifdef PNG_READ_sPLT_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_sPLT, 4))
          png_handle_sPLT(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_tEXt_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_tEXt, 4))
+#ifdef PNG_READ_tEXt_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_tEXt, 4))
          png_handle_tEXt(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_tIME_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_tIME, 4))
+#ifdef PNG_READ_tIME_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_tIME, 4))
          png_handle_tIME(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_tRNS_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_tRNS, 4))
+#ifdef PNG_READ_tRNS_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_tRNS, 4))
          png_handle_tRNS(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_zTXt_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_zTXt, 4))
+#ifdef PNG_READ_zTXt_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_zTXt, 4))
          png_handle_zTXt(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_iTXt_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_iTXt, 4))
+#ifdef PNG_READ_iTXt_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_iTXt, 4))
          png_handle_iTXt(png_ptr, info_ptr, length);
 #endif
       else
          png_handle_unknown(png_ptr, info_ptr, length);
    }
 }
-#endif /* PNG_NO_SEQUENTIAL_READ_SUPPORTED */
+#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
 
-/* optional call to update the users info_ptr structure */
+/* Optional call to update the users info_ptr structure */
 void PNGAPI
 png_read_update_info(png_structp png_ptr, png_infop info_ptr)
 {
-   png_debug(1, "in png_read_update_info\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_read_update_info");
+ 
+   if (png_ptr == NULL)
+      return;
    if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
       png_read_start_row(png_ptr);
    else
       png_warning(png_ptr,
       "Ignoring extra png_read_update_info() call; row buffer not reallocated");
+
    png_read_transform_info(png_ptr, info_ptr);
 }
 
-#ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
+#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
 /* Initialize palette, background, etc, after transformations
  * are set, but before any reading takes place.  This allows
  * the user to obtain a gamma-corrected palette, for example.
@@ -553,32 +584,38 @@
 void PNGAPI
 png_start_read_image(png_structp png_ptr)
 {
-   png_debug(1, "in png_start_read_image\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_start_read_image");
+ 
+   if (png_ptr == NULL)
+      return;
    if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
       png_read_start_row(png_ptr);
 }
-#endif /* PNG_NO_SEQUENTIAL_READ_SUPPORTED */
+#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
 
-#ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
+#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
 void PNGAPI
 png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
 {
-#ifdef PNG_USE_LOCAL_ARRAYS
+#ifndef PNG_USE_GLOBAL_ARRAYS
    PNG_CONST PNG_IDAT;
    PNG_CONST int png_pass_dsp_mask[7] = {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55,
-     0xff};
+      0xff};
    PNG_CONST int png_pass_mask[7] = {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};
 #endif
    int ret;
-   if(png_ptr == NULL) return;
-   png_debug2(1, "in png_read_row (row %lu, pass %d)\n",
+ 
+   if (png_ptr == NULL)
+      return;
+ 
+   png_debug2(1, "in png_read_row (row %lu, pass %d)",
       png_ptr->row_number, png_ptr->pass);
+
    if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
       png_read_start_row(png_ptr);
    if (png_ptr->row_number == 0 && png_ptr->pass == 0)
    {
-   /* check for transforms that have been set but were defined out */
+   /* Check for transforms that have been set but were defined out */
 #if defined(PNG_WRITE_INVERT_SUPPORTED) && !defined(PNG_READ_INVERT_SUPPORTED)
    if (png_ptr->transformations & PNG_INVERT_MONO)
       png_warning(png_ptr, "PNG_READ_INVERT_SUPPORTED is not defined.");
@@ -587,7 +624,8 @@
    if (png_ptr->transformations & PNG_FILLER)
       png_warning(png_ptr, "PNG_READ_FILLER_SUPPORTED is not defined.");
 #endif
-#if defined(PNG_WRITE_PACKSWAP_SUPPORTED) && !defined(PNG_READ_PACKSWAP_SUPPORTED)
+#if defined(PNG_WRITE_PACKSWAP_SUPPORTED) && \
+    !defined(PNG_READ_PACKSWAP_SUPPORTED)
    if (png_ptr->transformations & PNG_PACKSWAP)
       png_warning(png_ptr, "PNG_READ_PACKSWAP_SUPPORTED is not defined.");
 #endif
@@ -609,8 +647,8 @@
 #endif
    }
 
-#if defined(PNG_READ_INTERLACING_SUPPORTED)
-   /* if interlaced and we do not need a new row, combine row and return */
+#ifdef PNG_READ_INTERLACING_SUPPORTED
+   /* If interlaced and we do not need a new row, combine row and return */
    if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))
    {
       switch (png_ptr->pass)
@@ -690,22 +728,18 @@
       png_error(png_ptr, "Invalid attempt to read row data");
 
    png_ptr->zstream.next_out = png_ptr->row_buf;
-   png_ptr->zstream.avail_out = (uInt)png_ptr->irowbytes;
+   png_ptr->zstream.avail_out =
+       (uInt)(PNG_ROWBYTES(png_ptr->pixel_depth,
+       png_ptr->iwidth) + 1);
    do
    {
       if (!(png_ptr->zstream.avail_in))
       {
          while (!png_ptr->idat_size)
          {
-            png_byte chunk_length[4];
-
             png_crc_finish(png_ptr, 0);
 
-            png_read_data(png_ptr, chunk_length, 4);
-            png_ptr->idat_size = png_get_uint_31(png_ptr,chunk_length);
-
-            png_reset_crc(png_ptr);
-            png_crc_read(png_ptr, png_ptr->chunk_name, 4);
+            png_ptr->idat_size = png_read_chunk_header(png_ptr);
             if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
                png_error(png_ptr, "Not enough image data");
          }
@@ -741,7 +775,7 @@
    png_ptr->row_info.rowbytes = PNG_ROWBYTES(png_ptr->row_info.pixel_depth,
        png_ptr->row_info.width);
 
-   if(png_ptr->row_buf[0])
+   if (png_ptr->row_buf[0])
    png_read_filter_row(png_ptr, &(png_ptr->row_info),
       png_ptr->row_buf + 1, png_ptr->prev_row + 1,
       (int)(png_ptr->row_buf[0]));
@@ -749,8 +783,8 @@
    png_memcpy_check(png_ptr, png_ptr->prev_row, png_ptr->row_buf,
       png_ptr->rowbytes + 1);
 
-#if defined(PNG_MNG_FEATURES_SUPPORTED)
-   if((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
+#ifdef PNG_MNG_FEATURES_SUPPORTED
+   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
       (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))
    {
       /* Intrapixel differencing */
@@ -762,16 +796,16 @@
    if (png_ptr->transformations || (png_ptr->flags&PNG_FLAG_STRIP_ALPHA))
       png_do_read_transformations(png_ptr);
 
-#if defined(PNG_READ_INTERLACING_SUPPORTED)
-   /* blow up interlaced rows to full size */
+#ifdef PNG_READ_INTERLACING_SUPPORTED
+   /* Blow up interlaced rows to full size */
    if (png_ptr->interlaced &&
       (png_ptr->transformations & PNG_INTERLACE))
    {
       if (png_ptr->pass < 6)
-/*       old interface (pre-1.0.9):
-         png_do_read_interlace(&(png_ptr->row_info),
-            png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations);
- */
+         /* Old interface (pre-1.0.9):
+          * png_do_read_interlace(&(png_ptr->row_info),
+          *    png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations);
+          */
          png_do_read_interlace(png_ptr);
 
       if (dsp_row != NULL)
@@ -794,9 +828,9 @@
    if (png_ptr->read_row_fn != NULL)
       (*(png_ptr->read_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);
 }
-#endif /* PNG_NO_SEQUENTIAL_READ_SUPPORTED */
+#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
 
-#ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
+#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
 /* Read one or more rows of image data.  If the image is interlaced,
  * and png_set_interlace_handling() has been called, the rows need to
  * contain the contents of the rows from the previous pass.  If the
@@ -829,8 +863,10 @@
    png_bytepp rp;
    png_bytepp dp;
 
-   png_debug(1, "in png_read_rows\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_read_rows");
+ 
+   if (png_ptr == NULL)
+      return;
    rp = row;
    dp = display_row;
    if (rp != NULL && dp != NULL)
@@ -841,14 +877,14 @@
 
          png_read_row(png_ptr, rptr, dptr);
       }
-   else if(rp != NULL)
+   else if (rp != NULL)
       for (i = 0; i < num_rows; i++)
       {
          png_bytep rptr = *rp;
          png_read_row(png_ptr, rptr, png_bytep_NULL);
          rp++;
       }
-   else if(dp != NULL)
+   else if (dp != NULL)
       for (i = 0; i < num_rows; i++)
       {
          png_bytep dptr = *dp;
@@ -856,9 +892,9 @@
          dp++;
       }
 }
-#endif /* PNG_NO_SEQUENTIAL_READ_SUPPORTED */
+#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
 
-#ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
+#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
 /* Read the entire image.  If the image has an alpha channel or a tRNS
  * chunk, and you have called png_handle_alpha()[*], you will need to
  * initialize the image to the current image that PNG will be overlaying.
@@ -874,12 +910,14 @@
 void PNGAPI
 png_read_image(png_structp png_ptr, png_bytepp image)
 {
-   png_uint_32 i,image_height;
+   png_uint_32 i, image_height;
    int pass, j;
    png_bytepp rp;
 
-   png_debug(1, "in png_read_image\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_read_image");
+ 
+   if (png_ptr == NULL)
+      return;
 
 #ifdef PNG_READ_INTERLACING_SUPPORTED
    pass = png_set_interlace_handling(png_ptr);
@@ -904,9 +942,9 @@
       }
    }
 }
-#endif /* PNG_NO_SEQUENTIAL_READ_SUPPORTED */
+#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
 
-#ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
+#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
 /* Read the end of the PNG file.  Will not read past the end of the
  * file, will verify the end is accurate, and will read any comments
  * or time information at the end of the file, if info is not NULL.
@@ -914,11 +952,10 @@
 void PNGAPI
 png_read_end(png_structp png_ptr, png_infop info_ptr)
 {
-   png_byte chunk_length[4];
-   png_uint_32 length;
-
-   png_debug(1, "in png_read_end\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_read_end");
+ 
+   if (png_ptr == NULL)
+      return;
    png_crc_finish(png_ptr, 0); /* Finish off CRC from last IDAT chunk */
 
    do
@@ -928,85 +965,79 @@
       PNG_CONST PNG_IDAT;
       PNG_CONST PNG_IEND;
       PNG_CONST PNG_PLTE;
-#if defined(PNG_READ_bKGD_SUPPORTED)
+#ifdef PNG_READ_bKGD_SUPPORTED
       PNG_CONST PNG_bKGD;
 #endif
-#if defined(PNG_READ_cHRM_SUPPORTED)
+#ifdef PNG_READ_cHRM_SUPPORTED
       PNG_CONST PNG_cHRM;
 #endif
-#if defined(PNG_READ_gAMA_SUPPORTED)
+#ifdef PNG_READ_gAMA_SUPPORTED
       PNG_CONST PNG_gAMA;
 #endif
-#if defined(PNG_READ_hIST_SUPPORTED)
+#ifdef PNG_READ_hIST_SUPPORTED
       PNG_CONST PNG_hIST;
 #endif
-#if defined(PNG_READ_iCCP_SUPPORTED)
+#ifdef PNG_READ_iCCP_SUPPORTED
       PNG_CONST PNG_iCCP;
 #endif
-#if defined(PNG_READ_iTXt_SUPPORTED)
+#ifdef PNG_READ_iTXt_SUPPORTED
       PNG_CONST PNG_iTXt;
 #endif
-#if defined(PNG_READ_oFFs_SUPPORTED)
+#ifdef PNG_READ_oFFs_SUPPORTED
       PNG_CONST PNG_oFFs;
 #endif
-#if defined(PNG_READ_pCAL_SUPPORTED)
+#ifdef PNG_READ_pCAL_SUPPORTED
       PNG_CONST PNG_pCAL;
 #endif
-#if defined(PNG_READ_pHYs_SUPPORTED)
+#ifdef PNG_READ_pHYs_SUPPORTED
       PNG_CONST PNG_pHYs;
 #endif
-#if defined(PNG_READ_sBIT_SUPPORTED)
+#ifdef PNG_READ_sBIT_SUPPORTED
       PNG_CONST PNG_sBIT;
 #endif
-#if defined(PNG_READ_sCAL_SUPPORTED)
+#ifdef PNG_READ_sCAL_SUPPORTED
       PNG_CONST PNG_sCAL;
 #endif
-#if defined(PNG_READ_sPLT_SUPPORTED)
+#ifdef PNG_READ_sPLT_SUPPORTED
       PNG_CONST PNG_sPLT;
 #endif
-#if defined(PNG_READ_sRGB_SUPPORTED)
+#ifdef PNG_READ_sRGB_SUPPORTED
       PNG_CONST PNG_sRGB;
 #endif
-#if defined(PNG_READ_tEXt_SUPPORTED)
+#ifdef PNG_READ_tEXt_SUPPORTED
       PNG_CONST PNG_tEXt;
 #endif
-#if defined(PNG_READ_tIME_SUPPORTED)
+#ifdef PNG_READ_tIME_SUPPORTED
       PNG_CONST PNG_tIME;
 #endif
-#if defined(PNG_READ_tRNS_SUPPORTED)
+#ifdef PNG_READ_tRNS_SUPPORTED
       PNG_CONST PNG_tRNS;
 #endif
-#if defined(PNG_READ_zTXt_SUPPORTED)
+#ifdef PNG_READ_zTXt_SUPPORTED
       PNG_CONST PNG_zTXt;
 #endif
 #endif /* PNG_USE_LOCAL_ARRAYS */
+      png_uint_32 length = png_read_chunk_header(png_ptr);
+      PNG_CONST png_bytep chunk_name = png_ptr->chunk_name;
 
-      png_read_data(png_ptr, chunk_length, 4);
-      length = png_get_uint_31(png_ptr,chunk_length);
-
-      png_reset_crc(png_ptr);
-      png_crc_read(png_ptr, png_ptr->chunk_name, 4);
-
-      png_debug1(0, "Reading %s chunk.\n", png_ptr->chunk_name);
-
-      if (!png_memcmp(png_ptr->chunk_name, png_IHDR, 4))
+      if (!png_memcmp(chunk_name, png_IHDR, 4))
          png_handle_IHDR(png_ptr, info_ptr, length);
-      else if (!png_memcmp(png_ptr->chunk_name, png_IEND, 4))
+      else if (!png_memcmp(chunk_name, png_IEND, 4))
          png_handle_IEND(png_ptr, info_ptr, length);
 #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-      else if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name))
+      else if (png_handle_as_unknown(png_ptr, chunk_name))
       {
-         if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
+         if (!png_memcmp(chunk_name, png_IDAT, 4))
          {
             if ((length > 0) || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))
                png_error(png_ptr, "Too many IDAT's found");
          }
          png_handle_unknown(png_ptr, info_ptr, length);
-         if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
+         if (!png_memcmp(chunk_name, png_PLTE, 4))
             png_ptr->mode |= PNG_HAVE_PLTE;
       }
 #endif
-      else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
+      else if (!png_memcmp(chunk_name, png_IDAT, 4))
       {
          /* Zero length IDATs are legal after the last IDAT has been
           * read, but not after other chunks have been read.
@@ -1015,83 +1046,83 @@
             png_error(png_ptr, "Too many IDAT's found");
          png_crc_finish(png_ptr, length);
       }
-      else if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
+      else if (!png_memcmp(chunk_name, png_PLTE, 4))
          png_handle_PLTE(png_ptr, info_ptr, length);
-#if defined(PNG_READ_bKGD_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_bKGD, 4))
+#ifdef PNG_READ_bKGD_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_bKGD, 4))
          png_handle_bKGD(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_cHRM_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_cHRM, 4))
+#ifdef PNG_READ_cHRM_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_cHRM, 4))
          png_handle_cHRM(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_gAMA_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_gAMA, 4))
+#ifdef PNG_READ_gAMA_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_gAMA, 4))
          png_handle_gAMA(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_hIST_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_hIST, 4))
+#ifdef PNG_READ_hIST_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_hIST, 4))
          png_handle_hIST(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_oFFs_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_oFFs, 4))
+#ifdef PNG_READ_oFFs_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_oFFs, 4))
          png_handle_oFFs(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_pCAL_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_pCAL, 4))
+#ifdef PNG_READ_pCAL_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_pCAL, 4))
          png_handle_pCAL(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_sCAL_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_sCAL, 4))
+#ifdef PNG_READ_sCAL_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_sCAL, 4))
          png_handle_sCAL(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_pHYs_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_pHYs, 4))
+#ifdef PNG_READ_pHYs_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_pHYs, 4))
          png_handle_pHYs(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_sBIT_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_sBIT, 4))
+#ifdef PNG_READ_sBIT_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_sBIT, 4))
          png_handle_sBIT(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_sRGB_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_sRGB, 4))
+#ifdef PNG_READ_sRGB_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_sRGB, 4))
          png_handle_sRGB(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_iCCP_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_iCCP, 4))
+#ifdef PNG_READ_iCCP_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_iCCP, 4))
          png_handle_iCCP(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_sPLT_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_sPLT, 4))
+#ifdef PNG_READ_sPLT_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_sPLT, 4))
          png_handle_sPLT(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_tEXt_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_tEXt, 4))
+#ifdef PNG_READ_tEXt_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_tEXt, 4))
          png_handle_tEXt(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_tIME_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_tIME, 4))
+#ifdef PNG_READ_tIME_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_tIME, 4))
          png_handle_tIME(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_tRNS_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_tRNS, 4))
+#ifdef PNG_READ_tRNS_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_tRNS, 4))
          png_handle_tRNS(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_zTXt_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_zTXt, 4))
+#ifdef PNG_READ_zTXt_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_zTXt, 4))
          png_handle_zTXt(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_iTXt_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_iTXt, 4))
+#ifdef PNG_READ_iTXt_SUPPORTED
+      else if (!png_memcmp(chunk_name, png_iTXt, 4))
          png_handle_iTXt(png_ptr, info_ptr, length);
 #endif
       else
          png_handle_unknown(png_ptr, info_ptr, length);
    } while (!(png_ptr->mode & PNG_HAVE_IEND));
 }
-#endif /* PNG_NO_SEQUENTIAL_READ_SUPPORTED */
+#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
 
-/* free all memory used by the read */
+/* Free all memory used by the read */
 void PNGAPI
 png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr,
    png_infopp end_info_ptr_ptr)
@@ -1099,13 +1130,21 @@
    png_structp png_ptr = NULL;
    png_infop info_ptr = NULL, end_info_ptr = NULL;
 #ifdef PNG_USER_MEM_SUPPORTED
-   png_free_ptr free_fn;
-   png_voidp mem_ptr;
+   png_free_ptr free_fn = NULL;
+   png_voidp mem_ptr = NULL;
 #endif
 
-   png_debug(1, "in png_destroy_read_struct\n");
+   png_debug(1, "in png_destroy_read_struct");
+ 
    if (png_ptr_ptr != NULL)
       png_ptr = *png_ptr_ptr;
+   if (png_ptr == NULL)
+      return;
+
+#ifdef PNG_USER_MEM_SUPPORTED
+   free_fn = png_ptr->free_fn;
+   mem_ptr = png_ptr->mem_ptr;
+#endif
 
    if (info_ptr_ptr != NULL)
       info_ptr = *info_ptr_ptr;
@@ -1113,16 +1152,11 @@
    if (end_info_ptr_ptr != NULL)
       end_info_ptr = *end_info_ptr_ptr;
 
-#ifdef PNG_USER_MEM_SUPPORTED
-   free_fn = png_ptr->free_fn;
-   mem_ptr = png_ptr->mem_ptr;
-#endif
-
    png_read_destroy(png_ptr, info_ptr, end_info_ptr);
 
    if (info_ptr != NULL)
    {
-#if defined(PNG_TEXT_SUPPORTED)
+#ifdef PNG_TEXT_SUPPORTED
       png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, -1);
 #endif
 
@@ -1137,7 +1171,7 @@
 
    if (end_info_ptr != NULL)
    {
-#if defined(PNG_READ_TEXT_SUPPORTED)
+#ifdef PNG_READ_TEXT_SUPPORTED
       png_free_data(png_ptr, end_info_ptr, PNG_FREE_TEXT, -1);
 #endif
 #ifdef PNG_USER_MEM_SUPPORTED
@@ -1161,9 +1195,10 @@
    }
 }
 
-/* free all memory used by the read (old method) */
+/* Free all memory used by the read (old method) */
 void /* PRIVATE */
-png_read_destroy(png_structp png_ptr, png_infop info_ptr, png_infop end_info_ptr)
+png_read_destroy(png_structp png_ptr, png_infop info_ptr,
+    png_infop end_info_ptr)
 {
 #ifdef PNG_SETJMP_SUPPORTED
    jmp_buf tmp_jmp;
@@ -1175,7 +1210,8 @@
    png_free_ptr free_fn;
 #endif
 
-   png_debug(1, "in png_read_destroy\n");
+   png_debug(1, "in png_read_destroy");
+ 
    if (info_ptr != NULL)
       png_info_destroy(png_ptr, info_ptr);
 
@@ -1185,14 +1221,15 @@
    png_free(png_ptr, png_ptr->zbuf);
    png_free(png_ptr, png_ptr->big_row_buf);
    png_free(png_ptr, png_ptr->prev_row);
-#if defined(PNG_READ_DITHER_SUPPORTED)
+   png_free(png_ptr, png_ptr->chunkdata);
+#ifdef PNG_READ_DITHER_SUPPORTED
    png_free(png_ptr, png_ptr->palette_lookup);
    png_free(png_ptr, png_ptr->dither_index);
 #endif
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
    png_free(png_ptr, png_ptr->gamma_table);
 #endif
-#if defined(PNG_READ_BACKGROUND_SUPPORTED)
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
    png_free(png_ptr, png_ptr->gamma_from_1);
    png_free(png_ptr, png_ptr->gamma_to_1);
 #endif
@@ -1217,7 +1254,7 @@
    png_ptr->flags &= ~PNG_FLAG_FREE_TRNS;
 #endif
 #endif
-#if defined(PNG_READ_hIST_SUPPORTED)
+#ifdef PNG_READ_hIST_SUPPORTED
 #ifdef PNG_FREE_ME_SUPPORTED
    if (png_ptr->free_me & PNG_FREE_HIST)
       png_free(png_ptr, png_ptr->hist);
@@ -1228,7 +1265,7 @@
    png_ptr->flags &= ~PNG_FLAG_FREE_HIST;
 #endif
 #endif
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
    if (png_ptr->gamma_16_table != NULL)
    {
       int i;
@@ -1239,7 +1276,7 @@
       }
    png_free(png_ptr, png_ptr->gamma_16_table);
    }
-#if defined(PNG_READ_BACKGROUND_SUPPORTED)
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
    if (png_ptr->gamma_16_from_1 != NULL)
    {
       int i;
@@ -1262,7 +1299,7 @@
    }
 #endif
 #endif
-#if defined(PNG_TIME_RFC1123_SUPPORTED)
+#ifdef PNG_TIME_RFC1123_SUPPORTED
    png_free(png_ptr, png_ptr->time_buffer);
 #endif
 
@@ -1271,17 +1308,11 @@
    png_free(png_ptr, png_ptr->save_buffer);
 #endif
 
-#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-#ifdef PNG_TEXT_SUPPORTED
-   png_free(png_ptr, png_ptr->current_text);
-#endif /* PNG_TEXT_SUPPORTED */
-#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
-
    /* Save the important info out of the png_struct, in case it is
     * being used again.
     */
 #ifdef PNG_SETJMP_SUPPORTED
-   png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof (jmp_buf));
+   png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));
 #endif
 
    error_fn = png_ptr->error_fn;
@@ -1291,7 +1322,7 @@
    free_fn = png_ptr->free_fn;
 #endif
 
-   png_memset(png_ptr, 0, png_sizeof (png_struct));
+   png_memset(png_ptr, 0, png_sizeof(png_struct));
 
    png_ptr->error_fn = error_fn;
    png_ptr->warning_fn = warning_fn;
@@ -1301,7 +1332,7 @@
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
-   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof (jmp_buf));
+   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));
 #endif
 
 }
@@ -1309,13 +1340,14 @@
 void PNGAPI
 png_set_read_status_fn(png_structp png_ptr, png_read_status_ptr read_row_fn)
 {
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL)
+      return;
    png_ptr->read_row_fn = read_row_fn;
 }
 
 
-#ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
-#if defined(PNG_INFO_IMAGE_SUPPORTED)
+#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
+#ifdef PNG_INFO_IMAGE_SUPPORTED
 void PNGAPI
 png_read_png(png_structp png_ptr, png_infop info_ptr,
                            int transforms,
@@ -1323,9 +1355,10 @@
 {
    int row;
 
-   if(png_ptr == NULL) return;
-#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
-   /* invert the alpha channel from opacity to transparency
+   if (png_ptr == NULL)
+      return;
+#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
+   /* Invert the alpha channel from opacity to transparency
     */
    if (transforms & PNG_TRANSFORM_INVERT_ALPHA)
        png_set_invert_alpha(png_ptr);
@@ -1336,23 +1369,23 @@
     */
    png_read_info(png_ptr, info_ptr);
    if (info_ptr->height > PNG_UINT_32_MAX/png_sizeof(png_bytep))
-      png_error(png_ptr,"Image is too high to process with png_read_png()");
+      png_error(png_ptr, "Image is too high to process with png_read_png()");
 
    /* -------------- image transformations start here ------------------- */
 
-#if defined(PNG_READ_16_TO_8_SUPPORTED)
-   /* tell libpng to strip 16 bit/color files down to 8 bits per color
+#ifdef PNG_READ_16_TO_8_SUPPORTED
+   /* Tell libpng to strip 16 bit/color files down to 8 bits per color.
     */
    if (transforms & PNG_TRANSFORM_STRIP_16)
-       png_set_strip_16(png_ptr);
+      png_set_strip_16(png_ptr);
 #endif
 
-#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
+#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
    /* Strip alpha bytes from the input data without combining with
     * the background (not recommended).
     */
    if (transforms & PNG_TRANSFORM_STRIP_ALPHA)
-       png_set_strip_alpha(png_ptr);
+      png_set_strip_alpha(png_ptr);
 #endif
 
 #if defined(PNG_READ_PACK_SUPPORTED) && !defined(PNG_READ_EXPAND_SUPPORTED)
@@ -1360,74 +1393,84 @@
     * byte into separate bytes (useful for paletted and grayscale images).
     */
    if (transforms & PNG_TRANSFORM_PACKING)
-       png_set_packing(png_ptr);
+      png_set_packing(png_ptr);
 #endif
 
-#if defined(PNG_READ_PACKSWAP_SUPPORTED)
+#ifdef PNG_READ_PACKSWAP_SUPPORTED
    /* Change the order of packed pixels to least significant bit first
     * (not useful if you are using png_set_packing).
     */
    if (transforms & PNG_TRANSFORM_PACKSWAP)
-       png_set_packswap(png_ptr);
+      png_set_packswap(png_ptr);
 #endif
 
-#if defined(PNG_READ_EXPAND_SUPPORTED)
+#ifdef PNG_READ_EXPAND_SUPPORTED
    /* Expand paletted colors into true RGB triplets
     * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel
     * Expand paletted or RGB images with transparency to full alpha
     * channels so the data will be available as RGBA quartets.
     */
    if (transforms & PNG_TRANSFORM_EXPAND)
-       if ((png_ptr->bit_depth < 8) ||
-           (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ||
-           (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)))
+      if ((png_ptr->bit_depth < 8) ||
+          (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ||
+          (info_ptr->valid & PNG_INFO_tRNS))
          png_set_expand(png_ptr);
 #endif
 
    /* We don't handle background color or gamma transformation or dithering.
     */
 
-#if defined(PNG_READ_INVERT_SUPPORTED)
-   /* invert monochrome files to have 0 as white and 1 as black
+#ifdef PNG_READ_INVERT_SUPPORTED
+   /* Invert monochrome files to have 0 as white and 1 as black
     */
    if (transforms & PNG_TRANSFORM_INVERT_MONO)
-       png_set_invert_mono(png_ptr);
+      png_set_invert_mono(png_ptr);
 #endif
 
-#if defined(PNG_READ_SHIFT_SUPPORTED)
+#ifdef PNG_READ_SHIFT_SUPPORTED
    /* If you want to shift the pixel values from the range [0,255] or
     * [0,65535] to the original [0,7] or [0,31], or whatever range the
     * colors were originally in:
     */
-   if ((transforms & PNG_TRANSFORM_SHIFT)
-       && png_get_valid(png_ptr, info_ptr, PNG_INFO_sBIT))
-   {
-      png_color_8p sig_bit;
-
-      png_get_sBIT(png_ptr, info_ptr, &sig_bit);
-      png_set_shift(png_ptr, sig_bit);
-   }
+   if ((transforms & PNG_TRANSFORM_SHIFT) && (info_ptr->valid & PNG_INFO_sBIT))
+      png_set_shift(png_ptr, &info_ptr->sig_bit);
 #endif
 
-#if defined(PNG_READ_BGR_SUPPORTED)
-   /* flip the RGB pixels to BGR (or RGBA to BGRA)
+#ifdef PNG_READ_BGR_SUPPORTED
+   /* Flip the RGB pixels to BGR (or RGBA to BGRA)
     */
    if (transforms & PNG_TRANSFORM_BGR)
-       png_set_bgr(png_ptr);
+      png_set_bgr(png_ptr);
 #endif
 
-#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED)
-   /* swap the RGBA or GA data to ARGB or AG (or BGRA to ABGR)
+#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
+   /* Swap the RGBA or GA data to ARGB or AG (or BGRA to ABGR)
     */
    if (transforms & PNG_TRANSFORM_SWAP_ALPHA)
        png_set_swap_alpha(png_ptr);
 #endif
 
-#if defined(PNG_READ_SWAP_SUPPORTED)
-   /* swap bytes of 16 bit files to least significant byte first
+#ifdef PNG_READ_SWAP_SUPPORTED
+   /* Swap bytes of 16 bit files to least significant byte first
     */
    if (transforms & PNG_TRANSFORM_SWAP_ENDIAN)
-       png_set_swap(png_ptr);
+      png_set_swap(png_ptr);
+#endif
+
+/* Added at libpng-1.2.41 */
+#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
+   /* Invert the alpha channel from opacity to transparency
+    */
+   if (transforms & PNG_TRANSFORM_INVERT_ALPHA)
+       png_set_invert_alpha(png_ptr);
+#endif
+
+/* Added at libpng-1.2.41 */
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
+   /* Expand grayscale image to RGB
+    */
+   if (transforms & PNG_TRANSFORM_GRAY_TO_RGB)
+       png_set_gray_to_rgb(png_ptr);
 #endif
 
    /* We don't handle adding filler bytes */
@@ -1443,30 +1486,32 @@
 #ifdef PNG_FREE_ME_SUPPORTED
    png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);
 #endif
-   if(info_ptr->row_pointers == NULL)
+   if (info_ptr->row_pointers == NULL)
    {
       info_ptr->row_pointers = (png_bytepp)png_malloc(png_ptr,
          info_ptr->height * png_sizeof(png_bytep));
+      png_memset(info_ptr->row_pointers, 0, info_ptr->height
+         * png_sizeof(png_bytep));
+
 #ifdef PNG_FREE_ME_SUPPORTED
       info_ptr->free_me |= PNG_FREE_ROWS;
 #endif
+
       for (row = 0; row < (int)info_ptr->height; row++)
-      {
          info_ptr->row_pointers[row] = (png_bytep)png_malloc(png_ptr,
             png_get_rowbytes(png_ptr, info_ptr));
-      }
    }
 
    png_read_image(png_ptr, info_ptr->row_pointers);
    info_ptr->valid |= PNG_INFO_IDAT;
 
-   /* read rest of file, and get additional chunks in info_ptr - REQUIRED */
+   /* Read rest of file, and get additional chunks in info_ptr - REQUIRED */
    png_read_end(png_ptr, info_ptr);
 
-   transforms = transforms; /* quiet compiler warnings */
-   params = params;
+   PNG_UNUSED(transforms) /* Quiet compiler warnings */
+   PNG_UNUSED(params)
 
 }
 #endif /* PNG_INFO_IMAGE_SUPPORTED */
-#endif /* PNG_NO_SEQUENTIAL_READ_SUPPORTED */
+#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
 #endif /* PNG_READ_SUPPORTED */
diff -Naur libAfterImage-1.20/libpng/pngrio.c root/graf2d/asimage/src/libAfterImage/libpng/pngrio.c
--- libAfterImage-1.20/libpng/pngrio.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngrio.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,12 +1,15 @@
 
 /* pngrio.c - functions for data input
  *
- * Last changed in libpng 1.2.13 November 13, 2006
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.43 [February 25, 2010]
+ * Copyright (c) 1998-2010 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
  * This file provides a location for all input.  Users who need
  * special handling are expected to write a function that has the same
  * arguments as this and performs a similar function, but that possibly
@@ -16,41 +19,45 @@
  */
 
 #define PNG_INTERNAL
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
-
-#if defined(PNG_READ_SUPPORTED)
+#ifdef PNG_READ_SUPPORTED
 
 /* Read the data from whatever input you are using.  The default routine
-   reads from a file pointer.  Note that this routine sometimes gets called
-   with very small lengths, so you should implement some kind of simple
-   buffering if you are using unbuffered reads.  This should never be asked
-   to read more then 64K on a 16 bit machine. */
+ * reads from a file pointer.  Note that this routine sometimes gets called
+ * with very small lengths, so you should implement some kind of simple
+ * buffering if you are using unbuffered reads.  This should never be asked
+ * to read more then 64K on a 16 bit machine.
+ */
 void /* PRIVATE */
 png_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
 {
-   png_debug1(4,"reading %d bytes\n", (int)length);
+   png_debug1(4, "reading %d bytes", (int)length);
+ 
    if (png_ptr->read_data_fn != NULL)
       (*(png_ptr->read_data_fn))(png_ptr, data, length);
    else
       png_error(png_ptr, "Call to NULL read function");
 }
 
-#if !defined(PNG_NO_STDIO)
+#ifdef PNG_STDIO_SUPPORTED
 /* This is the function that does the actual reading of data.  If you are
-   not reading from a standard C stream, you should create a replacement
-   read_data function and use it at run time with png_set_read_fn(), rather
-   than changing the library. */
+ * not reading from a standard C stream, you should create a replacement
+ * read_data function and use it at run time with png_set_read_fn(), rather
+ * than changing the library.
+ */
 #ifndef USE_FAR_KEYWORD
 void PNGAPI
 png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
 {
    png_size_t check;
 
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL)
+      return;
    /* fread() returns 0 on error, so it is OK to store this in a png_size_t
     * instead of an int, which is what fread() actually returns.
     */
-#if defined(_WIN32_WCE)
+#ifdef _WIN32_WCE
    if ( !ReadFile((HANDLE)(png_ptr->io_ptr), data, length, &check, NULL) )
       check = 0;
 #else
@@ -62,7 +69,7 @@
       png_error(png_ptr, "Read Error");
 }
 #else
-/* this is the model-independent version. Since the standard I/O library
+/* This is the model-independent version. Since the standard I/O library
    can't handle far buffers in the medium and small models, we have to copy
    the data.
 */
@@ -77,14 +84,16 @@
    png_byte *n_data;
    png_FILE_p io_ptr;
 
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL)
+      return;
    /* Check if data really is near. If so, use usual code. */
    n_data = (png_byte *)CVT_PTR_NOCHECK(data);
    io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
    if ((png_bytep)n_data == data)
    {
-#if defined(_WIN32_WCE)
-      if ( !ReadFile((HANDLE)(png_ptr->io_ptr), data, length, &check, NULL) )
+#ifdef _WIN32_WCE
+      if ( !ReadFile((HANDLE)(png_ptr->io_ptr), data, length, &check,
+          NULL) )
          check = 0;
 #else
       check = fread(n_data, 1, length, io_ptr);
@@ -99,14 +108,14 @@
       do
       {
          read = MIN(NEAR_BUF_SIZE, remaining);
-#if defined(_WIN32_WCE)
+#ifdef _WIN32_WCE
          if ( !ReadFile((HANDLE)(io_ptr), buf, read, &err, NULL) )
             err = 0;
 #else
          err = fread(buf, (png_size_t)1, read, io_ptr);
 #endif
          png_memcpy(data, buf, read); /* copy far buffer to near buffer */
-         if(err != read)
+         if (err != read)
             break;
          else
             check += err;
@@ -122,26 +131,30 @@
 #endif
 
 /* This function allows the application to supply a new input function
-   for libpng if standard C streams aren't being used.
-
-   This function takes as its arguments:
-   png_ptr      - pointer to a png input data structure
-   io_ptr       - pointer to user supplied structure containing info about
-                  the input functions.  May be NULL.
-   read_data_fn - pointer to a new input function that takes as its
-                  arguments a pointer to a png_struct, a pointer to
-                  a location where input data can be stored, and a 32-bit
-                  unsigned int that is the number of bytes to be read.
-                  To exit and output any fatal error messages the new write
-                  function should call png_error(png_ptr, "Error msg"). */
+ * for libpng if standard C streams aren't being used.
+ *
+ * This function takes as its arguments:
+ * png_ptr      - pointer to a png input data structure
+ * io_ptr       - pointer to user supplied structure containing info about
+ *                the input functions.  May be NULL.
+ * read_data_fn - pointer to a new input function that takes as its
+ *                arguments a pointer to a png_struct, a pointer to
+ *                a location where input data can be stored, and a 32-bit
+ *                unsigned int that is the number of bytes to be read.
+ *                To exit and output any fatal error messages the new write
+ *                function should call png_error(png_ptr, "Error msg").
+ *                May be NULL, in which case libpng's default function will
+ *                be used.
+ */
 void PNGAPI
 png_set_read_fn(png_structp png_ptr, png_voidp io_ptr,
    png_rw_ptr read_data_fn)
 {
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL)
+      return;
    png_ptr->io_ptr = io_ptr;
 
-#if !defined(PNG_NO_STDIO)
+#ifdef PNG_STDIO_SUPPORTED
    if (read_data_fn != NULL)
       png_ptr->read_data_fn = read_data_fn;
    else
@@ -160,7 +173,7 @@
          "same structure.  Resetting write_data_fn to NULL.");
    }
 
-#if defined(PNG_WRITE_FLUSH_SUPPORTED)
+#ifdef PNG_WRITE_FLUSH_SUPPORTED
    png_ptr->output_flush_fn = NULL;
 #endif
 }
diff -Naur libAfterImage-1.20/libpng/pngrtran.c root/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c
--- libAfterImage-1.20/libpng/pngrtran.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,12 +1,15 @@
 
 /* pngrtran.c - transforms the data in a row for PNG readers
  *
- * Last changed in libpng 1.2.22 [November 6, 2007]
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.53 [February 26, 2015]
+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
  * This file contains functions optionally called by an application
  * in order to tell libpng how to handle data when reading a PNG.
  * Transformations that are used in both reading and writing are
@@ -14,57 +17,71 @@
  */
 
 #define PNG_INTERNAL
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
-
-#if defined(PNG_READ_SUPPORTED)
+#ifdef PNG_READ_SUPPORTED
 
 /* Set the action on getting a CRC error for an ancillary or critical chunk. */
 void PNGAPI
 png_set_crc_action(png_structp png_ptr, int crit_action, int ancil_action)
 {
-   png_debug(1, "in png_set_crc_action\n");
+   png_debug(1, "in png_set_crc_action");
+ 
+   if (png_ptr == NULL)
+      return;
+
    /* Tell libpng how we react to CRC errors in critical chunks */
-   if(png_ptr == NULL) return;
    switch (crit_action)
    {
-      case PNG_CRC_NO_CHANGE:                        /* leave setting as is */
+      case PNG_CRC_NO_CHANGE:                        /* Leave setting as is */
          break;
-      case PNG_CRC_WARN_USE:                               /* warn/use data */
+
+      case PNG_CRC_WARN_USE:                               /* Warn/use data */
          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
          png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;
          break;
-      case PNG_CRC_QUIET_USE:                             /* quiet/use data */
+
+      case PNG_CRC_QUIET_USE:                             /* Quiet/use data */
          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
          png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE |
                            PNG_FLAG_CRC_CRITICAL_IGNORE;
          break;
-      case PNG_CRC_WARN_DISCARD:    /* not a valid action for critical data */
-         png_warning(png_ptr, "Can't discard critical data on CRC error.");
-      case PNG_CRC_ERROR_QUIT:                                /* error/quit */
+
+      case PNG_CRC_WARN_DISCARD:    /* Not a valid action for critical data */
+         png_warning(png_ptr,
+            "Can't discard critical data on CRC error.");
+      case PNG_CRC_ERROR_QUIT:                                /* Error/quit */
+
       case PNG_CRC_DEFAULT:
       default:
          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
          break;
    }
 
+   /* Tell libpng how we react to CRC errors in ancillary chunks */
    switch (ancil_action)
    {
-      case PNG_CRC_NO_CHANGE:                       /* leave setting as is */
+      case PNG_CRC_NO_CHANGE:                       /* Leave setting as is */
          break;
-      case PNG_CRC_WARN_USE:                              /* warn/use data */
+
+      case PNG_CRC_WARN_USE:                              /* Warn/use data */
          png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
          png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE;
          break;
-      case PNG_CRC_QUIET_USE:                            /* quiet/use data */
+
+      case PNG_CRC_QUIET_USE:                            /* Quiet/use data */
          png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
          png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE |
                            PNG_FLAG_CRC_ANCILLARY_NOWARN;
          break;
-      case PNG_CRC_ERROR_QUIT:                               /* error/quit */
+
+      case PNG_CRC_ERROR_QUIT:                               /* Error/quit */
          png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
          png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_NOWARN;
          break;
-      case PNG_CRC_WARN_DISCARD:                      /* warn/discard data */
+
+      case PNG_CRC_WARN_DISCARD:                      /* Warn/discard data */
+
       case PNG_CRC_DEFAULT:
       default:
          png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
@@ -74,14 +91,16 @@
 
 #if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
     defined(PNG_FLOATING_POINT_SUPPORTED)
-/* handle alpha and tRNS via a background color */
+/* Handle alpha and tRNS via a background color */
 void PNGAPI
 png_set_background(png_structp png_ptr,
    png_color_16p background_color, int background_gamma_code,
    int need_expand, double background_gamma)
 {
-   png_debug(1, "in png_set_background\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_background");
+ 
+   if (png_ptr == NULL)
+      return;
    if (background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN)
    {
       png_warning(png_ptr, "Application must supply a known background gamma");
@@ -97,28 +116,32 @@
 }
 #endif
 
-#if defined(PNG_READ_16_TO_8_SUPPORTED)
-/* strip 16 bit depth files to 8 bit depth */
+#ifdef PNG_READ_16_TO_8_SUPPORTED
+/* Strip 16 bit depth files to 8 bit depth */
 void PNGAPI
 png_set_strip_16(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_strip_16\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_strip_16");
+
+   if (png_ptr == NULL)
+      return;
    png_ptr->transformations |= PNG_16_TO_8;
 }
 #endif
 
-#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
+#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
 void PNGAPI
 png_set_strip_alpha(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_strip_alpha\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_strip_alpha");
+
+   if (png_ptr == NULL)
+      return;
    png_ptr->flags |= PNG_FLAG_STRIP_ALPHA;
 }
 #endif
 
-#if defined(PNG_READ_DITHER_SUPPORTED)
+#ifdef PNG_READ_DITHER_SUPPORTED
 /* Dither file to 8 bit.  Supply a palette, the current number
  * of elements in the palette, the maximum number of elements
  * allowed, and a histogram if possible.  If the current number
@@ -142,8 +165,10 @@
    int num_palette, int maximum_colors, png_uint_16p histogram,
    int full_dither)
 {
-   png_debug(1, "in png_set_dither\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_dither");
+
+   if (png_ptr == NULL)
+      return;
    png_ptr->transformations |= PNG_DITHER;
 
    if (!full_dither)
@@ -151,7 +176,7 @@
       int i;
 
       png_ptr->dither_index = (png_bytep)png_malloc(png_ptr,
-         (png_uint_32)(num_palette * png_sizeof (png_byte)));
+         (png_uint_32)(num_palette * png_sizeof(png_byte)));
       for (i = 0; i < num_palette; i++)
          png_ptr->dither_index[i] = (png_byte)i;
    }
@@ -161,27 +186,29 @@
       if (histogram != NULL)
       {
          /* This is easy enough, just throw out the least used colors.
-            Perhaps not the best solution, but good enough. */
+          * Perhaps not the best solution, but good enough.
+          */
 
          int i;
 
-         /* initialize an array to sort colors */
+         /* Initialize an array to sort colors */
          png_ptr->dither_sort = (png_bytep)png_malloc(png_ptr,
-            (png_uint_32)(num_palette * png_sizeof (png_byte)));
+            (png_uint_32)(num_palette * png_sizeof(png_byte)));
 
-         /* initialize the dither_sort array */
+         /* Initialize the dither_sort array */
          for (i = 0; i < num_palette; i++)
             png_ptr->dither_sort[i] = (png_byte)i;
 
          /* Find the least used palette entries by starting a
-            bubble sort, and running it until we have sorted
-            out enough colors.  Note that we don't care about
-            sorting all the colors, just finding which are
-            least used. */
+          * bubble sort, and running it until we have sorted
+          * out enough colors.  Note that we don't care about
+          * sorting all the colors, just finding which are
+          * least used.
+          */
 
          for (i = num_palette - 1; i >= maximum_colors; i--)
          {
-            int done; /* to stop early if the list is pre-sorted */
+            int done; /* To stop early if the list is pre-sorted */
             int j;
 
             done = 1;
@@ -202,13 +229,14 @@
                break;
          }
 
-         /* swap the palette around, and set up a table, if necessary */
+         /* Swap the palette around, and set up a table, if necessary */
          if (full_dither)
          {
             int j = num_palette;
 
-            /* put all the useful colors within the max, but don't
-               move the others */
+            /* Put all the useful colors within the max, but don't
+             * move the others.
+             */
             for (i = 0; i < maximum_colors; i++)
             {
                if ((int)png_ptr->dither_sort[i] >= maximum_colors)
@@ -224,11 +252,12 @@
          {
             int j = num_palette;
 
-            /* move all the used colors inside the max limit, and
-               develop a translation table */
+            /* Move all the used colors inside the max limit, and
+             * develop a translation table.
+             */
             for (i = 0; i < maximum_colors; i++)
             {
-               /* only move the colors we need to */
+               /* Only move the colors we need to */
                if ((int)png_ptr->dither_sort[i] >= maximum_colors)
                {
                   png_color tmp_color;
@@ -240,20 +269,20 @@
                   tmp_color = palette[j];
                   palette[j] = palette[i];
                   palette[i] = tmp_color;
-                  /* indicate where the color went */
+                  /* Indicate where the color went */
                   png_ptr->dither_index[j] = (png_byte)i;
                   png_ptr->dither_index[i] = (png_byte)j;
                }
             }
 
-            /* find closest color for those colors we are not using */
+            /* Find closest color for those colors we are not using */
             for (i = 0; i < num_palette; i++)
             {
                if ((int)png_ptr->dither_index[i] >= maximum_colors)
                {
                   int min_d, k, min_k, d_index;
 
-                  /* find the closest color to one we threw out */
+                  /* Find the closest color to one we threw out */
                   d_index = png_ptr->dither_index[i];
                   min_d = PNG_COLOR_DIST(palette[d_index], palette[0]);
                   for (k = 1, min_k = 0; k < maximum_colors; k++)
@@ -268,61 +297,58 @@
                         min_k = k;
                      }
                   }
-                  /* point to closest color */
+                  /* Point to closest color */
                   png_ptr->dither_index[i] = (png_byte)min_k;
                }
             }
          }
          png_free(png_ptr, png_ptr->dither_sort);
-         png_ptr->dither_sort=NULL;
+         png_ptr->dither_sort = NULL;
       }
       else
       {
          /* This is much harder to do simply (and quickly).  Perhaps
-            we need to go through a median cut routine, but those
-            don't always behave themselves with only a few colors
-            as input.  So we will just find the closest two colors,
-            and throw out one of them (chosen somewhat randomly).
-            [We don't understand this at all, so if someone wants to
-             work on improving it, be our guest - AED, GRP]
-            */
+          * we need to go through a median cut routine, but those
+          * don't always behave themselves with only a few colors
+          * as input.  So we will just find the closest two colors,
+          * and throw out one of them (chosen somewhat randomly).
+          * [We don't understand this at all, so if someone wants to
+          *  work on improving it, be our guest - AED, GRP]
+          */
          int i;
          int max_d;
          int num_new_palette;
          png_dsortp t;
          png_dsortpp hash;
 
-         t=NULL;
+         t = NULL;
 
-         /* initialize palette index arrays */
+         /* Initialize palette index arrays */
          png_ptr->index_to_palette = (png_bytep)png_malloc(png_ptr,
-            (png_uint_32)(num_palette * png_sizeof (png_byte)));
+            (png_uint_32)(num_palette * png_sizeof(png_byte)));
          png_ptr->palette_to_index = (png_bytep)png_malloc(png_ptr,
-            (png_uint_32)(num_palette * png_sizeof (png_byte)));
+            (png_uint_32)(num_palette * png_sizeof(png_byte)));
 
-         /* initialize the sort array */
+         /* Initialize the sort array */
          for (i = 0; i < num_palette; i++)
          {
             png_ptr->index_to_palette[i] = (png_byte)i;
             png_ptr->palette_to_index[i] = (png_byte)i;
          }
 
-         hash = (png_dsortpp)png_malloc(png_ptr, (png_uint_32)(769 *
-            png_sizeof (png_dsortp)));
-         for (i = 0; i < 769; i++)
-            hash[i] = NULL;
-/*         png_memset(hash, 0, 769 * png_sizeof (png_dsortp)); */
+         hash = (png_dsortpp)png_calloc(png_ptr, (png_uint_32)(769 *
+            png_sizeof(png_dsortp)));
 
          num_new_palette = num_palette;
 
-         /* initial wild guess at how far apart the farthest pixel
-            pair we will be eliminating will be.  Larger
-            numbers mean more areas will be allocated, Smaller
-            numbers run the risk of not saving enough data, and
-            having to do this all over again.
-
-            I have not done extensive checking on this number.
-            */
+         /* Initial wild guess at how far apart the farthest pixel
+          * pair we will be eliminating will be.  Larger
+          * numbers mean more areas will be allocated, Smaller
+          * numbers run the risk of not saving enough data, and
+          * having to do this all over again.
+          *
+          * I have not done extensive checking on this number.
+          */
          max_d = 96;
 
          while (num_new_palette > maximum_colors)
@@ -406,8 +432,10 @@
                         png_ptr->palette_to_index[png_ptr->index_to_palette[j]]
                            = png_ptr->palette_to_index[num_new_palette];
 
-                        png_ptr->index_to_palette[j] = (png_byte)num_new_palette;
-                        png_ptr->palette_to_index[num_new_palette] = (png_byte)j;
+                        png_ptr->index_to_palette[j] =
+                            (png_byte)num_new_palette;
+                        png_ptr->palette_to_index[num_new_palette] =
+                            (png_byte)j;
                      }
                      if (num_new_palette <= maximum_colors)
                         break;
@@ -436,8 +464,8 @@
          png_free(png_ptr, hash);
          png_free(png_ptr, png_ptr->palette_to_index);
          png_free(png_ptr, png_ptr->index_to_palette);
-         png_ptr->palette_to_index=NULL;
-         png_ptr->index_to_palette=NULL;
+         png_ptr->palette_to_index = NULL;
+         png_ptr->index_to_palette = NULL;
       }
       num_palette = maximum_colors;
    }
@@ -458,15 +486,11 @@
       int num_blue = (1 << PNG_DITHER_BLUE_BITS);
       png_size_t num_entries = ((png_size_t)1 << total_bits);
 
-      png_ptr->palette_lookup = (png_bytep )png_malloc(png_ptr,
-         (png_uint_32)(num_entries * png_sizeof (png_byte)));
-
-      png_memset(png_ptr->palette_lookup, 0, num_entries *
-         png_sizeof (png_byte));
+      png_ptr->palette_lookup = (png_bytep )png_calloc(png_ptr,
+         (png_uint_32)(num_entries * png_sizeof(png_byte)));
 
       distance = (png_bytep)png_malloc(png_ptr, (png_uint_32)(num_entries *
          png_sizeof(png_byte)));
-
       png_memset(distance, 0xff, num_entries * png_sizeof(png_byte));
 
       for (i = 0; i < num_palette; i++)
@@ -480,7 +504,8 @@
          {
             /* int dr = abs(ir - r); */
             int dr = ((ir > r) ? ir - r : r - ir);
-            int index_r = (ir << (PNG_DITHER_BLUE_BITS + PNG_DITHER_GREEN_BITS));
+            int index_r = (ir << (PNG_DITHER_BLUE_BITS +
+                PNG_DITHER_GREEN_BITS));
 
             for (ig = 0; ig < num_green; ig++)
             {
@@ -526,8 +551,11 @@
 void PNGAPI
 png_set_gamma(png_structp png_ptr, double scrn_gamma, double file_gamma)
 {
-   png_debug(1, "in png_set_gamma\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_gamma");
+
+   if (png_ptr == NULL)
+      return;
+
    if ((fabs(scrn_gamma * file_gamma - 1.0) > PNG_GAMMA_THRESHOLD) ||
        (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) ||
        (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
@@ -537,7 +565,7 @@
 }
 #endif
 
-#if defined(PNG_READ_EXPAND_SUPPORTED)
+#ifdef PNG_READ_EXPAND_SUPPORTED
 /* Expand paletted images to RGB, expand grayscale images of
  * less than 8-bit depth to 8-bit depth, and expand tRNS chunks
  * to alpha channels.
@@ -545,12 +573,13 @@
 void PNGAPI
 png_set_expand(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_expand\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_expand");
+
+   if (png_ptr == NULL)
+      return;
+
    png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
-#ifdef PNG_WARN_UNINITIALIZED_ROW
    png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-#endif
 }
 
 /* GRR 19990627:  the following three functions currently are identical
@@ -566,33 +595,36 @@
  *  More to the point, these functions make it obvious what libpng will be
  *  doing, whereas "expand" can (and does) mean any number of things.
  *
- *  GRP 20060307: In libpng-1.4.0, png_set_gray_1_2_4_to_8() was modified
- *  to expand only the sample depth but not to expand the tRNS to alpha.
+ *  GRP 20060307: In libpng-1.2.9, png_set_gray_1_2_4_to_8() was modified
+ *  to expand only the sample depth but not to expand the tRNS to alpha
+ *  and its name was changed to png_set_expand_gray_1_2_4_to_8().
  */
 
 /* Expand paletted images to RGB. */
 void PNGAPI
 png_set_palette_to_rgb(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_palette_to_rgb\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_palette_to_rgb");
+
+   if (png_ptr == NULL)
+      return;
+
    png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
-#ifdef PNG_WARN_UNINITIALIZED_ROW
    png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-#endif
 }
 
-#if !defined(PNG_1_0_X)
+#ifndef PNG_1_0_X
 /* Expand grayscale images of less than 8-bit depth to 8 bits. */
 void PNGAPI
 png_set_expand_gray_1_2_4_to_8(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_expand_gray_1_2_4_to_8\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_expand_gray_1_2_4_to_8");
+
+   if (png_ptr == NULL)
+      return;
+
    png_ptr->transformations |= PNG_EXPAND;
-#ifdef PNG_WARN_UNINITIALIZED_ROW
    png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-#endif
 }
 #endif
 
@@ -602,8 +634,11 @@
 void PNGAPI
 png_set_gray_1_2_4_to_8(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_gray_1_2_4_to_8\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_gray_1_2_4_to_8");
+
+   if (png_ptr == NULL)
+      return;
+
    png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
 }
 #endif
@@ -613,28 +648,26 @@
 void PNGAPI
 png_set_tRNS_to_alpha(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_tRNS_to_alpha\n");
+   png_debug(1, "in png_set_tRNS_to_alpha");
+
    png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
-#ifdef PNG_WARN_UNINITIALIZED_ROW
    png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-#endif
 }
 #endif /* defined(PNG_READ_EXPAND_SUPPORTED) */
 
-#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
 void PNGAPI
 png_set_gray_to_rgb(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_gray_to_rgb\n");
+   png_debug(1, "in png_set_gray_to_rgb");
+
    png_ptr->transformations |= PNG_GRAY_TO_RGB;
-#ifdef PNG_WARN_UNINITIALIZED_ROW
    png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-#endif
 }
 #endif
 
-#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
-#if defined(PNG_FLOATING_POINT_SUPPORTED)
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
+#ifdef PNG_FLOATING_POINT_SUPPORTED
 /* Convert a RGB image to a grayscale of the same width.  This allows us,
  * for example, to convert a 24 bpp RGB image into an 8 bpp grayscale image.
  */
@@ -643,10 +676,22 @@
 png_set_rgb_to_gray(png_structp png_ptr, int error_action, double red,
    double green)
 {
-      int red_fixed = (int)((float)red*100000.0 + 0.5);
-      int green_fixed = (int)((float)green*100000.0 + 0.5);
-      if(png_ptr == NULL) return;
-      png_set_rgb_to_gray_fixed(png_ptr, error_action, red_fixed, green_fixed);
+   int red_fixed, green_fixed;
+   if (png_ptr == NULL)
+      return;
+   if (red > 21474.83647 || red < -21474.83648 ||
+       green > 21474.83647 || green < -21474.83648)
+   {
+      png_warning(png_ptr, "ignoring out of range rgb_to_gray coefficients");
+      red_fixed = -1;
+      green_fixed = -1;
+   }
+   else
+   {
+      red_fixed = (int)((float)red*100000.0 + 0.5);
+      green_fixed = (int)((float)green*100000.0 + 0.5);
+   }
+   png_set_rgb_to_gray_fixed(png_ptr, error_action, red_fixed, green_fixed);
 }
 #endif
 
@@ -654,36 +699,42 @@
 png_set_rgb_to_gray_fixed(png_structp png_ptr, int error_action,
    png_fixed_point red, png_fixed_point green)
 {
-   png_debug(1, "in png_set_rgb_to_gray\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_rgb_to_gray");
+
+   if (png_ptr == NULL)
+      return;
+
    switch(error_action)
    {
       case 1: png_ptr->transformations |= PNG_RGB_TO_GRAY;
               break;
+
       case 2: png_ptr->transformations |= PNG_RGB_TO_GRAY_WARN;
               break;
+
       case 3: png_ptr->transformations |= PNG_RGB_TO_GRAY_ERR;
    }
    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-#if defined(PNG_READ_EXPAND_SUPPORTED)
+#ifdef PNG_READ_EXPAND_SUPPORTED
       png_ptr->transformations |= PNG_EXPAND;
 #else
    {
-      png_warning(png_ptr, "Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED.");
+      png_warning(png_ptr,
+        "Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED.");
       png_ptr->transformations &= ~PNG_RGB_TO_GRAY;
    }
 #endif
    {
       png_uint_16 red_int, green_int;
-      if(red < 0 || green < 0)
+      if (red < 0 || green < 0)
       {
          red_int   =  6968; /* .212671 * 32768 + .5 */
          green_int = 23434; /* .715160 * 32768 + .5 */
       }
-      else if(red + green < 100000L)
+      else if (red + green < 100000L)
       {
-        red_int = (png_uint_16)(((png_uint_32)red*32768L)/100000L);
-        green_int = (png_uint_16)(((png_uint_32)green*32768L)/100000L);
+         red_int = (png_uint_16)(((png_uint_32)red*32768L)/100000L);
+         green_int = (png_uint_16)(((png_uint_32)green*32768L)/100000L);
       }
       else
       {
@@ -693,26 +744,30 @@
       }
       png_ptr->rgb_to_gray_red_coeff   = red_int;
       png_ptr->rgb_to_gray_green_coeff = green_int;
-      png_ptr->rgb_to_gray_blue_coeff  = (png_uint_16)(32768-red_int-green_int);
+      png_ptr->rgb_to_gray_blue_coeff  =
+         (png_uint_16)(32768 - red_int - green_int);
    }
 }
 #endif
 
 #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
-    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED) || \
-    defined(PNG_LEGACY_SUPPORTED)
+    defined(PNG_LEGACY_SUPPORTED) || \
+    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
 void PNGAPI
 png_set_read_user_transform_fn(png_structp png_ptr, png_user_transform_ptr
    read_user_transform_fn)
 {
-   png_debug(1, "in png_set_read_user_transform_fn\n");
-   if(png_ptr == NULL) return;
-#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
+   png_debug(1, "in png_set_read_user_transform_fn");
+
+   if (png_ptr == NULL)
+      return;
+
+#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
    png_ptr->transformations |= PNG_USER_TRANSFORM;
    png_ptr->read_user_transform_fn = read_user_transform_fn;
 #endif
 #ifdef PNG_LEGACY_SUPPORTED
-   if(read_user_transform_fn)
+   if (read_user_transform_fn)
       png_warning(png_ptr,
         "This version of libpng does not support user transforms");
 #endif
@@ -725,22 +780,25 @@
 void /* PRIVATE */
 png_init_read_transformations(png_structp png_ptr)
 {
-   png_debug(1, "in png_init_read_transformations\n");
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
-   if(png_ptr != NULL)
+   png_debug(1, "in png_init_read_transformations");
+
+#ifdef PNG_USELESS_TESTS_SUPPORTED
+  if (png_ptr != NULL)
 #endif
   {
-#if defined(PNG_READ_BACKGROUND_SUPPORTED) || defined(PNG_READ_SHIFT_SUPPORTED) \
- || defined(PNG_READ_GAMMA_SUPPORTED)
+#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
+    defined(PNG_READ_SHIFT_SUPPORTED) || \
+    defined(PNG_READ_GAMMA_SUPPORTED)
    int color_type = png_ptr->color_type;
 #endif
 
 #if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
 
-#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
    /* Detect gray background and attempt to enable optimization
-    * for gray --> RGB case */
-   /* Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
+    * for gray --> RGB case
+    *
+    * Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
     * RGB_ALPHA (in which case need_expand is superfluous anyway), the
     * background color might actually be gray yet not be flagged as such.
     * This is not a problem for the current code, which uses
@@ -767,7 +825,7 @@
    {
       if (!(color_type & PNG_COLOR_MASK_COLOR))  /* i.e., GRAY or GRAY_ALPHA */
       {
-         /* expand background and tRNS chunks */
+         /* Expand background and tRNS chunks */
          switch (png_ptr->bit_depth)
          {
             case 1:
@@ -781,6 +839,7 @@
                    = png_ptr->trans_values.blue = png_ptr->trans_values.gray;
                }
                break;
+
             case 2:
                png_ptr->background.gray *= (png_uint_16)0x55;
                png_ptr->background.red = png_ptr->background.green
@@ -792,6 +851,7 @@
                    = png_ptr->trans_values.blue = png_ptr->trans_values.gray;
                }
                break;
+
             case 4:
                png_ptr->background.gray *= (png_uint_16)0x11;
                png_ptr->background.red = png_ptr->background.green
@@ -803,7 +863,9 @@
                    = png_ptr->trans_values.blue = png_ptr->trans_values.gray;
                }
                break;
+
             case 8:
+
             case 16:
                png_ptr->background.red = png_ptr->background.green
                  = png_ptr->background.blue = png_ptr->background.gray;
@@ -819,16 +881,17 @@
          png_ptr->background.blue  =
             png_ptr->palette[png_ptr->background.index].blue;
 
-#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
+#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
         if (png_ptr->transformations & PNG_INVERT_ALPHA)
         {
-#if defined(PNG_READ_EXPAND_SUPPORTED)
+#ifdef PNG_READ_EXPAND_SUPPORTED
            if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
 #endif
            {
-           /* invert the alpha channel (in tRNS) unless the pixels are
-              going to be expanded, in which case leave it for later */
-              int i,istop;
+           /* Invert the alpha channel (in tRNS) unless the pixels are
+            * going to be expanded, in which case leave it for later
+            */
+              int i, istop;
               istop=(int)png_ptr->num_trans;
               for (i=0; i<istop; i++)
                  png_ptr->trans[i] = (png_byte)(255 - png_ptr->trans[i]);
@@ -849,12 +912,15 @@
        && (fabs(png_ptr->screen_gamma * png_ptr->gamma - 1.0)
          < PNG_GAMMA_THRESHOLD))
    {
-    int i,k;
+    int i, k;
     k=0;
     for (i=0; i<png_ptr->num_trans; i++)
     {
       if (png_ptr->trans[i] != 0 && png_ptr->trans[i] != 0xff)
-        k=1; /* partial transparency is present */
+      {
+        k=1; /* Partial transparency is present */
+        break;
+      }
     }
     if (k == 0)
       png_ptr->transformations &= ~PNG_GAMMA;
@@ -864,13 +930,13 @@
         png_ptr->gamma != 0.0)
    {
       png_build_gamma_table(png_ptr);
-#if defined(PNG_READ_BACKGROUND_SUPPORTED)
+
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
       if (png_ptr->transformations & PNG_BACKGROUND)
       {
          if (color_type == PNG_COLOR_TYPE_PALETTE)
          {
-           /* could skip if no transparency and
-           */
+           /* Could skip if no transparency */
             png_color back, back_1;
             png_colorp palette = png_ptr->palette;
             int num_palette = png_ptr->num_palette;
@@ -895,10 +961,12 @@
                      g = (png_ptr->screen_gamma);
                      gs = 1.0;
                      break;
+
                   case PNG_BACKGROUND_GAMMA_FILE:
                      g = 1.0 / (png_ptr->gamma);
                      gs = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
                      break;
+
                   case PNG_BACKGROUND_GAMMA_UNIQUE:
                      g = 1.0 / (png_ptr->background_gamma);
                      gs = 1.0 / (png_ptr->background_gamma *
@@ -920,7 +988,8 @@
                   back.red = (png_byte)(pow(
                      (double)png_ptr->background.red/255, gs) * 255.0 + .5);
                   back.green = (png_byte)(pow(
-                     (double)png_ptr->background.green/255, gs) * 255.0 + .5);
+                     (double)png_ptr->background.green/255, gs) * 255.0
+                         + .5);
                   back.blue = (png_byte)(pow(
                      (double)png_ptr->background.blue/255, gs) * 255.0 + .5);
                }
@@ -964,6 +1033,14 @@
                   palette[i].blue = png_ptr->gamma_table[palette[i].blue];
                }
             }
+            /* Prevent the transformations being done again, and make sure
+             * that the now spurious alpha channel is stripped - the code
+             * has just reduced background composition and gamma correction
+             * to a simple alpha channel strip.
+             */
+            png_ptr->transformations &= ~PNG_BACKGROUND;
+            png_ptr->transformations &= ~PNG_GAMMA;
+            png_ptr->transformations |= PNG_STRIP_ALPHA;
          }
          /* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN) */
          else
@@ -979,10 +1056,12 @@
                   g = (png_ptr->screen_gamma);
                   gs = 1.0;
                   break;
+
                case PNG_BACKGROUND_GAMMA_FILE:
                   g = 1.0 / (png_ptr->gamma);
                   gs = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
                   break;
+
                case PNG_BACKGROUND_GAMMA_UNIQUE:
                   g = 1.0 / (png_ptr->background_gamma);
                   gs = 1.0 / (png_ptr->background_gamma *
@@ -1024,7 +1103,7 @@
          }
       }
       else
-      /* transformation does not include PNG_BACKGROUND */
+      /* Transformation does not include PNG_BACKGROUND */
 #endif /* PNG_READ_BACKGROUND_SUPPORTED */
       if (color_type == PNG_COLOR_TYPE_PALETTE)
       {
@@ -1038,13 +1117,16 @@
             palette[i].green = png_ptr->gamma_table[palette[i].green];
             palette[i].blue = png_ptr->gamma_table[palette[i].blue];
          }
+
+         /* Done the gamma correction. */
+         png_ptr->transformations &= ~PNG_GAMMA;
       }
    }
-#if defined(PNG_READ_BACKGROUND_SUPPORTED)
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
    else
 #endif
 #endif /* PNG_READ_GAMMA_SUPPORTED && PNG_FLOATING_POINT_SUPPORTED */
-#if defined(PNG_READ_BACKGROUND_SUPPORTED)
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
    /* No GAMMA transformation */
    if ((png_ptr->transformations & PNG_BACKGROUND) &&
        (color_type == PNG_COLOR_TYPE_PALETTE))
@@ -1075,11 +1157,16 @@
                png_ptr->trans[i], back.blue);
          }
       }
+
+      /* Handled alpha, still need to strip the channel. */
+      png_ptr->transformations &= ~PNG_BACKGROUND;
+      png_ptr->transformations |= PNG_STRIP_ALPHA;
    }
 #endif /* PNG_READ_BACKGROUND_SUPPORTED */
 
-#if defined(PNG_READ_SHIFT_SUPPORTED)
+#ifdef PNG_READ_SHIFT_SUPPORTED
    if ((png_ptr->transformations & PNG_SHIFT) &&
+      !(png_ptr->transformations & PNG_EXPAND) &&
       (color_type == PNG_COLOR_TYPE_PALETTE))
    {
       png_uint_16 i;
@@ -1100,12 +1187,14 @@
          png_ptr->palette[i].green >>= sg;
          png_ptr->palette[i].blue >>= sb;
       }
+
+      png_ptr->transformations &= ~PNG_SHIFT;
    }
 #endif  /* PNG_READ_SHIFT_SUPPORTED */
  }
 #if !defined(PNG_READ_GAMMA_SUPPORTED) && !defined(PNG_READ_SHIFT_SUPPORTED) \
  && !defined(PNG_READ_BACKGROUND_SUPPORTED)
-   if(png_ptr)
+   if (png_ptr)
       return;
 #endif
 }
@@ -1117,13 +1206,14 @@
 void /* PRIVATE */
 png_read_transform_info(png_structp png_ptr, png_infop info_ptr)
 {
-   png_debug(1, "in png_read_transform_info\n");
-#if defined(PNG_READ_EXPAND_SUPPORTED)
+   png_debug(1, "in png_read_transform_info");
+
+#ifdef PNG_READ_EXPAND_SUPPORTED
    if (png_ptr->transformations & PNG_EXPAND)
    {
       if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
       {
-         if (png_ptr->num_trans && (png_ptr->transformations & PNG_EXPAND_tRNS))
+         if (png_ptr->num_trans)
             info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
          else
             info_ptr->color_type = PNG_COLOR_TYPE_RGB;
@@ -1136,8 +1226,6 @@
          {
             if (png_ptr->transformations & PNG_EXPAND_tRNS)
               info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
-            else
-              info_ptr->color_type |= PNG_COLOR_MASK_COLOR;
          }
          if (info_ptr->bit_depth < 8)
             info_ptr->bit_depth = 8;
@@ -1146,7 +1234,7 @@
    }
 #endif
 
-#if defined(PNG_READ_BACKGROUND_SUPPORTED)
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
    if (png_ptr->transformations & PNG_BACKGROUND)
    {
       info_ptr->color_type &= ~PNG_COLOR_MASK_ALPHA;
@@ -1155,7 +1243,7 @@
    }
 #endif
 
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
    if (png_ptr->transformations & PNG_GAMMA)
    {
 #ifdef PNG_FLOATING_POINT_SUPPORTED
@@ -1167,34 +1255,34 @@
    }
 #endif
 
-#if defined(PNG_READ_16_TO_8_SUPPORTED)
+#ifdef PNG_READ_16_TO_8_SUPPORTED
    if ((png_ptr->transformations & PNG_16_TO_8) && (info_ptr->bit_depth == 16))
       info_ptr->bit_depth = 8;
 #endif
 
-#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
    if (png_ptr->transformations & PNG_GRAY_TO_RGB)
       info_ptr->color_type |= PNG_COLOR_MASK_COLOR;
 #endif
 
-#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
    if (png_ptr->transformations & PNG_RGB_TO_GRAY)
       info_ptr->color_type &= ~PNG_COLOR_MASK_COLOR;
 #endif
 
-#if defined(PNG_READ_DITHER_SUPPORTED)
+#ifdef PNG_READ_DITHER_SUPPORTED
    if (png_ptr->transformations & PNG_DITHER)
    {
       if (((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||
-         (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)) &&
-         png_ptr->palette_lookup && info_ptr->bit_depth == 8)
+          (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)) &&
+          png_ptr->palette_lookup && info_ptr->bit_depth == 8)
       {
          info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
       }
    }
 #endif
 
-#if defined(PNG_READ_PACK_SUPPORTED)
+#ifdef PNG_READ_PACK_SUPPORTED
    if ((png_ptr->transformations & PNG_PACK) && (info_ptr->bit_depth < 8))
       info_ptr->bit_depth = 8;
 #endif
@@ -1206,7 +1294,7 @@
    else
       info_ptr->channels = 1;
 
-#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
+#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
    if (png_ptr->flags & PNG_FLAG_STRIP_ALPHA)
       info_ptr->color_type &= ~PNG_COLOR_MASK_ALPHA;
 #endif
@@ -1214,15 +1302,15 @@
    if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
       info_ptr->channels++;
 
-#if defined(PNG_READ_FILLER_SUPPORTED)
+#ifdef PNG_READ_FILLER_SUPPORTED
    /* STRIP_ALPHA and FILLER allowed:  MASK_ALPHA bit stripped above */
    if ((png_ptr->transformations & PNG_FILLER) &&
        ((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||
        (info_ptr->color_type == PNG_COLOR_TYPE_GRAY)))
    {
       info_ptr->channels++;
-      /* if adding a true alpha channel not just filler */
-#if !defined(PNG_1_0_X)
+      /* If adding a true alpha channel not just filler */
+#ifndef PNG_1_0_X
       if (png_ptr->transformations & PNG_ADD_ALPHA)
         info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
 #endif
@@ -1231,11 +1319,11 @@
 
 #if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED) && \
 defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
-   if(png_ptr->transformations & PNG_USER_TRANSFORM)
+   if (png_ptr->transformations & PNG_USER_TRANSFORM)
      {
-       if(info_ptr->bit_depth < png_ptr->user_transform_depth)
+       if (info_ptr->bit_depth < png_ptr->user_transform_depth)
          info_ptr->bit_depth = png_ptr->user_transform_depth;
-       if(info_ptr->channels < png_ptr->user_transform_channels)
+       if (info_ptr->channels < png_ptr->user_transform_channels)
          info_ptr->channels = png_ptr->user_transform_channels;
      }
 #endif
@@ -1243,10 +1331,10 @@
    info_ptr->pixel_depth = (png_byte)(info_ptr->channels *
       info_ptr->bit_depth);
 
-   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth,info_ptr->width);
+   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, info_ptr->width);
 
-#if !defined(PNG_READ_EXPAND_SUPPORTED)
-   if(png_ptr)
+#ifndef PNG_READ_EXPAND_SUPPORTED
+   if (png_ptr)
       return;
 #endif
 }
@@ -1258,14 +1346,15 @@
 void /* PRIVATE */
 png_do_read_transformations(png_structp png_ptr)
 {
-   png_debug(1, "in png_do_read_transformations\n");
+   png_debug(1, "in png_do_read_transformations");
+
    if (png_ptr->row_buf == NULL)
    {
-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
+#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
       char msg[50];
 
       png_snprintf2(msg, 50,
-         "NULL row buffer for row %ld, pass %d", png_ptr->row_number,
+         "NULL row buffer for row %ld, pass %d", (long)png_ptr->row_number,
          png_ptr->pass);
       png_error(png_ptr, msg);
 #else
@@ -1276,7 +1365,8 @@
    if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
       /* Application has failed to call either png_read_start_image()
        * or png_read_update_info() after setting transforms that expand
-       * pixels.  This check added to libpng-1.2.19 */
+       * pixels.  This check added to libpng-1.2.19
+       */
 #if (PNG_WARN_UNINITIALIZED_ROW==1)
       png_error(png_ptr, "Uninitialized row");
 #else
@@ -1284,11 +1374,14 @@
 #endif
 #endif
 
-#if defined(PNG_READ_EXPAND_SUPPORTED)
+#ifdef PNG_READ_EXPAND_SUPPORTED
    if (png_ptr->transformations & PNG_EXPAND)
    {
       if (png_ptr->row_info.color_type == PNG_COLOR_TYPE_PALETTE)
       {
+         if (png_ptr->palette == NULL)
+            png_error (png_ptr, "Palette is NULL in indexed image");
+
          png_do_expand_palette(&(png_ptr->row_info), png_ptr->row_buf + 1,
             png_ptr->palette, png_ptr->trans, png_ptr->num_trans);
       }
@@ -1305,75 +1398,78 @@
    }
 #endif
 
-#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
+#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
    if (png_ptr->flags & PNG_FLAG_STRIP_ALPHA)
       png_do_strip_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
          PNG_FLAG_FILLER_AFTER | (png_ptr->flags & PNG_FLAG_STRIP_ALPHA));
 #endif
 
-#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
    if (png_ptr->transformations & PNG_RGB_TO_GRAY)
    {
       int rgb_error =
-         png_do_rgb_to_gray(png_ptr, &(png_ptr->row_info), png_ptr->row_buf + 1);
-      if(rgb_error)
+         png_do_rgb_to_gray(png_ptr, &(png_ptr->row_info),
+             png_ptr->row_buf + 1);
+      if (rgb_error)
       {
          png_ptr->rgb_to_gray_status=1;
-         if((png_ptr->transformations & PNG_RGB_TO_GRAY) == 
+         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
              PNG_RGB_TO_GRAY_WARN)
             png_warning(png_ptr, "png_do_rgb_to_gray found nongray pixel");
-         if((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
+         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
              PNG_RGB_TO_GRAY_ERR)
             png_error(png_ptr, "png_do_rgb_to_gray found nongray pixel");
       }
    }
 #endif
 
-/*
-From Andreas Dilger e-mail to png-implement, 26 March 1998:
-
-  In most cases, the "simple transparency" should be done prior to doing
-  gray-to-RGB, or you will have to test 3x as many bytes to check if a
-  pixel is transparent.  You would also need to make sure that the
-  transparency information is upgraded to RGB.
-
-  To summarize, the current flow is:
-  - Gray + simple transparency -> compare 1 or 2 gray bytes and composite
-                                  with background "in place" if transparent,
-                                  convert to RGB if necessary
-  - Gray + alpha -> composite with gray background and remove alpha bytes,
-                                  convert to RGB if necessary
-
-  To support RGB backgrounds for gray images we need:
-  - Gray + simple transparency -> convert to RGB + simple transparency, compare
-                                  3 or 6 bytes and composite with background
-                                  "in place" if transparent (3x compare/pixel
-                                  compared to doing composite with gray bkgrnd)
-  - Gray + alpha -> convert to RGB + alpha, composite with background and
-                                  remove alpha bytes (3x float operations/pixel
-                                  compared with composite on gray background)
-
-  Greg's change will do this.  The reason it wasn't done before is for
-  performance, as this increases the per-pixel operations.  If we would check
-  in advance if the background was gray or RGB, and position the gray-to-RGB
-  transform appropriately, then it would save a lot of work/time.
+/* From Andreas Dilger e-mail to png-implement, 26 March 1998:
+ *
+ *   In most cases, the "simple transparency" should be done prior to doing
+ *   gray-to-RGB, or you will have to test 3x as many bytes to check if a
+ *   pixel is transparent.  You would also need to make sure that the
+ *   transparency information is upgraded to RGB.
+ *
+ *   To summarize, the current flow is:
+ *   - Gray + simple transparency -> compare 1 or 2 gray bytes and composite
+ *                                   with background "in place" if transparent,
+ *                                   convert to RGB if necessary
+ *   - Gray + alpha -> composite with gray background and remove alpha bytes,
+ *                                   convert to RGB if necessary
+ *
+ *   To support RGB backgrounds for gray images we need:
+ *   - Gray + simple transparency -> convert to RGB + simple transparency,
+ *                                   compare 3 or 6 bytes and composite with
+ *                                   background "in place" if transparent
+ *                                   (3x compare/pixel compared to doing
+ *                                   composite with gray bkgrnd)
+ *   - Gray + alpha -> convert to RGB + alpha, composite with background and
+ *                                   remove alpha bytes (3x float
+ *                                   operations/pixel compared with composite
+ *                                   on gray background)
+ *
+ *  Greg's change will do this.  The reason it wasn't done before is for
+ *  performance, as this increases the per-pixel operations.  If we would check
+ *  in advance if the background was gray or RGB, and position the gray-to-RGB
+ *  transform appropriately, then it would save a lot of work/time.
  */
 
-#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
-   /* if gray -> RGB, do so now only if background is non-gray; else do later
-    * for performance reasons */
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
+   /* If gray -> RGB, do so now only if background is non-gray; else do later
+    * for performance reasons
+    */
    if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
        !(png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
       png_do_gray_to_rgb(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
 
-#if defined(PNG_READ_BACKGROUND_SUPPORTED)
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
    if ((png_ptr->transformations & PNG_BACKGROUND) &&
       ((png_ptr->num_trans != 0 ) ||
       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA)))
       png_do_background(&(png_ptr->row_info), png_ptr->row_buf + 1,
          &(png_ptr->trans_values), &(png_ptr->background)
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
          , &(png_ptr->background_1),
          png_ptr->gamma_table, png_ptr->gamma_from_1,
          png_ptr->gamma_to_1, png_ptr->gamma_16_table,
@@ -1383,106 +1479,106 @@
 );
 #endif
 
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
    if ((png_ptr->transformations & PNG_GAMMA) &&
-#if defined(PNG_READ_BACKGROUND_SUPPORTED)
-      !((png_ptr->transformations & PNG_BACKGROUND) &&
-      ((png_ptr->num_trans != 0) ||
-      (png_ptr->color_type & PNG_COLOR_MASK_ALPHA))) &&
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
+       !((png_ptr->transformations & PNG_BACKGROUND) &&
+       ((png_ptr->num_trans != 0) ||
+       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA))) &&
 #endif
-      (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE))
+       (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE))
       png_do_gamma(&(png_ptr->row_info), png_ptr->row_buf + 1,
-         png_ptr->gamma_table, png_ptr->gamma_16_table,
-         png_ptr->gamma_shift);
+          png_ptr->gamma_table, png_ptr->gamma_16_table,
+          png_ptr->gamma_shift);
 #endif
 
-#if defined(PNG_READ_16_TO_8_SUPPORTED)
+#ifdef PNG_READ_16_TO_8_SUPPORTED
    if (png_ptr->transformations & PNG_16_TO_8)
       png_do_chop(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
 
-#if defined(PNG_READ_DITHER_SUPPORTED)
+#ifdef PNG_READ_DITHER_SUPPORTED
    if (png_ptr->transformations & PNG_DITHER)
    {
       png_do_dither((png_row_infop)&(png_ptr->row_info), png_ptr->row_buf + 1,
          png_ptr->palette_lookup, png_ptr->dither_index);
-      if(png_ptr->row_info.rowbytes == (png_uint_32)0)
+      if (png_ptr->row_info.rowbytes == (png_uint_32)0)
          png_error(png_ptr, "png_do_dither returned rowbytes=0");
    }
 #endif
 
-#if defined(PNG_READ_INVERT_SUPPORTED)
+#ifdef PNG_READ_INVERT_SUPPORTED
    if (png_ptr->transformations & PNG_INVERT_MONO)
       png_do_invert(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
 
-#if defined(PNG_READ_SHIFT_SUPPORTED)
+#ifdef PNG_READ_SHIFT_SUPPORTED
    if (png_ptr->transformations & PNG_SHIFT)
       png_do_unshift(&(png_ptr->row_info), png_ptr->row_buf + 1,
          &(png_ptr->shift));
 #endif
 
-#if defined(PNG_READ_PACK_SUPPORTED)
+#ifdef PNG_READ_PACK_SUPPORTED
    if (png_ptr->transformations & PNG_PACK)
       png_do_unpack(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
 
-#if defined(PNG_READ_BGR_SUPPORTED)
+#ifdef PNG_READ_BGR_SUPPORTED
    if (png_ptr->transformations & PNG_BGR)
       png_do_bgr(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
 
-#if defined(PNG_READ_PACKSWAP_SUPPORTED)
+#ifdef PNG_READ_PACKSWAP_SUPPORTED
    if (png_ptr->transformations & PNG_PACKSWAP)
       png_do_packswap(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
 
-#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
-   /* if gray -> RGB, do so now only if we did not do so above */
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
+   /* If gray -> RGB, do so now only if we did not do so above */
    if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
        (png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
       png_do_gray_to_rgb(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
 
-#if defined(PNG_READ_FILLER_SUPPORTED)
+#ifdef PNG_READ_FILLER_SUPPORTED
    if (png_ptr->transformations & PNG_FILLER)
       png_do_read_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
          (png_uint_32)png_ptr->filler, png_ptr->flags);
 #endif
 
-#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
+#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
    if (png_ptr->transformations & PNG_INVERT_ALPHA)
       png_do_read_invert_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
 
-#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED)
+#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
    if (png_ptr->transformations & PNG_SWAP_ALPHA)
       png_do_read_swap_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
 
-#if defined(PNG_READ_SWAP_SUPPORTED)
+#ifdef PNG_READ_SWAP_SUPPORTED
    if (png_ptr->transformations & PNG_SWAP_BYTES)
       png_do_swap(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
 
-#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
+#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
    if (png_ptr->transformations & PNG_USER_TRANSFORM)
     {
-      if(png_ptr->read_user_transform_fn != NULL)
-        (*(png_ptr->read_user_transform_fn)) /* user read transform function */
-          (png_ptr,                    /* png_ptr */
-           &(png_ptr->row_info),       /* row_info:     */
-             /*  png_uint_32 width;          width of row */
-             /*  png_uint_32 rowbytes;       number of bytes in row */
-             /*  png_byte color_type;        color type of pixels */
-             /*  png_byte bit_depth;         bit depth of samples */
-             /*  png_byte channels;          number of channels (1-4) */
-             /*  png_byte pixel_depth;       bits per pixel (depth*channels) */
-           png_ptr->row_buf + 1);      /* start of pixel data for row */
-#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
-      if(png_ptr->user_transform_depth)
+      if (png_ptr->read_user_transform_fn != NULL)
+         (*(png_ptr->read_user_transform_fn)) /* User read transform function */
+            (png_ptr,                    /* png_ptr */
+               &(png_ptr->row_info),     /* row_info: */
+               /*  png_uint_32 width;       width of row */
+               /*  png_uint_32 rowbytes;    number of bytes in row */
+               /*  png_byte color_type;     color type of pixels */
+               /*  png_byte bit_depth;      bit depth of samples */
+               /*  png_byte channels;       number of channels (1-4) */
+               /*  png_byte pixel_depth;    bits per pixel (depth*channels) */
+               png_ptr->row_buf + 1);    /* start of pixel data for row */
+#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
+      if (png_ptr->user_transform_depth)
          png_ptr->row_info.bit_depth = png_ptr->user_transform_depth;
-      if(png_ptr->user_transform_channels)
+      if (png_ptr->user_transform_channels)
          png_ptr->row_info.channels = png_ptr->user_transform_channels;
 #endif
       png_ptr->row_info.pixel_depth = (png_byte)(png_ptr->row_info.bit_depth *
@@ -1494,7 +1590,7 @@
 
 }
 
-#if defined(PNG_READ_PACK_SUPPORTED)
+#ifdef PNG_READ_PACK_SUPPORTED
 /* Unpack pixels of 1, 2, or 4 bits per pixel into 1 byte per pixel,
  * without changing the actual values.  Thus, if you had a row with
  * a bit depth of 1, you would end up with bytes that only contained
@@ -1504,8 +1600,9 @@
 void /* PRIVATE */
 png_do_unpack(png_row_infop row_info, png_bytep row)
 {
-   png_debug(1, "in png_do_unpack\n");
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+   png_debug(1, "in png_do_unpack");
+
+#ifdef PNG_USELESS_TESTS_SUPPORTED
    if (row != NULL && row_info != NULL && row_info->bit_depth < 8)
 #else
    if (row_info->bit_depth < 8)
@@ -1536,6 +1633,7 @@
             }
             break;
          }
+
          case 2:
          {
 
@@ -1557,6 +1655,7 @@
             }
             break;
          }
+
          case 4:
          {
             png_bytep sp = row + (png_size_t)((row_width - 1) >> 1);
@@ -1585,7 +1684,7 @@
 }
 #endif
 
-#if defined(PNG_READ_SHIFT_SUPPORTED)
+#ifdef PNG_READ_SHIFT_SUPPORTED
 /* Reverse the effects of png_do_shift.  This routine merely shifts the
  * pixels back to their significant bits values.  Thus, if you have
  * a row of bit depth 8, but only 5 are significant, this will shift
@@ -1594,9 +1693,10 @@
 void /* PRIVATE */
 png_do_unshift(png_row_infop row_info, png_bytep row, png_color_8p sig_bits)
 {
-   png_debug(1, "in png_do_unshift\n");
+   png_debug(1, "in png_do_unshift");
+
    if (
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+#ifdef PNG_USELESS_TESTS_SUPPORTED
        row != NULL && row_info != NULL && sig_bits != NULL &&
 #endif
        row_info->color_type != PNG_COLOR_TYPE_PALETTE)
@@ -1648,6 +1748,7 @@
             }
             break;
          }
+
          case 4:
          {
             png_bytep bp = row;
@@ -1663,6 +1764,7 @@
             }
             break;
          }
+
          case 8:
          {
             png_bytep bp = row;
@@ -1675,6 +1777,7 @@
             }
             break;
          }
+
          case 16:
          {
             png_bytep bp = row;
@@ -1695,13 +1798,14 @@
 }
 #endif
 
-#if defined(PNG_READ_16_TO_8_SUPPORTED)
-/* chop rows of bit depth 16 down to 8 */
+#ifdef PNG_READ_16_TO_8_SUPPORTED
+/* Chop rows of bit depth 16 down to 8 */
 void /* PRIVATE */
 png_do_chop(png_row_infop row_info, png_bytep row)
 {
-   png_debug(1, "in png_do_chop\n");
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+   png_debug(1, "in png_do_chop");
+
+#ifdef PNG_USELESS_TESTS_SUPPORTED
    if (row != NULL && row_info != NULL && row_info->bit_depth == 16)
 #else
    if (row_info->bit_depth == 16)
@@ -1714,20 +1818,23 @@
 
       for (i = 0; i<istop; i++, sp += 2, dp++)
       {
-#if defined(PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED)
+#ifdef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
       /* This does a more accurate scaling of the 16-bit color
        * value, rather than a simple low-byte truncation.
        *
        * What the ideal calculation should be:
        *   *dp = (((((png_uint_32)(*sp) << 8) |
-       *          (png_uint_32)(*(sp + 1))) * 255 + 127) / (png_uint_32)65535L;
+       *          (png_uint_32)(*(sp + 1))) * 255 + 127)
+       *          / (png_uint_32)65535L;
        *
        * GRR: no, I think this is what it really should be:
        *   *dp = (((((png_uint_32)(*sp) << 8) |
-       *           (png_uint_32)(*(sp + 1))) + 128L) / (png_uint_32)257L;
+       *           (png_uint_32)(*(sp + 1))) + 128L)
+       *           / (png_uint_32)257L;
        *
        * GRR: here's the exact calculation with shifts:
-       *   temp = (((png_uint_32)(*sp) << 8) | (png_uint_32)(*(sp + 1))) + 128L;
+       *   temp = (((png_uint_32)(*sp) << 8) |
+       *           (png_uint_32)(*(sp + 1))) + 128L;
        *   *dp = (temp - (temp >> 8)) >> 8;
        *
        * Approximate calculation with shift/add instead of multiply/divide:
@@ -1750,12 +1857,13 @@
 }
 #endif
 
-#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED)
+#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
 void /* PRIVATE */
 png_do_read_swap_alpha(png_row_infop row_info, png_bytep row)
 {
-   png_debug(1, "in png_do_read_swap_alpha\n");
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+   png_debug(1, "in png_do_read_swap_alpha");
+
+#ifdef PNG_USELESS_TESTS_SUPPORTED
    if (row != NULL && row_info != NULL)
 #endif
    {
@@ -1842,12 +1950,13 @@
 }
 #endif
 
-#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
+#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
 void /* PRIVATE */
 png_do_read_invert_alpha(png_row_infop row_info, png_bytep row)
 {
-   png_debug(1, "in png_do_read_invert_alpha\n");
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+   png_debug(1, "in png_do_read_invert_alpha");
+
+#ifdef PNG_USELESS_TESTS_SUPPORTED
    if (row != NULL && row_info != NULL)
 #endif
    {
@@ -1940,7 +2049,7 @@
 }
 #endif
 
-#if defined(PNG_READ_FILLER_SUPPORTED)
+#ifdef PNG_READ_FILLER_SUPPORTED
 /* Add filler channel if we have RGB color */
 void /* PRIVATE */
 png_do_read_filler(png_row_infop row_info, png_bytep row,
@@ -1952,14 +2061,15 @@
    png_byte hi_filler = (png_byte)((filler>>8) & 0xff);
    png_byte lo_filler = (png_byte)(filler & 0xff);
 
-   png_debug(1, "in png_do_read_filler\n");
+   png_debug(1, "in png_do_read_filler");
+
    if (
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+#ifdef PNG_USELESS_TESTS_SUPPORTED
        row != NULL  && row_info != NULL &&
 #endif
        row_info->color_type == PNG_COLOR_TYPE_GRAY)
    {
-      if(row_info->bit_depth == 8)
+      if (row_info->bit_depth == 8)
       {
          /* This changes the data from G to GX */
          if (flags & PNG_FLAG_FILLER_AFTER)
@@ -1991,7 +2101,7 @@
             row_info->rowbytes = row_width * 2;
          }
       }
-      else if(row_info->bit_depth == 16)
+      else if (row_info->bit_depth == 16)
       {
          /* This changes the data from GG to GGXX */
          if (flags & PNG_FLAG_FILLER_AFTER)
@@ -2031,7 +2141,7 @@
    } /* COLOR_TYPE == GRAY */
    else if (row_info->color_type == PNG_COLOR_TYPE_RGB)
    {
-      if(row_info->bit_depth == 8)
+      if (row_info->bit_depth == 8)
       {
          /* This changes the data from RGB to RGBX */
          if (flags & PNG_FLAG_FILLER_AFTER)
@@ -2067,7 +2177,7 @@
             row_info->rowbytes = row_width * 4;
          }
       }
-      else if(row_info->bit_depth == 16)
+      else if (row_info->bit_depth == 16)
       {
          /* This changes the data from RRGGBB to RRGGBBXX */
          if (flags & PNG_FLAG_FILLER_AFTER)
@@ -2116,17 +2226,18 @@
 }
 #endif
 
-#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
-/* expand grayscale files to RGB, with or without alpha */
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
+/* Expand grayscale files to RGB, with or without alpha */
 void /* PRIVATE */
 png_do_gray_to_rgb(png_row_infop row_info, png_bytep row)
 {
    png_uint_32 i;
    png_uint_32 row_width = row_info->width;
 
-   png_debug(1, "in png_do_gray_to_rgb\n");
+   png_debug(1, "in png_do_gray_to_rgb");
+
    if (row_info->bit_depth >= 8 &&
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+#ifdef PNG_USELESS_TESTS_SUPPORTED
        row != NULL && row_info != NULL &&
 #endif
       !(row_info->color_type & PNG_COLOR_MASK_COLOR))
@@ -2194,16 +2305,18 @@
       row_info->color_type |= PNG_COLOR_MASK_COLOR;
       row_info->pixel_depth = (png_byte)(row_info->channels *
          row_info->bit_depth);
-      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,row_width);
+      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
    }
 }
 #endif
 
-#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
-/* reduce RGB files to grayscale, with or without alpha
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
+/* Reduce RGB files to grayscale, with or without alpha
  * using the equation given in Poynton's ColorFAQ at
- * <http://www.inforamp.net/~poynton/>
- * Copyright (c) 1998-01-04 Charles Poynton poynton at inforamp.net
+ * <http://www.inforamp.net/~poynton/>  (THIS LINK IS DEAD June 2008)
+ * New link:
+ * <http://www.poynton.com/notes/colour_and_gamma/>
+ * Charles Poynton poynton at poynton.com
  *
  *     Y = 0.212671 * R + 0.715160 * G + 0.072169 * B
  *
@@ -2228,9 +2341,10 @@
    png_uint_32 row_width = row_info->width;
    int rgb_error = 0;
 
-   png_debug(1, "in png_do_rgb_to_gray\n");
+   png_debug(1, "in png_do_rgb_to_gray");
+
    if (
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+#ifdef PNG_USELESS_TESTS_SUPPORTED
        row != NULL && row_info != NULL &&
 #endif
       (row_info->color_type & PNG_COLOR_MASK_COLOR))
@@ -2254,14 +2368,14 @@
                   png_byte red   = png_ptr->gamma_to_1[*(sp++)];
                   png_byte green = png_ptr->gamma_to_1[*(sp++)];
                   png_byte blue  = png_ptr->gamma_to_1[*(sp++)];
-                  if(red != green || red != blue)
+                  if (red != green || red != blue)
                   {
                      rgb_error |= 1;
                      *(dp++) = png_ptr->gamma_from_1[
-                       (rc*red+gc*green+bc*blue)>>15];
+                       (rc*red + gc*green + bc*blue)>>15];
                   }
                   else
-                     *(dp++) = *(sp-1);
+                     *(dp++) = *(sp - 1);
                }
             }
             else
@@ -2274,13 +2388,13 @@
                   png_byte red   = *(sp++);
                   png_byte green = *(sp++);
                   png_byte blue  = *(sp++);
-                  if(red != green || red != blue)
+                  if (red != green || red != blue)
                   {
                      rgb_error |= 1;
-                     *(dp++) = (png_byte)((rc*red+gc*green+bc*blue)>>15);
+                     *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);
                   }
                   else
-                     *(dp++) = *(sp-1);
+                     *(dp++) = *(sp - 1);
                }
             }
          }
@@ -2296,18 +2410,23 @@
                for (i = 0; i < row_width; i++)
                {
                   png_uint_16 red, green, blue, w;
+                  png_byte hi,lo;
 
-                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
+                  hi=*(sp)++; lo=*(sp)++;
+                  red   = (png_uint_16)((hi << 8) | (lo));
+                  hi=*(sp)++; lo=*(sp)++;
+                  green = (png_uint_16)((hi << 8) | (lo));
+                  hi=*(sp)++; lo=*(sp)++;
+                  blue  = (png_uint_16)((hi << 8) | (lo));
 
-                  if(red == green && red == blue)
+                  if (red == green && red == blue)
                      w = red;
                   else
                   {
                      png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff) >>
                                   png_ptr->gamma_shift][red>>8];
-                     png_uint_16 green_1 = png_ptr->gamma_16_to_1[(green&0xff) >>
+                     png_uint_16 green_1 =
+                         png_ptr->gamma_16_to_1[(green&0xff) >>
                                   png_ptr->gamma_shift][green>>8];
                      png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff) >>
                                   png_ptr->gamma_shift][blue>>8];
@@ -2330,12 +2449,16 @@
                for (i = 0; i < row_width; i++)
                {
                   png_uint_16 red, green, blue, gray16;
+                  png_byte hi,lo;
 
-                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
+                  hi=*(sp)++; lo=*(sp)++;
+                  red   = (png_uint_16)((hi << 8) | (lo));
+                  hi=*(sp)++; lo=*(sp)++;
+                  green = (png_uint_16)((hi << 8) | (lo));
+                  hi=*(sp)++; lo=*(sp)++;
+                  blue  = (png_uint_16)((hi << 8) | (lo));
 
-                  if(red != green || red != blue)
+                  if (red != green || red != blue)
                      rgb_error |= 1;
                   gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);
                   *(dp++) = (png_byte)((gray16>>8) & 0xff);
@@ -2358,7 +2481,7 @@
                   png_byte red   = png_ptr->gamma_to_1[*(sp++)];
                   png_byte green = png_ptr->gamma_to_1[*(sp++)];
                   png_byte blue  = png_ptr->gamma_to_1[*(sp++)];
-                  if(red != green || red != blue)
+                  if (red != green || red != blue)
                      rgb_error |= 1;
                   *(dp++) =  png_ptr->gamma_from_1
                              [(rc*red + gc*green + bc*blue)>>15];
@@ -2375,7 +2498,7 @@
                   png_byte red   = *(sp++);
                   png_byte green = *(sp++);
                   png_byte blue  = *(sp++);
-                  if(red != green || red != blue)
+                  if (red != green || red != blue)
                      rgb_error |= 1;
                   *(dp++) =  (png_byte)((rc*red + gc*green + bc*blue)>>15);
                   *(dp++) = *(sp++);  /* alpha */
@@ -2393,23 +2516,28 @@
                for (i = 0; i < row_width; i++)
                {
                   png_uint_16 red, green, blue, w;
+                  png_byte hi,lo;
 
-                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
+                  hi=*(sp)++; lo=*(sp)++;
+                  red   = (png_uint_16)((hi << 8) | (lo));
+                  hi=*(sp)++; lo=*(sp)++;
+                  green = (png_uint_16)((hi << 8) | (lo));
+                  hi=*(sp)++; lo=*(sp)++;
+                  blue  = (png_uint_16)((hi << 8) | (lo));
 
-                  if(red == green && red == blue)
+                  if (red == green && red == blue)
                      w = red;
                   else
                   {
                      png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff) >>
-                                  png_ptr->gamma_shift][red>>8];
-                     png_uint_16 green_1 = png_ptr->gamma_16_to_1[(green&0xff) >>
-                                  png_ptr->gamma_shift][green>>8];
+                         png_ptr->gamma_shift][red>>8];
+                     png_uint_16 green_1 =
+                         png_ptr->gamma_16_to_1[(green&0xff) >>
+                         png_ptr->gamma_shift][green>>8];
                      png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff) >>
-                                  png_ptr->gamma_shift][blue>>8];
+                         png_ptr->gamma_shift][blue>>8];
                      png_uint_16 gray16  = (png_uint_16)((rc * red_1
-                                  + gc * green_1 + bc * blue_1)>>15);
+                         + gc * green_1 + bc * blue_1)>>15);
                      w = png_ptr->gamma_16_from_1[(gray16&0xff) >>
                          png_ptr->gamma_shift][gray16 >> 8];
                      rgb_error |= 1;
@@ -2432,7 +2560,7 @@
                   red   = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;
                   green = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;
                   blue  = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;
-                  if(red != green || red != blue)
+                  if (red != green || red != blue)
                      rgb_error |= 1;
                   gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);
                   *(dp++) = (png_byte)((gray16>>8) & 0xff);
@@ -2447,7 +2575,7 @@
       row_info->color_type &= ~PNG_COLOR_MASK_COLOR;
       row_info->pixel_depth = (png_byte)(row_info->channels *
          row_info->bit_depth);
-      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,row_width);
+      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
    }
    return rgb_error;
 }
@@ -2466,7 +2594,8 @@
    int i;
    int v;
 
-   png_debug(1, "in png_do_build_grayscale_palette\n");
+   png_debug(1, "in png_do_build_grayscale_palette");
+
    if (palette == NULL)
       return;
 
@@ -2476,18 +2605,22 @@
          num_palette = 2;
          color_inc = 0xff;
          break;
+
       case 2:
          num_palette = 4;
          color_inc = 0x55;
          break;
+
       case 4:
          num_palette = 16;
          color_inc = 0x11;
          break;
+
       case 8:
          num_palette = 256;
          color_inc = 1;
          break;
+
       default:
          num_palette = 0;
          color_inc = 0;
@@ -2503,14 +2636,17 @@
 }
 
 /* This function is currently unused.  Do we really need it? */
-#if defined(PNG_READ_DITHER_SUPPORTED) && defined(PNG_CORRECT_PALETTE_SUPPORTED)
+#if defined(PNG_READ_DITHER_SUPPORTED) && \
+  defined(PNG_CORRECT_PALETTE_SUPPORTED)
 void /* PRIVATE */
 png_correct_palette(png_structp png_ptr, png_colorp palette,
    int num_palette)
 {
-   png_debug(1, "in png_correct_palette\n");
+   png_debug(1, "in png_correct_palette");
+
 #if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
-    defined(PNG_READ_GAMMA_SUPPORTED) && defined(PNG_FLOATING_POINT_SUPPORTED)
+    defined(PNG_READ_GAMMA_SUPPORTED) && \
+  defined(PNG_FLOATING_POINT_SUPPORTED)
    if (png_ptr->transformations & (PNG_GAMMA | PNG_BACKGROUND))
    {
       png_color back, back_1;
@@ -2531,8 +2667,8 @@
 
          g = 1.0 / (png_ptr->background_gamma * png_ptr->screen_gamma);
 
-         if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_SCREEN ||
-             fabs(g - 1.0) < PNG_GAMMA_THRESHOLD)
+         if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_SCREEN
+             || fabs(g - 1.0) < PNG_GAMMA_THRESHOLD)
          {
             back.red = png_ptr->background.red;
             back.green = png_ptr->background.green;
@@ -2619,7 +2755,7 @@
    }
    else
 #endif
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
    if (png_ptr->transformations & PNG_GAMMA)
    {
       int i;
@@ -2631,11 +2767,11 @@
          palette[i].blue = png_ptr->gamma_table[palette[i].blue];
       }
    }
-#if defined(PNG_READ_BACKGROUND_SUPPORTED)
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
    else
 #endif
 #endif
-#if defined(PNG_READ_BACKGROUND_SUPPORTED)
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
    if (png_ptr->transformations & PNG_BACKGROUND)
    {
       if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
@@ -2665,7 +2801,7 @@
             }
          }
       }
-      else /* assume grayscale palette (what else could it be?) */
+      else /* Assume grayscale palette (what else could it be?) */
       {
          int i;
 
@@ -2684,7 +2820,7 @@
 }
 #endif
 
-#if defined(PNG_READ_BACKGROUND_SUPPORTED)
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
 /* Replace any alpha or transparency with the supplied background color.
  * "background" is already in the screen gamma, while "background_1" is
  * at a gamma of 1.0.  Paletted files have already been taken care of.
@@ -2692,7 +2828,7 @@
 void /* PRIVATE */
 png_do_background(png_row_infop row_info, png_bytep row,
    png_color_16p trans_values, png_color_16p background
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
    , png_color_16p background_1,
    png_bytep gamma_table, png_bytep gamma_from_1, png_bytep gamma_to_1,
    png_uint_16pp gamma_16, png_uint_16pp gamma_16_from_1,
@@ -2705,9 +2841,10 @@
    png_uint_32 row_width=row_info->width;
    int shift;
 
-   png_debug(1, "in png_do_background\n");
+   png_debug(1, "in png_do_background");
+
    if (background != NULL &&
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+#ifdef PNG_USELESS_TESTS_SUPPORTED
        row != NULL && row_info != NULL &&
 #endif
       (!(row_info->color_type & PNG_COLOR_MASK_ALPHA) ||
@@ -2741,9 +2878,10 @@
                   }
                   break;
                }
+
                case 2:
                {
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                   if (gamma_table != NULL)
                   {
                      sp = row;
@@ -2797,9 +2935,10 @@
                   }
                   break;
                }
+
                case 4:
                {
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                   if (gamma_table != NULL)
                   {
                      sp = row;
@@ -2853,9 +2992,10 @@
                   }
                   break;
                }
+
                case 8:
                {
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                   if (gamma_table != NULL)
                   {
                      sp = row;
@@ -2885,9 +3025,10 @@
                   }
                   break;
                }
+
                case 16:
                {
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                   if (gamma_16 != NULL)
                   {
                      sp = row;
@@ -2898,7 +3039,7 @@
                         v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
                         if (v == trans_values->gray)
                         {
-                           /* background is already in screen gamma */
+                           /* Background is already in screen gamma */
                            *sp = (png_byte)((background->gray >> 8) & 0xff);
                            *(sp + 1) = (png_byte)(background->gray & 0xff);
                         }
@@ -2931,11 +3072,12 @@
             }
             break;
          }
+
          case PNG_COLOR_TYPE_RGB:
          {
             if (row_info->bit_depth == 8)
             {
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                if (gamma_table != NULL)
                {
                   sp = row;
@@ -2976,7 +3118,7 @@
             }
             else /* if (row_info->bit_depth == 16) */
             {
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                if (gamma_16 != NULL)
                {
                   sp = row;
@@ -2988,7 +3130,7 @@
                      if (r == trans_values->red && g == trans_values->green &&
                         b == trans_values->blue)
                      {
-                        /* background is already in screen gamma */
+                        /* Background is already in screen gamma */
                         *sp = (png_byte)((background->red >> 8) & 0xff);
                         *(sp + 1) = (png_byte)(background->red & 0xff);
                         *(sp + 2) = (png_byte)((background->green >> 8) & 0xff);
@@ -3035,11 +3177,12 @@
             }
             break;
          }
+
          case PNG_COLOR_TYPE_GRAY_ALPHA:
          {
             if (row_info->bit_depth == 8)
             {
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
                    gamma_table != NULL)
                {
@@ -3055,7 +3198,7 @@
                      }
                      else if (a == 0)
                      {
-                        /* background is already in screen gamma */
+                        /* Background is already in screen gamma */
                         *dp = (png_byte)background->gray;
                      }
                      else
@@ -3081,7 +3224,7 @@
                      {
                         *dp = *sp;
                      }
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                      else if (a == 0)
                      {
                         *dp = (png_byte)background->gray;
@@ -3098,7 +3241,7 @@
             }
             else /* if (png_ptr->bit_depth == 16) */
             {
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
                    gamma_16_to_1 != NULL)
                {
@@ -3116,17 +3259,17 @@
                         *dp = (png_byte)((v >> 8) & 0xff);
                         *(dp + 1) = (png_byte)(v & 0xff);
                      }
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                      else if (a == 0)
 #else
                      else
 #endif
                      {
-                        /* background is already in screen gamma */
+                        /* Background is already in screen gamma */
                         *dp = (png_byte)((background->gray >> 8) & 0xff);
                         *(dp + 1) = (png_byte)(background->gray & 0xff);
                      }
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                      else
                      {
                         png_uint_16 g, v, w;
@@ -3152,7 +3295,7 @@
                      {
                         png_memcpy(dp, sp, 2);
                      }
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                      else if (a == 0)
 #else
                      else
@@ -3161,7 +3304,7 @@
                         *dp = (png_byte)((background->gray >> 8) & 0xff);
                         *(dp + 1) = (png_byte)(background->gray & 0xff);
                      }
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                      else
                      {
                         png_uint_16 g, v;
@@ -3177,11 +3320,12 @@
             }
             break;
          }
+
          case PNG_COLOR_TYPE_RGB_ALPHA:
          {
             if (row_info->bit_depth == 8)
             {
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
                    gamma_table != NULL)
                {
@@ -3199,7 +3343,7 @@
                      }
                      else if (a == 0)
                      {
-                        /* background is already in screen gamma */
+                        /* Background is already in screen gamma */
                         *dp = (png_byte)background->red;
                         *(dp + 1) = (png_byte)background->green;
                         *(dp + 2) = (png_byte)background->blue;
@@ -3254,7 +3398,7 @@
             }
             else /* if (row_info->bit_depth == 16) */
             {
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
                if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
                    gamma_16_to_1 != NULL)
                {
@@ -3280,7 +3424,7 @@
                      }
                      else if (a == 0)
                      {
-                        /* background is already in screen gamma */
+                        /* Background is already in screen gamma */
                         *dp = (png_byte)((background->red >> 8) & 0xff);
                         *(dp + 1) = (png_byte)(background->red & 0xff);
                         *(dp + 2) = (png_byte)((background->green >> 8) & 0xff);
@@ -3365,13 +3509,13 @@
          row_info->channels--;
          row_info->pixel_depth = (png_byte)(row_info->channels *
             row_info->bit_depth);
-         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,row_width);
+         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
       }
    }
 }
 #endif
 
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
 /* Gamma correct the image, avoiding the alpha channel.  Make sure
  * you do this after you deal with the transparency issue on grayscale
  * or RGB images. If your bit depth is 8, use gamma_table, if it
@@ -3387,9 +3531,10 @@
    png_uint_32 i;
    png_uint_32 row_width=row_info->width;
 
-   png_debug(1, "in png_do_gamma\n");
+   png_debug(1, "in png_do_gamma");
+
    if (
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+#ifdef PNG_USELESS_TESTS_SUPPORTED
        row != NULL && row_info != NULL &&
 #endif
        ((row_info->bit_depth <= 8 && gamma_table != NULL) ||
@@ -3435,6 +3580,7 @@
             }
             break;
          }
+
          case PNG_COLOR_TYPE_RGB_ALPHA:
          {
             if (row_info->bit_depth == 8)
@@ -3472,6 +3618,7 @@
             }
             break;
          }
+
          case PNG_COLOR_TYPE_GRAY_ALPHA:
          {
             if (row_info->bit_depth == 8)
@@ -3496,6 +3643,7 @@
             }
             break;
          }
+
          case PNG_COLOR_TYPE_GRAY:
          {
             if (row_info->bit_depth == 2)
@@ -3509,13 +3657,14 @@
                   int d = *sp & 0x03;
 
                   *sp = (png_byte)(
-                        ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|
-                        ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|
-                        ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|
-                        ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6) ));
+                      ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|
+                      ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|
+                      ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|
+                      ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6) ));
                   sp++;
                }
             }
+
             if (row_info->bit_depth == 4)
             {
                sp = row;
@@ -3525,10 +3674,11 @@
                   int lsb = *sp & 0x0f;
 
                   *sp = (png_byte)((((int)gamma_table[msb | (msb >> 4)]) & 0xf0)
-                          | (((int)gamma_table[(lsb << 4) | lsb]) >> 4));
+                      | (((int)gamma_table[(lsb << 4) | lsb]) >> 4));
                   sp++;
                }
             }
+
             else if (row_info->bit_depth == 8)
             {
                sp = row;
@@ -3538,6 +3688,7 @@
                   sp++;
                }
             }
+
             else if (row_info->bit_depth == 16)
             {
                sp = row;
@@ -3556,7 +3707,7 @@
 }
 #endif
 
-#if defined(PNG_READ_EXPAND_SUPPORTED)
+#ifdef PNG_READ_EXPAND_SUPPORTED
 /* Expands a palette row to an RGB or RGBA row depending
  * upon whether you supply trans and num_trans.
  */
@@ -3569,9 +3720,10 @@
    png_uint_32 i;
    png_uint_32 row_width=row_info->width;
 
-   png_debug(1, "in png_do_expand_palette\n");
+   png_debug(1, "in png_do_expand_palette");
+
    if (
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+#ifdef PNG_USELESS_TESTS_SUPPORTED
        row != NULL && row_info != NULL &&
 #endif
        row_info->color_type == PNG_COLOR_TYPE_PALETTE)
@@ -3603,6 +3755,7 @@
                }
                break;
             }
+
             case 2:
             {
                sp = row + (png_size_t)((row_width - 1) >> 2);
@@ -3624,6 +3777,7 @@
                }
                break;
             }
+
             case 4:
             {
                sp = row + (png_size_t)((row_width - 1) >> 1);
@@ -3688,6 +3842,7 @@
                   *dp-- = palette[*sp].red;
                   sp--;
                }
+
                row_info->bit_depth = 8;
                row_info->pixel_depth = 24;
                row_info->rowbytes = row_width * 3;
@@ -3712,8 +3867,9 @@
    png_uint_32 i;
    png_uint_32 row_width=row_info->width;
 
-   png_debug(1, "in png_do_expand\n");
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+   png_debug(1, "in png_do_expand");
+
+#ifdef PNG_USELESS_TESTS_SUPPORTED
    if (row != NULL && row_info != NULL)
 #endif
    {
@@ -3749,6 +3905,7 @@
                   }
                   break;
                }
+
                case 2:
                {
                   gray = (png_uint_16)((gray&0x03)*0x55);
@@ -3772,6 +3929,7 @@
                   }
                   break;
                }
+
                case 4:
                {
                   gray = (png_uint_16)((gray&0x0f)*0x11);
@@ -3795,6 +3953,7 @@
                   break;
                }
             }
+
             row_info->bit_depth = 8;
             row_info->pixel_depth = 8;
             row_info->rowbytes = row_width;
@@ -3816,6 +3975,7 @@
                   *dp-- = *sp--;
                }
             }
+
             else if (row_info->bit_depth == 16)
             {
                png_byte gray_high = (gray >> 8) & 0xff;
@@ -3824,7 +3984,7 @@
                dp = row + (row_info->rowbytes << 1) - 1;
                for (i = 0; i < row_width; i++)
                {
-                  if (*(sp-1) == gray_high && *(sp) == gray_low) 
+                  if (*(sp - 1) == gray_high && *(sp) == gray_low)
                   {
                      *dp-- = 0;
                      *dp-- = 0;
@@ -3838,6 +3998,7 @@
                   *dp-- = *sp--;
                }
             }
+
             row_info->color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
             row_info->channels = 2;
             row_info->pixel_depth = (png_byte)(row_info->bit_depth << 1);
@@ -3903,13 +4064,13 @@
          row_info->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
          row_info->channels = 4;
          row_info->pixel_depth = (png_byte)(row_info->bit_depth << 2);
-         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,row_width);
+         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
       }
    }
 }
 #endif
 
-#if defined(PNG_READ_DITHER_SUPPORTED)
+#ifdef PNG_READ_DITHER_SUPPORTED
 void /* PRIVATE */
 png_do_dither(png_row_infop row_info, png_bytep row,
     png_bytep palette_lookup, png_bytep dither_lookup)
@@ -3918,8 +4079,9 @@
    png_uint_32 i;
    png_uint_32 row_width=row_info->width;
 
-   png_debug(1, "in png_do_dither\n");
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+   png_debug(1, "in png_do_dither");
+
+#ifdef PNG_USELESS_TESTS_SUPPORTED
    if (row != NULL && row_info != NULL)
 #endif
    {
@@ -3935,13 +4097,13 @@
             g = *sp++;
             b = *sp++;
 
-            /* this looks real messy, but the compiler will reduce
-               it down to a reasonable formula.  For example, with
-               5 bits per color, we get:
-               p = (((r >> 3) & 0x1f) << 10) |
-                  (((g >> 3) & 0x1f) << 5) |
-                  ((b >> 3) & 0x1f);
-               */
+            /* This looks real messy, but the compiler will reduce
+             * it down to a reasonable formula.  For example, with
+             * 5 bits per color, we get:
+             * p = (((r >> 3) & 0x1f) << 10) |
+             *    (((g >> 3) & 0x1f) << 5) |
+             *    ((b >> 3) & 0x1f);
+             */
             p = (((r >> (8 - PNG_DITHER_RED_BITS)) &
                ((1 << PNG_DITHER_RED_BITS) - 1)) <<
                (PNG_DITHER_GREEN_BITS + PNG_DITHER_BLUE_BITS)) |
@@ -3956,7 +4118,7 @@
          row_info->color_type = PNG_COLOR_TYPE_PALETTE;
          row_info->channels = 1;
          row_info->pixel_depth = row_info->bit_depth;
-         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,row_width);
+         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
       }
       else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&
          palette_lookup != NULL && row_info->bit_depth == 8)
@@ -3985,7 +4147,7 @@
          row_info->color_type = PNG_COLOR_TYPE_PALETTE;
          row_info->channels = 1;
          row_info->pixel_depth = row_info->bit_depth;
-         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,row_width);
+         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
       }
       else if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&
          dither_lookup && row_info->bit_depth == 8)
@@ -4001,7 +4163,7 @@
 #endif
 
 #ifdef PNG_FLOATING_POINT_SUPPORTED
-#if defined(PNG_READ_GAMMA_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
 static PNG_CONST int png_gamma_shift[] =
    {0x10, 0x21, 0x42, 0x84, 0x110, 0x248, 0x550, 0xff0, 0x00};
 
@@ -4009,11 +4171,39 @@
  * tables, we don't make a full table if we are reducing to 8-bit in
  * the future.  Note also how the gamma_16 tables are segmented so that
  * we don't need to allocate > 64K chunks for a full 16-bit table.
+ *
+ * See the PNG extensions document for an integer algorithm for creating
+ * the gamma tables.  Maybe we will implement that here someday.
+ *
+ * We should only reach this point if
+ *
+ *      the file_gamma is known (i.e., the gAMA or sRGB chunk is present,
+ *      or the application has provided a file_gamma)
+ *
+ *   AND
+ *      {
+ *         the screen_gamma is known
+ *      OR
+ *
+ *         RGB_to_gray transformation is being performed
+ *      }
+ *
+ *   AND
+ *      {
+ *         the screen_gamma is different from the reciprocal of the
+ *         file_gamma by more than the specified threshold
+ *
+ *      OR
+ *
+ *         a background color has been specified and the file_gamma
+ *         and screen_gamma are not 1.0, within the specified threshold.
+ *      }
  */
+
 void /* PRIVATE */
 png_build_gamma_table(png_structp png_ptr)
 {
-  png_debug(1, "in png_build_gamma_table\n");
+  png_debug(1, "in png_build_gamma_table");
 
   if (png_ptr->bit_depth <= 8)
   {
@@ -4022,6 +4212,7 @@
 
      if (png_ptr->screen_gamma > .000001)
         g = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
+
      else
         g = 1.0;
 
@@ -4054,10 +4245,11 @@
         png_ptr->gamma_from_1 = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)256);
 
-        if(png_ptr->screen_gamma > 0.000001)
+        if (png_ptr->screen_gamma > 0.000001)
            g = 1.0 / png_ptr->screen_gamma;
+
         else
-           g = png_ptr->gamma;   /* probably doing rgb_to_gray */
+           g = png_ptr->gamma;   /* Probably doing rgb_to_gray */
 
         for (i = 0; i < 256; i++)
         {
@@ -4078,8 +4270,10 @@
      if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
      {
         sig_bit = (int)png_ptr->sig_bit.red;
+
         if ((int)png_ptr->sig_bit.green > sig_bit)
            sig_bit = png_ptr->sig_bit.green;
+
         if ((int)png_ptr->sig_bit.blue > sig_bit)
            sig_bit = png_ptr->sig_bit.blue;
      }
@@ -4090,6 +4284,7 @@
 
      if (sig_bit > 0)
         shift = 16 - sig_bit;
+
      else
         shift = 0;
 
@@ -4101,6 +4296,7 @@
 
      if (shift > 8)
         shift = 8;
+
      if (shift < 0)
         shift = 0;
 
@@ -4113,8 +4309,8 @@
      else
         g = 1.0;
 
-     png_ptr->gamma_16_table = (png_uint_16pp)png_malloc(png_ptr,
-        (png_uint_32)(num * png_sizeof (png_uint_16p)));
+     png_ptr->gamma_16_table = (png_uint_16pp)png_calloc(png_ptr,
+        (png_uint_32)(num * png_sizeof(png_uint_16p)));
 
      if (png_ptr->transformations & (PNG_16_TO_8 | PNG_BACKGROUND))
      {
@@ -4124,7 +4320,7 @@
         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_table[i] = (png_uint_16p)png_malloc(png_ptr,
-              (png_uint_32)(256 * png_sizeof (png_uint_16)));
+              (png_uint_32)(256 * png_sizeof(png_uint_16)));
         }
 
         g = 1.0 / g;
@@ -4154,9 +4350,10 @@
         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_table[i] = (png_uint_16p)png_malloc(png_ptr,
-              (png_uint_32)(256 * png_sizeof (png_uint_16)));
+              (png_uint_32)(256 * png_sizeof(png_uint_16)));
 
            ig = (((png_uint_32)i * (png_uint_32)png_gamma_shift[shift]) >> 4);
+
            for (j = 0; j < 256; j++)
            {
               png_ptr->gamma_16_table[i][j] =
@@ -4173,13 +4370,13 @@
 
         g = 1.0 / (png_ptr->gamma);
 
-        png_ptr->gamma_16_to_1 = (png_uint_16pp)png_malloc(png_ptr,
-           (png_uint_32)(num * png_sizeof (png_uint_16p )));
+        png_ptr->gamma_16_to_1 = (png_uint_16pp)png_calloc(png_ptr,
+           (png_uint_32)(num * png_sizeof(png_uint_16p )));
 
         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_to_1[i] = (png_uint_16p)png_malloc(png_ptr,
-              (png_uint_32)(256 * png_sizeof (png_uint_16)));
+              (png_uint_32)(256 * png_sizeof(png_uint_16)));
 
            ig = (((png_uint_32)i *
               (png_uint_32)png_gamma_shift[shift]) >> 4);
@@ -4191,21 +4388,23 @@
            }
         }
 
-        if(png_ptr->screen_gamma > 0.000001)
+        if (png_ptr->screen_gamma > 0.000001)
            g = 1.0 / png_ptr->screen_gamma;
+
         else
-           g = png_ptr->gamma;   /* probably doing rgb_to_gray */
+           g = png_ptr->gamma;   /* Probably doing rgb_to_gray */
 
-        png_ptr->gamma_16_from_1 = (png_uint_16pp)png_malloc(png_ptr,
-           (png_uint_32)(num * png_sizeof (png_uint_16p)));
+        png_ptr->gamma_16_from_1 = (png_uint_16pp)png_calloc(png_ptr,
+           (png_uint_32)(num * png_sizeof(png_uint_16p)));
 
         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_from_1[i] = (png_uint_16p)png_malloc(png_ptr,
-              (png_uint_32)(256 * png_sizeof (png_uint_16)));
+              (png_uint_32)(256 * png_sizeof(png_uint_16)));
 
            ig = (((png_uint_32)i *
               (png_uint_32)png_gamma_shift[shift]) >> 4);
+
            for (j = 0; j < 256; j++)
            {
               png_ptr->gamma_16_from_1[i][j] =
@@ -4221,14 +4420,15 @@
 /* To do: install integer version of png_build_gamma_table here */
 #endif
 
-#if defined(PNG_MNG_FEATURES_SUPPORTED)
-/* undoes intrapixel differencing  */
+#ifdef PNG_MNG_FEATURES_SUPPORTED
+/* Undoes intrapixel differencing  */
 void /* PRIVATE */
 png_do_read_intrapixel(png_row_infop row_info, png_bytep row)
 {
-   png_debug(1, "in png_do_read_intrapixel\n");
+   png_debug(1, "in png_do_read_intrapixel");
+
    if (
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+#ifdef PNG_USELESS_TESTS_SUPPORTED
        row != NULL && row_info != NULL &&
 #endif
        (row_info->color_type & PNG_COLOR_MASK_COLOR))
@@ -4242,8 +4442,10 @@
 
          if (row_info->color_type == PNG_COLOR_TYPE_RGB)
             bytes_per_pixel = 3;
+
          else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
             bytes_per_pixel = 4;
+
          else
             return;
 
@@ -4260,18 +4462,20 @@
 
          if (row_info->color_type == PNG_COLOR_TYPE_RGB)
             bytes_per_pixel = 6;
+
          else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
             bytes_per_pixel = 8;
+
          else
             return;
 
          for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
          {
-            png_uint_32 s0   = (*(rp  ) << 8) | *(rp+1);
-            png_uint_32 s1   = (*(rp+2) << 8) | *(rp+3);
-            png_uint_32 s2   = (*(rp+4) << 8) | *(rp+5);
-            png_uint_32 red  = (png_uint_32)((s0+s1+65536L) & 0xffffL);
-            png_uint_32 blue = (png_uint_32)((s2+s1+65536L) & 0xffffL);
+            png_uint_32 s0   = (*(rp    ) << 8) | *(rp + 1);
+            png_uint_32 s1   = (*(rp + 2) << 8) | *(rp + 3);
+            png_uint_32 s2   = (*(rp + 4) << 8) | *(rp + 5);
+            png_uint_32 red  = (png_uint_32)((s0 + s1 + 65536L) & 0xffffL);
+            png_uint_32 blue = (png_uint_32)((s2 + s1 + 65536L) & 0xffffL);
             *(rp  ) = (png_byte)((red >> 8) & 0xff);
             *(rp+1) = (png_byte)(red & 0xff);
             *(rp+4) = (png_byte)((blue >> 8) & 0xff);
diff -Naur libAfterImage-1.20/libpng/pngrutil.c root/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c
--- libAfterImage-1.20/libpng/pngrutil.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,36 +1,40 @@
 
 /* pngrutil.c - utilities to read a PNG file
  *
- * Last changed in libpng 1.2.22 [November 6, 2007]
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.55 [%RDATE%]
+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
  * This file contains routines that are only called from within
  * libpng itself during the course of reading an image.
  */
 
 #define PNG_INTERNAL
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
-
-#if defined(PNG_READ_SUPPORTED)
+#ifdef PNG_READ_SUPPORTED
 
 #if defined(_WIN32_WCE) && (_WIN32_WCE<0x500)
 #  define WIN32_WCE_OLD
 #endif
 
 #ifdef PNG_FLOATING_POINT_SUPPORTED
-#  if defined(WIN32_WCE_OLD)
-/* strtod() function is not supported on WindowsCE */
-__inline double png_strtod(png_structp png_ptr, PNG_CONST char *nptr, char **endptr)
+#  ifdef WIN32_WCE_OLD
+/* The strtod() function is not supported on WindowsCE */
+__inline double png_strtod(png_structp png_ptr, PNG_CONST char *nptr,
+    char **endptr)
 {
    double result = 0;
    int len;
    wchar_t *str, *end;
 
    len = MultiByteToWideChar(CP_ACP, 0, nptr, -1, NULL, 0);
-   str = (wchar_t *)png_malloc(png_ptr, len * sizeof(wchar_t));
+   str = (wchar_t *)png_malloc(png_ptr, len * png_sizeof(wchar_t));
    if ( NULL != str )
    {
       MultiByteToWideChar(CP_ACP, 0, nptr, -1, str, len);
@@ -49,9 +53,17 @@
 png_uint_32 PNGAPI
 png_get_uint_31(png_structp png_ptr, png_bytep buf)
 {
+#ifdef PNG_READ_BIG_ENDIAN_SUPPORTED
    png_uint_32 i = png_get_uint_32(buf);
+#else
+   /* Avoid an extra function call by inlining the result. */
+   png_uint_32 i = ((png_uint_32)((*(buf    )) & 0xff) << 24) +
+                   ((png_uint_32)((*(buf + 1)) & 0xff) << 16) +
+                   ((png_uint_32)((*(buf + 2)) & 0xff) <<  8) +
+                   ((png_uint_32)((*(buf + 3)) & 0xff)      );
+#endif
    if (i > PNG_UINT_31_MAX)
-     png_error(png_ptr, "PNG unsigned integer out of range.");
+      png_error(png_ptr, "PNG unsigned integer out of range.");
    return (i);
 }
 #ifndef PNG_READ_BIG_ENDIAN_SUPPORTED
@@ -59,24 +71,25 @@
 png_uint_32 PNGAPI
 png_get_uint_32(png_bytep buf)
 {
-   png_uint_32 i = ((png_uint_32)(*buf) << 24) +
-      ((png_uint_32)(*(buf + 1)) << 16) +
-      ((png_uint_32)(*(buf + 2)) << 8) +
-      (png_uint_32)(*(buf + 3));
+   png_uint_32 i = ((png_uint_32)((*(buf    )) & 0xff) << 24) +
+                   ((png_uint_32)((*(buf + 1)) & 0xff) << 16) +
+                   ((png_uint_32)((*(buf + 2)) & 0xff) <<  8) +
+                   ((png_uint_32)((*(buf + 3)) & 0xff)      );
 
    return (i);
 }
 
 /* Grab a signed 32-bit integer from a buffer in big-endian format.  The
  * data is stored in the PNG file in two's complement format, and it is
- * assumed that the machine format for signed integers is the same. */
+ * assumed that the machine format for signed integers is the same.
+ */
 png_int_32 PNGAPI
 png_get_int_32(png_bytep buf)
 {
-   png_int_32 i = ((png_int_32)(*buf) << 24) +
-      ((png_int_32)(*(buf + 1)) << 16) +
-      ((png_int_32)(*(buf + 2)) << 8) +
-      (png_int_32)(*(buf + 3));
+   png_int_32 i = ((png_int_32)((*(buf    )) & 0xff) << 24) +
+                  ((png_int_32)((*(buf + 1)) & 0xff) << 16) +
+                  ((png_int_32)((*(buf + 2)) & 0xff) <<  8) +
+                  ((png_int_32)((*(buf + 3)) & 0xff)      );
 
    return (i);
 }
@@ -85,26 +98,57 @@
 png_uint_16 PNGAPI
 png_get_uint_16(png_bytep buf)
 {
-   png_uint_16 i = (png_uint_16)(((png_uint_16)(*buf) << 8) +
-      (png_uint_16)(*(buf + 1)));
+   png_uint_16 i = ((png_uint_16)((*(buf     )) & 0xff) << 8) +
+                   ((png_uint_16)((*(buf +  1)) & 0xff)     );
 
    return (i);
 }
 #endif /* PNG_READ_BIG_ENDIAN_SUPPORTED */
 
+/* Read the chunk header (length + type name).
+ * Put the type name into png_ptr->chunk_name, and return the length.
+ */
+png_uint_32 /* PRIVATE */
+png_read_chunk_header(png_structp png_ptr)
+{
+   png_byte buf[8];
+   png_uint_32 length;
+
+   /* Read the length and the chunk name */
+   png_read_data(png_ptr, buf, 8);
+   length = png_get_uint_31(png_ptr, buf);
+
+   /* Put the chunk name into png_ptr->chunk_name */
+   png_memcpy(png_ptr->chunk_name, buf + 4, 4);
+
+   png_debug2(0, "Reading %s chunk, length = %lu",
+      png_ptr->chunk_name, length);
+
+   /* Reset the crc and run it over the chunk name */
+   png_reset_crc(png_ptr);
+   png_calculate_crc(png_ptr, png_ptr->chunk_name, 4);
+
+   /* Check to see if chunk name is valid */
+   png_check_chunk_name(png_ptr, png_ptr->chunk_name);
+
+   return length;
+}
+
 /* Read data, and (optionally) run it through the CRC. */
 void /* PRIVATE */
 png_crc_read(png_structp png_ptr, png_bytep buf, png_size_t length)
 {
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL)
+      return;
    png_read_data(png_ptr, buf, length);
    png_calculate_crc(png_ptr, buf, length);
 }
 
 /* Optionally skip data and then check the CRC.  Depending on whether we
-   are reading a ancillary or critical chunk, and how the program has set
-   things up, we may calculate the CRC on the data and print a message.
-   Returns '1' if there was a CRC error, '0' otherwise. */
+ * are reading a ancillary or critical chunk, and how the program has set
+ * things up, we may calculate the CRC on the data and print a message.
+ * Returns '1' if there was a CRC error, '0' otherwise.
+ */
 int /* PRIVATE */
 png_crc_finish(png_structp png_ptr, png_uint_32 skip)
 {
@@ -123,7 +167,7 @@
    if (png_crc_error(png_ptr))
    {
       if (((png_ptr->chunk_name[0] & 0x20) &&                /* Ancillary */
-           !(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)) ||
+          !(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)) ||
           (!(png_ptr->chunk_name[0] & 0x20) &&             /* Critical  */
           (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE)))
       {
@@ -140,7 +184,8 @@
 }
 
 /* Compare the CRC stored in the PNG file with that calculated by libpng from
-   the data it has read thus far. */
+ * the data it has read thus far.
+ */
 int /* PRIVATE */
 png_crc_error(png_structp png_ptr)
 {
@@ -173,6 +218,100 @@
 
 #if defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) || \
     defined(PNG_READ_iCCP_SUPPORTED)
+static png_size_t
+png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size,
+        png_bytep output, png_size_t output_size)
+{
+   png_size_t count = 0;
+
+   png_ptr->zstream.next_in = (png_bytep)data; /* const_cast: VALID */
+   png_ptr->zstream.avail_in = size;
+
+   while (1)
+   {
+      int ret, avail;
+
+      /* Reset the output buffer each time round - we empty it
+       * after every inflate call.
+       */
+      png_ptr->zstream.next_out = png_ptr->zbuf;
+      png_ptr->zstream.avail_out = png_ptr->zbuf_size;
+
+      ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);
+      avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out;
+
+      /* First copy/count any new output - but only if we didn't
+       * get an error code.
+       */
+      if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0)
+      {
+         if (output != 0 && output_size > count)
+         {
+            png_size_t copy = output_size - count;
+            if ((png_size_t) avail < copy) copy = (png_size_t) avail;
+            png_memcpy(output + count, png_ptr->zbuf, copy);
+         }
+         count += avail;
+      }
+
+      if (ret == Z_OK)
+         continue;
+
+      /* Termination conditions - always reset the zstream, it
+       * must be left in inflateInit state.
+       */
+      png_ptr->zstream.avail_in = 0;
+      inflateReset(&png_ptr->zstream);
+
+      if (ret == Z_STREAM_END)
+         return count; /* NOTE: may be zero. */
+
+      /* Now handle the error codes - the API always returns 0
+       * and the error message is dumped into the uncompressed
+       * buffer if available.
+       */
+      {
+         PNG_CONST char *msg;
+         if (png_ptr->zstream.msg != 0)
+            msg = png_ptr->zstream.msg;
+         else
+         {
+#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
+            char umsg[52];
+
+            switch (ret)
+            {
+               case Z_BUF_ERROR:
+                  msg = "Buffer error in compressed datastream in %s chunk";
+                  break;
+               case Z_DATA_ERROR:
+                  msg = "Data error in compressed datastream in %s chunk";
+                  break;
+               default:
+                  msg = "Incomplete compressed datastream in %s chunk";
+                  break;
+            }
+
+            png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);
+            msg = umsg;
+            png_warning(png_ptr, msg);
+#else
+            msg = "Damaged compressed datastream in chunk other than IDAT";
+#endif
+         }
+
+#ifndef PNG_STDIO_SUPPORTED
+         png_warning(png_ptr, msg);
+#endif
+      }
+
+      /* 0 means an error - notice that this code simple ignores
+       * zero length compressed chunks as a result.
+       */
+      return 0;
+   }
+}
+
 /*
  * Decompress trailing data in a chunk.  The assumption is that chunkdata
  * points at an allocated area holding the contents of a chunk with a
@@ -180,170 +319,115 @@
  * holding the original prefix part and an uncompressed version of the
  * trailing part (the malloc area passed in is freed).
  */
-png_charp /* PRIVATE */
+void /* PRIVATE */
 png_decompress_chunk(png_structp png_ptr, int comp_type,
-                              png_charp chunkdata, png_size_t chunklength,
-                              png_size_t prefix_size, png_size_t *newlength)
+    png_size_t chunklength,
+    png_size_t prefix_size, png_size_t *newlength)
 {
-   static PNG_CONST char msg[] = "Error decoding compressed text";
-   png_charp text;
-   png_size_t text_size;
+   /* The caller should guarantee this */
+   if (prefix_size > chunklength)
+   {
+      /* The recovery is to delete the chunk. */
+      png_warning(png_ptr, "invalid chunklength");
+      prefix_size = 0; /* To delete everything */
+   }
 
-   if (comp_type == PNG_COMPRESSION_TYPE_BASE)
+   else if (comp_type == PNG_COMPRESSION_TYPE_BASE)
    {
-      int ret = Z_OK;
-      png_ptr->zstream.next_in = (png_bytep)(chunkdata + prefix_size);
-      png_ptr->zstream.avail_in = (uInt)(chunklength - prefix_size);
-      png_ptr->zstream.next_out = png_ptr->zbuf;
-      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
+      png_size_t expanded_size = png_inflate(png_ptr,
+                (png_bytep)(png_ptr->chunkdata + prefix_size),
+                chunklength - prefix_size,
+                0/*output*/, 0/*output size*/);
 
-      text_size = 0;
-      text = NULL;
+      /* Now check the limits on this chunk - if the limit fails the
+       * compressed data will be removed, the prefix will remain.
+       */
+      if (prefix_size >= (~(png_size_t)0) - 1 ||
+         expanded_size >= (~(png_size_t)0) - 1 - prefix_size
+#ifdef PNG_USER_CHUNK_MALLOC_MAX
+         || ((PNG_USER_CHUNK_MALLOC_MAX > 0) &&
+          prefix_size + expanded_size >= PNG_USER_CHUNK_MALLOC_MAX - 1)
+#endif
+          )
+         png_warning(png_ptr, "Exceeded size limit while expanding chunk");
 
-      while (png_ptr->zstream.avail_in)
+      /* If the size is zero either there was an error and a message
+       * has already been output (warning) or the size really is zero
+       * and we have nothing to do - the code will exit through the
+       * error case below.
+       */
+      else if (expanded_size > 0)
       {
-         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
-         if (ret != Z_OK && ret != Z_STREAM_END)
-         {
-            if (png_ptr->zstream.msg != NULL)
-               png_warning(png_ptr, png_ptr->zstream.msg);
-            else
-               png_warning(png_ptr, msg);
-            inflateReset(&png_ptr->zstream);
-            png_ptr->zstream.avail_in = 0;
-
-            if (text ==  NULL)
-            {
-               text_size = prefix_size + png_sizeof(msg) + 1;
-               text = (png_charp)png_malloc_warn(png_ptr, text_size);
-               if (text ==  NULL)
-                 {
-                    png_free(png_ptr,chunkdata);
-                    png_error(png_ptr,"Not enough memory to decompress chunk");
-                 }
-               png_memcpy(text, chunkdata, prefix_size);
-            }
-
-            text[text_size - 1] = 0x00;
-
-            /* Copy what we can of the error message into the text chunk */
-            text_size = (png_size_t)(chunklength - (text - chunkdata) - 1);
-            text_size = png_sizeof(msg) > text_size ? text_size :
-               png_sizeof(msg);
-            png_memcpy(text + prefix_size, msg, text_size + 1);
-            break;
-         }
-         if (!png_ptr->zstream.avail_out || ret == Z_STREAM_END)
+         /* Success (maybe) - really uncompress the chunk. */
+         png_size_t new_size = 0;
+
+         png_charp text = png_malloc_warn(png_ptr,
+             prefix_size + expanded_size + 1);
+
+         if (text != NULL)
          {
-            if (text == NULL)
-            {
-               text_size = prefix_size +
-                   png_ptr->zbuf_size - png_ptr->zstream.avail_out;
-               text = (png_charp)png_malloc_warn(png_ptr, text_size + 1);
-               if (text ==  NULL)
-                 {
-                    png_free(png_ptr,chunkdata);
-                    png_error(png_ptr,"Not enough memory to decompress chunk.");
-                 }
-               png_memcpy(text + prefix_size, png_ptr->zbuf,
-                    text_size - prefix_size);
-               png_memcpy(text, chunkdata, prefix_size);
-               *(text + text_size) = 0x00;
-            }
-            else
-            {
-               png_charp tmp;
+            png_memcpy(text, png_ptr->chunkdata, prefix_size);
+            new_size = png_inflate(png_ptr,
+                (png_bytep)(png_ptr->chunkdata + prefix_size),
+                chunklength - prefix_size,
+                (png_bytep)(text + prefix_size), expanded_size);
+            text[prefix_size + expanded_size] = 0; /* just in case */
 
-               tmp = text;
-               text = (png_charp)png_malloc_warn(png_ptr,
-                  (png_uint_32)(text_size +
-                  png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1));
-               if (text == NULL)
-               {
-                  png_free(png_ptr, tmp);
-                  png_free(png_ptr, chunkdata);
-                  png_error(png_ptr,"Not enough memory to decompress chunk..");
-               }
-               png_memcpy(text, tmp, text_size);
-               png_free(png_ptr, tmp);
-               png_memcpy(text + text_size, png_ptr->zbuf,
-                  (png_ptr->zbuf_size - png_ptr->zstream.avail_out));
-               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;
-               *(text + text_size) = 0x00;
-            }
-            if (ret == Z_STREAM_END)
-               break;
-            else
+            if (new_size == expanded_size)
             {
-               png_ptr->zstream.next_out = png_ptr->zbuf;
-               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
+               png_free(png_ptr, png_ptr->chunkdata);
+               png_ptr->chunkdata = text;
+               *newlength = prefix_size + expanded_size;
+               return; /* The success return! */
             }
-         }
-      }
-      if (ret != Z_STREAM_END)
-      {
-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
-         char umsg[52];
 
-         if (ret == Z_BUF_ERROR)
-            png_snprintf(umsg, 52,
-                "Buffer error in compressed datastream in %s chunk",
-                png_ptr->chunk_name);
-         else if (ret == Z_DATA_ERROR)
-            png_snprintf(umsg, 52,
-                "Data error in compressed datastream in %s chunk",
-                png_ptr->chunk_name);
-         else
-            png_snprintf(umsg, 52,
-                "Incomplete compressed datastream in %s chunk",
-                png_ptr->chunk_name);
-         png_warning(png_ptr, umsg);
-#else
-         png_warning(png_ptr,
-            "Incomplete compressed datastream in chunk other than IDAT");
-#endif
-         text_size=prefix_size;
-         if (text ==  NULL)
-         {
-            text = (png_charp)png_malloc_warn(png_ptr, text_size+1);
-            if (text == NULL)
-              {
-                png_free(png_ptr, chunkdata);
-                png_error(png_ptr,"Not enough memory for text.");
-              }
-            png_memcpy(text, chunkdata, prefix_size);
+            png_warning(png_ptr, "png_inflate logic error");
+            png_free(png_ptr, text);
          }
-         *(text + text_size) = 0x00;
+         else
+          png_warning(png_ptr, "Not enough memory to decompress chunk.");
       }
-
-      inflateReset(&png_ptr->zstream);
-      png_ptr->zstream.avail_in = 0;
-
-      png_free(png_ptr, chunkdata);
-      chunkdata = text;
-      *newlength=text_size;
    }
+
    else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */
    {
-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
+#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
       char umsg[50];
 
-      png_snprintf(umsg, 50,
-         "Unknown zTXt compression type %d", comp_type);
+      png_snprintf(umsg, sizeof umsg, "Unknown zTXt compression type %d",
+          comp_type);
       png_warning(png_ptr, umsg);
 #else
       png_warning(png_ptr, "Unknown zTXt compression type");
 #endif
 
-      *(chunkdata + prefix_size) = 0x00;
-      *newlength=prefix_size;
+      /* The recovery is to simply drop the data. */
    }
 
-   return chunkdata;
+   /* Generic error return - leave the prefix, delete the compressed
+    * data, reallocate the chunkdata to remove the potentially large
+    * amount of compressed data.
+    */
+   {
+      png_charp text = png_malloc_warn(png_ptr, prefix_size + 1);
+      if (text != NULL)
+      {
+         if (prefix_size > 0)
+            png_memcpy(text, png_ptr->chunkdata, prefix_size);
+         png_free(png_ptr, png_ptr->chunkdata);
+         png_ptr->chunkdata = text;
+
+         /* This is an extra zero in the 'uncompressed' part. */
+         *(png_ptr->chunkdata + prefix_size) = 0x00;
+      }
+      /* Ignore a malloc error here - it is safe. */
+   }
+
+   *newlength = prefix_size;
 }
 #endif
 
-/* read and check the IDHR chunk */
+/* Read and check the IDHR chunk */
 void /* PRIVATE */
 png_handle_IHDR(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
@@ -352,12 +436,12 @@
    int bit_depth, color_type, compression_type, filter_type;
    int interlace_type;
 
-   png_debug(1, "in png_handle_IHDR\n");
+   png_debug(1, "in png_handle_IHDR");
 
    if (png_ptr->mode & PNG_HAVE_IHDR)
       png_error(png_ptr, "Out of place IHDR");
 
-   /* check the length */
+   /* Check the length */
    if (length != 13)
       png_error(png_ptr, "Invalid IHDR chunk");
 
@@ -374,66 +458,71 @@
    filter_type = buf[11];
    interlace_type = buf[12];
 
-   /* set internal variables */
+   /* Set internal variables */
    png_ptr->width = width;
    png_ptr->height = height;
    png_ptr->bit_depth = (png_byte)bit_depth;
    png_ptr->interlaced = (png_byte)interlace_type;
    png_ptr->color_type = (png_byte)color_type;
-#if defined(PNG_MNG_FEATURES_SUPPORTED)
+#ifdef PNG_MNG_FEATURES_SUPPORTED
    png_ptr->filter_type = (png_byte)filter_type;
 #endif
    png_ptr->compression_type = (png_byte)compression_type;
 
-   /* find number of channels */
+   /* Find number of channels */
    switch (png_ptr->color_type)
    {
       case PNG_COLOR_TYPE_GRAY:
       case PNG_COLOR_TYPE_PALETTE:
          png_ptr->channels = 1;
          break;
+
       case PNG_COLOR_TYPE_RGB:
          png_ptr->channels = 3;
          break;
+
       case PNG_COLOR_TYPE_GRAY_ALPHA:
          png_ptr->channels = 2;
          break;
+
       case PNG_COLOR_TYPE_RGB_ALPHA:
          png_ptr->channels = 4;
          break;
    }
 
-   /* set up other useful info */
+   /* Set up other useful info */
    png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth *
    png_ptr->channels);
-   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,png_ptr->width);
-   png_debug1(3,"bit_depth = %d\n", png_ptr->bit_depth);
-   png_debug1(3,"channels = %d\n", png_ptr->channels);
-   png_debug1(3,"rowbytes = %lu\n", png_ptr->rowbytes);
+   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->width);
+   png_debug1(3, "bit_depth = %d", png_ptr->bit_depth);
+   png_debug1(3, "channels = %d", png_ptr->channels);
+   png_debug1(3, "rowbytes = %lu", png_ptr->rowbytes);
    png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,
       color_type, interlace_type, compression_type, filter_type);
 }
 
-/* read and check the palette */
+/* Read and check the palette */
 void /* PRIVATE */
 png_handle_PLTE(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
    png_color palette[PNG_MAX_PALETTE_LENGTH];
-   int num, i;
-#ifndef PNG_NO_POINTER_INDEXING
+   int max_palette_length, num, i;
+#ifdef PNG_POINTER_INDEXING_SUPPORTED
    png_colorp pal_ptr;
 #endif
 
-   png_debug(1, "in png_handle_PLTE\n");
+   png_debug(1, "in png_handle_PLTE");
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before PLTE");
+
    else if (png_ptr->mode & PNG_HAVE_IDAT)
    {
       png_warning(png_ptr, "Invalid PLTE after IDAT");
       png_crc_finish(png_ptr, length);
       return;
    }
+
    else if (png_ptr->mode & PNG_HAVE_PLTE)
       png_error(png_ptr, "Duplicate PLTE chunk");
 
@@ -446,7 +535,7 @@
       png_crc_finish(png_ptr, length);
       return;
    }
-#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
+#ifndef PNG_READ_OPT_PLTE_SUPPORTED
    if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
    {
       png_crc_finish(png_ptr, length);
@@ -462,15 +551,30 @@
          png_crc_finish(png_ptr, length);
          return;
       }
+
       else
       {
          png_error(png_ptr, "Invalid palette chunk");
       }
    }
 
+   /* The cast is safe because 'length' is less than 3*PNG_MAX_PALETTE_LENGTH */
    num = (int)length / 3;
 
-#ifndef PNG_NO_POINTER_INDEXING
+   /* If the palette has 256 or fewer entries but is too large for the bit
+    * depth, we don't issue an error, to preserve the behavior of previous
+    * libpng versions. We silently truncate the unused extra palette entries
+    * here.
+    */
+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+      max_palette_length = (1 << png_ptr->bit_depth);
+   else
+      max_palette_length = PNG_MAX_PALETTE_LENGTH;
+
+   if (num > max_palette_length)
+      num = max_palette_length;
+
+#ifdef PNG_POINTER_INDEXING_SUPPORTED
    for (i = 0, pal_ptr = palette; i < num; i++, pal_ptr++)
    {
       png_byte buf[3];
@@ -486,7 +590,7 @@
       png_byte buf[3];
 
       png_crc_read(png_ptr, buf, 3);
-      /* don't depend upon png_color being any order */
+      /* Don't depend upon png_color being any order */
       palette[i].red = buf[0];
       palette[i].green = buf[1];
       palette[i].blue = buf[2];
@@ -494,16 +598,17 @@
 #endif
 
    /* If we actually NEED the PLTE chunk (ie for a paletted image), we do
-      whatever the normal CRC configuration tells us.  However, if we
-      have an RGB image, the PLTE can be considered ancillary, so
-      we will act as though it is. */
-#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
+    * whatever the normal CRC configuration tells us.  However, if we
+    * have an RGB image, the PLTE can be considered ancillary, so
+    * we will act as though it is.
+    */
+#ifndef PNG_READ_OPT_PLTE_SUPPORTED
    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
 #endif
    {
-      png_crc_finish(png_ptr, 0);
+      png_crc_finish(png_ptr, (int) length - num * 3);
    }
-#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
+#ifndef PNG_READ_OPT_PLTE_SUPPORTED
    else if (png_crc_error(png_ptr))  /* Only if we have a CRC error */
    {
       /* If we don't want to use the data from an ancillary chunk,
@@ -532,7 +637,7 @@
 
    png_set_PLTE(png_ptr, info_ptr, palette, num);
 
-#if defined(PNG_READ_tRNS_SUPPORTED)
+#ifdef PNG_READ_tRNS_SUPPORTED
    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
    {
       if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
@@ -556,7 +661,7 @@
 void /* PRIVATE */
 png_handle_IEND(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
-   png_debug(1, "in png_handle_IEND\n");
+   png_debug(1, "in png_handle_IEND");
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR) || !(png_ptr->mode & PNG_HAVE_IDAT))
    {
@@ -571,10 +676,10 @@
    }
    png_crc_finish(png_ptr, length);
 
-   info_ptr =info_ptr; /* quiet compiler warnings about unused info_ptr */
+   PNG_UNUSED(info_ptr) /* Quiet compiler warnings about unused info_ptr */
 }
 
-#if defined(PNG_READ_gAMA_SUPPORTED)
+#ifdef PNG_READ_gAMA_SUPPORTED
 void /* PRIVATE */
 png_handle_gAMA(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
@@ -584,7 +689,7 @@
 #endif
    png_byte buf[4];
 
-   png_debug(1, "in png_handle_gAMA\n");
+   png_debug(1, "in png_handle_gAMA");
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before gAMA");
@@ -599,7 +704,7 @@
       png_warning(png_ptr, "Out of place gAMA chunk");
 
    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
-#if defined(PNG_READ_sRGB_SUPPORTED)
+#ifdef PNG_READ_sRGB_SUPPORTED
       && !(info_ptr->valid & PNG_INFO_sRGB)
 #endif
       )
@@ -621,7 +726,7 @@
       return;
 
    igamma = (png_fixed_point)png_get_uint_32(buf);
-   /* check for zero gamma */
+   /* Check for zero gamma */
    if (igamma == 0)
       {
          png_warning(png_ptr,
@@ -629,14 +734,14 @@
          return;
       }
 
-#if defined(PNG_READ_sRGB_SUPPORTED)
+#ifdef PNG_READ_sRGB_SUPPORTED
    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
       if (PNG_OUT_OF_RANGE(igamma, 45500L, 500))
       {
          png_warning(png_ptr,
            "Ignoring incorrect gAMA value when sRGB is also present");
-#ifndef PNG_NO_CONSOLE_IO
-         fprintf(stderr, "gamma = (%d/100000)\n", (int)igamma);
+#ifdef PNG_CONSOLE_IO_SUPPORTED
+         fprintf(stderr, "gamma = (%d/100000)", (int)igamma);
 #endif
          return;
       }
@@ -655,14 +760,14 @@
 }
 #endif
 
-#if defined(PNG_READ_sBIT_SUPPORTED)
+#ifdef PNG_READ_sBIT_SUPPORTED
 void /* PRIVATE */
 png_handle_sBIT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
    png_size_t truelen;
    png_byte buf[4];
 
-   png_debug(1, "in png_handle_sBIT\n");
+   png_debug(1, "in png_handle_sBIT");
 
    buf[0] = buf[1] = buf[2] = buf[3] = 0;
 
@@ -721,11 +826,11 @@
 }
 #endif
 
-#if defined(PNG_READ_cHRM_SUPPORTED)
+#ifdef PNG_READ_cHRM_SUPPORTED
 void /* PRIVATE */
 png_handle_cHRM(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
-   png_byte buf[4];
+   png_byte buf[32];
 #ifdef PNG_FLOATING_POINT_SUPPORTED
    float white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y;
 #endif
@@ -734,7 +839,7 @@
 
    png_uint_32 uint_x, uint_y;
 
-   png_debug(1, "in png_handle_cHRM\n");
+   png_debug(1, "in png_handle_cHRM");
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before cHRM");
@@ -749,7 +854,7 @@
       png_warning(png_ptr, "Missing PLTE before cHRM");
 
    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM)
-#if defined(PNG_READ_sRGB_SUPPORTED)
+#ifdef PNG_READ_sRGB_SUPPORTED
       && !(info_ptr->valid & PNG_INFO_sRGB)
 #endif
       )
@@ -766,64 +871,27 @@
       return;
    }
 
-   png_crc_read(png_ptr, buf, 4);
-   uint_x = png_get_uint_32(buf);
-
-   png_crc_read(png_ptr, buf, 4);
-   uint_y = png_get_uint_32(buf);
-
-   if (uint_x > 80000L || uint_y > 80000L ||
-      uint_x + uint_y > 100000L)
-   {
-      png_warning(png_ptr, "Invalid cHRM white point");
-      png_crc_finish(png_ptr, 24);
+   png_crc_read(png_ptr, buf, 32);
+   if (png_crc_finish(png_ptr, 0))
       return;
-   }
-   int_x_white = (png_fixed_point)uint_x;
-   int_y_white = (png_fixed_point)uint_y;
 
-   png_crc_read(png_ptr, buf, 4);
    uint_x = png_get_uint_32(buf);
+   uint_y = png_get_uint_32(buf + 4);
+   int_x_white = (png_fixed_point)uint_x;
+   int_y_white = (png_fixed_point)uint_y;
 
-   png_crc_read(png_ptr, buf, 4);
-   uint_y = png_get_uint_32(buf);
-
-   if (uint_x + uint_y > 100000L)
-   {
-      png_warning(png_ptr, "Invalid cHRM red point");
-      png_crc_finish(png_ptr, 16);
-      return;
-   }
+   uint_x = png_get_uint_32(buf + 8);
+   uint_y = png_get_uint_32(buf + 12);
    int_x_red = (png_fixed_point)uint_x;
    int_y_red = (png_fixed_point)uint_y;
 
-   png_crc_read(png_ptr, buf, 4);
-   uint_x = png_get_uint_32(buf);
-
-   png_crc_read(png_ptr, buf, 4);
-   uint_y = png_get_uint_32(buf);
-
-   if (uint_x + uint_y > 100000L)
-   {
-      png_warning(png_ptr, "Invalid cHRM green point");
-      png_crc_finish(png_ptr, 8);
-      return;
-   }
+   uint_x = png_get_uint_32(buf + 16);
+   uint_y = png_get_uint_32(buf + 20);
    int_x_green = (png_fixed_point)uint_x;
    int_y_green = (png_fixed_point)uint_y;
 
-   png_crc_read(png_ptr, buf, 4);
-   uint_x = png_get_uint_32(buf);
-
-   png_crc_read(png_ptr, buf, 4);
-   uint_y = png_get_uint_32(buf);
-
-   if (uint_x + uint_y > 100000L)
-   {
-      png_warning(png_ptr, "Invalid cHRM blue point");
-      png_crc_finish(png_ptr, 0);
-      return;
-   }
+   uint_x = png_get_uint_32(buf + 24);
+   uint_y = png_get_uint_32(buf + 28);
    int_x_blue = (png_fixed_point)uint_x;
    int_y_blue = (png_fixed_point)uint_y;
 
@@ -838,7 +906,7 @@
    blue_y  = (float)int_y_blue  / (float)100000.0;
 #endif
 
-#if defined(PNG_READ_sRGB_SUPPORTED)
+#ifdef PNG_READ_sRGB_SUPPORTED
    if ((info_ptr != NULL) && (info_ptr->valid & PNG_INFO_sRGB))
       {
       if (PNG_OUT_OF_RANGE(int_x_white, 31270,  1000) ||
@@ -852,21 +920,22 @@
          {
             png_warning(png_ptr,
               "Ignoring incorrect cHRM value when sRGB is also present");
-#ifndef PNG_NO_CONSOLE_IO
+#ifdef PNG_CONSOLE_IO_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
-            fprintf(stderr,"wx=%f, wy=%f, rx=%f, ry=%f\n",
+            fprintf(stderr, "wx=%f, wy=%f, rx=%f, ry=%f\n",
                white_x, white_y, red_x, red_y);
-            fprintf(stderr,"gx=%f, gy=%f, bx=%f, by=%f\n",
+            fprintf(stderr, "gx=%f, gy=%f, bx=%f, by=%f\n",
                green_x, green_y, blue_x, blue_y);
 #else
-            fprintf(stderr,"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
-               int_x_white, int_y_white, int_x_red, int_y_red);
-            fprintf(stderr,"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
-               int_x_green, int_y_green, int_x_blue, int_y_blue);
+            fprintf(stderr, "wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
+               (long)int_x_white, (long)int_y_white,
+               (long)int_x_red, (long)int_y_red);
+            fprintf(stderr, "gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
+               (long)int_x_green, (long)int_y_green,
+               (long)int_x_blue, (long)int_y_blue);
 #endif
-#endif /* PNG_NO_CONSOLE_IO */
+#endif /* PNG_CONSOLE_IO_SUPPORTED */
          }
-         png_crc_finish(png_ptr, 0);
          return;
       }
 #endif /* PNG_READ_sRGB_SUPPORTED */
@@ -880,19 +949,17 @@
       int_x_white, int_y_white, int_x_red, int_y_red, int_x_green,
       int_y_green, int_x_blue, int_y_blue);
 #endif
-   if (png_crc_finish(png_ptr, 0))
-      return;
 }
 #endif
 
-#if defined(PNG_READ_sRGB_SUPPORTED)
+#ifdef PNG_READ_sRGB_SUPPORTED
 void /* PRIVATE */
 png_handle_sRGB(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
    int intent;
    png_byte buf[1];
 
-   png_debug(1, "in png_handle_sRGB\n");
+   png_debug(1, "in png_handle_sRGB");
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before sRGB");
@@ -925,7 +992,7 @@
       return;
 
    intent = buf[0];
-   /* check for bad intent */
+   /* Check for bad intent */
    if (intent >= PNG_sRGB_INTENT_LAST)
    {
       png_warning(png_ptr, "Unknown sRGB intent");
@@ -947,12 +1014,13 @@
       {
          png_warning(png_ptr,
            "Ignoring incorrect gAMA value when sRGB is also present");
-#ifndef PNG_NO_CONSOLE_IO
+#ifdef PNG_CONSOLE_IO_SUPPORTED
 #  ifdef PNG_FIXED_POINT_SUPPORTED
-         fprintf(stderr,"incorrect gamma=(%d/100000)\n",(int)png_ptr->int_gamma);
+         fprintf(stderr, "incorrect gamma=(%d/100000)\n",
+            (int)png_ptr->int_gamma);
 #  else
 #    ifdef PNG_FLOATING_POINT_SUPPORTED
-         fprintf(stderr,"incorrect gamma=%f\n",png_ptr->gamma);
+         fprintf(stderr, "incorrect gamma=%f\n", png_ptr->gamma);
 #    endif
 #  endif
 #endif
@@ -982,12 +1050,11 @@
 }
 #endif /* PNG_READ_sRGB_SUPPORTED */
 
-#if defined(PNG_READ_iCCP_SUPPORTED)
+#ifdef PNG_READ_iCCP_SUPPORTED
 void /* PRIVATE */
 png_handle_iCCP(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 /* Note: this does not properly handle chunks that are > 64K under DOS */
 {
-   png_charp chunkdata;
    png_byte compression_type;
    png_bytep pC;
    png_charp profile;
@@ -995,7 +1062,7 @@
    png_uint_32 profile_size, profile_length;
    png_size_t slength, prefix_length, data_length;
 
-   png_debug(1, "in png_handle_iCCP\n");
+   png_debug(1, "in png_handle_iCCP");
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before iCCP");
@@ -1025,93 +1092,117 @@
    }
 #endif
 
-   chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
+   png_free(png_ptr, png_ptr->chunkdata);
+   png_ptr->chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
    slength = (png_size_t)length;
-   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
+   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
 
    if (png_crc_finish(png_ptr, skip))
    {
-      png_free(png_ptr, chunkdata);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
 
-   chunkdata[slength] = 0x00;
+   png_ptr->chunkdata[slength] = 0x00;
 
-   for (profile = chunkdata; *profile; profile++)
-      /* empty loop to find end of name */ ;
+   for (profile = png_ptr->chunkdata; *profile; profile++)
+      /* Empty loop to find end of name */ ;
 
    ++profile;
 
-   /* there should be at least one zero (the compression type byte)
-      following the separator, and we should be on it  */
-   if ( profile >= chunkdata + slength - 1)
+   /* There should be at least one zero (the compression type byte)
+    * following the separator, and we should be on it
+    */
+   if (slength < 1U ||  profile >= png_ptr->chunkdata + slength - 1U)
    {
-      png_free(png_ptr, chunkdata);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       png_warning(png_ptr, "Malformed iCCP chunk");
       return;
    }
 
-   /* compression_type should always be zero */
+   /* Compression_type should always be zero */
    compression_type = *profile++;
    if (compression_type)
    {
       png_warning(png_ptr, "Ignoring nonzero compression type in iCCP chunk");
-      compression_type=0x00;  /* Reset it to zero (libpng-1.0.6 through 1.0.8
+      compression_type = 0x00;  /* Reset it to zero (libpng-1.0.6 through 1.0.8
                                  wrote nonzero) */
    }
 
-   prefix_length = profile - chunkdata;
-   chunkdata = png_decompress_chunk(png_ptr, compression_type, chunkdata,
-                                    slength, prefix_length, &data_length);
+   prefix_length = profile - png_ptr->chunkdata;
+   png_decompress_chunk(png_ptr, compression_type,
+     slength, prefix_length, &data_length);
 
    profile_length = data_length - prefix_length;
 
    if ( prefix_length > data_length || profile_length < 4)
    {
-      png_free(png_ptr, chunkdata);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       png_warning(png_ptr, "Profile size field missing from iCCP chunk");
       return;
    }
 
    /* Check the profile_size recorded in the first 32 bits of the ICC profile */
-   pC = (png_bytep)(chunkdata+prefix_length);
-   profile_size = ((*(pC  ))<<24) |
-                  ((*(pC+1))<<16) |
-                  ((*(pC+2))<< 8) |
-                  ((*(pC+3))    );
+   pC = (png_bytep)(png_ptr->chunkdata + prefix_length);
+   profile_size = ((png_uint_32) (*(pC    )<<24)) |
+                  ((png_uint_32) (*(pC + 1)<<16)) |
+                  ((png_uint_32) (*(pC + 2)<< 8)) |
+                  ((png_uint_32) (*(pC + 3)    ));
 
-   if(profile_size < profile_length)
+   if (profile_size < profile_length)
       profile_length = profile_size;
 
-   if(profile_size > profile_length)
+   if (profile_size > profile_length)
    {
-      png_free(png_ptr, chunkdata);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       png_warning(png_ptr, "Ignoring truncated iCCP profile.");
       return;
    }
 
-   png_set_iCCP(png_ptr, info_ptr, chunkdata, compression_type,
-                chunkdata + prefix_length, profile_length);
-   png_free(png_ptr, chunkdata);
+   png_set_iCCP(png_ptr, info_ptr, png_ptr->chunkdata,
+     compression_type, png_ptr->chunkdata + prefix_length, profile_length);
+   png_free(png_ptr, png_ptr->chunkdata);
+   png_ptr->chunkdata = NULL;
 }
 #endif /* PNG_READ_iCCP_SUPPORTED */
 
-#if defined(PNG_READ_sPLT_SUPPORTED)
+#ifdef PNG_READ_sPLT_SUPPORTED
 void /* PRIVATE */
 png_handle_sPLT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 /* Note: this does not properly handle chunks that are > 64K under DOS */
 {
-   png_bytep chunkdata;
    png_bytep entry_start;
    png_sPLT_t new_palette;
-#ifdef PNG_NO_POINTER_INDEXING
+#ifdef PNG_POINTER_INDEXING_SUPPORTED
    png_sPLT_entryp pp;
 #endif
    int data_length, entry_size, i;
    png_uint_32 skip = 0;
    png_size_t slength;
 
-   png_debug(1, "in png_handle_sPLT\n");
+   png_debug(1, "in png_handle_sPLT");
+
+#ifdef PNG_USER_LIMITS_SUPPORTED
+
+   if (png_ptr->user_chunk_cache_max != 0)
+   {
+      if (png_ptr->user_chunk_cache_max == 1)
+      {
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+      if (--png_ptr->user_chunk_cache_max == 1)
+      {
+         png_warning(png_ptr, "No space in chunk cache for sPLT");
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+   }
+#endif
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before sPLT");
@@ -1131,45 +1222,51 @@
    }
 #endif
 
-   chunkdata = (png_bytep)png_malloc(png_ptr, length + 1);
+   png_free(png_ptr, png_ptr->chunkdata);
+   png_ptr->chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
    slength = (png_size_t)length;
-   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
+   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
 
    if (png_crc_finish(png_ptr, skip))
    {
-      png_free(png_ptr, chunkdata);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
 
-   chunkdata[slength] = 0x00;
+   png_ptr->chunkdata[slength] = 0x00;
 
-   for (entry_start = chunkdata; *entry_start; entry_start++)
-      /* empty loop to find end of name */ ;
+   for (entry_start = (png_bytep)png_ptr->chunkdata; *entry_start;
+       entry_start++)
+      /* Empty loop to find end of name */ ;
    ++entry_start;
 
-   /* a sample depth should follow the separator, and we should be on it  */
-   if (entry_start > chunkdata + slength - 2)
+   /* A sample depth should follow the separator, and we should be on it  */
+   if (slength < 2U ||
+       entry_start > (png_bytep)png_ptr->chunkdata + slength - 2U)
    {
-      png_free(png_ptr, chunkdata);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       png_warning(png_ptr, "malformed sPLT chunk");
       return;
    }
 
    new_palette.depth = *entry_start++;
    entry_size = (new_palette.depth == 8 ? 6 : 10);
-   data_length = (slength - (entry_start - chunkdata));
+   data_length = (slength - (entry_start - (png_bytep)png_ptr->chunkdata));
 
-   /* integrity-check the data length */
+   /* Integrity-check the data length */
    if (data_length % entry_size)
    {
-      png_free(png_ptr, chunkdata);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       png_warning(png_ptr, "sPLT chunk has bad length");
       return;
    }
 
    new_palette.nentries = (png_int_32) ( data_length / entry_size);
-   if ((png_uint_32) new_palette.nentries > (png_uint_32) (PNG_SIZE_MAX /
-       png_sizeof(png_sPLT_entry)))
+   if ((png_uint_32) new_palette.nentries >
+       (png_uint_32) (PNG_SIZE_MAX / png_sizeof(png_sPLT_entry)))
    {
        png_warning(png_ptr, "sPLT chunk too long");
        return;
@@ -1182,10 +1279,10 @@
        return;
    }
 
-#ifndef PNG_NO_POINTER_INDEXING
+#ifdef PNG_POINTER_INDEXING_SUPPORTED
    for (i = 0; i < new_palette.nentries; i++)
    {
-      png_sPLT_entryp pp = new_palette.entries + i;
+      pp = new_palette.entries + i;
 
       if (new_palette.depth == 8)
       {
@@ -1226,29 +1323,24 @@
    }
 #endif
 
-   /* discard all chunk data except the name and stash that */
-   new_palette.name = (png_charp)chunkdata;
+   /* Discard all chunk data except the name and stash that */
+   new_palette.name = png_ptr->chunkdata;
 
    png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);
 
-   png_free(png_ptr, chunkdata);
+   png_free(png_ptr, png_ptr->chunkdata);
+   png_ptr->chunkdata = NULL;
    png_free(png_ptr, new_palette.entries);
 }
 #endif /* PNG_READ_sPLT_SUPPORTED */
 
-#if defined(PNG_READ_tRNS_SUPPORTED)
+#ifdef PNG_READ_tRNS_SUPPORTED
 void /* PRIVATE */
 png_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
    png_byte readbuf[PNG_MAX_PALETTE_LENGTH];
-   int bit_mask;
 
-   png_debug(1, "in png_handle_tRNS\n");
-
-   /* For non-indexed color, mask off any bits in the tRNS value that
-    * exceed the bit depth.  Some creators were writing extra bits there.
-    * This is not needed for indexed color. */
-   bit_mask = (1 << png_ptr->bit_depth) - 1;
+   png_debug(1, "in png_handle_tRNS");
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before tRNS");
@@ -1278,7 +1370,7 @@
 
       png_crc_read(png_ptr, buf, 2);
       png_ptr->num_trans = 1;
-      png_ptr->trans_values.gray = png_get_uint_16(buf) & bit_mask;
+      png_ptr->trans_values.gray = png_get_uint_16(buf);
    }
    else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
    {
@@ -1292,9 +1384,9 @@
       }
       png_crc_read(png_ptr, buf, (png_size_t)length);
       png_ptr->num_trans = 1;
-      png_ptr->trans_values.red = png_get_uint_16(buf) & bit_mask;
-      png_ptr->trans_values.green = png_get_uint_16(buf + 2) & bit_mask;
-      png_ptr->trans_values.blue = png_get_uint_16(buf + 4) & bit_mask;
+      png_ptr->trans_values.red = png_get_uint_16(buf);
+      png_ptr->trans_values.green = png_get_uint_16(buf + 2);
+      png_ptr->trans_values.blue = png_get_uint_16(buf + 4);
    }
    else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
    {
@@ -1337,14 +1429,14 @@
 }
 #endif
 
-#if defined(PNG_READ_bKGD_SUPPORTED)
+#ifdef PNG_READ_bKGD_SUPPORTED
 void /* PRIVATE */
 png_handle_bKGD(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
    png_size_t truelen;
    png_byte buf[6];
 
-   png_debug(1, "in png_handle_bKGD\n");
+   png_debug(1, "in png_handle_bKGD");
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before bKGD");
@@ -1393,9 +1485,9 @@
    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
    {
       png_ptr->background.index = buf[0];
-      if(info_ptr->num_palette)
+      if (info_ptr && info_ptr->num_palette)
       {
-          if(buf[0] > info_ptr->num_palette)
+          if (buf[0] >= info_ptr->num_palette)
           {
              png_warning(png_ptr, "Incorrect bKGD chunk index value");
              return;
@@ -1426,14 +1518,14 @@
 }
 #endif
 
-#if defined(PNG_READ_hIST_SUPPORTED)
+#ifdef PNG_READ_hIST_SUPPORTED
 void /* PRIVATE */
 png_handle_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
    unsigned int num, i;
    png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];
 
-   png_debug(1, "in png_handle_hIST\n");
+   png_debug(1, "in png_handle_hIST");
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before hIST");
@@ -1456,15 +1548,16 @@
       return;
    }
 
-   num = length / 2 ;
-   if (num != (unsigned int) png_ptr->num_palette || num >
-      (unsigned int) PNG_MAX_PALETTE_LENGTH)
+   if (length > 2*PNG_MAX_PALETTE_LENGTH ||
+       length != (unsigned int) (2*png_ptr->num_palette))
    {
       png_warning(png_ptr, "Incorrect hIST chunk length");
       png_crc_finish(png_ptr, length);
       return;
    }
 
+   num = length / 2 ;
+
    for (i = 0; i < num; i++)
    {
       png_byte buf[2];
@@ -1480,7 +1573,7 @@
 }
 #endif
 
-#if defined(PNG_READ_pHYs_SUPPORTED)
+#ifdef PNG_READ_pHYs_SUPPORTED
 void /* PRIVATE */
 png_handle_pHYs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
@@ -1488,7 +1581,7 @@
    png_uint_32 res_x, res_y;
    int unit_type;
 
-   png_debug(1, "in png_handle_pHYs\n");
+   png_debug(1, "in png_handle_pHYs");
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before pHYs");
@@ -1523,7 +1616,7 @@
 }
 #endif
 
-#if defined(PNG_READ_oFFs_SUPPORTED)
+#ifdef PNG_READ_oFFs_SUPPORTED
 void /* PRIVATE */
 png_handle_oFFs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
@@ -1531,7 +1624,7 @@
    png_int_32 offset_x, offset_y;
    int unit_type;
 
-   png_debug(1, "in png_handle_oFFs\n");
+   png_debug(1, "in png_handle_oFFs");
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before oFFs");
@@ -1566,12 +1659,11 @@
 }
 #endif
 
-#if defined(PNG_READ_pCAL_SUPPORTED)
-/* read the pCAL chunk (described in the PNG Extensions document) */
+#ifdef PNG_READ_pCAL_SUPPORTED
+/* Read the pCAL chunk (described in the PNG Extensions document) */
 void /* PRIVATE */
 png_handle_pCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
-   png_charp purpose;
    png_int_32 X0, X1;
    png_byte type, nparams;
    png_charp buf, units, endptr;
@@ -1579,7 +1671,7 @@
    png_size_t slength;
    int i;
 
-   png_debug(1, "in png_handle_pCAL\n");
+   png_debug(1, "in png_handle_pCAL");
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before pCAL");
@@ -1596,48 +1688,51 @@
       return;
    }
 
-   png_debug1(2, "Allocating and reading pCAL chunk data (%lu bytes)\n",
+   png_debug1(2, "Allocating and reading pCAL chunk data (%lu bytes)",
       length + 1);
-   purpose = (png_charp)png_malloc_warn(png_ptr, length + 1);
-   if (purpose == NULL)
+   png_free(png_ptr, png_ptr->chunkdata);
+   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
+   if (png_ptr->chunkdata == NULL)
      {
        png_warning(png_ptr, "No memory for pCAL purpose.");
        return;
      }
    slength = (png_size_t)length;
-   png_crc_read(png_ptr, (png_bytep)purpose, slength);
+   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
 
    if (png_crc_finish(png_ptr, 0))
    {
-      png_free(png_ptr, purpose);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
 
-   purpose[slength] = 0x00; /* null terminate the last string */
+   png_ptr->chunkdata[slength] = 0x00; /* Null terminate the last string */
 
-   png_debug(3, "Finding end of pCAL purpose string\n");
-   for (buf = purpose; *buf; buf++)
-      /* empty loop */ ;
+   png_debug(3, "Finding end of pCAL purpose string");
+   for (buf = png_ptr->chunkdata; *buf; buf++)
+      /* Empty loop */ ;
 
-   endptr = purpose + slength;
+   endptr = png_ptr->chunkdata + slength;
 
    /* We need to have at least 12 bytes after the purpose string
       in order to get the parameter information. */
-   if (endptr <= buf + 12)
+   if (slength < 12U || endptr - buf <= 12)
    {
       png_warning(png_ptr, "Invalid pCAL data");
-      png_free(png_ptr, purpose);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
 
-   png_debug(3, "Reading pCAL X0, X1, type, nparams, and units\n");
+   png_debug(3, "Reading pCAL X0, X1, type, nparams, and units");
    X0 = png_get_int_32((png_bytep)buf+1);
    X1 = png_get_int_32((png_bytep)buf+5);
    type = buf[9];
    nparams = buf[10];
    units = buf + 11;
 
-   png_debug(3, "Checking pCAL equation type and number of parameters\n");
+   png_debug(3, "Checking pCAL equation type and number of parameters");
    /* Check that we have the right number of parameters for known
       equation types. */
    if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||
@@ -1646,7 +1741,8 @@
        (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))
    {
       png_warning(png_ptr, "Invalid pCAL parameters for equation type");
-      png_free(png_ptr, purpose);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
    else if (type >= PNG_EQUATION_LAST)
@@ -1657,12 +1753,13 @@
    for (buf = units; *buf; buf++)
       /* Empty loop to move past the units string. */ ;
 
-   png_debug(3, "Allocating pCAL parameters array\n");
-   params = (png_charpp)png_malloc_warn(png_ptr, (png_uint_32)(nparams
-      *png_sizeof(png_charp))) ;
+   png_debug(3, "Allocating pCAL parameters array");
+   params = (png_charpp)png_malloc_warn(png_ptr,
+      (png_uint_32)(nparams * png_sizeof(png_charp))) ;
    if (params == NULL)
      {
-       png_free(png_ptr, purpose);
+       png_free(png_ptr, png_ptr->chunkdata);
+       png_ptr->chunkdata = NULL;
        png_warning(png_ptr, "No memory for pCAL params.");
        return;
      }
@@ -1672,7 +1769,7 @@
    {
       buf++; /* Skip the null string terminator from previous parameter. */
 
-      png_debug1(3, "Reading pCAL parameter %d\n", i);
+      png_debug1(3, "Reading pCAL parameter %d", i);
       for (params[i] = buf; buf <= endptr && *buf != 0x00; buf++)
          /* Empty loop to move past each parameter string */ ;
 
@@ -1680,26 +1777,28 @@
       if (buf > endptr)
       {
          png_warning(png_ptr, "Invalid pCAL data");
-         png_free(png_ptr, purpose);
+         png_free(png_ptr, png_ptr->chunkdata);
+         png_ptr->chunkdata = NULL;
          png_free(png_ptr, params);
          return;
       }
    }
 
-   png_set_pCAL(png_ptr, info_ptr, purpose, X0, X1, type, nparams,
+   png_set_pCAL(png_ptr, info_ptr, png_ptr->chunkdata, X0, X1, type, nparams,
       units, params);
 
-   png_free(png_ptr, purpose);
+   png_free(png_ptr, png_ptr->chunkdata);
+   png_ptr->chunkdata = NULL;
    png_free(png_ptr, params);
 }
 #endif
 
-#if defined(PNG_READ_sCAL_SUPPORTED)
-/* read the sCAL chunk */
+#ifdef PNG_READ_sCAL_SUPPORTED
+/* Read the sCAL chunk */
 void /* PRIVATE */
 png_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
-   png_charp buffer, ep;
+   png_charp ep;
 #ifdef PNG_FLOATING_POINT_SUPPORTED
    double width, height;
    png_charp vp;
@@ -1710,7 +1809,7 @@
 #endif
    png_size_t slength;
 
-   png_debug(1, "in png_handle_sCAL\n");
+   png_debug(1, "in png_handle_sCAL");
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before sCAL");
@@ -1727,88 +1826,113 @@
       return;
    }
 
-   png_debug1(2, "Allocating and reading sCAL chunk data (%lu bytes)\n",
+   /* Need unit type, width, \0, height: minimum 4 bytes */
+   else if (length < 4)
+   {
+      png_warning(png_ptr, "sCAL chunk too short");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   png_debug1(2, "Allocating and reading sCAL chunk data (%lu bytes)",
       length + 1);
-   buffer = (png_charp)png_malloc_warn(png_ptr, length + 1);
-   if (buffer == NULL)
-     {
-       png_warning(png_ptr, "Out of memory while processing sCAL chunk");
-       return;
-     }
+   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
+   if (png_ptr->chunkdata == NULL)
+   {
+      png_warning(png_ptr, "Out of memory while processing sCAL chunk");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
    slength = (png_size_t)length;
-   png_crc_read(png_ptr, (png_bytep)buffer, slength);
+   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
 
    if (png_crc_finish(png_ptr, 0))
    {
-      png_free(png_ptr, buffer);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
 
-   buffer[slength] = 0x00; /* null terminate the last string */
+   png_ptr->chunkdata[slength] = 0x00; /* Null terminate the last string */
 
-   ep = buffer + 1;        /* skip unit byte */
+   ep = png_ptr->chunkdata + 1;        /* Skip unit byte */
 
 #ifdef PNG_FLOATING_POINT_SUPPORTED
    width = png_strtod(png_ptr, ep, &vp);
    if (*vp)
    {
-       png_warning(png_ptr, "malformed width string in sCAL chunk");
-       return;
+      png_warning(png_ptr, "malformed width string in sCAL chunk");
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
+      return;
    }
 #else
 #ifdef PNG_FIXED_POINT_SUPPORTED
    swidth = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);
    if (swidth == NULL)
-     {
-       png_warning(png_ptr, "Out of memory while processing sCAL chunk width");
-       return;
-     }
-   png_memcpy(swidth, ep, (png_size_t)png_strlen(ep));
+   {
+      png_warning(png_ptr, "Out of memory while processing sCAL chunk width");
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
+      return;
+   }
+   png_memcpy(swidth, ep, (png_size_t)png_strlen(ep) + 1);
 #endif
 #endif
 
-   for (ep = buffer; *ep; ep++)
-      /* empty loop */ ;
+   for (ep = png_ptr->chunkdata + 1; *ep; ep++)
+      /* Empty loop */ ;
    ep++;
 
-   if (buffer + slength < ep)
+   if (png_ptr->chunkdata + slength < ep)
    {
-       png_warning(png_ptr, "Truncated sCAL chunk");
-#if defined(PNG_FIXED_POINT_SUPPORTED) && \
-    !defined(PNG_FLOATING_POINT_SUPPORTED)
-       png_free(png_ptr, swidth);
+      png_warning(png_ptr, "Truncated sCAL chunk");
+#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
+      png_free(png_ptr, swidth);
 #endif
-      png_free(png_ptr, buffer);
-       return;
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
+      return;
    }
 
 #ifdef PNG_FLOATING_POINT_SUPPORTED
    height = png_strtod(png_ptr, ep, &vp);
    if (*vp)
    {
-       png_warning(png_ptr, "malformed height string in sCAL chunk");
-       return;
+      png_warning(png_ptr, "malformed height string in sCAL chunk");
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
+#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
+      png_free(png_ptr, swidth);
+#endif
+      return;
    }
 #else
 #ifdef PNG_FIXED_POINT_SUPPORTED
    sheight = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);
-   if (swidth == NULL)
-     {
-       png_warning(png_ptr, "Out of memory while processing sCAL chunk height");
-       return;
-     }
-   png_memcpy(sheight, ep, (png_size_t)png_strlen(ep));
+   if (sheight == NULL)
+   {
+      png_warning(png_ptr, "Out of memory while processing sCAL chunk height");
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
+#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
+      png_free(png_ptr, swidth);
+#endif
+      return;
+   }
+   png_memcpy(sheight, ep, (png_size_t)png_strlen(ep) + 1);
 #endif
 #endif
 
-   if (buffer + slength < ep
+   if (png_ptr->chunkdata + slength < ep
 #ifdef PNG_FLOATING_POINT_SUPPORTED
       || width <= 0. || height <= 0.
 #endif
       )
    {
       png_warning(png_ptr, "Invalid sCAL data");
-      png_free(png_ptr, buffer);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
 #if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
       png_free(png_ptr, swidth);
       png_free(png_ptr, sheight);
@@ -1818,14 +1942,15 @@
 
 
 #ifdef PNG_FLOATING_POINT_SUPPORTED
-   png_set_sCAL(png_ptr, info_ptr, buffer[0], width, height);
+   png_set_sCAL(png_ptr, info_ptr, png_ptr->chunkdata[0], width, height);
 #else
 #ifdef PNG_FIXED_POINT_SUPPORTED
-   png_set_sCAL_s(png_ptr, info_ptr, buffer[0], swidth, sheight);
+   png_set_sCAL_s(png_ptr, info_ptr, png_ptr->chunkdata[0], swidth, sheight);
 #endif
 #endif
 
-   png_free(png_ptr, buffer);
+   png_free(png_ptr, png_ptr->chunkdata);
+   png_ptr->chunkdata = NULL;
 #if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
    png_free(png_ptr, swidth);
    png_free(png_ptr, sheight);
@@ -1833,14 +1958,14 @@
 }
 #endif
 
-#if defined(PNG_READ_tIME_SUPPORTED)
+#ifdef PNG_READ_tIME_SUPPORTED
 void /* PRIVATE */
 png_handle_tIME(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
    png_byte buf[7];
    png_time mod_time;
 
-   png_debug(1, "in png_handle_tIME\n");
+   png_debug(1, "in png_handle_tIME");
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Out of place tIME chunk");
@@ -1876,7 +2001,7 @@
 }
 #endif
 
-#if defined(PNG_READ_tEXt_SUPPORTED)
+#ifdef PNG_READ_tEXt_SUPPORTED
 /* Note: this does not properly handle chunks that are > 64K under DOS */
 void /* PRIVATE */
 png_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
@@ -1888,7 +2013,24 @@
    png_size_t slength;
    int ret;
 
-   png_debug(1, "in png_handle_tEXt\n");
+   png_debug(1, "in png_handle_tEXt");
+
+#ifdef PNG_USER_LIMITS_SUPPORTED
+   if (png_ptr->user_chunk_cache_max != 0)
+   {
+      if (png_ptr->user_chunk_cache_max == 1)
+      {
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+      if (--png_ptr->user_chunk_cache_max == 1)
+      {
+         png_warning(png_ptr, "No space in chunk cache for tEXt");
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+   }
+#endif
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before tEXt");
@@ -1905,25 +2047,30 @@
    }
 #endif
 
-   key = (png_charp)png_malloc_warn(png_ptr, length + 1);
-   if (key == NULL)
+   png_free(png_ptr, png_ptr->chunkdata);
+
+   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
+   if (png_ptr->chunkdata == NULL)
    {
      png_warning(png_ptr, "No memory to process text chunk.");
      return;
    }
    slength = (png_size_t)length;
-   png_crc_read(png_ptr, (png_bytep)key, slength);
+   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
 
    if (png_crc_finish(png_ptr, skip))
    {
-      png_free(png_ptr, key);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
 
+   key = png_ptr->chunkdata;
+
    key[slength] = 0x00;
 
    for (text = key; *text; text++)
-      /* empty loop to find end of key */ ;
+      /* Empty loop to find end of key */ ;
 
    if (text != key + slength)
       text++;
@@ -1933,7 +2080,8 @@
    if (text_ptr == NULL)
    {
      png_warning(png_ptr, "Not enough memory to process text chunk.");
-     png_free(png_ptr, key);
+     png_free(png_ptr, png_ptr->chunkdata);
+     png_ptr->chunkdata = NULL;
      return;
    }
    text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;
@@ -1946,28 +2094,46 @@
    text_ptr->text = text;
    text_ptr->text_length = png_strlen(text);
 
-   ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
+   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
 
-   png_free(png_ptr, key);
+   png_free(png_ptr, png_ptr->chunkdata);
+   png_ptr->chunkdata = NULL;
    png_free(png_ptr, text_ptr);
    if (ret)
      png_warning(png_ptr, "Insufficient memory to process text chunk.");
 }
 #endif
 
-#if defined(PNG_READ_zTXt_SUPPORTED)
-/* note: this does not correctly handle chunks that are > 64K under DOS */
+#ifdef PNG_READ_zTXt_SUPPORTED
+/* Note: this does not correctly handle chunks that are > 64K under DOS */
 void /* PRIVATE */
 png_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
    png_textp text_ptr;
-   png_charp chunkdata;
    png_charp text;
    int comp_type;
    int ret;
    png_size_t slength, prefix_len, data_len;
 
-   png_debug(1, "in png_handle_zTXt\n");
+   png_debug(1, "in png_handle_zTXt");
+
+#ifdef PNG_USER_LIMITS_SUPPORTED
+   if (png_ptr->user_chunk_cache_max != 0)
+   {
+      if (png_ptr->user_chunk_cache_max == 1)
+      {
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+      if (--png_ptr->user_chunk_cache_max == 1)
+      {
+         png_warning(png_ptr, "No space in chunk cache for zTXt");
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+   }
+#endif
+
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before zTXt");
 
@@ -1979,36 +2145,39 @@
       there is no hard and fast rule to tell us where to stop. */
    if (length > (png_uint_32)65535L)
    {
-     png_warning(png_ptr,"zTXt chunk too large to fit in memory");
+     png_warning(png_ptr, "zTXt chunk too large to fit in memory");
      png_crc_finish(png_ptr, length);
      return;
    }
 #endif
 
-   chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
-   if (chunkdata == NULL)
+   png_free(png_ptr, png_ptr->chunkdata);
+   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
+   if (png_ptr->chunkdata == NULL)
    {
-     png_warning(png_ptr,"Out of memory processing zTXt chunk.");
+     png_warning(png_ptr, "Out of memory processing zTXt chunk.");
      return;
    }
    slength = (png_size_t)length;
-   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
+   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
    if (png_crc_finish(png_ptr, 0))
    {
-      png_free(png_ptr, chunkdata);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
 
-   chunkdata[slength] = 0x00;
+   png_ptr->chunkdata[slength] = 0x00;
 
-   for (text = chunkdata; *text; text++)
-      /* empty loop */ ;
+   for (text = png_ptr->chunkdata; *text; text++)
+      /* Empty loop */ ;
 
    /* zTXt must have some text after the chunkdataword */
-   if (text >= chunkdata + slength - 2)
+   if (slength < 2U || text >= png_ptr->chunkdata + slength - 2U)
    {
       png_warning(png_ptr, "Truncated zTXt chunk");
-      png_free(png_ptr, chunkdata);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
    else
@@ -2019,54 +2188,72 @@
           png_warning(png_ptr, "Unknown compression type in zTXt chunk");
           comp_type = PNG_TEXT_COMPRESSION_zTXt;
        }
-       text++;        /* skip the compression_method byte */
+       text++;        /* Skip the compression_method byte */
    }
-   prefix_len = text - chunkdata;
+   prefix_len = text - png_ptr->chunkdata;
 
-   chunkdata = (png_charp)png_decompress_chunk(png_ptr, comp_type, chunkdata,
-                                    (png_size_t)length, prefix_len, &data_len);
+   png_decompress_chunk(png_ptr, comp_type,
+     (png_size_t)length, prefix_len, &data_len);
 
    text_ptr = (png_textp)png_malloc_warn(png_ptr,
-     (png_uint_32)png_sizeof(png_text));
+      (png_uint_32)png_sizeof(png_text));
    if (text_ptr == NULL)
    {
-     png_warning(png_ptr,"Not enough memory to process zTXt chunk.");
-     png_free(png_ptr, chunkdata);
+     png_warning(png_ptr, "Not enough memory to process zTXt chunk.");
+     png_free(png_ptr, png_ptr->chunkdata);
+     png_ptr->chunkdata = NULL;
      return;
    }
    text_ptr->compression = comp_type;
-   text_ptr->key = chunkdata;
+   text_ptr->key = png_ptr->chunkdata;
 #ifdef PNG_iTXt_SUPPORTED
    text_ptr->lang = NULL;
    text_ptr->lang_key = NULL;
    text_ptr->itxt_length = 0;
 #endif
-   text_ptr->text = chunkdata + prefix_len;
+   text_ptr->text = png_ptr->chunkdata + prefix_len;
    text_ptr->text_length = data_len;
 
-   ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
+   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
 
    png_free(png_ptr, text_ptr);
-   png_free(png_ptr, chunkdata);
+   png_free(png_ptr, png_ptr->chunkdata);
+   png_ptr->chunkdata = NULL;
    if (ret)
      png_error(png_ptr, "Insufficient memory to store zTXt chunk.");
 }
 #endif
 
-#if defined(PNG_READ_iTXt_SUPPORTED)
-/* note: this does not correctly handle chunks that are > 64K under DOS */
+#ifdef PNG_READ_iTXt_SUPPORTED
+/* Note: this does not correctly handle chunks that are > 64K under DOS */
 void /* PRIVATE */
 png_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
    png_textp text_ptr;
-   png_charp chunkdata;
    png_charp key, lang, text, lang_key;
    int comp_flag;
    int comp_type = 0;
    int ret;
    png_size_t slength, prefix_len, data_len;
 
-   png_debug(1, "in png_handle_iTXt\n");
+   png_debug(1, "in png_handle_iTXt");
+
+#ifdef PNG_USER_LIMITS_SUPPORTED
+   if (png_ptr->user_chunk_cache_max != 0)
+   {
+      if (png_ptr->user_chunk_cache_max == 1)
+      {
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+      if (--png_ptr->user_chunk_cache_max == 1)
+      {
+         png_warning(png_ptr, "No space in chunk cache for iTXt");
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+   }
+#endif
 
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before iTXt");
@@ -2079,40 +2266,44 @@
       there is no hard and fast rule to tell us where to stop. */
    if (length > (png_uint_32)65535L)
    {
-     png_warning(png_ptr,"iTXt chunk too large to fit in memory");
+     png_warning(png_ptr, "iTXt chunk too large to fit in memory");
      png_crc_finish(png_ptr, length);
      return;
    }
 #endif
 
-   chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
-   if (chunkdata == NULL)
+   png_free(png_ptr, png_ptr->chunkdata);
+   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
+   if (png_ptr->chunkdata == NULL)
    {
      png_warning(png_ptr, "No memory to process iTXt chunk.");
      return;
    }
    slength = (png_size_t)length;
-   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
+   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
    if (png_crc_finish(png_ptr, 0))
    {
-      png_free(png_ptr, chunkdata);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
 
-   chunkdata[slength] = 0x00;
+   png_ptr->chunkdata[slength] = 0x00;
 
-   for (lang = chunkdata; *lang; lang++)
-      /* empty loop */ ;
-   lang++;        /* skip NUL separator */
+   for (lang = png_ptr->chunkdata; *lang; lang++)
+      /* Empty loop */ ;
+   lang++;        /* Skip NUL separator */
 
    /* iTXt must have a language tag (possibly empty), two compression bytes,
-      translated keyword (possibly empty), and possibly some text after the
-      keyword */
+    * translated keyword (possibly empty), and possibly some text after the
+    * keyword
+    */
 
-   if (lang >= chunkdata + slength - 3)
+   if (slength < 3U || lang >= png_ptr->chunkdata + slength - 3U)
    {
       png_warning(png_ptr, "Truncated iTXt chunk");
-      png_free(png_ptr, chunkdata);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
    else
@@ -2122,54 +2313,58 @@
    }
 
    for (lang_key = lang; *lang_key; lang_key++)
-      /* empty loop */ ;
-   lang_key++;        /* skip NUL separator */
+      /* Empty loop */ ;
+   lang_key++;        /* Skip NUL separator */
 
-   if (lang_key >= chunkdata + slength)
+   if (lang_key >= png_ptr->chunkdata + slength)
    {
       png_warning(png_ptr, "Truncated iTXt chunk");
-      png_free(png_ptr, chunkdata);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
 
    for (text = lang_key; *text; text++)
-      /* empty loop */ ;
-   text++;        /* skip NUL separator */
-   if (text >= chunkdata + slength)
+      /* Empty loop */ ;
+   text++;        /* Skip NUL separator */
+   if (text >= png_ptr->chunkdata + slength)
    {
       png_warning(png_ptr, "Malformed iTXt chunk");
-      png_free(png_ptr, chunkdata);
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
 
-   prefix_len = text - chunkdata;
+   prefix_len = text - png_ptr->chunkdata;
 
-   key=chunkdata;
+   key=png_ptr->chunkdata;
    if (comp_flag)
-       chunkdata = png_decompress_chunk(png_ptr, comp_type, chunkdata,
-          (size_t)length, prefix_len, &data_len);
+       png_decompress_chunk(png_ptr, comp_type,
+         (size_t)length, prefix_len, &data_len);
    else
-       data_len=png_strlen(chunkdata + prefix_len);
+       data_len = png_strlen(png_ptr->chunkdata + prefix_len);
    text_ptr = (png_textp)png_malloc_warn(png_ptr,
       (png_uint_32)png_sizeof(png_text));
    if (text_ptr == NULL)
    {
-     png_warning(png_ptr,"Not enough memory to process iTXt chunk.");
-     png_free(png_ptr, chunkdata);
+     png_warning(png_ptr, "Not enough memory to process iTXt chunk.");
+     png_free(png_ptr, png_ptr->chunkdata);
+     png_ptr->chunkdata = NULL;
      return;
    }
    text_ptr->compression = (int)comp_flag + 1;
-   text_ptr->lang_key = chunkdata+(lang_key-key);
-   text_ptr->lang = chunkdata+(lang-key);
+   text_ptr->lang_key = png_ptr->chunkdata + (lang_key - key);
+   text_ptr->lang = png_ptr->chunkdata + (lang - key);
    text_ptr->itxt_length = data_len;
    text_ptr->text_length = 0;
-   text_ptr->key = chunkdata;
-   text_ptr->text = chunkdata + prefix_len;
+   text_ptr->key = png_ptr->chunkdata;
+   text_ptr->text = png_ptr->chunkdata + prefix_len;
 
-   ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
+   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
 
    png_free(png_ptr, text_ptr);
-   png_free(png_ptr, chunkdata);
+   png_free(png_ptr, png_ptr->chunkdata);
+   png_ptr->chunkdata = NULL;
    if (ret)
      png_error(png_ptr, "Insufficient memory to store iTXt chunk.");
 }
@@ -2185,25 +2380,40 @@
 {
    png_uint_32 skip = 0;
 
-   png_debug(1, "in png_handle_unknown\n");
+   png_debug(1, "in png_handle_unknown");
+
+#ifdef PNG_USER_LIMITS_SUPPORTED
+   if (png_ptr->user_chunk_cache_max != 0)
+   {
+      if (png_ptr->user_chunk_cache_max == 1)
+      {
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+      if (--png_ptr->user_chunk_cache_max == 1)
+      {
+         png_warning(png_ptr, "No space in chunk cache for unknown chunk");
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+   }
+#endif
 
    if (png_ptr->mode & PNG_HAVE_IDAT)
    {
 #ifdef PNG_USE_LOCAL_ARRAYS
       PNG_CONST PNG_IDAT;
 #endif
-      if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))  /* not an IDAT */
+      if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))  /* Not an IDAT */
          png_ptr->mode |= PNG_AFTER_IDAT;
    }
 
-   png_check_chunk_name(png_ptr, png_ptr->chunk_name);
-
    if (!(png_ptr->chunk_name[0] & 0x20))
    {
-#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
-      if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
+#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+      if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
            PNG_HANDLE_CHUNK_ALWAYS
-#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
+#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
            && png_ptr->read_user_chunk_fn == NULL
 #endif
         )
@@ -2211,9 +2421,12 @@
           png_chunk_error(png_ptr, "unknown critical chunk");
    }
 
-#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
-   if ((png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS) ||
-       (png_ptr->read_user_chunk_fn != NULL))
+#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
+   if ((png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)
+#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
+       || (png_ptr->read_user_chunk_fn != NULL)
+#endif
+        )
    {
 #ifdef PNG_MAX_MALLOC_64K
        if (length > (png_uint_32)65535L)
@@ -2224,16 +2437,22 @@
        }
 #endif
        png_memcpy((png_charp)png_ptr->unknown_chunk.name,
-                  (png_charp)png_ptr->chunk_name, 
+                  (png_charp)png_ptr->chunk_name,
                   png_sizeof(png_ptr->unknown_chunk.name));
-       png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name)-1] = '\0';
-       png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr, length);
+       png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name)-1]
+           = '\0';
        png_ptr->unknown_chunk.size = (png_size_t)length;
-       png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
-#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
-       if(png_ptr->read_user_chunk_fn != NULL)
+       if (length == 0)
+         png_ptr->unknown_chunk.data = NULL;
+       else
        {
-          /* callback to user unknown chunk handler */
+         png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr, length);
+         png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
+       }
+#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
+       if (png_ptr->read_user_chunk_fn != NULL)
+       {
+          /* Callback to user unknown chunk handler */
           int ret;
           ret = (*(png_ptr->read_user_chunk_fn))
             (png_ptr, &png_ptr->unknown_chunk);
@@ -2242,16 +2461,18 @@
           if (ret == 0)
           {
              if (!(png_ptr->chunk_name[0] & 0x20))
-                if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
+#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+                if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
                      PNG_HANDLE_CHUNK_ALWAYS)
+#endif
                    png_chunk_error(png_ptr, "unknown critical chunk");
              png_set_unknown_chunks(png_ptr, info_ptr,
                &png_ptr->unknown_chunk, 1);
           }
        }
-#else
-       png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
+       else
 #endif
+       png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
        png_free(png_ptr, png_ptr->unknown_chunk.data);
        png_ptr->unknown_chunk.data = NULL;
    }
@@ -2261,8 +2482,8 @@
 
    png_crc_finish(png_ptr, skip);
 
-#if !defined(PNG_READ_USER_CHUNKS_SUPPORTED)
-   info_ptr = info_ptr; /* quiet compiler warnings about unused info_ptr */
+#ifndef PNG_READ_USER_CHUNKS_SUPPORTED
+   PNG_UNUSED(info_ptr) /* Quiet compiler warnings about unused info_ptr */
 #endif
 }
 
@@ -2277,7 +2498,7 @@
 void /* PRIVATE */
 png_check_chunk_name(png_structp png_ptr, png_bytep chunk_name)
 {
-   png_debug(1, "in png_check_chunk_name\n");
+   png_debug(1, "in png_check_chunk_name");
    if (isnonalpha(chunk_name[0]) || isnonalpha(chunk_name[1]) ||
        isnonalpha(chunk_name[2]) || isnonalpha(chunk_name[3]))
    {
@@ -2299,7 +2520,7 @@
 void /* PRIVATE */
 png_combine_row(png_structp png_ptr, png_bytep row, int mask)
 {
-   png_debug(1,"in png_combine_row\n");
+   png_debug(1, "in png_combine_row");
    if (mask == 0xff)
    {
       png_memcpy(row, png_ptr->row_buf + 1,
@@ -2319,7 +2540,7 @@
             png_uint_32 i;
             png_uint_32 row_width = png_ptr->width;
 
-#if defined(PNG_READ_PACKSWAP_SUPPORTED)
+#ifdef PNG_READ_PACKSWAP_SUPPORTED
             if (png_ptr->transformations & PNG_PACKSWAP)
             {
                 s_start = 0;
@@ -2374,7 +2595,7 @@
             png_uint_32 row_width = png_ptr->width;
             int value;
 
-#if defined(PNG_READ_PACKSWAP_SUPPORTED)
+#ifdef PNG_READ_PACKSWAP_SUPPORTED
             if (png_ptr->transformations & PNG_PACKSWAP)
             {
                s_start = 0;
@@ -2426,7 +2647,7 @@
             png_uint_32 row_width = png_ptr->width;
             int value;
 
-#if defined(PNG_READ_PACKSWAP_SUPPORTED)
+#ifdef PNG_READ_PACKSWAP_SUPPORTED
             if (png_ptr->transformations & PNG_PACKSWAP)
             {
                s_start = 0;
@@ -2509,13 +2730,13 @@
    png_bytep row = png_ptr->row_buf + 1;
    int pass = png_ptr->pass;
    png_uint_32 transformations = png_ptr->transformations;
-#ifdef PNG_USE_LOCAL_ARRAYS
-   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
-   /* offset to next interlace block */
+   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
+   /* Offset to next interlace block */
+#ifndef PNG_USE_GLOBAL_ARRAYS
    PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 #endif
 
-   png_debug(1,"in png_do_read_interlace\n");
+   png_debug(1, "in png_do_read_interlace");
    if (row != NULL && row_info != NULL)
    {
       png_uint_32 final_width;
@@ -2535,7 +2756,7 @@
             png_uint_32 i;
             int j;
 
-#if defined(PNG_READ_PACKSWAP_SUPPORTED)
+#ifdef PNG_READ_PACKSWAP_SUPPORTED
             if (transformations & PNG_PACKSWAP)
             {
                 sshift = (int)((row_info->width + 7) & 0x07);
@@ -2588,7 +2809,7 @@
             int jstop = png_pass_inc[pass];
             png_uint_32 i;
 
-#if defined(PNG_READ_PACKSWAP_SUPPORTED)
+#ifdef PNG_READ_PACKSWAP_SUPPORTED
             if (transformations & PNG_PACKSWAP)
             {
                sshift = (int)(((row_info->width + 3) & 0x03) << 1);
@@ -2644,7 +2865,7 @@
             png_uint_32 i;
             int jstop = png_pass_inc[pass];
 
-#if defined(PNG_READ_PACKSWAP_SUPPORTED)
+#ifdef PNG_READ_PACKSWAP_SUPPORTED
             if (transformations & PNG_PACKSWAP)
             {
                sshift = (int)(((row_info->width + 1) & 0x01) << 2);
@@ -2693,7 +2914,8 @@
          default:
          {
             png_size_t pixel_bytes = (row_info->pixel_depth >> 3);
-            png_bytep sp = row + (png_size_t)(row_info->width - 1) * pixel_bytes;
+            png_bytep sp = row + (png_size_t)(row_info->width - 1)
+                * pixel_bytes;
             png_bytep dp = row + (png_size_t)(final_width - 1) * pixel_bytes;
 
             int jstop = png_pass_inc[pass];
@@ -2716,10 +2938,10 @@
          }
       }
       row_info->width = final_width;
-      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,final_width);
+      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);
    }
-#if !defined(PNG_READ_PACKSWAP_SUPPORTED)
-   transformations = transformations; /* silence compiler warning */
+#ifndef PNG_READ_PACKSWAP_SUPPORTED
+   PNG_UNUSED(transformations) /* Silence compiler warning */
 #endif
 }
 #endif /* PNG_READ_INTERLACING_SUPPORTED */
@@ -2728,8 +2950,8 @@
 png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep row,
    png_bytep prev_row, int filter)
 {
-   png_debug(1, "in png_read_filter_row\n");
-   png_debug2(2,"row = %lu, filter = %d\n", png_ptr->row_number, filter);
+   png_debug(1, "in png_read_filter_row");
+   png_debug2(2, "row = %lu, filter = %d", png_ptr->row_number, filter);
    switch (filter)
    {
       case PNG_FILTER_VALUE_NONE:
@@ -2803,7 +3025,7 @@
             rp++;
          }
 
-         for (i = 0; i < istop; i++)   /* use leftover rp,pp */
+         for (i = 0; i < istop; i++)   /* Use leftover rp,pp */
          {
             int a, b, c, pa, pb, pc, p;
 
@@ -2833,7 +3055,7 @@
                   p = c;
              */
 
-            p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
+            p = (pa <= pb && pa <= pc) ? a : (pb <= pc) ? b : c;
 
             *rp = (png_byte)(((int)(*rp) + p) & 0xff);
             rp++;
@@ -2842,35 +3064,39 @@
       }
       default:
          png_warning(png_ptr, "Ignoring bad adaptive filter type");
-         *row=0;
+         *row = 0;
          break;
    }
 }
 
+#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
 void /* PRIVATE */
 png_read_finish_row(png_structp png_ptr)
 {
-#ifdef PNG_USE_LOCAL_ARRAYS
-   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
+#ifdef PNG_READ_INTERLACING_SUPPORTED
+#ifndef PNG_USE_GLOBAL_ARRAYS
+   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
-   /* start of interlace block */
+   /* Start of interlace block */
    PNG_CONST int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
-   /* offset to next interlace block */
+   /* Offset to next interlace block */
    PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
-   /* start of interlace block in the y direction */
+   /* Start of interlace block in the y direction */
    PNG_CONST int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
 
-   /* offset to next interlace block in the y direction */
+   /* Offset to next interlace block in the y direction */
    PNG_CONST int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
 #endif
+#endif /* PNG_READ_INTERLACING_SUPPORTED */
 
-   png_debug(1, "in png_read_finish_row\n");
+   png_debug(1, "in png_read_finish_row");
    png_ptr->row_number++;
    if (png_ptr->row_number < png_ptr->num_rows)
       return;
 
+#ifdef PNG_READ_INTERLACING_SUPPORTED
    if (png_ptr->interlaced)
    {
       png_ptr->row_number = 0;
@@ -2886,9 +3112,6 @@
             png_pass_start[png_ptr->pass]) /
             png_pass_inc[png_ptr->pass];
 
-         png_ptr->irowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,
-            png_ptr->iwidth) + 1;
-
          if (!(png_ptr->transformations & PNG_INTERLACE))
          {
             png_ptr->num_rows = (png_ptr->height +
@@ -2905,6 +3128,7 @@
       if (png_ptr->pass < 7)
          return;
    }
+#endif /* PNG_READ_INTERLACING_SUPPORTED */
 
    if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
    {
@@ -2916,7 +3140,7 @@
 
       png_ptr->zstream.next_out = (Byte *)&extra;
       png_ptr->zstream.avail_out = (uInt)1;
-      for(;;)
+      for (;;)
       {
          if (!(png_ptr->zstream.avail_in))
          {
@@ -2946,7 +3170,7 @@
          {
             if (!(png_ptr->zstream.avail_out) || png_ptr->zstream.avail_in ||
                png_ptr->idat_size)
-               png_warning(png_ptr, "Extra compressed data");
+               png_warning(png_ptr, "Extra compressed data.");
             png_ptr->mode |= PNG_AFTER_IDAT;
             png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
             break;
@@ -2968,38 +3192,42 @@
    }
 
    if (png_ptr->idat_size || png_ptr->zstream.avail_in)
-      png_warning(png_ptr, "Extra compression data");
+      png_warning(png_ptr, "Extra compression data.");
 
    inflateReset(&png_ptr->zstream);
 
    png_ptr->mode |= PNG_AFTER_IDAT;
 }
+#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
 
 void /* PRIVATE */
 png_read_start_row(png_structp png_ptr)
 {
-#ifdef PNG_USE_LOCAL_ARRAYS
-   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
+#ifdef PNG_READ_INTERLACING_SUPPORTED
+#ifndef PNG_USE_GLOBAL_ARRAYS
+   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
-   /* start of interlace block */
+   /* Start of interlace block */
    PNG_CONST int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
-   /* offset to next interlace block */
+   /* Offset to next interlace block */
    PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
-   /* start of interlace block in the y direction */
+   /* Start of interlace block in the y direction */
    PNG_CONST int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
 
-   /* offset to next interlace block in the y direction */
+   /* Offset to next interlace block in the y direction */
    PNG_CONST int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
 #endif
+#endif
 
    int max_pixel_depth;
-   png_uint_32 row_bytes;
+   png_size_t row_bytes;
 
-   png_debug(1, "in png_read_start_row\n");
+   png_debug(1, "in png_read_start_row");
    png_ptr->zstream.avail_in = 0;
    png_init_read_transformations(png_ptr);
+#ifdef PNG_READ_INTERLACING_SUPPORTED
    if (png_ptr->interlaced)
    {
       if (!(png_ptr->transformations & PNG_INTERLACE))
@@ -3012,27 +3240,21 @@
          png_pass_inc[png_ptr->pass] - 1 -
          png_pass_start[png_ptr->pass]) /
          png_pass_inc[png_ptr->pass];
-
-         row_bytes = PNG_ROWBYTES(png_ptr->pixel_depth,png_ptr->iwidth) + 1;
-
-         png_ptr->irowbytes = (png_size_t)row_bytes;
-         if((png_uint_32)png_ptr->irowbytes != row_bytes)
-            png_error(png_ptr, "Rowbytes overflow in png_read_start_row");
    }
    else
+#endif /* PNG_READ_INTERLACING_SUPPORTED */
    {
       png_ptr->num_rows = png_ptr->height;
       png_ptr->iwidth = png_ptr->width;
-      png_ptr->irowbytes = png_ptr->rowbytes + 1;
    }
    max_pixel_depth = png_ptr->pixel_depth;
 
-#if defined(PNG_READ_PACK_SUPPORTED)
+#ifdef PNG_READ_PACK_SUPPORTED
    if ((png_ptr->transformations & PNG_PACK) && png_ptr->bit_depth < 8)
       max_pixel_depth = 8;
 #endif
 
-#if defined(PNG_READ_EXPAND_SUPPORTED)
+#ifdef PNG_READ_EXPAND_SUPPORTED
    if (png_ptr->transformations & PNG_EXPAND)
    {
       if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
@@ -3060,7 +3282,7 @@
    }
 #endif
 
-#if defined(PNG_READ_FILLER_SUPPORTED)
+#ifdef PNG_READ_FILLER_SUPPORTED
    if (png_ptr->transformations & (PNG_FILLER))
    {
       if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
@@ -3082,14 +3304,14 @@
    }
 #endif
 
-#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
    if (png_ptr->transformations & PNG_GRAY_TO_RGB)
    {
       if (
-#if defined(PNG_READ_EXPAND_SUPPORTED)
+#ifdef PNG_READ_EXPAND_SUPPORTED
         (png_ptr->num_trans && (png_ptr->transformations & PNG_EXPAND)) ||
 #endif
-#if defined(PNG_READ_FILLER_SUPPORTED)
+#ifdef PNG_READ_FILLER_SUPPORTED
         (png_ptr->transformations & (PNG_FILLER)) ||
 #endif
         png_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
@@ -3118,46 +3340,70 @@
 
 #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) && \
 defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
-   if(png_ptr->transformations & PNG_USER_TRANSFORM)
+   if (png_ptr->transformations & PNG_USER_TRANSFORM)
      {
-       int user_pixel_depth=png_ptr->user_transform_depth*
+       int user_pixel_depth = png_ptr->user_transform_depth*
          png_ptr->user_transform_channels;
-       if(user_pixel_depth > max_pixel_depth)
+       if (user_pixel_depth > max_pixel_depth)
          max_pixel_depth=user_pixel_depth;
      }
 #endif
 
-   /* align the width on the next larger 8 pixels.  Mainly used
-      for interlacing */
+   /* Align the width on the next larger 8 pixels.  Mainly used
+    * for interlacing
+    */
    row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));
-   /* calculate the maximum bytes needed, adding a byte and a pixel
-      for safety's sake */
-   row_bytes = PNG_ROWBYTES(max_pixel_depth,row_bytes) +
+   /* Calculate the maximum bytes needed, adding a byte and a pixel
+    * for safety's sake
+    */
+   row_bytes = PNG_ROWBYTES(max_pixel_depth, row_bytes) +
       1 + ((max_pixel_depth + 7) >> 3);
 #ifdef PNG_MAX_MALLOC_64K
    if (row_bytes > (png_uint_32)65536L)
       png_error(png_ptr, "This image requires a row greater than 64KB");
 #endif
-   png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes+64);
-   png_ptr->row_buf = png_ptr->big_row_buf+32;
+
+   if (row_bytes + 64 > png_ptr->old_big_row_buf_size)
+   {
+     png_free(png_ptr, png_ptr->big_row_buf);
+     if (png_ptr->interlaced)
+        png_ptr->big_row_buf = (png_bytep)png_calloc(png_ptr,
+            row_bytes + 64);
+     else
+        png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr,
+            row_bytes + 64);
+     png_ptr->old_big_row_buf_size = row_bytes + 64;
+
+     /* Use 32 bytes of padding before and after row_buf. */
+     png_ptr->row_buf = png_ptr->big_row_buf + 32;
+     png_ptr->old_big_row_buf_size = row_bytes + 64;
+   }
 
 #ifdef PNG_MAX_MALLOC_64K
-   if ((png_uint_32)png_ptr->rowbytes + 1 > (png_uint_32)65536L)
+   if ((png_uint_32)row_bytes + 1 > (png_uint_32)65536L)
       png_error(png_ptr, "This image requires a row greater than 64KB");
 #endif
-   if ((png_uint_32)png_ptr->rowbytes > (png_uint_32)(PNG_SIZE_MAX - 1))
+   if ((png_uint_32)row_bytes > (png_uint_32)(PNG_SIZE_MAX - 1))
       png_error(png_ptr, "Row has too many bytes to allocate in memory.");
-   png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
-      png_ptr->rowbytes + 1));
 
-   png_memset_check(png_ptr, png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
-
-   png_debug1(3, "width = %lu,\n", png_ptr->width);
-   png_debug1(3, "height = %lu,\n", png_ptr->height);
-   png_debug1(3, "iwidth = %lu,\n", png_ptr->iwidth);
-   png_debug1(3, "num_rows = %lu\n", png_ptr->num_rows);
-   png_debug1(3, "rowbytes = %lu,\n", png_ptr->rowbytes);
-   png_debug1(3, "irowbytes = %lu,\n", png_ptr->irowbytes);
+   if (row_bytes + 1 > png_ptr->old_prev_row_size)
+   {
+      png_free(png_ptr, png_ptr->prev_row);
+      png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
+        row_bytes + 1));
+      png_memset_check(png_ptr, png_ptr->prev_row, 0, row_bytes + 1);
+      png_ptr->old_prev_row_size = row_bytes + 1;
+   }
+
+   png_ptr->rowbytes = row_bytes;
+
+   png_debug1(3, "width = %lu,", png_ptr->width);
+   png_debug1(3, "height = %lu,", png_ptr->height);
+   png_debug1(3, "iwidth = %lu,", png_ptr->iwidth);
+   png_debug1(3, "num_rows = %lu,", png_ptr->num_rows);
+   png_debug1(3, "rowbytes = %lu,", png_ptr->rowbytes);
+   png_debug1(3, "irowbytes = %lu",
+       PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1);
 
    png_ptr->flags |= PNG_FLAG_ROW_INIT;
 }
diff -Naur libAfterImage-1.20/libpng/pngset.c root/graf2d/asimage/src/libAfterImage/libpng/pngset.c
--- libAfterImage-1.20/libpng/pngset.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngset.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,12 +1,15 @@
 
 /* pngset.c - storage of image information into info struct
  *
- * Last changed in libpng 1.2.22 [November 6, 2007]
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.54 [November 12, 2015]
+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
  * The functions here are used during reads to store data from the file
  * into the info struct, and during writes to store application data
  * into the info struct for writing into the file.  This abstracts the
@@ -14,15 +17,16 @@
  */
 
 #define PNG_INTERNAL
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
-
 #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
 
-#if defined(PNG_bKGD_SUPPORTED)
+#ifdef PNG_bKGD_SUPPORTED
 void PNGAPI
 png_set_bKGD(png_structp png_ptr, png_infop info_ptr, png_color_16p background)
 {
-   png_debug1(1, "in %s storage function\n", "bKGD");
+   png_debug1(1, "in %s storage function", "bKGD");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
@@ -31,41 +35,17 @@
 }
 #endif
 
-#if defined(PNG_cHRM_SUPPORTED)
+#ifdef PNG_cHRM_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 void PNGAPI
 png_set_cHRM(png_structp png_ptr, png_infop info_ptr,
    double white_x, double white_y, double red_x, double red_y,
    double green_x, double green_y, double blue_x, double blue_y)
 {
-   png_debug1(1, "in %s storage function\n", "cHRM");
+   png_debug1(1, "in %s storage function", "cHRM");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
-   if (!(white_x || white_y || red_x || red_y || green_x || green_y ||
-       blue_x || blue_y))
-   {
-      png_warning(png_ptr,
-        "Ignoring attempt to set all-zero chromaticity values");
-      return;
-   }
-   if (white_x < 0.0 || white_y < 0.0 ||
-         red_x < 0.0 ||   red_y < 0.0 ||
-       green_x < 0.0 || green_y < 0.0 ||
-        blue_x < 0.0 ||  blue_y < 0.0)
-   {
-      png_warning(png_ptr,
-        "Ignoring attempt to set negative chromaticity value");
-      return;
-   }
-   if (white_x > 21474.83 || white_y > 21474.83 ||
-         red_x > 21474.83 ||   red_y > 21474.83 ||
-       green_x > 21474.83 || green_y > 21474.83 ||
-        blue_x > 21474.83 ||  blue_y > 21474.83)
-   {
-      png_warning(png_ptr,
-        "Ignoring attempt to set chromaticity value exceeding 21474.83");
-      return;
-   }
 
    info_ptr->x_white = (float)white_x;
    info_ptr->y_white = (float)white_y;
@@ -87,7 +67,8 @@
 #endif
    info_ptr->valid |= PNG_INFO_cHRM;
 }
-#endif
+#endif /* PNG_FLOATING_POINT_SUPPORTED */
+
 #ifdef PNG_FIXED_POINT_SUPPORTED
 void PNGAPI
 png_set_cHRM_fixed(png_structp png_ptr, png_infop info_ptr,
@@ -95,80 +76,49 @@
    png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,
    png_fixed_point blue_x, png_fixed_point blue_y)
 {
-   png_debug1(1, "in %s storage function\n", "cHRM");
+   png_debug1(1, "in %s storage function", "cHRM fixed");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
-   if (!(white_x || white_y || red_x || red_y || green_x || green_y ||
-       blue_x || blue_y))
-   {
-      png_warning(png_ptr,
-        "Ignoring attempt to set all-zero chromaticity values");
-      return;
-   }
-   if (white_x < 0 || white_y < 0 ||
-         red_x < 0 ||   red_y < 0 ||
-       green_x < 0 || green_y < 0 ||
-        blue_x < 0 ||  blue_y < 0)
-   {
-      png_warning(png_ptr,
-        "Ignoring attempt to set negative chromaticity value");
-      return;
-   }
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   if (white_x > (double) PNG_UINT_31_MAX ||
-       white_y > (double) PNG_UINT_31_MAX ||
-         red_x > (double) PNG_UINT_31_MAX ||
-         red_y > (double) PNG_UINT_31_MAX ||
-       green_x > (double) PNG_UINT_31_MAX ||
-       green_y > (double) PNG_UINT_31_MAX ||
-        blue_x > (double) PNG_UINT_31_MAX ||
-        blue_y > (double) PNG_UINT_31_MAX)
-#else
-   if (white_x > (png_fixed_point) PNG_UINT_31_MAX/100000L ||
-       white_y > (png_fixed_point) PNG_UINT_31_MAX/100000L ||
-         red_x > (png_fixed_point) PNG_UINT_31_MAX/100000L ||
-         red_y > (png_fixed_point) PNG_UINT_31_MAX/100000L ||
-       green_x > (png_fixed_point) PNG_UINT_31_MAX/100000L ||
-       green_y > (png_fixed_point) PNG_UINT_31_MAX/100000L ||
-        blue_x > (png_fixed_point) PNG_UINT_31_MAX/100000L ||
-        blue_y > (png_fixed_point) PNG_UINT_31_MAX/100000L)
+#ifdef PNG_CHECK_cHRM_SUPPORTED
+   if (png_check_cHRM_fixed(png_ptr,
+      white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y))
 #endif
    {
-      png_warning(png_ptr,
-        "Ignoring attempt to set chromaticity value exceeding 21474.83");
-      return;
-   }
-   info_ptr->int_x_white = white_x;
-   info_ptr->int_y_white = white_y;
-   info_ptr->int_x_red   = red_x;
-   info_ptr->int_y_red   = red_y;
-   info_ptr->int_x_green = green_x;
-   info_ptr->int_y_green = green_y;
-   info_ptr->int_x_blue  = blue_x;
-   info_ptr->int_y_blue  = blue_y;
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   info_ptr->x_white = (float)(white_x/100000.);
-   info_ptr->y_white = (float)(white_y/100000.);
-   info_ptr->x_red   = (float)(  red_x/100000.);
-   info_ptr->y_red   = (float)(  red_y/100000.);
-   info_ptr->x_green = (float)(green_x/100000.);
-   info_ptr->y_green = (float)(green_y/100000.);
-   info_ptr->x_blue  = (float)( blue_x/100000.);
-   info_ptr->y_blue  = (float)( blue_y/100000.);
+      info_ptr->int_x_white = white_x;
+      info_ptr->int_y_white = white_y;
+      info_ptr->int_x_red   = red_x;
+      info_ptr->int_y_red   = red_y;
+      info_ptr->int_x_green = green_x;
+      info_ptr->int_y_green = green_y;
+      info_ptr->int_x_blue  = blue_x;
+      info_ptr->int_y_blue  = blue_y;
+#ifdef  PNG_FLOATING_POINT_SUPPORTED
+      info_ptr->x_white = (float)(white_x/100000.);
+      info_ptr->y_white = (float)(white_y/100000.);
+      info_ptr->x_red   = (float)(  red_x/100000.);
+      info_ptr->y_red   = (float)(  red_y/100000.);
+      info_ptr->x_green = (float)(green_x/100000.);
+      info_ptr->y_green = (float)(green_y/100000.);
+      info_ptr->x_blue  = (float)( blue_x/100000.);
+      info_ptr->y_blue  = (float)( blue_y/100000.);
 #endif
-   info_ptr->valid |= PNG_INFO_cHRM;
+      info_ptr->valid |= PNG_INFO_cHRM;
+   }
 }
-#endif
-#endif
+#endif /* PNG_FIXED_POINT_SUPPORTED */
+#endif /* PNG_cHRM_SUPPORTED */
 
-#if defined(PNG_gAMA_SUPPORTED)
+#ifdef PNG_gAMA_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 void PNGAPI
 png_set_gAMA(png_structp png_ptr, png_infop info_ptr, double file_gamma)
 {
-   double gamma;
-   png_debug1(1, "in %s storage function\n", "gAMA");
+   double png_gamma;
+
+   png_debug1(1, "in %s storage function", "gAMA");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
@@ -176,16 +126,16 @@
    if (file_gamma > 21474.83)
    {
       png_warning(png_ptr, "Limiting gamma to 21474.83");
-      gamma=21474.83;
+      png_gamma=21474.83;
    }
    else
-      gamma=file_gamma;
-   info_ptr->gamma = (float)gamma;
+      png_gamma = file_gamma;
+   info_ptr->gamma = (float)png_gamma;
 #ifdef PNG_FIXED_POINT_SUPPORTED
-   info_ptr->int_gamma = (int)(gamma*100000.+.5);
+   info_ptr->int_gamma = (int)(png_gamma*100000.+.5);
 #endif
    info_ptr->valid |= PNG_INFO_gAMA;
-   if(gamma == 0.0)
+   if (png_gamma == 0.0)
       png_warning(png_ptr, "Setting gamma=0");
 }
 #endif
@@ -193,71 +143,75 @@
 png_set_gAMA_fixed(png_structp png_ptr, png_infop info_ptr, png_fixed_point
    int_gamma)
 {
-   png_fixed_point gamma;
+   png_fixed_point png_gamma;
+
+   png_debug1(1, "in %s storage function", "gAMA");
 
-   png_debug1(1, "in %s storage function\n", "gAMA");
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
-   if (int_gamma > (png_fixed_point) PNG_UINT_31_MAX)
+   if (int_gamma > (png_fixed_point)PNG_UINT_31_MAX)
    {
-     png_warning(png_ptr, "Limiting gamma to 21474.83");
-     gamma=PNG_UINT_31_MAX;
+      png_warning(png_ptr, "Limiting gamma to 21474.83");
+      png_gamma=PNG_UINT_31_MAX;
    }
    else
    {
-     if (int_gamma < 0)
-     {
-       png_warning(png_ptr, "Setting negative gamma to zero");
-       gamma=0;
-     }
-     else
-       gamma=int_gamma;
+      if (int_gamma < 0)
+      {
+         png_warning(png_ptr, "Setting negative gamma to zero");
+         png_gamma = 0;
+      }
+      else
+         png_gamma = int_gamma;
    }
 #ifdef PNG_FLOATING_POINT_SUPPORTED
-   info_ptr->gamma = (float)(gamma/100000.);
+   info_ptr->gamma = (float)(png_gamma/100000.);
 #endif
 #ifdef PNG_FIXED_POINT_SUPPORTED
-   info_ptr->int_gamma = gamma;
+   info_ptr->int_gamma = png_gamma;
 #endif
    info_ptr->valid |= PNG_INFO_gAMA;
-   if(gamma == 0)
+   if (png_gamma == 0)
       png_warning(png_ptr, "Setting gamma=0");
 }
 #endif
 
-#if defined(PNG_hIST_SUPPORTED)
+#ifdef PNG_hIST_SUPPORTED
 void PNGAPI
 png_set_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_16p hist)
 {
    int i;
 
-   png_debug1(1, "in %s storage function\n", "hIST");
+   png_debug1(1, "in %s storage function", "hIST");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
+
    if (info_ptr->num_palette == 0 || info_ptr->num_palette
        > PNG_MAX_PALETTE_LENGTH)
    {
-       png_warning(png_ptr,
-          "Invalid palette size, hIST allocation skipped.");
-       return;
+      png_warning(png_ptr,
+         "Invalid palette size, hIST allocation skipped.");
+      return;
    }
 
 #ifdef PNG_FREE_ME_SUPPORTED
    png_free_data(png_ptr, info_ptr, PNG_FREE_HIST, 0);
 #endif
-   /* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in version
-      1.2.1 */
+   /* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in
+    * version 1.2.1
+    */
    png_ptr->hist = (png_uint_16p)png_malloc_warn(png_ptr,
-      (png_uint_32)(PNG_MAX_PALETTE_LENGTH * png_sizeof (png_uint_16)));
+      (png_uint_32)(PNG_MAX_PALETTE_LENGTH * png_sizeof(png_uint_16)));
    if (png_ptr->hist == NULL)
-     {
-       png_warning(png_ptr, "Insufficient memory for hIST chunk data.");
-       return;
-     }
+   {
+      png_warning(png_ptr, "Insufficient memory for hIST chunk data.");
+      return;
+   }
 
    for (i = 0; i < info_ptr->num_palette; i++)
-       png_ptr->hist[i] = hist[i];
+      png_ptr->hist[i] = hist[i];
    info_ptr->hist = png_ptr->hist;
    info_ptr->valid |= PNG_INFO_hIST;
 
@@ -275,86 +229,23 @@
    int color_type, int interlace_type, int compression_type,
    int filter_type)
 {
-   png_debug1(1, "in %s storage function\n", "IHDR");
+   png_debug1(1, "in %s storage function", "IHDR");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
-   /* check for width and height valid values */
-   if (width == 0 || height == 0)
-      png_error(png_ptr, "Image width or height is zero in IHDR");
-#ifdef PNG_SET_USER_LIMITS_SUPPORTED
-   if (width > png_ptr->user_width_max || height > png_ptr->user_height_max)
-      png_error(png_ptr, "image size exceeds user limits in IHDR");
-#else
-   if (width > PNG_USER_WIDTH_MAX || height > PNG_USER_HEIGHT_MAX)
-      png_error(png_ptr, "image size exceeds user limits in IHDR");
-#endif
-   if (width > PNG_UINT_31_MAX || height > PNG_UINT_31_MAX)
-      png_error(png_ptr, "Invalid image size in IHDR");
-   if ( width > (PNG_UINT_32_MAX
-                 >> 3)      /* 8-byte RGBA pixels */
-                 - 64       /* bigrowbuf hack */
-                 - 1        /* filter byte */
-                 - 7*8      /* rounding of width to multiple of 8 pixels */
-                 - 8)       /* extra max_pixel_depth pad */
-      png_warning(png_ptr, "Width is too large for libpng to process pixels");
-
-   /* check other values */
-   if (bit_depth != 1 && bit_depth != 2 && bit_depth != 4 &&
-      bit_depth != 8 && bit_depth != 16)
-      png_error(png_ptr, "Invalid bit depth in IHDR");
-
-   if (color_type < 0 || color_type == 1 ||
-      color_type == 5 || color_type > 6)
-      png_error(png_ptr, "Invalid color type in IHDR");
-
-   if (((color_type == PNG_COLOR_TYPE_PALETTE) && bit_depth > 8) ||
-       ((color_type == PNG_COLOR_TYPE_RGB ||
-         color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
-         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && bit_depth < 8))
-      png_error(png_ptr, "Invalid color type/bit depth combination in IHDR");
-
-   if (interlace_type >= PNG_INTERLACE_LAST)
-      png_error(png_ptr, "Unknown interlace method in IHDR");
-
-   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
-      png_error(png_ptr, "Unknown compression method in IHDR");
-
-#if defined(PNG_MNG_FEATURES_SUPPORTED)
-   /* Accept filter_method 64 (intrapixel differencing) only if
-    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
-    * 2. Libpng did not read a PNG signature (this filter_method is only
-    *    used in PNG datastreams that are embedded in MNG datastreams) and
-    * 3. The application called png_permit_mng_features with a mask that
-    *    included PNG_FLAG_MNG_FILTER_64 and
-    * 4. The filter_method is 64 and
-    * 5. The color_type is RGB or RGBA
-    */
-   if((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE)&&png_ptr->mng_features_permitted)
-      png_warning(png_ptr,"MNG features are not allowed in a PNG datastream");
-   if(filter_type != PNG_FILTER_TYPE_BASE)
-   {
-     if(!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
-        (filter_type == PNG_INTRAPIXEL_DIFFERENCING) &&
-        ((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE) == 0) &&
-        (color_type == PNG_COLOR_TYPE_RGB ||
-         color_type == PNG_COLOR_TYPE_RGB_ALPHA)))
-        png_error(png_ptr, "Unknown filter method in IHDR");
-     if(png_ptr->mode&PNG_HAVE_PNG_SIGNATURE)
-        png_warning(png_ptr, "Invalid filter method in IHDR");
-   }
-#else
-   if(filter_type != PNG_FILTER_TYPE_BASE)
-      png_error(png_ptr, "Unknown filter method in IHDR");
-#endif
-
    info_ptr->width = width;
    info_ptr->height = height;
    info_ptr->bit_depth = (png_byte)bit_depth;
-   info_ptr->color_type =(png_byte) color_type;
+   info_ptr->color_type = (png_byte)color_type;
    info_ptr->compression_type = (png_byte)compression_type;
    info_ptr->filter_type = (png_byte)filter_type;
    info_ptr->interlace_type = (png_byte)interlace_type;
+
+   png_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,
+       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,
+       info_ptr->compression_type, info_ptr->filter_type);
+
    if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
       info_ptr->channels = 1;
    else if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)
@@ -365,24 +256,28 @@
       info_ptr->channels++;
    info_ptr->pixel_depth = (png_byte)(info_ptr->channels * info_ptr->bit_depth);
 
-   /* check for potential overflow */
+   /* Check for potential overflow */
    if (width > (PNG_UINT_32_MAX
                  >> 3)      /* 8-byte RGBA pixels */
                  - 64       /* bigrowbuf hack */
                  - 1        /* filter byte */
                  - 7*8      /* rounding of width to multiple of 8 pixels */
                  - 8)       /* extra max_pixel_depth pad */
+   {
       info_ptr->rowbytes = (png_size_t)0;
+      png_error(png_ptr, "Image width is too large for this architecture");
+   }
    else
-      info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth,width);
+      info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);
 }
 
-#if defined(PNG_oFFs_SUPPORTED)
+#ifdef PNG_oFFs_SUPPORTED
 void PNGAPI
 png_set_oFFs(png_structp png_ptr, png_infop info_ptr,
    png_int_32 offset_x, png_int_32 offset_y, int unit_type)
 {
-   png_debug1(1, "in %s storage function\n", "oFFs");
+   png_debug1(1, "in %s storage function", "oFFs");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
@@ -393,7 +288,7 @@
 }
 #endif
 
-#if defined(PNG_pCAL_SUPPORTED)
+#ifdef PNG_pCAL_SUPPORTED
 void PNGAPI
 png_set_pCAL(png_structp png_ptr, png_infop info_ptr,
    png_charp purpose, png_int_32 X0, png_int_32 X1, int type, int nparams,
@@ -402,56 +297,60 @@
    png_uint_32 length;
    int i;
 
-   png_debug1(1, "in %s storage function\n", "pCAL");
+   png_debug1(1, "in %s storage function", "pCAL");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
    length = png_strlen(purpose) + 1;
-   png_debug1(3, "allocating purpose for info (%lu bytes)\n", length);
+   png_debug1(3, "allocating purpose for info (%lu bytes)",
+     (unsigned long)length);
    info_ptr->pcal_purpose = (png_charp)png_malloc_warn(png_ptr, length);
    if (info_ptr->pcal_purpose == NULL)
-     {
-       png_warning(png_ptr, "Insufficient memory for pCAL purpose.");
-       return;
-     }
+   {
+      png_warning(png_ptr, "Insufficient memory for pCAL purpose.");
+      return;
+   }
    png_memcpy(info_ptr->pcal_purpose, purpose, (png_size_t)length);
 
-   png_debug(3, "storing X0, X1, type, and nparams in info\n");
+   png_debug(3, "storing X0, X1, type, and nparams in info");
    info_ptr->pcal_X0 = X0;
    info_ptr->pcal_X1 = X1;
    info_ptr->pcal_type = (png_byte)type;
    info_ptr->pcal_nparams = (png_byte)nparams;
 
    length = png_strlen(units) + 1;
-   png_debug1(3, "allocating units for info (%lu bytes)\n", length);
+   png_debug1(3, "allocating units for info (%lu bytes)",
+     (unsigned long)length);
    info_ptr->pcal_units = (png_charp)png_malloc_warn(png_ptr, length);
    if (info_ptr->pcal_units == NULL)
-     {
-       png_warning(png_ptr, "Insufficient memory for pCAL units.");
-       return;
-     }
+   {
+      png_warning(png_ptr, "Insufficient memory for pCAL units.");
+      return;
+   }
    png_memcpy(info_ptr->pcal_units, units, (png_size_t)length);
 
    info_ptr->pcal_params = (png_charpp)png_malloc_warn(png_ptr,
       (png_uint_32)((nparams + 1) * png_sizeof(png_charp)));
    if (info_ptr->pcal_params == NULL)
-     {
-       png_warning(png_ptr, "Insufficient memory for pCAL params.");
-       return;
-     }
+   {
+      png_warning(png_ptr, "Insufficient memory for pCAL params.");
+      return;
+   }
 
-   info_ptr->pcal_params[nparams] = NULL;
+   png_memset(info_ptr->pcal_params, 0, (nparams + 1) * png_sizeof(png_charp));
 
    for (i = 0; i < nparams; i++)
    {
       length = png_strlen(params[i]) + 1;
-      png_debug2(3, "allocating parameter %d for info (%lu bytes)\n", i, length);
+      png_debug2(3, "allocating parameter %d for info (%lu bytes)", i,
+        (unsigned long)length);
       info_ptr->pcal_params[i] = (png_charp)png_malloc_warn(png_ptr, length);
       if (info_ptr->pcal_params[i] == NULL)
-        {
-          png_warning(png_ptr, "Insufficient memory for pCAL parameter.");
-          return;
-        }
+      {
+         png_warning(png_ptr, "Insufficient memory for pCAL parameter.");
+         return;
+      }
       png_memcpy(info_ptr->pcal_params[i], params[i], (png_size_t)length);
    }
 
@@ -468,7 +367,8 @@
 png_set_sCAL(png_structp png_ptr, png_infop info_ptr,
              int unit, double width, double height)
 {
-   png_debug1(1, "in %s storage function\n", "sCAL");
+   png_debug1(1, "in %s storage function", "sCAL");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
@@ -486,33 +386,38 @@
 {
    png_uint_32 length;
 
-   png_debug1(1, "in %s storage function\n", "sCAL");
+   png_debug1(1, "in %s storage function", "sCAL");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
    info_ptr->scal_unit = (png_byte)unit;
 
    length = png_strlen(swidth) + 1;
-   png_debug1(3, "allocating unit for info (%d bytes)\n", length);
+   png_debug1(3, "allocating unit for info (%u bytes)",
+      (unsigned int)length);
    info_ptr->scal_s_width = (png_charp)png_malloc_warn(png_ptr, length);
    if (info_ptr->scal_s_width == NULL)
    {
       png_warning(png_ptr,
-       "Memory allocation failed while processing sCAL.");
+         "Memory allocation failed while processing sCAL.");
+      return;
    }
    png_memcpy(info_ptr->scal_s_width, swidth, (png_size_t)length);
 
    length = png_strlen(sheight) + 1;
-   png_debug1(3, "allocating unit for info (%d bytes)\n", length);
+   png_debug1(3, "allocating unit for info (%u bytes)",
+      (unsigned int)length);
    info_ptr->scal_s_height = (png_charp)png_malloc_warn(png_ptr, length);
    if (info_ptr->scal_s_height == NULL)
    {
       png_free (png_ptr, info_ptr->scal_s_width);
+      info_ptr->scal_s_width = NULL;
       png_warning(png_ptr,
-       "Memory allocation failed while processing sCAL.");
+         "Memory allocation failed while processing sCAL.");
+      return;
    }
    png_memcpy(info_ptr->scal_s_height, sheight, (png_size_t)length);
-
    info_ptr->valid |= PNG_INFO_sCAL;
 #ifdef PNG_FREE_ME_SUPPORTED
    info_ptr->free_me |= PNG_FREE_SCAL;
@@ -522,12 +427,13 @@
 #endif
 #endif
 
-#if defined(PNG_pHYs_SUPPORTED)
+#ifdef PNG_pHYs_SUPPORTED
 void PNGAPI
 png_set_pHYs(png_structp png_ptr, png_infop info_ptr,
    png_uint_32 res_x, png_uint_32 res_y, int unit_type)
 {
-   png_debug1(1, "in %s storage function\n", "pHYs");
+   png_debug1(1, "in %s storage function", "pHYs");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
@@ -543,23 +449,28 @@
    png_colorp palette, int num_palette)
 {
 
-   png_debug1(1, "in %s storage function\n", "PLTE");
+   png_uint_32 max_palette_length;
+
+   png_debug1(1, "in %s storage function", "PLTE");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
-   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)
-     {
-       if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+   max_palette_length = (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?
+      (1 << info_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;
+
+   if (num_palette < 0 || num_palette > (int) max_palette_length)
+   {
+      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
          png_error(png_ptr, "Invalid palette length");
-       else
-       {
+      else
+      {
          png_warning(png_ptr, "Invalid palette length");
          return;
-       }
-     }
+      }
+   }
 
-   /*
-    * It may not actually be necessary to set png_ptr->palette here;
+   /* It may not actually be necessary to set png_ptr->palette here;
     * we do it for backward compatibility with the way the png_handle_tRNS
     * function used to do the allocation.
     */
@@ -568,13 +479,12 @@
 #endif
 
    /* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead
-      of num_palette entries,
-      in case of an invalid PNG file that has too-large sample values. */
-   png_ptr->palette = (png_colorp)png_malloc(png_ptr,
+    * of num_palette entries, in case of an invalid PNG file or incorrect
+    * call to png_set_PLTE() with too-large sample values.
+    */
+   png_ptr->palette = (png_colorp)png_calloc(png_ptr,
       PNG_MAX_PALETTE_LENGTH * png_sizeof(png_color));
-   png_memset(png_ptr->palette, 0, PNG_MAX_PALETTE_LENGTH *
-      png_sizeof(png_color));
-   png_memcpy(png_ptr->palette, palette, num_palette * png_sizeof (png_color));
+   png_memcpy(png_ptr->palette, palette, num_palette * png_sizeof(png_color));
    info_ptr->palette = png_ptr->palette;
    info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;
 
@@ -587,25 +497,27 @@
    info_ptr->valid |= PNG_INFO_PLTE;
 }
 
-#if defined(PNG_sBIT_SUPPORTED)
+#ifdef PNG_sBIT_SUPPORTED
 void PNGAPI
 png_set_sBIT(png_structp png_ptr, png_infop info_ptr,
    png_color_8p sig_bit)
 {
-   png_debug1(1, "in %s storage function\n", "sBIT");
+   png_debug1(1, "in %s storage function", "sBIT");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
-   png_memcpy(&(info_ptr->sig_bit), sig_bit, png_sizeof (png_color_8));
+   png_memcpy(&(info_ptr->sig_bit), sig_bit, png_sizeof(png_color_8));
    info_ptr->valid |= PNG_INFO_sBIT;
 }
 #endif
 
-#if defined(PNG_sRGB_SUPPORTED)
+#ifdef PNG_sRGB_SUPPORTED
 void PNGAPI
 png_set_sRGB(png_structp png_ptr, png_infop info_ptr, int intent)
 {
-   png_debug1(1, "in %s storage function\n", "sRGB");
+   png_debug1(1, "in %s storage function", "sRGB");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
@@ -617,7 +529,7 @@
 png_set_sRGB_gAMA_and_cHRM(png_structp png_ptr, png_infop info_ptr,
    int intent)
 {
-#if defined(PNG_gAMA_SUPPORTED)
+#ifdef PNG_gAMA_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
    float file_gamma;
 #endif
@@ -625,7 +537,7 @@
    png_fixed_point int_file_gamma;
 #endif
 #endif
-#if defined(PNG_cHRM_SUPPORTED)
+#ifdef PNG_cHRM_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
    float white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y;
 #endif
@@ -634,13 +546,14 @@
       int_green_y, int_blue_x, int_blue_y;
 #endif
 #endif
-   png_debug1(1, "in %s storage function\n", "sRGB_gAMA_and_cHRM");
+   png_debug1(1, "in %s storage function", "sRGB_gAMA_and_cHRM");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
    png_set_sRGB(png_ptr, info_ptr, intent);
 
-#if defined(PNG_gAMA_SUPPORTED)
+#ifdef PNG_gAMA_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
    file_gamma = (float).45455;
    png_set_gAMA(png_ptr, info_ptr, file_gamma);
@@ -651,8 +564,8 @@
 #endif
 #endif
 
-#if defined(PNG_cHRM_SUPPORTED)
-#ifdef PNG_FIXED_POINT_SUPPORTED
+#ifdef PNG_cHRM_SUPPORTED
+#  ifdef PNG_FIXED_POINT_SUPPORTED
    int_white_x = 31270L;
    int_white_y = 32900L;
    int_red_x   = 64000L;
@@ -661,12 +574,12 @@
    int_green_y = 60000L;
    int_blue_x  = 15000L;
    int_blue_y  =  6000L;
-
    png_set_cHRM_fixed(png_ptr, info_ptr,
-      int_white_x, int_white_y, int_red_x, int_red_y, int_green_x, int_green_y,
-      int_blue_x, int_blue_y);
-#endif
-#ifdef PNG_FLOATING_POINT_SUPPORTED
+       int_white_x, int_white_y, int_red_x, int_red_y, int_green_x,
+       int_green_y, int_blue_x, int_blue_y);
+#  endif
+
+#  ifdef PNG_FLOATING_POINT_SUPPORTED
    white_x = (float).3127;
    white_y = (float).3290;
    red_x   = (float).64;
@@ -675,16 +588,15 @@
    green_y = (float).60;
    blue_x  = (float).15;
    blue_y  = (float).06;
-
    png_set_cHRM(png_ptr, info_ptr,
-      white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
-#endif
-#endif
+       white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
+#  endif
+#endif /* cHRM */
 }
-#endif
+#endif /* sRGB */
 
 
-#if defined(PNG_iCCP_SUPPORTED)
+#ifdef PNG_iCCP_SUPPORTED
 void PNGAPI
 png_set_iCCP(png_structp png_ptr, png_infop info_ptr,
              png_charp name, int compression_type,
@@ -694,7 +606,8 @@
    png_charp new_iccp_profile;
    png_uint_32 length;
 
-   png_debug1(1, "in %s storage function\n", "iCCP");
+   png_debug1(1, "in %s storage function", "iCCP");
+
    if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)
       return;
 
@@ -702,7 +615,7 @@
    new_iccp_name = (png_charp)png_malloc_warn(png_ptr, length);
    if (new_iccp_name == NULL)
    {
-      png_warning(png_ptr, "Insufficient memory to process iCCP chunk.");
+        png_warning(png_ptr, "Insufficient memory to process iCCP chunk.");
       return;
    }
    png_memcpy(new_iccp_name, name, length);
@@ -710,7 +623,8 @@
    if (new_iccp_profile == NULL)
    {
       png_free (png_ptr, new_iccp_name);
-      png_warning(png_ptr, "Insufficient memory to process iCCP profile.");
+      png_warning(png_ptr,
+          "Insufficient memory to process iCCP profile.");
       return;
    }
    png_memcpy(new_iccp_profile, profile, (png_size_t)proflen);
@@ -721,7 +635,8 @@
    info_ptr->iccp_name = new_iccp_name;
    info_ptr->iccp_profile = new_iccp_profile;
    /* Compression is always zero but is here so the API and info structure
-    * does not have to change if we introduce multiple compression types */
+    * does not have to change if we introduce multiple compression types
+    */
    info_ptr->iccp_compression = (png_byte)compression_type;
 #ifdef PNG_FREE_ME_SUPPORTED
    info_ptr->free_me |= PNG_FREE_ICCP;
@@ -730,24 +645,25 @@
 }
 #endif
 
-#if defined(PNG_TEXT_SUPPORTED)
+#ifdef PNG_TEXT_SUPPORTED
 void PNGAPI
 png_set_text(png_structp png_ptr, png_infop info_ptr, png_textp text_ptr,
-   int num_text)
+             int num_text)
 {
    int ret;
-   ret=png_set_text_2(png_ptr, info_ptr, text_ptr, num_text);
+   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, num_text);
    if (ret)
-     png_error(png_ptr, "Insufficient memory to store text");
+      png_error(png_ptr, "Insufficient memory to store text");
 }
 
 int /* PRIVATE */
 png_set_text_2(png_structp png_ptr, png_infop info_ptr, png_textp text_ptr,
-   int num_text)
+               int num_text)
 {
    int i;
 
-   png_debug1(1, "in %s storage function\n", (png_ptr->chunk_name[0] == '\0' ?
+   png_debug1(1, "in %s storage function", ((png_ptr == NULL ||
+      png_ptr->chunk_name[0] == '\0') ?
       "text" : (png_const_charp)png_ptr->chunk_name));
 
    if (png_ptr == NULL || info_ptr == NULL || num_text == 0)
@@ -758,22 +674,26 @@
     */
    if (info_ptr->num_text + num_text > info_ptr->max_text)
    {
+      int old_max_text = info_ptr->max_text;
+      int old_num_text = info_ptr->num_text;
+
       if (info_ptr->text != NULL)
       {
          png_textp old_text;
-         int old_max;
 
-         old_max = info_ptr->max_text;
          info_ptr->max_text = info_ptr->num_text + num_text + 8;
          old_text = info_ptr->text;
+
          info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
-            (png_uint_32)(info_ptr->max_text * png_sizeof (png_text)));
+            (png_uint_32)(info_ptr->max_text * png_sizeof(png_text)));
          if (info_ptr->text == NULL)
-           {
-             png_free(png_ptr, old_text);
-             return(1);
-           }
-         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max *
+         {
+            /* Restore to previous condition */
+            info_ptr->max_text = old_max_text;
+            info_ptr->text = old_text;
+            return(1);
+         }
+         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max_text *
             png_sizeof(png_text)));
          png_free(png_ptr, old_text);
       }
@@ -782,20 +702,26 @@
          info_ptr->max_text = num_text + 8;
          info_ptr->num_text = 0;
          info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
-            (png_uint_32)(info_ptr->max_text * png_sizeof (png_text)));
+            (png_uint_32)(info_ptr->max_text * png_sizeof(png_text)));
          if (info_ptr->text == NULL)
-           return(1);
+         {
+            /* Restore to previous condition */
+            info_ptr->num_text = old_num_text;
+            info_ptr->max_text = old_max_text;
+            return(1);
+         }
 #ifdef PNG_FREE_ME_SUPPORTED
          info_ptr->free_me |= PNG_FREE_TEXT;
 #endif
       }
-      png_debug1(3, "allocated %d entries for info_ptr->text\n",
+      png_debug1(3, "allocated %d entries for info_ptr->text",
          info_ptr->max_text);
    }
+
    for (i = 0; i < num_text; i++)
    {
-      png_size_t text_length,key_len;
-      png_size_t lang_len,lang_key_len;
+      png_size_t text_length, key_len;
+      png_size_t lang_len, lang_key_len;
       png_textp textp = &(info_ptr->text[info_ptr->num_text]);
 
       if (text_ptr[i].key == NULL)
@@ -803,28 +729,30 @@
 
       key_len = png_strlen(text_ptr[i].key);
 
-      if(text_ptr[i].compression <= 0)
+      if (text_ptr[i].compression <= 0)
       {
-        lang_len = 0;
-        lang_key_len = 0;
+         lang_len = 0;
+         lang_key_len = 0;
       }
+
       else
 #ifdef PNG_iTXt_SUPPORTED
       {
-        /* set iTXt data */
-        if (text_ptr[i].lang != NULL)
-          lang_len = png_strlen(text_ptr[i].lang);
-        else
-          lang_len = 0;
-        if (text_ptr[i].lang_key != NULL)
-          lang_key_len = png_strlen(text_ptr[i].lang_key);
-        else
-          lang_key_len = 0;
+         /* Set iTXt data */
+
+         if (text_ptr[i].lang != NULL)
+            lang_len = png_strlen(text_ptr[i].lang);
+         else
+            lang_len = 0;
+         if (text_ptr[i].lang_key != NULL)
+            lang_key_len = png_strlen(text_ptr[i].lang_key);
+         else
+            lang_key_len = 0;
       }
-#else
+#else /* PNG_iTXt_SUPPORTED */
       {
-        png_warning(png_ptr, "iTXt chunk not supported.");
-        continue;
+         png_warning(png_ptr, "iTXt chunk not supported.");
+         continue;
       }
 #endif
 
@@ -832,12 +760,13 @@
       {
          text_length = 0;
 #ifdef PNG_iTXt_SUPPORTED
-         if(text_ptr[i].compression > 0)
+         if (text_ptr[i].compression > 0)
             textp->compression = PNG_ITXT_COMPRESSION_NONE;
          else
 #endif
             textp->compression = PNG_TEXT_COMPRESSION_NONE;
       }
+
       else
       {
          text_length = png_strlen(text_ptr[i].text);
@@ -845,26 +774,27 @@
       }
 
       textp->key = (png_charp)png_malloc_warn(png_ptr,
-         (png_uint_32)(key_len + text_length + lang_len + lang_key_len + 4));
+         (png_uint_32)
+         (key_len + text_length + lang_len + lang_key_len + 4));
       if (textp->key == NULL)
-        return(1);
-      png_debug2(2, "Allocated %lu bytes at %x in png_set_text\n",
-         (png_uint_32)(key_len + lang_len + lang_key_len + text_length + 4),
-         (int)textp->key);
-
-      png_memcpy(textp->key, text_ptr[i].key,
-         (png_size_t)(key_len));
-      *(textp->key+key_len) = '\0';
+         return(1);
+      png_debug2(2, "Allocated %lu bytes at %p in png_set_text",
+                 (png_uint_32)
+                 (key_len + lang_len + lang_key_len + text_length + 4),
+                 textp->key);
+
+      png_memcpy(textp->key, text_ptr[i].key,(png_size_t)(key_len));
+      *(textp->key + key_len) = '\0';
 #ifdef PNG_iTXt_SUPPORTED
       if (text_ptr[i].compression > 0)
       {
-         textp->lang=textp->key + key_len + 1;
+         textp->lang = textp->key + key_len + 1;
          png_memcpy(textp->lang, text_ptr[i].lang, lang_len);
-         *(textp->lang+lang_len) = '\0';
-         textp->lang_key=textp->lang + lang_len + 1;
+         *(textp->lang + lang_len) = '\0';
+         textp->lang_key = textp->lang + lang_len + 1;
          png_memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);
-         *(textp->lang_key+lang_key_len) = '\0';
-         textp->text=textp->lang_key + lang_key_len + 1;
+         *(textp->lang_key + lang_key_len) = '\0';
+         textp->text = textp->lang_key + lang_key_len + 1;
       }
       else
 #endif
@@ -873,21 +803,22 @@
          textp->lang=NULL;
          textp->lang_key=NULL;
 #endif
-         textp->text=textp->key + key_len + 1;
+         textp->text = textp->key + key_len + 1;
       }
-      if(text_length)
+      if (text_length)
          png_memcpy(textp->text, text_ptr[i].text,
             (png_size_t)(text_length));
-      *(textp->text+text_length) = '\0';
+      *(textp->text + text_length) = '\0';
 
 #ifdef PNG_iTXt_SUPPORTED
-      if(textp->compression > 0)
+      if (textp->compression > 0)
       {
          textp->text_length = 0;
          textp->itxt_length = text_length;
       }
       else
 #endif
+
       {
          textp->text_length = text_length;
 #ifdef PNG_iTXt_SUPPORTED
@@ -895,197 +826,239 @@
 #endif
       }
       info_ptr->num_text++;
-      png_debug1(3, "transferred text chunk %d\n", info_ptr->num_text);
+      png_debug1(3, "transferred text chunk %d", info_ptr->num_text);
    }
    return(0);
 }
 #endif
 
-#if defined(PNG_tIME_SUPPORTED)
+#ifdef PNG_tIME_SUPPORTED
 void PNGAPI
 png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_timep mod_time)
 {
-   png_debug1(1, "in %s storage function\n", "tIME");
+   png_debug1(1, "in %s storage function", "tIME");
+
    if (png_ptr == NULL || info_ptr == NULL ||
        (png_ptr->mode & PNG_WROTE_tIME))
       return;
 
-   png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof (png_time));
+   if (mod_time->month == 0   || mod_time->month > 12  ||
+       mod_time->day   == 0   || mod_time->day   > 31  ||
+       mod_time->hour  > 23   || mod_time->minute > 59 ||
+       mod_time->second > 60)
+   {
+      png_warning(png_ptr, "Ignoring invalid time value");
+      return;
+   }
+
+   png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));
    info_ptr->valid |= PNG_INFO_tIME;
 }
 #endif
 
-#if defined(PNG_tRNS_SUPPORTED)
+#ifdef PNG_tRNS_SUPPORTED
 void PNGAPI
 png_set_tRNS(png_structp png_ptr, png_infop info_ptr,
    png_bytep trans, int num_trans, png_color_16p trans_values)
 {
-   png_debug1(1, "in %s storage function\n", "tRNS");
+   png_debug1(1, "in %s storage function", "tRNS");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
+   if (num_trans < 0 || num_trans > PNG_MAX_PALETTE_LENGTH)
+      {
+        png_warning(png_ptr, "Ignoring invalid num_trans value");
+        return;
+      }
+
    if (trans != NULL)
    {
-       /*
-        * It may not actually be necessary to set png_ptr->trans here;
+       /* It may not actually be necessary to set png_ptr->trans here;
         * we do it for backward compatibility with the way the png_handle_tRNS
         * function used to do the allocation.
         */
+
 #ifdef PNG_FREE_ME_SUPPORTED
        png_free_data(png_ptr, info_ptr, PNG_FREE_TRNS, 0);
 #endif
+
        /* Changed from num_trans to PNG_MAX_PALETTE_LENGTH in version 1.2.1 */
        png_ptr->trans = info_ptr->trans = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)PNG_MAX_PALETTE_LENGTH);
-       if (num_trans <= PNG_MAX_PALETTE_LENGTH)
-         png_memcpy(info_ptr->trans, trans, (png_size_t)num_trans);
-#ifdef PNG_FREE_ME_SUPPORTED
-       info_ptr->free_me |= PNG_FREE_TRNS;
-#else
-       png_ptr->flags |= PNG_FLAG_FREE_TRNS;
-#endif
+       if (num_trans > 0 && num_trans <= PNG_MAX_PALETTE_LENGTH)
+          png_memcpy(info_ptr->trans, trans, (png_size_t)num_trans);
    }
 
    if (trans_values != NULL)
    {
+      int sample_max = (1 << info_ptr->bit_depth);
+      if ((info_ptr->color_type == PNG_COLOR_TYPE_GRAY &&
+          (int)trans_values->gray > sample_max) ||
+          (info_ptr->color_type == PNG_COLOR_TYPE_RGB &&
+          ((int)trans_values->red > sample_max ||
+          (int)trans_values->green > sample_max ||
+          (int)trans_values->blue > sample_max)))
+         png_warning(png_ptr,
+            "tRNS chunk has out-of-range samples for bit_depth");
       png_memcpy(&(info_ptr->trans_values), trans_values,
          png_sizeof(png_color_16));
       if (num_trans == 0)
-        num_trans = 1;
+         num_trans = 1;
    }
+
    info_ptr->num_trans = (png_uint_16)num_trans;
-   info_ptr->valid |= PNG_INFO_tRNS;
+   if (num_trans != 0)
+   {
+      info_ptr->valid |= PNG_INFO_tRNS;
+#ifdef PNG_FREE_ME_SUPPORTED
+      info_ptr->free_me |= PNG_FREE_TRNS;
+#else
+      png_ptr->flags |= PNG_FLAG_FREE_TRNS;
+#endif
+   }
 }
 #endif
 
-#if defined(PNG_sPLT_SUPPORTED)
+#ifdef PNG_sPLT_SUPPORTED
 void PNGAPI
 png_set_sPLT(png_structp png_ptr,
              png_infop info_ptr, png_sPLT_tp entries, int nentries)
+/*
+ *  entries        - array of png_sPLT_t structures
+ *                   to be added to the list of palettes
+ *                   in the info structure.
+ *  nentries       - number of palette structures to be
+ *                   added.
+ */
 {
-    png_sPLT_tp np;
-    int i;
+   png_sPLT_tp np;
+   int i;
 
-    if (png_ptr == NULL || info_ptr == NULL)
-       return;
+   if (png_ptr == NULL || info_ptr == NULL)
+      return;
 
-    np = (png_sPLT_tp)png_malloc_warn(png_ptr,
-        (info_ptr->splt_palettes_num + nentries) * png_sizeof(png_sPLT_t));
-    if (np == NULL)
-    {
+   np = (png_sPLT_tp)png_malloc_warn(png_ptr,
+       (info_ptr->splt_palettes_num + nentries) *
+        (png_uint_32)png_sizeof(png_sPLT_t));
+   if (np == NULL)
+   {
       png_warning(png_ptr, "No memory for sPLT palettes.");
       return;
-    }
+   }
+
+   png_memcpy(np, info_ptr->splt_palettes,
+       info_ptr->splt_palettes_num * png_sizeof(png_sPLT_t));
+   png_free(png_ptr, info_ptr->splt_palettes);
+   info_ptr->splt_palettes=NULL;
 
-    png_memcpy(np, info_ptr->splt_palettes,
-           info_ptr->splt_palettes_num * png_sizeof(png_sPLT_t));
-    png_free(png_ptr, info_ptr->splt_palettes);
-    info_ptr->splt_palettes=NULL;
-
-    for (i = 0; i < nentries; i++)
-    {
-        png_sPLT_tp to = np + info_ptr->splt_palettes_num + i;
-        png_sPLT_tp from = entries + i;
-        png_uint_32 length;
-
-        length = png_strlen(from->name) + 1;
-        to->name = (png_charp)png_malloc_warn(png_ptr, length);
-        if (to->name == NULL)
-        {
-           png_warning(png_ptr,
-             "Out of memory while processing sPLT chunk");
-        }
-        /* TODO: use png_malloc_warn */
-        png_memcpy(to->name, from->name, length);
-        to->entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,
-            from->nentries * png_sizeof(png_sPLT_entry));
-        /* TODO: use png_malloc_warn */
-        png_memcpy(to->entries, from->entries,
-            from->nentries * png_sizeof(png_sPLT_entry));
-        if (to->entries == NULL)
-        {
-           png_warning(png_ptr,
-             "Out of memory while processing sPLT chunk");
-           png_free(png_ptr,to->name);
-           to->name = NULL;
-        }
-        to->nentries = from->nentries;
-        to->depth = from->depth;
-    }
-
-    info_ptr->splt_palettes = np;
-    info_ptr->splt_palettes_num += nentries;
-    info_ptr->valid |= PNG_INFO_sPLT;
+   for (i = 0; i < nentries; i++)
+   {
+      png_sPLT_tp to = np + info_ptr->splt_palettes_num + i;
+      png_sPLT_tp from = entries + i;
+      png_uint_32 length;
+
+      length = png_strlen(from->name) + 1;
+      to->name = (png_charp)png_malloc_warn(png_ptr, length);
+      if (to->name == NULL)
+      {
+         png_warning(png_ptr,
+           "Out of memory while processing sPLT chunk");
+         continue;
+      }
+      png_memcpy(to->name, from->name, length);
+      to->entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,
+          (png_uint_32)(from->nentries * png_sizeof(png_sPLT_entry)));
+      if (to->entries == NULL)
+      {
+         png_warning(png_ptr,
+           "Out of memory while processing sPLT chunk");
+         png_free(png_ptr, to->name);
+         to->name = NULL;
+         continue;
+      }
+      png_memcpy(to->entries, from->entries,
+          from->nentries * png_sizeof(png_sPLT_entry));
+      to->nentries = from->nentries;
+      to->depth = from->depth;
+   }
+
+   info_ptr->splt_palettes = np;
+   info_ptr->splt_palettes_num += nentries;
+   info_ptr->valid |= PNG_INFO_sPLT;
 #ifdef PNG_FREE_ME_SUPPORTED
-    info_ptr->free_me |= PNG_FREE_SPLT;
+   info_ptr->free_me |= PNG_FREE_SPLT;
 #endif
 }
 #endif /* PNG_sPLT_SUPPORTED */
 
-#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
+#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
 void PNGAPI
 png_set_unknown_chunks(png_structp png_ptr,
    png_infop info_ptr, png_unknown_chunkp unknowns, int num_unknowns)
 {
-    png_unknown_chunkp np;
-    int i;
+   png_unknown_chunkp np;
+   int i;
 
-    if (png_ptr == NULL || info_ptr == NULL || num_unknowns == 0)
-        return;
+   if (png_ptr == NULL || info_ptr == NULL || num_unknowns == 0)
+      return;
 
-    np = (png_unknown_chunkp)png_malloc_warn(png_ptr,
-        (info_ptr->unknown_chunks_num + num_unknowns) *
-        png_sizeof(png_unknown_chunk));
-    if (np == NULL)
-    {
-       png_warning(png_ptr,
+   np = (png_unknown_chunkp)png_malloc_warn(png_ptr,
+       (png_uint_32)((info_ptr->unknown_chunks_num + num_unknowns) *
+       png_sizeof(png_unknown_chunk)));
+   if (np == NULL)
+   {
+      png_warning(png_ptr,
           "Out of memory while processing unknown chunk.");
-       return;
-    }
+      return;
+   }
 
-    png_memcpy(np, info_ptr->unknown_chunks,
-           info_ptr->unknown_chunks_num * png_sizeof(png_unknown_chunk));
-    png_free(png_ptr, info_ptr->unknown_chunks);
-    info_ptr->unknown_chunks=NULL;
-
-    for (i = 0; i < num_unknowns; i++)
-    {
-        png_unknown_chunkp to = np + info_ptr->unknown_chunks_num + i;
-        png_unknown_chunkp from = unknowns + i;
-
-        png_memcpy((png_charp)to->name, 
-                   (png_charp)from->name, 
-                   png_sizeof(from->name));
-        to->name[png_sizeof(to->name)-1] = '\0';
-
-        to->data = (png_bytep)png_malloc_warn(png_ptr, from->size);
-        if (to->data == NULL)
-        {
-           png_warning(png_ptr,
-              "Out of memory while processing unknown chunk.");
-        }
-        else
-        {
-           png_memcpy(to->data, from->data, from->size);
-           to->size = from->size;
-
-           /* note our location in the read or write sequence */
-           to->location = (png_byte)(png_ptr->mode & 0xff);
-        }
-    }
+   png_memcpy(np, info_ptr->unknown_chunks,
+       info_ptr->unknown_chunks_num * png_sizeof(png_unknown_chunk));
+   png_free(png_ptr, info_ptr->unknown_chunks);
+   info_ptr->unknown_chunks = NULL;
 
-    info_ptr->unknown_chunks = np;
-    info_ptr->unknown_chunks_num += num_unknowns;
+   for (i = 0; i < num_unknowns; i++)
+   {
+      png_unknown_chunkp to = np + info_ptr->unknown_chunks_num + i;
+      png_unknown_chunkp from = unknowns + i;
+
+      png_memcpy((png_charp)to->name, (png_charp)from->name,
+          png_sizeof(from->name));
+      to->name[png_sizeof(to->name)-1] = '\0';
+      to->size = from->size;
+      /* Note our location in the read or write sequence */
+      to->location = (png_byte)(png_ptr->mode & 0xff);
+
+      if (from->size == 0)
+         to->data=NULL;
+      else
+      {
+         to->data = (png_bytep)png_malloc_warn(png_ptr,
+           (png_uint_32)from->size);
+         if (to->data == NULL)
+         {
+            png_warning(png_ptr,
+             "Out of memory while processing unknown chunk.");
+            to->size = 0;
+         }
+         else
+            png_memcpy(to->data, from->data, from->size);
+      }
+   }
+
+   info_ptr->unknown_chunks = np;
+   info_ptr->unknown_chunks_num += num_unknowns;
 #ifdef PNG_FREE_ME_SUPPORTED
-    info_ptr->free_me |= PNG_FREE_UNKN;
+   info_ptr->free_me |= PNG_FREE_UNKN;
 #endif
 }
 void PNGAPI
 png_set_unknown_chunk_location(png_structp png_ptr, png_infop info_ptr,
    int chunk, int location)
 {
-   if(png_ptr != NULL && info_ptr != NULL && chunk >= 0 && chunk <
-         (int)info_ptr->unknown_chunks_num)
+   if (png_ptr != NULL && info_ptr != NULL && chunk >= 0 && chunk <
+       (int)info_ptr->unknown_chunks_num)
       info_ptr->unknown_chunks[chunk].location = (png_byte)location;
 }
 #endif
@@ -1098,7 +1071,9 @@
 {
    /* This function is deprecated in favor of png_permit_mng_features()
       and will be removed from libpng-1.3.0 */
-   png_debug(1, "in png_permit_empty_plte, DEPRECATED.\n");
+
+   png_debug(1, "in png_permit_empty_plte, DEPRECATED.");
+
    if (png_ptr == NULL)
       return;
    png_ptr->mng_features_permitted = (png_byte)
@@ -1108,11 +1083,12 @@
 #endif
 #endif
 
-#if defined(PNG_MNG_FEATURES_SUPPORTED)
+#ifdef PNG_MNG_FEATURES_SUPPORTED
 png_uint_32 PNGAPI
 png_permit_mng_features (png_structp png_ptr, png_uint_32 mng_features)
 {
-   png_debug(1, "in png_permit_mng_features\n");
+   png_debug(1, "in png_permit_mng_features");
+
    if (png_ptr == NULL)
       return (png_uint_32)0;
    png_ptr->mng_features_permitted =
@@ -1121,96 +1097,97 @@
 }
 #endif
 
-#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
+#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
 void PNGAPI
 png_set_keep_unknown_chunks(png_structp png_ptr, int keep, png_bytep
    chunk_list, int num_chunks)
 {
-    png_bytep new_list, p;
-    int i, old_num_chunks;
-    if (png_ptr == NULL)
-       return;
-    if (num_chunks == 0)
-    {
-      if(keep == PNG_HANDLE_CHUNK_ALWAYS || keep == PNG_HANDLE_CHUNK_IF_SAFE)
-        png_ptr->flags |= PNG_FLAG_KEEP_UNKNOWN_CHUNKS;
+   png_bytep new_list, p;
+   int i, old_num_chunks;
+   if (png_ptr == NULL)
+      return;
+   if (num_chunks == 0)
+   {
+      if (keep == PNG_HANDLE_CHUNK_ALWAYS || keep == PNG_HANDLE_CHUNK_IF_SAFE)
+         png_ptr->flags |= PNG_FLAG_KEEP_UNKNOWN_CHUNKS;
       else
-        png_ptr->flags &= ~PNG_FLAG_KEEP_UNKNOWN_CHUNKS;
+         png_ptr->flags &= ~PNG_FLAG_KEEP_UNKNOWN_CHUNKS;
 
-      if(keep == PNG_HANDLE_CHUNK_ALWAYS)
-        png_ptr->flags |= PNG_FLAG_KEEP_UNSAFE_CHUNKS;
+      if (keep == PNG_HANDLE_CHUNK_ALWAYS)
+         png_ptr->flags |= PNG_FLAG_KEEP_UNSAFE_CHUNKS;
       else
-        png_ptr->flags &= ~PNG_FLAG_KEEP_UNSAFE_CHUNKS;
+         png_ptr->flags &= ~PNG_FLAG_KEEP_UNSAFE_CHUNKS;
       return;
-    }
-    if (chunk_list == NULL)
+   }
+   if (chunk_list == NULL)
       return;
-    old_num_chunks=png_ptr->num_chunk_list;
-    new_list=(png_bytep)png_malloc(png_ptr,
-       (png_uint_32)(5*(num_chunks+old_num_chunks)));
-    if(png_ptr->chunk_list != NULL)
-    {
-       png_memcpy(new_list, png_ptr->chunk_list,
+   old_num_chunks = png_ptr->num_chunk_list;
+   new_list=(png_bytep)png_malloc(png_ptr,
+      (png_uint_32)
+       (5*(num_chunks + old_num_chunks)));
+   if (png_ptr->chunk_list != NULL)
+   {
+      png_memcpy(new_list, png_ptr->chunk_list,
           (png_size_t)(5*old_num_chunks));
-       png_free(png_ptr, png_ptr->chunk_list);
-       png_ptr->chunk_list=NULL;
-    }
-    png_memcpy(new_list+5*old_num_chunks, chunk_list,
+      png_free(png_ptr, png_ptr->chunk_list);
+      png_ptr->chunk_list=NULL;
+   }
+   png_memcpy(new_list + 5*old_num_chunks, chunk_list,
        (png_size_t)(5*num_chunks));
-    for (p=new_list+5*old_num_chunks+4, i=0; i<num_chunks; i++, p+=5)
-       *p=(png_byte)keep;
-    png_ptr->num_chunk_list=old_num_chunks+num_chunks;
-    png_ptr->chunk_list=new_list;
+   for (p = new_list + 5*old_num_chunks + 4, i = 0; i<num_chunks; i++, p += 5)
+      *p=(png_byte)keep;
+   png_ptr->num_chunk_list = old_num_chunks + num_chunks;
+   png_ptr->chunk_list = new_list;
 #ifdef PNG_FREE_ME_SUPPORTED
-    png_ptr->free_me |= PNG_FREE_LIST;
+   png_ptr->free_me |= PNG_FREE_LIST;
 #endif
 }
 #endif
 
-#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
+#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
 void PNGAPI
 png_set_read_user_chunk_fn(png_structp png_ptr, png_voidp user_chunk_ptr,
    png_user_chunk_ptr read_user_chunk_fn)
 {
-   png_debug(1, "in png_set_read_user_chunk_fn\n");
+   png_debug(1, "in png_set_read_user_chunk_fn");
+
    if (png_ptr == NULL)
       return;
+
    png_ptr->read_user_chunk_fn = read_user_chunk_fn;
    png_ptr->user_chunk_ptr = user_chunk_ptr;
 }
 #endif
 
-#if defined(PNG_INFO_IMAGE_SUPPORTED)
+#ifdef PNG_INFO_IMAGE_SUPPORTED
 void PNGAPI
 png_set_rows(png_structp png_ptr, png_infop info_ptr, png_bytepp row_pointers)
 {
-   png_debug1(1, "in %s storage function\n", "rows");
+   png_debug1(1, "in %s storage function", "rows");
 
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
-   if(info_ptr->row_pointers && (info_ptr->row_pointers != row_pointers))
+   if (info_ptr->row_pointers && (info_ptr->row_pointers != row_pointers))
       png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);
    info_ptr->row_pointers = row_pointers;
-   if(row_pointers)
+   if (row_pointers)
       info_ptr->valid |= PNG_INFO_IDAT;
 }
 #endif
 
-#ifdef PNG_WRITE_SUPPORTED
 void PNGAPI
-png_set_compression_buffer_size(png_structp png_ptr, png_uint_32 size)
+png_set_compression_buffer_size(png_structp png_ptr,
+    png_uint_32 size)
 {
     if (png_ptr == NULL)
        return;
-    if(png_ptr->zbuf)
-       png_free(png_ptr, png_ptr->zbuf);
+    png_free(png_ptr, png_ptr->zbuf);
     png_ptr->zbuf_size = (png_size_t)size;
     png_ptr->zbuf = (png_bytep)png_malloc(png_ptr, size);
     png_ptr->zstream.next_out = png_ptr->zbuf;
     png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
 }
-#endif
 
 void PNGAPI
 png_set_invalid(png_structp png_ptr, png_infop info_ptr, int mask)
@@ -1222,16 +1199,17 @@
 
 #ifndef PNG_1_0_X
 #ifdef PNG_ASSEMBLER_CODE_SUPPORTED
-/* function was added to libpng 1.2.0 and should always exist by default */
+/* Function was added to libpng 1.2.0 and should always exist by default */
 void PNGAPI
 png_set_asm_flags (png_structp png_ptr, png_uint_32 asm_flags)
 {
 /* Obsolete as of libpng-1.2.20 and will be removed from libpng-1.4.0 */
     if (png_ptr != NULL)
     png_ptr->asm_flags = 0;
+    PNG_UNUSED(asm_flags) /* Quiet the compiler */
 }
 
-/* this function was added to libpng 1.2.0 */
+/* This function was added to libpng 1.2.0 */
 void PNGAPI
 png_set_mmx_thresholds (png_structp png_ptr,
                         png_byte mmx_bitdepth_threshold,
@@ -1240,24 +1218,41 @@
 /* Obsolete as of libpng-1.2.20 and will be removed from libpng-1.4.0 */
     if (png_ptr == NULL)
        return;
+    /* Quiet the compiler */
+    PNG_UNUSED(mmx_bitdepth_threshold)
+    PNG_UNUSED(mmx_rowbytes_threshold)
 }
 #endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */
 
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
-/* this function was added to libpng 1.2.6 */
+/* This function was added to libpng 1.2.6 */
 void PNGAPI
 png_set_user_limits (png_structp png_ptr, png_uint_32 user_width_max,
     png_uint_32 user_height_max)
 {
-    /* Images with dimensions larger than these limits will be
-     * rejected by png_set_IHDR().  To accept any PNG datastream
-     * regardless of dimensions, set both limits to 0x7ffffffL.
-     */
-    if(png_ptr == NULL) return;
-    png_ptr->user_width_max = user_width_max;
-    png_ptr->user_height_max = user_height_max;
+   /* Images with dimensions larger than these limits will be
+    * rejected by png_set_IHDR().  To accept any PNG datastream
+    * regardless of dimensions, set both limits to 0x7fffffffL.
+    */
+   if (png_ptr == NULL)
+      return;
+   png_ptr->user_width_max = user_width_max;
+   png_ptr->user_height_max = user_height_max;
 }
 #endif /* ?PNG_SET_USER_LIMITS_SUPPORTED */
 
+
+#ifdef PNG_BENIGN_ERRORS_SUPPORTED
+void PNGAPI
+png_set_benign_errors(png_structp png_ptr, int allowed)
+{
+   png_debug(1, "in png_set_benign_errors");
+
+   if (allowed)
+      png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;
+   else
+      png_ptr->flags &= ~PNG_FLAG_BENIGN_ERRORS_WARN;
+}
+#endif /* PNG_BENIGN_ERRORS_SUPPORTED */
 #endif /* ?PNG_1_0_X */
 #endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff -Naur libAfterImage-1.20/libpng/pngtrans.c root/graf2d/asimage/src/libAfterImage/libpng/pngtrans.c
--- libAfterImage-1.20/libpng/pngtrans.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngtrans.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,47 +1,57 @@
 
 /* pngtrans.c - transforms the data in a row (used by both readers and writers)
  *
- * Last changed in libpng 1.2.17 May 15, 2007
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.41 [December 3, 2009]
+ * Copyright (c) 1998-2009 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
  */
 
 #define PNG_INTERNAL
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
-
 #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
+
 #if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
-/* turn on BGR-to-RGB mapping */
+/* Turn on BGR-to-RGB mapping */
 void PNGAPI
 png_set_bgr(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_bgr\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_bgr");
+
+   if (png_ptr == NULL)
+      return;
    png_ptr->transformations |= PNG_BGR;
 }
 #endif
 
 #if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
-/* turn on 16 bit byte swapping */
+/* Turn on 16 bit byte swapping */
 void PNGAPI
 png_set_swap(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_swap\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_swap");
+
+   if (png_ptr == NULL)
+      return;
    if (png_ptr->bit_depth == 16)
       png_ptr->transformations |= PNG_SWAP_BYTES;
 }
 #endif
 
 #if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
-/* turn on pixel packing */
+/* Turn on pixel packing */
 void PNGAPI
 png_set_packing(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_packing\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_packing");
+
+   if (png_ptr == NULL)
+      return;
    if (png_ptr->bit_depth < 8)
    {
       png_ptr->transformations |= PNG_PACK;
@@ -51,12 +61,14 @@
 #endif
 
 #if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
-/* turn on packed pixel swapping */
+/* Turn on packed pixel swapping */
 void PNGAPI
 png_set_packswap(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_packswap\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_packswap");
+
+   if (png_ptr == NULL)
+      return;
    if (png_ptr->bit_depth < 8)
       png_ptr->transformations |= PNG_PACKSWAP;
 }
@@ -66,8 +78,10 @@
 void PNGAPI
 png_set_shift(png_structp png_ptr, png_color_8p true_bits)
 {
-   png_debug(1, "in png_set_shift\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_shift");
+
+   if (png_ptr == NULL)
+      return;
    png_ptr->transformations |= PNG_SHIFT;
    png_ptr->shift = *true_bits;
 }
@@ -78,7 +92,8 @@
 int PNGAPI
 png_set_interlace_handling(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_interlace handling\n");
+   png_debug(1, "in png_set_interlace handling");
+
    if (png_ptr && png_ptr->interlaced)
    {
       png_ptr->transformations |= PNG_INTERLACE;
@@ -98,10 +113,16 @@
 void PNGAPI
 png_set_filler(png_structp png_ptr, png_uint_32 filler, int filler_loc)
 {
-   png_debug(1, "in png_set_filler\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_filler");
+
+   if (png_ptr == NULL)
+      return;
    png_ptr->transformations |= PNG_FILLER;
+#ifdef PNG_LEGACY_SUPPORTED
    png_ptr->filler = (png_byte)filler;
+#else
+   png_ptr->filler = (png_uint_16)filler;
+#endif
    if (filler_loc == PNG_FILLER_AFTER)
       png_ptr->flags |= PNG_FLAG_FILLER_AFTER;
    else
@@ -126,13 +147,15 @@
    }
 }
 
-#if !defined(PNG_1_0_X)
+#ifndef PNG_1_0_X
 /* Added to libpng-1.2.7 */
 void PNGAPI
 png_set_add_alpha(png_structp png_ptr, png_uint_32 filler, int filler_loc)
 {
-   png_debug(1, "in png_set_add_alpha\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_add_alpha");
+
+   if (png_ptr == NULL)
+      return;
    png_set_filler(png_ptr, filler, filler_loc);
    png_ptr->transformations |= PNG_ADD_ALPHA;
 }
@@ -145,8 +168,10 @@
 void PNGAPI
 png_set_swap_alpha(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_swap_alpha\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_swap_alpha");
+
+   if (png_ptr == NULL)
+      return;
    png_ptr->transformations |= PNG_SWAP_ALPHA;
 }
 #endif
@@ -156,8 +181,10 @@
 void PNGAPI
 png_set_invert_alpha(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_invert_alpha\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_invert_alpha");
+
+   if (png_ptr == NULL)
+      return;
    png_ptr->transformations |= PNG_INVERT_ALPHA;
 }
 #endif
@@ -166,20 +193,23 @@
 void PNGAPI
 png_set_invert_mono(png_structp png_ptr)
 {
-   png_debug(1, "in png_set_invert_mono\n");
-   if(png_ptr == NULL) return;
+   png_debug(1, "in png_set_invert_mono");
+
+   if (png_ptr == NULL)
+      return;
    png_ptr->transformations |= PNG_INVERT_MONO;
 }
 
-/* invert monochrome grayscale data */
+/* Invert monochrome grayscale data */
 void /* PRIVATE */
 png_do_invert(png_row_infop row_info, png_bytep row)
 {
-   png_debug(1, "in png_do_invert\n");
+   png_debug(1, "in png_do_invert");
+
   /* This test removed from libpng version 1.0.13 and 1.2.0:
    *   if (row_info->bit_depth == 1 &&
    */
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+#ifdef PNG_USELESS_TESTS_SUPPORTED
    if (row == NULL || row_info == NULL)
      return;
 #endif
@@ -226,13 +256,14 @@
 #endif
 
 #if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
-/* swaps byte order on 16 bit depth images */
+/* Swaps byte order on 16 bit depth images */
 void /* PRIVATE */
 png_do_swap(png_row_infop row_info, png_bytep row)
 {
-   png_debug(1, "in png_do_swap\n");
+   png_debug(1, "in png_do_swap");
+
    if (
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+#ifdef PNG_USELESS_TESTS_SUPPORTED
        row != NULL && row_info != NULL &&
 #endif
        row_info->bit_depth == 16)
@@ -357,13 +388,14 @@
    0x8F, 0x9F, 0xAF, 0xBF, 0xCF, 0xDF, 0xEF, 0xFF
 };
 
-/* swaps pixel packing order within bytes */
+/* Swaps pixel packing order within bytes */
 void /* PRIVATE */
 png_do_packswap(png_row_infop row_info, png_bytep row)
 {
-   png_debug(1, "in png_do_packswap\n");
+   png_debug(1, "in png_do_packswap");
+
    if (
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+#ifdef PNG_USELESS_TESTS_SUPPORTED
        row != NULL && row_info != NULL &&
 #endif
        row_info->bit_depth < 8)
@@ -389,12 +421,13 @@
 
 #if defined(PNG_WRITE_FILLER_SUPPORTED) || \
     defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
-/* remove filler or alpha byte(s) */
+/* Remove filler or alpha byte(s) */
 void /* PRIVATE */
 png_do_strip_filler(png_row_infop row_info, png_bytep row, png_uint_32 flags)
 {
-   png_debug(1, "in png_do_strip_filler\n");
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+   png_debug(1, "in png_do_strip_filler");
+
+#ifdef PNG_USELESS_TESTS_SUPPORTED
    if (row != NULL && row_info != NULL)
 #endif
    {
@@ -404,9 +437,9 @@
       png_uint_32 i;
 
       if ((row_info->color_type == PNG_COLOR_TYPE_RGB ||
-         (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&
-         (flags & PNG_FLAG_STRIP_ALPHA))) &&
-         row_info->channels == 4)
+          (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&
+          (flags & PNG_FLAG_STRIP_ALPHA))) &&
+          row_info->channels == 4)
       {
          if (row_info->bit_depth == 8)
          {
@@ -547,13 +580,14 @@
 #endif
 
 #if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
-/* swaps red and blue bytes within a pixel */
+/* Swaps red and blue bytes within a pixel */
 void /* PRIVATE */
 png_do_bgr(png_row_infop row_info, png_bytep row)
 {
-   png_debug(1, "in png_do_bgr\n");
+   png_debug(1, "in png_do_bgr");
+
    if (
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+#ifdef PNG_USELESS_TESTS_SUPPORTED
        row != NULL && row_info != NULL &&
 #endif
        (row_info->color_type & PNG_COLOR_MASK_COLOR))
@@ -624,20 +658,22 @@
 #endif /* PNG_READ_BGR_SUPPORTED or PNG_WRITE_BGR_SUPPORTED */
 
 #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
-    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED) || \
-    defined(PNG_LEGACY_SUPPORTED)
+    defined(PNG_LEGACY_SUPPORTED) || \
+    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
 void PNGAPI
 png_set_user_transform_info(png_structp png_ptr, png_voidp
    user_transform_ptr, int user_transform_depth, int user_transform_channels)
 {
-   png_debug(1, "in png_set_user_transform_info\n");
-   if(png_ptr == NULL) return;
-#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
+   png_debug(1, "in png_set_user_transform_info");
+
+   if (png_ptr == NULL)
+      return;
+#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
    png_ptr->user_transform_ptr = user_transform_ptr;
    png_ptr->user_transform_depth = (png_byte)user_transform_depth;
    png_ptr->user_transform_channels = (png_byte)user_transform_channels;
 #else
-   if(user_transform_ptr || user_transform_depth || user_transform_channels)
+   if (user_transform_ptr || user_transform_depth || user_transform_channels)
       png_warning(png_ptr,
         "This version of libpng does not support user transform info");
 #endif
@@ -652,8 +688,9 @@
 png_voidp PNGAPI
 png_get_user_transform_ptr(png_structp png_ptr)
 {
-#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
-   if (png_ptr == NULL) return (NULL);
+   if (png_ptr == NULL)
+      return (NULL);
+#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
    return ((png_voidp)png_ptr->user_transform_ptr);
 #else
    return (NULL);
diff -Naur libAfterImage-1.20/libpng/pngwio.c root/graf2d/asimage/src/libAfterImage/libpng/pngwio.c
--- libAfterImage-1.20/libpng/pngwio.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngwio.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,12 +1,15 @@
 
 /* pngwio.c - functions for data output
  *
- * Last changed in libpng 1.2.13 November 13, 2006
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.41 [December 3, 2009]
+ * Copyright (c) 1998-2009 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
  * This file provides a location for all output.  Users who need
  * special handling are expected to write functions that have the same
  * arguments as these and perform similar functions, but that possibly
@@ -16,14 +19,16 @@
  */
 
 #define PNG_INTERNAL
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
 #ifdef PNG_WRITE_SUPPORTED
 
 /* Write the data to whatever output you are using.  The default routine
-   writes to a file pointer.  Note that this routine sometimes gets called
-   with very small lengths, so you should implement some kind of simple
-   buffering if you are using unbuffered writes.  This should never be asked
-   to write more than 64K on a 16 bit machine.  */
+ * writes to a file pointer.  Note that this routine sometimes gets called
+ * with very small lengths, so you should implement some kind of simple
+ * buffering if you are using unbuffered writes.  This should never be asked
+ * to write more than 64K on a 16 bit machine.
+ */
 
 void /* PRIVATE */
 png_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
@@ -34,19 +39,21 @@
       png_error(png_ptr, "Call to NULL write function");
 }
 
-#if !defined(PNG_NO_STDIO)
+#ifdef PNG_STDIO_SUPPORTED
 /* This is the function that does the actual writing of data.  If you are
-   not writing to a standard C stream, you should create a replacement
-   write_data function and use it at run time with png_set_write_fn(), rather
-   than changing the library. */
+ * not writing to a standard C stream, you should create a replacement
+ * write_data function and use it at run time with png_set_write_fn(), rather
+ * than changing the library.
+ */
 #ifndef USE_FAR_KEYWORD
 void PNGAPI
 png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
 {
    png_uint_32 check;
 
-   if(png_ptr == NULL) return;
-#if defined(_WIN32_WCE)
+   if (png_ptr == NULL)
+      return;
+#ifdef _WIN32_WCE
    if ( !WriteFile((HANDLE)(png_ptr->io_ptr), data, length, &check, NULL) )
       check = 0;
 #else
@@ -56,10 +63,10 @@
       png_error(png_ptr, "Write Error");
 }
 #else
-/* this is the model-independent version. Since the standard I/O library
-   can't handle far buffers in the medium and small models, we have to copy
-   the data.
-*/
+/* This is the model-independent version. Since the standard I/O library
+ * can't handle far buffers in the medium and small models, we have to copy
+ * the data.
+ */
 
 #define NEAR_BUF_SIZE 1024
 #define MIN(a,b) (a <= b ? a : b)
@@ -71,13 +78,14 @@
    png_byte *near_data;  /* Needs to be "png_byte *" instead of "png_bytep" */
    png_FILE_p io_ptr;
 
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL)
+      return;
    /* Check if data really is near. If so, use usual code. */
    near_data = (png_byte *)CVT_PTR_NOCHECK(data);
    io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
    if ((png_bytep)near_data == data)
    {
-#if defined(_WIN32_WCE)
+#ifdef _WIN32_WCE
       if ( !WriteFile(io_ptr, near_data, length, &check, NULL) )
          check = 0;
 #else
@@ -93,8 +101,8 @@
       do
       {
          written = MIN(NEAR_BUF_SIZE, remaining);
-         png_memcpy(buf, data, written); /* copy far buffer to near buffer */
-#if defined(_WIN32_WCE)
+         png_memcpy(buf, data, written); /* Copy far buffer to near buffer */
+#ifdef _WIN32_WCE
          if ( !WriteFile(io_ptr, buf, written, &err, NULL) )
             err = 0;
 #else
@@ -102,8 +110,10 @@
 #endif
          if (err != written)
             break;
+
          else
             check += err;
+
          data += written;
          remaining -= written;
       }
@@ -117,9 +127,10 @@
 #endif
 
 /* This function is called to output any data pending writing (normally
-   to disk).  After png_flush is called, there should be no data pending
-   writing in any buffers. */
-#if defined(PNG_WRITE_FLUSH_SUPPORTED)
+ * to disk).  After png_flush is called, there should be no data pending
+ * writing in any buffers.
+ */
+#ifdef PNG_WRITE_FLUSH_SUPPORTED
 void /* PRIVATE */
 png_flush(png_structp png_ptr)
 {
@@ -127,65 +138,76 @@
       (*(png_ptr->output_flush_fn))(png_ptr);
 }
 
-#if !defined(PNG_NO_STDIO)
+#ifdef PNG_STDIO_SUPPORTED
 void PNGAPI
 png_default_flush(png_structp png_ptr)
 {
-#if !defined(_WIN32_WCE)
+#ifndef _WIN32_WCE
    png_FILE_p io_ptr;
 #endif
-   if(png_ptr == NULL) return;
-#if !defined(_WIN32_WCE)
+   if (png_ptr == NULL)
+      return;
+#ifndef _WIN32_WCE
    io_ptr = (png_FILE_p)CVT_PTR((png_ptr->io_ptr));
-   if (io_ptr != NULL)
-      fflush(io_ptr);
+   fflush(io_ptr);
 #endif
 }
 #endif
 #endif
 
 /* This function allows the application to supply new output functions for
-   libpng if standard C streams aren't being used.
-
-   This function takes as its arguments:
-   png_ptr       - pointer to a png output data structure
-   io_ptr        - pointer to user supplied structure containing info about
-                   the output functions.  May be NULL.
-   write_data_fn - pointer to a new output function that takes as its
-                   arguments a pointer to a png_struct, a pointer to
-                   data to be written, and a 32-bit unsigned int that is
-                   the number of bytes to be written.  The new write
-                   function should call png_error(png_ptr, "Error msg")
-                   to exit and output any fatal error messages.
-   flush_data_fn - pointer to a new flush function that takes as its
-                   arguments a pointer to a png_struct.  After a call to
-                   the flush function, there should be no data in any buffers
-                   or pending transmission.  If the output method doesn't do
-                   any buffering of ouput, a function prototype must still be
-                   supplied although it doesn't have to do anything.  If
-                   PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile
-                   time, output_flush_fn will be ignored, although it must be
-                   supplied for compatibility. */
+ * libpng if standard C streams aren't being used.
+ *
+ * This function takes as its arguments:
+ * png_ptr       - pointer to a png output data structure
+ * io_ptr        - pointer to user supplied structure containing info about
+ *                 the output functions.  May be NULL.
+ * write_data_fn - pointer to a new output function that takes as its
+ *                 arguments a pointer to a png_struct, a pointer to
+ *                 data to be written, and a 32-bit unsigned int that is
+ *                 the number of bytes to be written.  The new write
+ *                 function should call png_error(png_ptr, "Error msg")
+ *                 to exit and output any fatal error messages.  May be
+ *                 NULL, in which case libpng's default function will
+ *                 be used.
+ * flush_data_fn - pointer to a new flush function that takes as its
+ *                 arguments a pointer to a png_struct.  After a call to
+ *                 the flush function, there should be no data in any buffers
+ *                 or pending transmission.  If the output method doesn't do
+ *                 any buffering of output, a function prototype must still be
+ *                 supplied although it doesn't have to do anything.  If
+ *                 PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile
+ *                 time, output_flush_fn will be ignored, although it must be
+ *                 supplied for compatibility.  May be NULL, in which case
+ *                 libpng's default function will be used, if
+ *                 PNG_WRITE_FLUSH_SUPPORTED is defined.  This is not
+ *                 a good idea if io_ptr does not point to a standard
+ *                 *FILE structure.
+ */
 void PNGAPI
 png_set_write_fn(png_structp png_ptr, png_voidp io_ptr,
    png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn)
 {
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL)
+      return;
+
    png_ptr->io_ptr = io_ptr;
 
-#if !defined(PNG_NO_STDIO)
+#ifdef PNG_STDIO_SUPPORTED
    if (write_data_fn != NULL)
       png_ptr->write_data_fn = write_data_fn;
+
    else
       png_ptr->write_data_fn = png_default_write_data;
 #else
    png_ptr->write_data_fn = write_data_fn;
 #endif
 
-#if defined(PNG_WRITE_FLUSH_SUPPORTED)
-#if !defined(PNG_NO_STDIO)
+#ifdef PNG_WRITE_FLUSH_SUPPORTED
+#ifdef PNG_STDIO_SUPPORTED
    if (output_flush_fn != NULL)
       png_ptr->output_flush_fn = output_flush_fn;
+
    else
       png_ptr->output_flush_fn = png_default_flush;
 #else
@@ -204,29 +226,33 @@
    }
 }
 
-#if defined(USE_FAR_KEYWORD)
-#if defined(_MSC_VER)
-void *png_far_to_near(png_structp png_ptr,png_voidp ptr, int check)
+#ifdef USE_FAR_KEYWORD
+#ifdef _MSC_VER
+void *png_far_to_near(png_structp png_ptr, png_voidp ptr, int check)
 {
    void *near_ptr;
    void FAR *far_ptr;
    FP_OFF(near_ptr) = FP_OFF(ptr);
    far_ptr = (void FAR *)near_ptr;
-   if(check != 0)
-      if(FP_SEG(ptr) != FP_SEG(far_ptr))
-         png_error(png_ptr,"segment lost in conversion");
+
+   if (check != 0)
+      if (FP_SEG(ptr) != FP_SEG(far_ptr))
+         png_error(png_ptr, "segment lost in conversion");
+
    return(near_ptr);
 }
 #  else
-void *png_far_to_near(png_structp png_ptr,png_voidp ptr, int check)
+void *png_far_to_near(png_structp png_ptr, png_voidp ptr, int check)
 {
    void *near_ptr;
    void FAR *far_ptr;
    near_ptr = (void FAR *)ptr;
    far_ptr = (void FAR *)near_ptr;
-   if(check != 0)
-      if(far_ptr != ptr)
-         png_error(png_ptr,"segment lost in conversion");
+
+   if (check != 0)
+      if (far_ptr != ptr)
+         png_error(png_ptr, "segment lost in conversion");
+
    return(near_ptr);
 }
 #   endif
diff -Naur libAfterImage-1.20/libpng/pngwrite.c root/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c
--- libAfterImage-1.20/libpng/pngwrite.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,15 +1,19 @@
 
 /* pngwrite.c - general routines to write a PNG file
  *
- * Last changed in libpng 1.2.15 January 5, 2007
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.54 [November 12, 2015]
+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
  */
 
-/* get internal access to png.h */
+/* Get internal access to png.h */
 #define PNG_INTERNAL
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
 #ifdef PNG_WRITE_SUPPORTED
 
@@ -25,31 +29,35 @@
 void PNGAPI
 png_write_info_before_PLTE(png_structp png_ptr, png_infop info_ptr)
 {
-   png_debug(1, "in png_write_info_before_PLTE\n");
+   png_debug(1, "in png_write_info_before_PLTE");
+
    if (png_ptr == NULL || info_ptr == NULL)
       return;
    if (!(png_ptr->mode & PNG_WROTE_INFO_BEFORE_PLTE))
    {
-   png_write_sig(png_ptr); /* write PNG signature */
-#if defined(PNG_MNG_FEATURES_SUPPORTED)
-   if((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE)&&(png_ptr->mng_features_permitted))
+   /* Write PNG signature */
+   png_write_sig(png_ptr);
+#ifdef PNG_MNG_FEATURES_SUPPORTED
+   if ((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE) && \
+      (png_ptr->mng_features_permitted))
    {
-      png_warning(png_ptr,"MNG features are not allowed in a PNG datastream");
-      png_ptr->mng_features_permitted=0;
+      png_warning(png_ptr, "MNG features are not allowed in a PNG datastream");
+      png_ptr->mng_features_permitted = 0;
    }
 #endif
-   /* write IHDR information. */
+   /* Write IHDR information. */
    png_write_IHDR(png_ptr, info_ptr->width, info_ptr->height,
       info_ptr->bit_depth, info_ptr->color_type, info_ptr->compression_type,
       info_ptr->filter_type,
-#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
+#ifdef PNG_WRITE_INTERLACING_SUPPORTED
       info_ptr->interlace_type);
 #else
       0);
 #endif
-   /* the rest of these check to see if the valid field has the appropriate
-      flag set, and if it does, writes the chunk. */
-#if defined(PNG_WRITE_gAMA_SUPPORTED)
+   /* The rest of these check to see if the valid field has the appropriate
+    * flag set, and if it does, writes the chunk.
+    */
+#ifdef PNG_WRITE_gAMA_SUPPORTED
    if (info_ptr->valid & PNG_INFO_gAMA)
    {
 #  ifdef PNG_FLOATING_POINT_SUPPORTED
@@ -61,20 +69,20 @@
 #endif
    }
 #endif
-#if defined(PNG_WRITE_sRGB_SUPPORTED)
+#ifdef PNG_WRITE_sRGB_SUPPORTED
    if (info_ptr->valid & PNG_INFO_sRGB)
       png_write_sRGB(png_ptr, (int)info_ptr->srgb_intent);
 #endif
-#if defined(PNG_WRITE_iCCP_SUPPORTED)
+#ifdef PNG_WRITE_iCCP_SUPPORTED
    if (info_ptr->valid & PNG_INFO_iCCP)
       png_write_iCCP(png_ptr, info_ptr->iccp_name, PNG_COMPRESSION_TYPE_BASE,
                      info_ptr->iccp_profile, (int)info_ptr->iccp_proflen);
 #endif
-#if defined(PNG_WRITE_sBIT_SUPPORTED)
+#ifdef PNG_WRITE_sBIT_SUPPORTED
    if (info_ptr->valid & PNG_INFO_sBIT)
       png_write_sBIT(png_ptr, &(info_ptr->sig_bit), info_ptr->color_type);
 #endif
-#if defined(PNG_WRITE_cHRM_SUPPORTED)
+#ifdef PNG_WRITE_cHRM_SUPPORTED
    if (info_ptr->valid & PNG_INFO_cHRM)
    {
 #ifdef PNG_FLOATING_POINT_SUPPORTED
@@ -94,27 +102,29 @@
 #endif
    }
 #endif
-#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
+#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
    if (info_ptr->unknown_chunks_num)
    {
-       png_unknown_chunk *up;
+      png_unknown_chunk *up;
 
-       png_debug(5, "writing extra chunks\n");
+      png_debug(5, "writing extra chunks");
 
-       for (up = info_ptr->unknown_chunks;
-            up < info_ptr->unknown_chunks + info_ptr->unknown_chunks_num;
-            up++)
-       {
-         int keep=png_handle_as_unknown(png_ptr, up->name);
+      for (up = info_ptr->unknown_chunks;
+           up < info_ptr->unknown_chunks + info_ptr->unknown_chunks_num;
+           up++)
+      {
+         int keep = png_handle_as_unknown(png_ptr, up->name);
          if (keep != PNG_HANDLE_CHUNK_NEVER &&
             up->location && !(up->location & PNG_HAVE_PLTE) &&
             !(up->location & PNG_HAVE_IDAT) &&
             ((up->name[3] & 0x20) || keep == PNG_HANDLE_CHUNK_ALWAYS ||
             (png_ptr->flags & PNG_FLAG_KEEP_UNSAFE_CHUNKS)))
          {
+            if (up->size == 0)
+               png_warning(png_ptr, "Writing zero-length unknown chunk");
             png_write_chunk(png_ptr, up->name, up->data, up->size);
          }
-       }
+      }
    }
 #endif
       png_ptr->mode |= PNG_WROTE_INFO_BEFORE_PLTE;
@@ -128,7 +138,7 @@
    int i;
 #endif
 
-   png_debug(1, "in png_write_info\n");
+   png_debug(1, "in png_write_info");
 
    if (png_ptr == NULL || info_ptr == NULL)
       return;
@@ -141,85 +151,92 @@
    else if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
       png_error(png_ptr, "Valid palette required for paletted images");
 
-#if defined(PNG_WRITE_tRNS_SUPPORTED)
+#ifdef PNG_WRITE_tRNS_SUPPORTED
    if (info_ptr->valid & PNG_INFO_tRNS)
+   {
+#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
+      /* Invert the alpha channel (in tRNS) */
+      if ((png_ptr->transformations & PNG_INVERT_ALPHA) &&
+         info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
       {
-#if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
-         /* invert the alpha channel (in tRNS) */
-         if ((png_ptr->transformations & PNG_INVERT_ALPHA) &&
-            info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-         {
-            int j;
-            for (j=0; j<(int)info_ptr->num_trans; j++)
-               info_ptr->trans[j] = (png_byte)(255 - info_ptr->trans[j]);
-         }
+         int j;
+         for (j = 0; j<(int)info_ptr->num_trans; j++)
+            info_ptr->trans[j] = (png_byte)(255 - info_ptr->trans[j]);
+      }
 #endif
       png_write_tRNS(png_ptr, info_ptr->trans, &(info_ptr->trans_values),
          info_ptr->num_trans, info_ptr->color_type);
-      }
+   }
 #endif
-#if defined(PNG_WRITE_bKGD_SUPPORTED)
+#ifdef PNG_WRITE_bKGD_SUPPORTED
    if (info_ptr->valid & PNG_INFO_bKGD)
       png_write_bKGD(png_ptr, &(info_ptr->background), info_ptr->color_type);
 #endif
-#if defined(PNG_WRITE_hIST_SUPPORTED)
+#ifdef PNG_WRITE_hIST_SUPPORTED
    if (info_ptr->valid & PNG_INFO_hIST)
       png_write_hIST(png_ptr, info_ptr->hist, info_ptr->num_palette);
 #endif
-#if defined(PNG_WRITE_oFFs_SUPPORTED)
+#ifdef PNG_WRITE_oFFs_SUPPORTED
    if (info_ptr->valid & PNG_INFO_oFFs)
       png_write_oFFs(png_ptr, info_ptr->x_offset, info_ptr->y_offset,
          info_ptr->offset_unit_type);
 #endif
-#if defined(PNG_WRITE_pCAL_SUPPORTED)
+#ifdef PNG_WRITE_pCAL_SUPPORTED
    if (info_ptr->valid & PNG_INFO_pCAL)
       png_write_pCAL(png_ptr, info_ptr->pcal_purpose, info_ptr->pcal_X0,
          info_ptr->pcal_X1, info_ptr->pcal_type, info_ptr->pcal_nparams,
          info_ptr->pcal_units, info_ptr->pcal_params);
 #endif
-#if defined(PNG_WRITE_sCAL_SUPPORTED)
+
+#ifdef PNG_sCAL_SUPPORTED
    if (info_ptr->valid & PNG_INFO_sCAL)
-#if defined(PNG_FLOATING_POINT_SUPPORTED) && !defined(PNG_NO_STDIO)
+#ifdef PNG_WRITE_sCAL_SUPPORTED
+#if defined(PNG_FLOATING_POINT_SUPPORTED) && defined(PNG_STDIO_SUPPORTED)
       png_write_sCAL(png_ptr, (int)info_ptr->scal_unit,
           info_ptr->scal_pixel_width, info_ptr->scal_pixel_height);
-#else
+#else /* !FLOATING_POINT */
 #ifdef PNG_FIXED_POINT_SUPPORTED
       png_write_sCAL_s(png_ptr, (int)info_ptr->scal_unit,
           info_ptr->scal_s_width, info_ptr->scal_s_height);
-#else
+#endif /* FIXED_POINT */
+#endif /* FLOATING_POINT */
+#else  /* !WRITE_sCAL */
       png_warning(png_ptr,
           "png_write_sCAL not supported; sCAL chunk not written.");
-#endif
-#endif
-#endif
-#if defined(PNG_WRITE_pHYs_SUPPORTED)
+#endif /* WRITE_sCAL */
+#endif /* sCAL */
+
+#ifdef PNG_WRITE_pHYs_SUPPORTED
    if (info_ptr->valid & PNG_INFO_pHYs)
       png_write_pHYs(png_ptr, info_ptr->x_pixels_per_unit,
          info_ptr->y_pixels_per_unit, info_ptr->phys_unit_type);
-#endif
-#if defined(PNG_WRITE_tIME_SUPPORTED)
+#endif /* pHYs */
+
+#ifdef PNG_WRITE_tIME_SUPPORTED
    if (info_ptr->valid & PNG_INFO_tIME)
    {
       png_write_tIME(png_ptr, &(info_ptr->mod_time));
       png_ptr->mode |= PNG_WROTE_tIME;
    }
-#endif
-#if defined(PNG_WRITE_sPLT_SUPPORTED)
+#endif /* tIME */
+
+#ifdef PNG_WRITE_sPLT_SUPPORTED
    if (info_ptr->valid & PNG_INFO_sPLT)
      for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)
        png_write_sPLT(png_ptr, info_ptr->splt_palettes + i);
-#endif
-#if defined(PNG_WRITE_TEXT_SUPPORTED)
+#endif /* sPLT */
+
+#ifdef PNG_WRITE_TEXT_SUPPORTED
    /* Check to see if we need to write text chunks */
    for (i = 0; i < info_ptr->num_text; i++)
    {
-      png_debug2(2, "Writing header text chunk %d, type %d\n", i,
+      png_debug2(2, "Writing header text chunk %d, type %d", i,
          info_ptr->text[i].compression);
-      /* an internationalized chunk? */
+      /* An internationalized chunk? */
       if (info_ptr->text[i].compression > 0)
       {
-#if defined(PNG_WRITE_iTXt_SUPPORTED)
-          /* write international chunk */
+#ifdef PNG_WRITE_iTXt_SUPPORTED
+          /* Write international chunk */
           png_write_iTXt(png_ptr,
                          info_ptr->text[i].compression,
                          info_ptr->text[i].key,
@@ -235,8 +252,8 @@
       /* If we want a compressed text chunk */
       else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_zTXt)
       {
-#if defined(PNG_WRITE_zTXt_SUPPORTED)
-         /* write compressed chunk */
+#ifdef PNG_WRITE_zTXt_SUPPORTED
+         /* Write compressed chunk */
          png_write_zTXt(png_ptr, info_ptr->text[i].key,
             info_ptr->text[i].text, 0,
             info_ptr->text[i].compression);
@@ -248,40 +265,43 @@
       }
       else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
       {
-#if defined(PNG_WRITE_tEXt_SUPPORTED)
-         /* write uncompressed chunk */
+#ifdef PNG_WRITE_tEXt_SUPPORTED
+         /* Write uncompressed chunk */
          png_write_tEXt(png_ptr, info_ptr->text[i].key,
                          info_ptr->text[i].text,
                          0);
+         /* Mark this chunk as written */
+         info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
 #else
+         /* Can't get here */
          png_warning(png_ptr, "Unable to write uncompressed text");
 #endif
-         /* Mark this chunk as written */
-         info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
       }
    }
-#endif
-#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
+#endif /* tEXt */
+
+#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
    if (info_ptr->unknown_chunks_num)
    {
-       png_unknown_chunk *up;
+      png_unknown_chunk *up;
 
-       png_debug(5, "writing extra chunks\n");
+      png_debug(5, "writing extra chunks");
 
-       for (up = info_ptr->unknown_chunks;
-            up < info_ptr->unknown_chunks + info_ptr->unknown_chunks_num;
-            up++)
-       {
-         int keep=png_handle_as_unknown(png_ptr, up->name);
+      for (up = info_ptr->unknown_chunks;
+           up < info_ptr->unknown_chunks + info_ptr->unknown_chunks_num;
+           up++)
+      {
+         int keep = png_handle_as_unknown(png_ptr, up->name);
          if (keep != PNG_HANDLE_CHUNK_NEVER &&
             up->location && (up->location & PNG_HAVE_PLTE) &&
             !(up->location & PNG_HAVE_IDAT) &&
+            !(up->location & PNG_AFTER_IDAT) &&
             ((up->name[3] & 0x20) || keep == PNG_HANDLE_CHUNK_ALWAYS ||
             (png_ptr->flags & PNG_FLAG_KEEP_UNSAFE_CHUNKS)))
          {
             png_write_chunk(png_ptr, up->name, up->data, up->size);
          }
-       }
+      }
    }
 #endif
 }
@@ -294,51 +314,52 @@
 void PNGAPI
 png_write_end(png_structp png_ptr, png_infop info_ptr)
 {
-   png_debug(1, "in png_write_end\n");
+   png_debug(1, "in png_write_end");
+
    if (png_ptr == NULL)
       return;
    if (!(png_ptr->mode & PNG_HAVE_IDAT))
       png_error(png_ptr, "No IDATs written into file");
 
-   /* see if user wants us to write information chunks */
+   /* See if user wants us to write information chunks */
    if (info_ptr != NULL)
    {
-#if defined(PNG_WRITE_TEXT_SUPPORTED)
+#ifdef PNG_WRITE_TEXT_SUPPORTED
       int i; /* local index variable */
 #endif
-#if defined(PNG_WRITE_tIME_SUPPORTED)
-      /* check to see if user has supplied a time chunk */
+#ifdef PNG_WRITE_tIME_SUPPORTED
+      /* Check to see if user has supplied a time chunk */
       if ((info_ptr->valid & PNG_INFO_tIME) &&
          !(png_ptr->mode & PNG_WROTE_tIME))
          png_write_tIME(png_ptr, &(info_ptr->mod_time));
 #endif
-#if defined(PNG_WRITE_TEXT_SUPPORTED)
-      /* loop through comment chunks */
+#ifdef PNG_WRITE_TEXT_SUPPORTED
+      /* Loop through comment chunks */
       for (i = 0; i < info_ptr->num_text; i++)
       {
-         png_debug2(2, "Writing trailer text chunk %d, type %d\n", i,
+         png_debug2(2, "Writing trailer text chunk %d, type %d", i,
             info_ptr->text[i].compression);
-         /* an internationalized chunk? */
+         /* An internationalized chunk? */
          if (info_ptr->text[i].compression > 0)
          {
-#if defined(PNG_WRITE_iTXt_SUPPORTED)
-             /* write international chunk */
-             png_write_iTXt(png_ptr,
-                         info_ptr->text[i].compression,
-                         info_ptr->text[i].key,
-                         info_ptr->text[i].lang,
-                         info_ptr->text[i].lang_key,
-                         info_ptr->text[i].text);
+#ifdef PNG_WRITE_iTXt_SUPPORTED
+            /* Write international chunk */
+            png_write_iTXt(png_ptr,
+                        info_ptr->text[i].compression,
+                        info_ptr->text[i].key,
+                        info_ptr->text[i].lang,
+                        info_ptr->text[i].lang_key,
+                        info_ptr->text[i].text);
 #else
-             png_warning(png_ptr, "Unable to write international text");
+            png_warning(png_ptr, "Unable to write international text");
 #endif
-             /* Mark this chunk as written */
-             info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
+            /* Mark this chunk as written */
+            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
          }
          else if (info_ptr->text[i].compression >= PNG_TEXT_COMPRESSION_zTXt)
          {
-#if defined(PNG_WRITE_zTXt_SUPPORTED)
-            /* write compressed chunk */
+#ifdef PNG_WRITE_zTXt_SUPPORTED
+            /* Write compressed chunk */
             png_write_zTXt(png_ptr, info_ptr->text[i].key,
                info_ptr->text[i].text, 0,
                info_ptr->text[i].compression);
@@ -350,8 +371,8 @@
          }
          else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
          {
-#if defined(PNG_WRITE_tEXt_SUPPORTED)
-            /* write uncompressed chunk */
+#ifdef PNG_WRITE_tEXt_SUPPORTED
+            /* Write uncompressed chunk */
             png_write_tEXt(png_ptr, info_ptr->text[i].key,
                info_ptr->text[i].text, 0);
 #else
@@ -363,18 +384,18 @@
          }
       }
 #endif
-#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
+#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
    if (info_ptr->unknown_chunks_num)
    {
-       png_unknown_chunk *up;
+      png_unknown_chunk *up;
 
-       png_debug(5, "writing extra chunks\n");
+      png_debug(5, "writing extra chunks");
 
-       for (up = info_ptr->unknown_chunks;
-            up < info_ptr->unknown_chunks + info_ptr->unknown_chunks_num;
-            up++)
-       {
-         int keep=png_handle_as_unknown(png_ptr, up->name);
+      for (up = info_ptr->unknown_chunks;
+           up < info_ptr->unknown_chunks + info_ptr->unknown_chunks_num;
+           up++)
+      {
+         int keep = png_handle_as_unknown(png_ptr, up->name);
          if (keep != PNG_HANDLE_CHUNK_NEVER &&
             up->location && (up->location & PNG_AFTER_IDAT) &&
             ((up->name[3] & 0x20) || keep == PNG_HANDLE_CHUNK_ALWAYS ||
@@ -382,24 +403,36 @@
          {
             png_write_chunk(png_ptr, up->name, up->data, up->size);
          }
-       }
+      }
    }
 #endif
    }
 
    png_ptr->mode |= PNG_AFTER_IDAT;
 
-   /* write end of PNG file */
+   /* Write end of PNG file */
    png_write_IEND(png_ptr);
+   /* This flush, added in libpng-1.0.8, removed from libpng-1.0.9beta03,
+    * and restored again in libpng-1.2.30, may cause some applications that
+    * do not set png_ptr->output_flush_fn to crash.  If your application
+    * experiences a problem, please try building libpng with
+    * PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED defined, and report the event to
+    * png-mng-implement at lists.sf.net .
+    */
+#ifdef PNG_WRITE_FLUSH_SUPPORTED
+#  ifdef PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED
+   png_flush(png_ptr);
+#  endif
+#endif
 }
 
-#if defined(PNG_WRITE_tIME_SUPPORTED)
-#if !defined(_WIN32_WCE)
-/* "time.h" functions are not supported on WindowsCE */
+#ifdef PNG_CONVERT_tIME_SUPPORTED
+/* "tm" structure is not supported on WindowsCE */
 void PNGAPI
 png_convert_from_struct_tm(png_timep ptime, struct tm FAR * ttime)
 {
-   png_debug(1, "in png_convert_from_struct_tm\n");
+   png_debug(1, "in png_convert_from_struct_tm");
+
    ptime->year = (png_uint_16)(1900 + ttime->tm_year);
    ptime->month = (png_byte)(ttime->tm_mon + 1);
    ptime->day = (png_byte)ttime->tm_mday;
@@ -413,12 +446,12 @@
 {
    struct tm *tbuf;
 
-   png_debug(1, "in png_convert_from_time_t\n");
+   png_debug(1, "in png_convert_from_time_t");
+
    tbuf = gmtime(&ttime);
    png_convert_from_struct_tm(ptime, tbuf);
 }
 #endif
-#endif
 
 /* Initialize png_ptr structure, and allocate any memory needed */
 png_structp PNGAPI
@@ -437,6 +470,9 @@
    png_malloc_ptr malloc_fn, png_free_ptr free_fn)
 {
 #endif /* PNG_USER_MEM_SUPPORTED */
+#ifdef PNG_SETJMP_SUPPORTED
+   volatile
+#endif
    png_structp png_ptr;
 #ifdef PNG_SETJMP_SUPPORTED
 #ifdef USE_FAR_KEYWORD
@@ -444,7 +480,9 @@
 #endif
 #endif
    int i;
-   png_debug(1, "in png_create_write_struct\n");
+
+   png_debug(1, "in png_create_write_struct");
+
 #ifdef PNG_USER_MEM_SUPPORTED
    png_ptr = (png_structp)png_create_struct_2(PNG_STRUCT_PNG,
       (png_malloc_ptr)malloc_fn, (png_voidp)mem_ptr);
@@ -454,10 +492,10 @@
    if (png_ptr == NULL)
       return (NULL);
 
-   /* added at libpng-1.2.6 */
+   /* Added at libpng-1.2.6 */
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
-   png_ptr->user_width_max=PNG_USER_WIDTH_MAX;
-   png_ptr->user_height_max=PNG_USER_HEIGHT_MAX;
+   png_ptr->user_width_max = PNG_USER_WIDTH_MAX;
+   png_ptr->user_height_max = PNG_USER_HEIGHT_MAX;
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
@@ -468,12 +506,17 @@
 #endif
    {
       png_free(png_ptr, png_ptr->zbuf);
-      png_ptr->zbuf=NULL;
-      png_destroy_struct(png_ptr);
+      png_ptr->zbuf = NULL;
+#ifdef PNG_USER_MEM_SUPPORTED
+      png_destroy_struct_2((png_voidp)png_ptr,
+         (png_free_ptr)free_fn, (png_voidp)mem_ptr);
+#else
+      png_destroy_struct((png_voidp)png_ptr);
+#endif
       return (NULL);
    }
 #ifdef USE_FAR_KEYWORD
-   png_memcpy(png_ptr->jmpbuf,jmpbuf,png_sizeof(jmp_buf));
+   png_memcpy(png_ptr->jmpbuf, jmpbuf, png_sizeof(jmp_buf));
 #endif
 #endif
 
@@ -482,12 +525,23 @@
 #endif /* PNG_USER_MEM_SUPPORTED */
    png_set_error_fn(png_ptr, error_ptr, error_fn, warn_fn);
 
-   i=0;
-   do
+   if (user_png_ver != NULL)
    {
-     if(user_png_ver[i] != png_libpng_ver[i])
-        png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
-   } while (png_libpng_ver[i++]);
+      int found_dots = 0;
+      i = -1;
+
+      do
+      {
+         i++;
+         if (user_png_ver[i] != PNG_LIBPNG_VER_STRING[i])
+            png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
+         if (user_png_ver[i] == '.')
+            found_dots++;
+      } while (found_dots < 2 && user_png_ver[i] != 0 &&
+            PNG_LIBPNG_VER_STRING[i] != 0);
+   }
+   else
+      png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
 
    if (png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH)
    {
@@ -500,14 +554,14 @@
          (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||
          (user_png_ver[0] == '0' && user_png_ver[2] < '9'))
      {
-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
+#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
         char msg[80];
         if (user_png_ver)
         {
-          png_snprintf(msg, 80,
-             "Application was compiled with png.h from libpng-%.20s",
-             user_png_ver);
-          png_warning(png_ptr, msg);
+           png_snprintf(msg, 80,
+              "Application was compiled with png.h from libpng-%.20s",
+              user_png_ver);
+           png_warning(png_ptr, msg);
         }
         png_snprintf(msg, 80,
            "Application  is  running with png.c from libpng-%.20s",
@@ -515,34 +569,30 @@
         png_warning(png_ptr, msg);
 #endif
 #ifdef PNG_ERROR_NUMBERS_SUPPORTED
-        png_ptr->flags=0;
+        png_ptr->flags = 0;
 #endif
         png_error(png_ptr,
            "Incompatible libpng version in application and library");
      }
    }
 
-   /* initialize zbuf - compression buffer */
+   /* Initialize zbuf - compression buffer */
    png_ptr->zbuf_size = PNG_ZBUF_SIZE;
    png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
-      (png_uint_32)png_ptr->zbuf_size);
+     (png_uint_32)png_ptr->zbuf_size);
 
    png_set_write_fn(png_ptr, png_voidp_NULL, png_rw_ptr_NULL,
       png_flush_ptr_NULL);
 
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-   png_set_filter_heuristics(png_ptr, PNG_FILTER_HEURISTIC_DEFAULT,
-      1, png_doublep_NULL, png_doublep_NULL);
-#endif
-
 #ifdef PNG_SETJMP_SUPPORTED
-/* Applications that neglect to set up their own setjmp() and then encounter
-   a png_error() will longjmp here.  Since the jmpbuf is then meaningless we
-   abort instead of returning. */
+   /* Applications that neglect to set up their own setjmp() and then
+    * encounter a png_error() will longjmp here.  Since the jmpbuf is
+    * then meaningless we abort instead of returning.
+    */
 #ifdef USE_FAR_KEYWORD
    if (setjmp(jmpbuf))
       PNG_ABORT();
-   png_memcpy(png_ptr->jmpbuf,jmpbuf,png_sizeof(jmp_buf));
+   png_memcpy(png_ptr->jmpbuf, jmpbuf, png_sizeof(jmp_buf));
 #else
    if (setjmp(png_ptr->jmpbuf))
       PNG_ABORT();
@@ -567,19 +617,19 @@
    png_size_t png_struct_size, png_size_t png_info_size)
 {
    /* We only come here via pre-1.0.12-compiled applications */
-   if(png_ptr == NULL) return;
-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
-   if(png_sizeof(png_struct) > png_struct_size ||
+   if (png_ptr == NULL) return;
+#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
+   if (png_sizeof(png_struct) > png_struct_size ||
       png_sizeof(png_info) > png_info_size)
    {
       char msg[80];
-      png_ptr->warning_fn=NULL;
+      png_ptr->warning_fn = NULL;
       if (user_png_ver)
       {
-        png_snprintf(msg, 80,
-           "Application was compiled with png.h from libpng-%.20s",
-           user_png_ver);
-        png_warning(png_ptr, msg);
+         png_snprintf(msg, 80,
+            "Application was compiled with png.h from libpng-%.20s",
+            user_png_ver);
+         png_warning(png_ptr, msg);
       }
       png_snprintf(msg, 80,
          "Application  is  running with png.c from libpng-%.20s",
@@ -587,24 +637,26 @@
       png_warning(png_ptr, msg);
    }
 #endif
-   if(png_sizeof(png_struct) > png_struct_size)
-     {
-       png_ptr->error_fn=NULL;
+   if (png_sizeof(png_struct) > png_struct_size)
+   {
+      png_ptr->error_fn = NULL;
 #ifdef PNG_ERROR_NUMBERS_SUPPORTED
-       png_ptr->flags=0;
+      png_ptr->flags = 0;
 #endif
-       png_error(png_ptr,
-       "The png struct allocated by the application for writing is too small.");
-     }
-   if(png_sizeof(png_info) > png_info_size)
-     {
-       png_ptr->error_fn=NULL;
+      png_error(png_ptr,
+      "The png struct allocated by the application for writing is"
+      " too small.");
+   }
+   if (png_sizeof(png_info) > png_info_size)
+   {
+      png_ptr->error_fn = NULL;
 #ifdef PNG_ERROR_NUMBERS_SUPPORTED
-       png_ptr->flags=0;
+      png_ptr->flags = 0;
 #endif
-       png_error(png_ptr,
-       "The info struct allocated by the application for writing is too small.");
-     }
+      png_error(png_ptr,
+      "The info struct allocated by the application for writing is"
+      " too small.");
+   }
    png_write_init_3(&png_ptr, user_png_ver, png_struct_size);
 }
 #endif /* PNG_1_0_X || PNG_1_2_X */
@@ -614,7 +666,7 @@
 png_write_init_3(png_structpp ptr_ptr, png_const_charp user_png_ver,
    png_size_t png_struct_size)
 {
-   png_structp png_ptr=*ptr_ptr;
+   png_structp png_ptr = *ptr_ptr;
 #ifdef PNG_SETJMP_SUPPORTED
    jmp_buf tmp_jmp; /* to save current jump buffer */
 #endif
@@ -626,59 +678,54 @@
 
    do
    {
-     if (user_png_ver[i] != png_libpng_ver[i])
-     {
+      if (user_png_ver[i] != png_libpng_ver[i])
+      {
 #ifdef PNG_LEGACY_SUPPORTED
-       png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
+         png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
 #else
-       png_ptr->warning_fn=NULL;
-       png_warning(png_ptr,
-     "Application uses deprecated png_write_init() and should be recompiled.");
-       break;
+         png_ptr->warning_fn = NULL;
+         png_warning(png_ptr,
+ "Application uses deprecated png_write_init() and should be recompiled.");
 #endif
-     }
-   } while (png_libpng_ver[i++]);
+   }
+      i++;
+   } while (png_libpng_ver[i] != 0 && user_png_ver[i] != 0);
 
-   png_debug(1, "in png_write_init_3\n");
+   png_debug(1, "in png_write_init_3");
 
 #ifdef PNG_SETJMP_SUPPORTED
-   /* save jump buffer and error functions */
-   png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof (jmp_buf));
+   /* Save jump buffer and error functions */
+   png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));
 #endif
 
    if (png_sizeof(png_struct) > png_struct_size)
-     {
-       png_destroy_struct(png_ptr);
-       png_ptr = (png_structp)png_create_struct(PNG_STRUCT_PNG);
-       *ptr_ptr = png_ptr;
-     }
+   {
+      png_destroy_struct(png_ptr);
+      png_ptr = (png_structp)png_create_struct(PNG_STRUCT_PNG);
+      *ptr_ptr = png_ptr;
+   }
 
-   /* reset all variables to 0 */
-   png_memset(png_ptr, 0, png_sizeof (png_struct));
+   /* Reset all variables to 0 */
+   png_memset(png_ptr, 0, png_sizeof(png_struct));
 
-   /* added at libpng-1.2.6 */
+   /* Added at libpng-1.2.6 */
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
-   png_ptr->user_width_max=PNG_USER_WIDTH_MAX;
-   png_ptr->user_height_max=PNG_USER_HEIGHT_MAX;
+   png_ptr->user_width_max = PNG_USER_WIDTH_MAX;
+   png_ptr->user_height_max = PNG_USER_HEIGHT_MAX;
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
-   /* restore jump buffer */
-   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof (jmp_buf));
+   /* Restore jump buffer */
+   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));
 #endif
 
    png_set_write_fn(png_ptr, png_voidp_NULL, png_rw_ptr_NULL,
       png_flush_ptr_NULL);
 
-   /* initialize zbuf - compression buffer */
+   /* Initialize zbuf - compression buffer */
    png_ptr->zbuf_size = PNG_ZBUF_SIZE;
    png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
-      (png_uint_32)png_ptr->zbuf_size);
-
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-   png_set_filter_heuristics(png_ptr, PNG_FILTER_HEURISTIC_DEFAULT,
-      1, png_doublep_NULL, png_doublep_NULL);
-#endif
+     (png_uint_32)png_ptr->zbuf_size);
 }
 
 /* Write a few rows of image data.  If the image is interlaced,
@@ -693,12 +740,12 @@
    png_uint_32 i; /* row counter */
    png_bytepp rp; /* row pointer */
 
-   png_debug(1, "in png_write_rows\n");
+   png_debug(1, "in png_write_rows");
 
    if (png_ptr == NULL)
       return;
 
-   /* loop through the rows */
+   /* Loop through the rows */
    for (i = 0, rp = row; i < num_rows; i++, rp++)
    {
       png_write_row(png_ptr, *rp);
@@ -718,18 +765,20 @@
    if (png_ptr == NULL)
       return;
 
-   png_debug(1, "in png_write_image\n");
-#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
-   /* intialize interlace handling.  If image is not interlaced,
-      this will set pass to 1 */
+   png_debug(1, "in png_write_image");
+
+#ifdef PNG_WRITE_INTERLACING_SUPPORTED
+   /* Initialize interlace handling.  If image is not interlaced,
+    * this will set pass to 1
+    */
    num_pass = png_set_interlace_handling(png_ptr);
 #else
    num_pass = 1;
 #endif
-   /* loop through passes */
+   /* Loop through passes */
    for (pass = 0; pass < num_pass; pass++)
    {
-      /* loop through image */
+      /* Loop through image */
       for (i = 0, rp = image; i < png_ptr->height; i++, rp++)
       {
          png_write_row(png_ptr, *rp);
@@ -737,58 +786,63 @@
    }
 }
 
-/* called by user to write a row of image data */
+/* Called by user to write a row of image data */
 void PNGAPI
 png_write_row(png_structp png_ptr, png_bytep row)
 {
    if (png_ptr == NULL)
       return;
-   png_debug2(1, "in png_write_row (row %ld, pass %d)\n",
+
+   png_debug2(1, "in png_write_row (row %ld, pass %d)",
       png_ptr->row_number, png_ptr->pass);
 
-   /* initialize transformations and other stuff if first time */
+   /* Initialize transformations and other stuff if first time */
    if (png_ptr->row_number == 0 && png_ptr->pass == 0)
    {
-   /* make sure we wrote the header info */
-   if (!(png_ptr->mode & PNG_WROTE_INFO_BEFORE_PLTE))
-      png_error(png_ptr,
-         "png_write_info was never called before png_write_row.");
+      /* Make sure we wrote the header info */
+      if (!(png_ptr->mode & PNG_WROTE_INFO_BEFORE_PLTE))
+         png_error(png_ptr,
+            "png_write_info was never called before png_write_row.");
 
-   /* check for transforms that have been set but were defined out */
+      /* Check for transforms that have been set but were defined out */
 #if !defined(PNG_WRITE_INVERT_SUPPORTED) && defined(PNG_READ_INVERT_SUPPORTED)
-   if (png_ptr->transformations & PNG_INVERT_MONO)
-      png_warning(png_ptr, "PNG_WRITE_INVERT_SUPPORTED is not defined.");
+      if (png_ptr->transformations & PNG_INVERT_MONO)
+         png_warning(png_ptr,
+             "PNG_WRITE_INVERT_SUPPORTED is not defined.");
 #endif
 #if !defined(PNG_WRITE_FILLER_SUPPORTED) && defined(PNG_READ_FILLER_SUPPORTED)
-   if (png_ptr->transformations & PNG_FILLER)
-      png_warning(png_ptr, "PNG_WRITE_FILLER_SUPPORTED is not defined.");
-#endif
-#if !defined(PNG_WRITE_PACKSWAP_SUPPORTED) && defined(PNG_READ_PACKSWAP_SUPPORTED)
-   if (png_ptr->transformations & PNG_PACKSWAP)
-      png_warning(png_ptr, "PNG_WRITE_PACKSWAP_SUPPORTED is not defined.");
+      if (png_ptr->transformations & PNG_FILLER)
+         png_warning(png_ptr,
+             "PNG_WRITE_FILLER_SUPPORTED is not defined.");
+#endif
+#if !defined(PNG_WRITE_PACKSWAP_SUPPORTED) && \
+    defined(PNG_READ_PACKSWAP_SUPPORTED)
+      if (png_ptr->transformations & PNG_PACKSWAP)
+         png_warning(png_ptr,
+             "PNG_WRITE_PACKSWAP_SUPPORTED is not defined.");
 #endif
 #if !defined(PNG_WRITE_PACK_SUPPORTED) && defined(PNG_READ_PACK_SUPPORTED)
-   if (png_ptr->transformations & PNG_PACK)
-      png_warning(png_ptr, "PNG_WRITE_PACK_SUPPORTED is not defined.");
+      if (png_ptr->transformations & PNG_PACK)
+         png_warning(png_ptr, "PNG_WRITE_PACK_SUPPORTED is not defined.");
 #endif
 #if !defined(PNG_WRITE_SHIFT_SUPPORTED) && defined(PNG_READ_SHIFT_SUPPORTED)
-   if (png_ptr->transformations & PNG_SHIFT)
-      png_warning(png_ptr, "PNG_WRITE_SHIFT_SUPPORTED is not defined.");
+      if (png_ptr->transformations & PNG_SHIFT)
+         png_warning(png_ptr, "PNG_WRITE_SHIFT_SUPPORTED is not defined.");
 #endif
 #if !defined(PNG_WRITE_BGR_SUPPORTED) && defined(PNG_READ_BGR_SUPPORTED)
-   if (png_ptr->transformations & PNG_BGR)
-      png_warning(png_ptr, "PNG_WRITE_BGR_SUPPORTED is not defined.");
+      if (png_ptr->transformations & PNG_BGR)
+         png_warning(png_ptr, "PNG_WRITE_BGR_SUPPORTED is not defined.");
 #endif
 #if !defined(PNG_WRITE_SWAP_SUPPORTED) && defined(PNG_READ_SWAP_SUPPORTED)
-   if (png_ptr->transformations & PNG_SWAP_BYTES)
-      png_warning(png_ptr, "PNG_WRITE_SWAP_SUPPORTED is not defined.");
+      if (png_ptr->transformations & PNG_SWAP_BYTES)
+         png_warning(png_ptr, "PNG_WRITE_SWAP_SUPPORTED is not defined.");
 #endif
 
       png_write_start_row(png_ptr);
    }
 
-#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
-   /* if interlaced and not interested in row, return */
+#ifdef PNG_WRITE_INTERLACING_SUPPORTED
+   /* If interlaced and not interested in row, return */
    if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))
    {
       switch (png_ptr->pass)
@@ -846,7 +900,7 @@
    }
 #endif
 
-   /* set up row info for transformations */
+   /* Set up row info for transformations */
    png_ptr->row_info.color_type = png_ptr->color_type;
    png_ptr->row_info.width = png_ptr->usr_width;
    png_ptr->row_info.channels = png_ptr->usr_channels;
@@ -857,25 +911,25 @@
    png_ptr->row_info.rowbytes = PNG_ROWBYTES(png_ptr->row_info.pixel_depth,
       png_ptr->row_info.width);
 
-   png_debug1(3, "row_info->color_type = %d\n", png_ptr->row_info.color_type);
-   png_debug1(3, "row_info->width = %lu\n", png_ptr->row_info.width);
-   png_debug1(3, "row_info->channels = %d\n", png_ptr->row_info.channels);
-   png_debug1(3, "row_info->bit_depth = %d\n", png_ptr->row_info.bit_depth);
-   png_debug1(3, "row_info->pixel_depth = %d\n", png_ptr->row_info.pixel_depth);
-   png_debug1(3, "row_info->rowbytes = %lu\n", png_ptr->row_info.rowbytes);
+   png_debug1(3, "row_info->color_type = %d", png_ptr->row_info.color_type);
+   png_debug1(3, "row_info->width = %lu", png_ptr->row_info.width);
+   png_debug1(3, "row_info->channels = %d", png_ptr->row_info.channels);
+   png_debug1(3, "row_info->bit_depth = %d", png_ptr->row_info.bit_depth);
+   png_debug1(3, "row_info->pixel_depth = %d", png_ptr->row_info.pixel_depth);
+   png_debug1(3, "row_info->rowbytes = %lu", png_ptr->row_info.rowbytes);
 
    /* Copy user's row into buffer, leaving room for filter byte. */
    png_memcpy_check(png_ptr, png_ptr->row_buf + 1, row,
       png_ptr->row_info.rowbytes);
 
-#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
-   /* handle interlacing */
+#ifdef PNG_WRITE_INTERLACING_SUPPORTED
+   /* Handle interlacing */
    if (png_ptr->interlaced && png_ptr->pass < 6 &&
       (png_ptr->transformations & PNG_INTERLACE))
    {
       png_do_write_interlace(&(png_ptr->row_info),
          png_ptr->row_buf + 1, png_ptr->pass);
-      /* this should always get caught above, but still ... */
+      /* This should always get caught above, but still ... */
       if (!(png_ptr->row_info.width))
       {
          png_write_finish_row(png_ptr);
@@ -884,11 +938,11 @@
    }
 #endif
 
-   /* handle other transformations */
+   /* Handle other transformations */
    if (png_ptr->transformations)
       png_do_write_transformations(png_ptr);
 
-#if defined(PNG_MNG_FEATURES_SUPPORTED)
+#ifdef PNG_MNG_FEATURES_SUPPORTED
    /* Write filter_method 64 (intrapixel differencing) only if
     * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
     * 2. Libpng did not write a PNG signature (this filter_method is only
@@ -898,7 +952,7 @@
     * 4. The filter_method is 64 and
     * 5. The color_type is RGB or RGBA
     */
-   if((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
+   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
       (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))
    {
       /* Intrapixel differencing */
@@ -913,39 +967,41 @@
       (*(png_ptr->write_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);
 }
 
-#if defined(PNG_WRITE_FLUSH_SUPPORTED)
+#ifdef PNG_WRITE_FLUSH_SUPPORTED
 /* Set the automatic flush interval or 0 to turn flushing off */
 void PNGAPI
 png_set_flush(png_structp png_ptr, int nrows)
 {
-   png_debug(1, "in png_set_flush\n");
+   png_debug(1, "in png_set_flush");
+
    if (png_ptr == NULL)
       return;
    png_ptr->flush_dist = (nrows < 0 ? 0 : nrows);
 }
 
-/* flush the current output buffers now */
+/* Flush the current output buffers now */
 void PNGAPI
 png_write_flush(png_structp png_ptr)
 {
    int wrote_IDAT;
 
-   png_debug(1, "in png_write_flush\n");
+   png_debug(1, "in png_write_flush");
+
    if (png_ptr == NULL)
       return;
    /* We have already written out all of the data */
    if (png_ptr->row_number >= png_ptr->num_rows)
-     return;
+      return;
 
    do
    {
       int ret;
 
-      /* compress the data */
+      /* Compress the data */
       ret = deflate(&png_ptr->zstream, Z_SYNC_FLUSH);
       wrote_IDAT = 0;
 
-      /* check for compression errors */
+      /* Check for compression errors */
       if (ret != Z_OK)
       {
          if (png_ptr->zstream.msg != NULL)
@@ -956,7 +1012,7 @@
 
       if (!(png_ptr->zstream.avail_out))
       {
-         /* write the IDAT and reset the zlib output buffer */
+         /* Write the IDAT and reset the zlib output buffer */
          png_write_IDAT(png_ptr, png_ptr->zbuf,
                         png_ptr->zbuf_size);
          png_ptr->zstream.next_out = png_ptr->zbuf;
@@ -968,7 +1024,7 @@
    /* If there is any data left to be output, write it into a new IDAT */
    if (png_ptr->zbuf_size != png_ptr->zstream.avail_out)
    {
-      /* write the IDAT and reset the zlib output buffer */
+      /* Write the IDAT and reset the zlib output buffer */
       png_write_IDAT(png_ptr, png_ptr->zbuf,
                      png_ptr->zbuf_size - png_ptr->zstream.avail_out);
       png_ptr->zstream.next_out = png_ptr->zbuf;
@@ -979,7 +1035,7 @@
 }
 #endif /* PNG_WRITE_FLUSH_SUPPORTED */
 
-/* free all memory used by the write */
+/* Free all memory used by the write */
 void PNGAPI
 png_destroy_write_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr)
 {
@@ -990,7 +1046,8 @@
    png_voidp mem_ptr = NULL;
 #endif
 
-   png_debug(1, "in png_destroy_write_struct\n");
+   png_debug(1, "in png_destroy_write_struct");
+
    if (png_ptr_ptr != NULL)
    {
       png_ptr = *png_ptr_ptr;
@@ -1000,21 +1057,32 @@
 #endif
    }
 
+#ifdef PNG_USER_MEM_SUPPORTED
+   if (png_ptr != NULL)
+   {
+      free_fn = png_ptr->free_fn;
+      mem_ptr = png_ptr->mem_ptr;
+   }
+#endif
+
    if (info_ptr_ptr != NULL)
       info_ptr = *info_ptr_ptr;
 
    if (info_ptr != NULL)
    {
-      png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
-
-#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
-      if (png_ptr->num_chunk_list)
+      if (png_ptr != NULL)
       {
-         png_free(png_ptr, png_ptr->chunk_list);
-         png_ptr->chunk_list=NULL;
-         png_ptr->num_chunk_list=0;
-      }
+        png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
+
+#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+        if (png_ptr->num_chunk_list)
+        {
+           png_free(png_ptr, png_ptr->chunk_list);
+           png_ptr->chunk_list = NULL;
+           png_ptr->num_chunk_list = 0;
+        }
 #endif
+      }
 
 #ifdef PNG_USER_MEM_SUPPORTED
       png_destroy_struct_2((png_voidp)info_ptr, (png_free_ptr)free_fn,
@@ -1044,7 +1112,7 @@
 png_write_destroy(png_structp png_ptr)
 {
 #ifdef PNG_SETJMP_SUPPORTED
-   jmp_buf tmp_jmp; /* save jump buffer */
+   jmp_buf tmp_jmp; /* Save jump buffer */
 #endif
    png_error_ptr error_fn;
    png_error_ptr warning_fn;
@@ -1053,34 +1121,29 @@
    png_free_ptr free_fn;
 #endif
 
-   png_debug(1, "in png_write_destroy\n");
-   /* free any memory zlib uses */
+   png_debug(1, "in png_write_destroy");
+
+   /* Free any memory zlib uses */
    deflateEnd(&png_ptr->zstream);
 
-   /* free our memory.  png_free checks NULL for us. */
+   /* Free our memory.  png_free checks NULL for us. */
    png_free(png_ptr, png_ptr->zbuf);
    png_free(png_ptr, png_ptr->row_buf);
+#ifdef PNG_WRITE_FILTER_SUPPORTED
    png_free(png_ptr, png_ptr->prev_row);
    png_free(png_ptr, png_ptr->sub_row);
    png_free(png_ptr, png_ptr->up_row);
    png_free(png_ptr, png_ptr->avg_row);
    png_free(png_ptr, png_ptr->paeth_row);
-
-#if defined(PNG_TIME_RFC1123_SUPPORTED)
-   png_free(png_ptr, png_ptr->time_buffer);
 #endif
 
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-   png_free(png_ptr, png_ptr->prev_filters);
-   png_free(png_ptr, png_ptr->filter_weights);
-   png_free(png_ptr, png_ptr->inv_filter_weights);
-   png_free(png_ptr, png_ptr->filter_costs);
-   png_free(png_ptr, png_ptr->inv_filter_costs);
+#ifdef PNG_TIME_RFC1123_SUPPORTED
+   png_free(png_ptr, png_ptr->time_buffer);
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
-   /* reset structure */
-   png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof (jmp_buf));
+   /* Reset structure */
+   png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));
 #endif
 
    error_fn = png_ptr->error_fn;
@@ -1090,7 +1153,7 @@
    free_fn = png_ptr->free_fn;
 #endif
 
-   png_memset(png_ptr, 0, png_sizeof (png_struct));
+   png_memset(png_ptr, 0, png_sizeof(png_struct));
 
    png_ptr->error_fn = error_fn;
    png_ptr->warning_fn = warning_fn;
@@ -1100,7 +1163,7 @@
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
-   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof (jmp_buf));
+   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));
 #endif
 }
 
@@ -1108,11 +1171,12 @@
 void PNGAPI
 png_set_filter(png_structp png_ptr, int method, int filters)
 {
-   png_debug(1, "in png_set_filter\n");
+   png_debug(1, "in png_set_filter");
+
    if (png_ptr == NULL)
       return;
-#if defined(PNG_MNG_FEATURES_SUPPORTED)
-   if((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
+#ifdef PNG_MNG_FEATURES_SUPPORTED
+   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
       (method == PNG_INTRAPIXEL_DIFFERENCING))
          method = PNG_FILTER_TYPE_BASE;
 #endif
@@ -1120,26 +1184,26 @@
    {
       switch (filters & (PNG_ALL_FILTERS | 0x07))
       {
-#ifndef PNG_NO_WRITE_FILTER
+         case PNG_FILTER_VALUE_NONE:
+              png_ptr->do_filter = PNG_FILTER_NONE; break;
+#ifdef PNG_WRITE_FILTER_SUPPORTED
          case 5:
          case 6:
          case 7: png_warning(png_ptr, "Unknown row filter for method 0");
-#endif /* PNG_NO_WRITE_FILTER */
-         case PNG_FILTER_VALUE_NONE:
-              png_ptr->do_filter=PNG_FILTER_NONE; break;
-#ifndef PNG_NO_WRITE_FILTER
+                 break;
          case PNG_FILTER_VALUE_SUB:
-              png_ptr->do_filter=PNG_FILTER_SUB; break;
+              png_ptr->do_filter = PNG_FILTER_SUB; break;
          case PNG_FILTER_VALUE_UP:
-              png_ptr->do_filter=PNG_FILTER_UP; break;
+              png_ptr->do_filter = PNG_FILTER_UP; break;
          case PNG_FILTER_VALUE_AVG:
-              png_ptr->do_filter=PNG_FILTER_AVG; break;
+              png_ptr->do_filter = PNG_FILTER_AVG; break;
          case PNG_FILTER_VALUE_PAETH:
-              png_ptr->do_filter=PNG_FILTER_PAETH; break;
+              png_ptr->do_filter = PNG_FILTER_PAETH; break;
          default: png_ptr->do_filter = (png_byte)filters; break;
 #else
          default: png_warning(png_ptr, "Unknown row filter for method 0");
-#endif /* PNG_NO_WRITE_FILTER */
+                 break;
+#endif /* PNG_WRITE_FILTER_SUPPORTED */
       }
 
       /* If we have allocated the row_buf, this means we have already started
@@ -1153,7 +1217,7 @@
        */
       if (png_ptr->row_buf != NULL)
       {
-#ifndef PNG_NO_WRITE_FILTER
+#ifdef PNG_WRITE_FILTER_SUPPORTED
          if ((png_ptr->do_filter & PNG_FILTER_SUB) && png_ptr->sub_row == NULL)
          {
             png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,
@@ -1208,7 +1272,7 @@
          }
 
          if (png_ptr->do_filter == PNG_NO_FILTERS)
-#endif /* PNG_NO_WRITE_FILTER */
+#endif /* PNG_WRITE_FILTER_SUPPORTED */
             png_ptr->do_filter = PNG_FILTER_NONE;
       }
    }
@@ -1223,129 +1287,25 @@
  * filtered data going to zlib more consistent, hopefully resulting in
  * better compression.
  */
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)      /* GRR 970116 */
+#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED      /* GRR 970116 */
 void PNGAPI
 png_set_filter_heuristics(png_structp png_ptr, int heuristic_method,
    int num_weights, png_doublep filter_weights,
    png_doublep filter_costs)
 {
-   int i;
-
-   png_debug(1, "in png_set_filter_heuristics\n");
-   if (png_ptr == NULL)
-      return;
-   if (heuristic_method >= PNG_FILTER_HEURISTIC_LAST)
-   {
-      png_warning(png_ptr, "Unknown filter heuristic method");
-      return;
-   }
-
-   if (heuristic_method == PNG_FILTER_HEURISTIC_DEFAULT)
-   {
-      heuristic_method = PNG_FILTER_HEURISTIC_UNWEIGHTED;
-   }
-
-   if (num_weights < 0 || filter_weights == NULL ||
-      heuristic_method == PNG_FILTER_HEURISTIC_UNWEIGHTED)
-   {
-      num_weights = 0;
-   }
-
-   png_ptr->num_prev_filters = (png_byte)num_weights;
-   png_ptr->heuristic_method = (png_byte)heuristic_method;
-
-   if (num_weights > 0)
-   {
-      if (png_ptr->prev_filters == NULL)
-      {
-         png_ptr->prev_filters = (png_bytep)png_malloc(png_ptr,
-            (png_uint_32)(png_sizeof(png_byte) * num_weights));
-
-         /* To make sure that the weighting starts out fairly */
-         for (i = 0; i < num_weights; i++)
-         {
-            png_ptr->prev_filters[i] = 255;
-         }
-      }
-
-      if (png_ptr->filter_weights == NULL)
-      {
-         png_ptr->filter_weights = (png_uint_16p)png_malloc(png_ptr,
-            (png_uint_32)(png_sizeof(png_uint_16) * num_weights));
-
-         png_ptr->inv_filter_weights = (png_uint_16p)png_malloc(png_ptr,
-            (png_uint_32)(png_sizeof(png_uint_16) * num_weights));
-         for (i = 0; i < num_weights; i++)
-         {
-            png_ptr->inv_filter_weights[i] =
-            png_ptr->filter_weights[i] = PNG_WEIGHT_FACTOR;
-         }
-      }
-
-      for (i = 0; i < num_weights; i++)
-      {
-         if (filter_weights[i] < 0.0)
-         {
-            png_ptr->inv_filter_weights[i] =
-            png_ptr->filter_weights[i] = PNG_WEIGHT_FACTOR;
-         }
-         else
-         {
-            png_ptr->inv_filter_weights[i] =
-               (png_uint_16)((double)PNG_WEIGHT_FACTOR*filter_weights[i]+0.5);
-            png_ptr->filter_weights[i] =
-               (png_uint_16)((double)PNG_WEIGHT_FACTOR/filter_weights[i]+0.5);
-         }
-      }
-   }
-
-   /* If, in the future, there are other filter methods, this would
-    * need to be based on png_ptr->filter.
-    */
-   if (png_ptr->filter_costs == NULL)
-   {
-      png_ptr->filter_costs = (png_uint_16p)png_malloc(png_ptr,
-         (png_uint_32)(png_sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST));
-
-      png_ptr->inv_filter_costs = (png_uint_16p)png_malloc(png_ptr,
-         (png_uint_32)(png_sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST));
-
-      for (i = 0; i < PNG_FILTER_VALUE_LAST; i++)
-      {
-         png_ptr->inv_filter_costs[i] =
-         png_ptr->filter_costs[i] = PNG_COST_FACTOR;
-      }
-   }
-
-   /* Here is where we set the relative costs of the different filters.  We
-    * should take the desired compression level into account when setting
-    * the costs, so that Paeth, for instance, has a high relative cost at low
-    * compression levels, while it has a lower relative cost at higher
-    * compression settings.  The filter types are in order of increasing
-    * relative cost, so it would be possible to do this with an algorithm.
-    */
-   for (i = 0; i < PNG_FILTER_VALUE_LAST; i++)
-   {
-      if (filter_costs == NULL || filter_costs[i] < 0.0)
-      {
-         png_ptr->inv_filter_costs[i] =
-         png_ptr->filter_costs[i] = PNG_COST_FACTOR;
-      }
-      else if (filter_costs[i] >= 1.0)
-      {
-         png_ptr->inv_filter_costs[i] =
-            (png_uint_16)((double)PNG_COST_FACTOR / filter_costs[i] + 0.5);
-         png_ptr->filter_costs[i] =
-            (png_uint_16)((double)PNG_COST_FACTOR * filter_costs[i] + 0.5);
-      }
-   }
+   PNG_UNUSED(png_ptr)
+   PNG_UNUSED(heuristic_method)
+   PNG_UNUSED(num_weights)
+   PNG_UNUSED(filter_weights)
+   PNG_UNUSED(filter_costs)
 }
 #endif /* PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */
 
 void PNGAPI
 png_set_compression_level(png_structp png_ptr, int level)
 {
-   png_debug(1, "in png_set_compression_level\n");
+   png_debug(1, "in png_set_compression_level");
+
    if (png_ptr == NULL)
       return;
    png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_LEVEL;
@@ -1355,7 +1315,8 @@
 void PNGAPI
 png_set_compression_mem_level(png_structp png_ptr, int mem_level)
 {
-   png_debug(1, "in png_set_compression_mem_level\n");
+   png_debug(1, "in png_set_compression_mem_level");
+
    if (png_ptr == NULL)
       return;
    png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL;
@@ -1365,7 +1326,8 @@
 void PNGAPI
 png_set_compression_strategy(png_structp png_ptr, int strategy)
 {
-   png_debug(1, "in png_set_compression_strategy\n");
+   png_debug(1, "in png_set_compression_strategy");
+
    if (png_ptr == NULL)
       return;
    png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_STRATEGY;
@@ -1382,11 +1344,11 @@
    else if (window_bits < 8)
       png_warning(png_ptr, "Only compression windows >= 256 supported by PNG");
 #ifndef WBITS_8_OK
-   /* avoid libpng bug with 256-byte windows */
+   /* Avoid libpng bug with 256-byte windows */
    if (window_bits == 8)
      {
        png_warning(png_ptr, "Compression window is being reset to 512");
-       window_bits=9;
+       window_bits = 9;
      }
 #endif
    png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_WINDOW_BITS;
@@ -1396,7 +1358,8 @@
 void PNGAPI
 png_set_compression_method(png_structp png_ptr, int method)
 {
-   png_debug(1, "in png_set_compression_method\n");
+   png_debug(1, "in png_set_compression_method");
+
    if (png_ptr == NULL)
       return;
    if (method != 8)
@@ -1413,12 +1376,13 @@
    png_ptr->write_row_fn = write_row_fn;
 }
 
-#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
+#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
 void PNGAPI
 png_set_write_user_transform_fn(png_structp png_ptr, png_user_transform_ptr
    write_user_transform_fn)
 {
-   png_debug(1, "in png_set_write_user_transform_fn\n");
+   png_debug(1, "in png_set_write_user_transform_fn");
+
    if (png_ptr == NULL)
       return;
    png_ptr->transformations |= PNG_USER_TRANSFORM;
@@ -1427,88 +1391,89 @@
 #endif
 
 
-#if defined(PNG_INFO_IMAGE_SUPPORTED)
+#ifdef PNG_INFO_IMAGE_SUPPORTED
 void PNGAPI
 png_write_png(png_structp png_ptr, png_infop info_ptr,
               int transforms, voidp params)
 {
    if (png_ptr == NULL || info_ptr == NULL)
       return;
-#if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
-   /* invert the alpha channel from opacity to transparency */
-   if (transforms & PNG_TRANSFORM_INVERT_ALPHA)
-       png_set_invert_alpha(png_ptr);
-#endif
 
    /* Write the file header information. */
    png_write_info(png_ptr, info_ptr);
 
    /* ------ these transformations don't touch the info structure ------- */
 
-#if defined(PNG_WRITE_INVERT_SUPPORTED)
-   /* invert monochrome pixels */
+#ifdef PNG_WRITE_INVERT_SUPPORTED
+   /* Invert monochrome pixels */
    if (transforms & PNG_TRANSFORM_INVERT_MONO)
-       png_set_invert_mono(png_ptr);
+      png_set_invert_mono(png_ptr);
 #endif
 
-#if defined(PNG_WRITE_SHIFT_SUPPORTED)
+#ifdef PNG_WRITE_SHIFT_SUPPORTED
    /* Shift the pixels up to a legal bit depth and fill in
     * as appropriate to correctly scale the image.
     */
    if ((transforms & PNG_TRANSFORM_SHIFT)
                && (info_ptr->valid & PNG_INFO_sBIT))
-       png_set_shift(png_ptr, &info_ptr->sig_bit);
+      png_set_shift(png_ptr, &info_ptr->sig_bit);
 #endif
 
-#if defined(PNG_WRITE_PACK_SUPPORTED)
-   /* pack pixels into bytes */
+#ifdef PNG_WRITE_PACK_SUPPORTED
+   /* Pack pixels into bytes */
    if (transforms & PNG_TRANSFORM_PACKING)
        png_set_packing(png_ptr);
 #endif
 
-#if defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
-   /* swap location of alpha bytes from ARGB to RGBA */
+#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
+   /* Swap location of alpha bytes from ARGB to RGBA */
    if (transforms & PNG_TRANSFORM_SWAP_ALPHA)
-       png_set_swap_alpha(png_ptr);
+      png_set_swap_alpha(png_ptr);
 #endif
 
-#if defined(PNG_WRITE_FILLER_SUPPORTED)
-   /* Get rid of filler (OR ALPHA) bytes, pack XRGB/RGBX/ARGB/RGBA into
-    * RGB (4 channels -> 3 channels). The second parameter is not used.
-    */
-   if (transforms & PNG_TRANSFORM_STRIP_FILLER)
-       png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);
+#ifdef PNG_WRITE_FILLER_SUPPORTED
+   /* Pack XRGB/RGBX/ARGB/RGBA into * RGB (4 channels -> 3 channels) */
+   if (transforms & PNG_TRANSFORM_STRIP_FILLER_AFTER)
+      png_set_filler(png_ptr, 0, PNG_FILLER_AFTER);
+   else if (transforms & PNG_TRANSFORM_STRIP_FILLER_BEFORE)
+      png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);
 #endif
 
-#if defined(PNG_WRITE_BGR_SUPPORTED)
-   /* flip BGR pixels to RGB */
+#ifdef PNG_WRITE_BGR_SUPPORTED
+   /* Flip BGR pixels to RGB */
    if (transforms & PNG_TRANSFORM_BGR)
-       png_set_bgr(png_ptr);
+      png_set_bgr(png_ptr);
 #endif
 
-#if defined(PNG_WRITE_SWAP_SUPPORTED)
-   /* swap bytes of 16-bit files to most significant byte first */
+#ifdef PNG_WRITE_SWAP_SUPPORTED
+   /* Swap bytes of 16-bit files to most significant byte first */
    if (transforms & PNG_TRANSFORM_SWAP_ENDIAN)
-       png_set_swap(png_ptr);
+      png_set_swap(png_ptr);
 #endif
 
-#if defined(PNG_WRITE_PACKSWAP_SUPPORTED)
-   /* swap bits of 1, 2, 4 bit packed pixel formats */
+#ifdef PNG_WRITE_PACKSWAP_SUPPORTED
+   /* Swap bits of 1, 2, 4 bit packed pixel formats */
    if (transforms & PNG_TRANSFORM_PACKSWAP)
-       png_set_packswap(png_ptr);
+      png_set_packswap(png_ptr);
+#endif
+
+#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
+   /* Invert the alpha channel from opacity to transparency */
+   if (transforms & PNG_TRANSFORM_INVERT_ALPHA)
+      png_set_invert_alpha(png_ptr);
 #endif
 
    /* ----------------------- end of transformations ------------------- */
 
-   /* write the bits */
+   /* Write the bits */
    if (info_ptr->valid & PNG_INFO_IDAT)
        png_write_image(png_ptr, info_ptr->row_pointers);
 
    /* It is REQUIRED to call this to finish writing the rest of the file */
    png_write_end(png_ptr, info_ptr);
 
-   transforms = transforms; /* quiet compiler warnings */
-   params = params;
+   PNG_UNUSED(transforms) /* Quiet compiler warnings */
+   PNG_UNUSED(params)
 }
 #endif
 #endif /* PNG_WRITE_SUPPORTED */
diff -Naur libAfterImage-1.20/libpng/pngwtran.c root/graf2d/asimage/src/libAfterImage/libpng/pngwtran.c
--- libAfterImage-1.20/libpng/pngwtran.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngwtran.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,14 +1,18 @@
 
 /* pngwtran.c - transforms the data in a row for PNG writers
  *
- * Last changed in libpng 1.2.9 April 14, 2006
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.43 [February 25, 2010]
+ * Copyright (c) 1998-2010 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
  */
 
 #define PNG_INTERNAL
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
 #ifdef PNG_WRITE_SUPPORTED
 
@@ -18,15 +22,16 @@
 void /* PRIVATE */
 png_do_write_transformations(png_structp png_ptr)
 {
-   png_debug(1, "in png_do_write_transformations\n");
+   png_debug(1, "in png_do_write_transformations");
 
    if (png_ptr == NULL)
       return;
 
-#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
+#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
    if (png_ptr->transformations & PNG_USER_TRANSFORM)
-      if(png_ptr->write_user_transform_fn != NULL)
-        (*(png_ptr->write_user_transform_fn)) /* user write transform function */
+      if (png_ptr->write_user_transform_fn != NULL)
+        (*(png_ptr->write_user_transform_fn)) /* User write transform
+                                                 function */
           (png_ptr,                    /* png_ptr */
            &(png_ptr->row_info),       /* row_info:     */
              /*  png_uint_32 width;          width of row */
@@ -37,48 +42,48 @@
              /*  png_byte pixel_depth;       bits per pixel (depth*channels) */
            png_ptr->row_buf + 1);      /* start of pixel data for row */
 #endif
-#if defined(PNG_WRITE_FILLER_SUPPORTED)
+#ifdef PNG_WRITE_FILLER_SUPPORTED
    if (png_ptr->transformations & PNG_FILLER)
       png_do_strip_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
          png_ptr->flags);
 #endif
-#if defined(PNG_WRITE_PACKSWAP_SUPPORTED)
+#ifdef PNG_WRITE_PACKSWAP_SUPPORTED
    if (png_ptr->transformations & PNG_PACKSWAP)
       png_do_packswap(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
-#if defined(PNG_WRITE_PACK_SUPPORTED)
+#ifdef PNG_WRITE_PACK_SUPPORTED
    if (png_ptr->transformations & PNG_PACK)
       png_do_pack(&(png_ptr->row_info), png_ptr->row_buf + 1,
          (png_uint_32)png_ptr->bit_depth);
 #endif
-#if defined(PNG_WRITE_SWAP_SUPPORTED)
+#ifdef PNG_WRITE_SWAP_SUPPORTED
    if (png_ptr->transformations & PNG_SWAP_BYTES)
       png_do_swap(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
-#if defined(PNG_WRITE_SHIFT_SUPPORTED)
+#ifdef PNG_WRITE_SHIFT_SUPPORTED
    if (png_ptr->transformations & PNG_SHIFT)
       png_do_shift(&(png_ptr->row_info), png_ptr->row_buf + 1,
          &(png_ptr->shift));
 #endif
-#if defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
+#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
    if (png_ptr->transformations & PNG_SWAP_ALPHA)
       png_do_write_swap_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
-#if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
+#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
    if (png_ptr->transformations & PNG_INVERT_ALPHA)
       png_do_write_invert_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
-#if defined(PNG_WRITE_BGR_SUPPORTED)
+#ifdef PNG_WRITE_BGR_SUPPORTED
    if (png_ptr->transformations & PNG_BGR)
       png_do_bgr(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
-#if defined(PNG_WRITE_INVERT_SUPPORTED)
+#ifdef PNG_WRITE_INVERT_SUPPORTED
    if (png_ptr->transformations & PNG_INVERT_MONO)
       png_do_invert(&(png_ptr->row_info), png_ptr->row_buf + 1);
 #endif
 }
 
-#if defined(PNG_WRITE_PACK_SUPPORTED)
+#ifdef PNG_WRITE_PACK_SUPPORTED
 /* Pack pixels into bytes.  Pass the true bit depth in bit_depth.  The
  * row_info bit depth should be 8 (one pixel per byte).  The channels
  * should be 1 (this only happens on grayscale and paletted images).
@@ -86,9 +91,10 @@
 void /* PRIVATE */
 png_do_pack(png_row_infop row_info, png_bytep row, png_uint_32 bit_depth)
 {
-   png_debug(1, "in png_do_pack\n");
+   png_debug(1, "in png_do_pack");
+
    if (row_info->bit_depth == 8 &&
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+#ifdef PNG_USELESS_TESTS_SUPPORTED
        row != NULL && row_info != NULL &&
 #endif
       row_info->channels == 1)
@@ -201,7 +207,7 @@
 }
 #endif
 
-#if defined(PNG_WRITE_SHIFT_SUPPORTED)
+#ifdef PNG_WRITE_SHIFT_SUPPORTED
 /* Shift pixel values to take advantage of whole range.  Pass the
  * true number of bits in bit_depth.  The row should be packed
  * according to row_info->bit_depth.  Thus, if you had a row of
@@ -212,8 +218,9 @@
 void /* PRIVATE */
 png_do_shift(png_row_infop row_info, png_bytep row, png_color_8p bit_depth)
 {
-   png_debug(1, "in png_do_shift\n");
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+   png_debug(1, "in png_do_shift");
+
+#ifdef PNG_USELESS_TESTS_SUPPORTED
    if (row != NULL && row_info != NULL &&
 #else
    if (
@@ -248,7 +255,7 @@
          channels++;
       }
 
-      /* with low row depths, could only be grayscale, so one channel */
+      /* With low row depths, could only be grayscale, so one channel */
       if (row_info->bit_depth < 8)
       {
          png_bytep bp = row;
@@ -332,12 +339,13 @@
 }
 #endif
 
-#if defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
+#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
 void /* PRIVATE */
 png_do_write_swap_alpha(png_row_infop row_info, png_bytep row)
 {
-   png_debug(1, "in png_do_write_swap_alpha\n");
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+   png_debug(1, "in png_do_write_swap_alpha");
+
+#ifdef PNG_USELESS_TESTS_SUPPORTED
    if (row != NULL && row_info != NULL)
 #endif
    {
@@ -420,12 +428,13 @@
 }
 #endif
 
-#if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
+#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
 void /* PRIVATE */
 png_do_write_invert_alpha(png_row_infop row_info, png_bytep row)
 {
-   png_debug(1, "in png_do_write_invert_alpha\n");
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+   png_debug(1, "in png_do_write_invert_alpha");
+
+#ifdef PNG_USELESS_TESTS_SUPPORTED
    if (row != NULL && row_info != NULL)
 #endif
    {
@@ -439,7 +448,7 @@
             png_uint_32 row_width = row_info->width;
             for (i = 0, sp = dp = row; i < row_width; i++)
             {
-               /* does nothing
+               /* Does nothing
                *(dp++) = *(sp++);
                *(dp++) = *(sp++);
                *(dp++) = *(sp++);
@@ -457,7 +466,7 @@
 
             for (i = 0, sp = dp = row; i < row_width; i++)
             {
-               /* does nothing
+               /* Does nothing
                *(dp++) = *(sp++);
                *(dp++) = *(sp++);
                *(dp++) = *(sp++);
@@ -495,7 +504,7 @@
 
             for (i = 0, sp = dp = row; i < row_width; i++)
             {
-               /* does nothing
+               /* Does nothing
                *(dp++) = *(sp++);
                *(dp++) = *(sp++);
                */
@@ -509,14 +518,15 @@
 }
 #endif
 
-#if defined(PNG_MNG_FEATURES_SUPPORTED)
-/* undoes intrapixel differencing  */
+#ifdef PNG_MNG_FEATURES_SUPPORTED
+/* Undoes intrapixel differencing  */
 void /* PRIVATE */
 png_do_write_intrapixel(png_row_infop row_info, png_bytep row)
 {
-   png_debug(1, "in png_do_write_intrapixel\n");
+   png_debug(1, "in png_do_write_intrapixel");
+
    if (
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+#ifdef PNG_USELESS_TESTS_SUPPORTED
        row != NULL && row_info != NULL &&
 #endif
        (row_info->color_type & PNG_COLOR_MASK_COLOR))
@@ -558,8 +568,8 @@
             png_uint_32 s0   = (*(rp  ) << 8) | *(rp+1);
             png_uint_32 s1   = (*(rp+2) << 8) | *(rp+3);
             png_uint_32 s2   = (*(rp+4) << 8) | *(rp+5);
-            png_uint_32 red  = (png_uint_32)((s0-s1) & 0xffffL);
-            png_uint_32 blue = (png_uint_32)((s2-s1) & 0xffffL);
+            png_uint_32 red  = (png_uint_32)((s0 - s1) & 0xffffL);
+            png_uint_32 blue = (png_uint_32)((s2 - s1) & 0xffffL);
             *(rp  ) = (png_byte)((red >> 8) & 0xff);
             *(rp+1) = (png_byte)(red & 0xff);
             *(rp+4) = (png_byte)((blue >> 8) & 0xff);
diff -Naur libAfterImage-1.20/libpng/pngwutil.c root/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c
--- libAfterImage-1.20/libpng/pngwutil.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c	2018-12-08 08:18:38.000000000 +0100
@@ -1,14 +1,18 @@
 
 /* pngwutil.c - utilities to write a PNG file
  *
- * Last changed in libpng 1.2.20 Septhember 3, 2007
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Last changed in libpng 1.2.54 [November 12, 2015]
+ * Copyright (c) 1998-2015 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
  */
 
 #define PNG_INTERNAL
+#define PNG_NO_PEDANTIC_WARNINGS
 #include "png.h"
 #ifdef PNG_WRITE_SUPPORTED
 
@@ -49,6 +53,24 @@
    buf[1] = (png_byte)(i & 0xff);
 }
 
+/* Simple function to write the signature.  If we have already written
+ * the magic bytes of the signature, or more likely, the PNG stream is
+ * being embedded into another stream and doesn't need its own signature,
+ * we should call png_set_sig_bytes() to tell libpng how many of the
+ * bytes have already been written.
+ */
+void /* PRIVATE */
+png_write_sig(png_structp png_ptr)
+{
+   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
+
+   /* Write the rest of the 8 byte signature */
+   png_write_data(png_ptr, &png_signature[png_ptr->sig_bytes],
+      (png_size_t)(8 - png_ptr->sig_bytes));
+   if (png_ptr->sig_bytes < 3)
+      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
+}
+
 /* Write a PNG chunk all at once.  The type is an array of ASCII characters
  * representing the chunk name.  The array must be at least 4 bytes in
  * length, and does not need to be null terminated.  To be safe, pass the
@@ -62,9 +84,10 @@
 png_write_chunk(png_structp png_ptr, png_bytep chunk_name,
    png_bytep data, png_size_t length)
 {
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL)
+      return;
    png_write_chunk_start(png_ptr, chunk_name, (png_uint_32)length);
-   png_write_chunk_data(png_ptr, data, length);
+   png_write_chunk_data(png_ptr, data, (png_size_t)length);
    png_write_chunk_end(png_ptr);
 }
 
@@ -76,17 +99,22 @@
 png_write_chunk_start(png_structp png_ptr, png_bytep chunk_name,
    png_uint_32 length)
 {
-   png_byte buf[4];
-   png_debug2(0, "Writing %s chunk (%lu bytes)\n", chunk_name, length);
-   if(png_ptr == NULL) return;
+   png_byte buf[8];
+
+   png_debug2(0, "Writing %s chunk, length = %lu", chunk_name,
+      (unsigned long)length);
+
+   if (png_ptr == NULL)
+      return;
 
-   /* write the length */
-   png_save_uint_32(buf, length);
-   png_write_data(png_ptr, buf, (png_size_t)4);
 
-   /* write the chunk name */
-   png_write_data(png_ptr, chunk_name, (png_size_t)4);
-   /* reset the crc and run it over the chunk name */
+   /* Write the length and the chunk name */
+   png_save_uint_32(buf, length);
+   png_memcpy(buf + 4, chunk_name, 4);
+   png_write_data(png_ptr, buf, (png_size_t)8);
+   /* Put the chunk name into png_ptr->chunk_name */
+   png_memcpy(png_ptr->chunk_name, chunk_name, 4);
+   /* Reset the crc and run it over the chunk name */
    png_reset_crc(png_ptr);
    png_calculate_crc(png_ptr, chunk_name, (png_size_t)4);
 }
@@ -99,12 +127,16 @@
 void PNGAPI
 png_write_chunk_data(png_structp png_ptr, png_bytep data, png_size_t length)
 {
-   /* write the data, and run the CRC over it */
-   if(png_ptr == NULL) return;
+   /* Write the data, and run the CRC over it */
+   if (png_ptr == NULL)
+      return;
    if (data != NULL && length > 0)
    {
-      png_calculate_crc(png_ptr, data, length);
       png_write_data(png_ptr, data, length);
+      /* Update the CRC after writing the data,
+       * in case that the user I/O routine alters it.
+       */
+      png_calculate_crc(png_ptr, data, length);
    }
 }
 
@@ -114,34 +146,16 @@
 {
    png_byte buf[4];
 
-   if(png_ptr == NULL) return;
+   if (png_ptr == NULL) return;
 
-   /* write the crc */
+   /* Write the crc in a single operation */
    png_save_uint_32(buf, png_ptr->crc);
 
    png_write_data(png_ptr, buf, (png_size_t)4);
 }
 
-/* Simple function to write the signature.  If we have already written
- * the magic bytes of the signature, or more likely, the PNG stream is
- * being embedded into another stream and doesn't need its own signature,
- * we should call png_set_sig_bytes() to tell libpng how many of the
- * bytes have already been written.
- */
-void /* PRIVATE */
-png_write_sig(png_structp png_ptr)
-{
-   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
-   /* write the rest of the 8 byte signature */
-   png_write_data(png_ptr, &png_signature[png_ptr->sig_bytes],
-      (png_size_t)8 - png_ptr->sig_bytes);
-   if(png_ptr->sig_bytes < 3)
-      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
-}
-
 #if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_iCCP_SUPPORTED)
-/*
- * This pair of functions encapsulates the operation of (a) compressing a
+/* This pair of functions encapsulates the operation of (a) compressing a
  * text string, and (b) issuing it later as a series of chunk data writes.
  * The compression_state structure is shared context for these functions
  * set up by the caller in order to make the whole mess thread-safe.
@@ -149,14 +163,14 @@
 
 typedef struct
 {
-    char *input;   /* the uncompressed input data */
-    int input_len;   /* its length */
-    int num_output_ptr; /* number of output pointers used */
-    int max_output_ptr; /* size of output_ptr */
-    png_charpp output_ptr; /* array of pointers to output */
+   char *input;   /* The uncompressed input data */
+   int input_len;   /* Its length */
+   int num_output_ptr; /* Number of output pointers used */
+   int max_output_ptr; /* Size of output_ptr */
+   png_charpp output_ptr; /* Array of pointers to output */
 } compression_state;
 
-/* compress given text into storage in the png_ptr structure */
+/* Compress given text into storage in the png_ptr structure */
 static int /* PRIVATE */
 png_text_compress(png_structp png_ptr,
         png_charp text, png_size_t text_len, int compression,
@@ -170,7 +184,7 @@
    comp->input = NULL;
    comp->input_len = 0;
 
-   /* we may just want to pass the text right through */
+   /* We may just want to pass the text right through */
    if (compression == PNG_TEXT_COMPRESSION_NONE)
    {
        comp->input = text;
@@ -180,7 +194,7 @@
 
    if (compression >= PNG_TEXT_COMPRESSION_LAST)
    {
-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
+#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
       char msg[50];
       png_snprintf(msg, 50, "Unknown compression type %d", compression);
       png_warning(png_ptr, msg);
@@ -204,29 +218,29 @@
     * wouldn't cause a failure, just a slowdown due to swapping).
     */
 
-   /* set up the compression buffers */
+   /* Set up the compression buffers */
    png_ptr->zstream.avail_in = (uInt)text_len;
    png_ptr->zstream.next_in = (Bytef *)text;
    png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
    png_ptr->zstream.next_out = (Bytef *)png_ptr->zbuf;
 
-   /* this is the same compression loop as in png_write_row() */
+   /* This is the same compression loop as in png_write_row() */
    do
    {
-      /* compress the data */
+      /* Compress the data */
       ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);
       if (ret != Z_OK)
       {
-         /* error */
+         /* Error */
          if (png_ptr->zstream.msg != NULL)
             png_error(png_ptr, png_ptr->zstream.msg);
          else
             png_error(png_ptr, "zlib error");
       }
-      /* check to see if we need more room */
+      /* Check to see if we need more room */
       if (!(png_ptr->zstream.avail_out))
       {
-         /* make sure the output array has room */
+         /* Make sure the output array has room */
          if (comp->num_output_ptr >= comp->max_output_ptr)
          {
             int old_max;
@@ -239,20 +253,21 @@
 
                old_ptr = comp->output_ptr;
                comp->output_ptr = (png_charpp)png_malloc(png_ptr,
-                  (png_uint_32)(comp->max_output_ptr *
-                  png_sizeof (png_charpp)));
+                  (png_uint_32)
+                  (comp->max_output_ptr * png_sizeof(png_charp)));
                png_memcpy(comp->output_ptr, old_ptr, old_max
-                  * png_sizeof (png_charp));
+                  * png_sizeof(png_charp));
                png_free(png_ptr, old_ptr);
             }
             else
                comp->output_ptr = (png_charpp)png_malloc(png_ptr,
-                  (png_uint_32)(comp->max_output_ptr *
-                  png_sizeof (png_charp)));
+                  (png_uint_32)
+                  (comp->max_output_ptr * png_sizeof(png_charp)));
          }
 
-         /* save the data */
-         comp->output_ptr[comp->num_output_ptr] = (png_charp)png_malloc(png_ptr,
+         /* Save the data */
+         comp->output_ptr[comp->num_output_ptr] =
+            (png_charp)png_malloc(png_ptr,
             (png_uint_32)png_ptr->zbuf_size);
          png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,
             png_ptr->zbuf_size);
@@ -262,21 +277,21 @@
          png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
          png_ptr->zstream.next_out = png_ptr->zbuf;
       }
-   /* continue until we don't have any more to compress */
+   /* Continue until we don't have any more to compress */
    } while (png_ptr->zstream.avail_in);
 
-   /* finish the compression */
+   /* Finish the compression */
    do
    {
-      /* tell zlib we are finished */
+      /* Tell zlib we are finished */
       ret = deflate(&png_ptr->zstream, Z_FINISH);
 
       if (ret == Z_OK)
       {
-         /* check to see if we need more room */
+         /* Check to see if we need more room */
          if (!(png_ptr->zstream.avail_out))
          {
-            /* check to make sure our output array has room */
+            /* Check to make sure our output array has room */
             if (comp->num_output_ptr >= comp->max_output_ptr)
             {
                int old_max;
@@ -291,20 +306,21 @@
                   /* This could be optimized to realloc() */
                   comp->output_ptr = (png_charpp)png_malloc(png_ptr,
                      (png_uint_32)(comp->max_output_ptr *
-                     png_sizeof (png_charpp)));
+                     png_sizeof(png_charp)));
                   png_memcpy(comp->output_ptr, old_ptr,
-                     old_max * png_sizeof (png_charp));
+                     old_max * png_sizeof(png_charp));
                   png_free(png_ptr, old_ptr);
                }
                else
                   comp->output_ptr = (png_charpp)png_malloc(png_ptr,
                      (png_uint_32)(comp->max_output_ptr *
-                     png_sizeof (png_charp)));
+                     png_sizeof(png_charp)));
             }
 
-            /* save off the data */
+            /* Save the data */
             comp->output_ptr[comp->num_output_ptr] =
-               (png_charp)png_malloc(png_ptr, (png_uint_32)png_ptr->zbuf_size);
+               (png_charp)png_malloc(png_ptr,
+               (png_uint_32)png_ptr->zbuf_size);
             png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,
                png_ptr->zbuf_size);
             comp->num_output_ptr++;
@@ -316,7 +332,7 @@
       }
       else if (ret != Z_STREAM_END)
       {
-         /* we got an error */
+         /* We got an error */
          if (png_ptr->zstream.msg != NULL)
             png_error(png_ptr, png_ptr->zstream.msg);
          else
@@ -324,7 +340,7 @@
       }
    } while (ret != Z_STREAM_END);
 
-   /* text length is number of buffers plus last buffer */
+   /* Text length is number of buffers plus last buffer */
    text_len = png_ptr->zbuf_size * comp->num_output_ptr;
    if (png_ptr->zstream.avail_out < png_ptr->zbuf_size)
       text_len += png_ptr->zbuf_size - (png_size_t)png_ptr->zstream.avail_out;
@@ -332,37 +348,37 @@
    return((int)text_len);
 }
 
-/* ship the compressed text out via chunk writes */
+/* Ship the compressed text out via chunk writes */
 static void /* PRIVATE */
 png_write_compressed_data_out(png_structp png_ptr, compression_state *comp)
 {
    int i;
 
-   /* handle the no-compression case */
+   /* Handle the no-compression case */
    if (comp->input)
    {
-       png_write_chunk_data(png_ptr, (png_bytep)comp->input,
+      png_write_chunk_data(png_ptr, (png_bytep)comp->input,
                             (png_size_t)comp->input_len);
-       return;
+      return;
    }
 
-   /* write saved output buffers, if any */
+   /* Write saved output buffers, if any */
    for (i = 0; i < comp->num_output_ptr; i++)
    {
-      png_write_chunk_data(png_ptr,(png_bytep)comp->output_ptr[i],
-         png_ptr->zbuf_size);
+      png_write_chunk_data(png_ptr, (png_bytep)comp->output_ptr[i],
+         (png_size_t)png_ptr->zbuf_size);
       png_free(png_ptr, comp->output_ptr[i]);
-      comp->output_ptr[i]=NULL;
+       comp->output_ptr[i]=NULL;
    }
    if (comp->max_output_ptr != 0)
       png_free(png_ptr, comp->output_ptr);
-      comp->output_ptr=NULL;
-   /* write anything left in zbuf */
+       comp->output_ptr=NULL;
+   /* Write anything left in zbuf */
    if (png_ptr->zstream.avail_out < (png_uint_32)png_ptr->zbuf_size)
       png_write_chunk_data(png_ptr, png_ptr->zbuf,
-         png_ptr->zbuf_size - png_ptr->zstream.avail_out);
+         (png_size_t)(png_ptr->zbuf_size - png_ptr->zstream.avail_out));
 
-   /* reset zlib for another zTXt/iTXt or image data */
+   /* Reset zlib for another zTXt/iTXt or image data */
    deflateReset(&png_ptr->zstream);
    png_ptr->zstream.data_type = Z_BINARY;
 }
@@ -380,9 +396,12 @@
 #ifdef PNG_USE_LOCAL_ARRAYS
    PNG_IHDR;
 #endif
-   png_byte buf[13]; /* buffer to store the IHDR info */
+   int ret;
+
+   png_byte buf[13]; /* Buffer to store the IHDR info */
+
+   png_debug(1, "in png_write_IHDR");
 
-   png_debug(1, "in png_write_IHDR\n");
    /* Check that we have valid input data from the application info */
    switch (color_type)
    {
@@ -394,7 +413,8 @@
             case 4:
             case 8:
             case 16: png_ptr->channels = 1; break;
-            default: png_error(png_ptr,"Invalid bit depth for grayscale image");
+            default: png_error(png_ptr,
+                         "Invalid bit depth for grayscale image");
          }
          break;
       case PNG_COLOR_TYPE_RGB:
@@ -442,7 +462,7 @@
     * 5. The color_type is RGB or RGBA
     */
    if (
-#if defined(PNG_MNG_FEATURES_SUPPORTED)
+#ifdef PNG_MNG_FEATURES_SUPPORTED
       !((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
       ((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE) == 0) &&
       (color_type == PNG_COLOR_TYPE_RGB ||
@@ -466,11 +486,11 @@
    interlace_type=PNG_INTERLACE_NONE;
 #endif
 
-   /* save off the relevent information */
+   /* Save the relevent information */
    png_ptr->bit_depth = (png_byte)bit_depth;
    png_ptr->color_type = (png_byte)color_type;
    png_ptr->interlaced = (png_byte)interlace_type;
-#if defined(PNG_MNG_FEATURES_SUPPORTED)
+#ifdef PNG_MNG_FEATURES_SUPPORTED
    png_ptr->filter_type = (png_byte)filter_type;
 #endif
    png_ptr->compression_type = (png_byte)compression_type;
@@ -479,12 +499,12 @@
 
    png_ptr->pixel_depth = (png_byte)(bit_depth * png_ptr->channels);
    png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, width);
-   /* set the usr info, so any transformations can modify it */
+   /* Set the usr info, so any transformations can modify it */
    png_ptr->usr_width = png_ptr->width;
    png_ptr->usr_bit_depth = png_ptr->bit_depth;
    png_ptr->usr_channels = png_ptr->channels;
 
-   /* pack the header information into the buffer */
+   /* Pack the header information into the buffer */
    png_save_uint_32(buf, width);
    png_save_uint_32(buf + 4, height);
    buf[8] = (png_byte)bit_depth;
@@ -493,10 +513,10 @@
    buf[11] = (png_byte)filter_type;
    buf[12] = (png_byte)interlace_type;
 
-   /* write the chunk */
-   png_write_chunk(png_ptr, png_IHDR, buf, (png_size_t)13);
+   /* Write the chunk */
+   png_write_chunk(png_ptr, (png_bytep)png_IHDR, buf, (png_size_t)13);
 
-   /* initialize zlib with PNG info */
+   /* Initialize zlib with PNG info */
    png_ptr->zstream.zalloc = png_zalloc;
    png_ptr->zstream.zfree = png_zfree;
    png_ptr->zstream.opaque = (voidpf)png_ptr;
@@ -523,20 +543,29 @@
       png_ptr->zlib_window_bits = 15;
    if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_METHOD))
       png_ptr->zlib_method = 8;
-   if (deflateInit2(&png_ptr->zstream, png_ptr->zlib_level,
-      png_ptr->zlib_method, png_ptr->zlib_window_bits,
-      png_ptr->zlib_mem_level, png_ptr->zlib_strategy) != Z_OK)
-       png_error(png_ptr, "zlib failed to initialize compressor");
+   ret = deflateInit2(&png_ptr->zstream, png_ptr->zlib_level,
+         png_ptr->zlib_method, png_ptr->zlib_window_bits,
+         png_ptr->zlib_mem_level, png_ptr->zlib_strategy);
+   if (ret != Z_OK)
+   {
+      if (ret == Z_VERSION_ERROR) png_error(png_ptr,
+          "zlib failed to initialize compressor -- version error");
+      if (ret == Z_STREAM_ERROR) png_error(png_ptr,
+           "zlib failed to initialize compressor -- stream error");
+      if (ret == Z_MEM_ERROR) png_error(png_ptr,
+           "zlib failed to initialize compressor -- mem error");
+      png_error(png_ptr, "zlib failed to initialize compressor");
+   }
    png_ptr->zstream.next_out = png_ptr->zbuf;
    png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
    /* libpng is not interested in zstream.data_type */
-   /* set it to a predefined value, to avoid its evaluation inside zlib */
+   /* Set it to a predefined value, to avoid its evaluation inside zlib */
    png_ptr->zstream.data_type = Z_BINARY;
 
    png_ptr->mode = PNG_HAVE_IHDR;
 }
 
-/* write the palette.  We are careful not to trust png_color to be in the
+/* Write the palette.  We are careful not to trust png_color to be in the
  * correct order for PNG, so people can redefine it to any convenient
  * structure.
  */
@@ -546,16 +575,20 @@
 #ifdef PNG_USE_LOCAL_ARRAYS
    PNG_PLTE;
 #endif
-   png_uint_32 i;
+   png_uint_32 max_palette_length, i;
    png_colorp pal_ptr;
    png_byte buf[3];
 
-   png_debug(1, "in png_write_PLTE\n");
+   png_debug(1, "in png_write_PLTE");
+
+   max_palette_length = (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?
+      (1 << png_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;
+
    if ((
-#if defined(PNG_MNG_FEATURES_SUPPORTED)
+#ifdef PNG_MNG_FEATURES_SUPPORTED
         !(png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) &&
 #endif
-        num_pal == 0) || num_pal > 256)
+       num_pal == 0) || num_pal > max_palette_length)
    {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
@@ -576,10 +609,11 @@
    }
 
    png_ptr->num_palette = (png_uint_16)num_pal;
-   png_debug1(3, "num_palette = %d\n", png_ptr->num_palette);
+   png_debug1(3, "num_palette = %d", png_ptr->num_palette);
 
-   png_write_chunk_start(png_ptr, png_PLTE, num_pal * 3);
-#ifndef PNG_NO_POINTER_INDEXING
+   png_write_chunk_start(png_ptr, (png_bytep)png_PLTE,
+     (png_uint_32)(num_pal * 3));
+#ifdef PNG_POINTER_INDEXING_SUPPORTED
    for (i = 0, pal_ptr = palette; i < num_pal; i++, pal_ptr++)
    {
       buf[0] = pal_ptr->red;
@@ -588,7 +622,9 @@
       png_write_chunk_data(png_ptr, buf, (png_size_t)3);
    }
 #else
-   /* This is a little slower but some buggy compilers need to do this instead */
+   /* This is a little slower but some buggy compilers need to do this
+    * instead
+    */
    pal_ptr=palette;
    for (i = 0; i < num_pal; i++)
    {
@@ -602,14 +638,15 @@
    png_ptr->mode |= PNG_HAVE_PLTE;
 }
 
-/* write an IDAT chunk */
+/* Write an IDAT chunk */
 void /* PRIVATE */
 png_write_IDAT(png_structp png_ptr, png_bytep data, png_size_t length)
 {
 #ifdef PNG_USE_LOCAL_ARRAYS
    PNG_IDAT;
 #endif
-   png_debug(1, "in png_write_IDAT\n");
+
+   png_debug(1, "in png_write_IDAT");
 
    /* Optimize the CMF field in the zlib stream. */
    /* This hack of the zlib stream is compliant to the stream specification. */
@@ -619,9 +656,11 @@
       unsigned int z_cmf = data[0];  /* zlib compression method and flags */
       if ((z_cmf & 0x0f) == 8 && (z_cmf & 0xf0) <= 0x70)
       {
-         /* Avoid memory underflows and multiplication overflows. */
-         /* The conditions below are practically always satisfied;
-            however, they still must be checked. */
+         /* Avoid memory underflows and multiplication overflows.
+          *
+          * The conditions below are practically always satisfied;
+          * however, they still must be checked.
+          */
          if (length >= 2 &&
              png_ptr->height < 16384 && png_ptr->width < 16384)
          {
@@ -650,25 +689,27 @@
             "Invalid zlib compression method or flags in IDAT");
    }
 
-   png_write_chunk(png_ptr, png_IDAT, data, length);
+   png_write_chunk(png_ptr, (png_bytep)png_IDAT, data, length);
    png_ptr->mode |= PNG_HAVE_IDAT;
 }
 
-/* write an IEND chunk */
+/* Write an IEND chunk */
 void /* PRIVATE */
 png_write_IEND(png_structp png_ptr)
 {
 #ifdef PNG_USE_LOCAL_ARRAYS
    PNG_IEND;
 #endif
-   png_debug(1, "in png_write_IEND\n");
-   png_write_chunk(png_ptr, png_IEND, png_bytep_NULL,
+
+   png_debug(1, "in png_write_IEND");
+
+   png_write_chunk(png_ptr, (png_bytep)png_IEND, png_bytep_NULL,
      (png_size_t)0);
    png_ptr->mode |= PNG_HAVE_IEND;
 }
 
-#if defined(PNG_WRITE_gAMA_SUPPORTED)
-/* write a gAMA chunk */
+#ifdef PNG_WRITE_gAMA_SUPPORTED
+/* Write a gAMA chunk */
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 void /* PRIVATE */
 png_write_gAMA(png_structp png_ptr, double file_gamma)
@@ -679,11 +720,12 @@
    png_uint_32 igamma;
    png_byte buf[4];
 
-   png_debug(1, "in png_write_gAMA\n");
+   png_debug(1, "in png_write_gAMA");
+
    /* file_gamma is saved in 1/100,000ths */
    igamma = (png_uint_32)(file_gamma * 100000.0 + 0.5);
    png_save_uint_32(buf, igamma);
-   png_write_chunk(png_ptr, png_gAMA, buf, (png_size_t)4);
+   png_write_chunk(png_ptr, (png_bytep)png_gAMA, buf, (png_size_t)4);
 }
 #endif
 #ifdef PNG_FIXED_POINT_SUPPORTED
@@ -695,16 +737,17 @@
 #endif
    png_byte buf[4];
 
-   png_debug(1, "in png_write_gAMA\n");
+   png_debug(1, "in png_write_gAMA");
+
    /* file_gamma is saved in 1/100,000ths */
    png_save_uint_32(buf, (png_uint_32)file_gamma);
-   png_write_chunk(png_ptr, png_gAMA, buf, (png_size_t)4);
+   png_write_chunk(png_ptr, (png_bytep)png_gAMA, buf, (png_size_t)4);
 }
 #endif
 #endif
 
-#if defined(PNG_WRITE_sRGB_SUPPORTED)
-/* write a sRGB chunk */
+#ifdef PNG_WRITE_sRGB_SUPPORTED
+/* Write a sRGB chunk */
 void /* PRIVATE */
 png_write_sRGB(png_structp png_ptr, int srgb_intent)
 {
@@ -713,17 +756,18 @@
 #endif
    png_byte buf[1];
 
-   png_debug(1, "in png_write_sRGB\n");
-   if(srgb_intent >= PNG_sRGB_INTENT_LAST)
+   png_debug(1, "in png_write_sRGB");
+
+   if (srgb_intent >= PNG_sRGB_INTENT_LAST)
          png_warning(png_ptr,
             "Invalid sRGB rendering intent specified");
    buf[0]=(png_byte)srgb_intent;
-   png_write_chunk(png_ptr, png_sRGB, buf, (png_size_t)1);
+   png_write_chunk(png_ptr, (png_bytep)png_sRGB, buf, (png_size_t)1);
 }
 #endif
 
-#if defined(PNG_WRITE_iCCP_SUPPORTED)
-/* write an iCCP chunk */
+#ifdef PNG_WRITE_iCCP_SUPPORTED
+/* Write an iCCP chunk */
 void /* PRIVATE */
 png_write_iCCP(png_structp png_ptr, png_charp name, int compression_type,
    png_charp profile, int profile_len)
@@ -736,7 +780,7 @@
    compression_state comp;
    int embedded_profile_len = 0;
 
-   png_debug(1, "in png_write_iCCP\n");
+   png_debug(1, "in png_write_iCCP");
 
    comp.num_output_ptr = 0;
    comp.max_output_ptr = 0;
@@ -744,12 +788,9 @@
    comp.input = NULL;
    comp.input_len = 0;
 
-   if (name == NULL || (name_len = png_check_keyword(png_ptr, name,
+   if ((name_len = png_check_keyword(png_ptr, name,
       &new_name)) == 0)
-   {
-      png_warning(png_ptr, "Empty keyword in iCCP chunk");
       return;
-   }
 
    if (compression_type != PNG_COMPRESSION_TYPE_BASE)
       png_warning(png_ptr, "Unknown compression type in iCCP chunk");
@@ -759,34 +800,44 @@
 
    if (profile_len > 3)
       embedded_profile_len =
-          ((*( (png_bytep)profile  ))<<24) |
-          ((*( (png_bytep)profile+1))<<16) |
-          ((*( (png_bytep)profile+2))<< 8) |
-          ((*( (png_bytep)profile+3))    );
+          ((*( (png_bytep)profile    ))<<24) |
+          ((*( (png_bytep)profile + 1))<<16) |
+          ((*( (png_bytep)profile + 2))<< 8) |
+          ((*( (png_bytep)profile + 3))    );
+
+   if (embedded_profile_len < 0)
+   {
+      png_warning(png_ptr,
+        "Embedded profile length in iCCP chunk is negative");
+      png_free(png_ptr, new_name);
+      return;
+   }
 
    if (profile_len < embedded_profile_len)
-     {
-        png_warning(png_ptr,
-          "Embedded profile length too large in iCCP chunk");
-        return;
-     }
+   {
+      png_warning(png_ptr,
+        "Embedded profile length too large in iCCP chunk");
+      png_free(png_ptr, new_name);
+      return;
+   }
 
    if (profile_len > embedded_profile_len)
-     {
-        png_warning(png_ptr,
-          "Truncating profile to actual length in iCCP chunk");
-        profile_len = embedded_profile_len;
-     }
+   {
+      png_warning(png_ptr,
+        "Truncating profile to actual length in iCCP chunk");
+      profile_len = embedded_profile_len;
+   }
 
    if (profile_len)
-       profile_len = png_text_compress(png_ptr, profile, (png_size_t)profile_len,
-          PNG_COMPRESSION_TYPE_BASE, &comp);
+      profile_len = png_text_compress(png_ptr, profile,
+        (png_size_t)profile_len, PNG_COMPRESSION_TYPE_BASE, &comp);
 
-   /* make sure we include the NULL after the name and the compression type */
-   png_write_chunk_start(png_ptr, png_iCCP,
-          (png_uint_32)name_len+profile_len+2);
-   new_name[name_len+1]=0x00;
-   png_write_chunk_data(png_ptr, (png_bytep)new_name, name_len + 2);
+   /* Make sure we include the NULL after the name and the compression type */
+   png_write_chunk_start(png_ptr, (png_bytep)png_iCCP,
+          (png_uint_32)(name_len + profile_len + 2));
+   new_name[name_len + 1] = 0x00;
+   png_write_chunk_data(png_ptr, (png_bytep)new_name,
+     (png_size_t)(name_len + 2));
 
    if (profile_len)
       png_write_compressed_data_out(png_ptr, &comp);
@@ -796,8 +847,8 @@
 }
 #endif
 
-#if defined(PNG_WRITE_sPLT_SUPPORTED)
-/* write a sPLT chunk */
+#ifdef PNG_WRITE_sPLT_SUPPORTED
+/* Write a sPLT chunk */
 void /* PRIVATE */
 png_write_sPLT(png_structp png_ptr, png_sPLT_tp spalette)
 {
@@ -810,67 +861,65 @@
    int entry_size = (spalette->depth == 8 ? 6 : 10);
    int palette_size = entry_size * spalette->nentries;
    png_sPLT_entryp ep;
-#ifdef PNG_NO_POINTER_INDEXING
+#ifndef PNG_POINTER_INDEXING_SUPPORTED
    int i;
 #endif
 
-   png_debug(1, "in png_write_sPLT\n");
-   if (spalette->name == NULL || (name_len = png_check_keyword(png_ptr,
-      spalette->name, &new_name))==0)
-   {
-      png_warning(png_ptr, "Empty keyword in sPLT chunk");
+   png_debug(1, "in png_write_sPLT");
+
+   if ((name_len = png_check_keyword(png_ptr,spalette->name, &new_name))==0)
       return;
-   }
 
-   /* make sure we include the NULL after the name */
-   png_write_chunk_start(png_ptr, png_sPLT,
-          (png_uint_32)(name_len + 2 + palette_size));
-   png_write_chunk_data(png_ptr, (png_bytep)new_name, name_len + 1);
-   png_write_chunk_data(png_ptr, (png_bytep)&spalette->depth, 1);
-
-   /* loop through each palette entry, writing appropriately */
-#ifndef PNG_NO_POINTER_INDEXING
-   for (ep = spalette->entries; ep<spalette->entries+spalette->nentries; ep++)
-   {
-       if (spalette->depth == 8)
-       {
-           entrybuf[0] = (png_byte)ep->red;
-           entrybuf[1] = (png_byte)ep->green;
-           entrybuf[2] = (png_byte)ep->blue;
-           entrybuf[3] = (png_byte)ep->alpha;
-           png_save_uint_16(entrybuf + 4, ep->frequency);
-       }
-       else
-       {
-           png_save_uint_16(entrybuf + 0, ep->red);
-           png_save_uint_16(entrybuf + 2, ep->green);
-           png_save_uint_16(entrybuf + 4, ep->blue);
-           png_save_uint_16(entrybuf + 6, ep->alpha);
-           png_save_uint_16(entrybuf + 8, ep->frequency);
-       }
-       png_write_chunk_data(png_ptr, entrybuf, (png_size_t)entry_size);
+   /* Make sure we include the NULL after the name */
+   png_write_chunk_start(png_ptr, (png_bytep)png_sPLT,
+     (png_uint_32)(name_len + 2 + palette_size));
+   png_write_chunk_data(png_ptr, (png_bytep)new_name,
+     (png_size_t)(name_len + 1));
+   png_write_chunk_data(png_ptr, (png_bytep)&spalette->depth, (png_size_t)1);
+
+   /* Loop through each palette entry, writing appropriately */
+#ifdef PNG_POINTER_INDEXING_SUPPORTED
+   for (ep = spalette->entries; ep<spalette->entries + spalette->nentries; ep++)
+   {
+      if (spalette->depth == 8)
+      {
+          entrybuf[0] = (png_byte)ep->red;
+          entrybuf[1] = (png_byte)ep->green;
+          entrybuf[2] = (png_byte)ep->blue;
+          entrybuf[3] = (png_byte)ep->alpha;
+          png_save_uint_16(entrybuf + 4, ep->frequency);
+      }
+      else
+      {
+          png_save_uint_16(entrybuf + 0, ep->red);
+          png_save_uint_16(entrybuf + 2, ep->green);
+          png_save_uint_16(entrybuf + 4, ep->blue);
+          png_save_uint_16(entrybuf + 6, ep->alpha);
+          png_save_uint_16(entrybuf + 8, ep->frequency);
+      }
+      png_write_chunk_data(png_ptr, entrybuf, (png_size_t)entry_size);
    }
 #else
    ep=spalette->entries;
    for (i=0; i>spalette->nentries; i++)
    {
-       if (spalette->depth == 8)
-       {
-           entrybuf[0] = (png_byte)ep[i].red;
-           entrybuf[1] = (png_byte)ep[i].green;
-           entrybuf[2] = (png_byte)ep[i].blue;
-           entrybuf[3] = (png_byte)ep[i].alpha;
-           png_save_uint_16(entrybuf + 4, ep[i].frequency);
-       }
-       else
-       {
-           png_save_uint_16(entrybuf + 0, ep[i].red);
-           png_save_uint_16(entrybuf + 2, ep[i].green);
-           png_save_uint_16(entrybuf + 4, ep[i].blue);
-           png_save_uint_16(entrybuf + 6, ep[i].alpha);
-           png_save_uint_16(entrybuf + 8, ep[i].frequency);
-       }
-       png_write_chunk_data(png_ptr, entrybuf, entry_size);
+      if (spalette->depth == 8)
+      {
+          entrybuf[0] = (png_byte)ep[i].red;
+          entrybuf[1] = (png_byte)ep[i].green;
+          entrybuf[2] = (png_byte)ep[i].blue;
+          entrybuf[3] = (png_byte)ep[i].alpha;
+          png_save_uint_16(entrybuf + 4, ep[i].frequency);
+      }
+      else
+      {
+          png_save_uint_16(entrybuf + 0, ep[i].red);
+          png_save_uint_16(entrybuf + 2, ep[i].green);
+          png_save_uint_16(entrybuf + 4, ep[i].blue);
+          png_save_uint_16(entrybuf + 6, ep[i].alpha);
+          png_save_uint_16(entrybuf + 8, ep[i].frequency);
+      }
+      png_write_chunk_data(png_ptr, entrybuf, (png_size_t)entry_size);
    }
 #endif
 
@@ -879,8 +928,8 @@
 }
 #endif
 
-#if defined(PNG_WRITE_sBIT_SUPPORTED)
-/* write the sBIT chunk */
+#ifdef PNG_WRITE_sBIT_SUPPORTED
+/* Write the sBIT chunk */
 void /* PRIVATE */
 png_write_sBIT(png_structp png_ptr, png_color_8p sbit, int color_type)
 {
@@ -890,8 +939,9 @@
    png_byte buf[4];
    png_size_t size;
 
-   png_debug(1, "in png_write_sBIT\n");
-   /* make sure we don't depend upon the order of PNG_COLOR_8 */
+   png_debug(1, "in png_write_sBIT");
+
+   /* Make sure we don't depend upon the order of PNG_COLOR_8 */
    if (color_type & PNG_COLOR_MASK_COLOR)
    {
       png_byte maxbits;
@@ -931,12 +981,12 @@
       buf[size++] = sbit->alpha;
    }
 
-   png_write_chunk(png_ptr, png_sBIT, buf, size);
+   png_write_chunk(png_ptr, (png_bytep)png_sBIT, buf, size);
 }
 #endif
 
-#if defined(PNG_WRITE_cHRM_SUPPORTED)
-/* write the cHRM chunk */
+#ifdef PNG_WRITE_cHRM_SUPPORTED
+/* Write the cHRM chunk */
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 void /* PRIVATE */
 png_write_cHRM(png_structp png_ptr, double white_x, double white_y,
@@ -947,55 +997,42 @@
    PNG_cHRM;
 #endif
    png_byte buf[32];
-   png_uint_32 itemp;
 
-   png_debug(1, "in png_write_cHRM\n");
-   /* each value is saved in 1/100,000ths */
-   if (white_x < 0 || white_x > 0.8 || white_y < 0 || white_y > 0.8 ||
-       white_x + white_y > 1.0)
-   {
-      png_warning(png_ptr, "Invalid cHRM white point specified");
-#if !defined(PNG_NO_CONSOLE_IO)
-      fprintf(stderr,"white_x=%f, white_y=%f\n",white_x, white_y);
-#endif
-      return;
-   }
-   itemp = (png_uint_32)(white_x * 100000.0 + 0.5);
-   png_save_uint_32(buf, itemp);
-   itemp = (png_uint_32)(white_y * 100000.0 + 0.5);
-   png_save_uint_32(buf + 4, itemp);
+   png_fixed_point int_white_x, int_white_y, int_red_x, int_red_y,
+      int_green_x, int_green_y, int_blue_x, int_blue_y;
 
-   if (red_x < 0 ||  red_y < 0 || red_x + red_y > 1.0)
-   {
-      png_warning(png_ptr, "Invalid cHRM red point specified");
-      return;
-   }
-   itemp = (png_uint_32)(red_x * 100000.0 + 0.5);
-   png_save_uint_32(buf + 8, itemp);
-   itemp = (png_uint_32)(red_y * 100000.0 + 0.5);
-   png_save_uint_32(buf + 12, itemp);
+   png_debug(1, "in png_write_cHRM");
 
-   if (green_x < 0 || green_y < 0 || green_x + green_y > 1.0)
-   {
-      png_warning(png_ptr, "Invalid cHRM green point specified");
-      return;
-   }
-   itemp = (png_uint_32)(green_x * 100000.0 + 0.5);
-   png_save_uint_32(buf + 16, itemp);
-   itemp = (png_uint_32)(green_y * 100000.0 + 0.5);
-   png_save_uint_32(buf + 20, itemp);
+   int_white_x = (png_uint_32)(white_x * 100000.0 + 0.5);
+   int_white_y = (png_uint_32)(white_y * 100000.0 + 0.5);
+   int_red_x   = (png_uint_32)(red_x   * 100000.0 + 0.5);
+   int_red_y   = (png_uint_32)(red_y   * 100000.0 + 0.5);
+   int_green_x = (png_uint_32)(green_x * 100000.0 + 0.5);
+   int_green_y = (png_uint_32)(green_y * 100000.0 + 0.5);
+   int_blue_x  = (png_uint_32)(blue_x  * 100000.0 + 0.5);
+   int_blue_y  = (png_uint_32)(blue_y  * 100000.0 + 0.5);
 
-   if (blue_x < 0 || blue_y < 0 || blue_x + blue_y > 1.0)
+#ifdef PNG_CHECK_cHRM_SUPPORTED
+   if (png_check_cHRM_fixed(png_ptr, int_white_x, int_white_y,
+      int_red_x, int_red_y, int_green_x, int_green_y, int_blue_x, int_blue_y))
+#endif
    {
-      png_warning(png_ptr, "Invalid cHRM blue point specified");
-      return;
-   }
-   itemp = (png_uint_32)(blue_x * 100000.0 + 0.5);
-   png_save_uint_32(buf + 24, itemp);
-   itemp = (png_uint_32)(blue_y * 100000.0 + 0.5);
-   png_save_uint_32(buf + 28, itemp);
+      /* Each value is saved in 1/100,000ths */
+
+      png_save_uint_32(buf, int_white_x);
+      png_save_uint_32(buf + 4, int_white_y);
+
+      png_save_uint_32(buf + 8, int_red_x);
+      png_save_uint_32(buf + 12, int_red_y);
+
+      png_save_uint_32(buf + 16, int_green_x);
+      png_save_uint_32(buf + 20, int_green_y);
+
+      png_save_uint_32(buf + 24, int_blue_x);
+      png_save_uint_32(buf + 28, int_blue_y);
 
-   png_write_chunk(png_ptr, png_cHRM, buf, (png_size_t)32);
+      png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
+   }
 }
 #endif
 #ifdef PNG_FIXED_POINT_SUPPORTED
@@ -1010,50 +1047,34 @@
 #endif
    png_byte buf[32];
 
-   png_debug(1, "in png_write_cHRM\n");
-   /* each value is saved in 1/100,000ths */
-   if (white_x > 80000L || white_y > 80000L || white_x + white_y > 100000L)
-   {
-      png_warning(png_ptr, "Invalid fixed cHRM white point specified");
-#if !defined(PNG_NO_CONSOLE_IO)
-      fprintf(stderr,"white_x=%ld, white_y=%ld\n",white_x, white_y);
-#endif
-      return;
-   }
-   png_save_uint_32(buf, (png_uint_32)white_x);
-   png_save_uint_32(buf + 4, (png_uint_32)white_y);
+   png_debug(1, "in png_write_cHRM");
 
-   if (red_x + red_y > 100000L)
+   /* Each value is saved in 1/100,000ths */
+#ifdef PNG_CHECK_cHRM_SUPPORTED
+   if (png_check_cHRM_fixed(png_ptr, white_x, white_y, red_x, red_y,
+      green_x, green_y, blue_x, blue_y))
+#endif
    {
-      png_warning(png_ptr, "Invalid cHRM fixed red point specified");
-      return;
-   }
-   png_save_uint_32(buf + 8, (png_uint_32)red_x);
-   png_save_uint_32(buf + 12, (png_uint_32)red_y);
+      png_save_uint_32(buf, (png_uint_32)white_x);
+      png_save_uint_32(buf + 4, (png_uint_32)white_y);
 
-   if (green_x + green_y > 100000L)
-   {
-      png_warning(png_ptr, "Invalid fixed cHRM green point specified");
-      return;
-   }
-   png_save_uint_32(buf + 16, (png_uint_32)green_x);
-   png_save_uint_32(buf + 20, (png_uint_32)green_y);
+      png_save_uint_32(buf + 8, (png_uint_32)red_x);
+      png_save_uint_32(buf + 12, (png_uint_32)red_y);
 
-   if (blue_x + blue_y > 100000L)
-   {
-      png_warning(png_ptr, "Invalid fixed cHRM blue point specified");
-      return;
-   }
-   png_save_uint_32(buf + 24, (png_uint_32)blue_x);
-   png_save_uint_32(buf + 28, (png_uint_32)blue_y);
+      png_save_uint_32(buf + 16, (png_uint_32)green_x);
+      png_save_uint_32(buf + 20, (png_uint_32)green_y);
 
-   png_write_chunk(png_ptr, png_cHRM, buf, (png_size_t)32);
+      png_save_uint_32(buf + 24, (png_uint_32)blue_x);
+      png_save_uint_32(buf + 28, (png_uint_32)blue_y);
+
+      png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
+   }
 }
 #endif
 #endif
 
-#if defined(PNG_WRITE_tRNS_SUPPORTED)
-/* write the tRNS chunk */
+#ifdef PNG_WRITE_tRNS_SUPPORTED
+/* Write the tRNS chunk */
 void /* PRIVATE */
 png_write_tRNS(png_structp png_ptr, png_bytep trans, png_color_16p tran,
    int num_trans, int color_type)
@@ -1063,42 +1084,44 @@
 #endif
    png_byte buf[6];
 
-   png_debug(1, "in png_write_tRNS\n");
+   png_debug(1, "in png_write_tRNS");
+
    if (color_type == PNG_COLOR_TYPE_PALETTE)
    {
       if (num_trans <= 0 || num_trans > (int)png_ptr->num_palette)
       {
-         png_warning(png_ptr,"Invalid number of transparent colors specified");
+         png_warning(png_ptr, "Invalid number of transparent colors specified");
          return;
       }
-      /* write the chunk out as it is */
-      png_write_chunk(png_ptr, png_tRNS, trans, (png_size_t)num_trans);
+      /* Write the chunk out as it is */
+      png_write_chunk(png_ptr, (png_bytep)png_tRNS, trans,
+        (png_size_t)num_trans);
    }
    else if (color_type == PNG_COLOR_TYPE_GRAY)
    {
-      /* one 16 bit value */
-      if(tran->gray >= (1 << png_ptr->bit_depth))
+      /* One 16 bit value */
+      if (tran->gray >= (1 << png_ptr->bit_depth))
       {
          png_warning(png_ptr,
            "Ignoring attempt to write tRNS chunk out-of-range for bit_depth");
          return;
       }
       png_save_uint_16(buf, tran->gray);
-      png_write_chunk(png_ptr, png_tRNS, buf, (png_size_t)2);
+      png_write_chunk(png_ptr, (png_bytep)png_tRNS, buf, (png_size_t)2);
    }
    else if (color_type == PNG_COLOR_TYPE_RGB)
    {
-      /* three 16 bit values */
+      /* Three 16 bit values */
       png_save_uint_16(buf, tran->red);
       png_save_uint_16(buf + 2, tran->green);
       png_save_uint_16(buf + 4, tran->blue);
-      if(png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))
-         {
-            png_warning(png_ptr,
-              "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8");
-            return;
-         }
-      png_write_chunk(png_ptr, png_tRNS, buf, (png_size_t)6);
+      if (png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))
+      {
+         png_warning(png_ptr,
+           "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8");
+         return;
+      }
+      png_write_chunk(png_ptr, (png_bytep)png_tRNS, buf, (png_size_t)6);
    }
    else
    {
@@ -1107,8 +1130,8 @@
 }
 #endif
 
-#if defined(PNG_WRITE_bKGD_SUPPORTED)
-/* write the background chunk */
+#ifdef PNG_WRITE_bKGD_SUPPORTED
+/* Write the background chunk */
 void /* PRIVATE */
 png_write_bKGD(png_structp png_ptr, png_color_16p back, int color_type)
 {
@@ -1117,51 +1140,52 @@
 #endif
    png_byte buf[6];
 
-   png_debug(1, "in png_write_bKGD\n");
+   png_debug(1, "in png_write_bKGD");
+
    if (color_type == PNG_COLOR_TYPE_PALETTE)
    {
       if (
-#if defined(PNG_MNG_FEATURES_SUPPORTED)
+#ifdef PNG_MNG_FEATURES_SUPPORTED
           (png_ptr->num_palette ||
           (!(png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE))) &&
 #endif
-         back->index > png_ptr->num_palette)
+         back->index >= png_ptr->num_palette)
       {
          png_warning(png_ptr, "Invalid background palette index");
          return;
       }
       buf[0] = back->index;
-      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)1);
+      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)1);
    }
    else if (color_type & PNG_COLOR_MASK_COLOR)
    {
       png_save_uint_16(buf, back->red);
       png_save_uint_16(buf + 2, back->green);
       png_save_uint_16(buf + 4, back->blue);
-      if(png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))
-         {
-            png_warning(png_ptr,
-              "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8");
-            return;
-         }
-      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)6);
+      if (png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))
+      {
+         png_warning(png_ptr,
+           "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8");
+         return;
+      }
+      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)6);
    }
    else
    {
-      if(back->gray >= (1 << png_ptr->bit_depth))
+      if (back->gray >= (1 << png_ptr->bit_depth))
       {
          png_warning(png_ptr,
            "Ignoring attempt to write bKGD chunk out-of-range for bit_depth");
          return;
       }
       png_save_uint_16(buf, back->gray);
-      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)2);
+      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)2);
    }
 }
 #endif
 
-#if defined(PNG_WRITE_hIST_SUPPORTED)
-/* write the histogram */
+#ifdef PNG_WRITE_hIST_SUPPORTED
+/* Write the histogram */
 void /* PRIVATE */
 png_write_hIST(png_structp png_ptr, png_uint_16p hist, int num_hist)
 {
@@ -1171,16 +1195,18 @@
    int i;
    png_byte buf[3];
 
-   png_debug(1, "in png_write_hIST\n");
+   png_debug(1, "in png_write_hIST");
+
    if (num_hist > (int)png_ptr->num_palette)
    {
-      png_debug2(3, "num_hist = %d, num_palette = %d\n", num_hist,
+      png_debug2(3, "num_hist = %d, num_palette = %d", num_hist,
          png_ptr->num_palette);
       png_warning(png_ptr, "Invalid number of histogram entries specified");
       return;
    }
 
-   png_write_chunk_start(png_ptr, png_hIST, (png_uint_32)(num_hist * 2));
+   png_write_chunk_start(png_ptr, (png_bytep)png_hIST,
+     (png_uint_32)(num_hist * 2));
    for (i = 0; i < num_hist; i++)
    {
       png_save_uint_16(buf, hist[i]);
@@ -1210,7 +1236,8 @@
    int kflag;
    int kwarn=0;
 
-   png_debug(1, "in png_check_keyword\n");
+   png_debug(1, "in png_check_keyword");
+
    *new_key = NULL;
 
    if (key == NULL || (key_len = png_strlen(key)) == 0)
@@ -1219,7 +1246,7 @@
       return ((png_size_t)0);
    }
 
-   png_debug1(2, "Keyword to be checked is '%s'\n", key);
+   png_debug1(2, "Keyword to be checked is '%s'", key);
 
    *new_key = (png_charp)png_malloc_warn(png_ptr, (png_uint_32)(key_len + 2));
    if (*new_key == NULL)
@@ -1234,7 +1261,7 @@
       if ((png_byte)*kp < 0x20 ||
          ((png_byte)*kp > 0x7E && (png_byte)*kp < 0xA1))
       {
-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
+#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
          char msg[40];
 
          png_snprintf(msg, 40,
@@ -1260,8 +1287,8 @@
 
       while (*kp == ' ')
       {
-        *(kp--) = '\0';
-        key_len--;
+         *(kp--) = '\0';
+         key_len--;
       }
    }
 
@@ -1273,12 +1300,12 @@
 
       while (*kp == ' ')
       {
-        kp++;
-        key_len--;
+         kp++;
+         key_len--;
       }
    }
 
-   png_debug1(2, "Checking for multiple internal spaces in '%s'\n", kp);
+   png_debug1(2, "Checking for multiple internal spaces in '%s'", kp);
 
    /* Remove multiple internal spaces. */
    for (kflag = 0, dp = *new_key; *kp != '\0'; kp++)
@@ -1300,20 +1327,20 @@
       }
    }
    *dp = '\0';
-   if(kwarn)
+   if (kwarn)
       png_warning(png_ptr, "extra interior spaces removed from keyword");
 
    if (key_len == 0)
    {
       png_free(png_ptr, *new_key);
-      *new_key=NULL;
+       *new_key=NULL;
       png_warning(png_ptr, "Zero length keyword");
    }
 
    if (key_len > 79)
    {
       png_warning(png_ptr, "keyword length must be 1 - 79 characters");
-      new_key[79] = '\0';
+      (*new_key)[79] = '\0';
       key_len = 79;
    }
 
@@ -1321,8 +1348,8 @@
 }
 #endif
 
-#if defined(PNG_WRITE_tEXt_SUPPORTED)
-/* write a tEXt chunk */
+#ifdef PNG_WRITE_tEXt_SUPPORTED
+/* Write a tEXt chunk */
 void /* PRIVATE */
 png_write_tEXt(png_structp png_ptr, png_charp key, png_charp text,
    png_size_t text_len)
@@ -1333,37 +1360,37 @@
    png_size_t key_len;
    png_charp new_key;
 
-   png_debug(1, "in png_write_tEXt\n");
-   if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
-   {
-      png_warning(png_ptr, "Empty keyword in tEXt chunk");
+   png_debug(1, "in png_write_tEXt");
+
+   if ((key_len = png_check_keyword(png_ptr, key, &new_key))==0)
       return;
-   }
 
    if (text == NULL || *text == '\0')
       text_len = 0;
    else
       text_len = png_strlen(text);
 
-   /* make sure we include the 0 after the key */
-   png_write_chunk_start(png_ptr, png_tEXt, (png_uint_32)key_len+text_len+1);
+   /* Make sure we include the 0 after the key */
+   png_write_chunk_start(png_ptr, (png_bytep)png_tEXt,
+      (png_uint_32)(key_len + text_len + 1));
    /*
     * We leave it to the application to meet PNG-1.0 requirements on the
     * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
     * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.
     * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.
     */
-   png_write_chunk_data(png_ptr, (png_bytep)new_key, key_len + 1);
+   png_write_chunk_data(png_ptr, (png_bytep)new_key,
+     (png_size_t)(key_len + 1));
    if (text_len)
-      png_write_chunk_data(png_ptr, (png_bytep)text, text_len);
+      png_write_chunk_data(png_ptr, (png_bytep)text, (png_size_t)text_len);
 
    png_write_chunk_end(png_ptr);
    png_free(png_ptr, new_key);
 }
 #endif
 
-#if defined(PNG_WRITE_zTXt_SUPPORTED)
-/* write a compressed text chunk */
+#ifdef PNG_WRITE_zTXt_SUPPORTED
+/* Write a compressed text chunk */
 void /* PRIVATE */
 png_write_zTXt(png_structp png_ptr, png_charp key, png_charp text,
    png_size_t text_len, int compression)
@@ -1376,7 +1403,7 @@
    png_charp new_key;
    compression_state comp;
 
-   png_debug(1, "in png_write_zTXt\n");
+   png_debug(1, "in png_write_zTXt");
 
    comp.num_output_ptr = 0;
    comp.max_output_ptr = 0;
@@ -1384,9 +1411,9 @@
    comp.input = NULL;
    comp.input_len = 0;
 
-   if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
+   if ((key_len = png_check_keyword(png_ptr, key, &new_key))==0)
    {
-      png_warning(png_ptr, "Empty keyword in zTXt chunk");
+      png_free(png_ptr, new_key);
       return;
    }
 
@@ -1399,30 +1426,31 @@
 
    text_len = png_strlen(text);
 
-   /* compute the compressed data; do it now for the length */
+   /* Compute the compressed data; do it now for the length */
    text_len = png_text_compress(png_ptr, text, text_len, compression,
        &comp);
 
-   /* write start of chunk */
-   png_write_chunk_start(png_ptr, png_zTXt, (png_uint_32)
-      (key_len+text_len+2));
-   /* write key */
-   png_write_chunk_data(png_ptr, (png_bytep)new_key, key_len + 1);
+   /* Write start of chunk */
+   png_write_chunk_start(png_ptr, (png_bytep)png_zTXt,
+     (png_uint_32)(key_len+text_len + 2));
+   /* Write key */
+   png_write_chunk_data(png_ptr, (png_bytep)new_key,
+     (png_size_t)(key_len + 1));
    png_free(png_ptr, new_key);
 
    buf[0] = (png_byte)compression;
-   /* write compression */
+   /* Write compression */
    png_write_chunk_data(png_ptr, (png_bytep)buf, (png_size_t)1);
-   /* write the compressed data */
+   /* Write the compressed data */
    png_write_compressed_data_out(png_ptr, &comp);
 
-   /* close the chunk */
+   /* Close the chunk */
    png_write_chunk_end(png_ptr);
 }
 #endif
 
-#if defined(PNG_WRITE_iTXt_SUPPORTED)
-/* write an iTXt chunk */
+#ifdef PNG_WRITE_iTXt_SUPPORTED
+/* Write an iTXt chunk */
 void /* PRIVATE */
 png_write_iTXt(png_structp png_ptr, int compression, png_charp key,
     png_charp lang, png_charp lang_key, png_charp text)
@@ -1431,23 +1459,22 @@
    PNG_iTXt;
 #endif
    png_size_t lang_len, key_len, lang_key_len, text_len;
-   png_charp new_lang, new_key;
+   png_charp new_lang;
+   png_charp new_key = NULL;
    png_byte cbuf[2];
    compression_state comp;
 
-   png_debug(1, "in png_write_iTXt\n");
+   png_debug(1, "in png_write_iTXt");
 
    comp.num_output_ptr = 0;
    comp.max_output_ptr = 0;
    comp.output_ptr = NULL;
    comp.input = NULL;
 
-   if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
-   {
-      png_warning(png_ptr, "Empty keyword in iTXt chunk");
+   if ((key_len = png_check_keyword(png_ptr, key, &new_key))==0)
       return;
-   }
-   if (lang == NULL || (lang_len = png_check_keyword(png_ptr, lang, &new_lang))==0)
+
+   if ((lang_len = png_check_keyword(png_ptr, lang, &new_lang))==0)
    {
       png_warning(png_ptr, "Empty language field in iTXt chunk");
       new_lang = NULL;
@@ -1455,24 +1482,24 @@
    }
 
    if (lang_key == NULL)
-     lang_key_len = 0;
+      lang_key_len = 0;
    else
-     lang_key_len = png_strlen(lang_key);
+      lang_key_len = png_strlen(lang_key);
 
    if (text == NULL)
       text_len = 0;
    else
-     text_len = png_strlen(text);
+      text_len = png_strlen(text);
 
-   /* compute the compressed data; do it now for the length */
+   /* Compute the compressed data; do it now for the length */
    text_len = png_text_compress(png_ptr, text, text_len, compression-2,
       &comp);
 
 
-   /* make sure we include the compression flag, the compression byte,
+   /* Make sure we include the compression flag, the compression byte,
     * and the NULs after the key, lang, and lang_key parts */
 
-   png_write_chunk_start(png_ptr, png_iTXt,
+   png_write_chunk_start(png_ptr, (png_bytep)png_iTXt,
           (png_uint_32)(
         5 /* comp byte, comp flag, terminators for key, lang and lang_key */
         + key_len
@@ -1480,38 +1507,39 @@
         + lang_key_len
         + text_len));
 
-   /*
-    * We leave it to the application to meet PNG-1.0 requirements on the
+   /* We leave it to the application to meet PNG-1.0 requirements on the
     * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
     * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.
     * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.
     */
-   png_write_chunk_data(png_ptr, (png_bytep)new_key, key_len + 1);
+   png_write_chunk_data(png_ptr, (png_bytep)new_key,
+     (png_size_t)(key_len + 1));
 
-   /* set the compression flag */
+   /* Set the compression flag */
    if (compression == PNG_ITXT_COMPRESSION_NONE || \
        compression == PNG_TEXT_COMPRESSION_NONE)
        cbuf[0] = 0;
    else /* compression == PNG_ITXT_COMPRESSION_zTXt */
        cbuf[0] = 1;
-   /* set the compression method */
+   /* Set the compression method */
    cbuf[1] = 0;
-   png_write_chunk_data(png_ptr, cbuf, 2);
+   png_write_chunk_data(png_ptr, cbuf, (png_size_t)2);
 
    cbuf[0] = 0;
-   png_write_chunk_data(png_ptr, (new_lang ? (png_bytep)new_lang : cbuf), lang_len + 1);
-   png_write_chunk_data(png_ptr, (lang_key ? (png_bytep)lang_key : cbuf), lang_key_len + 1);
+   png_write_chunk_data(png_ptr, (new_lang ? (png_bytep)new_lang : cbuf),
+     (png_size_t)(lang_len + 1));
+   png_write_chunk_data(png_ptr, (lang_key ? (png_bytep)lang_key : cbuf),
+     (png_size_t)(lang_key_len + 1));
    png_write_compressed_data_out(png_ptr, &comp);
 
    png_write_chunk_end(png_ptr);
    png_free(png_ptr, new_key);
-   if (new_lang)
-     png_free(png_ptr, new_lang);
+   png_free(png_ptr, new_lang);
 }
 #endif
 
-#if defined(PNG_WRITE_oFFs_SUPPORTED)
-/* write the oFFs chunk */
+#ifdef PNG_WRITE_oFFs_SUPPORTED
+/* Write the oFFs chunk */
 void /* PRIVATE */
 png_write_oFFs(png_structp png_ptr, png_int_32 x_offset, png_int_32 y_offset,
    int unit_type)
@@ -1521,7 +1549,8 @@
 #endif
    png_byte buf[9];
 
-   png_debug(1, "in png_write_oFFs\n");
+   png_debug(1, "in png_write_oFFs");
+
    if (unit_type >= PNG_OFFSET_LAST)
       png_warning(png_ptr, "Unrecognized unit type for oFFs chunk");
 
@@ -1529,11 +1558,11 @@
    png_save_int_32(buf + 4, y_offset);
    buf[8] = (png_byte)unit_type;
 
-   png_write_chunk(png_ptr, png_oFFs, buf, (png_size_t)9);
+   png_write_chunk(png_ptr, (png_bytep)png_oFFs, buf, (png_size_t)9);
 }
 #endif
-#if defined(PNG_WRITE_pCAL_SUPPORTED)
-/* write the pCAL chunk (described in the PNG extensions document) */
+#ifdef PNG_WRITE_pCAL_SUPPORTED
+/* Write the pCAL chunk (described in the PNG extensions document) */
 void /* PRIVATE */
 png_write_pCAL(png_structp png_ptr, png_charp purpose, png_int_32 X0,
    png_int_32 X1, int type, int nparams, png_charp units, png_charpp params)
@@ -1547,31 +1576,34 @@
    png_charp new_purpose;
    int i;
 
-   png_debug1(1, "in png_write_pCAL (%d parameters)\n", nparams);
+   png_debug1(1, "in png_write_pCAL (%d parameters)", nparams);
+
    if (type >= PNG_EQUATION_LAST)
       png_warning(png_ptr, "Unrecognized equation type for pCAL chunk");
 
    purpose_len = png_check_keyword(png_ptr, purpose, &new_purpose) + 1;
-   png_debug1(3, "pCAL purpose length = %d\n", (int)purpose_len);
+   png_debug1(3, "pCAL purpose length = %d", (int)purpose_len);
    units_len = png_strlen(units) + (nparams == 0 ? 0 : 1);
-   png_debug1(3, "pCAL units length = %d\n", (int)units_len);
+   png_debug1(3, "pCAL units length = %d", (int)units_len);
    total_len = purpose_len + units_len + 10;
 
-   params_len = (png_uint_32p)png_malloc(png_ptr, (png_uint_32)(nparams
-      *png_sizeof(png_uint_32)));
+   params_len = (png_uint_32p)png_malloc(png_ptr,
+      (png_uint_32)(nparams * png_sizeof(png_uint_32)));
 
    /* Find the length of each parameter, making sure we don't count the
       null terminator for the last parameter. */
    for (i = 0; i < nparams; i++)
    {
       params_len[i] = png_strlen(params[i]) + (i == nparams - 1 ? 0 : 1);
-      png_debug2(3, "pCAL parameter %d length = %lu\n", i, params_len[i]);
+      png_debug2(3, "pCAL parameter %d length = %lu", i,
+        (unsigned long) params_len[i]);
       total_len += (png_size_t)params_len[i];
    }
 
-   png_debug1(3, "pCAL total length = %d\n", (int)total_len);
-   png_write_chunk_start(png_ptr, png_pCAL, (png_uint_32)total_len);
-   png_write_chunk_data(png_ptr, (png_bytep)new_purpose, purpose_len);
+   png_debug1(3, "pCAL total length = %d", (int)total_len);
+   png_write_chunk_start(png_ptr, (png_bytep)png_pCAL, (png_uint_32)total_len);
+   png_write_chunk_data(png_ptr, (png_bytep)new_purpose,
+     (png_size_t)purpose_len);
    png_save_int_32(buf, X0);
    png_save_int_32(buf + 4, X1);
    buf[8] = (png_byte)type;
@@ -1592,9 +1624,9 @@
 }
 #endif
 
-#if defined(PNG_WRITE_sCAL_SUPPORTED)
-/* write the sCAL chunk */
-#if defined(PNG_FLOATING_POINT_SUPPORTED) && !defined(PNG_NO_STDIO)
+#ifdef PNG_WRITE_sCAL_SUPPORTED
+/* Write the sCAL chunk */
+#if defined(PNG_FLOATING_POINT_SUPPORTED) && defined(PNG_STDIO_SUPPORTED)
 void /* PRIVATE */
 png_write_sCAL(png_structp png_ptr, int unit, double width, double height)
 {
@@ -1604,17 +1636,18 @@
    char buf[64];
    png_size_t total_len;
 
-   png_debug(1, "in png_write_sCAL\n");
+   png_debug(1, "in png_write_sCAL");
 
    buf[0] = (char)unit;
-#if defined(_WIN32_WCE)
+#ifdef _WIN32_WCE
 /* sprintf() function is not supported on WindowsCE */
    {
       wchar_t wc_buf[32];
       size_t wc_len;
       swprintf(wc_buf, TEXT("%12.12e"), width);
       wc_len = wcslen(wc_buf);
-      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, buf + 1, wc_len, NULL, NULL);
+      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, buf + 1, wc_len, NULL,
+          NULL);
       total_len = wc_len + 2;
       swprintf(wc_buf, TEXT("%12.12e"), height);
       wc_len = wcslen(wc_buf);
@@ -1629,8 +1662,8 @@
    total_len += png_strlen(buf + total_len);
 #endif
 
-   png_debug1(3, "sCAL total length = %u\n", (unsigned int)total_len);
-   png_write_chunk(png_ptr, png_sCAL, (png_bytep)buf, total_len);
+   png_debug1(3, "sCAL total length = %u", (unsigned int)total_len);
+   png_write_chunk(png_ptr, (png_bytep)png_sCAL, (png_bytep)buf, total_len);
 }
 #else
 #ifdef PNG_FIXED_POINT_SUPPORTED
@@ -1644,7 +1677,7 @@
    png_byte buf[64];
    png_size_t wlen, hlen, total_len;
 
-   png_debug(1, "in png_write_sCAL_s\n");
+   png_debug(1, "in png_write_sCAL_s");
 
    wlen = png_strlen(width);
    hlen = png_strlen(height);
@@ -1656,18 +1689,18 @@
    }
 
    buf[0] = (png_byte)unit;
-   png_memcpy(buf + 1, width, wlen + 1);      /* append the '\0' here */
-   png_memcpy(buf + wlen + 2, height, hlen);  /* do NOT append the '\0' here */
+   png_memcpy(buf + 1, width, wlen + 1);      /* Append the '\0' here */
+   png_memcpy(buf + wlen + 2, height, hlen);  /* Do NOT append the '\0' here */
 
-   png_debug1(3, "sCAL total length = %u\n", (unsigned int)total_len);
-   png_write_chunk(png_ptr, png_sCAL, buf, total_len);
+   png_debug1(3, "sCAL total length = %u", (unsigned int)total_len);
+   png_write_chunk(png_ptr, (png_bytep)png_sCAL, buf, total_len);
 }
 #endif
 #endif
 #endif
 
-#if defined(PNG_WRITE_pHYs_SUPPORTED)
-/* write the pHYs chunk */
+#ifdef PNG_WRITE_pHYs_SUPPORTED
+/* Write the pHYs chunk */
 void /* PRIVATE */
 png_write_pHYs(png_structp png_ptr, png_uint_32 x_pixels_per_unit,
    png_uint_32 y_pixels_per_unit,
@@ -1678,7 +1711,8 @@
 #endif
    png_byte buf[9];
 
-   png_debug(1, "in png_write_pHYs\n");
+   png_debug(1, "in png_write_pHYs");
+
    if (unit_type >= PNG_RESOLUTION_LAST)
       png_warning(png_ptr, "Unrecognized unit type for pHYs chunk");
 
@@ -1686,11 +1720,11 @@
    png_save_uint_32(buf + 4, y_pixels_per_unit);
    buf[8] = (png_byte)unit_type;
 
-   png_write_chunk(png_ptr, png_pHYs, buf, (png_size_t)9);
+   png_write_chunk(png_ptr, (png_bytep)png_pHYs, buf, (png_size_t)9);
 }
 #endif
 
-#if defined(PNG_WRITE_tIME_SUPPORTED)
+#ifdef PNG_WRITE_tIME_SUPPORTED
 /* Write the tIME chunk.  Use either png_convert_from_struct_tm()
  * or png_convert_from_time_t(), or fill in the structure yourself.
  */
@@ -1702,7 +1736,8 @@
 #endif
    png_byte buf[7];
 
-   png_debug(1, "in png_write_tIME\n");
+   png_debug(1, "in png_write_tIME");
+
    if (mod_time->month  > 12 || mod_time->month  < 1 ||
        mod_time->day    > 31 || mod_time->day    < 1 ||
        mod_time->hour   > 23 || mod_time->second > 60)
@@ -1718,83 +1753,85 @@
    buf[5] = mod_time->minute;
    buf[6] = mod_time->second;
 
-   png_write_chunk(png_ptr, png_tIME, buf, (png_size_t)7);
+   png_write_chunk(png_ptr, (png_bytep)png_tIME, buf, (png_size_t)7);
 }
 #endif
 
-/* initializes the row writing capability of libpng */
+/* Initializes the row writing capability of libpng */
 void /* PRIVATE */
 png_write_start_row(png_structp png_ptr)
 {
 #ifdef PNG_WRITE_INTERLACING_SUPPORTED
-#ifdef PNG_USE_LOCAL_ARRAYS
-   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
+#ifndef PNG_USE_GLOBAL_ARRAYS
+   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
-   /* start of interlace block */
+   /* Start of interlace block */
    int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
-   /* offset to next interlace block */
+   /* Offset to next interlace block */
    int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
-   /* start of interlace block in the y direction */
+   /* Start of interlace block in the y direction */
    int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
 
-   /* offset to next interlace block in the y direction */
+   /* Offset to next interlace block in the y direction */
    int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
 #endif
 #endif
 
    png_size_t buf_size;
 
-   png_debug(1, "in png_write_start_row\n");
+   png_debug(1, "in png_write_start_row");
+
    buf_size = (png_size_t)(PNG_ROWBYTES(
-      png_ptr->usr_channels*png_ptr->usr_bit_depth,png_ptr->width)+1);
+      png_ptr->usr_channels*png_ptr->usr_bit_depth, png_ptr->width) + 1);
 
-   /* set up row buffer */
-   png_ptr->row_buf = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
+   /* Set up row buffer */
+   png_ptr->row_buf = (png_bytep)png_malloc(png_ptr,
+     (png_uint_32)buf_size);
    png_ptr->row_buf[0] = PNG_FILTER_VALUE_NONE;
 
-#ifndef PNG_NO_WRITE_FILTERING
-   /* set up filtering buffer, if using this filter */
+#ifdef PNG_WRITE_FILTER_SUPPORTED
+   /* Set up filtering buffer, if using this filter */
    if (png_ptr->do_filter & PNG_FILTER_SUB)
    {
       png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,
-         (png_ptr->rowbytes + 1));
+         (png_uint_32)(png_ptr->rowbytes + 1));
       png_ptr->sub_row[0] = PNG_FILTER_VALUE_SUB;
    }
 
    /* We only need to keep the previous row if we are using one of these. */
    if (png_ptr->do_filter & (PNG_FILTER_AVG | PNG_FILTER_UP | PNG_FILTER_PAETH))
    {
-     /* set up previous row buffer */
-      png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
-      png_memset(png_ptr->prev_row, 0, buf_size);
+      /* Set up previous row buffer */
+      png_ptr->prev_row = (png_bytep)png_calloc(png_ptr,
+         (png_uint_32)buf_size);
 
       if (png_ptr->do_filter & PNG_FILTER_UP)
       {
          png_ptr->up_row = (png_bytep)png_malloc(png_ptr,
-            (png_ptr->rowbytes + 1));
+            (png_uint_32)(png_ptr->rowbytes + 1));
          png_ptr->up_row[0] = PNG_FILTER_VALUE_UP;
       }
 
       if (png_ptr->do_filter & PNG_FILTER_AVG)
       {
          png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,
-            (png_ptr->rowbytes + 1));
+            (png_uint_32)(png_ptr->rowbytes + 1));
          png_ptr->avg_row[0] = PNG_FILTER_VALUE_AVG;
       }
 
       if (png_ptr->do_filter & PNG_FILTER_PAETH)
       {
          png_ptr->paeth_row = (png_bytep)png_malloc(png_ptr,
-            (png_ptr->rowbytes + 1));
+            (png_uint_32)(png_ptr->rowbytes + 1));
          png_ptr->paeth_row[0] = PNG_FILTER_VALUE_PAETH;
       }
-#endif /* PNG_NO_WRITE_FILTERING */
    }
+#endif /* PNG_WRITE_FILTER_SUPPORTED */
 
 #ifdef PNG_WRITE_INTERLACING_SUPPORTED
-   /* if interlaced, we need to set up width and height of pass */
+   /* If interlaced, we need to set up width and height of pass */
    if (png_ptr->interlaced)
    {
       if (!(png_ptr->transformations & PNG_INTERLACE))
@@ -1825,35 +1862,36 @@
 png_write_finish_row(png_structp png_ptr)
 {
 #ifdef PNG_WRITE_INTERLACING_SUPPORTED
-#ifdef PNG_USE_LOCAL_ARRAYS
-   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
+#ifndef PNG_USE_GLOBAL_ARRAYS
+   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
-   /* start of interlace block */
+   /* Start of interlace block */
    int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
-   /* offset to next interlace block */
+   /* Offset to next interlace block */
    int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
-   /* start of interlace block in the y direction */
+   /* Start of interlace block in the y direction */
    int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
 
-   /* offset to next interlace block in the y direction */
+   /* Offset to next interlace block in the y direction */
    int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
 #endif
 #endif
 
    int ret;
 
-   png_debug(1, "in png_write_finish_row\n");
-   /* next row */
+   png_debug(1, "in png_write_finish_row");
+
+   /* Next row */
    png_ptr->row_number++;
 
-   /* see if we are done */
+   /* See if we are done */
    if (png_ptr->row_number < png_ptr->num_rows)
       return;
 
 #ifdef PNG_WRITE_INTERLACING_SUPPORTED
-   /* if interlaced, go to next pass */
+   /* If interlaced, go to next pass */
    if (png_ptr->interlaced)
    {
       png_ptr->row_number = 0;
@@ -1863,7 +1901,7 @@
       }
       else
       {
-         /* loop until we find a non-zero width or height pass */
+         /* Loop until we find a non-zero width or height pass */
          do
          {
             png_ptr->pass++;
@@ -1883,28 +1921,28 @@
 
       }
 
-      /* reset the row above the image for the next pass */
+      /* Reset the row above the image for the next pass */
       if (png_ptr->pass < 7)
       {
          if (png_ptr->prev_row != NULL)
             png_memset(png_ptr->prev_row, 0,
                (png_size_t)(PNG_ROWBYTES(png_ptr->usr_channels*
-               png_ptr->usr_bit_depth,png_ptr->width))+1);
+               png_ptr->usr_bit_depth, png_ptr->width)) + 1);
          return;
       }
    }
 #endif
 
-   /* if we get here, we've just written the last row, so we need
+   /* If we get here, we've just written the last row, so we need
       to flush the compressor */
    do
    {
-      /* tell the compressor we are done */
+      /* Tell the compressor we are done */
       ret = deflate(&png_ptr->zstream, Z_FINISH);
-      /* check for an error */
+      /* Check for an error */
       if (ret == Z_OK)
       {
-         /* check to see if we need more room */
+         /* Check to see if we need more room */
          if (!(png_ptr->zstream.avail_out))
          {
             png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
@@ -1921,7 +1959,7 @@
       }
    } while (ret != Z_STREAM_END);
 
-   /* write any extra space */
+   /* Write any extra space */
    if (png_ptr->zstream.avail_out < png_ptr->zbuf_size)
    {
       png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size -
@@ -1932,7 +1970,7 @@
    png_ptr->zstream.data_type = Z_BINARY;
 }
 
-#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
+#ifdef PNG_WRITE_INTERLACING_SUPPORTED
 /* Pick out the correct pixels for the interlace pass.
  * The basic idea here is to go through the row with a source
  * pointer and a destination pointer (sp and dp), and copy the
@@ -1943,25 +1981,26 @@
 void /* PRIVATE */
 png_do_write_interlace(png_row_infop row_info, png_bytep row, int pass)
 {
-#ifdef PNG_USE_LOCAL_ARRAYS
-   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
+   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
-   /* start of interlace block */
+#ifndef PNG_USE_GLOBAL_ARRAYS
+   /* Start of interlace block */
    int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
-   /* offset to next interlace block */
+   /* Offset to next interlace block */
    int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 #endif
 
-   png_debug(1, "in png_do_write_interlace\n");
-   /* we don't have to do anything on the last pass (6) */
-#if defined(PNG_USELESS_TESTS_SUPPORTED)
+   png_debug(1, "in png_do_write_interlace");
+
+   /* We don't have to do anything on the last pass (6) */
+#ifdef PNG_USELESS_TESTS_SUPPORTED
    if (row != NULL && row_info != NULL && pass < 6)
 #else
    if (pass < 6)
 #endif
    {
-      /* each pixel depth is handled separately */
+      /* Each pixel depth is handled separately */
       switch (row_info->pixel_depth)
       {
          case 1:
@@ -2072,27 +2111,27 @@
             png_uint_32 row_width = row_info->width;
             png_size_t pixel_bytes;
 
-            /* start at the beginning */
+            /* Start at the beginning */
             dp = row;
-            /* find out how many bytes each pixel takes up */
+            /* Find out how many bytes each pixel takes up */
             pixel_bytes = (row_info->pixel_depth >> 3);
-            /* loop through the row, only looking at the pixels that
+            /* Loop through the row, only looking at the pixels that
                matter */
             for (i = png_pass_start[pass]; i < row_width;
                i += png_pass_inc[pass])
             {
-               /* find out where the original pixel is */
+               /* Find out where the original pixel is */
                sp = row + (png_size_t)i * pixel_bytes;
-               /* move the pixel */
+               /* Move the pixel */
                if (dp != sp)
                   png_memcpy(dp, sp, pixel_bytes);
-               /* next pixel */
+               /* Next pixel */
                dp += pixel_bytes;
             }
             break;
          }
       }
-      /* set new row width */
+      /* Set new row width */
       row_info->width = (row_info->width +
          png_pass_inc[pass] - 1 -
          png_pass_start[pass]) /
@@ -2115,23 +2154,21 @@
 png_write_find_filter(png_structp png_ptr, png_row_infop row_info)
 {
    png_bytep best_row;
-#ifndef PNG_NO_WRITE_FILTER
+#ifdef PNG_WRITE_FILTER_SUPPORTED
    png_bytep prev_row, row_buf;
    png_uint_32 mins, bpp;
    png_byte filter_to_do = png_ptr->do_filter;
    png_uint_32 row_bytes = row_info->rowbytes;
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-   int num_p_filters = (int)png_ptr->num_prev_filters;
-#endif
 
-   png_debug(1, "in png_write_find_filter\n");
-   /* find out how many bytes offset each pixel is */
+   png_debug(1, "in png_write_find_filter");
+
+   /* Find out how many bytes offset each pixel is */
    bpp = (row_info->pixel_depth + 7) >> 3;
 
    prev_row = png_ptr->prev_row;
 #endif
    best_row = png_ptr->row_buf;
-#ifndef PNG_NO_WRITE_FILTER
+#ifdef PNG_WRITE_FILTER_SUPPORTED
    row_buf = best_row;
    mins = PNG_MAXSUM;
 
@@ -2174,47 +2211,12 @@
          sum += (v < 128) ? v : 256 - v;
       }
 
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         png_uint_32 sumhi, sumlo;
-         int j;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK; /* Gives us some footroom */
-
-         /* Reduce the sum if we match any of the previous rows */
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
-            {
-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         /* Factor in the cost of this filter (this is here for completeness,
-          * but it makes no sense to have a "cost" for the NONE filter, as
-          * it has the minimum possible computational cost - none).
-          */
-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
-            PNG_COST_SHIFT;
-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
-            PNG_COST_SHIFT;
-
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
-      }
-#endif
       mins = sum;
    }
 
-   /* sub filter */
+   /* Sub filter */
    if (filter_to_do == PNG_FILTER_SUB)
-   /* it's the only filter so no testing is needed */
+   /* It's the only filter so no testing is needed */
    {
       png_bytep rp, lp, dp;
       png_uint_32 i;
@@ -2238,41 +2240,6 @@
       png_uint_32 i;
       int v;
 
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-      /* We temporarily increase the "minimum sum" by the factor we
-       * would reduce the sum of this filter, so that we can do the
-       * early exit comparison without scaling the sum each time.
-       */
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 lmhi, lmlo;
-         lmlo = lmins & PNG_LOMASK;
-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
-            {
-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
-            PNG_COST_SHIFT;
-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
-            PNG_COST_SHIFT;
-
-         if (lmhi > PNG_HIMASK)
-            lmins = PNG_MAXSUM;
-         else
-            lmins = (lmhi << PNG_HISHIFT) + lmlo;
-      }
-#endif
-
       for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
            i++, rp++, dp++)
       {
@@ -2291,37 +2258,6 @@
             break;
       }
 
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 sumhi, sumlo;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
-            {
-               sumlo = (sumlo * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               sumhi = (sumhi * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         sumlo = (sumlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
-            PNG_COST_SHIFT;
-         sumhi = (sumhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
-            PNG_COST_SHIFT;
-
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
-      }
-#endif
-
       if (sum < mins)
       {
          mins = sum;
@@ -2329,7 +2265,7 @@
       }
    }
 
-   /* up filter */
+   /* Up filter */
    if (filter_to_do == PNG_FILTER_UP)
    {
       png_bytep rp, dp, pp;
@@ -2351,38 +2287,6 @@
       png_uint_32 i;
       int v;
 
-
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 lmhi, lmlo;
-         lmlo = lmins & PNG_LOMASK;
-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
-            {
-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
-            PNG_COST_SHIFT;
-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
-            PNG_COST_SHIFT;
-
-         if (lmhi > PNG_HIMASK)
-            lmins = PNG_MAXSUM;
-         else
-            lmins = (lmhi << PNG_HISHIFT) + lmlo;
-      }
-#endif
-
       for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
            pp = prev_row + 1; i < row_bytes; i++)
       {
@@ -2394,37 +2298,6 @@
             break;
       }
 
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 sumhi, sumlo;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
-            {
-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
-            PNG_COST_SHIFT;
-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
-            PNG_COST_SHIFT;
-
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
-      }
-#endif
-
       if (sum < mins)
       {
          mins = sum;
@@ -2432,7 +2305,7 @@
       }
    }
 
-   /* avg filter */
+   /* Avg filter */
    if (filter_to_do == PNG_FILTER_AVG)
    {
       png_bytep rp, dp, pp, lp;
@@ -2457,37 +2330,6 @@
       png_uint_32 i;
       int v;
 
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 lmhi, lmlo;
-         lmlo = lmins & PNG_LOMASK;
-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_AVG)
-            {
-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
-            PNG_COST_SHIFT;
-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
-            PNG_COST_SHIFT;
-
-         if (lmhi > PNG_HIMASK)
-            lmins = PNG_MAXSUM;
-         else
-            lmins = (lmhi << PNG_HISHIFT) + lmlo;
-      }
-#endif
-
       for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
            pp = prev_row + 1; i < bpp; i++)
       {
@@ -2506,37 +2348,6 @@
             break;
       }
 
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 sumhi, sumlo;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
-            {
-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
-            PNG_COST_SHIFT;
-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
-            PNG_COST_SHIFT;
-
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
-      }
-#endif
-
       if (sum < mins)
       {
          mins = sum;
@@ -2590,37 +2401,6 @@
       png_uint_32 i;
       int v;
 
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 lmhi, lmlo;
-         lmlo = lmins & PNG_LOMASK;
-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
-            {
-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
-            PNG_COST_SHIFT;
-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
-            PNG_COST_SHIFT;
-
-         if (lmhi > PNG_HIMASK)
-            lmins = PNG_MAXSUM;
-         else
-            lmins = (lmhi << PNG_HISHIFT) + lmlo;
-      }
-#endif
-
       for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
            pp = prev_row + 1; i < bpp; i++)
       {
@@ -2671,61 +2451,15 @@
             break;
       }
 
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 sumhi, sumlo;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
-            {
-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
-            PNG_COST_SHIFT;
-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
-            PNG_COST_SHIFT;
-
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
-      }
-#endif
-
       if (sum < mins)
       {
          best_row = png_ptr->paeth_row;
       }
    }
-#endif /* PNG_NO_WRITE_FILTER */
+#endif /* PNG_WRITE_FILTER_SUPPORTED */
    /* Do the actual writing of the filtered row data from the chosen filter. */
 
    png_write_filtered_row(png_ptr, best_row);
-
-#ifndef PNG_NO_WRITE_FILTER
-#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
-   /* Save the type of filter we picked this time for future calculations */
-   if (png_ptr->num_prev_filters > 0)
-   {
-      int j;
-      for (j = 1; j < num_p_filters; j++)
-      {
-         png_ptr->prev_filters[j] = png_ptr->prev_filters[j - 1];
-      }
-      png_ptr->prev_filters[j] = best_row[0];
-   }
-#endif
-#endif /* PNG_NO_WRITE_FILTER */
 }
 
 
@@ -2733,20 +2467,21 @@
 void /* PRIVATE */
 png_write_filtered_row(png_structp png_ptr, png_bytep filtered_row)
 {
-   png_debug(1, "in png_write_filtered_row\n");
-   png_debug1(2, "filter = %d\n", filtered_row[0]);
-   /* set up the zlib input buffer */
+   png_debug(1, "in png_write_filtered_row");
+
+   png_debug1(2, "filter = %d", filtered_row[0]);
+   /* Set up the zlib input buffer */
 
    png_ptr->zstream.next_in = filtered_row;
    png_ptr->zstream.avail_in = (uInt)png_ptr->row_info.rowbytes + 1;
-   /* repeat until we have compressed all the data */
+   /* Repeat until we have compressed all the data */
    do
    {
-      int ret; /* return of zlib */
+      int ret; /* Return of zlib */
 
-      /* compress the data */
+      /* Compress the data */
       ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);
-      /* check for compression errors */
+      /* Check for compression errors */
       if (ret != Z_OK)
       {
          if (png_ptr->zstream.msg != NULL)
@@ -2755,18 +2490,18 @@
             png_error(png_ptr, "zlib error");
       }
 
-      /* see if it is time to write another IDAT */
+      /* See if it is time to write another IDAT */
       if (!(png_ptr->zstream.avail_out))
       {
-         /* write the IDAT and reset the zlib output buffer */
+         /* Write the IDAT and reset the zlib output buffer */
          png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
          png_ptr->zstream.next_out = png_ptr->zbuf;
          png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
       }
-   /* repeat until all data has been compressed */
+   /* Repeat until all data has been compressed */
    } while (png_ptr->zstream.avail_in);
 
-   /* swap the current and previous rows */
+   /* Swap the current and previous rows */
    if (png_ptr->prev_row != NULL)
    {
       png_bytep tptr;
@@ -2776,10 +2511,10 @@
       png_ptr->row_buf = tptr;
    }
 
-   /* finish row - updates counters and flushes zlib if last row */
+   /* Finish row - updates counters and flushes zlib if last row */
    png_write_finish_row(png_ptr);
 
-#if defined(PNG_WRITE_FLUSH_SUPPORTED)
+#ifdef PNG_WRITE_FLUSH_SUPPORTED
    png_ptr->flush_rows++;
 
    if (png_ptr->flush_dist > 0 &&
diff -Naur libAfterImage-1.20/libungif/dgif_lib.c root/graf2d/asimage/src/libAfterImage/libungif/dgif_lib.c
--- libAfterImage-1.20/libungif/dgif_lib.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libungif/dgif_lib.c	2018-12-08 08:18:38.000000000 +0100
@@ -446,7 +446,7 @@
 }
 
 /******************************************************************************
-*   Get the image code in compressed form.  his routine can be called if the  *
+*   Get the image code in compressed form.  This routine can be called if the  *
 * information needed to be piped out as is. Obviously this is much faster     *
 * than decoding and encoding again. This routine should be followed by calls  *
 * to DGifGetCodeNext, until NULL block is returned.			      *
@@ -687,7 +687,7 @@
 *   The LZ decompression input routine:					      *
 *   This routine is responsable for the decompression of the bit stream from  *
 * 8 bits (bytes) packets, into the real codes.				      *
-*   Returns GIF_OK if read succesfully.					      *
+*   Returns GIF_OK if read successfully.					      *
 ******************************************************************************/
 static int DGifDecompressInput(GifFileType *GifFile, int *Code)
 {
@@ -730,7 +730,7 @@
 *   This routines read one gif data block at a time and buffers it internally *
 * so that the decompression routine could access it.			      *
 *   The routine returns the next byte from its internal buffer (or read next  *
-* block in if buffer empty) and returns GIF_OK if succesful.		      *
+* block in if buffer empty) and returns GIF_OK if successful.		      *
 ******************************************************************************/
 static int DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf,
 						      GifByteType *NextByte)
diff -Naur libAfterImage-1.20/libungif/egif_lib.c root/graf2d/asimage/src/libAfterImage/libungif/egif_lib.c
--- libAfterImage-1.20/libungif/egif_lib.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libungif/egif_lib.c	2018-12-08 08:18:38.000000000 +0100
@@ -69,7 +69,7 @@
 *   Update a new gif file, given its file handle, which must be opened for    *
 * write in binary mode.							      *
 *   Returns GifFileType pointer dynamically allocated which serves as the gif *
-* info record. _GifError is cleared if succesfull.			      *
+* info record. _GifError is cleared if successful.			      *
 ******************************************************************************/
 GifFileType *EGifOpenFileHandle(int FileHandle)
 {
@@ -732,7 +732,7 @@
 *   The LZ compression output routine:                                        *
 *   This routine is responsible for the compression of the bit stream into    *
 *   8 bits (bytes) packets.                                                   *
-*   Returns GIF_OK if written succesfully.                                    *
+*   Returns GIF_OK if written successfully.                                    *
 ******************************************************************************/
 static int EGifCompressOutput(GifFileType *GifFile, int Code)
 {
@@ -778,7 +778,7 @@
 *   This routines buffers the given characters until 255 characters are ready *
 * to be output. If Code is equal to -1 the buffer is flushed (EOF).	      *
 *   The buffer is Dumped with first byte as its size, as GIF format requires. *
-*   Returns GIF_OK if written succesfully.				      *
+*   Returns GIF_OK if written successfully.				      *
 ******************************************************************************/
 static int EGifBufferedOutput(GifFileType *GifFile, GifByteType *Buf, int c)
 {
diff -Naur libAfterImage-1.20/libungif/gifalloc.c root/graf2d/asimage/src/libAfterImage/libungif/gifalloc.c
--- libAfterImage-1.20/libungif/gifalloc.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/libungif/gifalloc.c	2018-12-08 08:18:38.000000000 +0100
@@ -57,8 +57,10 @@
 	return((ColorMapObject *)NULL);
 
     Object->Colors = (GifColorType *)calloc(ColorCount, sizeof(GifColorType));
-    if (Object->Colors == (GifColorType *)NULL)
+    if (Object->Colors == (GifColorType *)NULL) {
+	free(Object);
 	return((ColorMapObject *)NULL);
+    }
 
     Object->ColorCount = ColorCount;
     Object->BitsPerPixel = BitSize(ColorCount);
diff -Naur libAfterImage-1.20/transform.c root/graf2d/asimage/src/libAfterImage/transform.c
--- libAfterImage-1.20/transform.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/transform.c	2018-12-08 08:18:38.000000000 +0100
@@ -2639,7 +2639,7 @@
 		gauss[0] = 1.0;
 		return;
 	}
-	/* after radius of 128 - gaussian degrades into something wierd, 
+	/* after radius of 128 - gaussian degrades into something weird, 
 	   since our colors are only 8 bit */
 	if (radius > 128.0) radius = 128.0; 
 	std_dev = (radius - 1) * 0.3003866304;
@@ -2707,7 +2707,7 @@
 		gauss_sums[0] = 1024;
 		return;
 	}
-	/* after radius of 128 - gaussian degrades into something wierd, 
+	/* after radius of 128 - gaussian degrades into something weird, 
 	   since our colors are only 8 bit */
 	if (i > 128) i = 128; 
 #if 1
diff -Naur libAfterImage-1.20/ungif.c root/graf2d/asimage/src/libAfterImage/ungif.c
--- libAfterImage-1.20/ungif.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/ungif.c	2018-12-08 08:18:38.000000000 +0100
@@ -75,13 +75,21 @@
 	if( sp )
 	{
 		if (sp->ImageDesc.ColorMap)
+#if (GIFLIB_MAJOR>=5)
+	    	GifFreeMapObject(sp->ImageDesc.ColorMap);
+#else
 	    	FreeMapObject(sp->ImageDesc.ColorMap);
+#endif
 
 		if (sp->RasterBits)
 		    free((char *)sp->RasterBits);
 
 		if (sp->ExtensionBlocks)
+#if (GIFLIB_MAJOR>=5)
+		    GifFreeExtensions(&sp->ExtensionBlockCount, &sp->ExtensionBlocks);
+#else
 		    FreeExtension(sp);
+#endif
 
 		if( !reusable )
 			free( sp );
@@ -119,11 +127,19 @@
 	return ret;
 }
 
+#if (GIFLIB_MAJOR>=5)
+GifFileType*
+open_gif_read( FILE *in_stream, int *errcode )
+{
+	return DGifOpen(in_stream, fread_gif, errcode);
+}
+#else
 GifFileType*
 open_gif_read( FILE *in_stream )
 {
 	return DGifOpen(in_stream, fread_gif);
 }
+#endif
 
 int
 get_gif_image_desc( GifFileType *gif, SavedImage *im )
@@ -151,9 +167,13 @@
 		memcpy( &(im->ImageDesc), &(gif->Image), sizeof(GifImageDesc));
 		if( gif->Image.ColorMap )
 		{
+#if (GIFLIB_MAJOR>=5)
+			im->ImageDesc.ColorMap = GifMakeMapObject(gif->Image.ColorMap->ColorCount, NULL);
+#else
 			im->ImageDesc.ColorMap = MakeMapObject(gif->Image.ColorMap->ColorCount, NULL);
+#endif
 			fseek( gif->UserData, start_pos+9, SEEK_SET ); 
-			fread( im->ImageDesc.ColorMap->Colors, 1, gif->Image.ColorMap->ColorCount*3, gif->UserData);
+			if(fread( im->ImageDesc.ColorMap->Colors, 1, gif->Image.ColorMap->ColorCount*3, gif->UserData)){;};
 			fseek( gif->UserData, end_pos, SEEK_SET );
 			gif->Image.ColorMap = NULL ;
  		}
@@ -166,6 +186,9 @@
 {
     GifRecordType RecordType;
     GifByteType *ExtData;
+#if (GIFLIB_MAJOR>=5)
+    int ExtCode;
+#endif
     SavedImage temp_save;
 	int curr_image = 0, ret_count = *ret_images ;
 	int status = GIF_OK;
@@ -197,13 +220,23 @@
 				break;
 
 	    	case EXTENSION_RECORD_TYPE:
+#if (GIFLIB_MAJOR>=5)
+				status = DGifGetExtension(gif,&ExtCode,&ExtData);
+#else
 				status = DGifGetExtension(gif,&temp_save.Function,&ExtData);
+#endif
 				while (ExtData != NULL && status == GIF_OK )
 				{
             		/* Create an extension block with our data */
+#if (GIFLIB_MAJOR>=5)
+            		if ((status = GifAddExtensionBlock(&temp_save.ExtensionBlockCount, &temp_save.ExtensionBlocks,
+                            ExtCode, sizeof(ExtData), ExtData)) == GIF_OK)
+                    status = DGifGetExtension(gif,&ExtCode,&ExtData);
+#else
             		if ((status = AddExtensionBlock(&temp_save, ExtData[0], (char*)&(ExtData[1]))) == GIF_OK)
 				    	status = DGifGetExtensionNext(gif, &ExtData);
             		temp_save.Function = 0;
+#endif
 				}
 				break;
 
diff -Naur libAfterImage-1.20/ungif.h root/graf2d/asimage/src/libAfterImage/ungif.h
--- libAfterImage-1.20/ungif.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/ungif.h	2018-12-08 08:18:38.000000000 +0100
@@ -7,11 +7,29 @@
 extern "C" {
 #endif
 
+#if ((GIFLIB_MAJOR==4) && (GIFLIB_MINOR>=2)) 
+static inline void PrintGifError(void) {
+    fprintf(stderr, "%s\n", GifErrorString());
+}
+#elif (GIFLIB_MAJOR>=5)
+static inline void PrintGifError(int code) {
+    fprintf(stderr, "%s\n", GifErrorString(code));
+}
+#endif
+
+#if (GIFLIB_MAJOR>=5)
+#ifdef __GNUC__
+#define ASIM_PrintGifError(code) do{ fprintf( stderr, "%s():%d:<%s> ",__FUNCTION__, __LINE__, path?path:"null" ); PrintGifError(code); }while(0)
+#else
+#define ASIM_PrintGifError(code) do{ PrintGifError(code); }while(0)
+#endif
+#else // (GIFLIB_MAJOR>=5)
 #ifdef __GNUC__
 #define ASIM_PrintGifError() do{ fprintf( stderr, "%s():%d:<%s> ",__FUNCTION__, __LINE__, path?path:"null" ); PrintGifError(); }while(0)
 #else
 #define ASIM_PrintGifError() do{ PrintGifError(); }while(0)
 #endif
+#endif // (GIFLIB_MAJOR>=5)
 
 #define GIF_GCE_DELAY_BYTE_LOW	1
 #define GIF_GCE_DELAY_BYTE_HIGH	2
@@ -24,7 +42,11 @@
 
 
 int fread_gif( GifFileType *gif, GifByteType* buf, int len );
+#if (GIFLIB_MAJOR>=5)
+GifFileType* open_gif_read( FILE *in_stream, int *errcode );
+#else
 GifFileType* open_gif_read( FILE *in_stream );
+#endif
 
 int get_gif_image_desc( GifFileType *gif, SavedImage *im );
 
diff -Naur libAfterImage-1.20/win32/StdAfx.cpp root/graf2d/asimage/src/libAfterImage/win32/StdAfx.cpp
--- libAfterImage-1.20/win32/StdAfx.cpp	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/win32/StdAfx.cpp	2018-12-08 08:18:38.000000000 +0100
@@ -1,8 +1,8 @@
-// stdafx.cpp : source file that includes just the standard includes
-//	asview.pch will be the pre-compiled header
-//	stdafx.obj will contain the pre-compiled type information
-
-#include "stdafx.h"
-
-// TODO: reference any additional headers you need in STDAFX.H
-// and not in this file
+// stdafx.cpp : source file that includes just the standard includes
+//	asview.pch will be the pre-compiled header
+//	stdafx.obj will contain the pre-compiled type information
+
+#include "stdafx.h"
+
+// TODO: reference any additional headers you need in STDAFX.H
+// and not in this file
diff -Naur libAfterImage-1.20/win32/StdAfx.h root/graf2d/asimage/src/libAfterImage/win32/StdAfx.h
--- libAfterImage-1.20/win32/StdAfx.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/win32/StdAfx.h	2018-12-08 08:18:38.000000000 +0100
@@ -1,28 +1,28 @@
-// stdafx.h : include file for standard system include files,
-//  or project specific include files that are used frequently, but
-//      are changed infrequently
-//
-
-#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
-#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_
-
-#if _MSC_VER > 1000
-#pragma once
-#endif // _MSC_VER > 1000
-
-#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
-
-#include <windows.h>
-
-
-// TODO: reference additional headers your program requires here
-#include "config.h"
-#include <string.h>
-#include "afterbase.h"
-#include "../afterimage.h"
-#include "../bmp.h"
-
-//{{AFX_INSERT_LOCATION}}
-// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
-
-#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
+// stdafx.h : include file for standard system include files,
+//  or project specific include files that are used frequently, but
+//      are changed infrequently
+//
+
+#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
+#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_
+
+#if _MSC_VER > 1000
+#pragma once
+#endif // _MSC_VER > 1000
+
+#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
+
+#include <windows.h>
+
+
+// TODO: reference additional headers your program requires here
+#include "config.h"
+#include <string.h>
+#include "afterbase.h"
+#include "../afterimage.h"
+#include "../bmp.h"
+
+//{{AFX_INSERT_LOCATION}}
+// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
+
+#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
diff -Naur libAfterImage-1.20/win32/afterbase.h root/graf2d/asimage/src/libAfterImage/win32/afterbase.h
--- libAfterImage-1.20/win32/afterbase.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/win32/afterbase.h	2018-12-08 08:18:38.000000000 +0100
@@ -1,12 +1,12 @@
 #ifndef AFTERBASE_H_HEADER_INCLUDED
 #define AFTERBASE_H_HEADER_INCLUDED
-
+
 #define HAVE_AFTERBASE_FLAG 0
-
-
-# include "../asim_afterbase.h"
-
-#define R_OK 04
-
+
+
+# include "../asim_afterbase.h"
+
+#define R_OK 04
+
 #endif /* AFTERBASE_H_HEADER_INCLUDED */
 
diff -Naur libAfterImage-1.20/win32/asview.cpp root/graf2d/asimage/src/libAfterImage/win32/asview.cpp
--- libAfterImage-1.20/win32/asview.cpp	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/win32/asview.cpp	2018-12-08 08:18:38.000000000 +0100
@@ -1,159 +1,159 @@
-// asview.cpp : Defines the entry point for the application.
-//
-
-#include "stdafx.h"
-
-void usage()
-{
-	printf( "Usage: asview [-h]|[image]\n");
-	printf( "Where: image - filename of the image to display.\n");
-}
-
-LRESULT CALLBACK MyWindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
-void show_system_error();
-
-
-HINSTANCE hinst; 
-HWND hWnd = NULL ;
-void *bmbits = NULL ;
-BITMAPINFO *bmi = NULL ;
-
-
-int APIENTRY 
-WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR lpCmdLine, int nCmdShow)
-{
-	char *image_file = "../apps/rose512.jpg" ;
-	
-//	char *image_file = "../apps/fore.xpm" ;
-	ASImage *im ;
-	WNDCLASSEX wnd_class ; 
-	ASVisual *asv ;
-	MSG msg; 
-
-	if( lpCmdLine != NULL && strncmp( lpCmdLine, "-h", 2 ) == 0 )
-	{
-		usage();
-		return 0;
-	}else if( lpCmdLine  != NULL && strlen(lpCmdLine) > 0 ) 
-		image_file = lpCmdLine ;
-	else
-		usage();
-
-	if( image_file[0] == '\"' ) 
-	{
-		int i = 0;
-		while( image_file[i+1] != '\0' && image_file[i+1] !=  '\"')
-		{
-			image_file[i] = image_file[i+1] ; 
-			++i ;
-		}
-		image_file[i] = '\0' ;
-	}
-
-	asv = create_asvisual( NULL, 0, 0, NULL );
-
-	im = file2ASImage( image_file, 0xFFFFFFFF, SCREEN_GAMMA, 0, NULL );
-	if( im == NULL ) 
-	{
-		MessageBox( NULL, "Unable to load image from file.", image_file, MB_OK | MB_ICONINFORMATION );
-		return 0 ;
-	}
-	
-	/* converting result into BMP file ( as an example ) */
-	/* ASImage2file( im, NULL, "asview.bmp", ASIT_Bmp, NULL ); */
-	
-	/* The following could be used to dump JPEG version of the image into
-	 * stdout : */
-	/* ASImage2file( im, NULL, NULL, ASIT_Jpeg, NULL ); */
-
-
-	bmbits = NULL ;
-	// Convert ASImage into DIB: 
-	bmi = ASImage2DBI( asv, im, 0, 0, im->width, im->height, &bmbits );
-
-	if( bmi == NULL ) 
-	{
-		MessageBox( NULL, "Failed to convert image into Windows bitmap.", image_file, MB_OK | MB_ICONINFORMATION );
-		return 0 ;
-	}
-
-	memset( &wnd_class, 0x00, sizeof(wnd_class));
-	wnd_class.cbSize = sizeof(wnd_class);
-	wnd_class.hInstance = hInstance ;
-	wnd_class.lpszClassName = "ASView" ;
-	wnd_class.lpfnWndProc = MyWindowProc ;
-    wnd_class.hIcon = LoadIcon((HINSTANCE) NULL, IDI_APPLICATION); 
-    wnd_class.hCursor = LoadCursor((HINSTANCE) NULL, IDC_ARROW); 
-	wnd_class.hbrBackground = (struct HBRUSH__ *)GetStockObject(WHITE_BRUSH); 
-        
-	if( !RegisterClassEx( &wnd_class ) ) 
-	{
-		show_system_error();
-		return 0 ;
-	}
-
-	hinst = hInstance ;
-	/* Now let us create a window and display image in that window : */
-	hWnd = CreateWindow( "ASView",  image_file,
-						 WS_OVERLAPPEDWINDOW,  
-						 CW_USEDEFAULT, CW_USEDEFAULT, 
-						 bmi->bmiHeader.biWidth, bmi->bmiHeader.biHeight,          
-						 (HWND) NULL, (HMENU)NULL, hinst, NULL );
-	if (!hWnd) 
-	{
-		show_system_error();
-        return FALSE; 
-	}
-
-    // Show the window and paint its contents. 
-    ShowWindow(hWnd, nCmdShow); 
-    UpdateWindow(hWnd); 
-
-    // Start the message loop. 
-    while (GetMessage(&msg, hWnd, 0, 0) > 0 ) 
-    { 
-        TranslateMessage(&msg); 
-        DispatchMessage(&msg); 
-	} 
-	return 0;
-}
-
-LRESULT CALLBACK 
-MyWindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
-{
-	if( uMsg == WM_PAINT )
-	{
-		// Paint image in responce to WM_PAINT event : 
-		if( bmi != NULL && bmbits != NULL ) 
-		{
-			PAINTSTRUCT ps ;
-			HDC dc  = BeginPaint(hWnd, &ps );
-			StretchDIBits(	dc,                // handle to device context
-							0, 0, bmi->bmiHeader.biWidth, bmi->bmiHeader.biHeight, 
-							0, 0, bmi->bmiHeader.biWidth, bmi->bmiHeader.biHeight,  
-							bmbits, bmi, DIB_RGB_COLORS, SRCCOPY );	
-			EndPaint(hWnd, &ps );
-  
-		}
-		return 0;
-	}
-	
-	return DefWindowProc( hwnd, uMsg, wParam, lParam ) ;
-}
-
-void
-show_system_error()
-{
-	LPVOID lpMsgBuf;
-	FormatMessage( 
-		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
-		FORMAT_MESSAGE_FROM_SYSTEM | 
-		FORMAT_MESSAGE_IGNORE_INSERTS,
-		NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &lpMsgBuf,
-		0, NULL );
-	MessageBox( NULL, (LPCTSTR)lpMsgBuf, "ASView System Error", MB_OK | MB_ICONINFORMATION );
-	// Free the buffer.
-	LocalFree( lpMsgBuf );
-}
-
-
+// asview.cpp : Defines the entry point for the application.
+//
+
+#include "stdafx.h"
+
+void usage()
+{
+	printf( "Usage: asview [-h]|[image]\n");
+	printf( "Where: image - filename of the image to display.\n");
+}
+
+LRESULT CALLBACK MyWindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
+void show_system_error();
+
+
+HINSTANCE hinst; 
+HWND hWnd = NULL ;
+void *bmbits = NULL ;
+BITMAPINFO *bmi = NULL ;
+
+
+int APIENTRY 
+WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR lpCmdLine, int nCmdShow)
+{
+	char *image_file = "../apps/rose512.jpg" ;
+	
+//	char *image_file = "../apps/fore.xpm" ;
+	ASImage *im ;
+	WNDCLASSEX wnd_class ; 
+	ASVisual *asv ;
+	MSG msg; 
+
+	if( lpCmdLine != NULL && strncmp( lpCmdLine, "-h", 2 ) == 0 )
+	{
+		usage();
+		return 0;
+	}else if( lpCmdLine  != NULL && strlen(lpCmdLine) > 0 ) 
+		image_file = lpCmdLine ;
+	else
+		usage();
+
+	if( image_file[0] == '\"' ) 
+	{
+		int i = 0;
+		while( image_file[i+1] != '\0' && image_file[i+1] !=  '\"')
+		{
+			image_file[i] = image_file[i+1] ; 
+			++i ;
+		}
+		image_file[i] = '\0' ;
+	}
+
+	asv = create_asvisual( NULL, 0, 0, NULL );
+
+	im = file2ASImage( image_file, 0xFFFFFFFF, SCREEN_GAMMA, 0, NULL );
+	if( im == NULL ) 
+	{
+		MessageBox( NULL, "Unable to load image from file.", image_file, MB_OK | MB_ICONINFORMATION );
+		return 0 ;
+	}
+	
+	/* converting result into BMP file ( as an example ) */
+	/* ASImage2file( im, NULL, "asview.bmp", ASIT_Bmp, NULL ); */
+	
+	/* The following could be used to dump JPEG version of the image into
+	 * stdout : */
+	/* ASImage2file( im, NULL, NULL, ASIT_Jpeg, NULL ); */
+
+
+	bmbits = NULL ;
+	// Convert ASImage into DIB: 
+	bmi = ASImage2DBI( asv, im, 0, 0, im->width, im->height, &bmbits );
+
+	if( bmi == NULL ) 
+	{
+		MessageBox( NULL, "Failed to convert image into Windows bitmap.", image_file, MB_OK | MB_ICONINFORMATION );
+		return 0 ;
+	}
+
+	memset( &wnd_class, 0x00, sizeof(wnd_class));
+	wnd_class.cbSize = sizeof(wnd_class);
+	wnd_class.hInstance = hInstance ;
+	wnd_class.lpszClassName = "ASView" ;
+	wnd_class.lpfnWndProc = MyWindowProc ;
+    wnd_class.hIcon = LoadIcon((HINSTANCE) NULL, IDI_APPLICATION); 
+    wnd_class.hCursor = LoadCursor((HINSTANCE) NULL, IDC_ARROW); 
+	wnd_class.hbrBackground = (struct HBRUSH__ *)GetStockObject(WHITE_BRUSH); 
+        
+	if( !RegisterClassEx( &wnd_class ) ) 
+	{
+		show_system_error();
+		return 0 ;
+	}
+
+	hinst = hInstance ;
+	/* Now let us create a window and display image in that window : */
+	hWnd = CreateWindow( "ASView",  image_file,
+						 WS_OVERLAPPEDWINDOW,  
+						 CW_USEDEFAULT, CW_USEDEFAULT, 
+						 bmi->bmiHeader.biWidth, bmi->bmiHeader.biHeight,          
+						 (HWND) NULL, (HMENU)NULL, hinst, NULL );
+	if (!hWnd) 
+	{
+		show_system_error();
+        return FALSE; 
+	}
+
+    // Show the window and paint its contents. 
+    ShowWindow(hWnd, nCmdShow); 
+    UpdateWindow(hWnd); 
+
+    // Start the message loop. 
+    while (GetMessage(&msg, hWnd, 0, 0) > 0 ) 
+    { 
+        TranslateMessage(&msg); 
+        DispatchMessage(&msg); 
+	} 
+	return 0;
+}
+
+LRESULT CALLBACK 
+MyWindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
+{
+	if( uMsg == WM_PAINT )
+	{
+		// Paint image in responce to WM_PAINT event : 
+		if( bmi != NULL && bmbits != NULL ) 
+		{
+			PAINTSTRUCT ps ;
+			HDC dc  = BeginPaint(hWnd, &ps );
+			StretchDIBits(	dc,                // handle to device context
+							0, 0, bmi->bmiHeader.biWidth, bmi->bmiHeader.biHeight, 
+							0, 0, bmi->bmiHeader.biWidth, bmi->bmiHeader.biHeight,  
+							bmbits, bmi, DIB_RGB_COLORS, SRCCOPY );	
+			EndPaint(hWnd, &ps );
+  
+		}
+		return 0;
+	}
+	
+	return DefWindowProc( hwnd, uMsg, wParam, lParam ) ;
+}
+
+void
+show_system_error()
+{
+	LPVOID lpMsgBuf;
+	FormatMessage( 
+		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
+		FORMAT_MESSAGE_FROM_SYSTEM | 
+		FORMAT_MESSAGE_IGNORE_INSERTS,
+		NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &lpMsgBuf,
+		0, NULL );
+	MessageBox( NULL, (LPCTSTR)lpMsgBuf, "ASView System Error", MB_OK | MB_ICONINFORMATION );
+	// Free the buffer.
+	LocalFree( lpMsgBuf );
+}
+
+
diff -Naur libAfterImage-1.20/win32/asview.mak root/graf2d/asimage/src/libAfterImage/win32/asview.mak
--- libAfterImage-1.20/win32/asview.mak	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/win32/asview.mak	2018-12-08 08:18:38.000000000 +0100
@@ -1,229 +1,229 @@
-# Microsoft Developer Studio Generated NMAKE File, Based on asview.dsp
-!IF "$(CFG)" == ""
-CFG=asview - Win32 Debug
-!MESSAGE No configuration specified. Defaulting to asview - Win32 Debug.
-!ENDIF 
-
-!IF "$(CFG)" != "asview - Win32 Release" && "$(CFG)" != "asview - Win32 Debug"
-!MESSAGE Invalid configuration "$(CFG)" specified.
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "asview.mak" CFG="asview - Win32 Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "asview - Win32 Release" (based on "Win32 (x86) Application")
-!MESSAGE "asview - Win32 Debug" (based on "Win32 (x86) Application")
-!MESSAGE 
-!ERROR An invalid configuration is specified.
-!ENDIF 
-
-!IF "$(OS)" == "Windows_NT"
-NULL=
-!ELSE 
-NULL=nul
-!ENDIF 
-
-CPP=cl.exe
-MTL=midl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "asview - Win32 Release"
-
-OUTDIR=.\Release
-INTDIR=.\Release
-
-!IF "$(RECURSE)" == "0" 
-
-ALL : ".\asview.exe"
-
-!ELSE 
-
-ALL : "libAfterImage - Win32 Release" ".\asview.exe"
-
-!ENDIF 
-
-!IF "$(RECURSE)" == "1" 
-CLEAN :"libAfterImage - Win32 ReleaseCLEAN" 
-!ELSE 
-CLEAN :
-!ENDIF 
-	-@erase "$(INTDIR)\asview.obj"
-	-@erase "$(INTDIR)\asview.pch"
-	-@erase "$(INTDIR)\StdAfx.obj"
-	-@erase "$(INTDIR)\vc60.idb"
-	-@erase ".\asview.exe"
-
-"$(OUTDIR)" :
-    if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
-
-CPP_PROJ=/nologo /ML /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /Fp"$(INTDIR)\asview.pch" /Yu"stdafx.h" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
-MTL_PROJ=/nologo /D "NDEBUG" /mktyplib203 /win32 
-BSC32=bscmake.exe
-BSC32_FLAGS=/nologo /o"$(OUTDIR)\asview.bsc" 
-BSC32_SBRS= \
-	
-LINK32=link.exe
-LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /incremental:no /pdb:"$(OUTDIR)\asview.pdb" /machine:I386 /nodefaultlib:"LIBCD" /out:"asview.exe" /editandcontinue:NO 
-LINK32_OBJS= \
-	"$(INTDIR)\asview.obj" \
-	"$(INTDIR)\StdAfx.obj" \
-	"..\libAfterImage.lib"
-
-".\asview.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
-    $(LINK32) @<<
-  $(LINK32_FLAGS) $(LINK32_OBJS)
-<<
-
-!ELSEIF  "$(CFG)" == "asview - Win32 Debug"
-
-OUTDIR=.\Debug
-INTDIR=.\Debug
-
-!IF "$(RECURSE)" == "0" 
-
-ALL : ".\asview.exe"
-
-!ELSE 
-
-ALL : "libAfterImage - Win32 Debug" ".\asview.exe"
-
-!ENDIF 
-
-!IF "$(RECURSE)" == "1" 
-CLEAN :"libAfterImage - Win32 DebugCLEAN" 
-!ELSE 
-CLEAN :
-!ENDIF 
-	-@erase "$(INTDIR)\asview.obj"
-	-@erase "$(INTDIR)\asview.pch"
-	-@erase "$(INTDIR)\StdAfx.obj"
-	-@erase "$(INTDIR)\vc60.idb"
-	-@erase "$(INTDIR)\vc60.pdb"
-	-@erase "$(OUTDIR)\asview.pdb"
-	-@erase ".\asview.exe"
-	-@erase ".\asview.ilk"
-
-"$(OUTDIR)" :
-    if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
-
-CPP_PROJ=/nologo /MLd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /Fp"$(INTDIR)\asview.pch" /Yu"stdafx.h" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
-MTL_PROJ=/nologo /D "_DEBUG" /mktyplib203 /win32 
-BSC32=bscmake.exe
-BSC32_FLAGS=/nologo /o"$(OUTDIR)\asview.bsc" 
-BSC32_SBRS= \
-	
-LINK32=link.exe
-LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /incremental:yes /pdb:"$(OUTDIR)\asview.pdb" /debug /machine:I386 /nodefaultlib:"LIBC" /out:"asview.exe" /pdbtype:sept 
-LINK32_OBJS= \
-	"$(INTDIR)\asview.obj" \
-	"$(INTDIR)\StdAfx.obj" \
-	"..\libAfterImage.lib"
-
-".\asview.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
-    $(LINK32) @<<
-  $(LINK32_FLAGS) $(LINK32_OBJS)
-<<
-
-!ENDIF 
-
-.c{$(INTDIR)}.obj::
-   $(CPP) @<<
-   $(CPP_PROJ) $< 
-<<
-
-.cpp{$(INTDIR)}.obj::
-   $(CPP) @<<
-   $(CPP_PROJ) $< 
-<<
-
-.cxx{$(INTDIR)}.obj::
-   $(CPP) @<<
-   $(CPP_PROJ) $< 
-<<
-
-.c{$(INTDIR)}.sbr::
-   $(CPP) @<<
-   $(CPP_PROJ) $< 
-<<
-
-.cpp{$(INTDIR)}.sbr::
-   $(CPP) @<<
-   $(CPP_PROJ) $< 
-<<
-
-.cxx{$(INTDIR)}.sbr::
-   $(CPP) @<<
-   $(CPP_PROJ) $< 
-<<
-
-
-!IF "$(NO_EXTERNAL_DEPS)" != "1"
-!IF EXISTS("asview.dep")
-!INCLUDE "asview.dep"
-!ELSE 
-!MESSAGE Warning: cannot find "asview.dep"
-!ENDIF 
-!ENDIF 
-
-
-!IF "$(CFG)" == "asview - Win32 Release" || "$(CFG)" == "asview - Win32 Debug"
-SOURCE=.\asview.cpp
-
-"$(INTDIR)\asview.obj" : $(SOURCE) "$(INTDIR)" "$(INTDIR)\asview.pch"
-
-
-SOURCE=.\StdAfx.cpp
-
-!IF  "$(CFG)" == "asview - Win32 Release"
-
-CPP_SWITCHES=/nologo /ML /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /Fp"$(INTDIR)\asview.pch" /Yc"stdafx.h" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
-
-"$(INTDIR)\StdAfx.obj"	"$(INTDIR)\asview.pch" : $(SOURCE) "$(INTDIR)"
-	$(CPP) @<<
-  $(CPP_SWITCHES) $(SOURCE)
-<<
-
-
-!ELSEIF  "$(CFG)" == "asview - Win32 Debug"
-
-CPP_SWITCHES=/nologo /MLd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /Fp"$(INTDIR)\asview.pch" /Yc"stdafx.h" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
-
-"$(INTDIR)\StdAfx.obj"	"$(INTDIR)\asview.pch" : $(SOURCE) "$(INTDIR)"
-	$(CPP) @<<
-  $(CPP_SWITCHES) $(SOURCE)
-<<
-
-
-!ENDIF 
-
-!IF  "$(CFG)" == "asview - Win32 Release"
-
-"libAfterImage - Win32 Release" : 
-   cd "\devel\AfterStep\afterstep-stable\libAfterImage"
-   $(MAKE) /$(MAKEFLAGS) /F ".\libAfterImage.mak" CFG="libAfterImage - Win32 Release" 
-   cd ".\win32"
-
-"libAfterImage - Win32 ReleaseCLEAN" : 
-   cd "\devel\AfterStep\afterstep-stable\libAfterImage"
-   $(MAKE) /$(MAKEFLAGS) /F ".\libAfterImage.mak" CFG="libAfterImage - Win32 Release" RECURSE=1 CLEAN 
-   cd ".\win32"
-
-!ELSEIF  "$(CFG)" == "asview - Win32 Debug"
-
-"libAfterImage - Win32 Debug" : 
-   cd "\devel\AfterStep\afterstep-stable\libAfterImage"
-   $(MAKE) /$(MAKEFLAGS) /F ".\libAfterImage.mak" CFG="libAfterImage - Win32 Debug" 
-   cd ".\win32"
-
-"libAfterImage - Win32 DebugCLEAN" : 
-   cd "\devel\AfterStep\afterstep-stable\libAfterImage"
-   $(MAKE) /$(MAKEFLAGS) /F ".\libAfterImage.mak" CFG="libAfterImage - Win32 Debug" RECURSE=1 CLEAN 
-   cd ".\win32"
-
-!ENDIF 
-
-
-!ENDIF 
-
+# Microsoft Developer Studio Generated NMAKE File, Based on asview.dsp
+!IF "$(CFG)" == ""
+CFG=asview - Win32 Debug
+!MESSAGE No configuration specified. Defaulting to asview - Win32 Debug.
+!ENDIF 
+
+!IF "$(CFG)" != "asview - Win32 Release" && "$(CFG)" != "asview - Win32 Debug"
+!MESSAGE Invalid configuration "$(CFG)" specified.
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "asview.mak" CFG="asview - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "asview - Win32 Release" (based on "Win32 (x86) Application")
+!MESSAGE "asview - Win32 Debug" (based on "Win32 (x86) Application")
+!MESSAGE 
+!ERROR An invalid configuration is specified.
+!ENDIF 
+
+!IF "$(OS)" == "Windows_NT"
+NULL=
+!ELSE 
+NULL=nul
+!ENDIF 
+
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "asview - Win32 Release"
+
+OUTDIR=.\Release
+INTDIR=.\Release
+
+!IF "$(RECURSE)" == "0" 
+
+ALL : ".\asview.exe"
+
+!ELSE 
+
+ALL : "libAfterImage - Win32 Release" ".\asview.exe"
+
+!ENDIF 
+
+!IF "$(RECURSE)" == "1" 
+CLEAN :"libAfterImage - Win32 ReleaseCLEAN" 
+!ELSE 
+CLEAN :
+!ENDIF 
+	-@erase "$(INTDIR)\asview.obj"
+	-@erase "$(INTDIR)\asview.pch"
+	-@erase "$(INTDIR)\StdAfx.obj"
+	-@erase "$(INTDIR)\vc60.idb"
+	-@erase ".\asview.exe"
+
+"$(OUTDIR)" :
+    if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
+
+CPP_PROJ=/nologo /ML /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /Fp"$(INTDIR)\asview.pch" /Yu"stdafx.h" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
+MTL_PROJ=/nologo /D "NDEBUG" /mktyplib203 /win32 
+BSC32=bscmake.exe
+BSC32_FLAGS=/nologo /o"$(OUTDIR)\asview.bsc" 
+BSC32_SBRS= \
+	
+LINK32=link.exe
+LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /incremental:no /pdb:"$(OUTDIR)\asview.pdb" /machine:I386 /nodefaultlib:"LIBCD" /out:"asview.exe" /editandcontinue:NO 
+LINK32_OBJS= \
+	"$(INTDIR)\asview.obj" \
+	"$(INTDIR)\StdAfx.obj" \
+	"..\libAfterImage.lib"
+
+".\asview.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
+    $(LINK32) @<<
+  $(LINK32_FLAGS) $(LINK32_OBJS)
+<<
+
+!ELSEIF  "$(CFG)" == "asview - Win32 Debug"
+
+OUTDIR=.\Debug
+INTDIR=.\Debug
+
+!IF "$(RECURSE)" == "0" 
+
+ALL : ".\asview.exe"
+
+!ELSE 
+
+ALL : "libAfterImage - Win32 Debug" ".\asview.exe"
+
+!ENDIF 
+
+!IF "$(RECURSE)" == "1" 
+CLEAN :"libAfterImage - Win32 DebugCLEAN" 
+!ELSE 
+CLEAN :
+!ENDIF 
+	-@erase "$(INTDIR)\asview.obj"
+	-@erase "$(INTDIR)\asview.pch"
+	-@erase "$(INTDIR)\StdAfx.obj"
+	-@erase "$(INTDIR)\vc60.idb"
+	-@erase "$(INTDIR)\vc60.pdb"
+	-@erase "$(OUTDIR)\asview.pdb"
+	-@erase ".\asview.exe"
+	-@erase ".\asview.ilk"
+
+"$(OUTDIR)" :
+    if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
+
+CPP_PROJ=/nologo /MLd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /Fp"$(INTDIR)\asview.pch" /Yu"stdafx.h" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
+MTL_PROJ=/nologo /D "_DEBUG" /mktyplib203 /win32 
+BSC32=bscmake.exe
+BSC32_FLAGS=/nologo /o"$(OUTDIR)\asview.bsc" 
+BSC32_SBRS= \
+	
+LINK32=link.exe
+LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /incremental:yes /pdb:"$(OUTDIR)\asview.pdb" /debug /machine:I386 /nodefaultlib:"LIBC" /out:"asview.exe" /pdbtype:sept 
+LINK32_OBJS= \
+	"$(INTDIR)\asview.obj" \
+	"$(INTDIR)\StdAfx.obj" \
+	"..\libAfterImage.lib"
+
+".\asview.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
+    $(LINK32) @<<
+  $(LINK32_FLAGS) $(LINK32_OBJS)
+<<
+
+!ENDIF 
+
+.c{$(INTDIR)}.obj::
+   $(CPP) @<<
+   $(CPP_PROJ) $< 
+<<
+
+.cpp{$(INTDIR)}.obj::
+   $(CPP) @<<
+   $(CPP_PROJ) $< 
+<<
+
+.cxx{$(INTDIR)}.obj::
+   $(CPP) @<<
+   $(CPP_PROJ) $< 
+<<
+
+.c{$(INTDIR)}.sbr::
+   $(CPP) @<<
+   $(CPP_PROJ) $< 
+<<
+
+.cpp{$(INTDIR)}.sbr::
+   $(CPP) @<<
+   $(CPP_PROJ) $< 
+<<
+
+.cxx{$(INTDIR)}.sbr::
+   $(CPP) @<<
+   $(CPP_PROJ) $< 
+<<
+
+
+!IF "$(NO_EXTERNAL_DEPS)" != "1"
+!IF EXISTS("asview.dep")
+!INCLUDE "asview.dep"
+!ELSE 
+!MESSAGE Warning: cannot find "asview.dep"
+!ENDIF 
+!ENDIF 
+
+
+!IF "$(CFG)" == "asview - Win32 Release" || "$(CFG)" == "asview - Win32 Debug"
+SOURCE=.\asview.cpp
+
+"$(INTDIR)\asview.obj" : $(SOURCE) "$(INTDIR)" "$(INTDIR)\asview.pch"
+
+
+SOURCE=.\StdAfx.cpp
+
+!IF  "$(CFG)" == "asview - Win32 Release"
+
+CPP_SWITCHES=/nologo /ML /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /Fp"$(INTDIR)\asview.pch" /Yc"stdafx.h" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
+
+"$(INTDIR)\StdAfx.obj"	"$(INTDIR)\asview.pch" : $(SOURCE) "$(INTDIR)"
+	$(CPP) @<<
+  $(CPP_SWITCHES) $(SOURCE)
+<<
+
+
+!ELSEIF  "$(CFG)" == "asview - Win32 Debug"
+
+CPP_SWITCHES=/nologo /MLd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /Fp"$(INTDIR)\asview.pch" /Yc"stdafx.h" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
+
+"$(INTDIR)\StdAfx.obj"	"$(INTDIR)\asview.pch" : $(SOURCE) "$(INTDIR)"
+	$(CPP) @<<
+  $(CPP_SWITCHES) $(SOURCE)
+<<
+
+
+!ENDIF 
+
+!IF  "$(CFG)" == "asview - Win32 Release"
+
+"libAfterImage - Win32 Release" : 
+   cd "\devel\AfterStep\afterstep-stable\libAfterImage"
+   $(MAKE) /$(MAKEFLAGS) /F ".\libAfterImage.mak" CFG="libAfterImage - Win32 Release" 
+   cd ".\win32"
+
+"libAfterImage - Win32 ReleaseCLEAN" : 
+   cd "\devel\AfterStep\afterstep-stable\libAfterImage"
+   $(MAKE) /$(MAKEFLAGS) /F ".\libAfterImage.mak" CFG="libAfterImage - Win32 Release" RECURSE=1 CLEAN 
+   cd ".\win32"
+
+!ELSEIF  "$(CFG)" == "asview - Win32 Debug"
+
+"libAfterImage - Win32 Debug" : 
+   cd "\devel\AfterStep\afterstep-stable\libAfterImage"
+   $(MAKE) /$(MAKEFLAGS) /F ".\libAfterImage.mak" CFG="libAfterImage - Win32 Debug" 
+   cd ".\win32"
+
+"libAfterImage - Win32 DebugCLEAN" : 
+   cd "\devel\AfterStep\afterstep-stable\libAfterImage"
+   $(MAKE) /$(MAKEFLAGS) /F ".\libAfterImage.mak" CFG="libAfterImage - Win32 Debug" RECURSE=1 CLEAN 
+   cd ".\win32"
+
+!ENDIF 
+
+
+!ENDIF 
+
diff -Naur libAfterImage-1.20/win32/config.h root/graf2d/asimage/src/libAfterImage/win32/config.h
--- libAfterImage-1.20/win32/config.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/win32/config.h	2018-12-08 08:18:38.000000000 +0100
@@ -1,5 +1,6 @@
 /* config.h.in.  Generated from configure.in by autoheader.  */
-
+#ifndef WIN32_CONFIG_H
+#define WIN32_CONFIG_H
 /* Define if memory allocation logging and debugging is desired */
 #undef DEBUG_ALLOCS
 
@@ -176,3 +177,5 @@
 /* Define as `__inline' if that's what the C compiler calls it, or to nothing
    if it is not supported. */
 #define inline
+
+#endif
\ No newline at end of file
diff -Naur libAfterImage-1.20/zlib/adler32.c root/graf2d/asimage/src/libAfterImage/zlib/adler32.c
--- libAfterImage-1.20/zlib/adler32.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/zlib/adler32.c	2018-12-08 08:18:38.000000000 +0100
@@ -3,7 +3,7 @@
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* @(#) $Id: adler32.c,v 1.2 2007-08-01 20:31:52 sasha Exp $ */
+/* @(#) $Id$ */
 
 #define ZLIB_INTERNAL
 #include "zlib.h"
diff -Naur libAfterImage-1.20/zlib/compress.c root/graf2d/asimage/src/libAfterImage/zlib/compress.c
--- libAfterImage-1.20/zlib/compress.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/zlib/compress.c	2018-12-08 08:18:38.000000000 +0100
@@ -3,7 +3,7 @@
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* @(#) $Id: compress.c,v 1.1 2004-03-16 23:15:28 sasha Exp $ */
+/* @(#) $Id$ */
 
 #define ZLIB_INTERNAL
 #include "zlib.h"
diff -Naur libAfterImage-1.20/zlib/crc32.c root/graf2d/asimage/src/libAfterImage/zlib/crc32.c
--- libAfterImage-1.20/zlib/crc32.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/zlib/crc32.c	2018-12-08 08:18:38.000000000 +0100
@@ -9,7 +9,7 @@
  * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
  */
 
-/* @(#) $Id: crc32.c,v 1.2 2007-08-01 20:31:52 sasha Exp $ */
+/* @(#) $Id$ */
 
 /*
   Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
diff -Naur libAfterImage-1.20/zlib/deflate.c root/graf2d/asimage/src/libAfterImage/zlib/deflate.c
--- libAfterImage-1.20/zlib/deflate.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/zlib/deflate.c	2018-12-08 08:18:38.000000000 +0100
@@ -47,7 +47,7 @@
  *
  */
 
-/* @(#) $Id: deflate.c,v 1.2 2007-08-01 20:31:52 sasha Exp $ */
+/* @(#) $Id$ */
 
 #include "deflate.h"
 
diff -Naur libAfterImage-1.20/zlib/deflate.h root/graf2d/asimage/src/libAfterImage/zlib/deflate.h
--- libAfterImage-1.20/zlib/deflate.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/zlib/deflate.h	2018-12-08 08:18:38.000000000 +0100
@@ -8,7 +8,7 @@
    subject to change. Applications should only use zlib.h.
  */
 
-/* @(#) $Id: deflate.h,v 1.2 2007-08-01 20:31:52 sasha Exp $ */
+/* @(#) $Id$ */
 
 #ifndef DEFLATE_H
 #define DEFLATE_H
diff -Naur libAfterImage-1.20/zlib/gzio.c root/graf2d/asimage/src/libAfterImage/zlib/gzio.c
--- libAfterImage-1.20/zlib/gzio.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/zlib/gzio.c	2018-12-08 08:18:38.000000000 +0100
@@ -5,7 +5,7 @@
  * Compile this file with -DNO_GZCOMPRESS to avoid the compression code.
  */
 
-/* @(#) $Id: gzio.c,v 1.2 2007-08-01 20:31:52 sasha Exp $ */
+/* @(#) $Id$ */
 
 #include <stdio.h>
 
diff -Naur libAfterImage-1.20/zlib/trees.c root/graf2d/asimage/src/libAfterImage/zlib/trees.c
--- libAfterImage-1.20/zlib/trees.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/zlib/trees.c	2018-12-08 08:18:38.000000000 +0100
@@ -29,7 +29,7 @@
  *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
  */
 
-/* @(#) $Id: trees.c,v 1.2 2007-08-01 20:31:52 sasha Exp $ */
+/* @(#) $Id$ */
 
 /* #define GEN_TREES_H */
 
diff -Naur libAfterImage-1.20/zlib/uncompr.c root/graf2d/asimage/src/libAfterImage/zlib/uncompr.c
--- libAfterImage-1.20/zlib/uncompr.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/zlib/uncompr.c	2018-12-08 08:18:38.000000000 +0100
@@ -3,7 +3,7 @@
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* @(#) $Id: uncompr.c,v 1.1 2004-03-16 23:15:28 sasha Exp $ */
+/* @(#) $Id$ */
 
 #define ZLIB_INTERNAL
 #include "zlib.h"
diff -Naur libAfterImage-1.20/zlib/zconf.h root/graf2d/asimage/src/libAfterImage/zlib/zconf.h
--- libAfterImage-1.20/zlib/zconf.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/zlib/zconf.h	2018-12-08 08:18:38.000000000 +0100
@@ -3,7 +3,7 @@
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* @(#) $Id: zconf.h,v 1.2 2004-12-09 17:36:19 sasha Exp $ */
+/* @(#) $Id$ */
 
 #ifndef ZCONF_H
 #define ZCONF_H
diff -Naur libAfterImage-1.20/zlib/zlib.h root/graf2d/asimage/src/libAfterImage/zlib/zlib.h
--- libAfterImage-1.20/zlib/zlib.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/zlib/zlib.h	2018-12-08 08:18:38.000000000 +0100
@@ -869,7 +869,7 @@
      See inflateBack() for the usage of these routines.
 
      inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
-   the paramaters are invalid, Z_MEM_ERROR if the internal state could not
+   the parameters are invalid, Z_MEM_ERROR if the internal state could not
    be allocated, or Z_VERSION_ERROR if the version of the library does not
    match the version of the header file.
 */
diff -Naur libAfterImage-1.20/zlib/zutil.c root/graf2d/asimage/src/libAfterImage/zlib/zutil.c
--- libAfterImage-1.20/zlib/zutil.c	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/zlib/zutil.c	2018-12-08 08:18:38.000000000 +0100
@@ -3,7 +3,7 @@
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* @(#) $Id: zutil.c,v 1.2 2007-08-01 20:31:52 sasha Exp $ */
+/* @(#) $Id$ */
 
 #include "zutil.h"
 
diff -Naur libAfterImage-1.20/zlib/zutil.h root/graf2d/asimage/src/libAfterImage/zlib/zutil.h
--- libAfterImage-1.20/zlib/zutil.h	2011-01-15 06:52:22.000000000 +0100
+++ root/graf2d/asimage/src/libAfterImage/zlib/zutil.h	2018-12-08 08:18:38.000000000 +0100
@@ -8,7 +8,7 @@
    subject to change. Applications should only use zlib.h.
  */
 
-/* @(#) $Id: zutil.h,v 1.2 2007-08-01 20:31:52 sasha Exp $ */
+/* @(#) $Id$ */
 
 #ifndef ZUTIL_H
 #define ZUTIL_H
