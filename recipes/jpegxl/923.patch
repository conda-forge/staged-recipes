From 9be393bae98236030e0595af814caba7058a6a9e Mon Sep 17 00:00:00 2001
From: Jon Sneyers <jon@cloudinary.com>
Date: Mon, 29 Nov 2021 17:33:36 +0100
Subject: [PATCH] use libpng for all png decoding

---
 lib/extras/codec.cc                    |   9 +-
 lib/extras/codec_apng.cc               | 448 ++++++++++++++++++------
 lib/extras/codec_png.cc                | 461 -------------------------
 lib/extras/codec_png.h                 |   5 -
 tools/benchmark/benchmark_codec.cc     |   4 +
 tools/benchmark/benchmark_codec_png.cc |   5 +-
 tools/cjxl.cc                          |  12 +-
 7 files changed, 365 insertions(+), 579 deletions(-)

diff --git a/lib/extras/codec.cc b/lib/extras/codec.cc
index c46d8cc5c..6dafafdb6 100644
--- a/lib/extras/codec.cc
+++ b/lib/extras/codec.cc
@@ -97,15 +97,12 @@ Status SetFromBytes(const Span<const uint8_t> bytes,
 
   Codec codec;
   bool skip_ppf_conversion = false;
-  if (extras::DecodeImagePNG(bytes, color_hints, io->constraints, &ppf)) {
-    codec = Codec::kPNG;
-  }
 #if JPEGXL_ENABLE_APNG
-  else if (extras::DecodeImageAPNG(bytes, color_hints, io->constraints, &ppf)) {
+  if (extras::DecodeImageAPNG(bytes, color_hints, io->constraints, &ppf)) {
     codec = Codec::kPNG;
-  }
+  } else
 #endif
-  else if (extras::DecodeImagePGX(bytes, color_hints, io->constraints, &ppf)) {
+      if (extras::DecodeImagePGX(bytes, color_hints, io->constraints, &ppf)) {
     codec = Codec::kPGX;
   } else if (extras::DecodeImagePNM(bytes, color_hints, io->constraints,
                                     &ppf)) {
diff --git a/lib/extras/codec_apng.cc b/lib/extras/codec_apng.cc
index 1d9ae0b19..eb89a8743 100644
--- a/lib/extras/codec_apng.cc
+++ b/lib/extras/codec_apng.cc
@@ -46,6 +46,7 @@
 
 #include "jxl/encode.h"
 #include "lib/jxl/base/compiler_specific.h"
+#include "lib/jxl/base/printf_macros.h"
 #include "lib/jxl/color_encoding_internal.h"
 #include "lib/jxl/color_management.h"
 #include "lib/jxl/frame_header.h"
@@ -60,6 +61,184 @@ namespace extras {
 
 namespace {
 
+// Returns floating-point value from the PNG encoding (times 10^5).
+static double F64FromU32(const uint32_t x) {
+  return static_cast<int32_t>(x) * 1E-5;
+}
+
+Status DecodeSRGB(const unsigned char* payload, const size_t payload_size,
+                  JxlColorEncoding* color_encoding) {
+  if (payload_size != 1) return JXL_FAILURE("Wrong sRGB size");
+  // (PNG uses the same values as ICC.)
+  if (payload[0] >= 4) return JXL_FAILURE("Invalid Rendering Intent");
+  color_encoding->rendering_intent =
+      static_cast<JxlRenderingIntent>(payload[0]);
+  return true;
+}
+
+Status DecodeGAMA(const unsigned char* payload, const size_t payload_size,
+                  JxlColorEncoding* color_encoding) {
+  if (payload_size != 4) return JXL_FAILURE("Wrong gAMA size");
+  color_encoding->transfer_function = JXL_TRANSFER_FUNCTION_GAMMA;
+  color_encoding->gamma = F64FromU32(LoadBE32(payload));
+  return true;
+}
+
+Status DecodeCHRM(const unsigned char* payload, const size_t payload_size,
+                  JxlColorEncoding* color_encoding) {
+  if (payload_size != 32) return JXL_FAILURE("Wrong cHRM size");
+
+  color_encoding->white_point = JXL_WHITE_POINT_CUSTOM;
+  color_encoding->white_point_xy[0] = F64FromU32(LoadBE32(payload + 0));
+  color_encoding->white_point_xy[1] = F64FromU32(LoadBE32(payload + 4));
+
+  color_encoding->primaries = JXL_PRIMARIES_CUSTOM;
+  color_encoding->primaries_red_xy[0] = F64FromU32(LoadBE32(payload + 8));
+  color_encoding->primaries_red_xy[1] = F64FromU32(LoadBE32(payload + 12));
+  color_encoding->primaries_green_xy[0] = F64FromU32(LoadBE32(payload + 16));
+  color_encoding->primaries_green_xy[1] = F64FromU32(LoadBE32(payload + 20));
+  color_encoding->primaries_blue_xy[0] = F64FromU32(LoadBE32(payload + 24));
+  color_encoding->primaries_blue_xy[1] = F64FromU32(LoadBE32(payload + 28));
+  return true;
+}
+
+// Retrieves XMP and EXIF/IPTC from itext and text.
+class BlobsReaderPNG {
+ public:
+  static Status Decode(const png_text_struct& info, PackedMetadata* metadata) {
+    // We trust these are properly null-terminated by libpng.
+    const char* key = info.key;
+    const char* value = info.text;
+    if (strstr(key, "XML:com.adobe.xmp")) {
+      metadata->xmp.resize(strlen(value));  // safe, see above
+      memcpy(metadata->xmp.data(), value, metadata->xmp.size());
+    }
+
+    std::string type;
+    std::vector<uint8_t> bytes;
+
+    // Handle text chunks annotated with key "Raw profile type ####", with
+    // #### a type, which may contain metadata.
+    const char* kKey = "Raw profile type ";
+    if (strncmp(key, kKey, strlen(kKey)) != 0) return false;
+
+    if (!MaybeDecodeBase16(key, value, &type, &bytes)) {
+      JXL_WARNING("Couldn't parse 'Raw format type' text chunk");
+      return false;
+    }
+    if (type == "exif") {
+      if (!metadata->exif.empty()) {
+        JXL_WARNING("overwriting EXIF (%" PRIuS " bytes) with base16 (%" PRIuS
+                    " bytes)",
+                    metadata->exif.size(), bytes.size());
+      }
+      metadata->exif = std::move(bytes);
+    } else if (type == "iptc") {
+      // TODO (jon): Deal with IPTC in some way
+    } else if (type == "8bim") {
+      // TODO (jon): Deal with 8bim in some way
+    } else if (type == "xmp") {
+      if (!metadata->xmp.empty()) {
+        JXL_WARNING("overwriting XMP (%" PRIuS " bytes) with base16 (%" PRIuS
+                    " bytes)",
+                    metadata->xmp.size(), bytes.size());
+      }
+      metadata->xmp = std::move(bytes);
+    } else {
+      JXL_WARNING("Unknown type in 'Raw format type' text chunk: %s: %" PRIuS
+                  " bytes",
+                  type.c_str(), bytes.size());
+    }
+    return true;
+  }
+
+ private:
+  // Returns false if invalid.
+  static JXL_INLINE Status DecodeNibble(const char c,
+                                        uint32_t* JXL_RESTRICT nibble) {
+    if ('a' <= c && c <= 'f') {
+      *nibble = 10 + c - 'a';
+    } else if ('0' <= c && c <= '9') {
+      *nibble = c - '0';
+    } else {
+      *nibble = 0;
+      return JXL_FAILURE("Invalid metadata nibble");
+    }
+    JXL_ASSERT(*nibble < 16);
+    return true;
+  }
+
+  // Parses a PNG text chunk with key of the form "Raw profile type ####", with
+  // #### a type.
+  // Returns whether it could successfully parse the content.
+  // We trust key and encoded are null-terminated because they come from
+  // libpng.
+  static Status MaybeDecodeBase16(const char* key, const char* encoded,
+                                  std::string* type,
+                                  std::vector<uint8_t>* bytes) {
+    const char* encoded_end = encoded + strlen(encoded);
+
+    const char* kKey = "Raw profile type ";
+    if (strncmp(key, kKey, strlen(kKey)) != 0) return false;
+    *type = key + strlen(kKey);
+    const size_t kMaxTypeLen = 20;
+    if (type->length() > kMaxTypeLen) return false;  // Type too long
+
+    // Header: freeform string and number of bytes
+    // Expected format is:
+    // \n
+    // profile name/description\n
+    //       40\n               (the number of bytes after hex-decoding)
+    // 01234566789abcdef....\n  (72 bytes per line max).
+    // 012345667\n              (last line)
+    const char* pos = encoded;
+
+    if (*(pos++) != '\n') return false;
+    while (pos < encoded_end && *pos != '\n') {
+      pos++;
+    }
+    if (pos == encoded_end) return false;
+    // We parsed so far a \n, some number of non \n characters and are now
+    // pointing at a \n.
+    if (*(pos++) != '\n') return false;
+    unsigned long bytes_to_decode;
+    const int fields = sscanf(pos, "%8lu", &bytes_to_decode);
+    if (fields != 1) return false;  // Failed to decode metadata header
+    JXL_ASSERT(pos + 8 <= encoded_end);
+    pos += 8;  // read %8lu
+
+    // We need 2*bytes for the hex values plus 1 byte every 36 values.
+    const unsigned long needed_bytes =
+        bytes_to_decode * 2 + 1 + DivCeil(bytes_to_decode, 36);
+    if (needed_bytes != static_cast<size_t>(encoded_end - pos)) {
+      return JXL_FAILURE("Not enough bytes to parse %lu bytes in hex",
+                         bytes_to_decode);
+    }
+    JXL_ASSERT(bytes->empty());
+    bytes->reserve(bytes_to_decode);
+
+    // Encoding: base16 with newline after 72 chars.
+    // pos points to the \n before the first line of hex values.
+    for (size_t i = 0; i < bytes_to_decode; ++i) {
+      if (i % 36 == 0) {
+        if (pos + 1 >= encoded_end) return false;  // Truncated base16 1
+        if (*pos != '\n') return false;            // Expected newline
+        ++pos;
+      }
+
+      if (pos + 2 >= encoded_end) return false;  // Truncated base16 2;
+      uint32_t nibble0, nibble1;
+      JXL_RETURN_IF_ERROR(DecodeNibble(pos[0], &nibble0));
+      JXL_RETURN_IF_ERROR(DecodeNibble(pos[1], &nibble1));
+      bytes->push_back(static_cast<uint8_t>((nibble0 << 4) + nibble1));
+      pos += 2;
+    }
+    if (pos + 1 != encoded_end) return false;  // Too many encoded bytes
+    if (pos[0] != '\n') return false;          // Incorrect metadata terminator
+    return true;
+  }
+};
+
 constexpr bool isAbc(char c) {
   return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
 }
@@ -71,14 +250,15 @@ constexpr uint32_t kId_fcTL = 0x4C546366;
 constexpr uint32_t kId_IDAT = 0x54414449;
 constexpr uint32_t kId_fdAT = 0x54416466;
 constexpr uint32_t kId_IEND = 0x444E4549;
-
-struct CHUNK {
-  unsigned char* p;
-  unsigned int size;
-};
+constexpr uint32_t kId_iCCP = 0x50434369;
+constexpr uint32_t kId_sRGB = 0x42475273;
+constexpr uint32_t kId_gAMA = 0x414D4167;
+constexpr uint32_t kId_cHRM = 0x4D524863;
+constexpr uint32_t kId_eXIf = 0x66495865;
 
 struct APNGFrame {
-  unsigned char *p, **rows;
+  PaddedBytes pixels;
+  std::vector<uint8_t*> rows;
   unsigned int w, h, delay_num, delay_den;
 };
 
@@ -100,10 +280,8 @@ const size_t kMaxPNGChunkSize = 100000000;  // 100 MB
 
 void info_fn(png_structp png_ptr, png_infop info_ptr) {
   png_set_expand(png_ptr);
-  png_set_strip_16(png_ptr);
-  png_set_gray_to_rgb(png_ptr);
   png_set_palette_to_rgb(png_ptr);
-  png_set_add_alpha(png_ptr, 0xff, PNG_FILLER_AFTER);
+  png_set_tRNS_to_alpha(png_ptr);
   (void)png_set_interlace_handling(png_ptr);
   png_read_update_info(png_ptr, info_ptr);
 }
@@ -111,13 +289,13 @@ void info_fn(png_structp png_ptr, png_infop info_ptr) {
 void row_fn(png_structp png_ptr, png_bytep new_row, png_uint_32 row_num,
             int pass) {
   APNGFrame* frame = (APNGFrame*)png_get_progressive_ptr(png_ptr);
+  JXL_CHECK(frame);
+  JXL_CHECK(frame->rows[row_num] < frame->pixels.data() + frame->pixels.size());
   png_progressive_combine_row(png_ptr, frame->rows[row_num], new_row);
 }
 
-inline unsigned int read_chunk(Reader* r, CHUNK* pChunk) {
+inline unsigned int read_chunk(Reader* r, PaddedBytes* pChunk) {
   unsigned char len[4];
-  pChunk->size = 0;
-  pChunk->p = 0;
   if (r->Read(&len, 4)) {
     const auto size = png_get_uint_32(len);
     // Check first, to avoid overflow.
@@ -125,19 +303,18 @@ inline unsigned int read_chunk(Reader* r, CHUNK* pChunk) {
       JXL_WARNING("APNG chunk size is too big");
       return 0;
     }
-    pChunk->size = size + 12;
-    pChunk->p = new unsigned char[pChunk->size];
-    memcpy(pChunk->p, len, 4);
-    if (r->Read(pChunk->p + 4, pChunk->size - 4)) {
-      return *(unsigned int*)(pChunk->p + 4);
+    pChunk->resize(size + 12);
+    memcpy(pChunk->data(), len, 4);
+    if (r->Read(pChunk->data() + 4, pChunk->size() - 4)) {
+      return LoadLE32(pChunk->data() + 4);
     }
   }
   return 0;
 }
 
 int processing_start(png_structp& png_ptr, png_infop& info_ptr, void* frame_ptr,
-                     bool hasInfo, CHUNK& chunkIHDR,
-                     std::vector<CHUNK>& chunksInfo) {
+                     bool hasInfo, PaddedBytes& chunkIHDR,
+                     std::vector<PaddedBytes>& chunksInfo) {
   unsigned char header[8] = {137, 80, 78, 71, 13, 10, 26, 10};
 
   png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
@@ -153,11 +330,12 @@ int processing_start(png_structp& png_ptr, png_infop& info_ptr, void* frame_ptr,
   png_set_progressive_read_fn(png_ptr, frame_ptr, info_fn, row_fn, NULL);
 
   png_process_data(png_ptr, info_ptr, header, 8);
-  png_process_data(png_ptr, info_ptr, chunkIHDR.p, chunkIHDR.size);
+  png_process_data(png_ptr, info_ptr, chunkIHDR.data(), chunkIHDR.size());
 
   if (hasInfo) {
     for (unsigned int i = 0; i < chunksInfo.size(); i++) {
-      png_process_data(png_ptr, info_ptr, chunksInfo[i].p, chunksInfo[i].size);
+      png_process_data(png_ptr, info_ptr, chunksInfo[i].data(),
+                       chunksInfo[i].size());
     }
   }
   return 0;
@@ -176,7 +354,8 @@ int processing_data(png_structp png_ptr, png_infop info_ptr, unsigned char* p,
   return 0;
 }
 
-int processing_finish(png_structp png_ptr, png_infop info_ptr) {
+int processing_finish(png_structp png_ptr, png_infop info_ptr,
+                      PackedMetadata* metadata) {
   unsigned char footer[12] = {0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130};
 
   if (!png_ptr || !info_ptr) return 1;
@@ -187,6 +366,14 @@ int processing_finish(png_structp png_ptr, png_infop info_ptr) {
   }
 
   png_process_data(png_ptr, info_ptr, footer, 12);
+  // before destroying: check if we encountered any metadata chunks
+  png_textp text_ptr;
+  int num_text;
+  png_get_text(png_ptr, info_ptr, &text_ptr, &num_text);
+  for (int i = 0; i < num_text; i++) {
+    (void)BlobsReaderPNG::Decode(text_ptr[i], metadata);
+  }
+
   png_destroy_read_struct(&png_ptr, &info_ptr, 0);
 
   return 0;
@@ -199,75 +386,58 @@ Status DecodeImageAPNG(const Span<const uint8_t> bytes,
                        const SizeConstraints& constraints,
                        PackedPixelFile* ppf) {
   Reader r;
-  unsigned int id, i, j, w, h, w0, h0, x0, y0;
+  unsigned int id, j, w, h, w0, h0, x0, y0;
   unsigned int delay_num, delay_den, dop, bop, rowbytes, imagesize;
   unsigned char sig[8];
   png_structp png_ptr;
   png_infop info_ptr;
-  CHUNK chunk;
-  CHUNK chunkIHDR;
-  std::vector<CHUNK> chunksInfo;
+  PaddedBytes chunk;
+  PaddedBytes chunkIHDR;
+  std::vector<PaddedBytes> chunksInfo;
   bool isAnimated = false;
   bool skipFirst = false;
   bool hasInfo = false;
   bool all_dispose_bg = true;
   APNGFrame frameRaw = {};
+  uint32_t num_channels;
+  JxlPixelFormat format;
+  unsigned int bytes_per_pixel = 0;
 
   r = {bytes.data(), bytes.data() + bytes.size()};
-  // Not an aPNG => not an error
+  // Not a PNG => not an error
   unsigned char png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
   if (!r.Read(sig, 8) || memcmp(sig, png_signature, 8) != 0) {
     return false;
   }
   id = read_chunk(&r, &chunkIHDR);
 
-  // todo: get data from png metadata
-  JxlColorEncodingSetToSRGB(&ppf->color_encoding, /*is_gray=*/false);
-  JXL_RETURN_IF_ERROR(ApplyColorHints(color_hints, /*color_already_set=*/true,
-                                      /*is_gray=*/false, ppf));
-
-  // Only 8-bit supported.
-  ppf->info.bits_per_sample = 8;
   ppf->info.exponent_bits_per_sample = 0;
-  ppf->info.alpha_bits = 8;
   ppf->info.alpha_exponent_bits = 0;
-
-  ppf->info.num_color_channels = 3;  // RGBA
   ppf->info.orientation = JXL_ORIENT_IDENTITY;
 
-  const JxlPixelFormat format{
-      /*num_channels=*/4,
-      /*data_type=*/JXL_TYPE_UINT8,
-      /*endianness=*/JXL_BIG_ENDIAN,
-      /*align=*/0,
-  };
   ppf->frames.clear();
 
+  bool have_color = false, have_srgb = false;
   bool errorstate = true;
-  if (id == kId_IHDR && chunkIHDR.size == 25) {
-    w0 = w = png_get_uint_32(chunkIHDR.p + 8);
-    h0 = h = png_get_uint_32(chunkIHDR.p + 12);
-
-    if (w > cMaxPNGSize || h > cMaxPNGSize) {
-      return false;
-    }
-
-    ppf->info.xsize = w;
-    ppf->info.ysize = h;
-    JXL_RETURN_IF_ERROR(VerifyDimensions(&constraints, w, h));
-
+  if (id == kId_IHDR && chunkIHDR.size() == 25) {
     x0 = 0;
     y0 = 0;
     delay_num = 1;
     delay_den = 10;
     dop = 0;
     bop = 0;
-    rowbytes = w * 4;
-    imagesize = h * rowbytes;
 
-    frameRaw.p = new unsigned char[imagesize];
-    frameRaw.rows = new png_bytep[h * sizeof(png_bytep)];
-    for (j = 0; j < h; j++) frameRaw.rows[j] = frameRaw.p + j * rowbytes;
+    w0 = w = png_get_uint_32(chunkIHDR.data() + 8);
+    h0 = h = png_get_uint_32(chunkIHDR.data() + 12);
+    if (w > cMaxPNGSize || h > cMaxPNGSize) {
+      return false;
+    }
+
+    // default settings in case e.g. only gAMA is given
+    ppf->color_encoding.white_point = JXL_WHITE_POINT_D65;
+    ppf->color_encoding.primaries = JXL_PRIMARIES_SRGB;
+    ppf->color_encoding.transfer_function = JXL_TRANSFER_FUNCTION_SRGB;
+    ppf->color_encoding.rendering_intent = JXL_RENDERING_INTENT_PERCEPTUAL;
 
     if (!processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,
                           chunkIHDR, chunksInfo)) {
@@ -275,7 +445,6 @@ Status DecodeImageAPNG(const Span<const uint8_t> bytes,
       while (!r.Eof()) {
         id = read_chunk(&r, &chunk);
         if (!id) break;
-        JXL_ASSERT(chunk.p != nullptr);
 
         if (id == kId_acTL && !hasInfo && !isAnimated) {
           isAnimated = true;
@@ -286,7 +455,7 @@ Status DecodeImageAPNG(const Span<const uint8_t> bytes,
         } else if (id == kId_IEND ||
                    (id == kId_fcTL && (!hasInfo || isAnimated))) {
           if (hasInfo) {
-            if (!processing_finish(png_ptr, info_ptr)) {
+            if (!processing_finish(png_ptr, info_ptr, &ppf->metadata)) {
               // Allocates the frame buffer.
               ppf->frames.emplace_back(w0, h0, format);
               auto* frame = &ppf->frames.back();
@@ -297,8 +466,6 @@ Status DecodeImageAPNG(const Span<const uint8_t> bytes,
               // TODO(veluca): this could in principle be implemented.
               if (last_base_was_none && !all_dispose_bg &&
                   (x0 != 0 || y0 != 0 || w0 != w || h0 != h || bop != 0)) {
-                delete[] frameRaw.rows;
-                delete[] frameRaw.p;
                 return JXL_FAILURE(
                     "APNG with dispose-to-0 is not supported for non-full or "
                     "blended frames");
@@ -322,10 +489,9 @@ Status DecodeImageAPNG(const Span<const uint8_t> bytes,
               for (size_t y = 0; y < h0; ++y) {
                 memcpy(static_cast<uint8_t*>(frame->color.pixels()) +
                            frame->color.stride * y,
-                       frameRaw.rows[y], 4 * w0);
+                       frameRaw.rows[y], bytes_per_pixel * w0);
               }
             } else {
-              delete[] chunk.p;
               break;
             }
           }
@@ -335,31 +501,30 @@ Status DecodeImageAPNG(const Span<const uint8_t> bytes,
             break;
           }
           // At this point the old frame is done. Let's start a new one.
-          w0 = png_get_uint_32(chunk.p + 12);
-          h0 = png_get_uint_32(chunk.p + 16);
-          x0 = png_get_uint_32(chunk.p + 20);
-          y0 = png_get_uint_32(chunk.p + 24);
-          delay_num = png_get_uint_16(chunk.p + 28);
-          delay_den = png_get_uint_16(chunk.p + 30);
-          dop = chunk.p[32];
-          bop = chunk.p[33];
+          w0 = png_get_uint_32(chunk.data() + 12);
+          h0 = png_get_uint_32(chunk.data() + 16);
+          x0 = png_get_uint_32(chunk.data() + 20);
+          y0 = png_get_uint_32(chunk.data() + 24);
+          delay_num = png_get_uint_16(chunk.data() + 28);
+          delay_den = png_get_uint_16(chunk.data() + 30);
+          dop = chunk[32];
+          bop = chunk[33];
 
           if (!delay_den) delay_den = 100;
 
           if (w0 > cMaxPNGSize || h0 > cMaxPNGSize || x0 > cMaxPNGSize ||
               y0 > cMaxPNGSize || x0 + w0 > w || y0 + h0 > h || dop > 2 ||
               bop > 1) {
-            delete[] chunk.p;
             break;
           }
 
           if (hasInfo) {
-            memcpy(chunkIHDR.p + 8, chunk.p + 12, 8);
+            memcpy(chunkIHDR.data() + 8, chunk.data() + 12, 8);
             if (processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,
                                  chunkIHDR, chunksInfo)) {
-              delete[] chunk.p;
               break;
             }
+
           } else
             skipFirst = false;
 
@@ -368,41 +533,126 @@ Status DecodeImageAPNG(const Span<const uint8_t> bytes,
             if (dop == 2) dop = 1;
           }
         } else if (id == kId_IDAT) {
+          // First IDAT chunk means we now have all header info
           hasInfo = true;
-          if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {
-            delete[] chunk.p;
+          JXL_CHECK(w == png_get_image_width(png_ptr, info_ptr));
+          JXL_CHECK(h == png_get_image_height(png_ptr, info_ptr));
+          int colortype = png_get_color_type(png_ptr, info_ptr);
+          ppf->info.bits_per_sample = png_get_bit_depth(png_ptr, info_ptr);
+          png_color_8p sigbits = NULL;
+          png_get_sBIT(png_ptr, info_ptr, &sigbits);
+          if (colortype & 1) {
+            // palette will actually be 8-bit regardless of the index bitdepth
+            ppf->info.bits_per_sample = 8;
+          }
+          if (colortype & 2) {
+            ppf->info.num_color_channels = 3;
+            ppf->color_encoding.color_space = JXL_COLOR_SPACE_RGB;
+            if (sigbits && sigbits->red == sigbits->green &&
+                sigbits->green == sigbits->blue)
+              ppf->info.bits_per_sample = sigbits->red;
+          } else {
+            ppf->info.num_color_channels = 1;
+            ppf->color_encoding.color_space = JXL_COLOR_SPACE_GRAY;
+            if (sigbits) ppf->info.bits_per_sample = sigbits->gray;
+          }
+          if (colortype & 4 ||
+              png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) {
+            ppf->info.alpha_bits = ppf->info.bits_per_sample;
+            if (sigbits) ppf->info.alpha_bits = sigbits->alpha;
+          } else {
+            ppf->info.alpha_bits = 0;
+          }
+
+          ppf->info.xsize = w;
+          ppf->info.ysize = h;
+          JXL_RETURN_IF_ERROR(VerifyDimensions(&constraints, w, h));
+          num_channels =
+              ppf->info.num_color_channels + (ppf->info.alpha_bits ? 1 : 0);
+          format = {
+              /*num_channels=*/num_channels,
+              /*data_type=*/ppf->info.bits_per_sample > 8 ? JXL_TYPE_UINT16
+                                                          : JXL_TYPE_UINT8,
+              /*endianness=*/JXL_BIG_ENDIAN,
+              /*align=*/0,
+          };
+          bytes_per_pixel =
+              num_channels * (format.data_type == JXL_TYPE_UINT16 ? 2 : 1);
+          rowbytes = w * bytes_per_pixel;
+          imagesize = h * rowbytes;
+          frameRaw.pixels.resize(imagesize);
+          frameRaw.rows.resize(h);
+          for (j = 0; j < h; j++)
+            frameRaw.rows[j] = frameRaw.pixels.data() + j * rowbytes;
+
+          if (processing_data(png_ptr, info_ptr, chunk.data(), chunk.size())) {
             break;
           }
         } else if (id == kId_fdAT && isAnimated) {
-          png_save_uint_32(chunk.p + 4, chunk.size - 16);
-          memcpy(chunk.p + 8, "IDAT", 4);
-          if (processing_data(png_ptr, info_ptr, chunk.p + 4, chunk.size - 4)) {
-            delete[] chunk.p;
+          png_save_uint_32(chunk.data() + 4, chunk.size() - 16);
+          memcpy(chunk.data() + 8, "IDAT", 4);
+          if (processing_data(png_ptr, info_ptr, chunk.data() + 4,
+                              chunk.size() - 4)) {
             break;
           }
-        } else if (!isAbc(chunk.p[4]) || !isAbc(chunk.p[5]) ||
-                   !isAbc(chunk.p[6]) || !isAbc(chunk.p[7])) {
-          delete[] chunk.p;
+        } else if (id == kId_iCCP) {
+          if (processing_data(png_ptr, info_ptr, chunk.data(), chunk.size())) {
+            JXL_WARNING("Corrupt iCCP chunk");
+            break;
+          }
+
+          // TODO(jon): catch special case of PQ and synthesize color encoding
+          // in that case
+          int compression_type;
+          png_bytep profile;
+          png_charp name;
+          png_uint_32 proflen;
+          png_get_iCCP(png_ptr, info_ptr, &name, &compression_type, &profile,
+                       &proflen);
+          ppf->icc.resize(proflen);
+          memcpy(ppf->icc.data(), profile, proflen);
+          have_color = true;
+        } else if (id == kId_sRGB) {
+          JXL_RETURN_IF_ERROR(DecodeSRGB(chunk.data() + 8, chunk.size() - 12,
+                                         &ppf->color_encoding));
+          have_srgb = true;
+          have_color = true;
+        } else if (id == kId_gAMA) {
+          JXL_RETURN_IF_ERROR(DecodeGAMA(chunk.data() + 8, chunk.size() - 12,
+                                         &ppf->color_encoding));
+          have_color = true;
+        } else if (id == kId_cHRM) {
+          JXL_RETURN_IF_ERROR(DecodeCHRM(chunk.data() + 8, chunk.size() - 12,
+                                         &ppf->color_encoding));
+          have_color = true;
+        } else if (id == kId_eXIf) {
+          ppf->metadata.exif.resize(chunk.size() - 12);
+          memcpy(ppf->metadata.exif.data(), chunk.data() + 8,
+                 chunk.size() - 12);
+        } else if (!isAbc(chunk[4]) || !isAbc(chunk[5]) || !isAbc(chunk[6]) ||
+                   !isAbc(chunk[7])) {
           break;
-        } else if (!hasInfo) {
-          if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {
-            delete[] chunk.p;
+        } else {
+          if (processing_data(png_ptr, info_ptr, chunk.data(), chunk.size())) {
             break;
           }
-          chunksInfo.push_back(chunk);
-          continue;
+          if (!hasInfo) {
+            chunksInfo.push_back(chunk);
+            continue;
+          }
         }
-        delete[] chunk.p;
       }
     }
-    delete[] frameRaw.rows;
-    delete[] frameRaw.p;
-  }
 
-  for (i = 0; i < chunksInfo.size(); i++) delete[] chunksInfo[i].p;
-
-  chunksInfo.clear();
-  delete[] chunkIHDR.p;
+    if (have_srgb) {
+      ppf->color_encoding.white_point = JXL_WHITE_POINT_D65;
+      ppf->color_encoding.primaries = JXL_PRIMARIES_SRGB;
+      ppf->color_encoding.transfer_function = JXL_TRANSFER_FUNCTION_SRGB;
+      ppf->color_encoding.rendering_intent = JXL_RENDERING_INTENT_PERCEPTUAL;
+    }
+    JXL_RETURN_IF_ERROR(ApplyColorHints(
+        color_hints, have_color, ppf->info.num_color_channels == 1, ppf));
+  }
 
   if (errorstate) return false;
   return true;
diff --git a/lib/extras/codec_png.cc b/lib/extras/codec_png.cc
index 822f5d6d5..e0ee233c3 100644
--- a/lib/extras/codec_png.cc
+++ b/lib/extras/codec_png.cc
@@ -39,151 +39,6 @@ namespace {
 
 #define JXL_PNG_VERBOSE 0
 
-// Retrieves XMP and EXIF/IPTC from itext and text.
-class BlobsReaderPNG {
- public:
-  static Status Decode(const LodePNGInfo& info, PackedMetadata* metadata) {
-    for (unsigned idx_itext = 0; idx_itext < info.itext_num; ++idx_itext) {
-      // We trust these are properly null-terminated by LodePNG.
-      const char* key = info.itext_keys[idx_itext];
-      const char* value = info.itext_strings[idx_itext];
-      if (strstr(key, "XML:com.adobe.xmp")) {
-        metadata->xmp.resize(strlen(value));  // safe, see above
-        memcpy(metadata->xmp.data(), value, metadata->xmp.size());
-      }
-    }
-
-    for (unsigned idx_text = 0; idx_text < info.text_num; ++idx_text) {
-      // We trust these are properly null-terminated by LodePNG.
-      const char* key = info.text_keys[idx_text];
-      const char* value = info.text_strings[idx_text];
-      std::string type;
-      std::vector<uint8_t> bytes;
-
-      // Handle text chunks annotated with key "Raw profile type ####", with
-      // #### a type, which may contain metadata.
-      const char* kKey = "Raw profile type ";
-      if (strncmp(key, kKey, strlen(kKey)) != 0) continue;
-
-      if (!MaybeDecodeBase16(key, value, &type, &bytes)) {
-        JXL_WARNING("Couldn't parse 'Raw format type' text chunk");
-        continue;
-      }
-      if (type == "exif") {
-        if (!metadata->exif.empty()) {
-          JXL_WARNING("overwriting EXIF (%" PRIuS " bytes) with base16 (%" PRIuS
-                      " bytes)",
-                      metadata->exif.size(), bytes.size());
-        }
-        metadata->exif = std::move(bytes);
-      } else if (type == "iptc") {
-        // TODO (jon): Deal with IPTC in some way
-      } else if (type == "8bim") {
-        // TODO (jon): Deal with 8bim in some way
-      } else if (type == "xmp") {
-        if (!metadata->xmp.empty()) {
-          JXL_WARNING("overwriting XMP (%" PRIuS " bytes) with base16 (%" PRIuS
-                      " bytes)",
-                      metadata->xmp.size(), bytes.size());
-        }
-        metadata->xmp = std::move(bytes);
-      } else {
-        JXL_WARNING("Unknown type in 'Raw format type' text chunk: %s: %" PRIuS
-                    " bytes",
-                    type.c_str(), bytes.size());
-      }
-    }
-
-    return true;
-  }
-
- private:
-  // Returns false if invalid.
-  static JXL_INLINE Status DecodeNibble(const char c,
-                                        uint32_t* JXL_RESTRICT nibble) {
-    if ('a' <= c && c <= 'f') {
-      *nibble = 10 + c - 'a';
-    } else if ('0' <= c && c <= '9') {
-      *nibble = c - '0';
-    } else {
-      *nibble = 0;
-      return JXL_FAILURE("Invalid metadata nibble");
-    }
-    JXL_ASSERT(*nibble < 16);
-    return true;
-  }
-
-  // Parses a PNG text chunk with key of the form "Raw profile type ####", with
-  // #### a type.
-  // Returns whether it could successfully parse the content.
-  // We trust key and encoded are null-terminated because they come from
-  // LodePNG.
-  static Status MaybeDecodeBase16(const char* key, const char* encoded,
-                                  std::string* type,
-                                  std::vector<uint8_t>* bytes) {
-    const char* encoded_end = encoded + strlen(encoded);
-
-    const char* kKey = "Raw profile type ";
-    if (strncmp(key, kKey, strlen(kKey)) != 0) return false;
-    *type = key + strlen(kKey);
-    const size_t kMaxTypeLen = 20;
-    if (type->length() > kMaxTypeLen) return false;  // Type too long
-
-    // Header: freeform string and number of bytes
-    // Expected format is:
-    // \n
-    // profile name/description\n
-    //       40\n               (the number of bytes after hex-decoding)
-    // 01234566789abcdef....\n  (72 bytes per line max).
-    // 012345667\n              (last line)
-    const char* pos = encoded;
-
-    if (*(pos++) != '\n') return false;
-    while (pos < encoded_end && *pos != '\n') {
-      pos++;
-    }
-    if (pos == encoded_end) return false;
-    // We parsed so far a \n, some number of non \n characters and are now
-    // pointing at a \n.
-    if (*(pos++) != '\n') return false;
-    unsigned long bytes_to_decode;
-    const int fields = sscanf(pos, "%8lu", &bytes_to_decode);
-    if (fields != 1) return false;  // Failed to decode metadata header
-    JXL_ASSERT(pos + 8 <= encoded_end);
-    pos += 8;  // read %8lu
-
-    // We need 2*bytes for the hex values plus 1 byte every 36 values.
-    const unsigned long needed_bytes =
-        bytes_to_decode * 2 + 1 + DivCeil(bytes_to_decode, 36);
-    if (needed_bytes != static_cast<size_t>(encoded_end - pos)) {
-      return JXL_FAILURE("Not enough bytes to parse %lu bytes in hex",
-                         bytes_to_decode);
-    }
-    JXL_ASSERT(bytes->empty());
-    bytes->reserve(bytes_to_decode);
-
-    // Encoding: base16 with newline after 72 chars.
-    // pos points to the \n before the first line of hex values.
-    for (size_t i = 0; i < bytes_to_decode; ++i) {
-      if (i % 36 == 0) {
-        if (pos + 1 >= encoded_end) return false;  // Truncated base16 1
-        if (*pos != '\n') return false;            // Expected newline
-        ++pos;
-      }
-
-      if (pos + 2 >= encoded_end) return false;  // Truncated base16 2;
-      uint32_t nibble0, nibble1;
-      JXL_RETURN_IF_ERROR(DecodeNibble(pos[0], &nibble0));
-      JXL_RETURN_IF_ERROR(DecodeNibble(pos[1], &nibble1));
-      bytes->push_back(static_cast<uint8_t>((nibble0 << 4) + nibble1));
-      pos += 2;
-    }
-    if (pos + 1 != encoded_end) return false;  // Too many encoded bytes
-    if (pos[0] != '\n') return false;          // Incorrect metadata terminator
-    return true;
-  }
-};
-
 // Stores XMP and EXIF/IPTC into itext and text.
 class BlobsWriterPNG {
  public:
@@ -250,240 +105,6 @@ class BlobsWriterPNG {
   }
 };
 
-// Retrieves ColorEncoding from PNG chunks.
-class ColorEncodingReaderPNG {
- public:
-  // Fills original->color_encoding or returns false.
-  Status operator()(const Span<const uint8_t> bytes, const bool is_gray,
-                    PackedPixelFile* ppf) {
-    JXL_RETURN_IF_ERROR(Decode(bytes, &ppf->metadata, &ppf->color_encoding));
-
-    const JxlColorSpace color_space =
-        is_gray ? JXL_COLOR_SPACE_GRAY : JXL_COLOR_SPACE_RGB;
-    ppf->color_encoding.color_space = color_space;
-
-    if (have_pq_) {
-      // Synthesize the ICC with these parameters instead.
-      ppf->color_encoding.white_point = JXL_WHITE_POINT_D65;
-      ppf->color_encoding.primaries = JXL_PRIMARIES_2100;
-      ppf->color_encoding.transfer_function = JXL_TRANSFER_FUNCTION_PQ;
-      ppf->color_encoding.rendering_intent = JXL_RENDERING_INTENT_RELATIVE;
-      return true;
-    }
-
-    // ICC overrides anything else if present.
-    ppf->icc = std::move(icc_);
-
-    // PNG requires that sRGB override gAMA/cHRM.
-    if (have_srgb_) {
-      ppf->icc.clear();
-      ppf->color_encoding.white_point = JXL_WHITE_POINT_D65;
-      ppf->color_encoding.primaries = JXL_PRIMARIES_SRGB;
-      ppf->color_encoding.transfer_function = JXL_TRANSFER_FUNCTION_SRGB;
-      ppf->color_encoding.rendering_intent = JXL_RENDERING_INTENT_PERCEPTUAL;
-      return true;
-    }
-
-    // Try to create a custom profile:
-
-    // Attempt to set whitepoint and primaries if there is a cHRM chunk, or else
-    // use default sRGB (the PNG then is device-dependent).
-    // In case of grayscale, do not attempt to set the primaries and ignore the
-    // ones the PNG image has (but still set the white point).
-    if (!have_chrm_) {
-#if JXL_PNG_VERBOSE >= 1
-      JXL_WARNING("No cHRM, assuming sRGB");
-#endif
-      ppf->color_encoding.white_point = JXL_WHITE_POINT_D65;
-      ppf->color_encoding.primaries = JXL_PRIMARIES_SRGB;
-    }
-
-    if (!have_gama_) {
-#if JXL_PNG_VERBOSE >= 1
-      JXL_WARNING("No gAMA nor sRGB, assuming sRGB");
-#endif
-      ppf->color_encoding.transfer_function = JXL_TRANSFER_FUNCTION_SRGB;
-    }
-
-    ppf->color_encoding.rendering_intent = JXL_RENDERING_INTENT_RELATIVE;
-    return true;
-  }
-
-  // Whether the image has any color profile information (ICC chunk, sRGB
-  // chunk, cHRM chunk, and so on), or has no color information chunks at all.
-  bool HaveColorProfile() const {
-    return have_pq_ || have_srgb_ || have_gama_ || have_chrm_ || have_icc_;
-  }
-
- private:
-  Status DecodeICC(const unsigned char* const payload,
-                   const size_t payload_size) {
-    if (payload_size == 0) return JXL_FAILURE("Empty ICC payload");
-    const unsigned char* pos = payload;
-    const unsigned char* end = payload + payload_size;
-
-    // Profile name
-    if (*pos == '\0') return JXL_FAILURE("Expected ICC name");
-    for (size_t i = 0;; ++i) {
-      if (i == 80) return JXL_FAILURE("ICC profile name too long");
-      if (pos == end) return JXL_FAILURE("Not enough bytes for ICC name");
-      if (*pos++ == '\0') break;
-    }
-
-    // Special case for BT.2100 PQ (https://w3c.github.io/png-hdr-pq/) - try to
-    // synthesize the profile because table-based curves are less accurate.
-    // strcmp is safe because we already verified the string is 0-terminated.
-    if (!strcmp(reinterpret_cast<const char*>(payload), "ITUR_2100_PQ_FULL")) {
-      have_pq_ = true;
-    }
-
-    // Skip over compression method (only one is allowed)
-    if (pos == end) return JXL_FAILURE("Not enough bytes for ICC method");
-    if (*pos++ != 0) return JXL_FAILURE("Unsupported ICC method");
-
-    // Decompress
-    unsigned char* icc_buf = nullptr;
-    size_t icc_size = 0;
-    LodePNGDecompressSettings settings;
-    lodepng_decompress_settings_init(&settings);
-    const unsigned err = lodepng_zlib_decompress(
-        &icc_buf, &icc_size, pos, payload_size - (pos - payload), &settings);
-    if (err == 0) {
-      icc_.resize(icc_size);
-      memcpy(icc_.data(), icc_buf, icc_size);
-    }
-    free(icc_buf);
-    have_icc_ = true;
-    return true;
-  }
-
-  // Returns floating-point value from the PNG encoding (times 10^5).
-  static double F64FromU32(const uint32_t x) {
-    return static_cast<int32_t>(x) * 1E-5;
-  }
-
-  Status DecodeSRGB(const unsigned char* payload, const size_t payload_size,
-                    JxlColorEncoding* color_encoding) {
-    if (payload_size != 1) return JXL_FAILURE("Wrong sRGB size");
-    // (PNG uses the same values as ICC.)
-    if (payload[0] >= 4) return JXL_FAILURE("Invalid Rendering Intent");
-    color_encoding->rendering_intent =
-        static_cast<JxlRenderingIntent>(payload[0]);
-    have_srgb_ = true;
-    return true;
-  }
-
-  Status DecodeGAMA(const unsigned char* payload, const size_t payload_size,
-                    JxlColorEncoding* color_encoding) {
-    if (payload_size != 4) return JXL_FAILURE("Wrong gAMA size");
-    color_encoding->transfer_function = JXL_TRANSFER_FUNCTION_GAMMA;
-    color_encoding->gamma = F64FromU32(LoadBE32(payload));
-    have_gama_ = true;
-    return true;
-  }
-
-  Status DecodeCHRM(const unsigned char* payload, const size_t payload_size,
-                    JxlColorEncoding* color_encoding) {
-    if (payload_size != 32) return JXL_FAILURE("Wrong cHRM size");
-
-    color_encoding->white_point = JXL_WHITE_POINT_CUSTOM;
-    color_encoding->white_point_xy[0] = F64FromU32(LoadBE32(payload + 0));
-    color_encoding->white_point_xy[1] = F64FromU32(LoadBE32(payload + 4));
-
-    color_encoding->primaries = JXL_PRIMARIES_CUSTOM;
-    color_encoding->primaries_red_xy[0] = F64FromU32(LoadBE32(payload + 8));
-    color_encoding->primaries_red_xy[1] = F64FromU32(LoadBE32(payload + 12));
-    color_encoding->primaries_green_xy[0] = F64FromU32(LoadBE32(payload + 16));
-    color_encoding->primaries_green_xy[1] = F64FromU32(LoadBE32(payload + 20));
-    color_encoding->primaries_blue_xy[0] = F64FromU32(LoadBE32(payload + 24));
-    color_encoding->primaries_blue_xy[1] = F64FromU32(LoadBE32(payload + 28));
-
-    have_chrm_ = true;
-    return true;
-  }
-
-  Status DecodeEXIF(const unsigned char* payload, const size_t payload_size,
-                    PackedMetadata* metadata) {
-    // If we already have EXIF, keep the larger one.
-    if (metadata->exif.size() > payload_size) return true;
-    metadata->exif.resize(payload_size);
-    memcpy(metadata->exif.data(), payload, payload_size);
-    return true;
-  }
-
-  Status Decode(const Span<const uint8_t> bytes, PackedMetadata* metadata,
-                JxlColorEncoding* color_encoding) {
-    // Look for colorimetry and text chunks in the PNG image. The PNG chunks
-    // begin after the PNG magic header of 8 bytes.
-    const unsigned char* chunk = bytes.data() + 8;
-    const unsigned char* end = bytes.data() + bytes.size();
-    for (;;) {
-      // chunk points to the first field of a PNG chunk. The chunk has
-      // respectively 4 bytes of length, 4 bytes type, length bytes of data,
-      // 4 bytes CRC.
-      if (chunk + 4 >= end) {
-        break;  // Regular end reached.
-      }
-
-      char type_char[5];
-      if (chunk + 8 >= end) {
-        JXL_NOTIFY_ERROR("PNG: malformed chunk");
-        break;
-      }
-      lodepng_chunk_type(type_char, chunk);
-      std::string type = type_char;
-
-      if (type == "acTL" || type == "fcTL" || type == "fdAT") {
-        // this is an APNG file, without proper handling we would just return
-        // the first frame, so for now codec_apng handles animation until the
-        // animation chunk handling is added here
-        return false;
-      }
-      if (type == "eXIf" || type == "iCCP" || type == "sRGB" ||
-          type == "gAMA" || type == "cHRM") {
-        const unsigned char* payload = lodepng_chunk_data_const(chunk);
-        const size_t payload_size = lodepng_chunk_length(chunk);
-        // The entire chunk needs also 4 bytes of CRC after the payload.
-        if (payload + payload_size + 4 >= end) {
-          JXL_NOTIFY_ERROR("PNG: truncated chunk");
-          break;
-        }
-        if (lodepng_chunk_check_crc(chunk) != 0) {
-          JXL_NOTIFY_ERROR("CRC mismatch in unknown PNG chunk");
-          chunk = lodepng_chunk_next_const(chunk, end);
-          continue;
-        }
-
-        if (type == "eXIf") {
-          JXL_RETURN_IF_ERROR(DecodeEXIF(payload, payload_size, metadata));
-        } else if (type == "iCCP") {
-          JXL_RETURN_IF_ERROR(DecodeICC(payload, payload_size));
-        } else if (type == "sRGB") {
-          JXL_RETURN_IF_ERROR(
-              DecodeSRGB(payload, payload_size, color_encoding));
-        } else if (type == "gAMA") {
-          JXL_RETURN_IF_ERROR(
-              DecodeGAMA(payload, payload_size, color_encoding));
-        } else if (type == "cHRM") {
-          JXL_RETURN_IF_ERROR(
-              DecodeCHRM(payload, payload_size, color_encoding));
-        }
-      }
-
-      chunk = lodepng_chunk_next_const(chunk, end);
-    }
-    return true;
-  }
-
-  std::vector<uint8_t> icc_;
-
-  bool have_pq_ = false;
-  bool have_srgb_ = false;
-  bool have_gama_ = false;
-  bool have_chrm_ = false;
-  bool have_icc_ = false;
-};
-
 // Stores ColorEncoding into PNG chunks.
 class ColorEncodingWriterPNG {
  public:
@@ -714,88 +335,6 @@ Status InspectChunkType(const Span<const uint8_t> bytes,
 
 }  // namespace
 
-Status DecodeImagePNG(const Span<const uint8_t> bytes,
-                      const ColorHints& color_hints,
-                      const SizeConstraints& constraints,
-                      PackedPixelFile* ppf) {
-  unsigned w, h;
-  PNGState state;
-  if (lodepng_inspect(&w, &h, &state.s, bytes.data(), bytes.size()) != 0) {
-    return false;  // not an error - just wrong format
-  }
-  JXL_RETURN_IF_ERROR(VerifyDimensions(&constraints, w, h));
-
-  // Palette RGB values
-  if (!InspectChunkType(bytes, "PLTE", &state.s)) {
-    return false;
-  }
-  // Transparent color key, or palette transparency
-  if (!InspectChunkType(bytes, "tRNS", &state.s)) {
-    return false;
-  }
-  // ICC profile
-  if (!InspectChunkType(bytes, "iCCP", &state.s)) {
-    return false;
-  }
-  const LodePNGColorMode& color_mode = state.s.info_png.color;
-  bool has_icc = state.s.info_png.iccp_defined;
-
-  bool is_gray, has_alpha;
-  JXL_RETURN_IF_ERROR(CheckGray(color_mode, has_icc, &is_gray));
-  JXL_RETURN_IF_ERROR(CheckAlpha(color_mode, &has_alpha));
-  // We want LodePNG to promote 1/2/4 bit pixels to 8.
-  size_t bits_per_sample = std::max(color_mode.bitdepth, 8u);
-  if (bits_per_sample != 8 && bits_per_sample != 16) {
-    return JXL_FAILURE("Unexpected PNG bit depth");
-  }
-
-  // Always decode to 8/16-bit RGB/RGBA, not LCT_PALETTE.
-  state.s.info_raw.bitdepth = static_cast<unsigned>(bits_per_sample);
-  state.s.info_raw.colortype = MakeType(is_gray, has_alpha);
-  unsigned char* out = nullptr;
-  const unsigned err =
-      lodepng_decode(&out, &w, &h, &state.s, bytes.data(), bytes.size());
-  // Automatically call free(out) on return.
-  std::unique_ptr<unsigned char, void (*)(void*)> out_ptr{out, free};
-  if (err != 0) {
-    return JXL_FAILURE("PNG decode failed: %s", lodepng_error_text(err));
-  }
-
-  if (!BlobsReaderPNG::Decode(state.s.info_png, &ppf->metadata)) {
-    JXL_WARNING("PNG metadata may be incomplete");
-  }
-  ColorEncodingReaderPNG reader;
-  JXL_RETURN_IF_ERROR(reader(bytes, is_gray, ppf));
-
-  const uint32_t num_channels = (is_gray ? 1 : 3) + has_alpha;
-
-  ppf->info.xsize = w;
-  ppf->info.ysize = h;
-  // Original data is uint, so exponent_bits_per_sample = 0.
-  ppf->info.bits_per_sample = bits_per_sample;
-  ppf->info.exponent_bits_per_sample = 0;
-  ppf->info.uses_original_profile = true;
-  ppf->info.have_preview = false;
-  ppf->info.have_animation = false;
-
-  ppf->info.alpha_bits = has_alpha ? bits_per_sample : 0;
-  ppf->info.num_color_channels = is_gray ? 1 : 3;
-
-  const JxlPixelFormat format{
-      /*num_channels=*/num_channels,
-      /*data_type=*/bits_per_sample == 16 ? JXL_TYPE_UINT16 : JXL_TYPE_UINT8,
-      /*endianness=*/JXL_BIG_ENDIAN,  // PNG requirement
-      /*align=*/0,
-  };
-  const size_t out_size = static_cast<size_t>(w) * h * num_channels *
-                          bits_per_sample / kBitsPerByte;
-  ppf->frames.emplace_back(w, h, format, out_ptr.release(), out_size);
-
-  JXL_RETURN_IF_ERROR(
-      ApplyColorHints(color_hints, reader.HaveColorProfile(), is_gray, ppf));
-  return true;
-}
-
 Status EncodeImagePNG(const CodecInOut* io, const ColorEncoding& c_desired,
                       size_t bits_per_sample, ThreadPool* pool,
                       PaddedBytes* bytes) {
diff --git a/lib/extras/codec_png.h b/lib/extras/codec_png.h
index 670485ef8..37d3a58a9 100644
--- a/lib/extras/codec_png.h
+++ b/lib/extras/codec_png.h
@@ -26,11 +26,6 @@
 namespace jxl {
 namespace extras {
 
-// Decodes `bytes` into `ppf`.
-Status DecodeImagePNG(const Span<const uint8_t> bytes,
-                      const ColorHints& color_hints,
-                      const SizeConstraints& constraints, PackedPixelFile* ppf);
-
 // Transforms from io->c_current to `c_desired` and encodes into `bytes`.
 Status EncodeImagePNG(const CodecInOut* io, const ColorEncoding& c_desired,
                       size_t bits_per_sample, ThreadPool* pool,
diff --git a/tools/benchmark/benchmark_codec.cc b/tools/benchmark/benchmark_codec.cc
index f05a502b3..4a9aa2fc4 100644
--- a/tools/benchmark/benchmark_codec.cc
+++ b/tools/benchmark/benchmark_codec.cc
@@ -31,7 +31,9 @@
 #include "tools/benchmark/benchmark_codec_jpeg.h"
 #endif  // BENCHMARK_JPEG
 #include "tools/benchmark/benchmark_codec_jxl.h"
+#if JPEGXL_ENABLE_APNG
 #include "tools/benchmark/benchmark_codec_png.h"
+#endif
 #include "tools/benchmark/benchmark_stats.h"
 
 #ifdef BENCHMARK_WEBP
@@ -169,8 +171,10 @@ ImageCodecPtr CreateImageCodec(const std::string& description) {
   } else if (name == "jpeg") {
     result.reset(CreateNewJPEGCodec(*Args()));
 #endif  // BENCHMARK_JPEG
+#if JPEGXL_ENABLE_APNG
   } else if (name == "png") {
     result.reset(CreateNewPNGCodec(*Args()));
+#endif
   } else if (name == "none") {
     result.reset(new NoneCodec(*Args()));
 #ifdef BENCHMARK_WEBP
diff --git a/tools/benchmark/benchmark_codec_png.cc b/tools/benchmark/benchmark_codec_png.cc
index 4daa053b7..0e58b66e7 100644
--- a/tools/benchmark/benchmark_codec_png.cc
+++ b/tools/benchmark/benchmark_codec_png.cc
@@ -9,6 +9,7 @@
 
 #include <string>
 
+#include "lib/extras/codec_apng.h"
 #include "lib/extras/codec_png.h"
 #include "lib/extras/packed_image.h"
 #include "lib/extras/packed_image_convert.h"
@@ -55,8 +56,8 @@ class PNGCodec : public ImageCodec {
                     jpegxl::tools::SpeedStats* speed_stats) override {
     extras::PackedPixelFile ppf;
     const double start = Now();
-    JXL_RETURN_IF_ERROR(extras::DecodeImagePNG(compressed, ColorHints(),
-                                               SizeConstraints(), &ppf));
+    JXL_RETURN_IF_ERROR(extras::DecodeImageAPNG(compressed, ColorHints(),
+                                                SizeConstraints(), &ppf));
     const double end = Now();
     speed_stats->NotifyElapsed(end - start);
     JXL_RETURN_IF_ERROR(ConvertPackedPixelFileToCodecInOut(ppf, pool, io));
diff --git a/tools/cjxl.cc b/tools/cjxl.cc
index 26ca45bb1..ba0795ad1 100644
--- a/tools/cjxl.cc
+++ b/tools/cjxl.cc
@@ -272,20 +272,20 @@ void PrintMode(jxl::ThreadPoolInternal* pool, const jxl::CodecInOut& io,
 void CompressArgs::AddCommandLineOptions(CommandLineParser* cmdline) {
   // Positional arguments.
   cmdline->AddPositionalOption("INPUT", /* required = */ true,
-                               "the input can be PNG"
+                               "the input can be "
 #if JPEGXL_ENABLE_APNG
-                               ", APNG"
+                               "PNG, APNG, "
 #endif
 #if JPEGXL_ENABLE_GIF
-                               ", GIF"
+                               "GIF, "
 #endif
 #if JPEGXL_ENABLE_JPEG
-                               ", JPEG"
+                               "JPEG, "
 #endif
 #if JPEGXL_ENABLE_EXR
-                               ", EXR"
+                               "EXR, "
 #endif
-                               ", PPM, PFM, or PGX",
+                               "PPM, PFM, or PGX",
                                &file_in);
   cmdline->AddPositionalOption(
       "OUTPUT", /* required = */ true,
