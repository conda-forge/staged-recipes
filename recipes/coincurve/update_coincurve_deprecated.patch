diff -Nu _cffi_build/build.py b/coincurve/build.py
--- _cffi_build/build.py	2022-11-19 14:10:25.000000000 -0600
+++ b/coincurve/build.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,34 +0,0 @@
-import os
-from collections import namedtuple
-
-from cffi import FFI
-
-here = os.path.dirname(os.path.abspath(__file__))
-
-Source = namedtuple('Source', ('h', 'include'))
-
-
-def _mk_ffi(sources, name='_libsecp256k1', **kwargs):
-    _ffi = FFI()
-    code = []
-
-    for source in sources:
-        with open(os.path.join(here, source.h), 'rt') as h:
-            _ffi.cdef(h.read())
-        code.append(source.include)
-
-    code.append('#define PY_USE_BUNDLED')
-    _ffi.set_source(name, '\n'.join(code), **kwargs)
-
-    return _ffi
-
-
-modules = [
-    Source('secp256k1.h', '#include <secp256k1.h>'),
-    Source('secp256k1_ecdh.h', '#include <secp256k1_ecdh.h>'),
-    Source('secp256k1_extrakeys.h', '#include <secp256k1_extrakeys.h>'),
-    Source('secp256k1_recovery.h', '#include <secp256k1_recovery.h>'),
-    Source('secp256k1_schnorrsig.h', '#include <secp256k1_schnorrsig.h>'),
-]
-
-ffi = _mk_ffi(modules, libraries=['secp256k1'])
diff -Nu _cffi_build/context.py b/coincurve/context.py
--- _cffi_build/context.py	1969-12-31 18:00:00.000000000 -0600
+++ b/coincurve/context.py	2023-09-25 10:19:04.102511107 -0500
@@ -0,0 +1,35 @@
+from os import urandom
+from threading import Lock
+from typing import Optional
+
+from a/coincurve.flags import CONTEXT_ALL, CONTEXT_FLAGS
+
+from ._libsecp256k1 import ffi, lib
+
+
+class Context:
+    def __init__(self, seed: Optional[bytes] = None, flag=CONTEXT_ALL, name: str = ''):
+        if flag not in CONTEXT_FLAGS:
+            raise ValueError(f'{flag} is an invalid context flag.')
+        self._lock = Lock()
+
+        self.ctx = ffi.gc(lib.secp256k1_context_create(flag), lib.secp256k1_context_destroy)
+        self.reseed(seed)
+
+        self.name = name
+
+    def reseed(self, seed: Optional[bytes] = None):
+        """
+        Protects against certain possible future side-channel timing attacks.
+        """
+        with self._lock:
+            seed = urandom(32) if not seed or len(seed) != 32 else seed
+            res = lib.secp256k1_context_randomize(self.ctx, ffi.new('unsigned char [32]', seed))
+            if not res:
+                raise ValueError('secp256k1_context_randomize')
+
+    def __repr__(self):
+        return self.name or super().__repr__()
+
+
+GLOBAL_CONTEXT = Context(name='GLOBAL_CONTEXT')
diff -Nu _cffi_build/ecdsa.py b/coincurve/ecdsa.py
--- _cffi_build/ecdsa.py	1969-12-31 18:00:00.000000000 -0600
+++ b/coincurve/ecdsa.py	2023-09-02 16:54:48.207368141 -0500
@@ -0,0 +1,117 @@
+from a/coincurve.context import GLOBAL_CONTEXT, Context
+from a/coincurve.types import Hasher
+from a/coincurve.utils import bytes_to_int, int_to_bytes, sha256
+
+from ._libsecp256k1 import ffi, lib
+
+MAX_SIG_LENGTH = 72
+CDATA_SIG_LENGTH = 64
+
+
+def cdata_to_der(cdata, context: Context = GLOBAL_CONTEXT) -> bytes:
+    der = ffi.new('unsigned char[%d]' % MAX_SIG_LENGTH)
+    der_length = ffi.new('size_t *', MAX_SIG_LENGTH)
+
+    lib.secp256k1_ecdsa_signature_serialize_der(context.ctx, der, der_length, cdata)
+
+    return bytes(ffi.buffer(der, der_length[0]))
+
+
+def der_to_cdata(der: bytes, context: Context = GLOBAL_CONTEXT):
+    cdata = ffi.new('secp256k1_ecdsa_signature *')
+    parsed = lib.secp256k1_ecdsa_signature_parse_der(context.ctx, cdata, der, len(der))
+
+    if not parsed:
+        raise ValueError('The DER-encoded signature could not be parsed.')
+
+    return cdata
+
+
+def recover(message: bytes, recover_sig, hasher: Hasher = sha256, context: Context = GLOBAL_CONTEXT):
+    msg_hash = hasher(message) if hasher is not None else message
+    if len(msg_hash) != 32:
+        raise ValueError('Message hash must be 32 bytes long.')
+    pubkey = ffi.new('secp256k1_pubkey *')
+
+    recovered = lib.secp256k1_ecdsa_recover(context.ctx, pubkey, recover_sig, msg_hash)
+    if recovered:
+        return pubkey
+    raise ValueError('failed to recover ECDSA public key')
+
+
+def serialize_recoverable(recover_sig, context: Context = GLOBAL_CONTEXT) -> bytes:
+    output = ffi.new('unsigned char[%d]' % CDATA_SIG_LENGTH)
+    recid = ffi.new('int *')
+
+    lib.secp256k1_ecdsa_recoverable_signature_serialize_compact(context.ctx, output, recid, recover_sig)
+
+    return bytes(ffi.buffer(output, CDATA_SIG_LENGTH)) + int_to_bytes(recid[0])
+
+
+def deserialize_recoverable(serialized: bytes, context: Context = GLOBAL_CONTEXT):
+    if len(serialized) != 65:
+        raise ValueError('Serialized signature must be 65 bytes long.')
+
+    ser_sig, rec_id = serialized[:64], bytes_to_int(serialized[64:])
+
+    if not 0 <= rec_id <= 3:
+        raise ValueError('Invalid recovery id.')
+
+    recover_sig = ffi.new('secp256k1_ecdsa_recoverable_signature *')
+
+    parsed = lib.secp256k1_ecdsa_recoverable_signature_parse_compact(context.ctx, recover_sig, ser_sig, rec_id)
+    if not parsed:
+        raise ValueError('Failed to parse recoverable signature.')
+
+    return recover_sig
+
+
+"""
+Warning:
+    The functions below may change and are not tested!
+"""
+
+
+def serialize_compact(raw_sig, context: Context = GLOBAL_CONTEXT):  # no cov
+    output = ffi.new('unsigned char[%d]' % CDATA_SIG_LENGTH)
+
+    res = lib.secp256k1_ecdsa_signature_serialize_compact(context.ctx, output, raw_sig)
+    if not res:
+        raise ValueError('secp256k1_ecdsa_signature_serialize_compact')
+
+    return bytes(ffi.buffer(output, CDATA_SIG_LENGTH))
+
+
+def deserialize_compact(ser_sig: bytes, context: Context = GLOBAL_CONTEXT):  # no cov
+    if len(ser_sig) != 64:
+        raise Exception('invalid signature length')
+
+    raw_sig = ffi.new('secp256k1_ecdsa_signature *')
+    res = lib.secp256k1_ecdsa_signature_parse_compact(context.ctx, raw_sig, ser_sig)
+    if not res:
+        raise ValueError('secp256k1_ecdsa_signature_parse_compact')
+
+    return raw_sig
+
+
+def signature_normalize(raw_sig, context: Context = GLOBAL_CONTEXT):  # no cov
+    """
+    Check and optionally convert a signature to a normalized lower-S form.
+
+    This function always return a tuple containing a boolean (True if
+    not previously normalized or False if signature was already
+    normalized), and the normalized signature.
+    """
+    sigout = ffi.new('secp256k1_ecdsa_signature *')
+
+    res = lib.secp256k1_ecdsa_signature_normalize(context.ctx, sigout, raw_sig)
+
+    return not not res, sigout
+
+
+def recoverable_convert(recover_sig, context: Context = GLOBAL_CONTEXT):  # no cov
+    normal_sig = ffi.new('secp256k1_ecdsa_signature *')
+
+    lib.secp256k1_ecdsa_recoverable_signature_convert(context.ctx, normal_sig, recover_sig)
+
+    return normal_sig
diff -Nu _cffi_build/flags.py b/coincurve/flags.py
--- _cffi_build/flags.py	1969-12-31 18:00:00.000000000 -0600
+++ b/coincurve/flags.py	2023-09-02 16:54:48.207368141 -0500
@@ -0,0 +1,10 @@
+from ._libsecp256k1 import lib
+
+CONTEXT_SIGN = lib.SECP256K1_CONTEXT_SIGN
+CONTEXT_VERIFY = lib.SECP256K1_CONTEXT_VERIFY
+CONTEXT_ALL = CONTEXT_SIGN | CONTEXT_VERIFY
+CONTEXT_NONE = lib.SECP256K1_CONTEXT_NONE
+CONTEXT_FLAGS = {CONTEXT_SIGN, CONTEXT_VERIFY, CONTEXT_ALL, CONTEXT_NONE}
+
+EC_COMPRESSED = lib.SECP256K1_EC_COMPRESSED
+EC_UNCOMPRESSED = lib.SECP256K1_EC_UNCOMPRESSED
diff -Nu _cffi_build/__init__.py b/coincurve/__init__.py
--- _cffi_build/__init__.py	1969-12-31 18:00:00.000000000 -0600
+++ b/coincurve/__init__.py	2023-09-02 16:54:48.207368141 -0500
@@ -0,0 +1,12 @@
+from a/coincurve.context import GLOBAL_CONTEXT, Context
+from a/coincurve.keys import PrivateKey, PublicKey, PublicKeyXOnly
+from a/coincurve.utils import verify_signature
+
+__all__ = [
+    'GLOBAL_CONTEXT',
+    'Context',
+    'PrivateKey',
+    'PublicKey',
+    'PublicKeyXOnly',
+    'verify_signature',
+]
diff -Nu _cffi_build/keys.py b/coincurve/keys.py
--- _cffi_build/keys.py	1969-12-31 18:00:00.000000000 -0600
+++ b/coincurve/keys.py	2023-09-25 10:50:50.335746923 -0500
@@ -0,0 +1,630 @@
+import os
+from typing import Optional, Tuple
+
+from asn1crypto.keys import ECDomainParameters, ECPointBitString, ECPrivateKey, PrivateKeyAlgorithm, PrivateKeyInfo
+
+from a/coincurve.context import GLOBAL_CONTEXT, Context
+from a/coincurve.ecdsa import cdata_to_der, der_to_cdata, deserialize_recoverable, recover, serialize_recoverable
+from a/coincurve.flags import EC_COMPRESSED, EC_UNCOMPRESSED
+from a/coincurve.types import Hasher, Nonce
+from a/coincurve.utils import (
+    DEFAULT_NONCE,
+    bytes_to_int,
+    der_to_pem,
+    get_valid_secret,
+    hex_to_bytes,
+    int_to_bytes_padded,
+    pad_scalar,
+    pem_to_der,
+    sha256,
+    validate_secret,
+)
+
+from ._libsecp256k1 import ffi, lib
+
+
+class PrivateKey:
+    def __init__(self, secret: Optional[bytes] = None, context: Context = GLOBAL_CONTEXT):
+        """
+        :param secret: The secret used to initialize the private key.
+                       If not provided or `None`, a new key will be generated.
+        """
+        self.secret: bytes = validate_secret(secret) if secret is not None else get_valid_secret()
+        self.context = context
+        self.public_key: PublicKey = PublicKey.from_valid_secret(self.secret, self.context)
+        self.public_key_xonly: PublicKeyXOnly = PublicKeyXOnly.from_valid_secret(self.secret, self.context)
+
+    def sign(self, message: bytes, hasher: Hasher = sha256, custom_nonce: Nonce = DEFAULT_NONCE) -> bytes:
+        """
+        Create an ECDSA signature.
+
+        :param message: The message to sign.
+        :param hasher: The hash function to use, which must return 32 bytes. By default,
+                       the `sha256` algorithm is used. If `None`, no hashing occurs.
+        :param custom_nonce: Custom nonce data in the form `(nonce_function, input_data)`. Refer to
+                             [secp256k1.h](https://github.com/bitcoin-core/secp256k1/blob/f8c0b57e6ba202b1ce7c5357688de97c9c067697/include/secp256k1.h#L546-L547).
+        :return: The ECDSA signature.
+        :raises ValueError: If the message hash was not 32 bytes long, the nonce generation
+                            function failed, or the private key was invalid.
+        """
+        msg_hash = hasher(message) if hasher is not None else message
+        if len(msg_hash) != 32:
+            raise ValueError('Message hash must be 32 bytes long.')
+
+        signature = ffi.new('secp256k1_ecdsa_signature *')
+        nonce_fn, nonce_data = custom_nonce
+
+        signed = lib.secp256k1_ecdsa_sign(self.context.ctx, signature, msg_hash, self.secret, nonce_fn, nonce_data)
+
+        if not signed:
+            raise ValueError('The nonce generation function failed, or the private key was invalid.')
+
+        return cdata_to_der(signature, self.context)
+
+    def sign_schnorr(self, message: bytes, aux_randomness: bytes = b'') -> bytes:
+        """Create a Schnorr signature.
+
+        :param message: The message to sign.
+        :param aux_randomness: An optional 32 bytes of fresh randomness. By default (empty bytestring), this
+                               will be generated automatically. Set to `None` to disable this behavior.
+        :return: The Schnorr signature.
+        :raises ValueError: If the message was not 32 bytes long, the optional auxiliary random data was not
+                            32 bytes long, signing failed, or the signature was invalid.
+        """
+        if len(message) != 32:
+            raise ValueError('Message must be 32 bytes long.')
+        elif aux_randomness == b'':
+            aux_randomness = os.urandom(32)
+        elif aux_randomness is None:
+            aux_randomness = ffi.NULL
+        elif len(aux_randomness) != 32:
+            raise ValueError('Auxiliary random data must be 32 bytes long.')
+
+        keypair = ffi.new('secp256k1_keypair *')
+        res = lib.secp256k1_keypair_create(self.context.ctx, keypair, self.secret)
+        if not res:
+            raise ValueError('Secret was invalid')
+
+        signature = ffi.new('unsigned char[64]')
+        res = lib.secp256k1_schnorrsig_sign32(self.context.ctx, signature, message, keypair, aux_randomness)
+        if not res:
+            raise ValueError('Signing failed')
+
+        res = lib.secp256k1_schnorrsig_verify(
+            self.context.ctx, signature, message, len(message), self.public_key_xonly.public_key
+        )
+        if not res:
+            raise ValueError('Invalid signature')
+
+        return bytes(ffi.buffer(signature))
+
+    def sign_recoverable(self, message: bytes, hasher: Hasher = sha256, custom_nonce: Nonce = DEFAULT_NONCE) -> bytes:
+        """
+        Create a recoverable ECDSA signature.
+
+        :param message: The message to sign.
+        :param hasher: The hash function to use, which must return 32 bytes. By default,
+                       the `sha256` algorithm is used. If `None`, no hashing occurs.
+        :param custom_nonce: Custom nonce data in the form `(nonce_function, input_data)`. Refer to
+                             [secp256k1_recovery.h](https://github.com/bitcoin-core/secp256k1/blob/f8c0b57e6ba202b1ce7c5357688de97c9c067697/include/secp256k1_recovery.h#L78-L79).
+        :return: The recoverable ECDSA signature.
+        :raises ValueError: If the message hash was not 32 bytes long, the nonce generation
+                            function failed, or the private key was invalid.
+        """
+        msg_hash = hasher(message) if hasher is not None else message
+        if len(msg_hash) != 32:
+            raise ValueError('Message hash must be 32 bytes long.')
+
+        signature = ffi.new('secp256k1_ecdsa_recoverable_signature *')
+        nonce_fn, nonce_data = custom_nonce
+
+        signed = lib.secp256k1_ecdsa_sign_recoverable(
+            self.context.ctx, signature, msg_hash, self.secret, nonce_fn, nonce_data
+        )
+
+        if not signed:
+            raise ValueError('The nonce generation function failed, or the private key was invalid.')
+
+        return serialize_recoverable(signature, self.context)
+
+    def ecdh(self, public_key: bytes) -> bytes:
+        """
+        Compute an EC Diffie-Hellman secret in constant time.
+
+        !!! note
+            This prevents malleability by returning `sha256(compressed_public_key)` instead of the `x` coordinate
+            directly. See #9.
+
+        :param public_key: The formatted public key.
+        :return: The 32 byte shared secret.
+        :raises ValueError: If the public key could not be parsed or was invalid.
+        """
+        secret = ffi.new('unsigned char [32]')
+
+        lib.secp256k1_ecdh(self.context.ctx, secret, PublicKey(public_key).public_key, self.secret, ffi.NULL, ffi.NULL)
+
+        return bytes(ffi.buffer(secret, 32))
+
+    def add(self, scalar: bytes, update: bool = False):
+        """
+        Add a scalar to the private key.
+
+        :param scalar: The scalar with which to add.
+        :param update: Whether or not to update and return the private key in-place.
+        :return: The new private key, or the modified private key if `update` is `True`.
+        :rtype: PrivateKey
+        :raises ValueError: If the tweak was out of range or the resulting private key was invalid.
+        """
+        scalar = pad_scalar(scalar)
+
+        secret = ffi.new('unsigned char [32]', self.secret)
+
+        success = lib.secp256k1_ec_seckey_tweak_add(self.context.ctx, secret, scalar)
+
+        if not success:
+            raise ValueError('The tweak was out of range, or the resulting private key is invalid.')
+
+        secret = bytes(ffi.buffer(secret, 32))
+
+        if update:
+            self.secret = secret
+            self._update_public_key()
+            return self
+
+        return PrivateKey(secret, self.context)
+
+    def multiply(self, scalar: bytes, update: bool = False):
+        """
+        Multiply the private key by a scalar.
+
+        :param scalar: The scalar with which to multiply.
+        :param update: Whether or not to update and return the private key in-place.
+        :return: The new private key, or the modified private key if `update` is `True`.
+        :rtype: PrivateKey
+        """
+        scalar = validate_secret(scalar)
+
+        secret = ffi.new('unsigned char [32]', self.secret)
+
+        lib.secp256k1_ec_seckey_tweak_mul(self.context.ctx, secret, scalar)
+
+        secret = bytes(ffi.buffer(secret, 32))
+
+        if update:
+            self.secret = secret
+            self._update_public_key()
+            return self
+
+        return PrivateKey(secret, self.context)
+
+    def to_hex(self) -> str:
+        """
+        :return: The private key encoded as a hex string.
+        """
+        return self.secret.hex()
+
+    def to_int(self) -> int:
+        """
+        :return: The private key as an integer.
+        """
+        return bytes_to_int(self.secret)
+
+    def to_pem(self) -> bytes:
+        """
+        :return: The private key encoded in PEM format.
+        """
+        return der_to_pem(self.to_der())
+
+    def to_der(self) -> bytes:
+        """
+        :return: The private key encoded in DER format.
+        """
+        pk = ECPrivateKey(
+            {
+                'version': 'ecPrivkeyVer1',
+                'private_key': self.to_int(),
+                'public_key': ECPointBitString(self.public_key.format(compressed=False)),
+            }
+        )
+
+        return PrivateKeyInfo(
+            {
+                'version': 0,
+                'private_key_algorithm': PrivateKeyAlgorithm(
+                    {
+                        'algorithm': 'ec',
+                        'parameters': ECDomainParameters(name='named', value='1.3.132.0.10'),
+                    }
+                ),
+                'private_key': pk,
+            }
+        ).dump()
+
+    @classmethod
+    def from_hex(cls, hexed: str, context: Context = GLOBAL_CONTEXT):
+        """
+        :param hexed: The private key encoded as a hex string.
+        :param context:
+        :return: The private key.
+        :rtype: PrivateKey
+        """
+        return PrivateKey(hex_to_bytes(hexed), context)
+
+    @classmethod
+    def from_int(cls, num: int, context: Context = GLOBAL_CONTEXT):
+        """
+        :param num: The private key as an integer.
+        :param context:
+        :return: The private key.
+        :rtype: PrivateKey
+        """
+        return PrivateKey(int_to_bytes_padded(num), context)
+
+    @classmethod
+    def from_pem(cls, pem: bytes, context: Context = GLOBAL_CONTEXT):
+        """
+        :param pem: The private key encoded in PEM format.
+        :param context:
+        :return: The private key.
+        :rtype: PrivateKey
+        """
+        return PrivateKey(
+            int_to_bytes_padded(PrivateKeyInfo.load(pem_to_der(pem)).native['private_key']['private_key']), context
+        )
+
+    @classmethod
+    def from_der(cls, der: bytes, context: Context = GLOBAL_CONTEXT):
+        """
+        :param der: The private key encoded in DER format.
+        :param context:
+        :return: The private key.
+        :rtype: PrivateKey
+        """
+        return PrivateKey(int_to_bytes_padded(PrivateKeyInfo.load(der).native['private_key']['private_key']), context)
+
+    def _update_public_key(self):
+        created = lib.secp256k1_ec_pubkey_create(self.context.ctx, self.public_key.public_key, self.secret)
+
+        if not created:
+            raise ValueError('Invalid secret.')
+
+    def __eq__(self, other) -> bool:
+        return self.secret == other.secret
+
+
+class PublicKey:
+    def __init__(self, data, context: Context = GLOBAL_CONTEXT):
+        """
+        :param data: The formatted public key. This class supports parsing
+                     compressed (33 bytes, header byte `0x02` or `0x03`),
+                     uncompressed (65 bytes, header byte `0x04`), or
+                     hybrid (65 bytes, header byte `0x06` or `0x07`) format public keys.
+        :type data: bytes
+        :param context:
+        :raises ValueError: If the public key could not be parsed or was invalid.
+        """
+        if not isinstance(data, bytes):
+            self.public_key = data
+        else:
+            public_key = ffi.new('secp256k1_pubkey *')
+
+            parsed = lib.secp256k1_ec_pubkey_parse(context.ctx, public_key, data, len(data))
+
+            if not parsed:
+                raise ValueError('The public key could not be parsed or is invalid.')
+
+            self.public_key = public_key
+
+        self.context = context
+
+    @classmethod
+    def from_secret(cls, secret: bytes, context: Context = GLOBAL_CONTEXT):
+        """
+        Derive a public key from a private key secret.
+
+        :param secret: The private key secret.
+        :param context:
+        :return: The public key.
+        :rtype: PublicKey
+        """
+        public_key = ffi.new('secp256k1_pubkey *')
+
+        created = lib.secp256k1_ec_pubkey_create(context.ctx, public_key, validate_secret(secret))
+
+        if not created:  # no cov
+            raise ValueError(
+                'Somehow an invalid secret was used. Please '
+                'submit this as an issue here: '
+                b/coincurve/issues/new'
+            )
+
+        return PublicKey(public_key, context)
+
+    @classmethod
+    def from_valid_secret(cls, secret: bytes, context: Context = GLOBAL_CONTEXT):
+        public_key = ffi.new('secp256k1_pubkey *')
+
+        created = lib.secp256k1_ec_pubkey_create(context.ctx, public_key, secret)
+
+        if not created:
+            raise ValueError('Invalid secret.')
+
+        return PublicKey(public_key, context)
+
+    @classmethod
+    def from_point(cls, x: int, y: int, context: Context = GLOBAL_CONTEXT):
+        """
+        Derive a public key from a coordinate point in the form `(x, y)`.
+
+        :param x:
+        :param y:
+        :param context:
+        :return: The public key.
+        :rtype: PublicKey
+        """
+        return PublicKey(b'\x04' + int_to_bytes_padded(x) + int_to_bytes_padded(y), context)
+
+    @classmethod
+    def from_signature_and_message(
+        cls, signature: bytes, message: bytes, hasher: Hasher = sha256, context: Context = GLOBAL_CONTEXT
+    ):
+        """
+        Recover an ECDSA public key from a recoverable signature.
+
+        :param signature: The recoverable ECDSA signature.
+        :param message: The message that was supposedly signed.
+        :param hasher: The hash function to use, which must return 32 bytes. By default,
+                       the `sha256` algorithm is used. If `None`, no hashing occurs.
+        :param context:
+        :return: The public key that signed the message.
+        :rtype: PublicKey
+        :raises ValueError: If the message hash was not 32 bytes long or recovery of the ECDSA public key failed.
+        """
+        return PublicKey(
+            recover(message, deserialize_recoverable(signature, context=context), hasher=hasher, context=context)
+        )
+
+    @classmethod
+    def combine_keys(cls, public_keys, context: Context = GLOBAL_CONTEXT):
+        """
+        Add a number of public keys together.
+
+        :param public_keys: A sequence of public keys.
+        :type public_keys: List[PublicKey]
+        :param context:
+        :return: The combined public key.
+        :rtype: PublicKey
+        :raises ValueError: If the sum of the public keys was invalid.
+        """
+        public_key = ffi.new('secp256k1_pubkey *')
+
+        combined = lib.secp256k1_ec_pubkey_combine(
+            context.ctx, public_key, [pk.public_key for pk in public_keys], len(public_keys)
+        )
+
+        if not combined:
+            raise ValueError('The sum of the public keys is invalid.')
+
+        return PublicKey(public_key, context)
+
+    def format(self, compressed: bool = True) -> bytes:  # noqa: A003
+        """
+        Format the public key.
+
+        :param compressed: Whether or to use the compressed format.
+        :return: The 33 byte formatted public key, or the 65 byte formatted public key if `compressed` is `False`.
+        """
+        length = 33 if compressed else 65
+        serialized = ffi.new('unsigned char [%d]' % length)
+        output_len = ffi.new('size_t *', length)
+
+        lib.secp256k1_ec_pubkey_serialize(
+            self.context.ctx, serialized, output_len, self.public_key, EC_COMPRESSED if compressed else EC_UNCOMPRESSED
+        )
+
+        return bytes(ffi.buffer(serialized, length))
+
+    def point(self) -> Tuple[int, int]:
+        """
+        :return: The public key as a coordinate point.
+        """
+        public_key = self.format(compressed=False)
+        return bytes_to_int(public_key[1:33]), bytes_to_int(public_key[33:])
+
+    def verify(self, signature: bytes, message: bytes, hasher: Hasher = sha256) -> bool:
+        """
+        :param signature: The ECDSA signature.
+        :param message: The message that was supposedly signed.
+        :param hasher: The hash function to use, which must return 32 bytes. By default,
+                       the `sha256` algorithm is used. If `None`, no hashing occurs.
+        :return: A boolean indicating whether or not the signature is correct.
+        :raises ValueError: If the message hash was not 32 bytes long or the DER-encoded signature could not be parsed.
+        """
+        msg_hash = hasher(message) if hasher is not None else message
+        if len(msg_hash) != 32:
+            raise ValueError('Message hash must be 32 bytes long.')
+
+        verified = lib.secp256k1_ecdsa_verify(self.context.ctx, der_to_cdata(signature), msg_hash, self.public_key)
+
+        # A performance hack to avoid global bool() lookup.
+        return not not verified
+
+    def add(self, scalar: bytes, update: bool = False):
+        """
+        Add a scalar to the public key.
+
+        :param scalar: The scalar with which to add.
+        :param update: Whether or not to update and return the public key in-place.
+        :return: The new public key, or the modified public key if `update` is `True`.
+        :rtype: PublicKey
+        :raises ValueError: If the tweak was out of range or the resulting public key was invalid.
+        """
+        scalar = pad_scalar(scalar)
+
+        new_key = ffi.new('secp256k1_pubkey *', self.public_key[0])
+
+        success = lib.secp256k1_ec_pubkey_tweak_add(self.context.ctx, new_key, scalar)
+
+        if not success:
+            raise ValueError('The tweak was out of range, or the resulting public key is invalid.')
+
+        if update:
+            self.public_key = new_key
+            return self
+
+        return PublicKey(new_key, self.context)
+
+    def multiply(self, scalar: bytes, update: bool = False):
+        """
+        Multiply the public key by a scalar.
+
+        :param scalar: The scalar with which to multiply.
+        :param update: Whether or not to update and return the public key in-place.
+        :return: The new public key, or the modified public key if `update` is `True`.
+        :rtype: PublicKey
+        """
+        scalar = validate_secret(scalar)
+
+        new_key = ffi.new('secp256k1_pubkey *', self.public_key[0])
+
+        lib.secp256k1_ec_pubkey_tweak_mul(self.context.ctx, new_key, scalar)
+
+        if update:
+            self.public_key = new_key
+            return self
+
+        return PublicKey(new_key, self.context)
+
+    def combine(self, public_keys, update: bool = False):
+        """
+        Add a number of public keys together.
+
+        :param public_keys: A sequence of public keys.
+        :type public_keys: List[PublicKey]
+        :param update: Whether or not to update and return the public key in-place.
+        :return: The combined public key, or the modified public key if `update` is `True`.
+        :rtype: PublicKey
+        :raises ValueError: If the sum of the public keys was invalid.
+        """
+        new_key = ffi.new('secp256k1_pubkey *')
+
+        combined = lib.secp256k1_ec_pubkey_combine(
+            self.context.ctx, new_key, [pk.public_key for pk in [self, *public_keys]], len(public_keys) + 1
+        )
+
+        if not combined:
+            raise ValueError('The sum of the public keys is invalid.')
+
+        if update:
+            self.public_key = new_key
+            return self
+
+        return PublicKey(new_key, self.context)
+
+    def __eq__(self, other) -> bool:
+        return self.format(compressed=False) == other.format(compressed=False)
+
+
+class PublicKeyXOnly:
+    def __init__(self, data, parity: bool = False, context: Context = GLOBAL_CONTEXT):
+        """A BIP340 `x-only` public key.
+
+        :param data: The formatted public key.
+        :type data: bytes
+        :param parity: Whether the encoded point is the negation of the public key.
+        :param context:
+        """
+        if not isinstance(data, bytes):
+            self.public_key = data
+        else:
+            public_key = ffi.new('secp256k1_xonly_pubkey *')
+            parsed = lib.secp256k1_xonly_pubkey_parse(context.ctx, public_key, data)
+            if not parsed:
+                raise ValueError('The public key could not be parsed or is invalid.')
+
+            self.public_key = public_key
+
+        self.parity = parity
+        self.context = context
+
+    @classmethod
+    def from_secret(cls, secret: bytes, context: Context = GLOBAL_CONTEXT):
+        """Derive an x-only public key from a private key secret.
+
+        :param secret: The private key secret.
+        :param context:
+        :return: The x-only public key.
+        """
+        keypair = ffi.new('secp256k1_keypair *')
+        res = lib.secp256k1_keypair_create(context.ctx, keypair, validate_secret(secret))
+        if not res:
+            raise ValueError('Secret was invalid')
+
+        xonly_pubkey = ffi.new('secp256k1_xonly_pubkey *')
+        pk_parity = ffi.new('int *')
+        res = lib.secp256k1_keypair_xonly_pub(context.ctx, xonly_pubkey, pk_parity, keypair)
+
+        return cls(xonly_pubkey, parity=not not pk_parity[0], context=context)
+
+    @classmethod
+    def from_valid_secret(cls, secret: bytes, context: Context = GLOBAL_CONTEXT):
+        keypair = ffi.new('secp256k1_keypair *')
+        res = lib.secp256k1_keypair_create(context.ctx, keypair, secret)
+        if not res:
+            raise ValueError('Secret was invalid')
+
+        xonly_pubkey = ffi.new('secp256k1_xonly_pubkey *')
+        pk_parity = ffi.new('int *')
+        res = lib.secp256k1_keypair_xonly_pub(context.ctx, xonly_pubkey, pk_parity, keypair)
+
+        return cls(xonly_pubkey, parity=not not pk_parity[0], context=context)
+
+    def format(self) -> bytes:  # noqa: A003
+        """Serialize the public key.
+
+        :return: The public key serialized as 32 bytes.
+        """
+        output32 = ffi.new('unsigned char [32]')
+
+        res = lib.secp256k1_xonly_pubkey_serialize(self.context.ctx, output32, self.public_key)
+        if not res:
+            raise ValueError('Public key in self.public_key must be valid')
+
+        return bytes(ffi.buffer(output32, 32))
+
+    def verify(self, signature: bytes, message: bytes) -> bool:
+        """Verify a Schnorr signature over a given message.
+
+        :param signature: The 64-byte Schnorr signature to verify.
+        :param message: The message to be verified.
+        :return: A boolean indicating whether or not the signature is correct.
+        """
+        if len(signature) != 64:
+            raise ValueError('Signature must be 32 bytes long.')
+
+        return not not lib.secp256k1_schnorrsig_verify(
+            self.context.ctx, signature, message, len(message), self.public_key
+        )
+
+    def tweak_add(self, scalar: bytes):
+        """Add a scalar to the public key.
+
+        :param scalar: The scalar with which to add.
+        :return: The modified public key.
+        :rtype: PublicKeyXOnly
+        :raises ValueError: If the tweak was out of range or the resulting public key was invalid.
+        """
+        scalar = pad_scalar(scalar)
+
+        out_pubkey = ffi.new('secp256k1_pubkey *')
+        res = lib.secp256k1_xonly_pubkey_tweak_add(self.context.ctx, out_pubkey, self.public_key, scalar)
+        if not res:
+            raise ValueError('The tweak was out of range, or the resulting public key would be invalid')
+
+        pk_parity = ffi.new('int *')
+        lib.secp256k1_xonly_pubkey_from_pubkey(self.context.ctx, self.public_key, pk_parity, out_pubkey)
+        self.parity = not not pk_parity[0]
+
+    def __eq__(self, other) -> bool:
+        res = lib.secp256k1_xonly_pubkey_cmp(self.context.ctx, self.public_key, other.public_key)
+        return res == 0
Common subdirectories: _cffi_build/__pycache__ and b/coincurve/__pycache__
diff -Nu _cffi_build/secp256k1_ecdh.h b/coincurve/secp256k1_ecdh.h
--- _cffi_build/secp256k1_ecdh.h	2022-11-19 14:10:25.000000000 -0600
+++ b/coincurve/secp256k1_ecdh.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,8 +0,0 @@
-int secp256k1_ecdh(
-  const secp256k1_context* ctx,
-  unsigned char *result,
-  const secp256k1_pubkey *pubkey,
-  const unsigned char *privkey,
-  void *hashfp,
-  void *data
-);
diff -Nu _cffi_build/secp256k1_extrakeys.h b/coincurve/secp256k1_extrakeys.h
--- _cffi_build/secp256k1_extrakeys.h	2022-11-19 14:10:25.000000000 -0600
+++ b/coincurve/secp256k1_extrakeys.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,78 +0,0 @@
-typedef struct {
-    unsigned char data[64];
-} secp256k1_xonly_pubkey;
-
-typedef struct {
-    unsigned char data[96];
-} secp256k1_keypair;
-
-int secp256k1_xonly_pubkey_parse(
-    const secp256k1_context* ctx,
-    secp256k1_xonly_pubkey* pubkey,
-    const unsigned char *input32
-);
-
-int secp256k1_xonly_pubkey_serialize(
-    const secp256k1_context* ctx,
-    unsigned char *output32,
-    const secp256k1_xonly_pubkey* pubkey
-);
-
-int secp256k1_xonly_pubkey_cmp(
-    const secp256k1_context* ctx,
-    const secp256k1_xonly_pubkey* pk1,
-    const secp256k1_xonly_pubkey* pk2
-);
-
-int secp256k1_xonly_pubkey_from_pubkey(
-    const secp256k1_context* ctx,
-    secp256k1_xonly_pubkey *xonly_pubkey,
-    int *pk_parity,
-    const secp256k1_pubkey *pubkey
-);
-
-int secp256k1_xonly_pubkey_tweak_add(
-    const secp256k1_context* ctx,
-    secp256k1_pubkey *output_pubkey,
-    const secp256k1_xonly_pubkey *internal_pubkey,
-    const unsigned char *tweak32
-);
-
-int secp256k1_xonly_pubkey_tweak_add_check(
-    const secp256k1_context* ctx,
-    const unsigned char *tweaked_pubkey32,
-    int tweaked_pk_parity,
-    const secp256k1_xonly_pubkey *internal_pubkey,
-    const unsigned char *tweak32
-);
-
-int secp256k1_keypair_create(
-    const secp256k1_context* ctx,
-    secp256k1_keypair *keypair,
-    const unsigned char *seckey
-);
-
-int secp256k1_keypair_sec(
-    const secp256k1_context* ctx,
-    unsigned char *seckey,
-    const secp256k1_keypair *keypair
-);
-
-int secp256k1_keypair_pub(
-    const secp256k1_context* ctx,
-    secp256k1_pubkey *pubkey,
-    const secp256k1_keypair *keypair
-);
-
-int secp256k1_keypair_xonly_pub(
-    const secp256k1_context* ctx,
-    secp256k1_xonly_pubkey *pubkey,
-    int *pk_parity,
-    const secp256k1_keypair *keypair
-);
-
-int secp256k1_keypair_xonly_tweak_add(
-    const secp256k1_context* ctx,
-    secp256k1_keypair *keypair,
-    const unsigned char *tweak32
-);
diff -Nu _cffi_build/secp256k1.h b/coincurve/secp256k1.h
--- _cffi_build/secp256k1.h	2022-11-19 14:10:25.000000000 -0600
+++ b/coincurve/secp256k1.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,170 +0,0 @@
-typedef struct secp256k1_context_struct secp256k1_context;
-
-typedef struct {
-    unsigned char data[64];
-} secp256k1_pubkey;
-
-typedef struct {
-    unsigned char data[64];
-} secp256k1_ecdsa_signature;
-
-typedef int (*secp256k1_nonce_function)(
-    unsigned char *nonce32,
-    const unsigned char *msg32,
-    const unsigned char *key32,
-    const unsigned char *algo16,
-    void *data,
-    unsigned int attempt
-);
-
-#define SECP256K1_FLAGS_TYPE_MASK ...
-#define SECP256K1_FLAGS_TYPE_CONTEXT ...
-#define SECP256K1_FLAGS_TYPE_COMPRESSION ...
-#define SECP256K1_FLAGS_BIT_CONTEXT_VERIFY ...
-#define SECP256K1_FLAGS_BIT_CONTEXT_SIGN ...
-#define SECP256K1_FLAGS_BIT_COMPRESSION ...
-
-#define SECP256K1_CONTEXT_VERIFY ...
-#define SECP256K1_CONTEXT_SIGN ...
-#define SECP256K1_CONTEXT_NONE ...
-
-#define SECP256K1_EC_COMPRESSED ...
-#define SECP256K1_EC_UNCOMPRESSED ...
-
-secp256k1_context* secp256k1_context_create(
-    unsigned int flags
-);
-
-secp256k1_context* secp256k1_context_clone(
-    const secp256k1_context* ctx
-);
-
-void secp256k1_context_destroy(
-    secp256k1_context* ctx
-);
-
-void secp256k1_context_set_illegal_callback(
-    secp256k1_context* ctx,
-    void (*fun)(const char* message, void* data),
-    const void* data
-);
-
-void secp256k1_context_set_error_callback(
-    secp256k1_context* ctx,
-    void (*fun)(const char* message, void* data),
-    const void* data
-);
-
-int secp256k1_ec_pubkey_parse(
-    const secp256k1_context* ctx,
-    secp256k1_pubkey* pubkey,
-    const unsigned char *input,
-    size_t inputlen
-);
-
-int secp256k1_ec_pubkey_serialize(
-    const secp256k1_context* ctx,
-    unsigned char *output,
-    size_t *outputlen,
-    const secp256k1_pubkey* pubkey,
-    unsigned int flags
-);
-
-int secp256k1_ecdsa_signature_parse_compact(
-    const secp256k1_context* ctx,
-    secp256k1_ecdsa_signature* sig,
-    const unsigned char *input64
-);
-
-int secp256k1_ecdsa_signature_parse_der(
-    const secp256k1_context* ctx,
-    secp256k1_ecdsa_signature* sig,
-    const unsigned char *input,
-    size_t inputlen
-);
-
-int secp256k1_ecdsa_signature_serialize_der(
-    const secp256k1_context* ctx,
-    unsigned char *output,
-    size_t *outputlen,
-    const secp256k1_ecdsa_signature* sig
-);
-
-int secp256k1_ecdsa_signature_serialize_compact(
-    const secp256k1_context* ctx,
-    unsigned char *output64,
-    const secp256k1_ecdsa_signature* sig
-);
-
-int secp256k1_ecdsa_verify(
-    const secp256k1_context* ctx,
-    const secp256k1_ecdsa_signature *sig,
-    const unsigned char *msg32,
-    const secp256k1_pubkey *pubkey
-);
-
-int secp256k1_ecdsa_signature_normalize(
-    const secp256k1_context* ctx,
-    secp256k1_ecdsa_signature *sigout,
-    const secp256k1_ecdsa_signature *sigin
-);
-
-extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979;
-
-extern const secp256k1_nonce_function secp256k1_nonce_function_default;
-
-int secp256k1_ecdsa_sign(
-    const secp256k1_context* ctx,
-    secp256k1_ecdsa_signature *sig,
-    const unsigned char *msg32,
-    const unsigned char *seckey,
-    secp256k1_nonce_function noncefp,
-    const void *ndata
-);
-
-int secp256k1_ec_seckey_verify(
-    const secp256k1_context* ctx,
-    const unsigned char *seckey
-);
-
-int secp256k1_ec_pubkey_create(
-    const secp256k1_context* ctx,
-    secp256k1_pubkey *pubkey,
-    const unsigned char *seckey
-);
-
-int secp256k1_ec_privkey_tweak_add(
-    const secp256k1_context* ctx,
-    unsigned char *seckey,
-    const unsigned char *tweak
-);
-
-int secp256k1_ec_pubkey_tweak_add(
-    const secp256k1_context* ctx,
-    secp256k1_pubkey *pubkey,
-    const unsigned char *tweak
-);
-
-int secp256k1_ec_privkey_tweak_mul(
-    const secp256k1_context* ctx,
-    unsigned char *seckey,
-    const unsigned char *tweak
-);
-
-int secp256k1_ec_pubkey_tweak_mul(
-    const secp256k1_context* ctx,
-    secp256k1_pubkey *pubkey,
-    const unsigned char *tweak
-);
-
-int secp256k1_context_randomize(
-    secp256k1_context* ctx,
-    const unsigned char *seed32
-);
-
-int secp256k1_ec_pubkey_combine(
-    const secp256k1_context* ctx,
-    secp256k1_pubkey *out,
-    const secp256k1_pubkey * const * ins,
-    size_t n
-);
diff -Nu _cffi_build/secp256k1_recovery.h b/coincurve/secp256k1_recovery.h
--- _cffi_build/secp256k1_recovery.h	2022-11-19 14:10:25.000000000 -0600
+++ b/coincurve/secp256k1_recovery.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,39 +0,0 @@
-typedef struct {
-    unsigned char data[65];
-} secp256k1_ecdsa_recoverable_signature;
-
-int secp256k1_ecdsa_recoverable_signature_parse_compact(
-    const secp256k1_context* ctx,
-    secp256k1_ecdsa_recoverable_signature* sig,
-    const unsigned char *input64,
-    int recid
-);
-
-int secp256k1_ecdsa_recoverable_signature_convert(
-    const secp256k1_context* ctx,
-    secp256k1_ecdsa_signature* sig,
-    const secp256k1_ecdsa_recoverable_signature* sigin
-);
-
-int secp256k1_ecdsa_recoverable_signature_serialize_compact(
-    const secp256k1_context* ctx,
-    unsigned char *output64,
-    int *recid,
-    const secp256k1_ecdsa_recoverable_signature* sig
-);
-
-int secp256k1_ecdsa_sign_recoverable(
-    const secp256k1_context* ctx,
-    secp256k1_ecdsa_recoverable_signature *sig,
-    const unsigned char *msg32,
-    const unsigned char *seckey,
-    secp256k1_nonce_function noncefp,
-    const void *ndata
-);
-
-int secp256k1_ecdsa_recover(
-    const secp256k1_context* ctx,
-    secp256k1_pubkey *pubkey,
-    const secp256k1_ecdsa_recoverable_signature *sig,
-    const unsigned char *msg32
-);
diff -Nu _cffi_build/secp256k1_schnorrsig.h b/coincurve/secp256k1_schnorrsig.h
--- _cffi_build/secp256k1_schnorrsig.h	2022-11-19 14:10:25.000000000 -0600
+++ b/coincurve/secp256k1_schnorrsig.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,51 +0,0 @@
-typedef int (*secp256k1_nonce_function_hardened)(
-    unsigned char *nonce32,
-    const unsigned char *msg,
-    size_t msglen,
-    const unsigned char *key32,
-    const unsigned char *xonly_pk32,
-    const unsigned char *algo,
-    size_t algolen,
-    void *data
-);
-
-extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;
-
-typedef struct {
-    unsigned char magic[4];
-    secp256k1_nonce_function_hardened noncefp;
-    void* ndata;
-} secp256k1_schnorrsig_extraparams;
-
-int secp256k1_schnorrsig_sign(
-    const secp256k1_context* ctx,
-    unsigned char *sig64,
-    const unsigned char *msg32,
-    const secp256k1_keypair *keypair,
-    const unsigned char *aux_rand32
-);
-
-int secp256k1_schnorrsig_sign32(
-    const secp256k1_context* ctx,
-    unsigned char *sig64,
-    const unsigned char *msg32,
-    const secp256k1_keypair *keypair,
-    const unsigned char *aux_rand32
-);
-
-int secp256k1_schnorrsig_sign_custom(
-    const secp256k1_context* ctx,
-    unsigned char *sig64,
-    const unsigned char *msg,
-    size_t msglen,
-    const secp256k1_keypair *keypair,
-    secp256k1_schnorrsig_extraparams *extraparams
-);
-
-int secp256k1_schnorrsig_verify(
-    const secp256k1_context* ctx,
-    const unsigned char *sig64,
-    const unsigned char *msg,
-    size_t msglen,
-    const secp256k1_xonly_pubkey *pubkey
-);
diff -Nu _cffi_build/types.py b/coincurve/types.py
--- _cffi_build/types.py	1969-12-31 18:00:00.000000000 -0600
+++ b/coincurve/types.py	2023-09-02 16:54:48.207368141 -0500
@@ -0,0 +1,13 @@
+import sys
+from typing import Optional, Tuple
+
+from ._libsecp256k1 import ffi
+
+# https://bugs.python.org/issue42965
+if sys.version_info >= (3, 9, 2):
+    from collections.abc import Callable
+else:
+    from typing import Callable
+
+Hasher = Optional[Callable[[bytes], bytes]]
+Nonce = Tuple[ffi.CData, ffi.CData]
diff -Nu _cffi_build/utils.py b/coincurve/utils.py
--- _cffi_build/utils.py	1969-12-31 18:00:00.000000000 -0600
+++ b/coincurve/utils.py	2023-09-25 10:19:04.102511107 -0500
@@ -0,0 +1,130 @@
+from base64 import b64decode, b64encode
+from hashlib import sha256 as _sha256
+from os import environ, urandom
+from typing import Generator
+
+from a/coincurve.context import GLOBAL_CONTEXT, Context
+from a/coincurve.types import Hasher
+
+from ._libsecp256k1 import ffi, lib
+
+GROUP_ORDER = (
+    b'\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'
+    b'\xfe\xba\xae\xdc\xe6\xafH\xa0;\xbf\xd2^\x8c\xd06AA'
+)
+GROUP_ORDER_INT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
+KEY_SIZE = 32
+ZERO = b'\x00'
+PEM_HEADER = b'-----BEGIN PRIVATE KEY-----\n'
+PEM_FOOTER = b'-----END PRIVATE KEY-----\n'
+
+
+if environ.get('COINCURVE_BUILDING_DOCS') != 'true':
+    DEFAULT_NONCE = (ffi.NULL, ffi.NULL)
+
+    def sha256(bytestr: bytes) -> bytes:
+        return _sha256(bytestr).digest()
+
+else:  # no cov
+
+    class __Nonce(tuple):  # noqa: N801
+        def __repr__(self):
+            return '(ffi.NULL, ffi.NULL)'
+
+    class __HasherSHA256:  # noqa: N801
+        def __call__(self, bytestr: bytes) -> bytes:
+            return _sha256(bytestr).digest()
+
+        def __repr__(self):
+            return 'sha256'
+
+    DEFAULT_NONCE = __Nonce((ffi.NULL, ffi.NULL))  # type: ignore
+    sha256 = __HasherSHA256()
+
+
+def pad_hex(hexed: str) -> str:
+    # Pad odd-length hex strings.
+    return hexed if not len(hexed) & 1 else f'0{hexed}'
+
+
+def bytes_to_int(bytestr: bytes) -> int:
+    return int.from_bytes(bytestr, 'big')
+
+
+def int_to_bytes(num: int) -> bytes:
+    return num.to_bytes((num.bit_length() + 7) // 8 or 1, 'big')
+
+
+def int_to_bytes_padded(num: int) -> bytes:
+    return pad_scalar(num.to_bytes((num.bit_length() + 7) // 8 or 1, 'big'))
+
+
+def hex_to_bytes(hexed: str) -> bytes:
+    return pad_scalar(bytes.fromhex(pad_hex(hexed)))
+
+
+def chunk_data(data: bytes, size: int) -> Generator[bytes, None, None]:
+    return (data[i : i + size] for i in range(0, len(data), size))
+
+
+def der_to_pem(der: bytes) -> bytes:
+    return b''.join([PEM_HEADER, b'\n'.join(chunk_data(b64encode(der), 64)), b'\n', PEM_FOOTER])
+
+
+def pem_to_der(pem: bytes) -> bytes:
+    return b64decode(b''.join(pem.strip().splitlines()[1:-1]))
+
+
+def get_valid_secret() -> bytes:
+    while True:
+        secret = urandom(KEY_SIZE)
+        if ZERO < secret < GROUP_ORDER:
+            return secret
+
+
+def pad_scalar(scalar: bytes) -> bytes:
+    return (ZERO * (KEY_SIZE - len(scalar))) + scalar
+
+
+def validate_secret(secret: bytes) -> bytes:
+    if not 0 < bytes_to_int(secret) < GROUP_ORDER_INT:
+        raise ValueError(f'Secret scalar must be greater than 0 and less than {GROUP_ORDER_INT}.')
+    return pad_scalar(secret)
+
+
+def verify_signature(
+    signature: bytes, message: bytes, public_key: bytes, hasher: Hasher = sha256, context: Context = GLOBAL_CONTEXT
+) -> bool:
+    """
+    :param signature: The ECDSA signature.
+    :param message: The message that was supposedly signed.
+    :param public_key: The formatted public key.
+    :param hasher: The hash function to use, which must return 32 bytes. By default,
+                   the `sha256` algorithm is used. If `None`, no hashing occurs.
+    :param context:
+    :return: A boolean indicating whether or not the signature is correct.
+    :raises ValueError: If the public key could not be parsed or was invalid, the message hash was
+                        not 32 bytes long, or the DER-encoded signature could not be parsed.
+    """
+    pubkey = ffi.new('secp256k1_pubkey *')
+
+    pubkey_parsed = lib.secp256k1_ec_pubkey_parse(context.ctx, pubkey, public_key, len(public_key))
+
+    if not pubkey_parsed:
+        raise ValueError('The public key could not be parsed or is invalid.')
+
+    msg_hash = hasher(message) if hasher is not None else message
+    if len(msg_hash) != 32:
+        raise ValueError('Message hash must be 32 bytes long.')
+
+    sig = ffi.new('secp256k1_ecdsa_signature *')
+
+    sig_parsed = lib.secp256k1_ecdsa_signature_parse_der(context.ctx, sig, signature, len(signature))
+
+    if not sig_parsed:
+        raise ValueError('The DER-encoded signature could not be parsed.')
+
+    verified = lib.secp256k1_ecdsa_verify(context.ctx, sig, msg_hash, pubkey)
+
+    # A performance hack to avoid global bool() lookup.
+    return not not verified
