diff -ruN MUMPS_5.1.2/include/cmumps_root.h mumps-5.1.2-aster7/include/cmumps_root.h
--- MUMPS_5.1.2/include/cmumps_root.h	2017-10-02 09:37:22.000000000 +0200
+++ mumps-5.1.2-aster7/include/cmumps_root.h	2020-10-23 11:16:48.000000000 +0200
@@ -12,34 +12,34 @@
 !
       TYPE CMUMPS_ROOT_STRUC
         SEQUENCE
-        INTEGER :: MBLOCK, NBLOCK, NPROW, NPCOL
-        INTEGER :: MYROW, MYCOL
-        INTEGER :: SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
-        INTEGER :: RHS_NLOC
-        INTEGER :: ROOT_SIZE, TOT_ROOT_SIZE
+        INTEGER(4) :: MBLOCK, NBLOCK, NPROW, NPCOL
+        INTEGER(4) :: MYROW, MYCOL
+        INTEGER(4) :: SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
+        INTEGER(4) :: RHS_NLOC
+        INTEGER(4) :: ROOT_SIZE, TOT_ROOT_SIZE
 !       descriptor for scalapack
-        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR
-        INTEGER :: CNTXT_BLACS, LPIV, rootpad0
-        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
-        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
-        INTEGER , DIMENSION(:), POINTER :: IPIV, rootpad1
+        INTEGER(4), DIMENSION( 9 ) :: DESCRIPTOR
+        INTEGER(4) :: CNTXT_BLACS, LPIV, rootpad0
+        INTEGER(4), DIMENSION(:), POINTER :: RG2L_ROW
+        INTEGER(4), DIMENSION(:), POINTER :: RG2L_COL
+        INTEGER(4) , DIMENSION(:), POINTER :: IPIV, rootpad1
 !       Centralized master of root
-        COMPLEX, DIMENSION(:), POINTER :: RHS_CNTR_MASTER_ROOT
+        COMPLEX(4), DIMENSION(:), POINTER :: RHS_CNTR_MASTER_ROOT
 !       Used to access Schur easily from root structure
-        COMPLEX, DIMENSION(:), POINTER :: SCHUR_POINTER
+        COMPLEX(4), DIMENSION(:), POINTER :: SCHUR_POINTER
 !       for try_null_space preprocessing constant only:
-        COMPLEX, DIMENSION(:), POINTER :: QR_TAU, rootpad2
+        COMPLEX(4), DIMENSION(:), POINTER :: QR_TAU, rootpad2
 !       Fwd in facto: 
 !           case of scalapack root: to store RHS in 2D block cyclic
 !           format compatible with root distribution
-        COMPLEX, DIMENSION(:,:), POINTER :: RHS_ROOT, rootpad
+        COMPLEX(4), DIMENSION(:,:), POINTER :: RHS_ROOT, rootpad
 !       for try_nullspace preprocessing constant only:
-        REAL :: QR_RCOND, rootpad3
-        LOGICAL :: yes, gridinit_done
+        REAL(4) :: QR_RCOND, rootpad3
+        LOGICAL(4) :: yes, gridinit_done
 !       for SVD on root (#define try_null_space)
-        COMPLEX, DIMENSION(:,:), POINTER :: SVD_U, SVD_VT
+        COMPLEX(4), DIMENSION(:,:), POINTER :: SVD_U, SVD_VT
 !       for RR on root (#define try_null_space)
-        REAL, DIMENSION(:), POINTER :: SINGULAR_VALUES
-        INTEGER :: NB_SINGULAR_VALUES,rootpad4
+        REAL(4), DIMENSION(:), POINTER :: SINGULAR_VALUES
+        INTEGER(4) :: NB_SINGULAR_VALUES
 !
       END TYPE CMUMPS_ROOT_STRUC
diff -ruN MUMPS_5.1.2/include/cmumps_struc.h mumps-5.1.2-aster7/include/cmumps_struc.h
--- MUMPS_5.1.2/include/cmumps_struc.h	2017-10-02 09:37:22.000000000 +0200
+++ mumps-5.1.2-aster7/include/cmumps_struc.h	2020-10-23 11:16:48.000000000 +0200
@@ -14,7 +14,7 @@
       TYPE CMUMPS_STRUC
         SEQUENCE
 !
-! This structure contains all parameters 
+! This structure contains all parameters
 ! for the interface to the user, plus internal
 ! information from the solver
 !
@@ -24,102 +24,102 @@
 !    -----------------
 !    MPI Communicator
 !    -----------------
-        INTEGER :: COMM
+        INTEGER(4) :: COMM
 !    ------------------
 !    Problem definition
 !    ------------------
-!    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite, 
+!    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite,
 !        SYM=2 general symmetric)
 !    Type of parallelism (PAR=1 host working, PAR=0 host not working)
-        INTEGER ::  SYM, PAR
-        INTEGER ::  JOB 
+        INTEGER(4) ::  SYM, PAR
+        INTEGER(4) ::  JOB
 !    --------------------
-!    Order of Input matrix 
+!    Order of Input matrix
 !    --------------------
-        INTEGER ::  N
+        INTEGER(4) ::  N
 !
 !    ----------------------------------------
 !    Assembled input matrix : User interface
 !    ----------------------------------------
-        INTEGER    :: NZ  ! Standard integer input + bwd. compat.
+        INTEGER(4) :: NZ  ! Standard integer input + bwd. compat.
         INTEGER(8) :: NNZ ! 64-bit integer input
-        COMPLEX, DIMENSION(:), POINTER :: A
-        INTEGER, DIMENSION(:), POINTER :: IRN, JCN
-        REAL, DIMENSION(:), POINTER :: COLSCA, ROWSCA, pad0
+        COMPLEX(4), DIMENSION(:), POINTER :: A
+        INTEGER(4), DIMENSION(:), POINTER :: IRN, JCN
+        REAL(4), DIMENSION(:), POINTER :: COLSCA, ROWSCA, pad0
 !
 !       ------------------------------------
 !       Case of distributed assembled matrix
 !       matrix on entry:
 !       ------------------------------------
-        INTEGER    :: NZ_loc  ! Standard integer input + bwd. compat.
-        INTEGER    :: pad1
+        INTEGER(4) :: NZ_loc  ! Standard integer input + bwd. compat.
+        INTEGER(4) :: pad1
         INTEGER(8) :: NNZ_loc ! 64-bit integer input
-        INTEGER, DIMENSION(:), POINTER :: IRN_loc, JCN_loc
-        COMPLEX, DIMENSION(:), POINTER :: A_loc, pad2
+        INTEGER(4), DIMENSION(:), POINTER :: IRN_loc, JCN_loc
+        COMPLEX(4), DIMENSION(:), POINTER :: A_loc, pad2
 !
 !    ----------------------------------------
 !    Unassembled input matrix: User interface
 !    ----------------------------------------
-        INTEGER :: NELT, pad3
-        INTEGER, DIMENSION(:), POINTER :: ELTPTR
-        INTEGER, DIMENSION(:), POINTER :: ELTVAR
-        COMPLEX, DIMENSION(:), POINTER :: A_ELT, pad4
+        INTEGER(4) :: NELT, pad3
+        INTEGER(4), DIMENSION(:), POINTER :: ELTPTR
+        INTEGER(4), DIMENSION(:), POINTER :: ELTVAR
+        COMPLEX(4), DIMENSION(:), POINTER :: A_ELT, pad4
 !
 !    ---------------------------------------------
-!    Symmetric permutation : 
+!    Symmetric permutation :
 !               PERM_IN if given by user (optional)
 !    ---------------------------------------------
-        INTEGER, DIMENSION(:), POINTER :: PERM_IN
+        INTEGER(4), DIMENSION(:), POINTER :: PERM_IN
 !
 !
 ! ******************
-! INPUT/OUTPUT data 
+! INPUT/OUTPUT data
 ! ******************
 !    --------------------------------------------------------
 !    RHS / SOL_loc
 !    -------------
 !       right-hand side and solution
 !    -------------------------------------------------------
-        COMPLEX, DIMENSION(:), POINTER :: RHS, REDRHS
-        COMPLEX, DIMENSION(:), POINTER :: RHS_SPARSE
-        COMPLEX, DIMENSION(:), POINTER :: SOL_loc
-        INTEGER, DIMENSION(:), POINTER :: IRHS_SPARSE
-        INTEGER, DIMENSION(:), POINTER :: IRHS_PTR
-        INTEGER, DIMENSION(:), POINTER :: ISOL_loc
-        INTEGER ::  LRHS, NRHS, NZ_RHS, LSOL_loc, LREDRHS
-        INTEGER ::  pad5
+        COMPLEX(4), DIMENSION(:), POINTER :: RHS, REDRHS
+        COMPLEX(4), DIMENSION(:), POINTER :: RHS_SPARSE
+        COMPLEX(4), DIMENSION(:), POINTER :: SOL_loc
+        INTEGER(4), DIMENSION(:), POINTER :: IRHS_SPARSE
+        INTEGER(4), DIMENSION(:), POINTER :: IRHS_PTR
+        INTEGER(4), DIMENSION(:), POINTER :: ISOL_loc
+        INTEGER(4) ::  LRHS, NRHS, NZ_RHS, LSOL_loc, LREDRHS
+        INTEGER(4) ::  pad5
 !    ----------------------------
 !    Control parameters,
 !    statistics and output data
 !    ---------------------------
-        INTEGER ::  ICNTL(40)
-        INTEGER ::  INFO(40) 
-        INTEGER :: INFOG(40)
-        REAL ::  COST_SUBTREES
-        REAL ::  CNTL(15)
-        REAL ::  RINFO(40)
-        REAL ::  RINFOG(40)
+        INTEGER(4) ::  ICNTL(40)
+        INTEGER(4) ::  INFO(40)
+        INTEGER(4) :: INFOG(40)
+        REAL(4) ::  COST_SUBTREES
+        REAL(4) ::  CNTL(15)
+        REAL(4) ::  RINFO(40)
+        REAL(4) ::  RINFOG(40)
 !    ---------------------------------------------------------
 !    Permutations computed during analysis:
-!       SYM_PERM: Symmetric permutation 
+!       SYM_PERM: Symmetric permutation
 !       UNS_PERM: Column permutation (optional)
 !    ---------------------------------------------------------
-        INTEGER, DIMENSION(:), POINTER :: SYM_PERM, UNS_PERM
-! 
+        INTEGER(4), DIMENSION(:), POINTER :: SYM_PERM, UNS_PERM
+!
 !    -----
 !    Schur
 !    -----
-        INTEGER ::  NPROW, NPCOL, MBLOCK, NBLOCK
-        INTEGER ::  SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
-        INTEGER ::  SIZE_SCHUR
-        COMPLEX, DIMENSION(:), POINTER :: SCHUR
-        COMPLEX, DIMENSION(:), POINTER :: SCHUR_CINTERFACE
-        INTEGER, DIMENSION(:), POINTER :: LISTVAR_SCHUR
+        INTEGER(4) ::  NPROW, NPCOL, MBLOCK, NBLOCK
+        INTEGER(4) ::  SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
+        INTEGER(4) ::  SIZE_SCHUR
+        COMPLEX(4), DIMENSION(:), POINTER :: SCHUR
+        COMPLEX(4), DIMENSION(:), POINTER :: SCHUR_CINTERFACE
+        INTEGER(4), DIMENSION(:), POINTER :: LISTVAR_SCHUR
 !    -------------------------------------
 !    Case of distributed matrix on entry:
 !    CMUMPS potentially provides mapping
 !    -------------------------------------
-        INTEGER, DIMENSION(:), POINTER :: MAPPING
+        INTEGER(4), DIMENSION(:), POINTER :: MAPPING
 !    --------------
 !    Version number
 !    --------------
@@ -145,133 +145,133 @@
 ! INTERNAL Working data
 ! *********************
         INTEGER(8) :: KEEP8(150), MAX_SURF_MASTER
-        INTEGER ::  INST_Number
+        INTEGER(4) ::  INST_Number
 !       For MPI
-        INTEGER ::  COMM_NODES, MYID_NODES, COMM_LOAD
-        INTEGER ::   MYID, NPROCS, NSLAVES
-        INTEGER ::  ASS_IRECV
-        INTEGER ::  LBUFR
-        INTEGER ::  LBUFR_BYTES
-        INTEGER, DIMENSION(:), POINTER ::  BUFR
+        INTEGER(4) ::  COMM_NODES, MYID_NODES, COMM_LOAD
+        INTEGER(4) ::   MYID, NPROCS, NSLAVES
+        INTEGER(4) ::  ASS_IRECV
+        INTEGER(4) ::  LBUFR
+        INTEGER(4) ::  LBUFR_BYTES
+        INTEGER(4), DIMENSION(:), POINTER ::  BUFR
 !       IS is used for the factors + workspace for contrib. blocks
-        INTEGER, DIMENSION(:), POINTER :: IS
-!       IS1 (maxis1) contains working arrays computed 
+        INTEGER(4), DIMENSION(:), POINTER :: IS
+!       IS1 (maxis1) contains working arrays computed
 !       and used only during analysis
-        INTEGER, DIMENSION(:), POINTER :: IS1
+        INTEGER(4), DIMENSION(:), POINTER :: IS1
 !       For analysis/facto/solve phases
-        INTEGER ::  MAXIS1, Deficiency
-        INTEGER ::  KEEP(500)
+        INTEGER(4) ::  MAXIS1, Deficiency
+        INTEGER(4) ::  KEEP(500)
 !       The following data/arrays are computed during the analysis
 !       phase and used during the factorization and solve phases.
-        INTEGER ::  LNA
-        INTEGER ::  NBSA
-        INTEGER,POINTER,DIMENSION(:) :: STEP, NE_STEPS, ND_STEPS
-!  Info for pruning tree 
-        INTEGER,POINTER,DIMENSION(:) :: Step2node
+        INTEGER(4) ::  LNA
+        INTEGER(4) ::  NBSA
+        INTEGER(4),POINTER,DIMENSION(:) :: STEP, NE_STEPS, ND_STEPS
+!  Info for pruning tree
+        INTEGER(4),POINTER,DIMENSION(:) :: Step2node
 !  ---------------------
-        INTEGER,POINTER,DIMENSION(:) :: FRERE_STEPS, DAD_STEPS
-        INTEGER,POINTER,DIMENSION(:) :: FILS, FRTPTR, FRTELT
+        INTEGER(4),POINTER,DIMENSION(:) :: FRERE_STEPS, DAD_STEPS
+        INTEGER(4),POINTER,DIMENSION(:) :: FILS, FRTPTR, FRTELT
         INTEGER(8),POINTER,DIMENSION(:) :: PTRAR
-        INTEGER,POINTER,DIMENSION(:) :: NA, PROCNODE_STEPS
+        INTEGER(4),POINTER,DIMENSION(:) :: NA, PROCNODE_STEPS
 !       The two pointer arrays computed in facto and used by the solve
-!          (except the factors) are PTLUST_S and PTRFAC. 
-        INTEGER, DIMENSION(:), POINTER :: PTLUST_S
+!          (except the factors) are PTLUST_S and PTRFAC.
+        INTEGER(4), DIMENSION(:), POINTER :: PTLUST_S
         INTEGER(8), DIMENSION(:), POINTER :: PTRFAC
 !       main real working arrays for factorization/solve phases
-        COMPLEX, DIMENSION(:), POINTER :: S
+        COMPLEX(4), DIMENSION(:), POINTER :: S
 !       Information on mapping
-        INTEGER, DIMENSION(:), POINTER :: PROCNODE
-!       Input matrix ready for numerical assembly 
+        INTEGER(4), DIMENSION(:), POINTER :: PROCNODE
+!       Input matrix ready for numerical assembly
 !           -arrowhead format in case of assembled matrix
 !           -element format otherwise
-        INTEGER, DIMENSION(:), POINTER :: INTARR
-        COMPLEX, DIMENSION(:), POINTER :: DBLARR
+        INTEGER(4), DIMENSION(:), POINTER :: INTARR
+        COMPLEX(4), DIMENSION(:), POINTER :: DBLARR
 !       Element entry: internal data
-        INTEGER :: NELT_loc, LELTVAR
-        INTEGER, DIMENSION(:), POINTER :: ELTPROC
+        INTEGER(4) :: NELT_loc, LELTVAR
+        INTEGER(4), DIMENSION(:), POINTER :: ELTPROC
 !       Candidates and node partitionning
-        INTEGER, DIMENSION(:,:), POINTER :: CANDIDATES
-        INTEGER, DIMENSION(:),   POINTER :: ISTEP_TO_INIV2
-        INTEGER, DIMENSION(:),   POINTER :: FUTURE_NIV2
-        INTEGER, DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE 
-        LOGICAL, DIMENSION(:),   POINTER :: I_AM_CAND
+        INTEGER(4), DIMENSION(:,:), POINTER :: CANDIDATES
+        INTEGER(4), DIMENSION(:),   POINTER :: ISTEP_TO_INIV2
+        INTEGER(4), DIMENSION(:),   POINTER :: FUTURE_NIV2
+        INTEGER(4), DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE
+        LOGICAL(4), DIMENSION(:),   POINTER :: I_AM_CAND
 !       For heterogeneous architecture
-        INTEGER, DIMENSION(:), POINTER :: MEM_DIST
+        INTEGER(4), DIMENSION(:), POINTER :: MEM_DIST
 !       Compressed RHS
-        INTEGER, DIMENSION(:),   POINTER :: POSINRHSCOMP_ROW
-        LOGICAL  :: POSINRHSCOMP_COL_ALLOC, pad11
-        INTEGER, DIMENSION(:),   POINTER :: POSINRHSCOMP_COL
-        COMPLEX, DIMENSION(:),   POINTER :: RHSCOMP
+        INTEGER(4), DIMENSION(:),   POINTER :: POSINRHSCOMP_ROW
+        LOGICAL(4)  :: POSINRHSCOMP_COL_ALLOC, pad11
+        INTEGER(4), DIMENSION(:),   POINTER :: POSINRHSCOMP_COL
+        COMPLEX(4), DIMENSION(:),   POINTER :: RHSCOMP
 !       Info on the subtrees to be used during factorization
         DOUBLE PRECISION, DIMENSION(:), POINTER :: MEM_SUBTREE
         DOUBLE PRECISION, DIMENSION(:), POINTER :: COST_TRAV
-        INTEGER, DIMENSION(:),   POINTER :: MY_ROOT_SBTR
-        INTEGER, DIMENSION(:),   POINTER :: MY_FIRST_LEAF
-        INTEGER, DIMENSION(:),   POINTER :: MY_NB_LEAF
-        INTEGER, DIMENSION(:),   POINTER :: DEPTH_FIRST
-        INTEGER, DIMENSION(:),   POINTER :: DEPTH_FIRST_SEQ
-        INTEGER, DIMENSION(:),   POINTER :: SBTR_ID
-        INTEGER, DIMENSION(:),   POINTER :: SCHED_DEP
-        INTEGER, DIMENSION(:),   POINTER :: SCHED_GRP
-        INTEGER, DIMENSION(:),   POINTER :: SCHED_SBTR
-        INTEGER, DIMENSION(:),   POINTER :: CROIX_MANU
-        COMPLEX, DIMENSION(:), POINTER :: WK_USER
-        INTEGER :: NBSA_LOCAL
-        INTEGER :: LWK_USER
+        INTEGER(4), DIMENSION(:),   POINTER :: MY_ROOT_SBTR
+        INTEGER(4), DIMENSION(:),   POINTER :: MY_FIRST_LEAF
+        INTEGER(4), DIMENSION(:),   POINTER :: MY_NB_LEAF
+        INTEGER(4), DIMENSION(:),   POINTER :: DEPTH_FIRST
+        INTEGER(4), DIMENSION(:),   POINTER :: DEPTH_FIRST_SEQ
+        INTEGER(4), DIMENSION(:),   POINTER :: SBTR_ID
+        INTEGER(4), DIMENSION(:),   POINTER :: SCHED_DEP
+        INTEGER(4), DIMENSION(:),   POINTER :: SCHED_GRP
+        INTEGER(4), DIMENSION(:),   POINTER :: SCHED_SBTR
+        INTEGER(4), DIMENSION(:),   POINTER :: CROIX_MANU
+        COMPLEX(4), DIMENSION(:), POINTER :: WK_USER
+        INTEGER(4) :: NBSA_LOCAL
+        INTEGER(4) :: LWK_USER
 !    Internal control array
-        REAL ::  DKEEP(230)
+        REAL(4) ::  DKEEP(230)
 !    For simulating parallel out-of-core stack.
         DOUBLE PRECISION, DIMENSION(:),POINTER :: CB_SON_SIZE
 !    Instance number used/managed by the C/F77 interface
-        INTEGER ::  INSTANCE_NUMBER
+        INTEGER(4) ::  INSTANCE_NUMBER
 !    OOC management data that must persist from factorization to solve.
-        INTEGER ::  OOC_MAX_NB_NODES_FOR_ZONE
-        INTEGER, DIMENSION(:,:),   POINTER :: OOC_INODE_SEQUENCE
+        INTEGER(4) ::  OOC_MAX_NB_NODES_FOR_ZONE
+        INTEGER(4), DIMENSION(:,:),   POINTER :: OOC_INODE_SEQUENCE
         INTEGER(8),DIMENSION(:,:), POINTER :: OOC_SIZE_OF_BLOCK
         INTEGER(8), DIMENSION(:,:),   POINTER :: OOC_VADDR
-        INTEGER,DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES
-        INTEGER,DIMENSION(:), POINTER :: OOC_NB_FILES
-        INTEGER :: OOC_NB_FILE_TYPE,pad12
-        INTEGER,DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH
+        INTEGER(4),DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES
+        INTEGER(4),DIMENSION(:), POINTER :: OOC_NB_FILES
+        INTEGER(4) :: OOC_NB_FILE_TYPE,pad12
+        INTEGER(4),DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH
         CHARACTER,DIMENSION(:,:), POINTER :: OOC_FILE_NAMES  
 !    Indices of nul pivots
-        INTEGER,DIMENSION(:), POINTER :: PIVNUL_LIST
-!    Array needed to manage additionnal candidate processor 
-        INTEGER, DIMENSION(:,:), POINTER :: SUP_PROC, pad14
+        INTEGER(4),DIMENSION(:), POINTER :: PIVNUL_LIST
+!    Array needed to manage additionnal candidate processor
+        INTEGER(4), DIMENSION(:,:), POINTER :: SUP_PROC, pad14
 !    Lists of nodes where processors work. Built/used in solve phase.
-        INTEGER, DIMENSION(:), POINTER :: IPTR_WORKING, WORKING
+        INTEGER(4), DIMENSION(:), POINTER :: IPTR_WORKING, WORKING
 !    Root structure(internal)
         TYPE (CMUMPS_ROOT_STRUC) :: root
 !    Low-rank
-        INTEGER, POINTER, DIMENSION(:) :: LRGROUPS
-        INTEGER :: NBGRP,pad13
+        INTEGER(4), POINTER, DIMENSION(:) :: LRGROUPS
+        INTEGER(4) :: NBGRP,pad13
 !    Pointer encoding for FDM_F data
         CHARACTER(LEN=1), DIMENSION(:), POINTER :: FDM_F_ENCODING
 !    Pointer array encoding BLR factors pointers
         CHARACTER(LEN=1), DIMENSION(:), POINTER :: BLRARRAY_ENCODING
 !    Multicore
-        INTEGER :: LPOOL_AFTER_L0_OMP, LPOOL_BEFORE_L0_OMP
-        INTEGER :: L_PHYS_L0_OMP
-        INTEGER :: L_VIRT_L0_OMP                                    
-        INTEGER :: LL0_OMP_MAPPING,pad15
+        INTEGER(4) :: LPOOL_AFTER_L0_OMP, LPOOL_BEFORE_L0_OMP
+        INTEGER(4) :: L_PHYS_L0_OMP
+        INTEGER(4) :: L_VIRT_L0_OMP                                    
+        INTEGER(4) :: LL0_OMP_MAPPING,pad15
         INTEGER(8) :: THREAD_LA
 ! Pool before L0_OMP
-        INTEGER, DIMENSION(:), POINTER :: IPOOL_BEFORE_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: IPOOL_BEFORE_L0_OMP
 ! Pool after L0_OMP
-        INTEGER, DIMENSION(:), POINTER :: IPOOL_AFTER_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: IPOOL_AFTER_L0_OMP
 ! Subtrees
-        INTEGER, DIMENSION(:), POINTER :: PHYS_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: PHYS_L0_OMP
 ! Amalgamated subtrees
-        INTEGER, DIMENSION(:), POINTER :: VIRT_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: VIRT_L0_OMP
 ! From heaviest to lowest subtree
-        INTEGER, DIMENSION(:), POINTER :: PERM_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: PERM_L0_OMP
 ! To get leafs in global pool
-        INTEGER, DIMENSION(:), POINTER :: PTR_LEAFS_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: PTR_LEAFS_L0_OMP
 ! Mapping of the subtrees
-        INTEGER, DIMENSION(:), POINTER :: L0_OMP_MAPPING
+        INTEGER(4), DIMENSION(:), POINTER :: L0_OMP_MAPPING
 ! for RR on root
-        REAL, DIMENSION(:), POINTER :: SINGULAR_VALUES
-        INTEGER ::  NB_SINGULAR_VALUES
+        REAL(4), DIMENSION(:), POINTER :: SINGULAR_VALUES
+        INTEGER(4) ::  NB_SINGULAR_VALUES
 ! To know if OOC files are associated to a saved and so if they should be removed.
-        LOGICAL :: ASSOCIATED_OOC_FILES
+        LOGICAL(4) :: ASSOCIATED_OOC_FILES
       END TYPE CMUMPS_STRUC
diff -ruN MUMPS_5.1.2/include/dmumps_root.h mumps-5.1.2-aster7/include/dmumps_root.h
--- MUMPS_5.1.2/include/dmumps_root.h	2017-10-02 09:37:22.000000000 +0200
+++ mumps-5.1.2-aster7/include/dmumps_root.h	2020-10-23 11:16:48.000000000 +0200
@@ -12,17 +12,17 @@
 !
       TYPE DMUMPS_ROOT_STRUC
         SEQUENCE
-        INTEGER :: MBLOCK, NBLOCK, NPROW, NPCOL
-        INTEGER :: MYROW, MYCOL
-        INTEGER :: SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
-        INTEGER :: RHS_NLOC
-        INTEGER :: ROOT_SIZE, TOT_ROOT_SIZE
+        INTEGER(4) :: MBLOCK, NBLOCK, NPROW, NPCOL
+        INTEGER(4) :: MYROW, MYCOL
+        INTEGER(4) :: SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
+        INTEGER(4) :: RHS_NLOC
+        INTEGER(4) :: ROOT_SIZE, TOT_ROOT_SIZE
 !       descriptor for scalapack
-        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR
-        INTEGER :: CNTXT_BLACS, LPIV, rootpad0
-        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
-        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
-        INTEGER , DIMENSION(:), POINTER :: IPIV, rootpad1
+        INTEGER(4), DIMENSION( 9 ) :: DESCRIPTOR
+        INTEGER(4) :: CNTXT_BLACS, LPIV, rootpad0
+        INTEGER(4), DIMENSION(:), POINTER :: RG2L_ROW
+        INTEGER(4), DIMENSION(:), POINTER :: RG2L_COL
+        INTEGER(4) , DIMENSION(:), POINTER :: IPIV, rootpad1
 !       Centralized master of root
         DOUBLE PRECISION, DIMENSION(:), POINTER :: RHS_CNTR_MASTER_ROOT
 !       Used to access Schur easily from root structure
@@ -35,11 +35,11 @@
         DOUBLE PRECISION, DIMENSION(:,:), POINTER :: RHS_ROOT, rootpad
 !       for try_nullspace preprocessing constant only:
         DOUBLE PRECISION :: QR_RCOND, rootpad3
-        LOGICAL :: yes, gridinit_done
+        LOGICAL(4) :: yes, gridinit_done
 !       for SVD on root (#define try_null_space)
         DOUBLE PRECISION, DIMENSION(:,:), POINTER :: SVD_U, SVD_VT
 !       for RR on root (#define try_null_space)
         DOUBLE PRECISION, DIMENSION(:), POINTER :: SINGULAR_VALUES
-        INTEGER :: NB_SINGULAR_VALUES,rootpad4
+        INTEGER(4) :: NB_SINGULAR_VALUES
 !
       END TYPE DMUMPS_ROOT_STRUC
diff -ruN MUMPS_5.1.2/include/dmumps_struc.h mumps-5.1.2-aster7/include/dmumps_struc.h
--- MUMPS_5.1.2/include/dmumps_struc.h	2017-10-02 09:37:22.000000000 +0200
+++ mumps-5.1.2-aster7/include/dmumps_struc.h	2020-10-23 11:16:48.000000000 +0200
@@ -14,7 +14,7 @@
       TYPE DMUMPS_STRUC
         SEQUENCE
 !
-! This structure contains all parameters 
+! This structure contains all parameters
 ! for the interface to the user, plus internal
 ! information from the solver
 !
@@ -24,56 +24,56 @@
 !    -----------------
 !    MPI Communicator
 !    -----------------
-        INTEGER :: COMM
+        INTEGER(4) :: COMM
 !    ------------------
 !    Problem definition
 !    ------------------
-!    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite, 
+!    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite,
 !        SYM=2 general symmetric)
 !    Type of parallelism (PAR=1 host working, PAR=0 host not working)
-        INTEGER ::  SYM, PAR
-        INTEGER ::  JOB 
+        INTEGER(4) ::  SYM, PAR
+        INTEGER(4) ::  JOB
 !    --------------------
-!    Order of Input matrix 
+!    Order of Input matrix
 !    --------------------
-        INTEGER ::  N
+        INTEGER(4) ::  N
 !
 !    ----------------------------------------
 !    Assembled input matrix : User interface
 !    ----------------------------------------
-        INTEGER    :: NZ  ! Standard integer input + bwd. compat.
+        INTEGER(4) :: NZ  ! Standard integer input + bwd. compat.
         INTEGER(8) :: NNZ ! 64-bit integer input
         DOUBLE PRECISION, DIMENSION(:), POINTER :: A
-        INTEGER, DIMENSION(:), POINTER :: IRN, JCN
+        INTEGER(4), DIMENSION(:), POINTER :: IRN, JCN
         DOUBLE PRECISION, DIMENSION(:), POINTER :: COLSCA, ROWSCA, pad0
 !
 !       ------------------------------------
 !       Case of distributed assembled matrix
 !       matrix on entry:
 !       ------------------------------------
-        INTEGER    :: NZ_loc  ! Standard integer input + bwd. compat.
-        INTEGER    :: pad1
+        INTEGER(4)   :: NZ_loc  ! Standard integer input + bwd. compat.
+        INTEGER(4)   :: pad1
         INTEGER(8) :: NNZ_loc ! 64-bit integer input
-        INTEGER, DIMENSION(:), POINTER :: IRN_loc, JCN_loc
+        INTEGER(4), DIMENSION(:), POINTER :: IRN_loc, JCN_loc
         DOUBLE PRECISION, DIMENSION(:), POINTER :: A_loc, pad2
 !
 !    ----------------------------------------
 !    Unassembled input matrix: User interface
 !    ----------------------------------------
-        INTEGER :: NELT, pad3
-        INTEGER, DIMENSION(:), POINTER :: ELTPTR
-        INTEGER, DIMENSION(:), POINTER :: ELTVAR
+        INTEGER(4) :: NELT, pad3
+        INTEGER(4), DIMENSION(:), POINTER :: ELTPTR
+        INTEGER(4), DIMENSION(:), POINTER :: ELTVAR
         DOUBLE PRECISION, DIMENSION(:), POINTER :: A_ELT, pad4
 !
 !    ---------------------------------------------
-!    Symmetric permutation : 
+!    Symmetric permutation :
 !               PERM_IN if given by user (optional)
 !    ---------------------------------------------
-        INTEGER, DIMENSION(:), POINTER :: PERM_IN
+        INTEGER(4), DIMENSION(:), POINTER :: PERM_IN
 !
 !
 ! ******************
-! INPUT/OUTPUT data 
+! INPUT/OUTPUT data
 ! ******************
 !    --------------------------------------------------------
 !    RHS / SOL_loc
@@ -83,43 +83,43 @@
         DOUBLE PRECISION, DIMENSION(:), POINTER :: RHS, REDRHS
         DOUBLE PRECISION, DIMENSION(:), POINTER :: RHS_SPARSE
         DOUBLE PRECISION, DIMENSION(:), POINTER :: SOL_loc
-        INTEGER, DIMENSION(:), POINTER :: IRHS_SPARSE
-        INTEGER, DIMENSION(:), POINTER :: IRHS_PTR
-        INTEGER, DIMENSION(:), POINTER :: ISOL_loc
-        INTEGER ::  LRHS, NRHS, NZ_RHS, LSOL_loc, LREDRHS
-        INTEGER ::  pad5
+        INTEGER(4), DIMENSION(:), POINTER :: IRHS_SPARSE
+        INTEGER(4), DIMENSION(:), POINTER :: IRHS_PTR
+        INTEGER(4), DIMENSION(:), POINTER :: ISOL_loc
+        INTEGER(4) ::  LRHS, NRHS, NZ_RHS, LSOL_loc, LREDRHS
+        INTEGER(4) ::  pad5
 !    ----------------------------
 !    Control parameters,
 !    statistics and output data
 !    ---------------------------
-        INTEGER ::  ICNTL(40)
-        INTEGER ::  INFO(40) 
-        INTEGER :: INFOG(40)
+        INTEGER(4) ::  ICNTL(40)
+        INTEGER(4) ::  INFO(40)
+        INTEGER(4) :: INFOG(40)
         DOUBLE PRECISION ::  COST_SUBTREES
         DOUBLE PRECISION ::  CNTL(15)
         DOUBLE PRECISION ::  RINFO(40)
         DOUBLE PRECISION ::  RINFOG(40)
 !    ---------------------------------------------------------
 !    Permutations computed during analysis:
-!       SYM_PERM: Symmetric permutation 
+!       SYM_PERM: Symmetric permutation
 !       UNS_PERM: Column permutation (optional)
 !    ---------------------------------------------------------
-        INTEGER, DIMENSION(:), POINTER :: SYM_PERM, UNS_PERM
-! 
+        INTEGER(4), DIMENSION(:), POINTER :: SYM_PERM, UNS_PERM
+!
 !    -----
 !    Schur
 !    -----
-        INTEGER ::  NPROW, NPCOL, MBLOCK, NBLOCK
-        INTEGER ::  SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
-        INTEGER ::  SIZE_SCHUR
+        INTEGER(4) ::  NPROW, NPCOL, MBLOCK, NBLOCK
+        INTEGER(4) ::  SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
+        INTEGER(4) ::  SIZE_SCHUR
         DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR
         DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_CINTERFACE
-        INTEGER, DIMENSION(:), POINTER :: LISTVAR_SCHUR
+        INTEGER(4), DIMENSION(:), POINTER :: LISTVAR_SCHUR
 !    -------------------------------------
 !    Case of distributed matrix on entry:
 !    DMUMPS potentially provides mapping
 !    -------------------------------------
-        INTEGER, DIMENSION(:), POINTER :: MAPPING
+        INTEGER(4), DIMENSION(:), POINTER :: MAPPING
 !    --------------
 !    Version number
 !    --------------
@@ -145,133 +145,133 @@
 ! INTERNAL Working data
 ! *********************
         INTEGER(8) :: KEEP8(150), MAX_SURF_MASTER
-        INTEGER ::  INST_Number
+        INTEGER(4) ::  INST_Number
 !       For MPI
-        INTEGER ::  COMM_NODES, MYID_NODES, COMM_LOAD
-        INTEGER ::   MYID, NPROCS, NSLAVES
-        INTEGER ::  ASS_IRECV
-        INTEGER ::  LBUFR
-        INTEGER ::  LBUFR_BYTES
-        INTEGER, DIMENSION(:), POINTER ::  BUFR
+        INTEGER(4) ::  COMM_NODES, MYID_NODES, COMM_LOAD
+        INTEGER(4) ::   MYID, NPROCS, NSLAVES
+        INTEGER(4) ::  ASS_IRECV
+        INTEGER(4) ::  LBUFR
+        INTEGER(4) ::  LBUFR_BYTES
+        INTEGER(4), DIMENSION(:), POINTER ::  BUFR
 !       IS is used for the factors + workspace for contrib. blocks
-        INTEGER, DIMENSION(:), POINTER :: IS
-!       IS1 (maxis1) contains working arrays computed 
+        INTEGER(4), DIMENSION(:), POINTER :: IS
+!       IS1 (maxis1) contains working arrays computed
 !       and used only during analysis
-        INTEGER, DIMENSION(:), POINTER :: IS1
+        INTEGER(4), DIMENSION(:), POINTER :: IS1
 !       For analysis/facto/solve phases
-        INTEGER ::  MAXIS1, Deficiency
-        INTEGER ::  KEEP(500)
+        INTEGER(4) ::  MAXIS1, Deficiency
+        INTEGER(4) ::  KEEP(500)
 !       The following data/arrays are computed during the analysis
 !       phase and used during the factorization and solve phases.
-        INTEGER ::  LNA
-        INTEGER ::  NBSA
-        INTEGER,POINTER,DIMENSION(:) :: STEP, NE_STEPS, ND_STEPS
-!  Info for pruning tree 
-        INTEGER,POINTER,DIMENSION(:) :: Step2node
+        INTEGER(4) ::  LNA
+        INTEGER(4) ::  NBSA
+        INTEGER(4),POINTER,DIMENSION(:) :: STEP, NE_STEPS, ND_STEPS
+!  Info for pruning tree
+        INTEGER(4),POINTER,DIMENSION(:) :: Step2node
 !  ---------------------
-        INTEGER,POINTER,DIMENSION(:) :: FRERE_STEPS, DAD_STEPS
-        INTEGER,POINTER,DIMENSION(:) :: FILS, FRTPTR, FRTELT
+        INTEGER(4),POINTER,DIMENSION(:) :: FRERE_STEPS, DAD_STEPS
+        INTEGER(4),POINTER,DIMENSION(:) :: FILS, FRTPTR, FRTELT
         INTEGER(8),POINTER,DIMENSION(:) :: PTRAR
-        INTEGER,POINTER,DIMENSION(:) :: NA, PROCNODE_STEPS
+        INTEGER(4),POINTER,DIMENSION(:) :: NA, PROCNODE_STEPS
 !       The two pointer arrays computed in facto and used by the solve
-!          (except the factors) are PTLUST_S and PTRFAC. 
-        INTEGER, DIMENSION(:), POINTER :: PTLUST_S
+!          (except the factors) are PTLUST_S and PTRFAC.
+        INTEGER(4), DIMENSION(:), POINTER :: PTLUST_S
         INTEGER(8), DIMENSION(:), POINTER :: PTRFAC
 !       main real working arrays for factorization/solve phases
         DOUBLE PRECISION, DIMENSION(:), POINTER :: S
 !       Information on mapping
-        INTEGER, DIMENSION(:), POINTER :: PROCNODE
-!       Input matrix ready for numerical assembly 
+        INTEGER(4), DIMENSION(:), POINTER :: PROCNODE
+!       Input matrix ready for numerical assembly
 !           -arrowhead format in case of assembled matrix
 !           -element format otherwise
-        INTEGER, DIMENSION(:), POINTER :: INTARR
+        INTEGER(4), DIMENSION(:), POINTER :: INTARR
         DOUBLE PRECISION, DIMENSION(:), POINTER :: DBLARR
 !       Element entry: internal data
-        INTEGER :: NELT_loc, LELTVAR
-        INTEGER, DIMENSION(:), POINTER :: ELTPROC
+        INTEGER(4) :: NELT_loc, LELTVAR
+        INTEGER(4), DIMENSION(:), POINTER :: ELTPROC
 !       Candidates and node partitionning
-        INTEGER, DIMENSION(:,:), POINTER :: CANDIDATES
-        INTEGER, DIMENSION(:),   POINTER :: ISTEP_TO_INIV2
-        INTEGER, DIMENSION(:),   POINTER :: FUTURE_NIV2
-        INTEGER, DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE 
-        LOGICAL, DIMENSION(:),   POINTER :: I_AM_CAND
+        INTEGER(4), DIMENSION(:,:), POINTER :: CANDIDATES
+        INTEGER(4), DIMENSION(:),   POINTER :: ISTEP_TO_INIV2
+        INTEGER(4), DIMENSION(:),   POINTER :: FUTURE_NIV2
+        INTEGER(4), DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE
+        LOGICAL(4), DIMENSION(:),   POINTER :: I_AM_CAND
 !       For heterogeneous architecture
-        INTEGER, DIMENSION(:), POINTER :: MEM_DIST
+        INTEGER(4), DIMENSION(:), POINTER :: MEM_DIST
 !       Compressed RHS
-        INTEGER, DIMENSION(:),   POINTER :: POSINRHSCOMP_ROW
-        LOGICAL  :: POSINRHSCOMP_COL_ALLOC, pad11
-        INTEGER, DIMENSION(:),   POINTER :: POSINRHSCOMP_COL
+        INTEGER(4), DIMENSION(:),   POINTER :: POSINRHSCOMP_ROW
+        LOGICAL(4)  :: POSINRHSCOMP_COL_ALLOC, pad11
+        INTEGER(4), DIMENSION(:),   POINTER :: POSINRHSCOMP_COL
         DOUBLE PRECISION, DIMENSION(:),   POINTER :: RHSCOMP
 !       Info on the subtrees to be used during factorization
         DOUBLE PRECISION, DIMENSION(:), POINTER :: MEM_SUBTREE
         DOUBLE PRECISION, DIMENSION(:), POINTER :: COST_TRAV
-        INTEGER, DIMENSION(:),   POINTER :: MY_ROOT_SBTR
-        INTEGER, DIMENSION(:),   POINTER :: MY_FIRST_LEAF
-        INTEGER, DIMENSION(:),   POINTER :: MY_NB_LEAF
-        INTEGER, DIMENSION(:),   POINTER :: DEPTH_FIRST
-        INTEGER, DIMENSION(:),   POINTER :: DEPTH_FIRST_SEQ
-        INTEGER, DIMENSION(:),   POINTER :: SBTR_ID
-        INTEGER, DIMENSION(:),   POINTER :: SCHED_DEP
-        INTEGER, DIMENSION(:),   POINTER :: SCHED_GRP
-        INTEGER, DIMENSION(:),   POINTER :: SCHED_SBTR
-        INTEGER, DIMENSION(:),   POINTER :: CROIX_MANU
+        INTEGER(4), DIMENSION(:),   POINTER :: MY_ROOT_SBTR
+        INTEGER(4), DIMENSION(:),   POINTER :: MY_FIRST_LEAF
+        INTEGER(4), DIMENSION(:),   POINTER :: MY_NB_LEAF
+        INTEGER(4), DIMENSION(:),   POINTER :: DEPTH_FIRST
+        INTEGER(4), DIMENSION(:),   POINTER :: DEPTH_FIRST_SEQ
+        INTEGER(4), DIMENSION(:),   POINTER :: SBTR_ID
+        INTEGER(4), DIMENSION(:),   POINTER :: SCHED_DEP
+        INTEGER(4), DIMENSION(:),   POINTER :: SCHED_GRP
+        INTEGER(4), DIMENSION(:),   POINTER :: SCHED_SBTR
+        INTEGER(4), DIMENSION(:),   POINTER :: CROIX_MANU
         DOUBLE PRECISION, DIMENSION(:), POINTER :: WK_USER
-        INTEGER :: NBSA_LOCAL
-        INTEGER :: LWK_USER
+        INTEGER(4) :: NBSA_LOCAL
+        INTEGER(4) :: LWK_USER
 !    Internal control array
         DOUBLE PRECISION ::  DKEEP(230)
 !    For simulating parallel out-of-core stack.
         DOUBLE PRECISION, DIMENSION(:),POINTER :: CB_SON_SIZE
 !    Instance number used/managed by the C/F77 interface
-        INTEGER ::  INSTANCE_NUMBER
+        INTEGER(4) ::  INSTANCE_NUMBER
 !    OOC management data that must persist from factorization to solve.
-        INTEGER ::  OOC_MAX_NB_NODES_FOR_ZONE
-        INTEGER, DIMENSION(:,:),   POINTER :: OOC_INODE_SEQUENCE
+        INTEGER(4) ::  OOC_MAX_NB_NODES_FOR_ZONE
+        INTEGER(4), DIMENSION(:,:),   POINTER :: OOC_INODE_SEQUENCE
         INTEGER(8),DIMENSION(:,:), POINTER :: OOC_SIZE_OF_BLOCK
         INTEGER(8), DIMENSION(:,:),   POINTER :: OOC_VADDR
-        INTEGER,DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES
-        INTEGER,DIMENSION(:), POINTER :: OOC_NB_FILES
-        INTEGER :: OOC_NB_FILE_TYPE,pad12
-        INTEGER,DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH
+        INTEGER(4),DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES
+        INTEGER(4),DIMENSION(:), POINTER :: OOC_NB_FILES
+        INTEGER(4) :: OOC_NB_FILE_TYPE,pad12
+        INTEGER(4),DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH
         CHARACTER,DIMENSION(:,:), POINTER :: OOC_FILE_NAMES  
 !    Indices of nul pivots
-        INTEGER,DIMENSION(:), POINTER :: PIVNUL_LIST
-!    Array needed to manage additionnal candidate processor 
-        INTEGER, DIMENSION(:,:), POINTER :: SUP_PROC, pad14
+        INTEGER(4),DIMENSION(:), POINTER :: PIVNUL_LIST
+!    Array needed to manage additionnal candidate processor
+        INTEGER(4), DIMENSION(:,:), POINTER :: SUP_PROC, pad14
 !    Lists of nodes where processors work. Built/used in solve phase.
-        INTEGER, DIMENSION(:), POINTER :: IPTR_WORKING, WORKING
+        INTEGER(4), DIMENSION(:), POINTER :: IPTR_WORKING, WORKING
 !    Root structure(internal)
         TYPE (DMUMPS_ROOT_STRUC) :: root
 !    Low-rank
-        INTEGER, POINTER, DIMENSION(:) :: LRGROUPS
-        INTEGER :: NBGRP,pad13
+        INTEGER(4), POINTER, DIMENSION(:) :: LRGROUPS
+        INTEGER(4) :: NBGRP,pad13
 !    Pointer encoding for FDM_F data
         CHARACTER(LEN=1), DIMENSION(:), POINTER :: FDM_F_ENCODING
 !    Pointer array encoding BLR factors pointers
         CHARACTER(LEN=1), DIMENSION(:), POINTER :: BLRARRAY_ENCODING
 !    Multicore
-        INTEGER :: LPOOL_AFTER_L0_OMP, LPOOL_BEFORE_L0_OMP
-        INTEGER :: L_PHYS_L0_OMP
-        INTEGER :: L_VIRT_L0_OMP                                    
-        INTEGER :: LL0_OMP_MAPPING,pad15
+        INTEGER(4) :: LPOOL_AFTER_L0_OMP, LPOOL_BEFORE_L0_OMP
+        INTEGER(4) :: L_PHYS_L0_OMP
+        INTEGER(4) :: L_VIRT_L0_OMP                                    
+        INTEGER(4) :: LL0_OMP_MAPPING,pad15
         INTEGER(8) :: THREAD_LA
 ! Pool before L0_OMP
-        INTEGER, DIMENSION(:), POINTER :: IPOOL_BEFORE_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: IPOOL_BEFORE_L0_OMP
 ! Pool after L0_OMP
-        INTEGER, DIMENSION(:), POINTER :: IPOOL_AFTER_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: IPOOL_AFTER_L0_OMP
 ! Subtrees
-        INTEGER, DIMENSION(:), POINTER :: PHYS_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: PHYS_L0_OMP
 ! Amalgamated subtrees
-        INTEGER, DIMENSION(:), POINTER :: VIRT_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: VIRT_L0_OMP
 ! From heaviest to lowest subtree
-        INTEGER, DIMENSION(:), POINTER :: PERM_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: PERM_L0_OMP
 ! To get leafs in global pool
-        INTEGER, DIMENSION(:), POINTER :: PTR_LEAFS_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: PTR_LEAFS_L0_OMP
 ! Mapping of the subtrees
-        INTEGER, DIMENSION(:), POINTER :: L0_OMP_MAPPING
+        INTEGER(4), DIMENSION(:), POINTER :: L0_OMP_MAPPING
 ! for RR on root
         DOUBLE PRECISION, DIMENSION(:), POINTER :: SINGULAR_VALUES
-        INTEGER ::  NB_SINGULAR_VALUES
+        INTEGER(4) ::  NB_SINGULAR_VALUES
 ! To know if OOC files are associated to a saved and so if they should be removed.
-        LOGICAL :: ASSOCIATED_OOC_FILES
+        LOGICAL(4) :: ASSOCIATED_OOC_FILES
       END TYPE DMUMPS_STRUC
diff -ruN MUMPS_5.1.2/include/smumps_root.h mumps-5.1.2-aster7/include/smumps_root.h
--- MUMPS_5.1.2/include/smumps_root.h	2017-10-02 09:37:22.000000000 +0200
+++ mumps-5.1.2-aster7/include/smumps_root.h	2020-10-23 11:16:48.000000000 +0200
@@ -12,34 +12,34 @@
 !
       TYPE SMUMPS_ROOT_STRUC
         SEQUENCE
-        INTEGER :: MBLOCK, NBLOCK, NPROW, NPCOL
-        INTEGER :: MYROW, MYCOL
-        INTEGER :: SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
-        INTEGER :: RHS_NLOC
-        INTEGER :: ROOT_SIZE, TOT_ROOT_SIZE
+        INTEGER(4) :: MBLOCK, NBLOCK, NPROW, NPCOL
+        INTEGER(4) :: MYROW, MYCOL
+        INTEGER(4) :: SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
+        INTEGER(4) :: RHS_NLOC
+        INTEGER(4) :: ROOT_SIZE, TOT_ROOT_SIZE
 !       descriptor for scalapack
-        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR
-        INTEGER :: CNTXT_BLACS, LPIV, rootpad0
-        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
-        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
-        INTEGER , DIMENSION(:), POINTER :: IPIV, rootpad1
+        INTEGER(4), DIMENSION( 9 ) :: DESCRIPTOR
+        INTEGER(4) :: CNTXT_BLACS, LPIV, rootpad0
+        INTEGER(4), DIMENSION(:), POINTER :: RG2L_ROW
+        INTEGER(4), DIMENSION(:), POINTER :: RG2L_COL
+        INTEGER(4) , DIMENSION(:), POINTER :: IPIV, rootpad1
 !       Centralized master of root
-        REAL, DIMENSION(:), POINTER :: RHS_CNTR_MASTER_ROOT
+        REAL(4), DIMENSION(:), POINTER :: RHS_CNTR_MASTER_ROOT
 !       Used to access Schur easily from root structure
-        REAL, DIMENSION(:), POINTER :: SCHUR_POINTER
+        REAL(4), DIMENSION(:), POINTER :: SCHUR_POINTER
 !       for try_null_space preprocessing constant only:
-        REAL, DIMENSION(:), POINTER :: QR_TAU, rootpad2
+        REAL(4), DIMENSION(:), POINTER :: QR_TAU, rootpad2
 !       Fwd in facto: 
 !           case of scalapack root: to store RHS in 2D block cyclic
 !           format compatible with root distribution
-        REAL, DIMENSION(:,:), POINTER :: RHS_ROOT, rootpad
+        REAL(4), DIMENSION(:,:), POINTER :: RHS_ROOT, rootpad
 !       for try_nullspace preprocessing constant only:
-        REAL :: QR_RCOND, rootpad3
-        LOGICAL :: yes, gridinit_done
+        REAL(4) :: QR_RCOND, rootpad3
+        LOGICAL(4) :: yes, gridinit_done
 !       for SVD on root (#define try_null_space)
-        REAL, DIMENSION(:,:), POINTER :: SVD_U, SVD_VT
+        REAL(4), DIMENSION(:,:), POINTER :: SVD_U, SVD_VT
 !       for RR on root (#define try_null_space)
-        REAL, DIMENSION(:), POINTER :: SINGULAR_VALUES
-        INTEGER :: NB_SINGULAR_VALUES,rootpad4
+        REAL(4), DIMENSION(:), POINTER :: SINGULAR_VALUES
+        INTEGER(4) :: NB_SINGULAR_VALUES,rootpad4
 !
       END TYPE SMUMPS_ROOT_STRUC
diff -ruN MUMPS_5.1.2/include/smumps_struc.h mumps-5.1.2-aster7/include/smumps_struc.h
--- MUMPS_5.1.2/include/smumps_struc.h	2017-10-02 09:37:22.000000000 +0200
+++ mumps-5.1.2-aster7/include/smumps_struc.h	2020-10-23 11:16:48.000000000 +0200
@@ -14,7 +14,7 @@
       TYPE SMUMPS_STRUC
         SEQUENCE
 !
-! This structure contains all parameters 
+! This structure contains all parameters
 ! for the interface to the user, plus internal
 ! information from the solver
 !
@@ -24,102 +24,102 @@
 !    -----------------
 !    MPI Communicator
 !    -----------------
-        INTEGER :: COMM
+        INTEGER(4) :: COMM
 !    ------------------
 !    Problem definition
 !    ------------------
-!    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite, 
+!    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite,
 !        SYM=2 general symmetric)
 !    Type of parallelism (PAR=1 host working, PAR=0 host not working)
-        INTEGER ::  SYM, PAR
-        INTEGER ::  JOB 
+        INTEGER(4) ::  SYM, PAR
+        INTEGER(4) ::  JOB
 !    --------------------
-!    Order of Input matrix 
+!    Order of Input matrix
 !    --------------------
-        INTEGER ::  N
+        INTEGER(4) ::  N
 !
 !    ----------------------------------------
 !    Assembled input matrix : User interface
 !    ----------------------------------------
-        INTEGER    :: NZ  ! Standard integer input + bwd. compat.
+        INTEGER(4) :: NZ  ! Standard integer input + bwd. compat.
         INTEGER(8) :: NNZ ! 64-bit integer input
-        REAL, DIMENSION(:), POINTER :: A
-        INTEGER, DIMENSION(:), POINTER :: IRN, JCN
-        REAL, DIMENSION(:), POINTER :: COLSCA, ROWSCA, pad0
+        REAL(4), DIMENSION(:), POINTER :: A
+        INTEGER(4), DIMENSION(:), POINTER :: IRN, JCN
+        REAL(4), DIMENSION(:), POINTER :: COLSCA, ROWSCA, pad0
 !
 !       ------------------------------------
 !       Case of distributed assembled matrix
 !       matrix on entry:
 !       ------------------------------------
-        INTEGER    :: NZ_loc  ! Standard integer input + bwd. compat.
-        INTEGER    :: pad1
+        INTEGER(4) :: NZ_loc  ! Standard integer input + bwd. compat.
+        INTEGER(4) :: pad1
         INTEGER(8) :: NNZ_loc ! 64-bit integer input
-        INTEGER, DIMENSION(:), POINTER :: IRN_loc, JCN_loc
-        REAL, DIMENSION(:), POINTER :: A_loc, pad2
+        INTEGER(4), DIMENSION(:), POINTER :: IRN_loc, JCN_loc
+        REAL(4), DIMENSION(:), POINTER :: A_loc, pad2
 !
 !    ----------------------------------------
 !    Unassembled input matrix: User interface
 !    ----------------------------------------
-        INTEGER :: NELT, pad3
-        INTEGER, DIMENSION(:), POINTER :: ELTPTR
-        INTEGER, DIMENSION(:), POINTER :: ELTVAR
-        REAL, DIMENSION(:), POINTER :: A_ELT, pad4
+        INTEGER(4) :: NELT, pad3
+        INTEGER(4), DIMENSION(:), POINTER :: ELTPTR
+        INTEGER(4), DIMENSION(:), POINTER :: ELTVAR
+        REAL(4), DIMENSION(:), POINTER :: A_ELT, pad4
 !
 !    ---------------------------------------------
-!    Symmetric permutation : 
+!    Symmetric permutation :
 !               PERM_IN if given by user (optional)
 !    ---------------------------------------------
-        INTEGER, DIMENSION(:), POINTER :: PERM_IN
+        INTEGER(4), DIMENSION(:), POINTER :: PERM_IN
 !
 !
 ! ******************
-! INPUT/OUTPUT data 
+! INPUT/OUTPUT data
 ! ******************
 !    --------------------------------------------------------
 !    RHS / SOL_loc
 !    -------------
 !       right-hand side and solution
 !    -------------------------------------------------------
-        REAL, DIMENSION(:), POINTER :: RHS, REDRHS
-        REAL, DIMENSION(:), POINTER :: RHS_SPARSE
-        REAL, DIMENSION(:), POINTER :: SOL_loc
-        INTEGER, DIMENSION(:), POINTER :: IRHS_SPARSE
-        INTEGER, DIMENSION(:), POINTER :: IRHS_PTR
-        INTEGER, DIMENSION(:), POINTER :: ISOL_loc
-        INTEGER ::  LRHS, NRHS, NZ_RHS, LSOL_loc, LREDRHS
-        INTEGER ::  pad5
+        REAL(4), DIMENSION(:), POINTER :: RHS, REDRHS
+        REAL(4), DIMENSION(:), POINTER :: RHS_SPARSE
+        REAL(4), DIMENSION(:), POINTER :: SOL_loc
+        INTEGER(4), DIMENSION(:), POINTER :: IRHS_SPARSE
+        INTEGER(4), DIMENSION(:), POINTER :: IRHS_PTR
+        INTEGER(4), DIMENSION(:), POINTER :: ISOL_loc
+        INTEGER(4) ::  LRHS, NRHS, NZ_RHS, LSOL_loc, LREDRHS
+        INTEGER(4) ::  pad5
 !    ----------------------------
 !    Control parameters,
 !    statistics and output data
 !    ---------------------------
-        INTEGER ::  ICNTL(40)
-        INTEGER ::  INFO(40) 
-        INTEGER :: INFOG(40)
-        REAL ::  COST_SUBTREES
-        REAL ::  CNTL(15)
-        REAL ::  RINFO(40)
-        REAL ::  RINFOG(40)
+        INTEGER(4) ::  ICNTL(40)
+        INTEGER(4) ::  INFO(40)
+        INTEGER(4) :: INFOG(40)
+        REAL(4) ::  COST_SUBTREES
+        REAL(4) ::  CNTL(15)
+        REAL(4) ::  RINFO(40)
+        REAL(4) ::  RINFOG(40)
 !    ---------------------------------------------------------
 !    Permutations computed during analysis:
-!       SYM_PERM: Symmetric permutation 
+!       SYM_PERM: Symmetric permutation
 !       UNS_PERM: Column permutation (optional)
 !    ---------------------------------------------------------
-        INTEGER, DIMENSION(:), POINTER :: SYM_PERM, UNS_PERM
-! 
+        INTEGER(4), DIMENSION(:), POINTER :: SYM_PERM, UNS_PERM
+!
 !    -----
 !    Schur
 !    -----
-        INTEGER ::  NPROW, NPCOL, MBLOCK, NBLOCK
-        INTEGER ::  SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
-        INTEGER ::  SIZE_SCHUR
-        REAL, DIMENSION(:), POINTER :: SCHUR
-        REAL, DIMENSION(:), POINTER :: SCHUR_CINTERFACE
-        INTEGER, DIMENSION(:), POINTER :: LISTVAR_SCHUR
+        INTEGER(4) ::  NPROW, NPCOL, MBLOCK, NBLOCK
+        INTEGER(4) ::  SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
+        INTEGER(4) ::  SIZE_SCHUR
+        REAL(4), DIMENSION(:), POINTER :: SCHUR
+        REAL(4), DIMENSION(:), POINTER :: SCHUR_CINTERFACE
+        INTEGER(4), DIMENSION(:), POINTER :: LISTVAR_SCHUR
 !    -------------------------------------
 !    Case of distributed matrix on entry:
 !    SMUMPS potentially provides mapping
 !    -------------------------------------
-        INTEGER, DIMENSION(:), POINTER :: MAPPING
+        INTEGER(4), DIMENSION(:), POINTER :: MAPPING
 !    --------------
 !    Version number
 !    --------------
@@ -145,133 +145,133 @@
 ! INTERNAL Working data
 ! *********************
         INTEGER(8) :: KEEP8(150), MAX_SURF_MASTER
-        INTEGER ::  INST_Number
+        INTEGER(4) ::  INST_Number
 !       For MPI
-        INTEGER ::  COMM_NODES, MYID_NODES, COMM_LOAD
-        INTEGER ::   MYID, NPROCS, NSLAVES
-        INTEGER ::  ASS_IRECV
-        INTEGER ::  LBUFR
-        INTEGER ::  LBUFR_BYTES
-        INTEGER, DIMENSION(:), POINTER ::  BUFR
+        INTEGER(4) ::  COMM_NODES, MYID_NODES, COMM_LOAD
+        INTEGER(4) ::   MYID, NPROCS, NSLAVES
+        INTEGER(4) ::  ASS_IRECV
+        INTEGER(4) ::  LBUFR
+        INTEGER(4) ::  LBUFR_BYTES
+        INTEGER(4), DIMENSION(:), POINTER ::  BUFR
 !       IS is used for the factors + workspace for contrib. blocks
-        INTEGER, DIMENSION(:), POINTER :: IS
-!       IS1 (maxis1) contains working arrays computed 
+        INTEGER(4), DIMENSION(:), POINTER :: IS
+!       IS1 (maxis1) contains working arrays computed
 !       and used only during analysis
-        INTEGER, DIMENSION(:), POINTER :: IS1
+        INTEGER(4), DIMENSION(:), POINTER :: IS1
 !       For analysis/facto/solve phases
-        INTEGER ::  MAXIS1, Deficiency
-        INTEGER ::  KEEP(500)
+        INTEGER(4) ::  MAXIS1, Deficiency
+        INTEGER(4) ::  KEEP(500)
 !       The following data/arrays are computed during the analysis
 !       phase and used during the factorization and solve phases.
-        INTEGER ::  LNA
-        INTEGER ::  NBSA
-        INTEGER,POINTER,DIMENSION(:) :: STEP, NE_STEPS, ND_STEPS
-!  Info for pruning tree 
-        INTEGER,POINTER,DIMENSION(:) :: Step2node
+        INTEGER(4) ::  LNA
+        INTEGER(4) ::  NBSA
+        INTEGER(4),POINTER,DIMENSION(:) :: STEP, NE_STEPS, ND_STEPS
+!  Info for pruning tree
+        INTEGER(4),POINTER,DIMENSION(:) :: Step2node
 !  ---------------------
-        INTEGER,POINTER,DIMENSION(:) :: FRERE_STEPS, DAD_STEPS
-        INTEGER,POINTER,DIMENSION(:) :: FILS, FRTPTR, FRTELT
+        INTEGER(4),POINTER,DIMENSION(:) :: FRERE_STEPS, DAD_STEPS
+        INTEGER(4),POINTER,DIMENSION(:) :: FILS, FRTPTR, FRTELT
         INTEGER(8),POINTER,DIMENSION(:) :: PTRAR
-        INTEGER,POINTER,DIMENSION(:) :: NA, PROCNODE_STEPS
+        INTEGER(4),POINTER,DIMENSION(:) :: NA, PROCNODE_STEPS
 !       The two pointer arrays computed in facto and used by the solve
-!          (except the factors) are PTLUST_S and PTRFAC. 
-        INTEGER, DIMENSION(:), POINTER :: PTLUST_S
+!          (except the factors) are PTLUST_S and PTRFAC.
+        INTEGER(4), DIMENSION(:), POINTER :: PTLUST_S
         INTEGER(8), DIMENSION(:), POINTER :: PTRFAC
 !       main real working arrays for factorization/solve phases
-        REAL, DIMENSION(:), POINTER :: S
+        REAL(4), DIMENSION(:), POINTER :: S
 !       Information on mapping
-        INTEGER, DIMENSION(:), POINTER :: PROCNODE
-!       Input matrix ready for numerical assembly 
+        INTEGER(4), DIMENSION(:), POINTER :: PROCNODE
+!       Input matrix ready for numerical assembly
 !           -arrowhead format in case of assembled matrix
 !           -element format otherwise
-        INTEGER, DIMENSION(:), POINTER :: INTARR
-        REAL, DIMENSION(:), POINTER :: DBLARR
+        INTEGER(4), DIMENSION(:), POINTER :: INTARR
+        REAL(4), DIMENSION(:), POINTER :: DBLARR
 !       Element entry: internal data
-        INTEGER :: NELT_loc, LELTVAR
-        INTEGER, DIMENSION(:), POINTER :: ELTPROC
+        INTEGER(4) :: NELT_loc, LELTVAR
+        INTEGER(4), DIMENSION(:), POINTER :: ELTPROC
 !       Candidates and node partitionning
-        INTEGER, DIMENSION(:,:), POINTER :: CANDIDATES
-        INTEGER, DIMENSION(:),   POINTER :: ISTEP_TO_INIV2
-        INTEGER, DIMENSION(:),   POINTER :: FUTURE_NIV2
-        INTEGER, DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE 
-        LOGICAL, DIMENSION(:),   POINTER :: I_AM_CAND
+        INTEGER(4), DIMENSION(:,:), POINTER :: CANDIDATES
+        INTEGER(4), DIMENSION(:),   POINTER :: ISTEP_TO_INIV2
+        INTEGER(4), DIMENSION(:),   POINTER :: FUTURE_NIV2
+        INTEGER(4), DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE
+        LOGICAL(4), DIMENSION(:),   POINTER :: I_AM_CAND
 !       For heterogeneous architecture
-        INTEGER, DIMENSION(:), POINTER :: MEM_DIST
+        INTEGER(4), DIMENSION(:), POINTER :: MEM_DIST
 !       Compressed RHS
-        INTEGER, DIMENSION(:),   POINTER :: POSINRHSCOMP_ROW
-        LOGICAL  :: POSINRHSCOMP_COL_ALLOC, pad11
-        INTEGER, DIMENSION(:),   POINTER :: POSINRHSCOMP_COL
-        REAL, DIMENSION(:),   POINTER :: RHSCOMP
+        INTEGER(4), DIMENSION(:),   POINTER :: POSINRHSCOMP_ROW
+        LOGICAL(4)  :: POSINRHSCOMP_COL_ALLOC, pad11
+        INTEGER(4), DIMENSION(:),   POINTER :: POSINRHSCOMP_COL
+        REAL(4), DIMENSION(:),   POINTER :: RHSCOMP
 !       Info on the subtrees to be used during factorization
         DOUBLE PRECISION, DIMENSION(:), POINTER :: MEM_SUBTREE
         DOUBLE PRECISION, DIMENSION(:), POINTER :: COST_TRAV
-        INTEGER, DIMENSION(:),   POINTER :: MY_ROOT_SBTR
-        INTEGER, DIMENSION(:),   POINTER :: MY_FIRST_LEAF
-        INTEGER, DIMENSION(:),   POINTER :: MY_NB_LEAF
-        INTEGER, DIMENSION(:),   POINTER :: DEPTH_FIRST
-        INTEGER, DIMENSION(:),   POINTER :: DEPTH_FIRST_SEQ
-        INTEGER, DIMENSION(:),   POINTER :: SBTR_ID
-        INTEGER, DIMENSION(:),   POINTER :: SCHED_DEP
-        INTEGER, DIMENSION(:),   POINTER :: SCHED_GRP
-        INTEGER, DIMENSION(:),   POINTER :: SCHED_SBTR
-        INTEGER, DIMENSION(:),   POINTER :: CROIX_MANU
-        REAL, DIMENSION(:), POINTER :: WK_USER
-        INTEGER :: NBSA_LOCAL
-        INTEGER :: LWK_USER
+        INTEGER(4), DIMENSION(:),   POINTER :: MY_ROOT_SBTR
+        INTEGER(4), DIMENSION(:),   POINTER :: MY_FIRST_LEAF
+        INTEGER(4), DIMENSION(:),   POINTER :: MY_NB_LEAF
+        INTEGER(4), DIMENSION(:),   POINTER :: DEPTH_FIRST
+        INTEGER(4), DIMENSION(:),   POINTER :: DEPTH_FIRST_SEQ
+        INTEGER(4), DIMENSION(:),   POINTER :: SBTR_ID
+        INTEGER(4), DIMENSION(:),   POINTER :: SCHED_DEP
+        INTEGER(4), DIMENSION(:),   POINTER :: SCHED_GRP
+        INTEGER(4), DIMENSION(:),   POINTER :: SCHED_SBTR
+        INTEGER(4), DIMENSION(:),   POINTER :: CROIX_MANU
+        REAL(4), DIMENSION(:), POINTER :: WK_USER
+        INTEGER(4) :: NBSA_LOCAL
+        INTEGER(4) :: LWK_USER
 !    Internal control array
-        REAL ::  DKEEP(230)
+        REAL(4) ::  DKEEP(230)
 !    For simulating parallel out-of-core stack.
         DOUBLE PRECISION, DIMENSION(:),POINTER :: CB_SON_SIZE
 !    Instance number used/managed by the C/F77 interface
-        INTEGER ::  INSTANCE_NUMBER
+        INTEGER(4) ::  INSTANCE_NUMBER
 !    OOC management data that must persist from factorization to solve.
-        INTEGER ::  OOC_MAX_NB_NODES_FOR_ZONE
-        INTEGER, DIMENSION(:,:),   POINTER :: OOC_INODE_SEQUENCE
+        INTEGER(4) ::  OOC_MAX_NB_NODES_FOR_ZONE
+        INTEGER(4), DIMENSION(:,:),   POINTER :: OOC_INODE_SEQUENCE
         INTEGER(8),DIMENSION(:,:), POINTER :: OOC_SIZE_OF_BLOCK
         INTEGER(8), DIMENSION(:,:),   POINTER :: OOC_VADDR
-        INTEGER,DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES
-        INTEGER,DIMENSION(:), POINTER :: OOC_NB_FILES
-        INTEGER :: OOC_NB_FILE_TYPE,pad12
-        INTEGER,DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH
+        INTEGER(4),DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES
+        INTEGER(4),DIMENSION(:), POINTER :: OOC_NB_FILES
+        INTEGER(4) :: OOC_NB_FILE_TYPE,pad12
+        INTEGER(4),DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH
         CHARACTER,DIMENSION(:,:), POINTER :: OOC_FILE_NAMES  
 !    Indices of nul pivots
-        INTEGER,DIMENSION(:), POINTER :: PIVNUL_LIST
-!    Array needed to manage additionnal candidate processor 
-        INTEGER, DIMENSION(:,:), POINTER :: SUP_PROC, pad14
+        INTEGER(4),DIMENSION(:), POINTER :: PIVNUL_LIST
+!    Array needed to manage additionnal candidate processor
+        INTEGER(4), DIMENSION(:,:), POINTER :: SUP_PROC, pad14
 !    Lists of nodes where processors work. Built/used in solve phase.
-        INTEGER, DIMENSION(:), POINTER :: IPTR_WORKING, WORKING
+        INTEGER(4), DIMENSION(:), POINTER :: IPTR_WORKING, WORKING
 !    Root structure(internal)
         TYPE (SMUMPS_ROOT_STRUC) :: root
 !    Low-rank
-        INTEGER, POINTER, DIMENSION(:) :: LRGROUPS
-        INTEGER :: NBGRP,pad13
+        INTEGER(4), POINTER, DIMENSION(:) :: LRGROUPS
+        INTEGER(4) :: NBGRP,pad13
 !    Pointer encoding for FDM_F data
         CHARACTER(LEN=1), DIMENSION(:), POINTER :: FDM_F_ENCODING
 !    Pointer array encoding BLR factors pointers
         CHARACTER(LEN=1), DIMENSION(:), POINTER :: BLRARRAY_ENCODING
 !    Multicore
-        INTEGER :: LPOOL_AFTER_L0_OMP, LPOOL_BEFORE_L0_OMP
-        INTEGER :: L_PHYS_L0_OMP
-        INTEGER :: L_VIRT_L0_OMP                                    
-        INTEGER :: LL0_OMP_MAPPING,pad15
+        INTEGER(4) :: LPOOL_AFTER_L0_OMP, LPOOL_BEFORE_L0_OMP
+        INTEGER(4) :: L_PHYS_L0_OMP
+        INTEGER(4) :: L_VIRT_L0_OMP                                    
+        INTEGER(4) :: LL0_OMP_MAPPING,pad15
         INTEGER(8) :: THREAD_LA
 ! Pool before L0_OMP
-        INTEGER, DIMENSION(:), POINTER :: IPOOL_BEFORE_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: IPOOL_BEFORE_L0_OMP
 ! Pool after L0_OMP
-        INTEGER, DIMENSION(:), POINTER :: IPOOL_AFTER_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: IPOOL_AFTER_L0_OMP
 ! Subtrees
-        INTEGER, DIMENSION(:), POINTER :: PHYS_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: PHYS_L0_OMP
 ! Amalgamated subtrees
-        INTEGER, DIMENSION(:), POINTER :: VIRT_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: VIRT_L0_OMP
 ! From heaviest to lowest subtree
-        INTEGER, DIMENSION(:), POINTER :: PERM_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: PERM_L0_OMP
 ! To get leafs in global pool
-        INTEGER, DIMENSION(:), POINTER :: PTR_LEAFS_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: PTR_LEAFS_L0_OMP
 ! Mapping of the subtrees
-        INTEGER, DIMENSION(:), POINTER :: L0_OMP_MAPPING
+        INTEGER(4), DIMENSION(:), POINTER :: L0_OMP_MAPPING
 ! for RR on root
-        REAL, DIMENSION(:), POINTER :: SINGULAR_VALUES
-        INTEGER ::  NB_SINGULAR_VALUES
+        REAL(4), DIMENSION(:), POINTER :: SINGULAR_VALUES
+        INTEGER(4) ::  NB_SINGULAR_VALUES
 ! To know if OOC files are associated to a saved and so if they should be removed.
-        LOGICAL :: ASSOCIATED_OOC_FILES
+        LOGICAL(4) :: ASSOCIATED_OOC_FILES
       END TYPE SMUMPS_STRUC
diff -ruN MUMPS_5.1.2/include/zmumps_root.h mumps-5.1.2-aster7/include/zmumps_root.h
--- MUMPS_5.1.2/include/zmumps_root.h	2017-10-02 09:37:22.000000000 +0200
+++ mumps-5.1.2-aster7/include/zmumps_root.h	2020-10-23 11:16:48.000000000 +0200
@@ -12,17 +12,17 @@
 !
       TYPE ZMUMPS_ROOT_STRUC
         SEQUENCE
-        INTEGER :: MBLOCK, NBLOCK, NPROW, NPCOL
-        INTEGER :: MYROW, MYCOL
-        INTEGER :: SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
-        INTEGER :: RHS_NLOC
-        INTEGER :: ROOT_SIZE, TOT_ROOT_SIZE
+        INTEGER(4) :: MBLOCK, NBLOCK, NPROW, NPCOL
+        INTEGER(4) :: MYROW, MYCOL
+        INTEGER(4) :: SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
+        INTEGER(4) :: RHS_NLOC
+        INTEGER(4) :: ROOT_SIZE, TOT_ROOT_SIZE
 !       descriptor for scalapack
-        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR
-        INTEGER :: CNTXT_BLACS, LPIV, rootpad0
-        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
-        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
-        INTEGER , DIMENSION(:), POINTER :: IPIV, rootpad1
+        INTEGER(4), DIMENSION( 9 ) :: DESCRIPTOR
+        INTEGER(4) :: CNTXT_BLACS, LPIV, rootpad0
+        INTEGER(4), DIMENSION(:), POINTER :: RG2L_ROW
+        INTEGER(4), DIMENSION(:), POINTER :: RG2L_COL
+        INTEGER(4) , DIMENSION(:), POINTER :: IPIV, rootpad1
 !       Centralized master of root
         COMPLEX(kind=8), DIMENSION(:), POINTER :: RHS_CNTR_MASTER_ROOT
 !       Used to access Schur easily from root structure
@@ -35,11 +35,11 @@
         COMPLEX(kind=8), DIMENSION(:,:), POINTER :: RHS_ROOT, rootpad
 !       for try_nullspace preprocessing constant only:
         DOUBLE PRECISION :: QR_RCOND, rootpad3
-        LOGICAL :: yes, gridinit_done
+        LOGICAL(4) :: yes, gridinit_done
 !       for SVD on root (#define try_null_space)
         COMPLEX(kind=8), DIMENSION(:,:), POINTER :: SVD_U, SVD_VT
 !       for RR on root (#define try_null_space)
         DOUBLE PRECISION, DIMENSION(:), POINTER :: SINGULAR_VALUES
-        INTEGER :: NB_SINGULAR_VALUES,rootpad4
+        INTEGER(4) :: NB_SINGULAR_VALUES,rootpad4
 !
       END TYPE ZMUMPS_ROOT_STRUC
diff -ruN MUMPS_5.1.2/include/zmumps_struc.h mumps-5.1.2-aster7/include/zmumps_struc.h
--- MUMPS_5.1.2/include/zmumps_struc.h	2017-10-02 09:37:22.000000000 +0200
+++ mumps-5.1.2-aster7/include/zmumps_struc.h	2020-10-23 11:16:48.000000000 +0200
@@ -14,7 +14,7 @@
       TYPE ZMUMPS_STRUC
         SEQUENCE
 !
-! This structure contains all parameters 
+! This structure contains all parameters
 ! for the interface to the user, plus internal
 ! information from the solver
 !
@@ -24,56 +24,56 @@
 !    -----------------
 !    MPI Communicator
 !    -----------------
-        INTEGER :: COMM
+        INTEGER(4) :: COMM
 !    ------------------
 !    Problem definition
 !    ------------------
-!    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite, 
+!    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite,
 !        SYM=2 general symmetric)
 !    Type of parallelism (PAR=1 host working, PAR=0 host not working)
-        INTEGER ::  SYM, PAR
-        INTEGER ::  JOB 
+        INTEGER(4) ::  SYM, PAR
+        INTEGER(4) ::  JOB
 !    --------------------
-!    Order of Input matrix 
+!    Order of Input matrix
 !    --------------------
-        INTEGER ::  N
+        INTEGER(4) ::  N
 !
 !    ----------------------------------------
 !    Assembled input matrix : User interface
 !    ----------------------------------------
-        INTEGER    :: NZ  ! Standard integer input + bwd. compat.
+        INTEGER(4) :: NZ  ! Standard integer input + bwd. compat.
         INTEGER(8) :: NNZ ! 64-bit integer input
         COMPLEX(kind=8), DIMENSION(:), POINTER :: A
-        INTEGER, DIMENSION(:), POINTER :: IRN, JCN
+        INTEGER(4), DIMENSION(:), POINTER :: IRN, JCN
         DOUBLE PRECISION, DIMENSION(:), POINTER :: COLSCA, ROWSCA, pad0
 !
 !       ------------------------------------
 !       Case of distributed assembled matrix
 !       matrix on entry:
 !       ------------------------------------
-        INTEGER    :: NZ_loc  ! Standard integer input + bwd. compat.
-        INTEGER    :: pad1
+        INTEGER(4) :: NZ_loc  ! Standard integer input + bwd. compat.
+        INTEGER(4) :: pad1
         INTEGER(8) :: NNZ_loc ! 64-bit integer input
-        INTEGER, DIMENSION(:), POINTER :: IRN_loc, JCN_loc
+        INTEGER(4), DIMENSION(:), POINTER :: IRN_loc, JCN_loc
         COMPLEX(kind=8), DIMENSION(:), POINTER :: A_loc, pad2
 !
 !    ----------------------------------------
 !    Unassembled input matrix: User interface
 !    ----------------------------------------
-        INTEGER :: NELT, pad3
-        INTEGER, DIMENSION(:), POINTER :: ELTPTR
-        INTEGER, DIMENSION(:), POINTER :: ELTVAR
+        INTEGER(4) :: NELT, pad3
+        INTEGER(4), DIMENSION(:), POINTER :: ELTPTR
+        INTEGER(4), DIMENSION(:), POINTER :: ELTVAR
         COMPLEX(kind=8), DIMENSION(:), POINTER :: A_ELT, pad4
 !
 !    ---------------------------------------------
-!    Symmetric permutation : 
+!    Symmetric permutation :
 !               PERM_IN if given by user (optional)
 !    ---------------------------------------------
-        INTEGER, DIMENSION(:), POINTER :: PERM_IN
+        INTEGER(4), DIMENSION(:), POINTER :: PERM_IN
 !
 !
 ! ******************
-! INPUT/OUTPUT data 
+! INPUT/OUTPUT data
 ! ******************
 !    --------------------------------------------------------
 !    RHS / SOL_loc
@@ -83,43 +83,43 @@
         COMPLEX(kind=8), DIMENSION(:), POINTER :: RHS, REDRHS
         COMPLEX(kind=8), DIMENSION(:), POINTER :: RHS_SPARSE
         COMPLEX(kind=8), DIMENSION(:), POINTER :: SOL_loc
-        INTEGER, DIMENSION(:), POINTER :: IRHS_SPARSE
-        INTEGER, DIMENSION(:), POINTER :: IRHS_PTR
-        INTEGER, DIMENSION(:), POINTER :: ISOL_loc
-        INTEGER ::  LRHS, NRHS, NZ_RHS, LSOL_loc, LREDRHS
-        INTEGER ::  pad5
+        INTEGER(4), DIMENSION(:), POINTER :: IRHS_SPARSE
+        INTEGER(4), DIMENSION(:), POINTER :: IRHS_PTR
+        INTEGER(4), DIMENSION(:), POINTER :: ISOL_loc
+        INTEGER(4) ::  LRHS, NRHS, NZ_RHS, LSOL_loc, LREDRHS
+        INTEGER(4) ::  pad5
 !    ----------------------------
 !    Control parameters,
 !    statistics and output data
 !    ---------------------------
-        INTEGER ::  ICNTL(40)
-        INTEGER ::  INFO(40) 
-        INTEGER :: INFOG(40)
+        INTEGER(4) ::  ICNTL(40)
+        INTEGER(4) ::  INFO(40)
+        INTEGER(4) :: INFOG(40)
         DOUBLE PRECISION ::  COST_SUBTREES
         DOUBLE PRECISION ::  CNTL(15)
         DOUBLE PRECISION ::  RINFO(40)
         DOUBLE PRECISION ::  RINFOG(40)
 !    ---------------------------------------------------------
 !    Permutations computed during analysis:
-!       SYM_PERM: Symmetric permutation 
+!       SYM_PERM: Symmetric permutation
 !       UNS_PERM: Column permutation (optional)
 !    ---------------------------------------------------------
-        INTEGER, DIMENSION(:), POINTER :: SYM_PERM, UNS_PERM
-! 
+        INTEGER(4), DIMENSION(:), POINTER :: SYM_PERM, UNS_PERM
+!
 !    -----
 !    Schur
 !    -----
-        INTEGER ::  NPROW, NPCOL, MBLOCK, NBLOCK
-        INTEGER ::  SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
-        INTEGER ::  SIZE_SCHUR
+        INTEGER(4) ::  NPROW, NPCOL, MBLOCK, NBLOCK
+        INTEGER(4) ::  SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
+        INTEGER(4) ::  SIZE_SCHUR
         COMPLEX(kind=8), DIMENSION(:), POINTER :: SCHUR
         COMPLEX(kind=8), DIMENSION(:), POINTER :: SCHUR_CINTERFACE
-        INTEGER, DIMENSION(:), POINTER :: LISTVAR_SCHUR
+        INTEGER(4), DIMENSION(:), POINTER :: LISTVAR_SCHUR
 !    -------------------------------------
 !    Case of distributed matrix on entry:
 !    ZMUMPS potentially provides mapping
 !    -------------------------------------
-        INTEGER, DIMENSION(:), POINTER :: MAPPING
+        INTEGER(4), DIMENSION(:), POINTER :: MAPPING
 !    --------------
 !    Version number
 !    --------------
@@ -145,133 +145,133 @@
 ! INTERNAL Working data
 ! *********************
         INTEGER(8) :: KEEP8(150), MAX_SURF_MASTER
-        INTEGER ::  INST_Number
+        INTEGER(4) ::  INST_Number
 !       For MPI
-        INTEGER ::  COMM_NODES, MYID_NODES, COMM_LOAD
-        INTEGER ::   MYID, NPROCS, NSLAVES
-        INTEGER ::  ASS_IRECV
-        INTEGER ::  LBUFR
-        INTEGER ::  LBUFR_BYTES
-        INTEGER, DIMENSION(:), POINTER ::  BUFR
+        INTEGER(4) ::  COMM_NODES, MYID_NODES, COMM_LOAD
+        INTEGER(4) ::   MYID, NPROCS, NSLAVES
+        INTEGER(4) ::  ASS_IRECV
+        INTEGER(4) ::  LBUFR
+        INTEGER(4) ::  LBUFR_BYTES
+        INTEGER(4), DIMENSION(:), POINTER ::  BUFR
 !       IS is used for the factors + workspace for contrib. blocks
-        INTEGER, DIMENSION(:), POINTER :: IS
-!       IS1 (maxis1) contains working arrays computed 
+        INTEGER(4), DIMENSION(:), POINTER :: IS
+!       IS1 (maxis1) contains working arrays computed
 !       and used only during analysis
-        INTEGER, DIMENSION(:), POINTER :: IS1
+        INTEGER(4), DIMENSION(:), POINTER :: IS1
 !       For analysis/facto/solve phases
-        INTEGER ::  MAXIS1, Deficiency
-        INTEGER ::  KEEP(500)
+        INTEGER(4) ::  MAXIS1, Deficiency
+        INTEGER(4) ::  KEEP(500)
 !       The following data/arrays are computed during the analysis
 !       phase and used during the factorization and solve phases.
-        INTEGER ::  LNA
-        INTEGER ::  NBSA
-        INTEGER,POINTER,DIMENSION(:) :: STEP, NE_STEPS, ND_STEPS
-!  Info for pruning tree 
-        INTEGER,POINTER,DIMENSION(:) :: Step2node
+        INTEGER(4) ::  LNA
+        INTEGER(4) ::  NBSA
+        INTEGER(4),POINTER,DIMENSION(:) :: STEP, NE_STEPS, ND_STEPS
+!  Info for pruning tree
+        INTEGER(4),POINTER,DIMENSION(:) :: Step2node
 !  ---------------------
-        INTEGER,POINTER,DIMENSION(:) :: FRERE_STEPS, DAD_STEPS
-        INTEGER,POINTER,DIMENSION(:) :: FILS, FRTPTR, FRTELT
+        INTEGER(4),POINTER,DIMENSION(:) :: FRERE_STEPS, DAD_STEPS
+        INTEGER(4),POINTER,DIMENSION(:) :: FILS, FRTPTR, FRTELT
         INTEGER(8),POINTER,DIMENSION(:) :: PTRAR
-        INTEGER,POINTER,DIMENSION(:) :: NA, PROCNODE_STEPS
+        INTEGER(4),POINTER,DIMENSION(:) :: NA, PROCNODE_STEPS
 !       The two pointer arrays computed in facto and used by the solve
-!          (except the factors) are PTLUST_S and PTRFAC. 
-        INTEGER, DIMENSION(:), POINTER :: PTLUST_S
+!          (except the factors) are PTLUST_S and PTRFAC.
+        INTEGER(4), DIMENSION(:), POINTER :: PTLUST_S
         INTEGER(8), DIMENSION(:), POINTER :: PTRFAC
 !       main real working arrays for factorization/solve phases
         COMPLEX(kind=8), DIMENSION(:), POINTER :: S
 !       Information on mapping
-        INTEGER, DIMENSION(:), POINTER :: PROCNODE
-!       Input matrix ready for numerical assembly 
+        INTEGER(4), DIMENSION(:), POINTER :: PROCNODE
+!       Input matrix ready for numerical assembly
 !           -arrowhead format in case of assembled matrix
 !           -element format otherwise
-        INTEGER, DIMENSION(:), POINTER :: INTARR
+        INTEGER(4), DIMENSION(:), POINTER :: INTARR
         COMPLEX(kind=8), DIMENSION(:), POINTER :: DBLARR
 !       Element entry: internal data
-        INTEGER :: NELT_loc, LELTVAR
-        INTEGER, DIMENSION(:), POINTER :: ELTPROC
+        INTEGER(4) :: NELT_loc, LELTVAR
+        INTEGER(4), DIMENSION(:), POINTER :: ELTPROC
 !       Candidates and node partitionning
-        INTEGER, DIMENSION(:,:), POINTER :: CANDIDATES
-        INTEGER, DIMENSION(:),   POINTER :: ISTEP_TO_INIV2
-        INTEGER, DIMENSION(:),   POINTER :: FUTURE_NIV2
-        INTEGER, DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE 
-        LOGICAL, DIMENSION(:),   POINTER :: I_AM_CAND
+        INTEGER(4), DIMENSION(:,:), POINTER :: CANDIDATES
+        INTEGER(4), DIMENSION(:),   POINTER :: ISTEP_TO_INIV2
+        INTEGER(4), DIMENSION(:),   POINTER :: FUTURE_NIV2
+        INTEGER(4), DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE
+        LOGICAL(4), DIMENSION(:),   POINTER :: I_AM_CAND
 !       For heterogeneous architecture
-        INTEGER, DIMENSION(:), POINTER :: MEM_DIST
+        INTEGER(4), DIMENSION(:), POINTER :: MEM_DIST
 !       Compressed RHS
-        INTEGER, DIMENSION(:),   POINTER :: POSINRHSCOMP_ROW
-        LOGICAL  :: POSINRHSCOMP_COL_ALLOC, pad11
-        INTEGER, DIMENSION(:),   POINTER :: POSINRHSCOMP_COL
+        INTEGER(4), DIMENSION(:),   POINTER :: POSINRHSCOMP_ROW
+        LOGICAL(4)  :: POSINRHSCOMP_COL_ALLOC, pad11
+        INTEGER(4), DIMENSION(:),   POINTER :: POSINRHSCOMP_COL
         COMPLEX(kind=8), DIMENSION(:),   POINTER :: RHSCOMP
 !       Info on the subtrees to be used during factorization
         DOUBLE PRECISION, DIMENSION(:), POINTER :: MEM_SUBTREE
         DOUBLE PRECISION, DIMENSION(:), POINTER :: COST_TRAV
-        INTEGER, DIMENSION(:),   POINTER :: MY_ROOT_SBTR
-        INTEGER, DIMENSION(:),   POINTER :: MY_FIRST_LEAF
-        INTEGER, DIMENSION(:),   POINTER :: MY_NB_LEAF
-        INTEGER, DIMENSION(:),   POINTER :: DEPTH_FIRST
-        INTEGER, DIMENSION(:),   POINTER :: DEPTH_FIRST_SEQ
-        INTEGER, DIMENSION(:),   POINTER :: SBTR_ID
-        INTEGER, DIMENSION(:),   POINTER :: SCHED_DEP
-        INTEGER, DIMENSION(:),   POINTER :: SCHED_GRP
-        INTEGER, DIMENSION(:),   POINTER :: SCHED_SBTR
-        INTEGER, DIMENSION(:),   POINTER :: CROIX_MANU
+        INTEGER(4), DIMENSION(:),   POINTER :: MY_ROOT_SBTR
+        INTEGER(4), DIMENSION(:),   POINTER :: MY_FIRST_LEAF
+        INTEGER(4), DIMENSION(:),   POINTER :: MY_NB_LEAF
+        INTEGER(4), DIMENSION(:),   POINTER :: DEPTH_FIRST
+        INTEGER(4), DIMENSION(:),   POINTER :: DEPTH_FIRST_SEQ
+        INTEGER(4), DIMENSION(:),   POINTER :: SBTR_ID
+        INTEGER(4), DIMENSION(:),   POINTER :: SCHED_DEP
+        INTEGER(4), DIMENSION(:),   POINTER :: SCHED_GRP
+        INTEGER(4), DIMENSION(:),   POINTER :: SCHED_SBTR
+        INTEGER(4), DIMENSION(:),   POINTER :: CROIX_MANU
         COMPLEX(kind=8), DIMENSION(:), POINTER :: WK_USER
-        INTEGER :: NBSA_LOCAL
-        INTEGER :: LWK_USER
+        INTEGER(4) :: NBSA_LOCAL
+        INTEGER(4) :: LWK_USER
 !    Internal control array
         DOUBLE PRECISION ::  DKEEP(230)
 !    For simulating parallel out-of-core stack.
         DOUBLE PRECISION, DIMENSION(:),POINTER :: CB_SON_SIZE
 !    Instance number used/managed by the C/F77 interface
-        INTEGER ::  INSTANCE_NUMBER
+        INTEGER(4) ::  INSTANCE_NUMBER
 !    OOC management data that must persist from factorization to solve.
-        INTEGER ::  OOC_MAX_NB_NODES_FOR_ZONE
-        INTEGER, DIMENSION(:,:),   POINTER :: OOC_INODE_SEQUENCE
+        INTEGER(4) ::  OOC_MAX_NB_NODES_FOR_ZONE
+        INTEGER(4), DIMENSION(:,:),   POINTER :: OOC_INODE_SEQUENCE
         INTEGER(8),DIMENSION(:,:), POINTER :: OOC_SIZE_OF_BLOCK
         INTEGER(8), DIMENSION(:,:),   POINTER :: OOC_VADDR
-        INTEGER,DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES
-        INTEGER,DIMENSION(:), POINTER :: OOC_NB_FILES
-        INTEGER :: OOC_NB_FILE_TYPE,pad12
-        INTEGER,DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH
+        INTEGER(4),DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES
+        INTEGER(4),DIMENSION(:), POINTER :: OOC_NB_FILES
+        INTEGER(4) :: OOC_NB_FILE_TYPE,pad12
+        INTEGER(4),DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH
         CHARACTER,DIMENSION(:,:), POINTER :: OOC_FILE_NAMES  
 !    Indices of nul pivots
-        INTEGER,DIMENSION(:), POINTER :: PIVNUL_LIST
-!    Array needed to manage additionnal candidate processor 
-        INTEGER, DIMENSION(:,:), POINTER :: SUP_PROC, pad14
+        INTEGER(4),DIMENSION(:), POINTER :: PIVNUL_LIST
+!    Array needed to manage additionnal candidate processor
+        INTEGER(4), DIMENSION(:,:), POINTER :: SUP_PROC, pad14
 !    Lists of nodes where processors work. Built/used in solve phase.
-        INTEGER, DIMENSION(:), POINTER :: IPTR_WORKING, WORKING
+        INTEGER(4), DIMENSION(:), POINTER :: IPTR_WORKING, WORKING
 !    Root structure(internal)
         TYPE (ZMUMPS_ROOT_STRUC) :: root
 !    Low-rank
-        INTEGER, POINTER, DIMENSION(:) :: LRGROUPS
-        INTEGER :: NBGRP,pad13
+        INTEGER(4), POINTER, DIMENSION(:) :: LRGROUPS
+        INTEGER(4) :: NBGRP,pad13
 !    Pointer encoding for FDM_F data
         CHARACTER(LEN=1), DIMENSION(:), POINTER :: FDM_F_ENCODING
 !    Pointer array encoding BLR factors pointers
         CHARACTER(LEN=1), DIMENSION(:), POINTER :: BLRARRAY_ENCODING
 !    Multicore
-        INTEGER :: LPOOL_AFTER_L0_OMP, LPOOL_BEFORE_L0_OMP
-        INTEGER :: L_PHYS_L0_OMP
-        INTEGER :: L_VIRT_L0_OMP                                    
-        INTEGER :: LL0_OMP_MAPPING,pad15
+        INTEGER(4) :: LPOOL_AFTER_L0_OMP, LPOOL_BEFORE_L0_OMP
+        INTEGER(4) :: L_PHYS_L0_OMP
+        INTEGER(4) :: L_VIRT_L0_OMP                                    
+        INTEGER(4) :: LL0_OMP_MAPPING,pad15
         INTEGER(8) :: THREAD_LA
 ! Pool before L0_OMP
-        INTEGER, DIMENSION(:), POINTER :: IPOOL_BEFORE_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: IPOOL_BEFORE_L0_OMP
 ! Pool after L0_OMP
-        INTEGER, DIMENSION(:), POINTER :: IPOOL_AFTER_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: IPOOL_AFTER_L0_OMP
 ! Subtrees
-        INTEGER, DIMENSION(:), POINTER :: PHYS_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: PHYS_L0_OMP
 ! Amalgamated subtrees
-        INTEGER, DIMENSION(:), POINTER :: VIRT_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: VIRT_L0_OMP
 ! From heaviest to lowest subtree
-        INTEGER, DIMENSION(:), POINTER :: PERM_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: PERM_L0_OMP
 ! To get leafs in global pool
-        INTEGER, DIMENSION(:), POINTER :: PTR_LEAFS_L0_OMP
+        INTEGER(4), DIMENSION(:), POINTER :: PTR_LEAFS_L0_OMP
 ! Mapping of the subtrees
-        INTEGER, DIMENSION(:), POINTER :: L0_OMP_MAPPING
+        INTEGER(4), DIMENSION(:), POINTER :: L0_OMP_MAPPING
 ! for RR on root
         DOUBLE PRECISION, DIMENSION(:), POINTER :: SINGULAR_VALUES
-        INTEGER ::  NB_SINGULAR_VALUES
+        INTEGER(4) ::  NB_SINGULAR_VALUES
 ! To know if OOC files are associated to a saved and so if they should be removed.
-        LOGICAL :: ASSOCIATED_OOC_FILES
+        LOGICAL(4) :: ASSOCIATED_OOC_FILES
       END TYPE ZMUMPS_STRUC
diff -ruN MUMPS_5.1.2/lib/.place_holder mumps-5.1.2-aster7/lib/.place_holder
--- MUMPS_5.1.2/lib/.place_holder	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/lib/.place_holder	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1 @@
+place holder
diff -ruN MUMPS_5.1.2/libseq/mpif.h mumps-5.1.2-aster7/libseq/mpif.h
--- MUMPS_5.1.2/libseq/mpif.h	2017-10-02 09:37:04.000000000 +0200
+++ mumps-5.1.2-aster7/libseq/mpif.h	2020-10-23 11:16:48.000000000 +0200
@@ -13,41 +13,41 @@
 !
 !      Dummy mpif.h file including symbols used by MUMPS.
 !
-      INTEGER MPI_2DOUBLE_PRECISION
-      INTEGER MPI_2INTEGER
-      INTEGER MPI_2REAL
-      INTEGER MPI_ANY_SOURCE
-      INTEGER MPI_ANY_TAG
-      INTEGER MPI_BYTE
-      INTEGER MPI_CHARACTER
-      INTEGER MPI_COMM_NULL
-      INTEGER MPI_COMM_WORLD
-      INTEGER MPI_COMPLEX
-      INTEGER MPI_DOUBLE_COMPLEX
-      INTEGER MPI_DOUBLE_PRECISION
-      INTEGER MPI_INTEGER
-      INTEGER MPI_LOGICAL
-      INTEGER MPI_MAX
-      INTEGER MPI_MAX_PROCESSOR_NAME
-      INTEGER MPI_MAXLOC
-      INTEGER MPI_MIN
-      INTEGER MPI_MINLOC
-      INTEGER MPI_PACKED
-      INTEGER MPI_PROD
-      INTEGER MPI_REAL
-      INTEGER MPI_REPLACE
-      INTEGER MPI_REQUEST_NULL
-      INTEGER MPI_SOURCE
-      INTEGER MPI_STATUS_SIZE
-      INTEGER MPI_SUM
-      INTEGER MPI_TAG
-      INTEGER MPI_UNDEFINED
-      INTEGER MPI_WTIME_IS_GLOBAL
-      INTEGER MPI_LOR
-      INTEGER MPI_LAND
-      INTEGER MPI_INTEGER8
-      INTEGER MPI_REAL8
-      INTEGER MPI_BSEND_OVERHEAD
+      INTEGER(4) MPI_2DOUBLE_PRECISION
+      INTEGER(4) MPI_2INTEGER
+      INTEGER(4) MPI_2REAL
+      INTEGER(4) MPI_ANY_SOURCE
+      INTEGER(4) MPI_ANY_TAG
+      INTEGER(4) MPI_BYTE
+      INTEGER(4) MPI_CHARACTER
+      INTEGER(4) MPI_COMM_NULL
+      INTEGER(4) MPI_COMM_WORLD
+      INTEGER(4) MPI_COMPLEX
+      INTEGER(4) MPI_DOUBLE_COMPLEX
+      INTEGER(4) MPI_DOUBLE_PRECISION
+      INTEGER(4) MPI_INTEGER
+      INTEGER(4) MPI_LOGICAL
+      INTEGER(4) MPI_MAX
+      INTEGER(4) MPI_MAX_PROCESSOR_NAME
+      INTEGER(4) MPI_MAXLOC
+      INTEGER(4) MPI_MIN
+      INTEGER(4) MPI_MINLOC
+      INTEGER(4) MPI_PACKED
+      INTEGER(4) MPI_PROD
+      INTEGER(4) MPI_REAL
+      INTEGER(4) MPI_REPLACE
+      INTEGER(4) MPI_REQUEST_NULL
+      INTEGER(4) MPI_SOURCE
+      INTEGER(4) MPI_STATUS_SIZE
+      INTEGER(4) MPI_SUM
+      INTEGER(4) MPI_TAG
+      INTEGER(4) MPI_UNDEFINED
+      INTEGER(4) MPI_WTIME_IS_GLOBAL
+      INTEGER(4) MPI_LOR
+      INTEGER(4) MPI_LAND
+      INTEGER(4) MPI_INTEGER8
+      INTEGER(4) MPI_REAL8
+      INTEGER(4) MPI_BSEND_OVERHEAD
       PARAMETER (MPI_2DOUBLE_PRECISION=1)
       PARAMETER (MPI_2INTEGER=2)
       PARAMETER (MPI_2REAL=3)
diff -ruN MUMPS_5.1.2/Makefile.inc.in mumps-5.1.2-aster7/Makefile.inc.in
--- MUMPS_5.1.2/Makefile.inc.in	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/Makefile.inc.in	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,95 @@
+#
+# This file is part of MUMPS 5.0.1, changed to be configured by waf scripts
+# provided by the Code_Aster team.
+#
+#Begin orderings
+
+# NOTE that PORD is distributed within MUMPS by default. If you would like to
+# use other orderings, you need to obtain the corresponding package and modify
+# the variables below accordingly.
+# For example, to have Metis available within MUMPS:
+#          1/ download Metis and compile it
+#          2/ uncomment (suppress # in first column) lines
+#             starting with LMETISDIR,  LMETIS
+#          3/ add -Dmetis in line ORDERINGSF
+#             ORDERINGSF  = -Dpord -Dmetis
+#          4/ Compile and install MUMPS
+#             make clean; make   (to clean up previous installation)
+#
+#          Metis/ParMetis and SCOTCH/PT-SCOTCH (ver 5.1 and later) orderings are now available for MUMPS.
+#
+
+ISCOTCH    = ?INCLUDES?
+# You have to choose one among the following two lines depending on
+# the type of analysis you want to perform. If you want to perform only
+# sequential analysis choose the first (remember to add -Dscotch in the ORDERINGSF
+# variable below); for both parallel and sequential analysis choose the second 
+# line (remember to add -Dptscotch in the ORDERINGSF variable below)
+
+LSCOTCH    = ?LIBPATH? ?LIB_SCOTCH? ?STLIB_SCOTCH?
+#LSCOTCH    = -L$(SCOTCHDIR)/lib -lptesmumps -lptscotch -lptscotcherr
+
+
+LPORDDIR = $(topdir)/PORD/lib/
+IPORD    = -I$(topdir)/PORD/include/
+LPORD    = -L$(LPORDDIR) -lpord
+
+#IMETIS    = # Metis doesn't need include files (Fortran interface avail.)
+# You have to choose one among the following two lines depending on
+# the type of analysis you want to perform. If you want to perform only
+# sequential analysis choose the first (remember to add -Dmetis in the ORDERINGSF
+# variable below); for both parallel and sequential analysis choose the second 
+# line (remember to add -Dparmetis in the ORDERINGSF variable below)
+
+LMETIS    = ?LIBPATH? ?LIB_PARMETIS? ?STLIB_PARMETIS? ?LIB_METIS? ?STLIB_METIS? 
+#LMETIS    = -L$(LMETISDIR) -lparmetis -lmetis
+
+# The following variables will be used in the compilation process.
+# Please note that -Dptscotch and -Dparmetis imply -Dscotch and -Dmetis respectively.
+#ORDERINGSF = -Dscotch -Dmetis -Dpord -Dptscotch -Dparmetis
+ORDERINGSF  = ?ORDERINGS?
+ORDERINGSC  = $(ORDERINGSF)
+
+LORDERINGS = $(LMETIS) $(LPORD) $(LSCOTCH)
+IORDERINGSF = $(ISCOTCH)
+IORDERINGSC = $(IMETIS) $(IPORD) $(ISCOTCH)
+
+#End orderings
+########################################################################
+################################################################################
+
+PLAT    =
+LIBEXT  = .a
+OUTC    = -o 
+OUTF    = -o 
+RM      = /bin/rm -f
+CC      = ?CC?
+FC      = ?FC?
+FL      = ?LINK_FC?
+# WARNING: AR must ends with a blank space!
+AR      = ?AR? ?ARFLAGS? 
+#
+RANLIB  = echo
+
+#
+INCPAR = ?INCLUDES?
+LIBPAR = ?LIB_SCALAPACK?
+#
+INCSEQ = -I$(topdir)/libseq
+LIBSEQ = -L$(topdir)/libseq -lmpiseq
+
+#
+LIBBLAS = ?LIBPATH? ?LIB_MATH? ?STLIB_MATH?
+LIBOTHERS =  ?LIBPATH? ?LIB_SYS? ?STLIB_SYS? ?OPTLIB_FLAGS? ?OPTLIB_FLAGS_MATH?
+#Preprocessor defs for calling Fortran from C (-DAdd_ or -DAdd__ or -DUPPER)
+CDEFS   = ?DEFINES?
+
+#Begin Optimized options
+OPTF    = -O ?FCFLAGS? ?FCFLAGS_OPENMP?
+OPTL    = -O ?LINKFLAGS? ?LINKFLAGS_OPENMP? ?LINKFLAGS_CLIB?
+OPTC    = -O ?CFLAGS?
+#End Optimized options
+
+INCS = ?INCS?
+LIBS = ?LIBS?
+LIBSEQNEEDED = ?LIBSEQNEEDED?
diff -ruN MUMPS_5.1.2/README mumps-5.1.2-aster7/README
--- MUMPS_5.1.2/README	2017-10-02 09:37:01.000000000 +0200
+++ mumps-5.1.2-aster7/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-===========================================
-MUMPS 5.1.2
-===========================================
-
-MUMPS 5.1.2 solves a sparse system of linear equations A x = b
-using Gaussian elimination. Please read this README file and
-the documentation (in ./doc/) for a complete list of
-functionalities. Documentation and publications related
-to MUMPS can also be found at http://mumps-solver.org/
-
-For installation problems, bug reports, and to report your
-experience/feedback with the package, please subscribe to the
-MUMPS Users's mailing list.
-
-Please refer to INSTALL for installation instructions.
-
-
-  Copyright 1991-2017 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria,
-  University of Bordeaux.
-
-  This version of MUMPS is provided to you free of charge. It is
-  released under the CeCILL-C license:
-  http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
-
-
-
-Contents of the distribution:
-----------------------------
-
-ChangeLog  LICENSE    CREDITS    INSTALL    README     VERSION
-Makefile   Make.inc/  doc/       src/       lib/       include/
-ibseq/     examples/  PORD/      MATLAB/    SCILAB/
-
-doc      contains the users' guide in pdf format.
-
-src      contains the source files (for all arithmetics 's','d','c' or 'z')
-         necessary to generate the MUMPS library.
-
-lib      is the place where the MUMPS libraries libxmumps.a
-         (x='s','d','c' or 'z') and the arith-independent
-         library libmumps_common.a are generated.
-
-include  contains xmumps_struc.h, xmumps_root.h and xmumps_c.h (where x is one
-         of 'd','c','s','z' depending on the arithmetic desired),
-         mumps_c_types.h and mumps_compat.h. The first two files must be
-         available at compile time in order to use MUMPS from external FORTRAN
-         programs. The three others for C programs.
-
-libseq   contains a sequential MPI library used by the purely sequential
-         version of MUMPS.
-
-examples contains illustrative test programs showing how MUMPS can be used.
-
-PORD     contains the PORD package (not part of MUMPS) from University
-         of Paderborn. See PORD/README for more info.
-
-MATLAB   contains a MATLAB interface to the sequential version of MUMPS
-
-SCILAB   contains a SCILAB interface to the sequential version of MUMPS
-         (only tested with scilab version 4)
-
diff -ruN MUMPS_5.1.2/README.md mumps-5.1.2-aster7/README.md
--- MUMPS_5.1.2/README.md	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/README.md	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,154 @@
+# MUMPS: a MUltifrontal Massively Parallel sparse direct Solver #
+
+http://mumps.enseeiht.fr/index.php?page=home
+
+This repository publishes a branch **for_aster** that differs from **default** (*upstream*) by:
+
+- adding a build system based on `waf` that gives a automatic `waf configure` step,
+
+- changing the fortran include files to force short integers, reals and logicals. This allows to use `-i8` option when building *code_aster*.
+
+
+Download the source files by cloning the repository (don't forget to change to the **for_aster** branch):
+
+```
+mkdir -p $HOME/dev/aster-prerequisites && cd $HOME/dev/aster-prerequisites
+hg clone http://hg.code.sf.net/p/prereq/mumps
+cd mumps
+hg update for_aster
+```
+
+
+## Building Mumps using the waf scripts ##
+
+The [waf][] scripts have been added by the code_aster team to configure the
+`Makefile.inc` of [Mumps][].
+
+The configuration will check for C and Fortran compilers, eventually MPI wrappers if `--enable-mpi` option is provided, mathematical libraries, Metis and Scotch libraries.
+
+
+Type `waf --help` for a full description.
+
+Main options:
+
+* `--prefix=$PREFIX`:
+
+  This is the installation directory where `lib` will be created and the libraries will be copied to.
+
+* `--enable-mpi`:
+
+  This enables build against MPI libraries.
+  MPI wrappers are automatically selected to `mpicc` and `mpif90`.
+  Use `CC` and `FC` to set different values.
+  Blacs and Scalapack are also added into the mathematical libraries dependencies.
+
+* `--install-tests`:
+
+  The small unittests of Mumps are always built in `src/examples`.
+  Using this option, there will be installed in `$PREFIX/share/examples`.
+
+
+### Configuration and installation ###
+
+Libraries are searched in standard paths. Environment variable `LIBPATH` can be used to search in some other directories (space separated). `INCLUDES` environment variable can be used to search includes in other directories than standard ones.
+
+Compilers can be customized throug `CC` and `FC` (or options `--check-c-compiler=` and `--check-fortran-compiler=`).
+
+Mathematical libraries are automatically searched or defined with `--maths-libs=` (space separated).
+
+Typical usage:
+
+```
+#!bash
+
+    CC=... FC=... \
+    LIBPATH="SCOTCHDIR/lib METISDIR/lib" \
+    INCLUDES="SCOTCHDIR/include METISDIR/include" \
+        ./waf configure install [options]
+```
+
+
+### Examples ###
+
+`[options]` is usually `--prefix=$PREFIX --install-tests`.
+
+
+Sequential builds:
+
+- Using gfortran:
+
+```
+#!bash
+
+     LIBPATH="xxx" INCLUDES="xxx" \
+        ./waf configure install [options]
+```
+
+
+- Using Intel compilers:
+
+```
+#!bash
+
+    CC=icc FC=ifort LIBPATH="xxx" INCLUDES="xxx" \
+        ./waf configure install [options]
+```
+
+Parallel builds:
+
+- Using gfortran with OpenMPI:
+
+```
+#!bash
+
+    LIBPATH="xxx" INCLUDES="xxx" \
+        ./waf configure install --enable-mpi [options]
+```
+
+- Using Intel compilers with MPI support::
+
+```
+#!bash
+
+    CC=mpiicc FC=mpiifort LIBPATH="xxx" INCLUDES="xxx" \
+        ./waf configure install --enable-mpi [options]
+```
+
+
+### Troubleshooting ###
+
+Because `waf` does not know elementary targets in the Makefile (and `Makefile.inc` is not a dependency), sometimes you need force to rebuild by:
+
+```
+#!bash
+
+    ./waf clean install
+```
+
+
+See [code_aster][] and [waf][] websites for more informations.
+
+
+### Changes on include files ###
+
+The changes allow to build code_aster with `-i8` option and keep short integers in the Mumps interface using these changed includes.
+
+Declarations are forced to be of size 4 for integers, reals and logicals:
+
+```
+#!bash
+
+    sed -i 's/INTEGER,/INTEGER(4),/g' include/*_{struc,root}.h libseq/mpif.h
+    sed -i 's/INTEGER /INTEGER(4) /g' include/*_{struc,root}.h libseq/mpif.h
+    sed -i 's/REAL,/REAL(4),/g' include/*_{struc,root}.h libseq/mpif.h
+    sed -i 's/REAL /REAL(4) /g' include/*_{struc,root}.h libseq/mpif.h
+    sed -i 's/LOGICAL,/LOGICAL(4),/g' include/*_{struc,root}.h libseq/mpif.h
+    sed -i 's/LOGICAL /LOGICAL(4) /g' include/*_{struc,root}.h libseq/mpif.h
+```
+
+Do not forget to check long lines (< 72 chars).
+
+
+[code_aster]: http://www.code-aster.org
+[Mumps]: http://mumps.enseeiht.fr/index.php?page=home
+[waf]: https://waf.io
diff -ruN MUMPS_5.1.2/README.mumps mumps-5.1.2-aster7/README.mumps
--- MUMPS_5.1.2/README.mumps	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/README.mumps	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,61 @@
+===========================================
+MUMPS 5.1.2
+===========================================
+
+MUMPS 5.1.2 solves a sparse system of linear equations A x = b
+using Gaussian elimination. Please read this README file and
+the documentation (in ./doc/) for a complete list of
+functionalities. Documentation and publications related
+to MUMPS can also be found at http://mumps-solver.org/
+
+For installation problems, bug reports, and to report your
+experience/feedback with the package, please subscribe to the
+MUMPS Users's mailing list.
+
+Please refer to INSTALL for installation instructions.
+
+
+  Copyright 1991-2017 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria,
+  University of Bordeaux.
+
+  This version of MUMPS is provided to you free of charge. It is
+  released under the CeCILL-C license:
+  http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
+
+
+
+Contents of the distribution:
+----------------------------
+
+ChangeLog  LICENSE    CREDITS    INSTALL    README     VERSION
+Makefile   Make.inc/  doc/       src/       lib/       include/
+ibseq/     examples/  PORD/      MATLAB/    SCILAB/
+
+doc      contains the users' guide in pdf format.
+
+src      contains the source files (for all arithmetics 's','d','c' or 'z')
+         necessary to generate the MUMPS library.
+
+lib      is the place where the MUMPS libraries libxmumps.a
+         (x='s','d','c' or 'z') and the arith-independent
+         library libmumps_common.a are generated.
+
+include  contains xmumps_struc.h, xmumps_root.h and xmumps_c.h (where x is one
+         of 'd','c','s','z' depending on the arithmetic desired),
+         mumps_c_types.h and mumps_compat.h. The first two files must be
+         available at compile time in order to use MUMPS from external FORTRAN
+         programs. The three others for C programs.
+
+libseq   contains a sequential MPI library used by the purely sequential
+         version of MUMPS.
+
+examples contains illustrative test programs showing how MUMPS can be used.
+
+PORD     contains the PORD package (not part of MUMPS) from University
+         of Paderborn. See PORD/README for more info.
+
+MATLAB   contains a MATLAB interface to the sequential version of MUMPS
+
+SCILAB   contains a SCILAB interface to the sequential version of MUMPS
+         (only tested with scilab version 4)
+
diff -ruN MUMPS_5.1.2/src/cmumps_restart.F mumps-5.1.2-aster7/src/cmumps_restart.F
--- MUMPS_5.1.2/src/cmumps_restart.F	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/src/cmumps_restart.F	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,2648 @@
+C
+C  This file is part of MUMPS 5.0.2, released
+C  on Fri Jul 15 09:12:54 UTC 2016
+C
+C
+C  Copyright 1991-2016 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria,
+C  University of Bordeaux.
+C
+C  This version of MUMPS is provided to you free of charge. It is
+C  released under the CeCILL-C license:
+C  http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
+C
+      SUBROUTINE CMUMPS_STOP(id,OUTFILE)
+      USE CMUMPS_STRUC_DEF
+      IMPLICIT NONE
+      INCLUDE 'mpif.h'
+      CHARACTER(len=*), intent(in) :: OUTFILE
+      INTEGER::i1,i2,NBVARIABLES,NBVARIABLES_ROOT
+      INTEGER::OUT,err,OUTROOT
+      CHARACTER(len=100), allocatable, dimension(:)::VARIABLES
+      CHARACTER(len=100), allocatable, dimension(:)::VARIABLES_ROOT
+      CHARACTER(len=100):: OUTFILEMAIN,OUTFILEROOT
+      CHARACTER(len=3) :: STRING_ID
+      LOGICAL :: error
+      INTEGER MASTER
+      PARAMETER( MASTER = 0 )
+      TYPE (CMUMPS_STRUC) :: id
+      id%IF_RESTARTING=.TRUE.
+      NBVARIABLES=171
+      allocate(VARIABLES(NBVARIABLES))
+      VARIABLES(171)="NB_SINGULAR_VALUES"
+      VARIABLES(170)="SINGULAR_VALUES"
+      VARIABLES(169)="IF_RESTARTING"
+      VARIABLES(168)="L0_OMP_MAPPING"
+      VARIABLES(167)="PTR_LEAFS_L0_OMP"
+      VARIABLES(166)="PERM_L0_OMP"
+      VARIABLES(165)="VIRT_L0_OMP"
+      VARIABLES(164)="PHYS_L0_OMP"
+      VARIABLES(163)="IPOOL_AFTER_L0_OMP"
+      VARIABLES(162)="IPOOL_BEFORE_L0_OMP"
+      VARIABLES(161)="THREAD_LA"
+      VARIABLES(160)="LL0_OMP_MAPPING"
+      VARIABLES(159)="L_VIRT_L0_OMP"
+      VARIABLES(158)="L_PHYS_L0_OMP"
+      VARIABLES(157)="LPOOL_BEFORE_L0_OMP"
+      VARIABLES(156)="LPOOL_AFTER_L0_OMP"
+      VARIABLES(155)="NBGRP"
+      VARIABLES(154)="LRGROUPS"
+      VARIABLES(153)="root"
+      VARIABLES(152)="WORKING"
+      VARIABLES(151)="IPTR_WORKING"
+      VARIABLES(150)="pad14"
+      VARIABLES(149)="SUP_PROC"
+      VARIABLES(148)="PIVNUL_LIST"
+      VARIABLES(147)="OOC_FILE_NAME_LENGTH"
+      VARIABLES(146)="OOC_FILE_NAMES"
+      VARIABLES(145)="OOC_NB_FILE_TYPE"
+      VARIABLES(144)="OOC_NB_FILES"
+      VARIABLES(143)="OOC_TOTAL_NB_NODES"
+      VARIABLES(142)="OOC_VADDR"
+      VARIABLES(141)="OOC_SIZE_OF_BLOCK"
+      VARIABLES(140)="pad13"
+      VARIABLES(139)="OOC_INODE_SEQUENCE"
+      VARIABLES(138)="OOC_MAX_NB_NODES_FOR_ZONE"
+      VARIABLES(137)="INSTANCE_NUMBER"
+      VARIABLES(136)="pad12"
+      VARIABLES(135)="CB_SON_SIZE"
+      VARIABLES(134)="DKEEP"
+      VARIABLES(133)="LWK_USER"
+      VARIABLES(132)="NBSA_LOCAL"
+      VARIABLES(131)="WK_USER"
+      VARIABLES(130)="CROIX_MANU"
+      VARIABLES(129)="SCHED_SBTR"
+      VARIABLES(128)="SCHED_GRP"
+      VARIABLES(127)="SCHED_DEP"
+      VARIABLES(126)="SBTR_ID"
+      VARIABLES(125)="DEPTH_FIRST_SEQ"
+      VARIABLES(124)="DEPTH_FIRST"
+      VARIABLES(123)="MY_NB_LEAF"
+      VARIABLES(122)="MY_FIRST_LEAF"
+      VARIABLES(121)="MY_ROOT_SBTR"
+      VARIABLES(120)="COST_TRAV"
+      VARIABLES(119)="MEM_SUBTREE"
+      VARIABLES(118)="RHSCOMP"
+      VARIABLES(117)="POSINRHSCOMP_COL"
+      VARIABLES(116)="POSINRHSCOMP_ROW"
+      VARIABLES(115)="POSINRHSCOMP_COL_ALLOC"
+      VARIABLES(114)="MEM_DIST"
+      VARIABLES(113)="I_AM_CAND"
+      VARIABLES(112)="TAB_POS_IN_PERE"
+      VARIABLES(111)="FUTURE_NIV2"
+      VARIABLES(110)="ISTEP_TO_INIV2"
+      VARIABLES(109)="CANDIDATES"
+      VARIABLES(108)="ELTPROC"
+      VARIABLES(107)="pad11"
+      VARIABLES(106)="NA_ELT"
+      VARIABLES(105)="LELTVAR"
+      VARIABLES(104)="NELT_loc"
+      VARIABLES(103)="DBLARR"
+      VARIABLES(102)="INTARR"
+      VARIABLES(101)="PROCNODE"
+      VARIABLES(100)="S"
+      VARIABLES(99)="PTRFAC"
+      VARIABLES(98)="PTLUST_S"
+      VARIABLES(97)="PROCNODE_STEPS"
+      VARIABLES(96)="NA"
+      VARIABLES(95)="FRTELT"
+      VARIABLES(94)="FRTPTR"
+      VARIABLES(93)="PTRAR"
+      VARIABLES(92)="FILS"
+      VARIABLES(91)="DAD_STEPS"
+      VARIABLES(90)="FRERE_STEPS"
+      VARIABLES(89)="Step2node"
+      VARIABLES(88)="ND_STEPS"
+      VARIABLES(87)="NE_STEPS"
+      VARIABLES(86)="STEP"
+      VARIABLES(85)="NBSA"
+      VARIABLES(84)="LNA"
+      VARIABLES(83)="KEEP"
+      VARIABLES(82)="Deficiency"
+      VARIABLES(81)="MAXIS1"
+      VARIABLES(80)="IS1"
+      VARIABLES(79)="IS"
+      VARIABLES(78)="BUFR"
+      VARIABLES(77)="POIDS"
+      VARIABLES(76)="LBUFR_BYTES"
+      VARIABLES(75)="LBUFR"
+      VARIABLES(74)="ASS_IRECV"
+      VARIABLES(73)="NSLAVES"
+      VARIABLES(72)="NPROCS"
+      VARIABLES(71)="MYID"
+      VARIABLES(70)="COMM_LOAD"
+      VARIABLES(69)="MYID_NODES"
+      VARIABLES(68)="COMM_NODES"
+      VARIABLES(67)="INST_Number"
+      VARIABLES(66)="MAX_SURF_MASTER"
+      VARIABLES(65)="KEEP8"
+      VARIABLES(64)="pad8"
+      VARIABLES(63)="WRITE_PROBLEM"
+      VARIABLES(62)="OOC_PREFIX"
+      VARIABLES(61)="OOC_TMPDIR"
+      VARIABLES(60)="VERSION_NUMBER"
+      VARIABLES(59)="MAPPING"
+      VARIABLES(58)="LISTVAR_SCHUR"
+      VARIABLES(57)="SCHUR_CINTERFACE"
+      VARIABLES(56)="SCHUR"
+      VARIABLES(55)="SIZE_SCHUR"
+      VARIABLES(54)="SCHUR_LLD"
+      VARIABLES(53)="SCHUR_NLOC"
+      VARIABLES(52)="SCHUR_MLOC"
+      VARIABLES(51)="NBLOCK"
+      VARIABLES(50)="MBLOCK"
+      VARIABLES(49)="NPCOL"
+      VARIABLES(48)="NPROW"
+      VARIABLES(47)="UNS_PERM"
+      VARIABLES(46)="SYM_PERM"
+      VARIABLES(45)="RINFOG"
+      VARIABLES(44)="RINFO"
+      VARIABLES(43)="CNTL"
+      VARIABLES(42)="COST_SUBTREES"
+      VARIABLES(41)="INFOG"
+      VARIABLES(40)="INFO"
+      VARIABLES(39)="ICNTL"
+      VARIABLES(38)="pad5"
+      VARIABLES(37)="LREDRHS"
+      VARIABLES(36)="LSOL_loc"
+      VARIABLES(35)="NZ_RHS"
+      VARIABLES(34)="NRHS"
+      VARIABLES(33)="LRHS"
+      VARIABLES(32)="ISOL_loc"
+      VARIABLES(31)="IRHS_PTR"
+      VARIABLES(30)="IRHS_SPARSE"
+      VARIABLES(29)="SOL_loc"
+      VARIABLES(28)="RHS_SPARSE"
+      VARIABLES(27)="REDRHS"
+      VARIABLES(26)="RHS"
+      VARIABLES(25)="PERM_IN"
+      VARIABLES(24)="pad4"
+      VARIABLES(23)="A_ELT"
+      VARIABLES(22)="ELTVAR"
+      VARIABLES(21)="ELTPTR"
+      VARIABLES(20)="pad3"
+      VARIABLES(19)="NELT"
+      VARIABLES(18)="pad2"
+      VARIABLES(17)="A_loc"
+      VARIABLES(16)="JCN_loc"
+      VARIABLES(15)="IRN_loc"
+      VARIABLES(14)="pad1"
+      VARIABLES(13)="NZ_loc"
+      VARIABLES(12)="pad0"
+      VARIABLES(11)="ROWSCA"
+      VARIABLES(10)="COLSCA"
+      VARIABLES(9)="JCN"
+      VARIABLES(8)="IRN"
+      VARIABLES(7)="A"
+      VARIABLES(6)="NZ"
+      VARIABLES(5)="N"
+      VARIABLES(4)="JOB"
+      VARIABLES(3)="PAR"
+      VARIABLES(2)="SYM"
+      VARIABLES(1)="COMM"
+      NBVARIABLES_ROOT=34
+      allocate(VARIABLES_ROOT(NBVARIABLES_ROOT))
+      VARIABLES_ROOT(34)="NB_SINGULAR_VALUES"
+      VARIABLES_ROOT(33)="SINGULAR_VALUES"
+      VARIABLES_ROOT(32)="SVD_VT"
+      VARIABLES_ROOT(31)="SVD_U"
+      VARIABLES_ROOT(30)="gridinit_done"
+      VARIABLES_ROOT(29)="yes"
+      VARIABLES_ROOT(28)="rootpad3"
+      VARIABLES_ROOT(27)="QR_RCOND"
+      VARIABLES_ROOT(26)="rootpad"
+      VARIABLES_ROOT(25)="RHS_ROOT"
+      VARIABLES_ROOT(24)="rootpad2"
+      VARIABLES_ROOT(23)="QR_TAU"
+      VARIABLES_ROOT(22)="SCHUR_POINTER"
+      VARIABLES_ROOT(21)="RHS_CNTR_MASTER_ROOT"
+      VARIABLES_ROOT(20)="rootpad1"
+      VARIABLES_ROOT(19)="IPIV"
+      VARIABLES_ROOT(18)="RG2L_COL"
+      VARIABLES_ROOT(17)="RG2L_ROW"
+      VARIABLES_ROOT(16)="rootpad0"
+      VARIABLES_ROOT(15)="LPIV"
+      VARIABLES_ROOT(14)="CNTXT_BLACS"
+      VARIABLES_ROOT(13)="DESCRIPTOR"
+      VARIABLES_ROOT(12)="TOT_ROOT_SIZE"
+      VARIABLES_ROOT(11)="ROOT_SIZE"
+      VARIABLES_ROOT(10)="RHS_NLOC"
+      VARIABLES_ROOT(9)="SCHUR_LLD"
+      VARIABLES_ROOT(8)="SCHUR_NLOC"
+      VARIABLES_ROOT(7)="SCHUR_MLOC"
+      VARIABLES_ROOT(6)="MYCOL"
+      VARIABLES_ROOT(5)="MYROW"
+      VARIABLES_ROOT(4)="NPCOL"
+      VARIABLES_ROOT(3)="NPROW"
+      VARIABLES_ROOT(2)="NBLOCK"
+      VARIABLES_ROOT(1)="MBLOCK"
+      if(((id%ICNTL(3).GT.0).AND.(id%MYID .EQ. MASTER))) then
+         write(*,*) "DUMPING MUMPS STRUCTURE IN FILE:",OUTFILE
+      endif
+      error=.false.
+      write (STRING_ID, '(i3)') id%MYID
+      OUT=42+id%MYID
+      OUTFILEMAIN=trim(adjustl(OUTFILE)) // trim(adjustl(STRING_ID))
+      open(UNIT=OUT,FILE=OUTFILEMAIN,STATUS='replace',
+     &     form='unformatted',iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN CMUMPS_STOP CANNOT OPEN FILE: "
+     &        //trim(adjustl(OUTFILEMAIN))
+         error=.true.
+         goto 100
+      endif      
+      DO i1=1,NBVARIABLES 
+         SELECT CASE(trim(adjustl(VARIABLES(i1))))
+         CASE("COMM") 
+         CASE("SYM")
+         CASE("PAR")
+         CASE("JOB")
+            write(OUT) id%JOB
+         CASE("N")
+            write(OUT) id%N
+         CASE("ICNTL")
+            write(OUT) id%ICNTL
+         CASE("INFO")
+            write(OUT) id%INFO
+         CASE("INFOG")
+            write(OUT) id%INFOG
+         CASE("COST_SUBTREES")
+            write(OUT) id%COST_SUBTREES
+         CASE("CNTL")
+            write(OUT) id%CNTL
+         CASE("RINFO")
+            write(OUT) id%RINFO
+         CASE("RINFOG")
+            write(OUT) id%RINFOG
+         CASE("KEEP8")
+            write(OUT) id%KEEP8
+         CASE("KEEP")
+            write(OUT) id%KEEP
+         CASE("DKEEP")
+            write(OUT) id%DKEEP    
+         CASE("NZ")
+            write(OUT) id%NZ
+         CASE("A")
+            IF(associated(id%A)) THEN
+               write(OUT) size(id%A,1)
+               write(OUT) id%A
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IRN")
+            IF(associated(id%IRN)) THEN
+               write(OUT) size(id%IRN,1)
+               write(OUT) id%IRN
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("JCN")
+            IF(associated(id%JCN)) THEN
+               write(OUT) size(id%JCN,1)
+               write(OUT) id%JCN
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("COLSCA")
+            IF(associated(id%COLSCA)) THEN
+               write(OUT) size(id%COLSCA,1)
+               write(OUT) id%COLSCA
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF 
+         CASE("ROWSCA")
+            IF(associated(id%ROWSCA)) THEN
+               write(OUT) size(id%ROWSCA,1)
+               write(OUT) id%ROWSCA
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NZ_loc")
+            write(OUT) id%NZ_loc
+         CASE("IRN_loc")
+            IF(associated(id%IRN_loc)) THEN
+               write(OUT) size(id%IRN_loc,1)
+               write(OUT) id%IRN_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("JCN_loc")
+            IF(associated(id%JCN_loc)) THEN
+               write(OUT) size(id%JCN_loc,1)
+               write(OUT) id%JCN_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("A_loc")
+            IF(associated(id%A_loc)) THEN
+               write(OUT) size(id%A_loc,1)
+               write(OUT) id%A_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NELT")
+            write(OUT) id%NELT
+         CASE("ELTPTR")
+            IF(associated(id%ELTPTR)) THEN
+               write(OUT) size(id%ELTPTR,1)
+               write(OUT) id%ELTPTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("ELTVAR")
+            IF(associated(id%ELTVAR)) THEN
+               write(OUT) size(id%ELTVAR,1)
+               write(OUT) id%ELTVAR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("A_ELT")
+            IF(associated(id%A_ELT)) THEN
+               write(OUT) size(id%A_ELT,1)
+               write(OUT) id%A_ELT
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PERM_IN")
+            IF(associated(id%PERM_IN)) THEN
+               write(OUT) size(id%PERM_IN,1)
+               write(OUT) id%PERM_IN
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("RHS")
+            IF(associated(id%RHS)) THEN
+               write(OUT) size(id%RHS,1)
+               write(OUT) id%RHS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("REDRHS")
+            IF(associated(id%REDRHS)) THEN
+               write(OUT) size(id%REDRHS,1)
+               write(OUT) id%REDRHS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("RHS_SPARSE")
+            IF(associated(id%RHS_SPARSE)) THEN
+               write(OUT) size(id%RHS_SPARSE,1)
+               write(OUT) id%RHS_SPARSE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SOL_loc")
+            IF(associated(id%SOL_loc)) THEN
+               write(OUT) size(id%SOL_loc,1)
+               write(OUT) id%SOL_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IRHS_SPARSE")
+            IF(associated(id%IRHS_SPARSE)) THEN
+               write(OUT) size(id%IRHS_SPARSE,1)
+               write(OUT) id%IRHS_SPARSE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IRHS_PTR")
+            IF(associated(id%IRHS_PTR)) THEN
+               write(OUT) size(id%IRHS_PTR,1)
+               write(OUT) id%IRHS_PTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("ISOL_loc")
+            IF(associated(id%ISOL_loc)) THEN
+               write(OUT) size(id%ISOL_loc,1)
+               write(OUT) id%ISOL_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("LRHS")
+            write(OUT) id%LRHS
+         CASE("NRHS")
+            write(OUT) id%NRHS
+         CASE("NZ_RHS")
+            write(OUT) id%NZ_RHS
+         CASE("LSOL_loc")
+            write(OUT) id%LSOL_loc
+         CASE("LREDRHS")
+            write(OUT) id%LREDRHS
+         CASE("SYM_PERM")
+            IF(associated(id%SYM_PERM)) THEN
+               write(OUT) size(id%SYM_PERM,1)
+               write(OUT) id%SYM_PERM
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("UNS_PERM")
+            IF(associated(id%UNS_PERM)) THEN
+               write(OUT) size(id%UNS_PERM,1)
+               write(OUT) id%UNS_PERM
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NPROW")
+            write(OUT) id%NPROW
+         CASE("NPCOL")
+            write(OUT) id%NPCOL
+         CASE("MBLOCK")
+            write(OUT) id%MBLOCK
+         CASE("NBLOCK")
+            write(OUT) id%NBLOCK
+         CASE("SCHUR_MLOC")
+            write(OUT) id%SCHUR_MLOC
+         CASE("SCHUR_NLOC")
+            write(OUT) id%SCHUR_NLOC
+         CASE("SCHUR_LLD")
+            write(OUT) id%SCHUR_LLD
+         CASE("SIZE_SCHUR")
+            write(OUT) id%SIZE_SCHUR
+         CASE("SCHUR")
+            IF(associated(id%SCHUR)) THEN
+               write(OUT) size(id%SCHUR,1)
+               write(OUT) id%SCHUR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SCHUR_CINTERFACE")
+            IF(associated(id%SCHUR_CINTERFACE)) THEN
+               write(OUT) size(id%SCHUR_CINTERFACE,1)
+               write(OUT) id%SCHUR_CINTERFACE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("LISTVAR_SCHUR")
+            IF(associated(id%LISTVAR_SCHUR)) THEN
+               write(OUT) size(id%LISTVAR_SCHUR,1)
+               write(OUT) id%LISTVAR_SCHUR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MAPPING")
+            IF(associated(id%MAPPING)) THEN
+               write(OUT) size(id%MAPPING,1)
+               write(OUT) id%MAPPING
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("VERSION_NUMBER")
+            write(OUT) id%VERSION_NUMBER
+         CASE("OOC_TMPDIR")
+            write(OUT) id%OOC_TMPDIR
+         CASE("OOC_PREFIX")
+            write(OUT) id%OOC_PREFIX
+         CASE("WRITE_PROBLEM")
+            write(OUT) id%WRITE_PROBLEM
+         CASE("MAX_SURF_MASTER")
+            write(OUT) id%MAX_SURF_MASTER
+         CASE("INST_Number")
+            write(OUT) id%INST_Number
+         CASE("COMM_NODES")
+            write(OUT) id%COMM_NODES
+         CASE("MYID_NODES")
+            write(OUT) id%MYID_NODES
+         CASE("COMM_LOAD")
+            write(OUT) id%COMM_LOAD
+         CASE("MYID")
+            write(OUT) id%MYID
+         CASE("NPROCS")
+            write(OUT) id%NPROCS
+         CASE("NSLAVES")
+            write(OUT) id%NSLAVES
+         CASE("ASS_IRECV")
+            write(OUT) id%ASS_IRECV
+         CASE("LBUFR")
+            write(OUT) id%LBUFR
+         CASE("LBUFR_BYTES")
+            write(OUT) id%LBUFR_BYTES
+         CASE("POIDS")
+            IF(associated(id%POIDS)) THEN 
+               write(OUT) size(id%POIDS,1)
+               write(OUT) id%POIDS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("BUFR")
+            IF(associated(id%BUFR)) THEN 
+               write(OUT) size(id%BUFR,1)
+               write(OUT) id%BUFR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IS")
+            IF(associated(id%IS)) THEN 
+               write(OUT) size(id%IS,1)
+               write(OUT) id%IS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IS1")
+            IF(associated(id%IS1)) THEN 
+               write(OUT) size(id%IS1,1)
+               write(OUT) id%IS1
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MAXIS1")
+            write(OUT) id%MAXIS1
+         CASE("Deficiency")
+            write(OUT) id%Deficiency
+         CASE("LNA")
+            write(OUT) id%LNA
+         CASE("NBSA")
+            write(OUT) id%NBSA
+         CASE("STEP")
+            IF(associated(id%STEP)) THEN
+               write(OUT) size(id%STEP,1)
+               write(OUT) id%STEP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NE_STEPS")
+            IF(associated(id%NE_STEPS)) THEN
+               write(OUT) size(id%NE_STEPS,1)
+               write(OUT) id%NE_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("ND_STEPS")
+            IF(associated(id%ND_STEPS)) THEN
+               write(OUT) size(id%ND_STEPS,1)
+               write(OUT) id%ND_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("Step2node")
+            IF(associated(id%Step2node)) THEN
+               write(OUT) size(id%Step2node,1)
+               write(OUT) id%Step2node
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FRERE_STEPS")
+            IF(associated(id%FRERE_STEPS)) THEN
+               write(OUT) size(id%FRERE_STEPS,1)
+               write(OUT) id%FRERE_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DAD_STEPS")
+            IF(associated(id%DAD_STEPS)) THEN
+               write(OUT) size(id%DAD_STEPS,1)
+               write(OUT) id%DAD_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FILS")
+            IF(associated(id%FILS)) THEN
+               write(OUT) size(id%FILS,1)
+               write(OUT) id%FILS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PTRAR")
+            IF(associated(id%PTRAR)) THEN
+               write(OUT) size(id%PTRAR,1)
+               write(OUT) id%PTRAR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FRTPTR")
+            IF(associated(id%FRTPTR)) THEN
+               write(OUT) size(id%FRTPTR,1)
+               write(OUT) id%FRTPTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FRTELT")
+            IF(associated(id%FRTELT)) THEN
+               write(OUT) size(id%FRTELT,1)
+               write(OUT) id%FRTELT
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NA")
+            IF(associated(id%NA)) THEN
+               write(OUT) size(id%NA,1)
+               write(OUT) id%NA
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PROCNODE_STEPS")
+            IF(associated(id%PROCNODE_STEPS)) THEN
+               write(OUT) size(id%PROCNODE_STEPS,1)
+               write(OUT) id%PROCNODE_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PTLUST_S")
+            IF(associated(id%PTLUST_S)) THEN
+               write(OUT) size(id%PTLUST_S,1)
+               write(OUT) id%PTLUST_S
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PTRFAC")
+            IF(associated(id%PTRFAC)) THEN
+               write(OUT) size(id%PTRFAC,1)
+               write(OUT) id%PTRFAC
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("S")
+            IF(associated(id%S)) THEN
+               write(OUT) id%KEEP8(23)
+               write(OUT) id%S
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PROCNODE")
+            IF(associated(id%PROCNODE)) THEN
+               write(OUT) size(id%PROCNODE,1)
+               write(OUT) id%PROCNODE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("INTARR")
+            IF(associated(id%INTARR)) THEN
+               write(OUT) size(id%INTARR,1)
+               write(OUT) id%INTARR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DBLARR")
+            IF(associated(id%DBLARR)) THEN
+               write(OUT) size(id%DBLARR,1)
+               write(OUT) id%DBLARR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NELT_loc")
+            write(OUT) id%NELT_loc
+         CASE("LELTVAR")
+            write(OUT) id%LELTVAR
+         CASE("NA_ELT")
+            write(OUT) id%NA_ELT
+         CASE("ELTPROC")
+            IF(associated(id%ELTPROC)) THEN
+               write(OUT) size(id%ELTPROC,1)
+               write(OUT) id%ELTPROC
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("CANDIDATES")
+            IF(associated(id%CANDIDATES)) THEN
+               write(OUT) size(id%CANDIDATES,1)
+     &              ,size(id%CANDIDATES,2)
+               write(OUT) id%CANDIDATES
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("ISTEP_TO_INIV2")
+            IF(associated(id%ISTEP_TO_INIV2)) THEN
+               write(OUT) size(id%ISTEP_TO_INIV2,1)
+               write(OUT) id%ISTEP_TO_INIV2
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FUTURE_NIV2")
+            IF(associated(id%FUTURE_NIV2)) THEN
+               write(OUT) size(id%FUTURE_NIV2,1)
+               write(OUT) id%FUTURE_NIV2
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("TAB_POS_IN_PERE")
+            IF(associated(id%TAB_POS_IN_PERE)) THEN
+               write(OUT) size(id%TAB_POS_IN_PERE,1)
+     &              ,size(id%TAB_POS_IN_PERE,2)
+               write(OUT) id%TAB_POS_IN_PERE
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("I_AM_CAND")
+            IF(associated(id%I_AM_CAND)) THEN
+               write(OUT) size(id%I_AM_CAND,1)
+               write(OUT) id%I_AM_CAND
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MEM_DIST")
+            IF(associated(id%MEM_DIST)) THEN
+               write(OUT) size(id%MEM_DIST,1)
+               write(OUT) id%MEM_DIST
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("POSINRHSCOMP_ROW")
+            IF(associated(id%POSINRHSCOMP_ROW)) THEN 
+               write(OUT) size(id%POSINRHSCOMP_ROW,1)
+               write(OUT) id%POSINRHSCOMP_ROW
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("POSINRHSCOMP_COL_ALLOC")
+            write(OUT) id%POSINRHSCOMP_COL_ALLOC
+         CASE("POSINRHSCOMP_COL")
+            IF(associated(id%POSINRHSCOMP_COL)) THEN
+               IF(id%POSINRHSCOMP_COL_ALLOC) THEN
+                  write(OUT) size(id%POSINRHSCOMP_COL,1)
+                  write(OUT) id%POSINRHSCOMP_COL
+               ELSE
+                  write(OUT) size(id%POSINRHSCOMP_COL,1)
+                  write(OUT) -999
+               ENDIF
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("RHSCOMP")
+            IF(associated(id%RHSCOMP)) THEN
+               write(OUT) size(id%RHSCOMP,1)
+               write(OUT) id%RHSCOMP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MEM_SUBTREE")
+            IF(associated(id%MEM_SUBTREE)) THEN
+               write(OUT) size(id%MEM_SUBTREE,1)
+               write(OUT) id%MEM_SUBTREE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("COST_TRAV")
+            IF(associated(id%COST_TRAV)) THEN
+               write(OUT) size(id%COST_TRAV,1)
+               write(OUT) id%COST_TRAV
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MY_ROOT_SBTR")
+            IF(associated(id%MY_ROOT_SBTR)) THEN
+               write(OUT) size(id%MY_ROOT_SBTR,1)
+               write(OUT) id%MY_ROOT_SBTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MY_FIRST_LEAF")
+            IF(associated(id%MY_FIRST_LEAF)) THEN
+               write(OUT) size(id%MY_FIRST_LEAF,1)
+               write(OUT) id%MY_FIRST_LEAF
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MY_NB_LEAF")
+            IF(associated(id%MY_NB_LEAF)) THEN
+               write(OUT) size(id%MY_NB_LEAF,1)
+               write(OUT) id%MY_NB_LEAF
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DEPTH_FIRST")
+            IF(associated(id%DEPTH_FIRST)) THEN
+               write(OUT) size(id%DEPTH_FIRST,1)
+               write(OUT) id%DEPTH_FIRST
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DEPTH_FIRST_SEQ")
+            IF(associated(id%DEPTH_FIRST_SEQ)) THEN
+               write(OUT) size(id%DEPTH_FIRST_SEQ,1)
+               write(OUT) id%DEPTH_FIRST_SEQ
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SBTR_ID")
+            IF(associated(id%SBTR_ID)) THEN
+               write(OUT) size(id%SBTR_ID,1)
+               write(OUT) id%SBTR_ID
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SCHED_DEP")
+            IF(associated(id%SCHED_DEP)) THEN
+               write(OUT) size(id%SCHED_DEP,1)
+               write(OUT) id%SCHED_DEP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SCHED_GRP")
+            IF(associated(id%SCHED_GRP)) THEN
+               write(OUT) size(id%SCHED_GRP,1)
+               write(OUT) id%SCHED_GRP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("CROIX_MANU")
+            IF(associated(id%CROIX_MANU)) THEN
+               write(OUT) size(id%CROIX_MANU,1)
+               write(OUT) id%CROIX_MANU
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("WK_USER")
+            IF(associated(id%WK_USER)) THEN
+               write(OUT) id%KEEP8(24)
+               write(OUT) id%WK_USER
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NBSA_LOCAL")
+            write(OUT) id%NBSA_LOCAL
+         CASE("LWK_USER")
+            write(OUT) id%LWK_USER
+         CASE("CB_SON_SIZE")
+            IF(associated(id%CB_SON_SIZE)) THEN
+               write(OUT) size(id%CB_SON_SIZE,1)
+               write(OUT) id%CB_SON_SIZE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("INSTANCE_NUMBER")
+            write(OUT) id%INSTANCE_NUMBER
+         CASE("OOC_MAX_NB_NODES_FOR_ZONE")
+            write(OUT) id%OOC_MAX_NB_NODES_FOR_ZONE
+         CASE("OOC_INODE_SEQUENCE")
+            IF(associated(id%OOC_INODE_SEQUENCE)) THEN
+               write(OUT) size(id%OOC_INODE_SEQUENCE,1)
+     &              ,size(id%OOC_INODE_SEQUENCE,2)
+               write(OUT) id%OOC_INODE_SEQUENCE
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_SIZE_OF_BLOCK")
+            IF(associated(id%OOC_SIZE_OF_BLOCK)) THEN
+               write(OUT) size(id%OOC_SIZE_OF_BLOCK,1)
+     &              ,size(id%OOC_SIZE_OF_BLOCK,2)  
+               write(OUT) id%OOC_SIZE_OF_BLOCK
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_VADDR")
+            IF(associated(id%OOC_VADDR)) THEN
+               write(OUT) size(id%OOC_VADDR,1),size(id%OOC_VADDR,2)
+               write(OUT) id%OOC_VADDR
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_TOTAL_NB_NODES")
+            IF(associated(id%OOC_TOTAL_NB_NODES)) THEN
+               write(OUT) size(id%OOC_TOTAL_NB_NODES,1)
+               write(OUT) id%OOC_TOTAL_NB_NODES
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_NB_FILES")
+            IF(associated(id%OOC_NB_FILES)) THEN
+               write(OUT) size(id%OOC_NB_FILES,1)
+               write(OUT) id%OOC_NB_FILES
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_NB_FILE_TYPE")
+            write(OUT) id%OOC_NB_FILE_TYPE
+         CASE("OOC_FILE_NAMES")
+            IF(associated(id%OOC_FILE_NAMES)) THEN
+               write(OUT) size(id%OOC_FILE_NAMES,1)
+     &              ,size(id%OOC_FILE_NAMES,2)
+               write(OUT) id%OOC_FILE_NAMES
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_FILE_NAME_LENGTH")
+            IF(associated(id%OOC_FILE_NAME_LENGTH)) THEN
+               write(OUT) size(id%OOC_FILE_NAME_LENGTH,1)
+               write(OUT) id%OOC_FILE_NAME_LENGTH
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PIVNUL_LIST")
+            IF(associated(id%PIVNUL_LIST)) THEN
+               write(OUT) size(id%PIVNUL_LIST,1)
+               write(OUT) id%PIVNUL_LIST
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SUP_PROC")
+            IF(associated(id%SUP_PROC)) THEN
+               write(OUT) size(id%SUP_PROC,1),size(id%SUP_PROC,2)
+               write(OUT) id%SUP_PROC
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("IPTR_WORKING")
+            IF(associated(id%IPTR_WORKING)) THEN
+               write(OUT) size(id%IPTR_WORKING,1)
+               write(OUT) id%IPTR_WORKING
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("WORKING")
+            IF(associated(id%WORKING)) THEN
+               write(OUT) size(id%WORKING,1)
+               write(OUT) id%WORKING
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("root")
+         CASE("NBGRP")
+           write(OUT) id%NBGRP
+        CASE("LRGROUPS")
+           IF(associated(id%LRGROUPS)) THEN
+              write(OUT) size(id%LRGROUPS,1)
+              write(OUT) id%LRGROUPS
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("SCHED_SBTR")
+           IF(associated(id%SCHED_SBTR)) THEN
+              write(OUT) size(id%SCHED_SBTR,1)
+              write(OUT) id%SCHED_SBTR
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("LPOOL_AFTER_L0_OMP")
+           write(OUT) id%LPOOL_AFTER_L0_OMP
+        CASE("LPOOL_BEFORE_L0_OMP")
+           write(OUT) id%LPOOL_BEFORE_L0_OMP
+        CASE("L_PHYS_L0_OMP")
+           write(OUT) id%L_PHYS_L0_OMP
+        CASE("L_VIRT_L0_OMP")        
+           write(OUT) id%L_VIRT_L0_OMP
+        CASE("LL0_OMP_MAPPING")
+           write(OUT) id%LL0_OMP_MAPPING
+        CASE("THREAD_LA")
+           write(OUT) id%THREAD_LA
+        CASE("IPOOL_AFTER_L0_OMP")
+           IF(associated(id%IPOOL_AFTER_L0_OMP)) THEN
+              write(OUT) size(id%IPOOL_AFTER_L0_OMP,1)
+              write(OUT) id%IPOOL_AFTER_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("IPOOL_BEFORE_L0_OMP")
+           IF(associated(id%IPOOL_BEFORE_L0_OMP)) THEN
+              write(OUT) size(id%IPOOL_BEFORE_L0_OMP,1)
+              write(OUT) id%IPOOL_BEFORE_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("PHYS_L0_OMP")
+           IF(associated(id%PHYS_L0_OMP)) THEN
+              write(OUT) size(id%PHYS_L0_OMP,1)
+              write(OUT) id%PHYS_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("VIRT_L0_OMP")
+           IF(associated(id%VIRT_L0_OMP)) THEN
+              write(OUT) size(id%VIRT_L0_OMP,1)
+              write(OUT) id%VIRT_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("PERM_L0_OMP")
+           IF(associated(id%PERM_L0_OMP)) THEN
+              write(OUT) size(id%PERM_L0_OMP,1)
+              write(OUT) id%PERM_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("PTR_LEAFS_L0_OMP")
+           IF(associated(id%PTR_LEAFS_L0_OMP)) THEN
+              write(OUT) size(id%PTR_LEAFS_L0_OMP,1)
+              write(OUT) id%PTR_LEAFS_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("L0_OMP_MAPPING")
+          IF(associated(id%L0_OMP_MAPPING)) THEN
+              write(OUT) size(id%L0_OMP_MAPPING,1)
+              write(OUT) id%L0_OMP_MAPPING
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("IF_RESTARTING")
+           write(OUT) id%IF_RESTARTING
+      CASE("SINGULAR_VALUES")
+         IF(associated(id%SINGULAR_VALUES)) THEN
+            write(OUT) size(id%SINGULAR_VALUES,1)
+            write(OUT) id%SINGULAR_VALUES
+         ELSE
+            write(OUT) -999,-998
+            write(OUT) -999
+         ENDIF 
+      CASE("NB_SINGULAR_VALUES")
+        write(OUT) id%NB_SINGULAR_VALUES
+        CASE("pad0","pad1","pad2","pad3","pad4","pad5","pad8","pad11",
+     &          "pad111", "pad12","pad13","pad14")
+        CASE DEFAULT
+           id%INFOG(1)=-92
+           write(*,*) "IN CMUMPS_STOP UNKNOWN VARIABLE IN STRUCTURE: "
+     &          // trim(adjustl(VARIABLES(i1)))
+           error=.true.
+           goto 100
+        END SELECT
+      ENDDO
+ 100  continue
+      CLOSE(OUT)
+      if(error) goto 101
+      OUTROOT=OUT+1000
+      OUTFILEROOT=trim(adjustl(OUTFILE)) // trim(adjustl("ROOT")) 
+     &     // trim(adjustl(STRING_ID))
+      open(UNIT=OUTROOT,FILE=OUTFILEROOT,STATUS='replace',
+     &     form='unformatted',iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN CMUMPS_STOP CANNOT OPEN FILE: "
+     &        //trim(adjustl(OUTFILEROOT))
+         goto 100
+      endif
+      DO i2=1,NBVARIABLES_ROOT
+         SELECT CASE(VARIABLES_ROOT(i2))
+      CASE("MBLOCK")
+         write(OUTROOT) id%root%MBLOCK
+      CASE("NBLOCK")
+         write(OUTROOT) id%root%NBLOCK
+      CASE("NPROW")
+         write(OUTROOT) id%root%NPROW
+      CASE("NPCOL")
+         write(OUTROOT) id%root%NPCOL
+      CASE("MYROW")
+         write(OUTROOT) id%root%MYROW
+      CASE("MYCOL")
+         write(OUTROOT) id%root%MYCOL
+      CASE("SCHUR_MLOC")
+         write(OUTROOT) id%root%SCHUR_MLOC
+      CASE("SCHUR_NLOC")
+         write(OUTROOT) id%root%SCHUR_NLOC
+      CASE("SCHUR_LLD")
+         write(OUTROOT) id%root%SCHUR_LLD
+      CASE("RHS_NLOC")
+         write(OUTROOT) id%root%RHS_NLOC
+      CASE("ROOT_SIZE")
+         write(OUTROOT) id%root%ROOT_SIZE
+      CASE("TOT_ROOT_SIZE")
+         write(OUTROOT) id%root%TOT_ROOT_SIZE
+      CASE("DESCRIPTOR")
+         write(OUTROOT) id%root%DESCRIPTOR
+      CASE("CNTXT_BLACS")
+         write(OUTROOT) id%root%CNTXT_BLACS
+      CASE("LPIV")
+         write(OUTROOT) id%root%LPIV
+      CASE("RG2L_ROW")
+         IF(associated(id%root%RG2L_ROW)) THEN
+            write(OUTROOT) size(id%root%RG2L_ROW,1)
+            write(OUTROOT) id%root%RG2L_ROW
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("RG2L_COL")
+         IF(associated(id%root%RG2L_COL)) THEN
+            write(OUTROOT) size(id%root%RG2L_COL,1)
+            write(OUTROOT) id%root%RG2L_COL
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("IPIV")
+         IF(associated(id%root%IPIV)) THEN
+            write(OUTROOT) size(id%root%IPIV,1)
+            write(OUTROOT) id%root%IPIV
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("RHS_CNTR_MASTER_ROOT")
+         IF(associated(id%root%RHS_CNTR_MASTER_ROOT)) THEN
+            write(OUTROOT) size(id%root%RHS_CNTR_MASTER_ROOT,1)
+            write(OUTROOT) id%root%RHS_CNTR_MASTER_ROOT
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("SCHUR_POINTER")
+         IF(associated(id%root%SCHUR_POINTER)) THEN
+            write(OUTROOT) size(id%root%SCHUR_POINTER,1)
+            write(OUTROOT) id%root%SCHUR_POINTER
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("QR_TAU")
+         IF(associated(id%root%QR_TAU)) THEN
+            write(OUTROOT) size(id%root%QR_TAU,1)
+            write(OUTROOT) id%root%QR_TAU
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("RHS_ROOT")
+         IF(associated(id%root%RHS_ROOT)) THEN
+            write(OUTROOT) size(id%root%RHS_ROOT,1)
+     &           ,size(id%root%RHS_ROOT,2)
+            write(OUTROOT) id%root%RHS_ROOT
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF
+      CASE("QR_RCOND")
+         write(OUTROOT) id%root%QR_RCOND
+      CASE("yes")
+         write(OUTROOT) id%root%yes
+      CASE("gridinit_done")
+         write(OUTROOT) id%root%gridinit_done
+      CASE("SVD_U")
+         IF(associated(id%root%SVD_U)) THEN
+            write(OUTROOT) size(id%root%SVD_U,1)
+     &           ,size(id%root%SVD_U,2)
+            write(OUTROOT) id%root%SVD_U
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF   
+      CASE("SVD_VT")
+         IF(associated(id%root%SVD_VT)) THEN
+            write(OUTROOT) size(id%root%SVD_VT,1)
+     &           ,size(id%root%SVD_VT,2)
+            write(OUTROOT) id%root%SVD_VT
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF  
+      CASE("SINGULAR_VALUES")
+         IF(associated(id%root%SINGULAR_VALUES)) THEN
+            write(OUTROOT) size(id%root%SINGULAR_VALUES,1)
+            write(OUTROOT) id%root%SINGULAR_VALUES
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF 
+      CASE("NB_SINGULAR_VALUES")
+         write(OUTROOT) id%root%NB_SINGULAR_VALUES
+      CASE("rootpad0","rootpad1","rootpad2","rootpad",
+     &        "rootpad3")
+      CASE DEFAULT
+         id%INFOG(1)=-92
+         write(*,*) "IN CMUMPS_STOP UNKNOWN VARIABLE"
+     &        // "IN ROOT: " // trim(adjustl(VARIABLES_ROOT(i2)))
+         goto 101
+      END SELECT  
+      ENDDO
+ 101  continue
+      CLOSE(OUTROOT)
+      END SUBROUTINE CMUMPS_STOP
+      SUBROUTINE CMUMPS_RESTART(id,INFILE)
+      USE CMUMPS_STRUC_DEF
+      IMPLICIT NONE
+      INCLUDE 'mpif.h'
+      INTEGER::IN,err,NBVARIABLES,i1,NBVARIABLES_ROOT,dummy
+      INTEGER:: i2,size_array1,size_array2,INROOT
+      CHARACTER(len=100),allocatable,DIMENSION(:)::VARIABLES
+      CHARACTER(len=100),allocatable,DIMENSION(:)::VARIABLES_ROOT
+      CHARACTER(len=*), intent(in):: INFILE
+      CHARACTER(len=100):: INFILEMAIN,INFILEROOT
+      CHARACTER(len=3) :: STRING_ID
+      LOGICAL :: error
+      INTEGER MASTER
+      PARAMETER( MASTER = 0 )
+      TYPE (CMUMPS_STRUC) :: id
+      error=.false.
+      write (STRING_ID, '(i3)') id%MYID
+      NBVARIABLES=171
+      allocate(VARIABLES(NBVARIABLES))
+      VARIABLES(171)="NB_SINGULAR_VALUES"
+      VARIABLES(170)="SINGULAR_VALUES"
+      VARIABLES(169)="IF_RESTARTING"
+      VARIABLES(168)="L0_OMP_MAPPING"
+      VARIABLES(167)="PTR_LEAFS_L0_OMP"
+      VARIABLES(166)="PERM_L0_OMP"
+      VARIABLES(165)="VIRT_L0_OMP"
+      VARIABLES(164)="PHYS_L0_OMP"
+      VARIABLES(163)="IPOOL_AFTER_L0_OMP"
+      VARIABLES(162)="IPOOL_BEFORE_L0_OMP"
+      VARIABLES(161)="THREAD_LA"
+      VARIABLES(160)="LL0_OMP_MAPPING"
+      VARIABLES(159)="L_VIRT_L0_OMP"
+      VARIABLES(158)="L_PHYS_L0_OMP"
+      VARIABLES(157)="LPOOL_BEFORE_L0_OMP"
+      VARIABLES(156)="LPOOL_AFTER_L0_OMP"
+      VARIABLES(155)="NBGRP"
+      VARIABLES(154)="LRGROUPS"
+      VARIABLES(153)="root"
+      VARIABLES(152)="WORKING"
+      VARIABLES(151)="IPTR_WORKING"
+      VARIABLES(150)="pad14"
+      VARIABLES(149)="SUP_PROC"
+      VARIABLES(148)="PIVNUL_LIST"
+      VARIABLES(147)="OOC_FILE_NAME_LENGTH"
+      VARIABLES(146)="OOC_FILE_NAMES"
+      VARIABLES(145)="OOC_NB_FILE_TYPE"
+      VARIABLES(144)="OOC_NB_FILES"
+      VARIABLES(143)="OOC_TOTAL_NB_NODES"
+      VARIABLES(142)="OOC_VADDR"
+      VARIABLES(141)="OOC_SIZE_OF_BLOCK"
+      VARIABLES(140)="pad13"
+      VARIABLES(139)="OOC_INODE_SEQUENCE"
+      VARIABLES(138)="OOC_MAX_NB_NODES_FOR_ZONE"
+      VARIABLES(137)="INSTANCE_NUMBER"
+      VARIABLES(136)="pad12"
+      VARIABLES(135)="CB_SON_SIZE"
+      VARIABLES(134)="DKEEP"
+      VARIABLES(133)="LWK_USER"
+      VARIABLES(132)="NBSA_LOCAL"
+      VARIABLES(131)="WK_USER"
+      VARIABLES(130)="CROIX_MANU"
+      VARIABLES(129)="SCHED_SBTR"
+      VARIABLES(128)="SCHED_GRP"
+      VARIABLES(127)="SCHED_DEP"
+      VARIABLES(126)="SBTR_ID"
+      VARIABLES(125)="DEPTH_FIRST_SEQ"
+      VARIABLES(124)="DEPTH_FIRST"
+      VARIABLES(123)="MY_NB_LEAF"
+      VARIABLES(122)="MY_FIRST_LEAF"
+      VARIABLES(121)="MY_ROOT_SBTR"
+      VARIABLES(120)="COST_TRAV"
+      VARIABLES(119)="MEM_SUBTREE"
+      VARIABLES(118)="RHSCOMP"
+      VARIABLES(117)="POSINRHSCOMP_COL"
+      VARIABLES(116)="POSINRHSCOMP_ROW"
+      VARIABLES(115)="POSINRHSCOMP_COL_ALLOC"
+      VARIABLES(114)="MEM_DIST"
+      VARIABLES(113)="I_AM_CAND"
+      VARIABLES(112)="TAB_POS_IN_PERE"
+      VARIABLES(111)="FUTURE_NIV2"
+      VARIABLES(110)="ISTEP_TO_INIV2"
+      VARIABLES(109)="CANDIDATES"
+      VARIABLES(108)="ELTPROC"
+      VARIABLES(107)="pad11"
+      VARIABLES(106)="NA_ELT"
+      VARIABLES(105)="LELTVAR"
+      VARIABLES(104)="NELT_loc"
+      VARIABLES(103)="DBLARR"
+      VARIABLES(102)="INTARR"
+      VARIABLES(101)="PROCNODE"
+      VARIABLES(100)="S"
+      VARIABLES(99)="PTRFAC"
+      VARIABLES(98)="PTLUST_S"
+      VARIABLES(97)="PROCNODE_STEPS"
+      VARIABLES(96)="NA"
+      VARIABLES(95)="FRTELT"
+      VARIABLES(94)="FRTPTR"
+      VARIABLES(93)="PTRAR"
+      VARIABLES(92)="FILS"
+      VARIABLES(91)="DAD_STEPS"
+      VARIABLES(90)="FRERE_STEPS"
+      VARIABLES(89)="Step2node"
+      VARIABLES(88)="ND_STEPS"
+      VARIABLES(87)="NE_STEPS"
+      VARIABLES(86)="STEP"
+      VARIABLES(85)="NBSA"
+      VARIABLES(84)="LNA"
+      VARIABLES(83)="KEEP"
+      VARIABLES(82)="Deficiency"
+      VARIABLES(81)="MAXIS1"
+      VARIABLES(80)="IS1"
+      VARIABLES(79)="IS"
+      VARIABLES(78)="BUFR"
+      VARIABLES(77)="POIDS"
+      VARIABLES(76)="LBUFR_BYTES"
+      VARIABLES(75)="LBUFR"
+      VARIABLES(74)="ASS_IRECV"
+      VARIABLES(73)="NSLAVES"
+      VARIABLES(72)="NPROCS"
+      VARIABLES(71)="MYID"
+      VARIABLES(70)="COMM_LOAD"
+      VARIABLES(69)="MYID_NODES"
+      VARIABLES(68)="COMM_NODES"
+      VARIABLES(67)="INST_Number"
+      VARIABLES(66)="MAX_SURF_MASTER"
+      VARIABLES(65)="KEEP8"
+      VARIABLES(64)="pad8"
+      VARIABLES(63)="WRITE_PROBLEM"
+      VARIABLES(62)="OOC_PREFIX"
+      VARIABLES(61)="OOC_TMPDIR"
+      VARIABLES(60)="VERSION_NUMBER"
+      VARIABLES(59)="MAPPING"
+      VARIABLES(58)="LISTVAR_SCHUR"
+      VARIABLES(57)="SCHUR_CINTERFACE"
+      VARIABLES(56)="SCHUR"
+      VARIABLES(55)="SIZE_SCHUR"
+      VARIABLES(54)="SCHUR_LLD"
+      VARIABLES(53)="SCHUR_NLOC"
+      VARIABLES(52)="SCHUR_MLOC"
+      VARIABLES(51)="NBLOCK"
+      VARIABLES(50)="MBLOCK"
+      VARIABLES(49)="NPCOL"
+      VARIABLES(48)="NPROW"
+      VARIABLES(47)="UNS_PERM"
+      VARIABLES(46)="SYM_PERM"
+      VARIABLES(45)="RINFOG"
+      VARIABLES(44)="RINFO"
+      VARIABLES(43)="CNTL"
+      VARIABLES(42)="COST_SUBTREES"
+      VARIABLES(41)="INFOG"
+      VARIABLES(40)="INFO"
+      VARIABLES(39)="ICNTL"
+      VARIABLES(38)="pad5"
+      VARIABLES(37)="LREDRHS"
+      VARIABLES(36)="LSOL_loc"
+      VARIABLES(35)="NZ_RHS"
+      VARIABLES(34)="NRHS"
+      VARIABLES(33)="LRHS"
+      VARIABLES(32)="ISOL_loc"
+      VARIABLES(31)="IRHS_PTR"
+      VARIABLES(30)="IRHS_SPARSE"
+      VARIABLES(29)="SOL_loc"
+      VARIABLES(28)="RHS_SPARSE"
+      VARIABLES(27)="REDRHS"
+      VARIABLES(26)="RHS"
+      VARIABLES(25)="PERM_IN"
+      VARIABLES(24)="pad4"
+      VARIABLES(23)="A_ELT"
+      VARIABLES(22)="ELTVAR"
+      VARIABLES(21)="ELTPTR"
+      VARIABLES(20)="pad3"
+      VARIABLES(19)="NELT"
+      VARIABLES(18)="pad2"
+      VARIABLES(17)="A_loc"
+      VARIABLES(16)="JCN_loc"
+      VARIABLES(15)="IRN_loc"
+      VARIABLES(14)="pad1"
+      VARIABLES(13)="NZ_loc"
+      VARIABLES(12)="pad0"
+      VARIABLES(11)="ROWSCA"
+      VARIABLES(10)="COLSCA"
+      VARIABLES(9)="JCN"
+      VARIABLES(8)="IRN"
+      VARIABLES(7)="A"
+      VARIABLES(6)="NZ"
+      VARIABLES(5)="N"
+      VARIABLES(4)="JOB"
+      VARIABLES(3)="PAR"
+      VARIABLES(2)="SYM"
+      VARIABLES(1)="COMM"
+      NBVARIABLES_ROOT=34
+      allocate(VARIABLES_ROOT(NBVARIABLES_ROOT))
+      VARIABLES_ROOT(34)="NB_SINGULAR_VALUES"
+      VARIABLES_ROOT(33)="SINGULAR_VALUES"
+      VARIABLES_ROOT(32)="SVD_VT"
+      VARIABLES_ROOT(31)="SVD_U"
+      VARIABLES_ROOT(30)="gridinit_done"
+      VARIABLES_ROOT(29)="yes"
+      VARIABLES_ROOT(28)="rootpad3"
+      VARIABLES_ROOT(27)="QR_RCOND"
+      VARIABLES_ROOT(26)="rootpad"
+      VARIABLES_ROOT(25)="RHS_ROOT"
+      VARIABLES_ROOT(24)="rootpad2"
+      VARIABLES_ROOT(23)="QR_TAU"
+      VARIABLES_ROOT(22)="SCHUR_POINTER"
+      VARIABLES_ROOT(21)="RHS_CNTR_MASTER_ROOT"
+      VARIABLES_ROOT(20)="rootpad1"
+      VARIABLES_ROOT(19)="IPIV"
+      VARIABLES_ROOT(18)="RG2L_COL"
+      VARIABLES_ROOT(17)="RG2L_ROW"
+      VARIABLES_ROOT(16)="rootpad0"
+      VARIABLES_ROOT(15)="LPIV"
+      VARIABLES_ROOT(14)="CNTXT_BLACS"
+      VARIABLES_ROOT(13)="DESCRIPTOR"
+      VARIABLES_ROOT(12)="TOT_ROOT_SIZE"
+      VARIABLES_ROOT(11)="ROOT_SIZE"
+      VARIABLES_ROOT(10)="RHS_NLOC"
+      VARIABLES_ROOT(9)="SCHUR_LLD"
+      VARIABLES_ROOT(8)="SCHUR_NLOC"
+      VARIABLES_ROOT(7)="SCHUR_MLOC"
+      VARIABLES_ROOT(6)="MYCOL"
+      VARIABLES_ROOT(5)="MYROW"
+      VARIABLES_ROOT(4)="NPCOL"
+      VARIABLES_ROOT(3)="NPROW"
+      VARIABLES_ROOT(2)="NBLOCK"
+      VARIABLES_ROOT(1)="MBLOCK"
+      IN=52+id%MYID
+      INFILEMAIN=trim(adjustl(INFILE)) // trim(adjustl(STRING_ID))
+      open(UNIT=IN,FILE=INFILEMAIN, STATUS='old',FORM='unformatted'
+     &     ,iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN CMUMPS_RESTART CANNOT OPEN FILE: "
+     &        //trim(adjustl(INFILEMAIN))
+         error=.true.
+         goto 101
+      endif
+      DO i1=4,NBVARIABLES
+         size_array1=0
+         size_array2=0
+         SELECT CASE(VARIABLES(i1))
+         CASE("JOB")
+            read(IN) id%JOB
+         CASE("N")
+            read(IN) id%N
+         CASE("ICNTL")
+            read(IN) id%ICNTL
+         CASE("INFO")
+            read(IN) id%INFO
+         CASE("INFOG")
+            read(IN) id%INFOG
+         CASE("COST_SUBTREES")
+            read(IN) id%COST_SUBTREES
+         CASE("CNTL")
+            read(IN) id%CNTL
+         CASE("RINFO")
+            read(IN) id%RINFO
+         CASE("RINFOG")
+            read(IN) id%RINFOG
+         CASE("KEEP8")
+            read(IN) id%KEEP8
+         CASE("KEEP")
+            read(IN) id%KEEP
+         CASE("DKEEP")
+            read(IN) id%DKEEP    
+         CASE("NZ")
+            read(IN) id%NZ
+         CASE("A")
+            nullify(id%A)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%A(size_array1))
+               read(IN) id%A
+            endif
+         CASE("IRN")
+            nullify(id%IRN)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRN(size_array1))
+               read(IN) id%IRN
+            endif
+         CASE("JCN")
+            nullify(id%JCN)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%JCN(size_array1))
+               read(IN) id%JCN
+            endif
+         CASE("COLSCA")
+            nullify(id%COLSCA)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%COLSCA(size_array1))
+               read(IN) id%COLSCA
+            endif
+         CASE("ROWSCA")
+            nullify(id%ROWSCA)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ROWSCA(size_array1))
+               read(IN) id%ROWSCA
+            endif
+         CASE("NZ_loc")
+            read(IN) id%NZ_loc
+         CASE("IRN_loc")
+            nullify(id%IRN_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRN_loc(size_array1))
+               read(IN) id%IRN_loc
+            endif
+         CASE("JCN_loc")
+            nullify(id%JCN_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%JCN_loc(size_array1))
+               read(IN) id%JCN_loc
+            endif
+         CASE("A_loc")
+            nullify(id%A_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%A_loc(size_array1))
+               read(IN) id%A_loc
+            endif
+         CASE("NELT")
+            read(IN) id%NELT
+         CASE("ELTPTR")
+            nullify(id%ELTPTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ELTPTR(size_array1))
+               read(IN) id%ELTPTR
+            endif
+         CASE("ELTVAR")
+            nullify(id%ELTVAR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ELTVAR(size_array1))
+               read(IN) id%ELTVAR
+            endif
+         CASE("A_ELT")
+            nullify(id%A_ELT)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%A_ELT(size_array1))
+               read(IN) id%A_ELT
+            endif
+         CASE("PERM_IN")
+            nullify(id%PERM_IN)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PERM_IN(size_array1))
+               read(IN) id%PERM_IN
+            endif
+         CASE("RHS")
+            nullify(id%RHS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%RHS(size_array1))
+               read(IN) id%RHS
+            endif
+         CASE("REDRHS")
+            nullify(id%REDRHS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%REDRHS(size_array1))
+               read(IN) id%REDRHS
+            endif
+         CASE("RHS_SPARSE")
+            nullify(id%RHS_SPARSE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%RHS_SPARSE(size_array1))
+               read(IN) id%RHS_SPARSE
+            endif
+         CASE("SOL_loc")
+            nullify(id%SOL_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SOL_loc(size_array1))
+               read(IN) id%SOL_loc
+            endif
+         CASE("IRHS_SPARSE")
+            nullify(id%IRHS_SPARSE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRHS_SPARSE(size_array1))
+               read(IN) id%IRHS_SPARSE
+            endif
+         CASE("IRHS_PTR")
+            nullify(id%IRHS_PTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRHS_PTR(size_array1))
+               read(IN) id%IRHS_PTR
+            endif
+         CASE("ISOL_loc")
+            nullify(id%ISOL_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ISOL_loc(size_array1))
+               read(IN) id%ISOL_loc
+            endif
+         CASE("LRHS")
+            read(IN) id%LRHS
+         CASE("NRHS")
+            read(IN) id%NRHS
+         CASE("NZ_RHS")
+            read(IN) id%NZ_RHS
+         CASE("LSOL_loc")
+            read(IN) id%LSOL_loc
+         CASE("LREDRHS")
+            read(IN) id%LREDRHS
+         CASE("SYM_PERM")
+            nullify(id%SYM_PERM)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SYM_PERM(size_array1))
+               read(IN) id%SYM_PERM
+            endif
+         CASE("UNS_PERM")
+            nullify(id%UNS_PERM)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%UNS_PERM(size_array1))
+               read(IN) id%UNS_PERM
+            endif
+         CASE("NPROW")
+            read(IN) id%NPROW
+         CASE("NPCOL")
+            read(IN) id%NPCOL
+         CASE("MBLOCK")
+            read(IN) id%MBLOCK
+         CASE("NBLOCK")
+            read(IN) id%NBLOCK
+         CASE("SCHUR_MLOC")
+            read(IN) id%SCHUR_MLOC
+         CASE("SCHUR_NLOC")
+            read(IN) id%SCHUR_NLOC
+         CASE("SCHUR_LLD")
+            read(IN) id%SCHUR_LLD
+         CASE("SIZE_SCHUR")
+            read(IN) id%SIZE_SCHUR
+         CASE("SCHUR")
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHUR(size_array1))
+               read(IN) id%SCHUR
+            endif
+         CASE("SCHUR_CINTERFACE")
+            nullify(id%SCHUR_CINTERFACE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHUR_CINTERFACE(size_array1))
+               read(IN) id%SCHUR_CINTERFACE
+            endif
+         CASE("LISTVAR_SCHUR")
+            nullify(id%LISTVAR_SCHUR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%LISTVAR_SCHUR(size_array1))
+               read(IN) id%LISTVAR_SCHUR
+            endif
+         CASE("MAPPING")
+            nullify(id%MAPPING)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MAPPING(size_array1))
+               read(IN) id%MAPPING
+            endif
+         CASE("VERSION_NUMBER")
+            read(IN) id%VERSION_NUMBER
+         CASE("OOC_TMPDIR")
+            read(IN) id%OOC_TMPDIR
+         CASE("OOC_PREFIX")
+            read(IN) id%OOC_PREFIX
+         CASE("WRITE_PROBLEM")
+            read(IN) id%WRITE_PROBLEM
+         CASE("MAX_SURF_MASTER")
+            read(IN) id%MAX_SURF_MASTER
+         CASE("INST_Number")
+            read(IN) id%INST_Number
+         CASE("COMM_NODES")
+            read(IN) id%COMM_NODES
+         CASE("MYID_NODES")
+            read(IN) id%MYID_NODES
+         CASE("COMM_LOAD")
+            read(IN) id%COMM_LOAD
+         CASE("MYID")
+            read(IN) id%MYID
+         CASE("NPROCS")
+            read(IN) id%NPROCS
+         CASE("NSLAVES")
+            read(IN) id%NSLAVES
+         CASE("ASS_IRECV")
+            read(IN) id%ASS_IRECV
+         CASE("LBUFR")
+            read(IN) id%LBUFR
+         CASE("LBUFR_BYTES")
+            read(IN) id%LBUFR_BYTES
+         CASE("POIDS")
+            nullify(id%POIDS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%POIDS(size_array1))
+               read(IN) id%POIDS
+            endif
+         CASE("BUFR")
+            nullify(id%BUFR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%BUFR(size_array1))
+               read(IN) id%BUFR
+            endif
+         CASE("IS")
+            nullify(id%IS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IS(size_array1))
+               read(IN) id%IS
+            endif
+         CASE("IS1")
+            nullify(id%IS1)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IS1(size_array1))
+               read(IN) id%IS1
+            endif
+         CASE("MAXIS1")
+            read(IN) id%MAXIS1
+         CASE("Deficiency")
+            read(IN) id%Deficiency
+         CASE("LNA")
+            read(IN) id%LNA
+         CASE("NBSA")
+            read(IN) id%NBSA
+         CASE("STEP")
+            nullify(id%STEP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%STEP(size_array1))
+               read(IN) id%STEP
+            endif
+         CASE("NE_STEPS")
+            nullify(id%NE_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%NE_STEPS(size_array1))
+               read(IN) id%NE_STEPS
+            endif
+         CASE("ND_STEPS")
+            nullify(id%ND_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ND_STEPS(size_array1))
+               read(IN) id%ND_STEPS
+            endif
+         CASE("Step2node")
+            nullify(id%Step2node)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%Step2node(size_array1))
+               read(IN) id%Step2node
+            endif
+         CASE("FRERE_STEPS")
+            nullify(id%FRERE_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FRERE_STEPS(size_array1))
+               read(IN) id%FRERE_STEPS
+            endif
+         CASE("DAD_STEPS")
+            nullify(id%DAD_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DAD_STEPS(size_array1))
+               read(IN) id%DAD_STEPS
+            endif
+         CASE("FILS")
+            nullify(id%FILS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FILS(size_array1))
+               read(IN) id%FILS
+            endif
+         CASE("PTRAR")
+            nullify(id%PTRAR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PTRAR(size_array1))
+               read(IN) id%PTRAR
+            endif
+         CASE("FRTPTR")
+            nullify(id%FRTPTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FRTPTR(size_array1))
+               read(IN) id%FRTPTR
+            endif
+         CASE("FRTELT")
+            nullify(id%FRTELT)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FRTELT(size_array1))
+               read(IN) id%FRTELT
+            endif
+         CASE("NA")
+            nullify(id%NA)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%NA(size_array1))
+               read(IN) id%NA
+            endif
+         CASE("PROCNODE_STEPS")
+            nullify(id%PROCNODE_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PROCNODE_STEPS(size_array1))
+               read(IN) id%PROCNODE_STEPS
+            endif
+         CASE("PTLUST_S")
+            nullify(id%PTLUST_S)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PTLUST_S(size_array1))
+               read(IN) id%PTLUST_S
+            endif
+         CASE("PTRFAC")
+            nullify(id%PTRFAC)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PTRFAC(size_array1))
+               read(IN) id%PTRFAC
+            endif
+         CASE("S")
+            nullify(id%S)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%S(size_array1))
+               read(IN) id%S
+            endif
+         CASE("PROCNODE")
+            nullify(id%PROCNODE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PROCNODE(size_array1))
+               read(IN) id%PROCNODE
+            endif
+         CASE("INTARR")
+            nullify(id%INTARR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%INTARR(size_array1))
+               read(IN) id%INTARR
+            endif
+         CASE("DBLARR")
+            nullify(id%DBLARR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DBLARR(size_array1))
+               read(IN) id%DBLARR
+            endif
+         CASE("NELT_loc")
+            read(IN) id%NELT_loc
+         CASE("LELTVAR")
+            read(IN) id%LELTVAR
+         CASE("NA_ELT")
+            read(IN) id%NA_ELT
+         CASE("ELTPROC")
+            nullify(id%ELTPROC)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ELTPROC(size_array1))
+               read(IN) id%ELTPROC
+            endif
+         CASE("CANDIDATES")
+            nullify(id%CANDIDATES)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%CANDIDATES(size_array1,size_array2))
+               read(IN) id%CANDIDATES
+            endif
+         CASE("ISTEP_TO_INIV2")
+            nullify(id%ISTEP_TO_INIV2)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ISTEP_TO_INIV2(size_array1))
+               read(IN) id%ISTEP_TO_INIV2
+            endif
+         CASE("FUTURE_NIV2")
+            nullify(id%FUTURE_NIV2)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FUTURE_NIV2(size_array1))
+               read(IN) id%FUTURE_NIV2
+            endif
+         CASE("TAB_POS_IN_PERE")
+            nullify(id%TAB_POS_IN_PERE)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%TAB_POS_IN_PERE(size_array1,size_array2))
+               read(IN) id%TAB_POS_IN_PERE
+            endif
+         CASE("I_AM_CAND")
+            nullify(id%I_AM_CAND)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%I_AM_CAND(size_array1))
+               read(IN) id%I_AM_CAND
+            endif
+         CASE("MEM_DIST")
+            nullify(id%MEM_DIST)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MEM_DIST(0:size_array1-1))
+               read(IN) id%MEM_DIST
+            endif
+         CASE("POSINRHSCOMP_ROW")
+            nullify(id%POSINRHSCOMP_ROW)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%POSINRHSCOMP_ROW(size_array1))
+               read(IN) id%POSINRHSCOMP_ROW
+            endif
+         CASE("POSINRHSCOMP_COL_ALLOC")
+            read(IN) id%POSINRHSCOMP_COL_ALLOC
+         CASE("POSINRHSCOMP_COL")
+            nullify(id%POSINRHSCOMP_COL)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               if(id%POSINRHSCOMP_COL_ALLOC) then
+                  allocate(id%POSINRHSCOMP_COL(size_array1))
+                  read(IN) id%POSINRHSCOMP_COL
+               else
+                  read(IN) dummy
+                  id%POSINRHSCOMP_COL=>id%POSINRHSCOMP_ROW
+               endif
+            endif
+         CASE("RHSCOMP")
+            nullify(id%RHSCOMP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%RHSCOMP(size_array1))
+               read(IN) id%RHSCOMP
+            endif
+         CASE("MEM_SUBTREE")
+            nullify(id%MEM_SUBTREE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MEM_SUBTREE(size_array1))
+               read(IN) id%MEM_SUBTREE
+            endif
+         CASE("COST_TRAV")
+            nullify(id%COST_TRAV)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%COST_TRAV(size_array1))
+               read(IN) id%COST_TRAV
+            endif
+         CASE("MY_ROOT_SBTR")
+            nullify(id%MY_ROOT_SBTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MY_ROOT_SBTR(size_array1))
+               read(IN) id%MY_ROOT_SBTR
+            endif
+         CASE("MY_FIRST_LEAF")
+            nullify(id%MY_FIRST_LEAF)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MY_FIRST_LEAF(size_array1))
+               read(IN) id%MY_FIRST_LEAF
+            endif
+         CASE("MY_NB_LEAF")
+            nullify(id%MY_NB_LEAF)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MY_NB_LEAF(size_array1))
+               read(IN) id%MY_NB_LEAF
+            endif
+         CASE("DEPTH_FIRST")
+            nullify(id%DEPTH_FIRST)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DEPTH_FIRST(size_array1))
+               read(IN) id%DEPTH_FIRST
+            endif
+         CASE("DEPTH_FIRST_SEQ")
+            nullify(id%DEPTH_FIRST_SEQ)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DEPTH_FIRST_SEQ(size_array1))
+               read(IN) id%DEPTH_FIRST_SEQ
+            endif
+         CASE("SBTR_ID")
+            nullify(id%SBTR_ID)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SBTR_ID(size_array1))
+               read(IN) id%SBTR_ID
+            endif
+         CASE("SCHED_DEP")
+            nullify(id%SCHED_DEP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHED_DEP(size_array1))
+               read(IN) id%SCHED_DEP
+            endif
+         CASE("SCHED_GRP")
+            nullify(id%SCHED_GRP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHED_GRP(size_array1))
+               read(IN) id%SCHED_GRP
+            endif
+         CASE("CROIX_MANU")
+            nullify(id%CROIX_MANU)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%CROIX_MANU(size_array1))
+               read(IN) id%CROIX_MANU
+            endif
+         CASE("WK_USER")
+            nullify(id%WK_USER)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%WK_USER(size_array1))
+               read(IN) id%WK_USER
+            endif
+         CASE("NBSA_LOCAL")
+            read(IN) id%NBSA_LOCAL
+         CASE("LWK_USER")
+            read(IN) id%LWK_USER
+         CASE("CB_SON_SIZE")
+            nullify(id%CB_SON_SIZE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%CB_SON_SIZE(size_array1))
+               read(IN) id%CB_SON_SIZE
+            endif
+         CASE("INSTANCE_NUMBER")
+            read(IN) id%INSTANCE_NUMBER
+         CASE("OOC_MAX_NB_NODES_FOR_ZONE")
+            read(IN) id%OOC_MAX_NB_NODES_FOR_ZONE
+         CASE("OOC_INODE_SEQUENCE")
+            nullify(id%OOC_INODE_SEQUENCE)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_INODE_SEQUENCE(size_array1,size_array2))
+               read(IN) id%OOC_INODE_SEQUENCE
+            endif
+         CASE("OOC_SIZE_OF_BLOCK")
+            nullify(id%OOC_SIZE_OF_BLOCK)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_SIZE_OF_BLOCK(size_array1,size_array2))
+               read(IN) id%OOC_SIZE_OF_BLOCK
+            endif
+         CASE("OOC_VADDR")
+            nullify(id%OOC_VADDR)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_VADDR(size_array1,size_array2))
+               read(IN) id%OOC_VADDR
+            endif
+         CASE("OOC_TOTAL_NB_NODES")
+            nullify(id%OOC_TOTAL_NB_NODES)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_TOTAL_NB_NODES(size_array1))
+               read(IN) id%OOC_TOTAL_NB_NODES
+            endif
+         CASE("OOC_NB_FILES")
+            nullify(id%OOC_NB_FILES)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_NB_FILES(size_array1))
+               read(IN) id%OOC_NB_FILES
+            endif
+         CASE("OOC_NB_FILE_TYPE")
+            read(IN) id%OOC_NB_FILE_TYPE
+         CASE("OOC_FILE_NAMES")
+            nullify(id%OOC_FILE_NAMES)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_FILE_NAMES(size_array1,size_array2))
+               read(IN) id%OOC_FILE_NAMES
+            endif
+         CASE("OOC_FILE_NAME_LENGTH")
+            nullify(id%OOC_FILE_NAME_LENGTH)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_FILE_NAME_LENGTH(size_array1))
+               read(IN) id%OOC_FILE_NAME_LENGTH
+            endif
+         CASE("PIVNUL_LIST")
+            nullify(id%PIVNUL_LIST)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PIVNUL_LIST(size_array1))
+               read(IN) id%PIVNUL_LIST
+            endif
+         CASE("SUP_PROC")
+            nullify(id%SUP_PROC)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SUP_PROC(size_array1,size_array2))
+               read(IN) id%SUP_PROC
+            endif
+         CASE("IPTR_WORKING")
+            nullify(id%IPTR_WORKING)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IPTR_WORKING(size_array1))
+               read(IN) id%IPTR_WORKING
+            endif
+         CASE("WORKING")
+            nullify(id%WORKING)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%WORKING(size_array1))
+               read(IN) id%WORKING
+            endif
+         CASE("root")
+        CASE("NBGRP")
+           read(IN) id%NBGRP
+        CASE("LRGROUPS")
+           nullify(id%LRGROUPS)
+           read(IN) size_array1
+           if(size_array1.EQ.-999) then
+              read(IN) dummy
+           else
+              allocate(id%LRGROUPS(size_array1))
+              read(IN) id%LRGROUPS
+           endif
+         CASE("SCHED_SBTR")
+            nullify(id%SCHED_SBTR)
+            read(IN) size_array1
+            IF(size_array1.EQ.-999) THEN
+               read(IN) dummy
+            ELSE
+               allocate(id%SCHED_SBTR(size_array1))
+               read(IN) id%SCHED_SBTR
+            ENDIF 
+        CASE("LPOOL_AFTER_L0_OMP")
+           read(IN) id%LPOOL_AFTER_L0_OMP
+        CASE("LPOOL_BEFORE_L0_OMP")
+           read(IN) id%LPOOL_BEFORE_L0_OMP
+        CASE("L_PHYS_L0_OMP")
+           read(IN) id%L_PHYS_L0_OMP
+        CASE("L_VIRT_L0_OMP")  
+           read(IN) id%L_VIRT_L0_OMP
+        CASE("LL0_OMP_MAPPING")
+           read(IN) id%LL0_OMP_MAPPING
+        CASE("THREAD_LA")
+           read(IN) id%THREAD_LA
+        CASE("IPOOL_AFTER_L0_OMP")
+           nullify(id%IPOOL_AFTER_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%IPOOL_AFTER_L0_OMP(size_array1))
+              read(IN) id%IPOOL_AFTER_L0_OMP
+           ENDIF 
+        CASE("IPOOL_BEFORE_L0_OMP")
+           nullify(id%IPOOL_BEFORE_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%IPOOL_BEFORE_L0_OMP(size_array1))
+              read(IN) id%IPOOL_BEFORE_L0_OMP
+           ENDIF 
+        CASE("PHYS_L0_OMP")
+           nullify(id%PHYS_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%PHYS_L0_OMP(size_array1))
+              read(IN) id%PHYS_L0_OMP
+           ENDIF 
+        CASE("VIRT_L0_OMP")
+           nullify(id%VIRT_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%VIRT_L0_OMP(size_array1))
+              read(IN) id%VIRT_L0_OMP
+           ENDIF
+        CASE("PERM_L0_OMP")
+           nullify(id%PERM_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%PERM_L0_OMP(size_array1))
+              read(IN) id%PERM_L0_OMP
+           ENDIF
+        CASE("PTR_LEAFS_L0_OMP")
+           nullify(id%PTR_LEAFS_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%PTR_LEAFS_L0_OMP(size_array1))
+              read(IN) id%PTR_LEAFS_L0_OMP
+           ENDIF
+        CASE("L0_OMP_MAPPING")
+           nullify(id%L0_OMP_MAPPING)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%L0_OMP_MAPPING(size_array1))
+              read(IN) id%L0_OMP_MAPPING
+           ENDIF 
+        CASE("IF_RESTARTING")
+           read(IN) id%IF_RESTARTING 
+        CASE("SINGULAR_VALUES")
+         read(IN) size_array1
+         if(size_array1.EQ.-999) then
+            read(IN) dummy
+         else
+            allocate(id%SINGULAR_VALUES(size_array1))
+            read(IN) id%SINGULAR_VALUES
+         endif  
+      CASE("NB_SINGULAR_VALUES")
+        write(IN) id%NB_SINGULAR_VALUES
+        CASE("pad0","pad1","pad2","pad3","pad4","pad5","pad8","pad11",
+     &          "pad111", "pad12","pad13","pad14")
+        CASE DEFAULT
+           id%INFOG(1)=-92
+           write(*,*) "IN CMUMPS_RESTART UNKNOWN VARIABLE IN "
+     &       // "STRUCTURE: "//  trim(adjustl(VARIABLES(i1)))
+           goto 101
+        END SELECT
+      ENDDO
+ 101  continue
+      close(IN)
+      if(error) goto 102
+      INROOT=1000+IN
+      INFILEROOT=trim(adjustl(INFILE)) // trim(adjustl("ROOT")) 
+     &     // trim(adjustl(STRING_ID)) 
+      open(UNIT=INROOT,FILE=INFILEROOT, STATUS='old',FORM='unformatted'
+     &     ,iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN CMUMPS_RESTART CANNOT OPEN FILE: "
+     &        //trim(adjustl(INFILEROOT))
+         goto 102
+      endif
+      DO i2=1,NBVARIABLES_ROOT
+         SELECT CASE(VARIABLES_ROOT(i2))
+      CASE("MBLOCK")
+         read(INROOT) id%root%MBLOCK
+      CASE("NBLOCK")
+         read(INROOT) id%root%NBLOCK
+      CASE("NPROW")
+         read(INROOT) id%root%NPROW
+      CASE("NPCOL")
+         read(INROOT) id%root%NPCOL
+      CASE("MYROW")
+         read(INROOT) id%root%MYROW
+      CASE("MYCOL")
+         read(INROOT) id%root%MYCOL
+      CASE("SCHUR_MLOC")
+         read(INROOT) id%root%SCHUR_MLOC
+      CASE("SCHUR_NLOC")
+         read(INROOT) id%root%SCHUR_NLOC
+      CASE("SCHUR_LLD")
+         read(INROOT) id%root%SCHUR_LLD
+      CASE("RHS_NLOC")
+         read(INROOT) id%root%RHS_NLOC
+      CASE("ROOT_SIZE")
+         read(INROOT) id%root%ROOT_SIZE
+      CASE("TOT_ROOT_SIZE")
+         read(INROOT) id%root%TOT_ROOT_SIZE
+      CASE("DESCRIPTOR")
+         read(INROOT) id%root%DESCRIPTOR
+      CASE("CNTXT_BLACS")
+         read(INROOT) id%root%CNTXT_BLACS
+      CASE("LPIV")
+         read(INROOT) id%root%LPIV
+      CASE("RG2L_ROW")
+         nullify(id%root%RG2L_ROW)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RG2L_ROW(size_array1))
+            read(INROOT) id%root%RG2L_ROW
+         endif
+      CASE("RG2L_COL")
+         nullify(id%root%RG2L_COL)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RG2L_COL(size_array1))
+            read(INROOT) id%root%RG2L_COL
+         endif
+      CASE("IPIV")
+         nullify(id%root%IPIV)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%IPIV(size_array1))
+            read(INROOT) id%root%IPIV
+         endif
+      CASE("RHS_CNTR_MASTER_ROOT")
+         nullify(id%root%RHS_CNTR_MASTER_ROOT)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RHS_CNTR_MASTER_ROOT(size_array1))
+            read(INROOT) id%root%RHS_CNTR_MASTER_ROOT
+         endif
+      CASE("SCHUR_POINTER")
+         nullify(id%root%SCHUR_POINTER)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SCHUR_POINTER(size_array1))
+            read(INROOT) id%root%SCHUR_POINTER
+         endif
+      CASE("QR_TAU")
+         nullify(id%root%QR_TAU)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%QR_TAU(size_array1))
+            read(INROOT) id%root%QR_TAU
+         endif
+      CASE("RHS_ROOT")
+         nullify(id%root%RHS_ROOT)
+         read(INROOT) size_array1,size_array2
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RHS_ROOT(size_array1,size_array2))
+            read(INROOT) id%root%RHS_ROOT
+         endif
+      CASE("QR_RCOND")
+         read(INROOT) id%root%QR_RCOND
+      CASE("yes")
+         read(INROOT) id%root%yes
+      CASE("gridinit_done")
+         read(INROOT) id%root%gridinit_done
+      CASE("SVD_U")
+         read(INROOT) size_array1,size_array2
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SVD_U(size_array1,size_array2))
+            read(INROOT) id%root%SVD_U
+         endif
+      CASE("SVD_VT")
+         read(INROOT) size_array1,size_array2
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SVD_VT(size_array1,size_array2))
+            read(INROOT) id%root%SVD_VT
+         endif
+      CASE("SINGULAR_VALUES")
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SINGULAR_VALUES(size_array1))
+            read(INROOT) id%root%SINGULAR_VALUES
+         endif  
+      CASE("NB_SINGULAR_VALUES")
+        write(INROOT) id%root%NB_SINGULAR_VALUES
+         CASE("rootpad0","rootpad1","rootpad2","rootpad",
+     &        "rootpad3")
+      CASE DEFAULT
+         id%INFOG(1)=-92
+         write(*,*) "IN CMUMPS_RESTART UNKNOWN VARIABLE "
+     &        // "IN ROOT: "// trim(adjustl(VARIABLES_ROOT(i2)))
+         goto 102
+      END SELECT  
+      ENDDO
+      if(id%root%gridinit_done) then
+         id%root%CNTXT_BLACS = id%COMM_NODES
+         CALL blacs_gridinit( id%root%CNTXT_BLACS, 'R',
+     &        id%root%NPROW, id%root%NPCOL )
+         id%root%gridinit_done = .TRUE.
+      endif
+ 102  continue
+      close(INROOT)
+      END SUBROUTINE CMUMPS_RESTART
diff -ruN MUMPS_5.1.2/src/dmumps_restart.F mumps-5.1.2-aster7/src/dmumps_restart.F
--- MUMPS_5.1.2/src/dmumps_restart.F	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/src/dmumps_restart.F	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,2648 @@
+C
+C  This file is part of MUMPS 5.0.2, released
+C  on Fri Jul 15 09:12:54 UTC 2016
+C
+C
+C  Copyright 1991-2016 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria,
+C  University of Bordeaux.
+C
+C  This version of MUMPS is provided to you free of charge. It is
+C  released under the CeCILL-C license:
+C  http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
+C
+      SUBROUTINE DMUMPS_STOP(id,OUTFILE)
+      USE DMUMPS_STRUC_DEF
+      IMPLICIT NONE
+      INCLUDE 'mpif.h'
+      CHARACTER(len=*), intent(in) :: OUTFILE
+      INTEGER::i1,i2,NBVARIABLES,NBVARIABLES_ROOT
+      INTEGER::OUT,err,OUTROOT
+      CHARACTER(len=100), allocatable, dimension(:)::VARIABLES
+      CHARACTER(len=100), allocatable, dimension(:)::VARIABLES_ROOT
+      CHARACTER(len=100):: OUTFILEMAIN,OUTFILEROOT
+      CHARACTER(len=3) :: STRING_ID
+      LOGICAL :: error
+      INTEGER MASTER
+      PARAMETER( MASTER = 0 )
+      TYPE (DMUMPS_STRUC) :: id
+      id%IF_RESTARTING=.TRUE.
+      NBVARIABLES=171
+      allocate(VARIABLES(NBVARIABLES))
+      VARIABLES(171)="NB_SINGULAR_VALUES"
+      VARIABLES(170)="SINGULAR_VALUES"
+      VARIABLES(169)="IF_RESTARTING"
+      VARIABLES(168)="L0_OMP_MAPPING"
+      VARIABLES(167)="PTR_LEAFS_L0_OMP"
+      VARIABLES(166)="PERM_L0_OMP"
+      VARIABLES(165)="VIRT_L0_OMP"
+      VARIABLES(164)="PHYS_L0_OMP"
+      VARIABLES(163)="IPOOL_AFTER_L0_OMP"
+      VARIABLES(162)="IPOOL_BEFORE_L0_OMP"
+      VARIABLES(161)="THREAD_LA"
+      VARIABLES(160)="LL0_OMP_MAPPING"
+      VARIABLES(159)="L_VIRT_L0_OMP"
+      VARIABLES(158)="L_PHYS_L0_OMP"
+      VARIABLES(157)="LPOOL_BEFORE_L0_OMP"
+      VARIABLES(156)="LPOOL_AFTER_L0_OMP"
+      VARIABLES(155)="NBGRP"
+      VARIABLES(154)="LRGROUPS"
+      VARIABLES(153)="root"
+      VARIABLES(152)="WORKING"
+      VARIABLES(151)="IPTR_WORKING"
+      VARIABLES(150)="pad14"
+      VARIABLES(149)="SUP_PROC"
+      VARIABLES(148)="PIVNUL_LIST"
+      VARIABLES(147)="OOC_FILE_NAME_LENGTH"
+      VARIABLES(146)="OOC_FILE_NAMES"
+      VARIABLES(145)="OOC_NB_FILE_TYPE"
+      VARIABLES(144)="OOC_NB_FILES"
+      VARIABLES(143)="OOC_TOTAL_NB_NODES"
+      VARIABLES(142)="OOC_VADDR"
+      VARIABLES(141)="OOC_SIZE_OF_BLOCK"
+      VARIABLES(140)="pad13"
+      VARIABLES(139)="OOC_INODE_SEQUENCE"
+      VARIABLES(138)="OOC_MAX_NB_NODES_FOR_ZONE"
+      VARIABLES(137)="INSTANCE_NUMBER"
+      VARIABLES(136)="pad12"
+      VARIABLES(135)="CB_SON_SIZE"
+      VARIABLES(134)="DKEEP"
+      VARIABLES(133)="LWK_USER"
+      VARIABLES(132)="NBSA_LOCAL"
+      VARIABLES(131)="WK_USER"
+      VARIABLES(130)="CROIX_MANU"
+      VARIABLES(129)="SCHED_SBTR"
+      VARIABLES(128)="SCHED_GRP"
+      VARIABLES(127)="SCHED_DEP"
+      VARIABLES(126)="SBTR_ID"
+      VARIABLES(125)="DEPTH_FIRST_SEQ"
+      VARIABLES(124)="DEPTH_FIRST"
+      VARIABLES(123)="MY_NB_LEAF"
+      VARIABLES(122)="MY_FIRST_LEAF"
+      VARIABLES(121)="MY_ROOT_SBTR"
+      VARIABLES(120)="COST_TRAV"
+      VARIABLES(119)="MEM_SUBTREE"
+      VARIABLES(118)="RHSCOMP"
+      VARIABLES(117)="POSINRHSCOMP_COL"
+      VARIABLES(116)="POSINRHSCOMP_ROW"
+      VARIABLES(115)="POSINRHSCOMP_COL_ALLOC"
+      VARIABLES(114)="MEM_DIST"
+      VARIABLES(113)="I_AM_CAND"
+      VARIABLES(112)="TAB_POS_IN_PERE"
+      VARIABLES(111)="FUTURE_NIV2"
+      VARIABLES(110)="ISTEP_TO_INIV2"
+      VARIABLES(109)="CANDIDATES"
+      VARIABLES(108)="ELTPROC"
+      VARIABLES(107)="pad11"
+      VARIABLES(106)="NA_ELT"
+      VARIABLES(105)="LELTVAR"
+      VARIABLES(104)="NELT_loc"
+      VARIABLES(103)="DBLARR"
+      VARIABLES(102)="INTARR"
+      VARIABLES(101)="PROCNODE"
+      VARIABLES(100)="S"
+      VARIABLES(99)="PTRFAC"
+      VARIABLES(98)="PTLUST_S"
+      VARIABLES(97)="PROCNODE_STEPS"
+      VARIABLES(96)="NA"
+      VARIABLES(95)="FRTELT"
+      VARIABLES(94)="FRTPTR"
+      VARIABLES(93)="PTRAR"
+      VARIABLES(92)="FILS"
+      VARIABLES(91)="DAD_STEPS"
+      VARIABLES(90)="FRERE_STEPS"
+      VARIABLES(89)="Step2node"
+      VARIABLES(88)="ND_STEPS"
+      VARIABLES(87)="NE_STEPS"
+      VARIABLES(86)="STEP"
+      VARIABLES(85)="NBSA"
+      VARIABLES(84)="LNA"
+      VARIABLES(83)="KEEP"
+      VARIABLES(82)="Deficiency"
+      VARIABLES(81)="MAXIS1"
+      VARIABLES(80)="IS1"
+      VARIABLES(79)="IS"
+      VARIABLES(78)="BUFR"
+      VARIABLES(77)="POIDS"
+      VARIABLES(76)="LBUFR_BYTES"
+      VARIABLES(75)="LBUFR"
+      VARIABLES(74)="ASS_IRECV"
+      VARIABLES(73)="NSLAVES"
+      VARIABLES(72)="NPROCS"
+      VARIABLES(71)="MYID"
+      VARIABLES(70)="COMM_LOAD"
+      VARIABLES(69)="MYID_NODES"
+      VARIABLES(68)="COMM_NODES"
+      VARIABLES(67)="INST_Number"
+      VARIABLES(66)="MAX_SURF_MASTER"
+      VARIABLES(65)="KEEP8"
+      VARIABLES(64)="pad8"
+      VARIABLES(63)="WRITE_PROBLEM"
+      VARIABLES(62)="OOC_PREFIX"
+      VARIABLES(61)="OOC_TMPDIR"
+      VARIABLES(60)="VERSION_NUMBER"
+      VARIABLES(59)="MAPPING"
+      VARIABLES(58)="LISTVAR_SCHUR"
+      VARIABLES(57)="SCHUR_CINTERFACE"
+      VARIABLES(56)="SCHUR"
+      VARIABLES(55)="SIZE_SCHUR"
+      VARIABLES(54)="SCHUR_LLD"
+      VARIABLES(53)="SCHUR_NLOC"
+      VARIABLES(52)="SCHUR_MLOC"
+      VARIABLES(51)="NBLOCK"
+      VARIABLES(50)="MBLOCK"
+      VARIABLES(49)="NPCOL"
+      VARIABLES(48)="NPROW"
+      VARIABLES(47)="UNS_PERM"
+      VARIABLES(46)="SYM_PERM"
+      VARIABLES(45)="RINFOG"
+      VARIABLES(44)="RINFO"
+      VARIABLES(43)="CNTL"
+      VARIABLES(42)="COST_SUBTREES"
+      VARIABLES(41)="INFOG"
+      VARIABLES(40)="INFO"
+      VARIABLES(39)="ICNTL"
+      VARIABLES(38)="pad5"
+      VARIABLES(37)="LREDRHS"
+      VARIABLES(36)="LSOL_loc"
+      VARIABLES(35)="NZ_RHS"
+      VARIABLES(34)="NRHS"
+      VARIABLES(33)="LRHS"
+      VARIABLES(32)="ISOL_loc"
+      VARIABLES(31)="IRHS_PTR"
+      VARIABLES(30)="IRHS_SPARSE"
+      VARIABLES(29)="SOL_loc"
+      VARIABLES(28)="RHS_SPARSE"
+      VARIABLES(27)="REDRHS"
+      VARIABLES(26)="RHS"
+      VARIABLES(25)="PERM_IN"
+      VARIABLES(24)="pad4"
+      VARIABLES(23)="A_ELT"
+      VARIABLES(22)="ELTVAR"
+      VARIABLES(21)="ELTPTR"
+      VARIABLES(20)="pad3"
+      VARIABLES(19)="NELT"
+      VARIABLES(18)="pad2"
+      VARIABLES(17)="A_loc"
+      VARIABLES(16)="JCN_loc"
+      VARIABLES(15)="IRN_loc"
+      VARIABLES(14)="pad1"
+      VARIABLES(13)="NZ_loc"
+      VARIABLES(12)="pad0"
+      VARIABLES(11)="ROWSCA"
+      VARIABLES(10)="COLSCA"
+      VARIABLES(9)="JCN"
+      VARIABLES(8)="IRN"
+      VARIABLES(7)="A"
+      VARIABLES(6)="NZ"
+      VARIABLES(5)="N"
+      VARIABLES(4)="JOB"
+      VARIABLES(3)="PAR"
+      VARIABLES(2)="SYM"
+      VARIABLES(1)="COMM"
+      NBVARIABLES_ROOT=34
+      allocate(VARIABLES_ROOT(NBVARIABLES_ROOT))
+      VARIABLES_ROOT(34)="NB_SINGULAR_VALUES"
+      VARIABLES_ROOT(33)="SINGULAR_VALUES"
+      VARIABLES_ROOT(32)="SVD_VT"
+      VARIABLES_ROOT(31)="SVD_U"
+      VARIABLES_ROOT(30)="gridinit_done"
+      VARIABLES_ROOT(29)="yes"
+      VARIABLES_ROOT(28)="rootpad3"
+      VARIABLES_ROOT(27)="QR_RCOND"
+      VARIABLES_ROOT(26)="rootpad"
+      VARIABLES_ROOT(25)="RHS_ROOT"
+      VARIABLES_ROOT(24)="rootpad2"
+      VARIABLES_ROOT(23)="QR_TAU"
+      VARIABLES_ROOT(22)="SCHUR_POINTER"
+      VARIABLES_ROOT(21)="RHS_CNTR_MASTER_ROOT"
+      VARIABLES_ROOT(20)="rootpad1"
+      VARIABLES_ROOT(19)="IPIV"
+      VARIABLES_ROOT(18)="RG2L_COL"
+      VARIABLES_ROOT(17)="RG2L_ROW"
+      VARIABLES_ROOT(16)="rootpad0"
+      VARIABLES_ROOT(15)="LPIV"
+      VARIABLES_ROOT(14)="CNTXT_BLACS"
+      VARIABLES_ROOT(13)="DESCRIPTOR"
+      VARIABLES_ROOT(12)="TOT_ROOT_SIZE"
+      VARIABLES_ROOT(11)="ROOT_SIZE"
+      VARIABLES_ROOT(10)="RHS_NLOC"
+      VARIABLES_ROOT(9)="SCHUR_LLD"
+      VARIABLES_ROOT(8)="SCHUR_NLOC"
+      VARIABLES_ROOT(7)="SCHUR_MLOC"
+      VARIABLES_ROOT(6)="MYCOL"
+      VARIABLES_ROOT(5)="MYROW"
+      VARIABLES_ROOT(4)="NPCOL"
+      VARIABLES_ROOT(3)="NPROW"
+      VARIABLES_ROOT(2)="NBLOCK"
+      VARIABLES_ROOT(1)="MBLOCK"
+      if(((id%ICNTL(3).GT.0).AND.(id%MYID .EQ. MASTER))) then
+         write(*,*) "DUMPING MUMPS STRUCTURE IN FILE:",OUTFILE
+      endif
+      error=.false.
+      write (STRING_ID, '(i3)') id%MYID
+      OUT=42+id%MYID
+      OUTFILEMAIN=trim(adjustl(OUTFILE)) // trim(adjustl(STRING_ID))
+      open(UNIT=OUT,FILE=OUTFILEMAIN,STATUS='replace',
+     &     form='unformatted',iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN DMUMPS_STOP CANNOT OPEN FILE: "
+     &        //trim(adjustl(OUTFILEMAIN))
+         error=.true.
+         goto 100
+      endif      
+      DO i1=1,NBVARIABLES 
+         SELECT CASE(trim(adjustl(VARIABLES(i1))))
+         CASE("COMM") 
+         CASE("SYM")
+         CASE("PAR")
+         CASE("JOB")
+            write(OUT) id%JOB
+         CASE("N")
+            write(OUT) id%N
+         CASE("ICNTL")
+            write(OUT) id%ICNTL
+         CASE("INFO")
+            write(OUT) id%INFO
+         CASE("INFOG")
+            write(OUT) id%INFOG
+         CASE("COST_SUBTREES")
+            write(OUT) id%COST_SUBTREES
+         CASE("CNTL")
+            write(OUT) id%CNTL
+         CASE("RINFO")
+            write(OUT) id%RINFO
+         CASE("RINFOG")
+            write(OUT) id%RINFOG
+         CASE("KEEP8")
+            write(OUT) id%KEEP8
+         CASE("KEEP")
+            write(OUT) id%KEEP
+         CASE("DKEEP")
+            write(OUT) id%DKEEP    
+         CASE("NZ")
+            write(OUT) id%NZ
+         CASE("A")
+            IF(associated(id%A)) THEN
+               write(OUT) size(id%A,1)
+               write(OUT) id%A
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IRN")
+            IF(associated(id%IRN)) THEN
+               write(OUT) size(id%IRN,1)
+               write(OUT) id%IRN
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("JCN")
+            IF(associated(id%JCN)) THEN
+               write(OUT) size(id%JCN,1)
+               write(OUT) id%JCN
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("COLSCA")
+            IF(associated(id%COLSCA)) THEN
+               write(OUT) size(id%COLSCA,1)
+               write(OUT) id%COLSCA
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF 
+         CASE("ROWSCA")
+            IF(associated(id%ROWSCA)) THEN
+               write(OUT) size(id%ROWSCA,1)
+               write(OUT) id%ROWSCA
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NZ_loc")
+            write(OUT) id%NZ_loc
+         CASE("IRN_loc")
+            IF(associated(id%IRN_loc)) THEN
+               write(OUT) size(id%IRN_loc,1)
+               write(OUT) id%IRN_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("JCN_loc")
+            IF(associated(id%JCN_loc)) THEN
+               write(OUT) size(id%JCN_loc,1)
+               write(OUT) id%JCN_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("A_loc")
+            IF(associated(id%A_loc)) THEN
+               write(OUT) size(id%A_loc,1)
+               write(OUT) id%A_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NELT")
+            write(OUT) id%NELT
+         CASE("ELTPTR")
+            IF(associated(id%ELTPTR)) THEN
+               write(OUT) size(id%ELTPTR,1)
+               write(OUT) id%ELTPTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("ELTVAR")
+            IF(associated(id%ELTVAR)) THEN
+               write(OUT) size(id%ELTVAR,1)
+               write(OUT) id%ELTVAR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("A_ELT")
+            IF(associated(id%A_ELT)) THEN
+               write(OUT) size(id%A_ELT,1)
+               write(OUT) id%A_ELT
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PERM_IN")
+            IF(associated(id%PERM_IN)) THEN
+               write(OUT) size(id%PERM_IN,1)
+               write(OUT) id%PERM_IN
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("RHS")
+            IF(associated(id%RHS)) THEN
+               write(OUT) size(id%RHS,1)
+               write(OUT) id%RHS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("REDRHS")
+            IF(associated(id%REDRHS)) THEN
+               write(OUT) size(id%REDRHS,1)
+               write(OUT) id%REDRHS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("RHS_SPARSE")
+            IF(associated(id%RHS_SPARSE)) THEN
+               write(OUT) size(id%RHS_SPARSE,1)
+               write(OUT) id%RHS_SPARSE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SOL_loc")
+            IF(associated(id%SOL_loc)) THEN
+               write(OUT) size(id%SOL_loc,1)
+               write(OUT) id%SOL_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IRHS_SPARSE")
+            IF(associated(id%IRHS_SPARSE)) THEN
+               write(OUT) size(id%IRHS_SPARSE,1)
+               write(OUT) id%IRHS_SPARSE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IRHS_PTR")
+            IF(associated(id%IRHS_PTR)) THEN
+               write(OUT) size(id%IRHS_PTR,1)
+               write(OUT) id%IRHS_PTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("ISOL_loc")
+            IF(associated(id%ISOL_loc)) THEN
+               write(OUT) size(id%ISOL_loc,1)
+               write(OUT) id%ISOL_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("LRHS")
+            write(OUT) id%LRHS
+         CASE("NRHS")
+            write(OUT) id%NRHS
+         CASE("NZ_RHS")
+            write(OUT) id%NZ_RHS
+         CASE("LSOL_loc")
+            write(OUT) id%LSOL_loc
+         CASE("LREDRHS")
+            write(OUT) id%LREDRHS
+         CASE("SYM_PERM")
+            IF(associated(id%SYM_PERM)) THEN
+               write(OUT) size(id%SYM_PERM,1)
+               write(OUT) id%SYM_PERM
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("UNS_PERM")
+            IF(associated(id%UNS_PERM)) THEN
+               write(OUT) size(id%UNS_PERM,1)
+               write(OUT) id%UNS_PERM
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NPROW")
+            write(OUT) id%NPROW
+         CASE("NPCOL")
+            write(OUT) id%NPCOL
+         CASE("MBLOCK")
+            write(OUT) id%MBLOCK
+         CASE("NBLOCK")
+            write(OUT) id%NBLOCK
+         CASE("SCHUR_MLOC")
+            write(OUT) id%SCHUR_MLOC
+         CASE("SCHUR_NLOC")
+            write(OUT) id%SCHUR_NLOC
+         CASE("SCHUR_LLD")
+            write(OUT) id%SCHUR_LLD
+         CASE("SIZE_SCHUR")
+            write(OUT) id%SIZE_SCHUR
+         CASE("SCHUR")
+            IF(associated(id%SCHUR)) THEN
+               write(OUT) size(id%SCHUR,1)
+               write(OUT) id%SCHUR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SCHUR_CINTERFACE")
+            IF(associated(id%SCHUR_CINTERFACE)) THEN
+               write(OUT) size(id%SCHUR_CINTERFACE,1)
+               write(OUT) id%SCHUR_CINTERFACE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("LISTVAR_SCHUR")
+            IF(associated(id%LISTVAR_SCHUR)) THEN
+               write(OUT) size(id%LISTVAR_SCHUR,1)
+               write(OUT) id%LISTVAR_SCHUR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MAPPING")
+            IF(associated(id%MAPPING)) THEN
+               write(OUT) size(id%MAPPING,1)
+               write(OUT) id%MAPPING
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("VERSION_NUMBER")
+            write(OUT) id%VERSION_NUMBER
+         CASE("OOC_TMPDIR")
+            write(OUT) id%OOC_TMPDIR
+         CASE("OOC_PREFIX")
+            write(OUT) id%OOC_PREFIX
+         CASE("WRITE_PROBLEM")
+            write(OUT) id%WRITE_PROBLEM
+         CASE("MAX_SURF_MASTER")
+            write(OUT) id%MAX_SURF_MASTER
+         CASE("INST_Number")
+            write(OUT) id%INST_Number
+         CASE("COMM_NODES")
+            write(OUT) id%COMM_NODES
+         CASE("MYID_NODES")
+            write(OUT) id%MYID_NODES
+         CASE("COMM_LOAD")
+            write(OUT) id%COMM_LOAD
+         CASE("MYID")
+            write(OUT) id%MYID
+         CASE("NPROCS")
+            write(OUT) id%NPROCS
+         CASE("NSLAVES")
+            write(OUT) id%NSLAVES
+         CASE("ASS_IRECV")
+            write(OUT) id%ASS_IRECV
+         CASE("LBUFR")
+            write(OUT) id%LBUFR
+         CASE("LBUFR_BYTES")
+            write(OUT) id%LBUFR_BYTES
+         CASE("POIDS")
+            IF(associated(id%POIDS)) THEN 
+               write(OUT) size(id%POIDS,1)
+               write(OUT) id%POIDS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("BUFR")
+            IF(associated(id%BUFR)) THEN 
+               write(OUT) size(id%BUFR,1)
+               write(OUT) id%BUFR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IS")
+            IF(associated(id%IS)) THEN 
+               write(OUT) size(id%IS,1)
+               write(OUT) id%IS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IS1")
+            IF(associated(id%IS1)) THEN 
+               write(OUT) size(id%IS1,1)
+               write(OUT) id%IS1
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MAXIS1")
+            write(OUT) id%MAXIS1
+         CASE("Deficiency")
+            write(OUT) id%Deficiency
+         CASE("LNA")
+            write(OUT) id%LNA
+         CASE("NBSA")
+            write(OUT) id%NBSA
+         CASE("STEP")
+            IF(associated(id%STEP)) THEN
+               write(OUT) size(id%STEP,1)
+               write(OUT) id%STEP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NE_STEPS")
+            IF(associated(id%NE_STEPS)) THEN
+               write(OUT) size(id%NE_STEPS,1)
+               write(OUT) id%NE_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("ND_STEPS")
+            IF(associated(id%ND_STEPS)) THEN
+               write(OUT) size(id%ND_STEPS,1)
+               write(OUT) id%ND_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("Step2node")
+            IF(associated(id%Step2node)) THEN
+               write(OUT) size(id%Step2node,1)
+               write(OUT) id%Step2node
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FRERE_STEPS")
+            IF(associated(id%FRERE_STEPS)) THEN
+               write(OUT) size(id%FRERE_STEPS,1)
+               write(OUT) id%FRERE_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DAD_STEPS")
+            IF(associated(id%DAD_STEPS)) THEN
+               write(OUT) size(id%DAD_STEPS,1)
+               write(OUT) id%DAD_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FILS")
+            IF(associated(id%FILS)) THEN
+               write(OUT) size(id%FILS,1)
+               write(OUT) id%FILS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PTRAR")
+            IF(associated(id%PTRAR)) THEN
+               write(OUT) size(id%PTRAR,1)
+               write(OUT) id%PTRAR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FRTPTR")
+            IF(associated(id%FRTPTR)) THEN
+               write(OUT) size(id%FRTPTR,1)
+               write(OUT) id%FRTPTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FRTELT")
+            IF(associated(id%FRTELT)) THEN
+               write(OUT) size(id%FRTELT,1)
+               write(OUT) id%FRTELT
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NA")
+            IF(associated(id%NA)) THEN
+               write(OUT) size(id%NA,1)
+               write(OUT) id%NA
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PROCNODE_STEPS")
+            IF(associated(id%PROCNODE_STEPS)) THEN
+               write(OUT) size(id%PROCNODE_STEPS,1)
+               write(OUT) id%PROCNODE_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PTLUST_S")
+            IF(associated(id%PTLUST_S)) THEN
+               write(OUT) size(id%PTLUST_S,1)
+               write(OUT) id%PTLUST_S
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PTRFAC")
+            IF(associated(id%PTRFAC)) THEN
+               write(OUT) size(id%PTRFAC,1)
+               write(OUT) id%PTRFAC
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("S")
+            IF(associated(id%S)) THEN
+               write(OUT) id%KEEP8(23)
+               write(OUT) id%S
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PROCNODE")
+            IF(associated(id%PROCNODE)) THEN
+               write(OUT) size(id%PROCNODE,1)
+               write(OUT) id%PROCNODE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("INTARR")
+            IF(associated(id%INTARR)) THEN
+               write(OUT) size(id%INTARR,1)
+               write(OUT) id%INTARR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DBLARR")
+            IF(associated(id%DBLARR)) THEN
+               write(OUT) size(id%DBLARR,1)
+               write(OUT) id%DBLARR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NELT_loc")
+            write(OUT) id%NELT_loc
+         CASE("LELTVAR")
+            write(OUT) id%LELTVAR
+         CASE("NA_ELT")
+            write(OUT) id%NA_ELT
+         CASE("ELTPROC")
+            IF(associated(id%ELTPROC)) THEN
+               write(OUT) size(id%ELTPROC,1)
+               write(OUT) id%ELTPROC
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("CANDIDATES")
+            IF(associated(id%CANDIDATES)) THEN
+               write(OUT) size(id%CANDIDATES,1)
+     &              ,size(id%CANDIDATES,2)
+               write(OUT) id%CANDIDATES
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("ISTEP_TO_INIV2")
+            IF(associated(id%ISTEP_TO_INIV2)) THEN
+               write(OUT) size(id%ISTEP_TO_INIV2,1)
+               write(OUT) id%ISTEP_TO_INIV2
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FUTURE_NIV2")
+            IF(associated(id%FUTURE_NIV2)) THEN
+               write(OUT) size(id%FUTURE_NIV2,1)
+               write(OUT) id%FUTURE_NIV2
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("TAB_POS_IN_PERE")
+            IF(associated(id%TAB_POS_IN_PERE)) THEN
+               write(OUT) size(id%TAB_POS_IN_PERE,1)
+     &              ,size(id%TAB_POS_IN_PERE,2)
+               write(OUT) id%TAB_POS_IN_PERE
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("I_AM_CAND")
+            IF(associated(id%I_AM_CAND)) THEN
+               write(OUT) size(id%I_AM_CAND,1)
+               write(OUT) id%I_AM_CAND
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MEM_DIST")
+            IF(associated(id%MEM_DIST)) THEN
+               write(OUT) size(id%MEM_DIST,1)
+               write(OUT) id%MEM_DIST
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("POSINRHSCOMP_ROW")
+            IF(associated(id%POSINRHSCOMP_ROW)) THEN 
+               write(OUT) size(id%POSINRHSCOMP_ROW,1)
+               write(OUT) id%POSINRHSCOMP_ROW
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("POSINRHSCOMP_COL_ALLOC")
+            write(OUT) id%POSINRHSCOMP_COL_ALLOC
+         CASE("POSINRHSCOMP_COL")
+            IF(associated(id%POSINRHSCOMP_COL)) THEN
+               IF(id%POSINRHSCOMP_COL_ALLOC) THEN
+                  write(OUT) size(id%POSINRHSCOMP_COL,1)
+                  write(OUT) id%POSINRHSCOMP_COL
+               ELSE
+                  write(OUT) size(id%POSINRHSCOMP_COL,1)
+                  write(OUT) -999
+               ENDIF
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("RHSCOMP")
+            IF(associated(id%RHSCOMP)) THEN
+               write(OUT) size(id%RHSCOMP,1)
+               write(OUT) id%RHSCOMP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MEM_SUBTREE")
+            IF(associated(id%MEM_SUBTREE)) THEN
+               write(OUT) size(id%MEM_SUBTREE,1)
+               write(OUT) id%MEM_SUBTREE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("COST_TRAV")
+            IF(associated(id%COST_TRAV)) THEN
+               write(OUT) size(id%COST_TRAV,1)
+               write(OUT) id%COST_TRAV
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MY_ROOT_SBTR")
+            IF(associated(id%MY_ROOT_SBTR)) THEN
+               write(OUT) size(id%MY_ROOT_SBTR,1)
+               write(OUT) id%MY_ROOT_SBTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MY_FIRST_LEAF")
+            IF(associated(id%MY_FIRST_LEAF)) THEN
+               write(OUT) size(id%MY_FIRST_LEAF,1)
+               write(OUT) id%MY_FIRST_LEAF
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MY_NB_LEAF")
+            IF(associated(id%MY_NB_LEAF)) THEN
+               write(OUT) size(id%MY_NB_LEAF,1)
+               write(OUT) id%MY_NB_LEAF
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DEPTH_FIRST")
+            IF(associated(id%DEPTH_FIRST)) THEN
+               write(OUT) size(id%DEPTH_FIRST,1)
+               write(OUT) id%DEPTH_FIRST
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DEPTH_FIRST_SEQ")
+            IF(associated(id%DEPTH_FIRST_SEQ)) THEN
+               write(OUT) size(id%DEPTH_FIRST_SEQ,1)
+               write(OUT) id%DEPTH_FIRST_SEQ
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SBTR_ID")
+            IF(associated(id%SBTR_ID)) THEN
+               write(OUT) size(id%SBTR_ID,1)
+               write(OUT) id%SBTR_ID
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SCHED_DEP")
+            IF(associated(id%SCHED_DEP)) THEN
+               write(OUT) size(id%SCHED_DEP,1)
+               write(OUT) id%SCHED_DEP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SCHED_GRP")
+            IF(associated(id%SCHED_GRP)) THEN
+               write(OUT) size(id%SCHED_GRP,1)
+               write(OUT) id%SCHED_GRP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("CROIX_MANU")
+            IF(associated(id%CROIX_MANU)) THEN
+               write(OUT) size(id%CROIX_MANU,1)
+               write(OUT) id%CROIX_MANU
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("WK_USER")
+            IF(associated(id%WK_USER)) THEN
+               write(OUT) id%KEEP8(24)
+               write(OUT) id%WK_USER
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NBSA_LOCAL")
+            write(OUT) id%NBSA_LOCAL
+         CASE("LWK_USER")
+            write(OUT) id%LWK_USER
+         CASE("CB_SON_SIZE")
+            IF(associated(id%CB_SON_SIZE)) THEN
+               write(OUT) size(id%CB_SON_SIZE,1)
+               write(OUT) id%CB_SON_SIZE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("INSTANCE_NUMBER")
+            write(OUT) id%INSTANCE_NUMBER
+         CASE("OOC_MAX_NB_NODES_FOR_ZONE")
+            write(OUT) id%OOC_MAX_NB_NODES_FOR_ZONE
+         CASE("OOC_INODE_SEQUENCE")
+            IF(associated(id%OOC_INODE_SEQUENCE)) THEN
+               write(OUT) size(id%OOC_INODE_SEQUENCE,1)
+     &              ,size(id%OOC_INODE_SEQUENCE,2)
+               write(OUT) id%OOC_INODE_SEQUENCE
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_SIZE_OF_BLOCK")
+            IF(associated(id%OOC_SIZE_OF_BLOCK)) THEN
+               write(OUT) size(id%OOC_SIZE_OF_BLOCK,1)
+     &              ,size(id%OOC_SIZE_OF_BLOCK,2)  
+               write(OUT) id%OOC_SIZE_OF_BLOCK
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_VADDR")
+            IF(associated(id%OOC_VADDR)) THEN
+               write(OUT) size(id%OOC_VADDR,1),size(id%OOC_VADDR,2)
+               write(OUT) id%OOC_VADDR
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_TOTAL_NB_NODES")
+            IF(associated(id%OOC_TOTAL_NB_NODES)) THEN
+               write(OUT) size(id%OOC_TOTAL_NB_NODES,1)
+               write(OUT) id%OOC_TOTAL_NB_NODES
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_NB_FILES")
+            IF(associated(id%OOC_NB_FILES)) THEN
+               write(OUT) size(id%OOC_NB_FILES,1)
+               write(OUT) id%OOC_NB_FILES
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_NB_FILE_TYPE")
+            write(OUT) id%OOC_NB_FILE_TYPE
+         CASE("OOC_FILE_NAMES")
+            IF(associated(id%OOC_FILE_NAMES)) THEN
+               write(OUT) size(id%OOC_FILE_NAMES,1)
+     &              ,size(id%OOC_FILE_NAMES,2)
+               write(OUT) id%OOC_FILE_NAMES
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_FILE_NAME_LENGTH")
+            IF(associated(id%OOC_FILE_NAME_LENGTH)) THEN
+               write(OUT) size(id%OOC_FILE_NAME_LENGTH,1)
+               write(OUT) id%OOC_FILE_NAME_LENGTH
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PIVNUL_LIST")
+            IF(associated(id%PIVNUL_LIST)) THEN
+               write(OUT) size(id%PIVNUL_LIST,1)
+               write(OUT) id%PIVNUL_LIST
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SUP_PROC")
+            IF(associated(id%SUP_PROC)) THEN
+               write(OUT) size(id%SUP_PROC,1),size(id%SUP_PROC,2)
+               write(OUT) id%SUP_PROC
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("IPTR_WORKING")
+            IF(associated(id%IPTR_WORKING)) THEN
+               write(OUT) size(id%IPTR_WORKING,1)
+               write(OUT) id%IPTR_WORKING
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("WORKING")
+            IF(associated(id%WORKING)) THEN
+               write(OUT) size(id%WORKING,1)
+               write(OUT) id%WORKING
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("root")
+         CASE("NBGRP")
+           write(OUT) id%NBGRP
+        CASE("LRGROUPS")
+           IF(associated(id%LRGROUPS)) THEN
+              write(OUT) size(id%LRGROUPS,1)
+              write(OUT) id%LRGROUPS
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("SCHED_SBTR")
+           IF(associated(id%SCHED_SBTR)) THEN
+              write(OUT) size(id%SCHED_SBTR,1)
+              write(OUT) id%SCHED_SBTR
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("LPOOL_AFTER_L0_OMP")
+           write(OUT) id%LPOOL_AFTER_L0_OMP
+        CASE("LPOOL_BEFORE_L0_OMP")
+           write(OUT) id%LPOOL_BEFORE_L0_OMP
+        CASE("L_PHYS_L0_OMP")
+           write(OUT) id%L_PHYS_L0_OMP
+        CASE("L_VIRT_L0_OMP")        
+           write(OUT) id%L_VIRT_L0_OMP
+        CASE("LL0_OMP_MAPPING")
+           write(OUT) id%LL0_OMP_MAPPING
+        CASE("THREAD_LA")
+           write(OUT) id%THREAD_LA
+        CASE("IPOOL_AFTER_L0_OMP")
+           IF(associated(id%IPOOL_AFTER_L0_OMP)) THEN
+              write(OUT) size(id%IPOOL_AFTER_L0_OMP,1)
+              write(OUT) id%IPOOL_AFTER_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("IPOOL_BEFORE_L0_OMP")
+           IF(associated(id%IPOOL_BEFORE_L0_OMP)) THEN
+              write(OUT) size(id%IPOOL_BEFORE_L0_OMP,1)
+              write(OUT) id%IPOOL_BEFORE_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("PHYS_L0_OMP")
+           IF(associated(id%PHYS_L0_OMP)) THEN
+              write(OUT) size(id%PHYS_L0_OMP,1)
+              write(OUT) id%PHYS_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("VIRT_L0_OMP")
+           IF(associated(id%VIRT_L0_OMP)) THEN
+              write(OUT) size(id%VIRT_L0_OMP,1)
+              write(OUT) id%VIRT_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("PERM_L0_OMP")
+           IF(associated(id%PERM_L0_OMP)) THEN
+              write(OUT) size(id%PERM_L0_OMP,1)
+              write(OUT) id%PERM_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("PTR_LEAFS_L0_OMP")
+           IF(associated(id%PTR_LEAFS_L0_OMP)) THEN
+              write(OUT) size(id%PTR_LEAFS_L0_OMP,1)
+              write(OUT) id%PTR_LEAFS_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("L0_OMP_MAPPING")
+          IF(associated(id%L0_OMP_MAPPING)) THEN
+              write(OUT) size(id%L0_OMP_MAPPING,1)
+              write(OUT) id%L0_OMP_MAPPING
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("IF_RESTARTING")
+           write(OUT) id%IF_RESTARTING
+      CASE("SINGULAR_VALUES")
+         IF(associated(id%SINGULAR_VALUES)) THEN
+            write(OUT) size(id%SINGULAR_VALUES,1)
+            write(OUT) id%SINGULAR_VALUES
+         ELSE
+            write(OUT) -999,-998
+            write(OUT) -999
+         ENDIF 
+      CASE("NB_SINGULAR_VALUES")
+        write(OUT) id%NB_SINGULAR_VALUES
+        CASE("pad0","pad1","pad2","pad3","pad4","pad5","pad8","pad11",
+     &          "pad111", "pad12","pad13","pad14")
+        CASE DEFAULT
+           id%INFOG(1)=-92
+           write(*,*) "IN DMUMPS_STOP UNKNOWN VARIABLE IN STRUCTURE: "
+     &          // trim(adjustl(VARIABLES(i1)))
+           error=.true.
+           goto 100
+        END SELECT
+      ENDDO
+ 100  continue
+      CLOSE(OUT)
+      if(error) goto 101
+      OUTROOT=OUT+1000
+      OUTFILEROOT=trim(adjustl(OUTFILE)) // trim(adjustl("ROOT")) 
+     &     // trim(adjustl(STRING_ID))
+      open(UNIT=OUTROOT,FILE=OUTFILEROOT,STATUS='replace',
+     &     form='unformatted',iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN DMUMPS_STOP CANNOT OPEN FILE: "
+     &        //trim(adjustl(OUTFILEROOT))
+         goto 100
+      endif
+      DO i2=1,NBVARIABLES_ROOT
+         SELECT CASE(VARIABLES_ROOT(i2))
+      CASE("MBLOCK")
+         write(OUTROOT) id%root%MBLOCK
+      CASE("NBLOCK")
+         write(OUTROOT) id%root%NBLOCK
+      CASE("NPROW")
+         write(OUTROOT) id%root%NPROW
+      CASE("NPCOL")
+         write(OUTROOT) id%root%NPCOL
+      CASE("MYROW")
+         write(OUTROOT) id%root%MYROW
+      CASE("MYCOL")
+         write(OUTROOT) id%root%MYCOL
+      CASE("SCHUR_MLOC")
+         write(OUTROOT) id%root%SCHUR_MLOC
+      CASE("SCHUR_NLOC")
+         write(OUTROOT) id%root%SCHUR_NLOC
+      CASE("SCHUR_LLD")
+         write(OUTROOT) id%root%SCHUR_LLD
+      CASE("RHS_NLOC")
+         write(OUTROOT) id%root%RHS_NLOC
+      CASE("ROOT_SIZE")
+         write(OUTROOT) id%root%ROOT_SIZE
+      CASE("TOT_ROOT_SIZE")
+         write(OUTROOT) id%root%TOT_ROOT_SIZE
+      CASE("DESCRIPTOR")
+         write(OUTROOT) id%root%DESCRIPTOR
+      CASE("CNTXT_BLACS")
+         write(OUTROOT) id%root%CNTXT_BLACS
+      CASE("LPIV")
+         write(OUTROOT) id%root%LPIV
+      CASE("RG2L_ROW")
+         IF(associated(id%root%RG2L_ROW)) THEN
+            write(OUTROOT) size(id%root%RG2L_ROW,1)
+            write(OUTROOT) id%root%RG2L_ROW
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("RG2L_COL")
+         IF(associated(id%root%RG2L_COL)) THEN
+            write(OUTROOT) size(id%root%RG2L_COL,1)
+            write(OUTROOT) id%root%RG2L_COL
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("IPIV")
+         IF(associated(id%root%IPIV)) THEN
+            write(OUTROOT) size(id%root%IPIV,1)
+            write(OUTROOT) id%root%IPIV
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("RHS_CNTR_MASTER_ROOT")
+         IF(associated(id%root%RHS_CNTR_MASTER_ROOT)) THEN
+            write(OUTROOT) size(id%root%RHS_CNTR_MASTER_ROOT,1)
+            write(OUTROOT) id%root%RHS_CNTR_MASTER_ROOT
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("SCHUR_POINTER")
+         IF(associated(id%root%SCHUR_POINTER)) THEN
+            write(OUTROOT) size(id%root%SCHUR_POINTER,1)
+            write(OUTROOT) id%root%SCHUR_POINTER
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("QR_TAU")
+         IF(associated(id%root%QR_TAU)) THEN
+            write(OUTROOT) size(id%root%QR_TAU,1)
+            write(OUTROOT) id%root%QR_TAU
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("RHS_ROOT")
+         IF(associated(id%root%RHS_ROOT)) THEN
+            write(OUTROOT) size(id%root%RHS_ROOT,1)
+     &           ,size(id%root%RHS_ROOT,2)
+            write(OUTROOT) id%root%RHS_ROOT
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF
+      CASE("QR_RCOND")
+         write(OUTROOT) id%root%QR_RCOND
+      CASE("yes")
+         write(OUTROOT) id%root%yes
+      CASE("gridinit_done")
+         write(OUTROOT) id%root%gridinit_done
+      CASE("SVD_U")
+         IF(associated(id%root%SVD_U)) THEN
+            write(OUTROOT) size(id%root%SVD_U,1)
+     &           ,size(id%root%SVD_U,2)
+            write(OUTROOT) id%root%SVD_U
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF   
+      CASE("SVD_VT")
+         IF(associated(id%root%SVD_VT)) THEN
+            write(OUTROOT) size(id%root%SVD_VT,1)
+     &           ,size(id%root%SVD_VT,2)
+            write(OUTROOT) id%root%SVD_VT
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF  
+      CASE("SINGULAR_VALUES")
+         IF(associated(id%root%SINGULAR_VALUES)) THEN
+            write(OUTROOT) size(id%root%SINGULAR_VALUES,1)
+            write(OUTROOT) id%root%SINGULAR_VALUES
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF 
+      CASE("NB_SINGULAR_VALUES")
+         write(OUTROOT) id%root%NB_SINGULAR_VALUES
+      CASE("rootpad0","rootpad1","rootpad2","rootpad",
+     &        "rootpad3")
+      CASE DEFAULT
+         id%INFOG(1)=-92
+         write(*,*) "IN DMUMPS_STOP UNKNOWN VARIABLE"
+     &        // "IN ROOT: " // trim(adjustl(VARIABLES_ROOT(i2)))
+         goto 101
+      END SELECT  
+      ENDDO
+ 101  continue
+      CLOSE(OUTROOT)
+      END SUBROUTINE DMUMPS_STOP
+      SUBROUTINE DMUMPS_RESTART(id,INFILE)
+      USE DMUMPS_STRUC_DEF
+      IMPLICIT NONE
+      INCLUDE 'mpif.h'
+      INTEGER::IN,err,NBVARIABLES,i1,NBVARIABLES_ROOT,dummy
+      INTEGER:: i2,size_array1,size_array2,INROOT
+      CHARACTER(len=100),allocatable,DIMENSION(:)::VARIABLES
+      CHARACTER(len=100),allocatable,DIMENSION(:)::VARIABLES_ROOT
+      CHARACTER(len=*), intent(in):: INFILE
+      CHARACTER(len=100):: INFILEMAIN,INFILEROOT
+      CHARACTER(len=3) :: STRING_ID
+      LOGICAL :: error
+      INTEGER MASTER
+      PARAMETER( MASTER = 0 )
+      TYPE (DMUMPS_STRUC) :: id
+      error=.false.
+      write (STRING_ID, '(i3)') id%MYID
+      NBVARIABLES=171
+      allocate(VARIABLES(NBVARIABLES))
+      VARIABLES(171)="NB_SINGULAR_VALUES"
+      VARIABLES(170)="SINGULAR_VALUES"
+      VARIABLES(169)="IF_RESTARTING"
+      VARIABLES(168)="L0_OMP_MAPPING"
+      VARIABLES(167)="PTR_LEAFS_L0_OMP"
+      VARIABLES(166)="PERM_L0_OMP"
+      VARIABLES(165)="VIRT_L0_OMP"
+      VARIABLES(164)="PHYS_L0_OMP"
+      VARIABLES(163)="IPOOL_AFTER_L0_OMP"
+      VARIABLES(162)="IPOOL_BEFORE_L0_OMP"
+      VARIABLES(161)="THREAD_LA"
+      VARIABLES(160)="LL0_OMP_MAPPING"
+      VARIABLES(159)="L_VIRT_L0_OMP"
+      VARIABLES(158)="L_PHYS_L0_OMP"
+      VARIABLES(157)="LPOOL_BEFORE_L0_OMP"
+      VARIABLES(156)="LPOOL_AFTER_L0_OMP"
+      VARIABLES(155)="NBGRP"
+      VARIABLES(154)="LRGROUPS"
+      VARIABLES(153)="root"
+      VARIABLES(152)="WORKING"
+      VARIABLES(151)="IPTR_WORKING"
+      VARIABLES(150)="pad14"
+      VARIABLES(149)="SUP_PROC"
+      VARIABLES(148)="PIVNUL_LIST"
+      VARIABLES(147)="OOC_FILE_NAME_LENGTH"
+      VARIABLES(146)="OOC_FILE_NAMES"
+      VARIABLES(145)="OOC_NB_FILE_TYPE"
+      VARIABLES(144)="OOC_NB_FILES"
+      VARIABLES(143)="OOC_TOTAL_NB_NODES"
+      VARIABLES(142)="OOC_VADDR"
+      VARIABLES(141)="OOC_SIZE_OF_BLOCK"
+      VARIABLES(140)="pad13"
+      VARIABLES(139)="OOC_INODE_SEQUENCE"
+      VARIABLES(138)="OOC_MAX_NB_NODES_FOR_ZONE"
+      VARIABLES(137)="INSTANCE_NUMBER"
+      VARIABLES(136)="pad12"
+      VARIABLES(135)="CB_SON_SIZE"
+      VARIABLES(134)="DKEEP"
+      VARIABLES(133)="LWK_USER"
+      VARIABLES(132)="NBSA_LOCAL"
+      VARIABLES(131)="WK_USER"
+      VARIABLES(130)="CROIX_MANU"
+      VARIABLES(129)="SCHED_SBTR"
+      VARIABLES(128)="SCHED_GRP"
+      VARIABLES(127)="SCHED_DEP"
+      VARIABLES(126)="SBTR_ID"
+      VARIABLES(125)="DEPTH_FIRST_SEQ"
+      VARIABLES(124)="DEPTH_FIRST"
+      VARIABLES(123)="MY_NB_LEAF"
+      VARIABLES(122)="MY_FIRST_LEAF"
+      VARIABLES(121)="MY_ROOT_SBTR"
+      VARIABLES(120)="COST_TRAV"
+      VARIABLES(119)="MEM_SUBTREE"
+      VARIABLES(118)="RHSCOMP"
+      VARIABLES(117)="POSINRHSCOMP_COL"
+      VARIABLES(116)="POSINRHSCOMP_ROW"
+      VARIABLES(115)="POSINRHSCOMP_COL_ALLOC"
+      VARIABLES(114)="MEM_DIST"
+      VARIABLES(113)="I_AM_CAND"
+      VARIABLES(112)="TAB_POS_IN_PERE"
+      VARIABLES(111)="FUTURE_NIV2"
+      VARIABLES(110)="ISTEP_TO_INIV2"
+      VARIABLES(109)="CANDIDATES"
+      VARIABLES(108)="ELTPROC"
+      VARIABLES(107)="pad11"
+      VARIABLES(106)="NA_ELT"
+      VARIABLES(105)="LELTVAR"
+      VARIABLES(104)="NELT_loc"
+      VARIABLES(103)="DBLARR"
+      VARIABLES(102)="INTARR"
+      VARIABLES(101)="PROCNODE"
+      VARIABLES(100)="S"
+      VARIABLES(99)="PTRFAC"
+      VARIABLES(98)="PTLUST_S"
+      VARIABLES(97)="PROCNODE_STEPS"
+      VARIABLES(96)="NA"
+      VARIABLES(95)="FRTELT"
+      VARIABLES(94)="FRTPTR"
+      VARIABLES(93)="PTRAR"
+      VARIABLES(92)="FILS"
+      VARIABLES(91)="DAD_STEPS"
+      VARIABLES(90)="FRERE_STEPS"
+      VARIABLES(89)="Step2node"
+      VARIABLES(88)="ND_STEPS"
+      VARIABLES(87)="NE_STEPS"
+      VARIABLES(86)="STEP"
+      VARIABLES(85)="NBSA"
+      VARIABLES(84)="LNA"
+      VARIABLES(83)="KEEP"
+      VARIABLES(82)="Deficiency"
+      VARIABLES(81)="MAXIS1"
+      VARIABLES(80)="IS1"
+      VARIABLES(79)="IS"
+      VARIABLES(78)="BUFR"
+      VARIABLES(77)="POIDS"
+      VARIABLES(76)="LBUFR_BYTES"
+      VARIABLES(75)="LBUFR"
+      VARIABLES(74)="ASS_IRECV"
+      VARIABLES(73)="NSLAVES"
+      VARIABLES(72)="NPROCS"
+      VARIABLES(71)="MYID"
+      VARIABLES(70)="COMM_LOAD"
+      VARIABLES(69)="MYID_NODES"
+      VARIABLES(68)="COMM_NODES"
+      VARIABLES(67)="INST_Number"
+      VARIABLES(66)="MAX_SURF_MASTER"
+      VARIABLES(65)="KEEP8"
+      VARIABLES(64)="pad8"
+      VARIABLES(63)="WRITE_PROBLEM"
+      VARIABLES(62)="OOC_PREFIX"
+      VARIABLES(61)="OOC_TMPDIR"
+      VARIABLES(60)="VERSION_NUMBER"
+      VARIABLES(59)="MAPPING"
+      VARIABLES(58)="LISTVAR_SCHUR"
+      VARIABLES(57)="SCHUR_CINTERFACE"
+      VARIABLES(56)="SCHUR"
+      VARIABLES(55)="SIZE_SCHUR"
+      VARIABLES(54)="SCHUR_LLD"
+      VARIABLES(53)="SCHUR_NLOC"
+      VARIABLES(52)="SCHUR_MLOC"
+      VARIABLES(51)="NBLOCK"
+      VARIABLES(50)="MBLOCK"
+      VARIABLES(49)="NPCOL"
+      VARIABLES(48)="NPROW"
+      VARIABLES(47)="UNS_PERM"
+      VARIABLES(46)="SYM_PERM"
+      VARIABLES(45)="RINFOG"
+      VARIABLES(44)="RINFO"
+      VARIABLES(43)="CNTL"
+      VARIABLES(42)="COST_SUBTREES"
+      VARIABLES(41)="INFOG"
+      VARIABLES(40)="INFO"
+      VARIABLES(39)="ICNTL"
+      VARIABLES(38)="pad5"
+      VARIABLES(37)="LREDRHS"
+      VARIABLES(36)="LSOL_loc"
+      VARIABLES(35)="NZ_RHS"
+      VARIABLES(34)="NRHS"
+      VARIABLES(33)="LRHS"
+      VARIABLES(32)="ISOL_loc"
+      VARIABLES(31)="IRHS_PTR"
+      VARIABLES(30)="IRHS_SPARSE"
+      VARIABLES(29)="SOL_loc"
+      VARIABLES(28)="RHS_SPARSE"
+      VARIABLES(27)="REDRHS"
+      VARIABLES(26)="RHS"
+      VARIABLES(25)="PERM_IN"
+      VARIABLES(24)="pad4"
+      VARIABLES(23)="A_ELT"
+      VARIABLES(22)="ELTVAR"
+      VARIABLES(21)="ELTPTR"
+      VARIABLES(20)="pad3"
+      VARIABLES(19)="NELT"
+      VARIABLES(18)="pad2"
+      VARIABLES(17)="A_loc"
+      VARIABLES(16)="JCN_loc"
+      VARIABLES(15)="IRN_loc"
+      VARIABLES(14)="pad1"
+      VARIABLES(13)="NZ_loc"
+      VARIABLES(12)="pad0"
+      VARIABLES(11)="ROWSCA"
+      VARIABLES(10)="COLSCA"
+      VARIABLES(9)="JCN"
+      VARIABLES(8)="IRN"
+      VARIABLES(7)="A"
+      VARIABLES(6)="NZ"
+      VARIABLES(5)="N"
+      VARIABLES(4)="JOB"
+      VARIABLES(3)="PAR"
+      VARIABLES(2)="SYM"
+      VARIABLES(1)="COMM"
+      NBVARIABLES_ROOT=34
+      allocate(VARIABLES_ROOT(NBVARIABLES_ROOT))
+      VARIABLES_ROOT(34)="NB_SINGULAR_VALUES"
+      VARIABLES_ROOT(33)="SINGULAR_VALUES"
+      VARIABLES_ROOT(32)="SVD_VT"
+      VARIABLES_ROOT(31)="SVD_U"
+      VARIABLES_ROOT(30)="gridinit_done"
+      VARIABLES_ROOT(29)="yes"
+      VARIABLES_ROOT(28)="rootpad3"
+      VARIABLES_ROOT(27)="QR_RCOND"
+      VARIABLES_ROOT(26)="rootpad"
+      VARIABLES_ROOT(25)="RHS_ROOT"
+      VARIABLES_ROOT(24)="rootpad2"
+      VARIABLES_ROOT(23)="QR_TAU"
+      VARIABLES_ROOT(22)="SCHUR_POINTER"
+      VARIABLES_ROOT(21)="RHS_CNTR_MASTER_ROOT"
+      VARIABLES_ROOT(20)="rootpad1"
+      VARIABLES_ROOT(19)="IPIV"
+      VARIABLES_ROOT(18)="RG2L_COL"
+      VARIABLES_ROOT(17)="RG2L_ROW"
+      VARIABLES_ROOT(16)="rootpad0"
+      VARIABLES_ROOT(15)="LPIV"
+      VARIABLES_ROOT(14)="CNTXT_BLACS"
+      VARIABLES_ROOT(13)="DESCRIPTOR"
+      VARIABLES_ROOT(12)="TOT_ROOT_SIZE"
+      VARIABLES_ROOT(11)="ROOT_SIZE"
+      VARIABLES_ROOT(10)="RHS_NLOC"
+      VARIABLES_ROOT(9)="SCHUR_LLD"
+      VARIABLES_ROOT(8)="SCHUR_NLOC"
+      VARIABLES_ROOT(7)="SCHUR_MLOC"
+      VARIABLES_ROOT(6)="MYCOL"
+      VARIABLES_ROOT(5)="MYROW"
+      VARIABLES_ROOT(4)="NPCOL"
+      VARIABLES_ROOT(3)="NPROW"
+      VARIABLES_ROOT(2)="NBLOCK"
+      VARIABLES_ROOT(1)="MBLOCK"
+      IN=52+id%MYID
+      INFILEMAIN=trim(adjustl(INFILE)) // trim(adjustl(STRING_ID))
+      open(UNIT=IN,FILE=INFILEMAIN, STATUS='old',FORM='unformatted'
+     &     ,iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN DMUMPS_RESTART CANNOT OPEN FILE: "
+     &        //trim(adjustl(INFILEMAIN))
+         error=.true.
+         goto 101
+      endif
+      DO i1=4,NBVARIABLES
+         size_array1=0
+         size_array2=0
+         SELECT CASE(VARIABLES(i1))
+         CASE("JOB")
+            read(IN) id%JOB
+         CASE("N")
+            read(IN) id%N
+         CASE("ICNTL")
+            read(IN) id%ICNTL
+         CASE("INFO")
+            read(IN) id%INFO
+         CASE("INFOG")
+            read(IN) id%INFOG
+         CASE("COST_SUBTREES")
+            read(IN) id%COST_SUBTREES
+         CASE("CNTL")
+            read(IN) id%CNTL
+         CASE("RINFO")
+            read(IN) id%RINFO
+         CASE("RINFOG")
+            read(IN) id%RINFOG
+         CASE("KEEP8")
+            read(IN) id%KEEP8
+         CASE("KEEP")
+            read(IN) id%KEEP
+         CASE("DKEEP")
+            read(IN) id%DKEEP    
+         CASE("NZ")
+            read(IN) id%NZ
+         CASE("A")
+            nullify(id%A)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%A(size_array1))
+               read(IN) id%A
+            endif
+         CASE("IRN")
+            nullify(id%IRN)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRN(size_array1))
+               read(IN) id%IRN
+            endif
+         CASE("JCN")
+            nullify(id%JCN)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%JCN(size_array1))
+               read(IN) id%JCN
+            endif
+         CASE("COLSCA")
+            nullify(id%COLSCA)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%COLSCA(size_array1))
+               read(IN) id%COLSCA
+            endif
+         CASE("ROWSCA")
+            nullify(id%ROWSCA)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ROWSCA(size_array1))
+               read(IN) id%ROWSCA
+            endif
+         CASE("NZ_loc")
+            read(IN) id%NZ_loc
+         CASE("IRN_loc")
+            nullify(id%IRN_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRN_loc(size_array1))
+               read(IN) id%IRN_loc
+            endif
+         CASE("JCN_loc")
+            nullify(id%JCN_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%JCN_loc(size_array1))
+               read(IN) id%JCN_loc
+            endif
+         CASE("A_loc")
+            nullify(id%A_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%A_loc(size_array1))
+               read(IN) id%A_loc
+            endif
+         CASE("NELT")
+            read(IN) id%NELT
+         CASE("ELTPTR")
+            nullify(id%ELTPTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ELTPTR(size_array1))
+               read(IN) id%ELTPTR
+            endif
+         CASE("ELTVAR")
+            nullify(id%ELTVAR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ELTVAR(size_array1))
+               read(IN) id%ELTVAR
+            endif
+         CASE("A_ELT")
+            nullify(id%A_ELT)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%A_ELT(size_array1))
+               read(IN) id%A_ELT
+            endif
+         CASE("PERM_IN")
+            nullify(id%PERM_IN)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PERM_IN(size_array1))
+               read(IN) id%PERM_IN
+            endif
+         CASE("RHS")
+            nullify(id%RHS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%RHS(size_array1))
+               read(IN) id%RHS
+            endif
+         CASE("REDRHS")
+            nullify(id%REDRHS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%REDRHS(size_array1))
+               read(IN) id%REDRHS
+            endif
+         CASE("RHS_SPARSE")
+            nullify(id%RHS_SPARSE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%RHS_SPARSE(size_array1))
+               read(IN) id%RHS_SPARSE
+            endif
+         CASE("SOL_loc")
+            nullify(id%SOL_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SOL_loc(size_array1))
+               read(IN) id%SOL_loc
+            endif
+         CASE("IRHS_SPARSE")
+            nullify(id%IRHS_SPARSE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRHS_SPARSE(size_array1))
+               read(IN) id%IRHS_SPARSE
+            endif
+         CASE("IRHS_PTR")
+            nullify(id%IRHS_PTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRHS_PTR(size_array1))
+               read(IN) id%IRHS_PTR
+            endif
+         CASE("ISOL_loc")
+            nullify(id%ISOL_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ISOL_loc(size_array1))
+               read(IN) id%ISOL_loc
+            endif
+         CASE("LRHS")
+            read(IN) id%LRHS
+         CASE("NRHS")
+            read(IN) id%NRHS
+         CASE("NZ_RHS")
+            read(IN) id%NZ_RHS
+         CASE("LSOL_loc")
+            read(IN) id%LSOL_loc
+         CASE("LREDRHS")
+            read(IN) id%LREDRHS
+         CASE("SYM_PERM")
+            nullify(id%SYM_PERM)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SYM_PERM(size_array1))
+               read(IN) id%SYM_PERM
+            endif
+         CASE("UNS_PERM")
+            nullify(id%UNS_PERM)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%UNS_PERM(size_array1))
+               read(IN) id%UNS_PERM
+            endif
+         CASE("NPROW")
+            read(IN) id%NPROW
+         CASE("NPCOL")
+            read(IN) id%NPCOL
+         CASE("MBLOCK")
+            read(IN) id%MBLOCK
+         CASE("NBLOCK")
+            read(IN) id%NBLOCK
+         CASE("SCHUR_MLOC")
+            read(IN) id%SCHUR_MLOC
+         CASE("SCHUR_NLOC")
+            read(IN) id%SCHUR_NLOC
+         CASE("SCHUR_LLD")
+            read(IN) id%SCHUR_LLD
+         CASE("SIZE_SCHUR")
+            read(IN) id%SIZE_SCHUR
+         CASE("SCHUR")
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHUR(size_array1))
+               read(IN) id%SCHUR
+            endif
+         CASE("SCHUR_CINTERFACE")
+            nullify(id%SCHUR_CINTERFACE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHUR_CINTERFACE(size_array1))
+               read(IN) id%SCHUR_CINTERFACE
+            endif
+         CASE("LISTVAR_SCHUR")
+            nullify(id%LISTVAR_SCHUR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%LISTVAR_SCHUR(size_array1))
+               read(IN) id%LISTVAR_SCHUR
+            endif
+         CASE("MAPPING")
+            nullify(id%MAPPING)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MAPPING(size_array1))
+               read(IN) id%MAPPING
+            endif
+         CASE("VERSION_NUMBER")
+            read(IN) id%VERSION_NUMBER
+         CASE("OOC_TMPDIR")
+            read(IN) id%OOC_TMPDIR
+         CASE("OOC_PREFIX")
+            read(IN) id%OOC_PREFIX
+         CASE("WRITE_PROBLEM")
+            read(IN) id%WRITE_PROBLEM
+         CASE("MAX_SURF_MASTER")
+            read(IN) id%MAX_SURF_MASTER
+         CASE("INST_Number")
+            read(IN) id%INST_Number
+         CASE("COMM_NODES")
+            read(IN) id%COMM_NODES
+         CASE("MYID_NODES")
+            read(IN) id%MYID_NODES
+         CASE("COMM_LOAD")
+            read(IN) id%COMM_LOAD
+         CASE("MYID")
+            read(IN) id%MYID
+         CASE("NPROCS")
+            read(IN) id%NPROCS
+         CASE("NSLAVES")
+            read(IN) id%NSLAVES
+         CASE("ASS_IRECV")
+            read(IN) id%ASS_IRECV
+         CASE("LBUFR")
+            read(IN) id%LBUFR
+         CASE("LBUFR_BYTES")
+            read(IN) id%LBUFR_BYTES
+         CASE("POIDS")
+            nullify(id%POIDS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%POIDS(size_array1))
+               read(IN) id%POIDS
+            endif
+         CASE("BUFR")
+            nullify(id%BUFR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%BUFR(size_array1))
+               read(IN) id%BUFR
+            endif
+         CASE("IS")
+            nullify(id%IS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IS(size_array1))
+               read(IN) id%IS
+            endif
+         CASE("IS1")
+            nullify(id%IS1)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IS1(size_array1))
+               read(IN) id%IS1
+            endif
+         CASE("MAXIS1")
+            read(IN) id%MAXIS1
+         CASE("Deficiency")
+            read(IN) id%Deficiency
+         CASE("LNA")
+            read(IN) id%LNA
+         CASE("NBSA")
+            read(IN) id%NBSA
+         CASE("STEP")
+            nullify(id%STEP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%STEP(size_array1))
+               read(IN) id%STEP
+            endif
+         CASE("NE_STEPS")
+            nullify(id%NE_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%NE_STEPS(size_array1))
+               read(IN) id%NE_STEPS
+            endif
+         CASE("ND_STEPS")
+            nullify(id%ND_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ND_STEPS(size_array1))
+               read(IN) id%ND_STEPS
+            endif
+         CASE("Step2node")
+            nullify(id%Step2node)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%Step2node(size_array1))
+               read(IN) id%Step2node
+            endif
+         CASE("FRERE_STEPS")
+            nullify(id%FRERE_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FRERE_STEPS(size_array1))
+               read(IN) id%FRERE_STEPS
+            endif
+         CASE("DAD_STEPS")
+            nullify(id%DAD_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DAD_STEPS(size_array1))
+               read(IN) id%DAD_STEPS
+            endif
+         CASE("FILS")
+            nullify(id%FILS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FILS(size_array1))
+               read(IN) id%FILS
+            endif
+         CASE("PTRAR")
+            nullify(id%PTRAR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PTRAR(size_array1))
+               read(IN) id%PTRAR
+            endif
+         CASE("FRTPTR")
+            nullify(id%FRTPTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FRTPTR(size_array1))
+               read(IN) id%FRTPTR
+            endif
+         CASE("FRTELT")
+            nullify(id%FRTELT)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FRTELT(size_array1))
+               read(IN) id%FRTELT
+            endif
+         CASE("NA")
+            nullify(id%NA)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%NA(size_array1))
+               read(IN) id%NA
+            endif
+         CASE("PROCNODE_STEPS")
+            nullify(id%PROCNODE_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PROCNODE_STEPS(size_array1))
+               read(IN) id%PROCNODE_STEPS
+            endif
+         CASE("PTLUST_S")
+            nullify(id%PTLUST_S)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PTLUST_S(size_array1))
+               read(IN) id%PTLUST_S
+            endif
+         CASE("PTRFAC")
+            nullify(id%PTRFAC)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PTRFAC(size_array1))
+               read(IN) id%PTRFAC
+            endif
+         CASE("S")
+            nullify(id%S)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%S(size_array1))
+               read(IN) id%S
+            endif
+         CASE("PROCNODE")
+            nullify(id%PROCNODE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PROCNODE(size_array1))
+               read(IN) id%PROCNODE
+            endif
+         CASE("INTARR")
+            nullify(id%INTARR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%INTARR(size_array1))
+               read(IN) id%INTARR
+            endif
+         CASE("DBLARR")
+            nullify(id%DBLARR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DBLARR(size_array1))
+               read(IN) id%DBLARR
+            endif
+         CASE("NELT_loc")
+            read(IN) id%NELT_loc
+         CASE("LELTVAR")
+            read(IN) id%LELTVAR
+         CASE("NA_ELT")
+            read(IN) id%NA_ELT
+         CASE("ELTPROC")
+            nullify(id%ELTPROC)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ELTPROC(size_array1))
+               read(IN) id%ELTPROC
+            endif
+         CASE("CANDIDATES")
+            nullify(id%CANDIDATES)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%CANDIDATES(size_array1,size_array2))
+               read(IN) id%CANDIDATES
+            endif
+         CASE("ISTEP_TO_INIV2")
+            nullify(id%ISTEP_TO_INIV2)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ISTEP_TO_INIV2(size_array1))
+               read(IN) id%ISTEP_TO_INIV2
+            endif
+         CASE("FUTURE_NIV2")
+            nullify(id%FUTURE_NIV2)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FUTURE_NIV2(size_array1))
+               read(IN) id%FUTURE_NIV2
+            endif
+         CASE("TAB_POS_IN_PERE")
+            nullify(id%TAB_POS_IN_PERE)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%TAB_POS_IN_PERE(size_array1,size_array2))
+               read(IN) id%TAB_POS_IN_PERE
+            endif
+         CASE("I_AM_CAND")
+            nullify(id%I_AM_CAND)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%I_AM_CAND(size_array1))
+               read(IN) id%I_AM_CAND
+            endif
+         CASE("MEM_DIST")
+            nullify(id%MEM_DIST)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MEM_DIST(0:size_array1-1))
+               read(IN) id%MEM_DIST
+            endif
+         CASE("POSINRHSCOMP_ROW")
+            nullify(id%POSINRHSCOMP_ROW)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%POSINRHSCOMP_ROW(size_array1))
+               read(IN) id%POSINRHSCOMP_ROW
+            endif
+         CASE("POSINRHSCOMP_COL_ALLOC")
+            read(IN) id%POSINRHSCOMP_COL_ALLOC
+         CASE("POSINRHSCOMP_COL")
+            nullify(id%POSINRHSCOMP_COL)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               if(id%POSINRHSCOMP_COL_ALLOC) then
+                  allocate(id%POSINRHSCOMP_COL(size_array1))
+                  read(IN) id%POSINRHSCOMP_COL
+               else
+                  read(IN) dummy
+                  id%POSINRHSCOMP_COL=>id%POSINRHSCOMP_ROW
+               endif
+            endif
+         CASE("RHSCOMP")
+            nullify(id%RHSCOMP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%RHSCOMP(size_array1))
+               read(IN) id%RHSCOMP
+            endif
+         CASE("MEM_SUBTREE")
+            nullify(id%MEM_SUBTREE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MEM_SUBTREE(size_array1))
+               read(IN) id%MEM_SUBTREE
+            endif
+         CASE("COST_TRAV")
+            nullify(id%COST_TRAV)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%COST_TRAV(size_array1))
+               read(IN) id%COST_TRAV
+            endif
+         CASE("MY_ROOT_SBTR")
+            nullify(id%MY_ROOT_SBTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MY_ROOT_SBTR(size_array1))
+               read(IN) id%MY_ROOT_SBTR
+            endif
+         CASE("MY_FIRST_LEAF")
+            nullify(id%MY_FIRST_LEAF)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MY_FIRST_LEAF(size_array1))
+               read(IN) id%MY_FIRST_LEAF
+            endif
+         CASE("MY_NB_LEAF")
+            nullify(id%MY_NB_LEAF)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MY_NB_LEAF(size_array1))
+               read(IN) id%MY_NB_LEAF
+            endif
+         CASE("DEPTH_FIRST")
+            nullify(id%DEPTH_FIRST)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DEPTH_FIRST(size_array1))
+               read(IN) id%DEPTH_FIRST
+            endif
+         CASE("DEPTH_FIRST_SEQ")
+            nullify(id%DEPTH_FIRST_SEQ)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DEPTH_FIRST_SEQ(size_array1))
+               read(IN) id%DEPTH_FIRST_SEQ
+            endif
+         CASE("SBTR_ID")
+            nullify(id%SBTR_ID)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SBTR_ID(size_array1))
+               read(IN) id%SBTR_ID
+            endif
+         CASE("SCHED_DEP")
+            nullify(id%SCHED_DEP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHED_DEP(size_array1))
+               read(IN) id%SCHED_DEP
+            endif
+         CASE("SCHED_GRP")
+            nullify(id%SCHED_GRP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHED_GRP(size_array1))
+               read(IN) id%SCHED_GRP
+            endif
+         CASE("CROIX_MANU")
+            nullify(id%CROIX_MANU)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%CROIX_MANU(size_array1))
+               read(IN) id%CROIX_MANU
+            endif
+         CASE("WK_USER")
+            nullify(id%WK_USER)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%WK_USER(size_array1))
+               read(IN) id%WK_USER
+            endif
+         CASE("NBSA_LOCAL")
+            read(IN) id%NBSA_LOCAL
+         CASE("LWK_USER")
+            read(IN) id%LWK_USER
+         CASE("CB_SON_SIZE")
+            nullify(id%CB_SON_SIZE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%CB_SON_SIZE(size_array1))
+               read(IN) id%CB_SON_SIZE
+            endif
+         CASE("INSTANCE_NUMBER")
+            read(IN) id%INSTANCE_NUMBER
+         CASE("OOC_MAX_NB_NODES_FOR_ZONE")
+            read(IN) id%OOC_MAX_NB_NODES_FOR_ZONE
+         CASE("OOC_INODE_SEQUENCE")
+            nullify(id%OOC_INODE_SEQUENCE)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_INODE_SEQUENCE(size_array1,size_array2))
+               read(IN) id%OOC_INODE_SEQUENCE
+            endif
+         CASE("OOC_SIZE_OF_BLOCK")
+            nullify(id%OOC_SIZE_OF_BLOCK)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_SIZE_OF_BLOCK(size_array1,size_array2))
+               read(IN) id%OOC_SIZE_OF_BLOCK
+            endif
+         CASE("OOC_VADDR")
+            nullify(id%OOC_VADDR)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_VADDR(size_array1,size_array2))
+               read(IN) id%OOC_VADDR
+            endif
+         CASE("OOC_TOTAL_NB_NODES")
+            nullify(id%OOC_TOTAL_NB_NODES)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_TOTAL_NB_NODES(size_array1))
+               read(IN) id%OOC_TOTAL_NB_NODES
+            endif
+         CASE("OOC_NB_FILES")
+            nullify(id%OOC_NB_FILES)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_NB_FILES(size_array1))
+               read(IN) id%OOC_NB_FILES
+            endif
+         CASE("OOC_NB_FILE_TYPE")
+            read(IN) id%OOC_NB_FILE_TYPE
+         CASE("OOC_FILE_NAMES")
+            nullify(id%OOC_FILE_NAMES)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_FILE_NAMES(size_array1,size_array2))
+               read(IN) id%OOC_FILE_NAMES
+            endif
+         CASE("OOC_FILE_NAME_LENGTH")
+            nullify(id%OOC_FILE_NAME_LENGTH)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_FILE_NAME_LENGTH(size_array1))
+               read(IN) id%OOC_FILE_NAME_LENGTH
+            endif
+         CASE("PIVNUL_LIST")
+            nullify(id%PIVNUL_LIST)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PIVNUL_LIST(size_array1))
+               read(IN) id%PIVNUL_LIST
+            endif
+         CASE("SUP_PROC")
+            nullify(id%SUP_PROC)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SUP_PROC(size_array1,size_array2))
+               read(IN) id%SUP_PROC
+            endif
+         CASE("IPTR_WORKING")
+            nullify(id%IPTR_WORKING)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IPTR_WORKING(size_array1))
+               read(IN) id%IPTR_WORKING
+            endif
+         CASE("WORKING")
+            nullify(id%WORKING)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%WORKING(size_array1))
+               read(IN) id%WORKING
+            endif
+         CASE("root")
+        CASE("NBGRP")
+           read(IN) id%NBGRP
+        CASE("LRGROUPS")
+           nullify(id%LRGROUPS)
+           read(IN) size_array1
+           if(size_array1.EQ.-999) then
+              read(IN) dummy
+           else
+              allocate(id%LRGROUPS(size_array1))
+              read(IN) id%LRGROUPS
+           endif
+         CASE("SCHED_SBTR")
+            nullify(id%SCHED_SBTR)
+            read(IN) size_array1
+            IF(size_array1.EQ.-999) THEN
+               read(IN) dummy
+            ELSE
+               allocate(id%SCHED_SBTR(size_array1))
+               read(IN) id%SCHED_SBTR
+            ENDIF 
+        CASE("LPOOL_AFTER_L0_OMP")
+           read(IN) id%LPOOL_AFTER_L0_OMP
+        CASE("LPOOL_BEFORE_L0_OMP")
+           read(IN) id%LPOOL_BEFORE_L0_OMP
+        CASE("L_PHYS_L0_OMP")
+           read(IN) id%L_PHYS_L0_OMP
+        CASE("L_VIRT_L0_OMP")  
+           read(IN) id%L_VIRT_L0_OMP
+        CASE("LL0_OMP_MAPPING")
+           read(IN) id%LL0_OMP_MAPPING
+        CASE("THREAD_LA")
+           read(IN) id%THREAD_LA
+        CASE("IPOOL_AFTER_L0_OMP")
+           nullify(id%IPOOL_AFTER_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%IPOOL_AFTER_L0_OMP(size_array1))
+              read(IN) id%IPOOL_AFTER_L0_OMP
+           ENDIF 
+        CASE("IPOOL_BEFORE_L0_OMP")
+           nullify(id%IPOOL_BEFORE_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%IPOOL_BEFORE_L0_OMP(size_array1))
+              read(IN) id%IPOOL_BEFORE_L0_OMP
+           ENDIF 
+        CASE("PHYS_L0_OMP")
+           nullify(id%PHYS_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%PHYS_L0_OMP(size_array1))
+              read(IN) id%PHYS_L0_OMP
+           ENDIF 
+        CASE("VIRT_L0_OMP")
+           nullify(id%VIRT_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%VIRT_L0_OMP(size_array1))
+              read(IN) id%VIRT_L0_OMP
+           ENDIF
+        CASE("PERM_L0_OMP")
+           nullify(id%PERM_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%PERM_L0_OMP(size_array1))
+              read(IN) id%PERM_L0_OMP
+           ENDIF
+        CASE("PTR_LEAFS_L0_OMP")
+           nullify(id%PTR_LEAFS_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%PTR_LEAFS_L0_OMP(size_array1))
+              read(IN) id%PTR_LEAFS_L0_OMP
+           ENDIF
+        CASE("L0_OMP_MAPPING")
+           nullify(id%L0_OMP_MAPPING)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%L0_OMP_MAPPING(size_array1))
+              read(IN) id%L0_OMP_MAPPING
+           ENDIF 
+        CASE("IF_RESTARTING")
+           read(IN) id%IF_RESTARTING 
+        CASE("SINGULAR_VALUES")
+         read(IN) size_array1
+         if(size_array1.EQ.-999) then
+            read(IN) dummy
+         else
+            allocate(id%SINGULAR_VALUES(size_array1))
+            read(IN) id%SINGULAR_VALUES
+         endif  
+      CASE("NB_SINGULAR_VALUES")
+        write(IN) id%NB_SINGULAR_VALUES
+        CASE("pad0","pad1","pad2","pad3","pad4","pad5","pad8","pad11",
+     &          "pad111", "pad12","pad13","pad14")
+        CASE DEFAULT
+           id%INFOG(1)=-92
+           write(*,*) "IN DMUMPS_RESTART UNKNOWN VARIABLE IN "
+     &       // "STRUCTURE: "//  trim(adjustl(VARIABLES(i1)))
+           goto 101
+        END SELECT
+      ENDDO
+ 101  continue
+      close(IN)
+      if(error) goto 102
+      INROOT=1000+IN
+      INFILEROOT=trim(adjustl(INFILE)) // trim(adjustl("ROOT")) 
+     &     // trim(adjustl(STRING_ID)) 
+      open(UNIT=INROOT,FILE=INFILEROOT, STATUS='old',FORM='unformatted'
+     &     ,iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN DMUMPS_RESTART CANNOT OPEN FILE: "
+     &        //trim(adjustl(INFILEROOT))
+         goto 102
+      endif
+      DO i2=1,NBVARIABLES_ROOT
+         SELECT CASE(VARIABLES_ROOT(i2))
+      CASE("MBLOCK")
+         read(INROOT) id%root%MBLOCK
+      CASE("NBLOCK")
+         read(INROOT) id%root%NBLOCK
+      CASE("NPROW")
+         read(INROOT) id%root%NPROW
+      CASE("NPCOL")
+         read(INROOT) id%root%NPCOL
+      CASE("MYROW")
+         read(INROOT) id%root%MYROW
+      CASE("MYCOL")
+         read(INROOT) id%root%MYCOL
+      CASE("SCHUR_MLOC")
+         read(INROOT) id%root%SCHUR_MLOC
+      CASE("SCHUR_NLOC")
+         read(INROOT) id%root%SCHUR_NLOC
+      CASE("SCHUR_LLD")
+         read(INROOT) id%root%SCHUR_LLD
+      CASE("RHS_NLOC")
+         read(INROOT) id%root%RHS_NLOC
+      CASE("ROOT_SIZE")
+         read(INROOT) id%root%ROOT_SIZE
+      CASE("TOT_ROOT_SIZE")
+         read(INROOT) id%root%TOT_ROOT_SIZE
+      CASE("DESCRIPTOR")
+         read(INROOT) id%root%DESCRIPTOR
+      CASE("CNTXT_BLACS")
+         read(INROOT) id%root%CNTXT_BLACS
+      CASE("LPIV")
+         read(INROOT) id%root%LPIV
+      CASE("RG2L_ROW")
+         nullify(id%root%RG2L_ROW)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RG2L_ROW(size_array1))
+            read(INROOT) id%root%RG2L_ROW
+         endif
+      CASE("RG2L_COL")
+         nullify(id%root%RG2L_COL)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RG2L_COL(size_array1))
+            read(INROOT) id%root%RG2L_COL
+         endif
+      CASE("IPIV")
+         nullify(id%root%IPIV)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%IPIV(size_array1))
+            read(INROOT) id%root%IPIV
+         endif
+      CASE("RHS_CNTR_MASTER_ROOT")
+         nullify(id%root%RHS_CNTR_MASTER_ROOT)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RHS_CNTR_MASTER_ROOT(size_array1))
+            read(INROOT) id%root%RHS_CNTR_MASTER_ROOT
+         endif
+      CASE("SCHUR_POINTER")
+         nullify(id%root%SCHUR_POINTER)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SCHUR_POINTER(size_array1))
+            read(INROOT) id%root%SCHUR_POINTER
+         endif
+      CASE("QR_TAU")
+         nullify(id%root%QR_TAU)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%QR_TAU(size_array1))
+            read(INROOT) id%root%QR_TAU
+         endif
+      CASE("RHS_ROOT")
+         nullify(id%root%RHS_ROOT)
+         read(INROOT) size_array1,size_array2
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RHS_ROOT(size_array1,size_array2))
+            read(INROOT) id%root%RHS_ROOT
+         endif
+      CASE("QR_RCOND")
+         read(INROOT) id%root%QR_RCOND
+      CASE("yes")
+         read(INROOT) id%root%yes
+      CASE("gridinit_done")
+         read(INROOT) id%root%gridinit_done
+      CASE("SVD_U")
+         read(INROOT) size_array1,size_array2
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SVD_U(size_array1,size_array2))
+            read(INROOT) id%root%SVD_U
+         endif
+      CASE("SVD_VT")
+         read(INROOT) size_array1,size_array2
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SVD_VT(size_array1,size_array2))
+            read(INROOT) id%root%SVD_VT
+         endif
+      CASE("SINGULAR_VALUES")
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SINGULAR_VALUES(size_array1))
+            read(INROOT) id%root%SINGULAR_VALUES
+         endif  
+      CASE("NB_SINGULAR_VALUES")
+        write(INROOT) id%root%NB_SINGULAR_VALUES
+         CASE("rootpad0","rootpad1","rootpad2","rootpad",
+     &        "rootpad3")
+      CASE DEFAULT
+         id%INFOG(1)=-92
+         write(*,*) "IN DMUMPS_RESTART UNKNOWN VARIABLE "
+     &        // "IN ROOT: "// trim(adjustl(VARIABLES_ROOT(i2)))
+         goto 102
+      END SELECT  
+      ENDDO
+      if(id%root%gridinit_done) then
+         id%root%CNTXT_BLACS = id%COMM_NODES
+         CALL blacs_gridinit( id%root%CNTXT_BLACS, 'R',
+     &        id%root%NPROW, id%root%NPCOL )
+         id%root%gridinit_done = .TRUE.
+      endif
+ 102  continue
+      close(INROOT)
+      END SUBROUTINE DMUMPS_RESTART
diff -ruN MUMPS_5.1.2/src/mumps_orderings.c mumps-5.1.2-aster7/src/mumps_orderings.c
--- MUMPS_5.1.2/src/mumps_orderings.c	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/src/mumps_orderings.c	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,354 @@
+/*
+ *
+ *  This file is part of MUMPS 5.0.2, released
+ *  on Fri Jul 15 09:12:54 UTC 2016
+ *
+ *
+ *  Copyright 1991-2016 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria,
+ *  University of Bordeaux.
+ *
+ *  This version of MUMPS is provided to you free of charge. It is
+ *  released under the CeCILL-C license:
+ *  http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
+ *
+ */
+/*
+ * This file contains interfaces to external ordering packages.
+ * At the moment, PORD (J. Schulze) and SCOTCH are interfaced.
+ */
+#include "mumps_orderings.h"
+#include "mumps_c_types.h"
+#if defined(pord)
+/* Interface to PORD */
+/*int mumps_pord( int, int, int *, int *, int * );
+#define MUMPS_PORDF   \
+F_SYMBOL(pordf,PORDF)*/
+void MUMPS_CALL
+MUMPS_PORDF( MUMPS_INT *nvtx, MUMPS_INT *nedges,
+             MUMPS_INT *xadj, MUMPS_INT *adjncy,
+             MUMPS_INT *nv, MUMPS_INT *ncmpa )
+{
+    *ncmpa = mumps_pord( *nvtx, *nedges, xadj, adjncy, nv );
+}
+/* Interface to PORD with weighted graph*/
+/*int mumps_pord_wnd( int, int, int *, int *, int *, int * );
+#define MUMPS_PORDF_WND           \
+    F_SYMBOL(pordf_wnd,PORDF_WND)*/
+void MUMPS_CALL
+MUMPS_PORDF_WND( MUMPS_INT *nvtx, MUMPS_INT *nedges,
+                 MUMPS_INT *xadj, MUMPS_INT *adjncy,
+                 MUMPS_INT *nv, MUMPS_INT *ncmpa, MUMPS_INT *totw )
+{
+    *ncmpa = mumps_pord_wnd( *nvtx, *nedges, xadj, adjncy, nv, totw );
+}
+/************************************************************
+ mumps_pord is used in ana_aux.F
+        permutation and inverse permutation not set in output,
+        but may be printed in default file: "perm_pord" and "iperm_pord",
+        if associated part uncommneted.
+        But, if uncommetnted a bug occurs in psl_ma41_analysi.F
+******************************************************************/
+/*********************************************************/
+MUMPS_INT mumps_pord
+(
+   MUMPS_INT nvtx,
+   MUMPS_INT nedges,
+   MUMPS_INT *xadj_pe,
+   MUMPS_INT *adjncy,
+   MUMPS_INT *nv
+)
+{
+/**********************************
+Argument Comments:
+input:
+-----
+- nvtx          : dimension of the Problem (N)
+- nedges        : number of entries (NZ)
+- adjncy        : non-zeros entries (IW input)
+input/output:
+-------------
+- xadj_pe       : pointer through beginning of column non-zeros entries (PTRAR)
+- on exit, "father array" (PE)
+ouput:
+------
+- nv            : "nfront array" (NV)
+*************************************/
+  graph_t    *G;
+  elimtree_t *T;
+  timings_t  cpus[12];
+  options_t  options[] = { SPACE_ORDTYPE, SPACE_NODE_SELECTION1,
+                    SPACE_NODE_SELECTION2, SPACE_NODE_SELECTION3,
+                    SPACE_DOMAIN_SIZE, 0 };
+  MUMPS_INT *ncolfactor, *ncolupdate, *parent, *vtx2front;
+  MUMPS_INT *first, *link, nfronts, J, K, u, vertex, vertex_root, count;
+      /**************************************************
+       declaration to uncomment if printing ordering
+      ***************************************************
+         FILE *fp1, *fp2;
+         int  *perm,  *iperm;
+      */
+/*** decalage des indices couteux dans un premier temps:
+****  A modifier dans une version ulterieure de MA41GD  */
+  for (u = nvtx; u >= 0; u--)
+   {
+     xadj_pe[u] = xadj_pe[u] - 1;
+   }
+   for (K = nedges-1; K >= 0; K--)
+   {
+      adjncy[K] = adjncy[K] - 1;
+   }
+ /* initialization of the graph */
+   mymalloc(G, 1, graph_t);
+   G->xadj   = xadj_pe;
+   G->adjncy = adjncy;
+   mymalloc(G->vwght, nvtx, MUMPS_INT);
+   G->nvtx = nvtx;
+   G->nedges = nedges;
+   G->type = UNWEIGHTED;
+   G->totvwght = nvtx;
+   for (u = 0; u < nvtx; u++)
+     G->vwght[u] = 1;
+  /* main function of the Ordering */
+   T = SPACE_ordering(G, options, cpus);
+   nfronts = T->nfronts;
+   ncolfactor = T->ncolfactor;
+   ncolupdate = T->ncolupdate;
+   parent = T->parent;
+  /*    firstchild = T->firstchild; */
+   vtx2front = T->vtx2front;
+    /* -----------------------------------------------------------
+     store the vertices/columns of a front in a bucket structure
+     ----------------------------------------------------------- */
+   mymalloc(first, nfronts, MUMPS_INT);
+   mymalloc(link, nvtx, MUMPS_INT);
+   for (J = 0; J < nfronts; J++)
+      first[J] = -1;
+   for (u = nvtx-1; u >= 0; u--)
+      {
+        J = vtx2front[u];
+        link[u] = first[J];
+        first[J] = u;
+      }
+  /* -----------------------------------------------------------
+     fill the two arrays corresponding to the MUMPS tree structure
+     ----------------------------------------------------------- */
+   count = 0;
+   for (K = firstPostorder(T); K != -1; K = nextPostorder(T, K))
+     {
+       vertex_root = first[K];
+       if (vertex_root == -1)
+	 {
+            /* JY: I think this cannot happen */
+	   printf(" Internal error in mumps_pord (cf JY), %d\n",K);
+	   exit(-1);
+	 }
+       /* for the principal column of the supervariable */
+       if (parent[K] == -1)
+	 xadj_pe[vertex_root] = 0; /* root of the tree */
+       else
+	 xadj_pe[vertex_root] = - (first[parent[K]]+1);
+       nv[vertex_root] = ncolfactor[K] + ncolupdate[K];
+       count++;
+       for (vertex = link[vertex_root]; vertex != -1; vertex = link[vertex])
+        /* for the secondary columns of the supervariable */
+	 {
+	   xadj_pe[vertex] = - (vertex_root+1);
+	   nv[vertex] = 0;
+	   count++;
+	 }
+     }
+  /* ----------------------
+     free memory and return
+     ---------------------- */
+  free(first); free(link);
+  free(G->vwght);
+  free(G);
+  freeElimTree(T);
+  return (0);
+}
+/*********************************************************/
+MUMPS_INT mumps_pord_wnd
+(
+        MUMPS_INT nvtx,
+        MUMPS_INT nedges,
+        MUMPS_INT *xadj_pe,
+        MUMPS_INT *adjncy,
+        MUMPS_INT *nv,
+        MUMPS_INT *totw
+)
+{
+/**********************************
+Argument Comments:
+input:
+-----
+- nvtx   : dimension of the Problem (N)
+- nedges : number of entries (NZ)
+- adjncy : non-zeros entries (IW input)
+- totw   : sum of the weigth of the vertices
+input/output:
+-------------
+- xadj_pe : pointer through beginning of column non-zeros entries (PTRAR)
+- on exit, "father array" (PE)
+ouput:
+------
+- nv      : weight of the vertices
+- on exit "nfront array" (NV)
+*************************************/
+        graph_t    *G;
+        elimtree_t *T;
+        timings_t  cpus[12];
+        options_t  options[] = { SPACE_ORDTYPE, SPACE_NODE_SELECTION1,
+                    SPACE_NODE_SELECTION2, SPACE_NODE_SELECTION3,
+                    SPACE_DOMAIN_SIZE, 0 };
+        MUMPS_INT *ncolfactor, *ncolupdate, *parent, *vtx2front;
+        MUMPS_INT *first, *link, nfronts, J, K, u, vertex, vertex_root, count;
+      /**************************************************
+       declaration to uncomment if printing ordering
+      ***************************************************
+         FILE *fp1, *fp2;
+         int  *perm,  *iperm;
+      */
+/*** decalage des indices couteux dans un premier temps:
+****  A modifier dans une version ulterieure de MA41GD  */
+        for (u = nvtx; u >= 0; u--)
+        {
+          xadj_pe[u] = xadj_pe[u] - 1;
+        }
+        for (K = nedges-1; K >= 0; K--)
+        {
+          adjncy[K] = adjncy[K] - 1;
+        }
+ /* initialization of the graph */
+        mymalloc(G, 1, graph_t);
+        G->xadj  = xadj_pe;
+        G->adjncy= adjncy;
+        mymalloc(G->vwght, nvtx, MUMPS_INT);
+        G->nvtx = nvtx;
+        G->nedges = nedges;
+        G->type = WEIGHTED;
+        G->totvwght = (*totw);
+        for (u = 0; u < nvtx; u++)
+          G->vwght[u] = nv[u];
+  /* main function of the Ordering */
+        T = SPACE_ordering(G, options, cpus);
+        nfronts = T->nfronts;
+        ncolfactor = T->ncolfactor;
+        ncolupdate = T->ncolupdate;
+        parent = T->parent;
+  /*    firstchild = T->firstchild; */
+        vtx2front = T->vtx2front;
+    /* -----------------------------------------------------------
+     store the vertices/columns of a front in a bucket structure
+     ----------------------------------------------------------- */
+        mymalloc(first, nfronts, MUMPS_INT);
+        mymalloc(link, nvtx, MUMPS_INT);
+        for (J = 0; J < nfronts; J++)
+          first[J] = -1;
+        for (u = nvtx-1; u >= 0; u--)
+        {
+          J = vtx2front[u];
+          link[u] = first[J];
+          first[J] = u;
+        }
+  /* -----------------------------------------------------------
+     fill the two arrays corresponding to the MUMPS tree structure
+     ----------------------------------------------------------- */
+  count = 0;
+  for (K = firstPostorder(T); K != -1; K = nextPostorder(T, K))
+     {
+       vertex_root = first[K];
+       if (vertex_root == -1)
+	 {
+	   /* JY: I think this cannot happen */
+	   printf(" Internal error in mumps_pord (cf JY), %d\n",K);
+	   exit(-1);
+	 }
+         /* for the principal column of the supervariable */
+       if (parent[K] == -1)
+	 xadj_pe[vertex_root] = 0; /* root of the tree */
+       else
+	 xadj_pe[vertex_root] = - (first[parent[K]]+1);
+       nv[vertex_root] = ncolfactor[K] + ncolupdate[K];
+       count++;
+       for (vertex = link[vertex_root]; vertex != -1; vertex = link[vertex])
+	 /* for the secondary columns of the supervariable */
+	 {
+	   xadj_pe[vertex] = - (vertex_root+1);
+	   nv[vertex] = 0;
+	   count++;
+	 }
+     }
+  /* ----------------------
+     free memory and return
+     ---------------------- */
+  free(first); free(link);
+  free(G->vwght);
+  free(G);
+  freeElimTree(T);
+  return (0);
+}
+#endif /* pord */
+/************************************************************/
+#if defined(scotch) || defined(ptscotch)
+/*int esmumps( const int n, const int iwlen, int * const pe, const int pfree,
+             int * const len, int * const iw, int * const nv, int * const elen,
+             int * const last);*/
+/* Fortran interface to SCOTCH */
+/*#define MUMPS_SCOTCH    \
+  F_SYMBOL(scotch,SCOTCH)*/
+void MUMPS_CALL
+MUMPS_SCOTCH( const MUMPS_INT * const  n,
+              const MUMPS_INT * const  iwlen,
+              MUMPS_INT * const        petab,
+              const MUMPS_INT * const  pfree,
+              MUMPS_INT * const        lentab,
+              MUMPS_INT * const        iwtab,
+              MUMPS_INT * const        nvtab,
+              MUMPS_INT * const        elentab,
+              MUMPS_INT * const        lasttab,
+              MUMPS_INT * const        ncmpa )
+{
+     *ncmpa = esmumps( *n, *iwlen, petab, *pfree,
+                       lentab, iwtab, nvtab, elentab, lasttab );
+}
+#endif /* scotch */
+#if defined(ptscotch)
+/*#include "mpi.h"
+#include <stdio.h>
+#include "ptscotch.h"
+int mumps_dgraphinit( SCOTCH_Dgraph *, MPI_Fint *, MPI_Fint *);
+#define MUMPS_DGRAPHINIT        \
+F_SYMBOL(dgraphinit,DGRAPHINIT)*/
+void MUMPS_CALL
+MUMPS_DGRAPHINIT(SCOTCH_Dgraph *graphptr, MPI_Fint *comm, MPI_Fint *ierr)
+{
+  MPI_Comm  int_comm;
+  int_comm = MPI_Comm_f2c(*comm);
+  *ierr = SCOTCH_dgraphInit(graphptr, int_comm);
+  return;
+}
+#endif
+#if defined(parmetis) || defined(parmetis3)
+/*PARMETIS*/
+#include "parmetis.h"
+void MUMPS_CALL
+MUMPS_PARMETIS(MUMPS_INT *first,      MUMPS_INT *vertloctab, 
+               MUMPS_INT *edgeloctab, MUMPS_INT *numflag, 
+               MUMPS_INT *options,    MUMPS_INT *order, 
+               MUMPS_INT *sizes,      MUMPS_INT *comm,
+               MUMPS_INT *ierr)
+{
+  MPI_Comm  int_comm;
+  int iierr;
+  int_comm = MPI_Comm_f2c(*comm);
+#if defined(parmetis)
+  *ierr=0;
+  iierr=ParMETIS_V3_NodeND(first, vertloctab, edgeloctab, numflag, options, order, sizes, &int_comm);
+  if(iierr != METIS_OK)
+    *ierr=1;
+#else
+  ParMETIS_V3_NodeND(first, vertloctab, edgeloctab, numflag, options, order, sizes, &int_comm);
+#endif
+  return;
+}
+#endif
diff -ruN MUMPS_5.1.2/src/mumps_orderings.h mumps-5.1.2-aster7/src/mumps_orderings.h
--- MUMPS_5.1.2/src/mumps_orderings.h	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/src/mumps_orderings.h	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,75 @@
+/*
+ *
+ *  This file is part of MUMPS 5.0.2, released
+ *  on Fri Jul 15 09:12:54 UTC 2016
+ *
+ *
+ *  Copyright 1991-2016 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria,
+ *  University of Bordeaux.
+ *
+ *  This version of MUMPS is provided to you free of charge. It is
+ *  released under the CeCILL-C license:
+ *  http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
+ *
+ */
+#ifndef MUMPS_ORDERINGS_H
+#define MUMPS_ORDERINGS_H
+#include "mumps_common.h"
+#include "mumps_c_types.h"
+#if defined(pord)
+#include <space.h>
+MUMPS_INT mumps_pord( MUMPS_INT, MUMPS_INT, MUMPS_INT *, MUMPS_INT *, MUMPS_INT * );
+#define MUMPS_PORDF \
+    F_SYMBOL(pordf,PORDF)
+void MUMPS_CALL
+MUMPS_PORDF( MUMPS_INT *nvtx, MUMPS_INT *nedges,
+             MUMPS_INT *xadj, MUMPS_INT *adjncy,
+             MUMPS_INT *nv, MUMPS_INT *ncmpa );
+MUMPS_INT mumps_pord_wnd( MUMPS_INT, MUMPS_INT, MUMPS_INT *, MUMPS_INT *, MUMPS_INT *, MUMPS_INT * );
+#define MUMPS_PORDF_WND          \
+    F_SYMBOL(pordf_wnd,PORDF_WND)
+void MUMPS_CALL
+MUMPS_PORDF_WND( MUMPS_INT *nvtx, MUMPS_INT *nedges,
+                 MUMPS_INT *xadj, MUMPS_INT *adjncy,
+                 MUMPS_INT *nv, MUMPS_INT *ncmpa, MUMPS_INT *totw );
+#endif /*PORD*/
+#if defined(scotch) || defined(ptscotch)
+MUMPS_INT esmumps( const MUMPS_INT n, const MUMPS_INT iwlen, MUMPS_INT * const pe, const MUMPS_INT pfree,
+             MUMPS_INT * const len, MUMPS_INT * const iw, MUMPS_INT * const nv, MUMPS_INT * const elen,
+             MUMPS_INT * const last);
+#define MUMPS_SCOTCH        \
+    F_SYMBOL(scotch,SCOTCH)
+void MUMPS_CALL
+MUMPS_SCOTCH( const MUMPS_INT * const  n,
+              const MUMPS_INT * const  iwlen,
+              MUMPS_INT * const        petab,
+              const MUMPS_INT * const  pfree,
+              MUMPS_INT * const        lentab,
+              MUMPS_INT * const        iwtab,
+              MUMPS_INT * const        nvtab,
+              MUMPS_INT * const        elentab,
+              MUMPS_INT * const        lasttab,
+              MUMPS_INT * const        ncmpa );
+#endif /*scotch or ptscotch*/
+#if defined(ptscotch)
+#include "mpi.h"
+#include <stdio.h>
+#include "ptscotch.h"
+#define MUMPS_DGRAPHINIT \
+  F_SYMBOL(dgraphinit,DGRAPHINIT)
+void MUMPS_CALL
+MUMPS_DGRAPHINIT(SCOTCH_Dgraph *graphptr, MPI_Fint *comm, MPI_Fint *ierr);
+#endif /*ptscotch*/
+#if defined(parmetis) || defined(parmetis3)
+#include "mpi.h"
+#include "parmetis.h"
+#define MUMPS_PARMETIS \
+  F_SYMBOL(parmetis,PARMETIS)
+void MUMPS_CALL
+MUMPS_PARMETIS(MUMPS_INT *first,      MUMPS_INT *vertloctab, 
+               MUMPS_INT *edgeloctab, MUMPS_INT *numflag, 
+               MUMPS_INT *options,    MUMPS_INT *order, 
+               MUMPS_INT *sizes,      MUMPS_INT *comm,
+               MUMPS_INT *ierr);
+#endif /*PARMETIS*/
+#endif /* MUMPS_ORDERINGS_H */
diff -ruN MUMPS_5.1.2/src/smumps_restart.F mumps-5.1.2-aster7/src/smumps_restart.F
--- MUMPS_5.1.2/src/smumps_restart.F	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/src/smumps_restart.F	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,2648 @@
+C
+C  This file is part of MUMPS 5.0.2, released
+C  on Fri Jul 15 09:12:54 UTC 2016
+C
+C
+C  Copyright 1991-2016 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria,
+C  University of Bordeaux.
+C
+C  This version of MUMPS is provided to you free of charge. It is
+C  released under the CeCILL-C license:
+C  http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
+C
+      SUBROUTINE SMUMPS_STOP(id,OUTFILE)
+      USE SMUMPS_STRUC_DEF
+      IMPLICIT NONE
+      INCLUDE 'mpif.h'
+      CHARACTER(len=*), intent(in) :: OUTFILE
+      INTEGER::i1,i2,NBVARIABLES,NBVARIABLES_ROOT
+      INTEGER::OUT,err,OUTROOT
+      CHARACTER(len=100), allocatable, dimension(:)::VARIABLES
+      CHARACTER(len=100), allocatable, dimension(:)::VARIABLES_ROOT
+      CHARACTER(len=100):: OUTFILEMAIN,OUTFILEROOT
+      CHARACTER(len=3) :: STRING_ID
+      LOGICAL :: error
+      INTEGER MASTER
+      PARAMETER( MASTER = 0 )
+      TYPE (SMUMPS_STRUC) :: id
+      id%IF_RESTARTING=.TRUE.
+      NBVARIABLES=171
+      allocate(VARIABLES(NBVARIABLES))
+      VARIABLES(171)="NB_SINGULAR_VALUES"
+      VARIABLES(170)="SINGULAR_VALUES"
+      VARIABLES(169)="IF_RESTARTING"
+      VARIABLES(168)="L0_OMP_MAPPING"
+      VARIABLES(167)="PTR_LEAFS_L0_OMP"
+      VARIABLES(166)="PERM_L0_OMP"
+      VARIABLES(165)="VIRT_L0_OMP"
+      VARIABLES(164)="PHYS_L0_OMP"
+      VARIABLES(163)="IPOOL_AFTER_L0_OMP"
+      VARIABLES(162)="IPOOL_BEFORE_L0_OMP"
+      VARIABLES(161)="THREAD_LA"
+      VARIABLES(160)="LL0_OMP_MAPPING"
+      VARIABLES(159)="L_VIRT_L0_OMP"
+      VARIABLES(158)="L_PHYS_L0_OMP"
+      VARIABLES(157)="LPOOL_BEFORE_L0_OMP"
+      VARIABLES(156)="LPOOL_AFTER_L0_OMP"
+      VARIABLES(155)="NBGRP"
+      VARIABLES(154)="LRGROUPS"
+      VARIABLES(153)="root"
+      VARIABLES(152)="WORKING"
+      VARIABLES(151)="IPTR_WORKING"
+      VARIABLES(150)="pad14"
+      VARIABLES(149)="SUP_PROC"
+      VARIABLES(148)="PIVNUL_LIST"
+      VARIABLES(147)="OOC_FILE_NAME_LENGTH"
+      VARIABLES(146)="OOC_FILE_NAMES"
+      VARIABLES(145)="OOC_NB_FILE_TYPE"
+      VARIABLES(144)="OOC_NB_FILES"
+      VARIABLES(143)="OOC_TOTAL_NB_NODES"
+      VARIABLES(142)="OOC_VADDR"
+      VARIABLES(141)="OOC_SIZE_OF_BLOCK"
+      VARIABLES(140)="pad13"
+      VARIABLES(139)="OOC_INODE_SEQUENCE"
+      VARIABLES(138)="OOC_MAX_NB_NODES_FOR_ZONE"
+      VARIABLES(137)="INSTANCE_NUMBER"
+      VARIABLES(136)="pad12"
+      VARIABLES(135)="CB_SON_SIZE"
+      VARIABLES(134)="DKEEP"
+      VARIABLES(133)="LWK_USER"
+      VARIABLES(132)="NBSA_LOCAL"
+      VARIABLES(131)="WK_USER"
+      VARIABLES(130)="CROIX_MANU"
+      VARIABLES(129)="SCHED_SBTR"
+      VARIABLES(128)="SCHED_GRP"
+      VARIABLES(127)="SCHED_DEP"
+      VARIABLES(126)="SBTR_ID"
+      VARIABLES(125)="DEPTH_FIRST_SEQ"
+      VARIABLES(124)="DEPTH_FIRST"
+      VARIABLES(123)="MY_NB_LEAF"
+      VARIABLES(122)="MY_FIRST_LEAF"
+      VARIABLES(121)="MY_ROOT_SBTR"
+      VARIABLES(120)="COST_TRAV"
+      VARIABLES(119)="MEM_SUBTREE"
+      VARIABLES(118)="RHSCOMP"
+      VARIABLES(117)="POSINRHSCOMP_COL"
+      VARIABLES(116)="POSINRHSCOMP_ROW"
+      VARIABLES(115)="POSINRHSCOMP_COL_ALLOC"
+      VARIABLES(114)="MEM_DIST"
+      VARIABLES(113)="I_AM_CAND"
+      VARIABLES(112)="TAB_POS_IN_PERE"
+      VARIABLES(111)="FUTURE_NIV2"
+      VARIABLES(110)="ISTEP_TO_INIV2"
+      VARIABLES(109)="CANDIDATES"
+      VARIABLES(108)="ELTPROC"
+      VARIABLES(107)="pad11"
+      VARIABLES(106)="NA_ELT"
+      VARIABLES(105)="LELTVAR"
+      VARIABLES(104)="NELT_loc"
+      VARIABLES(103)="DBLARR"
+      VARIABLES(102)="INTARR"
+      VARIABLES(101)="PROCNODE"
+      VARIABLES(100)="S"
+      VARIABLES(99)="PTRFAC"
+      VARIABLES(98)="PTLUST_S"
+      VARIABLES(97)="PROCNODE_STEPS"
+      VARIABLES(96)="NA"
+      VARIABLES(95)="FRTELT"
+      VARIABLES(94)="FRTPTR"
+      VARIABLES(93)="PTRAR"
+      VARIABLES(92)="FILS"
+      VARIABLES(91)="DAD_STEPS"
+      VARIABLES(90)="FRERE_STEPS"
+      VARIABLES(89)="Step2node"
+      VARIABLES(88)="ND_STEPS"
+      VARIABLES(87)="NE_STEPS"
+      VARIABLES(86)="STEP"
+      VARIABLES(85)="NBSA"
+      VARIABLES(84)="LNA"
+      VARIABLES(83)="KEEP"
+      VARIABLES(82)="Deficiency"
+      VARIABLES(81)="MAXIS1"
+      VARIABLES(80)="IS1"
+      VARIABLES(79)="IS"
+      VARIABLES(78)="BUFR"
+      VARIABLES(77)="POIDS"
+      VARIABLES(76)="LBUFR_BYTES"
+      VARIABLES(75)="LBUFR"
+      VARIABLES(74)="ASS_IRECV"
+      VARIABLES(73)="NSLAVES"
+      VARIABLES(72)="NPROCS"
+      VARIABLES(71)="MYID"
+      VARIABLES(70)="COMM_LOAD"
+      VARIABLES(69)="MYID_NODES"
+      VARIABLES(68)="COMM_NODES"
+      VARIABLES(67)="INST_Number"
+      VARIABLES(66)="MAX_SURF_MASTER"
+      VARIABLES(65)="KEEP8"
+      VARIABLES(64)="pad8"
+      VARIABLES(63)="WRITE_PROBLEM"
+      VARIABLES(62)="OOC_PREFIX"
+      VARIABLES(61)="OOC_TMPDIR"
+      VARIABLES(60)="VERSION_NUMBER"
+      VARIABLES(59)="MAPPING"
+      VARIABLES(58)="LISTVAR_SCHUR"
+      VARIABLES(57)="SCHUR_CINTERFACE"
+      VARIABLES(56)="SCHUR"
+      VARIABLES(55)="SIZE_SCHUR"
+      VARIABLES(54)="SCHUR_LLD"
+      VARIABLES(53)="SCHUR_NLOC"
+      VARIABLES(52)="SCHUR_MLOC"
+      VARIABLES(51)="NBLOCK"
+      VARIABLES(50)="MBLOCK"
+      VARIABLES(49)="NPCOL"
+      VARIABLES(48)="NPROW"
+      VARIABLES(47)="UNS_PERM"
+      VARIABLES(46)="SYM_PERM"
+      VARIABLES(45)="RINFOG"
+      VARIABLES(44)="RINFO"
+      VARIABLES(43)="CNTL"
+      VARIABLES(42)="COST_SUBTREES"
+      VARIABLES(41)="INFOG"
+      VARIABLES(40)="INFO"
+      VARIABLES(39)="ICNTL"
+      VARIABLES(38)="pad5"
+      VARIABLES(37)="LREDRHS"
+      VARIABLES(36)="LSOL_loc"
+      VARIABLES(35)="NZ_RHS"
+      VARIABLES(34)="NRHS"
+      VARIABLES(33)="LRHS"
+      VARIABLES(32)="ISOL_loc"
+      VARIABLES(31)="IRHS_PTR"
+      VARIABLES(30)="IRHS_SPARSE"
+      VARIABLES(29)="SOL_loc"
+      VARIABLES(28)="RHS_SPARSE"
+      VARIABLES(27)="REDRHS"
+      VARIABLES(26)="RHS"
+      VARIABLES(25)="PERM_IN"
+      VARIABLES(24)="pad4"
+      VARIABLES(23)="A_ELT"
+      VARIABLES(22)="ELTVAR"
+      VARIABLES(21)="ELTPTR"
+      VARIABLES(20)="pad3"
+      VARIABLES(19)="NELT"
+      VARIABLES(18)="pad2"
+      VARIABLES(17)="A_loc"
+      VARIABLES(16)="JCN_loc"
+      VARIABLES(15)="IRN_loc"
+      VARIABLES(14)="pad1"
+      VARIABLES(13)="NZ_loc"
+      VARIABLES(12)="pad0"
+      VARIABLES(11)="ROWSCA"
+      VARIABLES(10)="COLSCA"
+      VARIABLES(9)="JCN"
+      VARIABLES(8)="IRN"
+      VARIABLES(7)="A"
+      VARIABLES(6)="NZ"
+      VARIABLES(5)="N"
+      VARIABLES(4)="JOB"
+      VARIABLES(3)="PAR"
+      VARIABLES(2)="SYM"
+      VARIABLES(1)="COMM"
+      NBVARIABLES_ROOT=34
+      allocate(VARIABLES_ROOT(NBVARIABLES_ROOT))
+      VARIABLES_ROOT(34)="NB_SINGULAR_VALUES"
+      VARIABLES_ROOT(33)="SINGULAR_VALUES"
+      VARIABLES_ROOT(32)="SVD_VT"
+      VARIABLES_ROOT(31)="SVD_U"
+      VARIABLES_ROOT(30)="gridinit_done"
+      VARIABLES_ROOT(29)="yes"
+      VARIABLES_ROOT(28)="rootpad3"
+      VARIABLES_ROOT(27)="QR_RCOND"
+      VARIABLES_ROOT(26)="rootpad"
+      VARIABLES_ROOT(25)="RHS_ROOT"
+      VARIABLES_ROOT(24)="rootpad2"
+      VARIABLES_ROOT(23)="QR_TAU"
+      VARIABLES_ROOT(22)="SCHUR_POINTER"
+      VARIABLES_ROOT(21)="RHS_CNTR_MASTER_ROOT"
+      VARIABLES_ROOT(20)="rootpad1"
+      VARIABLES_ROOT(19)="IPIV"
+      VARIABLES_ROOT(18)="RG2L_COL"
+      VARIABLES_ROOT(17)="RG2L_ROW"
+      VARIABLES_ROOT(16)="rootpad0"
+      VARIABLES_ROOT(15)="LPIV"
+      VARIABLES_ROOT(14)="CNTXT_BLACS"
+      VARIABLES_ROOT(13)="DESCRIPTOR"
+      VARIABLES_ROOT(12)="TOT_ROOT_SIZE"
+      VARIABLES_ROOT(11)="ROOT_SIZE"
+      VARIABLES_ROOT(10)="RHS_NLOC"
+      VARIABLES_ROOT(9)="SCHUR_LLD"
+      VARIABLES_ROOT(8)="SCHUR_NLOC"
+      VARIABLES_ROOT(7)="SCHUR_MLOC"
+      VARIABLES_ROOT(6)="MYCOL"
+      VARIABLES_ROOT(5)="MYROW"
+      VARIABLES_ROOT(4)="NPCOL"
+      VARIABLES_ROOT(3)="NPROW"
+      VARIABLES_ROOT(2)="NBLOCK"
+      VARIABLES_ROOT(1)="MBLOCK"
+      if(((id%ICNTL(3).GT.0).AND.(id%MYID .EQ. MASTER))) then
+         write(*,*) "DUMPING MUMPS STRUCTURE IN FILE:",OUTFILE
+      endif
+      error=.false.
+      write (STRING_ID, '(i3)') id%MYID
+      OUT=42+id%MYID
+      OUTFILEMAIN=trim(adjustl(OUTFILE)) // trim(adjustl(STRING_ID))
+      open(UNIT=OUT,FILE=OUTFILEMAIN,STATUS='replace',
+     &     form='unformatted',iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN SMUMPS_STOP CANNOT OPEN FILE: "
+     &        //trim(adjustl(OUTFILEMAIN))
+         error=.true.
+         goto 100
+      endif      
+      DO i1=1,NBVARIABLES 
+         SELECT CASE(trim(adjustl(VARIABLES(i1))))
+         CASE("COMM") 
+         CASE("SYM")
+         CASE("PAR")
+         CASE("JOB")
+            write(OUT) id%JOB
+         CASE("N")
+            write(OUT) id%N
+         CASE("ICNTL")
+            write(OUT) id%ICNTL
+         CASE("INFO")
+            write(OUT) id%INFO
+         CASE("INFOG")
+            write(OUT) id%INFOG
+         CASE("COST_SUBTREES")
+            write(OUT) id%COST_SUBTREES
+         CASE("CNTL")
+            write(OUT) id%CNTL
+         CASE("RINFO")
+            write(OUT) id%RINFO
+         CASE("RINFOG")
+            write(OUT) id%RINFOG
+         CASE("KEEP8")
+            write(OUT) id%KEEP8
+         CASE("KEEP")
+            write(OUT) id%KEEP
+         CASE("DKEEP")
+            write(OUT) id%DKEEP    
+         CASE("NZ")
+            write(OUT) id%NZ
+         CASE("A")
+            IF(associated(id%A)) THEN
+               write(OUT) size(id%A,1)
+               write(OUT) id%A
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IRN")
+            IF(associated(id%IRN)) THEN
+               write(OUT) size(id%IRN,1)
+               write(OUT) id%IRN
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("JCN")
+            IF(associated(id%JCN)) THEN
+               write(OUT) size(id%JCN,1)
+               write(OUT) id%JCN
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("COLSCA")
+            IF(associated(id%COLSCA)) THEN
+               write(OUT) size(id%COLSCA,1)
+               write(OUT) id%COLSCA
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF 
+         CASE("ROWSCA")
+            IF(associated(id%ROWSCA)) THEN
+               write(OUT) size(id%ROWSCA,1)
+               write(OUT) id%ROWSCA
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NZ_loc")
+            write(OUT) id%NZ_loc
+         CASE("IRN_loc")
+            IF(associated(id%IRN_loc)) THEN
+               write(OUT) size(id%IRN_loc,1)
+               write(OUT) id%IRN_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("JCN_loc")
+            IF(associated(id%JCN_loc)) THEN
+               write(OUT) size(id%JCN_loc,1)
+               write(OUT) id%JCN_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("A_loc")
+            IF(associated(id%A_loc)) THEN
+               write(OUT) size(id%A_loc,1)
+               write(OUT) id%A_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NELT")
+            write(OUT) id%NELT
+         CASE("ELTPTR")
+            IF(associated(id%ELTPTR)) THEN
+               write(OUT) size(id%ELTPTR,1)
+               write(OUT) id%ELTPTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("ELTVAR")
+            IF(associated(id%ELTVAR)) THEN
+               write(OUT) size(id%ELTVAR,1)
+               write(OUT) id%ELTVAR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("A_ELT")
+            IF(associated(id%A_ELT)) THEN
+               write(OUT) size(id%A_ELT,1)
+               write(OUT) id%A_ELT
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PERM_IN")
+            IF(associated(id%PERM_IN)) THEN
+               write(OUT) size(id%PERM_IN,1)
+               write(OUT) id%PERM_IN
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("RHS")
+            IF(associated(id%RHS)) THEN
+               write(OUT) size(id%RHS,1)
+               write(OUT) id%RHS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("REDRHS")
+            IF(associated(id%REDRHS)) THEN
+               write(OUT) size(id%REDRHS,1)
+               write(OUT) id%REDRHS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("RHS_SPARSE")
+            IF(associated(id%RHS_SPARSE)) THEN
+               write(OUT) size(id%RHS_SPARSE,1)
+               write(OUT) id%RHS_SPARSE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SOL_loc")
+            IF(associated(id%SOL_loc)) THEN
+               write(OUT) size(id%SOL_loc,1)
+               write(OUT) id%SOL_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IRHS_SPARSE")
+            IF(associated(id%IRHS_SPARSE)) THEN
+               write(OUT) size(id%IRHS_SPARSE,1)
+               write(OUT) id%IRHS_SPARSE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IRHS_PTR")
+            IF(associated(id%IRHS_PTR)) THEN
+               write(OUT) size(id%IRHS_PTR,1)
+               write(OUT) id%IRHS_PTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("ISOL_loc")
+            IF(associated(id%ISOL_loc)) THEN
+               write(OUT) size(id%ISOL_loc,1)
+               write(OUT) id%ISOL_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("LRHS")
+            write(OUT) id%LRHS
+         CASE("NRHS")
+            write(OUT) id%NRHS
+         CASE("NZ_RHS")
+            write(OUT) id%NZ_RHS
+         CASE("LSOL_loc")
+            write(OUT) id%LSOL_loc
+         CASE("LREDRHS")
+            write(OUT) id%LREDRHS
+         CASE("SYM_PERM")
+            IF(associated(id%SYM_PERM)) THEN
+               write(OUT) size(id%SYM_PERM,1)
+               write(OUT) id%SYM_PERM
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("UNS_PERM")
+            IF(associated(id%UNS_PERM)) THEN
+               write(OUT) size(id%UNS_PERM,1)
+               write(OUT) id%UNS_PERM
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NPROW")
+            write(OUT) id%NPROW
+         CASE("NPCOL")
+            write(OUT) id%NPCOL
+         CASE("MBLOCK")
+            write(OUT) id%MBLOCK
+         CASE("NBLOCK")
+            write(OUT) id%NBLOCK
+         CASE("SCHUR_MLOC")
+            write(OUT) id%SCHUR_MLOC
+         CASE("SCHUR_NLOC")
+            write(OUT) id%SCHUR_NLOC
+         CASE("SCHUR_LLD")
+            write(OUT) id%SCHUR_LLD
+         CASE("SIZE_SCHUR")
+            write(OUT) id%SIZE_SCHUR
+         CASE("SCHUR")
+            IF(associated(id%SCHUR)) THEN
+               write(OUT) size(id%SCHUR,1)
+               write(OUT) id%SCHUR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SCHUR_CINTERFACE")
+            IF(associated(id%SCHUR_CINTERFACE)) THEN
+               write(OUT) size(id%SCHUR_CINTERFACE,1)
+               write(OUT) id%SCHUR_CINTERFACE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("LISTVAR_SCHUR")
+            IF(associated(id%LISTVAR_SCHUR)) THEN
+               write(OUT) size(id%LISTVAR_SCHUR,1)
+               write(OUT) id%LISTVAR_SCHUR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MAPPING")
+            IF(associated(id%MAPPING)) THEN
+               write(OUT) size(id%MAPPING,1)
+               write(OUT) id%MAPPING
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("VERSION_NUMBER")
+            write(OUT) id%VERSION_NUMBER
+         CASE("OOC_TMPDIR")
+            write(OUT) id%OOC_TMPDIR
+         CASE("OOC_PREFIX")
+            write(OUT) id%OOC_PREFIX
+         CASE("WRITE_PROBLEM")
+            write(OUT) id%WRITE_PROBLEM
+         CASE("MAX_SURF_MASTER")
+            write(OUT) id%MAX_SURF_MASTER
+         CASE("INST_Number")
+            write(OUT) id%INST_Number
+         CASE("COMM_NODES")
+            write(OUT) id%COMM_NODES
+         CASE("MYID_NODES")
+            write(OUT) id%MYID_NODES
+         CASE("COMM_LOAD")
+            write(OUT) id%COMM_LOAD
+         CASE("MYID")
+            write(OUT) id%MYID
+         CASE("NPROCS")
+            write(OUT) id%NPROCS
+         CASE("NSLAVES")
+            write(OUT) id%NSLAVES
+         CASE("ASS_IRECV")
+            write(OUT) id%ASS_IRECV
+         CASE("LBUFR")
+            write(OUT) id%LBUFR
+         CASE("LBUFR_BYTES")
+            write(OUT) id%LBUFR_BYTES
+         CASE("POIDS")
+            IF(associated(id%POIDS)) THEN 
+               write(OUT) size(id%POIDS,1)
+               write(OUT) id%POIDS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("BUFR")
+            IF(associated(id%BUFR)) THEN 
+               write(OUT) size(id%BUFR,1)
+               write(OUT) id%BUFR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IS")
+            IF(associated(id%IS)) THEN 
+               write(OUT) size(id%IS,1)
+               write(OUT) id%IS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IS1")
+            IF(associated(id%IS1)) THEN 
+               write(OUT) size(id%IS1,1)
+               write(OUT) id%IS1
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MAXIS1")
+            write(OUT) id%MAXIS1
+         CASE("Deficiency")
+            write(OUT) id%Deficiency
+         CASE("LNA")
+            write(OUT) id%LNA
+         CASE("NBSA")
+            write(OUT) id%NBSA
+         CASE("STEP")
+            IF(associated(id%STEP)) THEN
+               write(OUT) size(id%STEP,1)
+               write(OUT) id%STEP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NE_STEPS")
+            IF(associated(id%NE_STEPS)) THEN
+               write(OUT) size(id%NE_STEPS,1)
+               write(OUT) id%NE_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("ND_STEPS")
+            IF(associated(id%ND_STEPS)) THEN
+               write(OUT) size(id%ND_STEPS,1)
+               write(OUT) id%ND_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("Step2node")
+            IF(associated(id%Step2node)) THEN
+               write(OUT) size(id%Step2node,1)
+               write(OUT) id%Step2node
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FRERE_STEPS")
+            IF(associated(id%FRERE_STEPS)) THEN
+               write(OUT) size(id%FRERE_STEPS,1)
+               write(OUT) id%FRERE_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DAD_STEPS")
+            IF(associated(id%DAD_STEPS)) THEN
+               write(OUT) size(id%DAD_STEPS,1)
+               write(OUT) id%DAD_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FILS")
+            IF(associated(id%FILS)) THEN
+               write(OUT) size(id%FILS,1)
+               write(OUT) id%FILS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PTRAR")
+            IF(associated(id%PTRAR)) THEN
+               write(OUT) size(id%PTRAR,1)
+               write(OUT) id%PTRAR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FRTPTR")
+            IF(associated(id%FRTPTR)) THEN
+               write(OUT) size(id%FRTPTR,1)
+               write(OUT) id%FRTPTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FRTELT")
+            IF(associated(id%FRTELT)) THEN
+               write(OUT) size(id%FRTELT,1)
+               write(OUT) id%FRTELT
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NA")
+            IF(associated(id%NA)) THEN
+               write(OUT) size(id%NA,1)
+               write(OUT) id%NA
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PROCNODE_STEPS")
+            IF(associated(id%PROCNODE_STEPS)) THEN
+               write(OUT) size(id%PROCNODE_STEPS,1)
+               write(OUT) id%PROCNODE_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PTLUST_S")
+            IF(associated(id%PTLUST_S)) THEN
+               write(OUT) size(id%PTLUST_S,1)
+               write(OUT) id%PTLUST_S
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PTRFAC")
+            IF(associated(id%PTRFAC)) THEN
+               write(OUT) size(id%PTRFAC,1)
+               write(OUT) id%PTRFAC
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("S")
+            IF(associated(id%S)) THEN
+               write(OUT) id%KEEP8(23)
+               write(OUT) id%S
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PROCNODE")
+            IF(associated(id%PROCNODE)) THEN
+               write(OUT) size(id%PROCNODE,1)
+               write(OUT) id%PROCNODE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("INTARR")
+            IF(associated(id%INTARR)) THEN
+               write(OUT) size(id%INTARR,1)
+               write(OUT) id%INTARR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DBLARR")
+            IF(associated(id%DBLARR)) THEN
+               write(OUT) size(id%DBLARR,1)
+               write(OUT) id%DBLARR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NELT_loc")
+            write(OUT) id%NELT_loc
+         CASE("LELTVAR")
+            write(OUT) id%LELTVAR
+         CASE("NA_ELT")
+            write(OUT) id%NA_ELT
+         CASE("ELTPROC")
+            IF(associated(id%ELTPROC)) THEN
+               write(OUT) size(id%ELTPROC,1)
+               write(OUT) id%ELTPROC
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("CANDIDATES")
+            IF(associated(id%CANDIDATES)) THEN
+               write(OUT) size(id%CANDIDATES,1)
+     &              ,size(id%CANDIDATES,2)
+               write(OUT) id%CANDIDATES
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("ISTEP_TO_INIV2")
+            IF(associated(id%ISTEP_TO_INIV2)) THEN
+               write(OUT) size(id%ISTEP_TO_INIV2,1)
+               write(OUT) id%ISTEP_TO_INIV2
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FUTURE_NIV2")
+            IF(associated(id%FUTURE_NIV2)) THEN
+               write(OUT) size(id%FUTURE_NIV2,1)
+               write(OUT) id%FUTURE_NIV2
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("TAB_POS_IN_PERE")
+            IF(associated(id%TAB_POS_IN_PERE)) THEN
+               write(OUT) size(id%TAB_POS_IN_PERE,1)
+     &              ,size(id%TAB_POS_IN_PERE,2)
+               write(OUT) id%TAB_POS_IN_PERE
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("I_AM_CAND")
+            IF(associated(id%I_AM_CAND)) THEN
+               write(OUT) size(id%I_AM_CAND,1)
+               write(OUT) id%I_AM_CAND
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MEM_DIST")
+            IF(associated(id%MEM_DIST)) THEN
+               write(OUT) size(id%MEM_DIST,1)
+               write(OUT) id%MEM_DIST
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("POSINRHSCOMP_ROW")
+            IF(associated(id%POSINRHSCOMP_ROW)) THEN 
+               write(OUT) size(id%POSINRHSCOMP_ROW,1)
+               write(OUT) id%POSINRHSCOMP_ROW
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("POSINRHSCOMP_COL_ALLOC")
+            write(OUT) id%POSINRHSCOMP_COL_ALLOC
+         CASE("POSINRHSCOMP_COL")
+            IF(associated(id%POSINRHSCOMP_COL)) THEN
+               IF(id%POSINRHSCOMP_COL_ALLOC) THEN
+                  write(OUT) size(id%POSINRHSCOMP_COL,1)
+                  write(OUT) id%POSINRHSCOMP_COL
+               ELSE
+                  write(OUT) size(id%POSINRHSCOMP_COL,1)
+                  write(OUT) -999
+               ENDIF
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("RHSCOMP")
+            IF(associated(id%RHSCOMP)) THEN
+               write(OUT) size(id%RHSCOMP,1)
+               write(OUT) id%RHSCOMP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MEM_SUBTREE")
+            IF(associated(id%MEM_SUBTREE)) THEN
+               write(OUT) size(id%MEM_SUBTREE,1)
+               write(OUT) id%MEM_SUBTREE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("COST_TRAV")
+            IF(associated(id%COST_TRAV)) THEN
+               write(OUT) size(id%COST_TRAV,1)
+               write(OUT) id%COST_TRAV
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MY_ROOT_SBTR")
+            IF(associated(id%MY_ROOT_SBTR)) THEN
+               write(OUT) size(id%MY_ROOT_SBTR,1)
+               write(OUT) id%MY_ROOT_SBTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MY_FIRST_LEAF")
+            IF(associated(id%MY_FIRST_LEAF)) THEN
+               write(OUT) size(id%MY_FIRST_LEAF,1)
+               write(OUT) id%MY_FIRST_LEAF
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MY_NB_LEAF")
+            IF(associated(id%MY_NB_LEAF)) THEN
+               write(OUT) size(id%MY_NB_LEAF,1)
+               write(OUT) id%MY_NB_LEAF
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DEPTH_FIRST")
+            IF(associated(id%DEPTH_FIRST)) THEN
+               write(OUT) size(id%DEPTH_FIRST,1)
+               write(OUT) id%DEPTH_FIRST
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DEPTH_FIRST_SEQ")
+            IF(associated(id%DEPTH_FIRST_SEQ)) THEN
+               write(OUT) size(id%DEPTH_FIRST_SEQ,1)
+               write(OUT) id%DEPTH_FIRST_SEQ
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SBTR_ID")
+            IF(associated(id%SBTR_ID)) THEN
+               write(OUT) size(id%SBTR_ID,1)
+               write(OUT) id%SBTR_ID
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SCHED_DEP")
+            IF(associated(id%SCHED_DEP)) THEN
+               write(OUT) size(id%SCHED_DEP,1)
+               write(OUT) id%SCHED_DEP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SCHED_GRP")
+            IF(associated(id%SCHED_GRP)) THEN
+               write(OUT) size(id%SCHED_GRP,1)
+               write(OUT) id%SCHED_GRP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("CROIX_MANU")
+            IF(associated(id%CROIX_MANU)) THEN
+               write(OUT) size(id%CROIX_MANU,1)
+               write(OUT) id%CROIX_MANU
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("WK_USER")
+            IF(associated(id%WK_USER)) THEN
+               write(OUT) id%KEEP8(24)
+               write(OUT) id%WK_USER
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NBSA_LOCAL")
+            write(OUT) id%NBSA_LOCAL
+         CASE("LWK_USER")
+            write(OUT) id%LWK_USER
+         CASE("CB_SON_SIZE")
+            IF(associated(id%CB_SON_SIZE)) THEN
+               write(OUT) size(id%CB_SON_SIZE,1)
+               write(OUT) id%CB_SON_SIZE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("INSTANCE_NUMBER")
+            write(OUT) id%INSTANCE_NUMBER
+         CASE("OOC_MAX_NB_NODES_FOR_ZONE")
+            write(OUT) id%OOC_MAX_NB_NODES_FOR_ZONE
+         CASE("OOC_INODE_SEQUENCE")
+            IF(associated(id%OOC_INODE_SEQUENCE)) THEN
+               write(OUT) size(id%OOC_INODE_SEQUENCE,1)
+     &              ,size(id%OOC_INODE_SEQUENCE,2)
+               write(OUT) id%OOC_INODE_SEQUENCE
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_SIZE_OF_BLOCK")
+            IF(associated(id%OOC_SIZE_OF_BLOCK)) THEN
+               write(OUT) size(id%OOC_SIZE_OF_BLOCK,1)
+     &              ,size(id%OOC_SIZE_OF_BLOCK,2)  
+               write(OUT) id%OOC_SIZE_OF_BLOCK
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_VADDR")
+            IF(associated(id%OOC_VADDR)) THEN
+               write(OUT) size(id%OOC_VADDR,1),size(id%OOC_VADDR,2)
+               write(OUT) id%OOC_VADDR
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_TOTAL_NB_NODES")
+            IF(associated(id%OOC_TOTAL_NB_NODES)) THEN
+               write(OUT) size(id%OOC_TOTAL_NB_NODES,1)
+               write(OUT) id%OOC_TOTAL_NB_NODES
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_NB_FILES")
+            IF(associated(id%OOC_NB_FILES)) THEN
+               write(OUT) size(id%OOC_NB_FILES,1)
+               write(OUT) id%OOC_NB_FILES
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_NB_FILE_TYPE")
+            write(OUT) id%OOC_NB_FILE_TYPE
+         CASE("OOC_FILE_NAMES")
+            IF(associated(id%OOC_FILE_NAMES)) THEN
+               write(OUT) size(id%OOC_FILE_NAMES,1)
+     &              ,size(id%OOC_FILE_NAMES,2)
+               write(OUT) id%OOC_FILE_NAMES
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_FILE_NAME_LENGTH")
+            IF(associated(id%OOC_FILE_NAME_LENGTH)) THEN
+               write(OUT) size(id%OOC_FILE_NAME_LENGTH,1)
+               write(OUT) id%OOC_FILE_NAME_LENGTH
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PIVNUL_LIST")
+            IF(associated(id%PIVNUL_LIST)) THEN
+               write(OUT) size(id%PIVNUL_LIST,1)
+               write(OUT) id%PIVNUL_LIST
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SUP_PROC")
+            IF(associated(id%SUP_PROC)) THEN
+               write(OUT) size(id%SUP_PROC,1),size(id%SUP_PROC,2)
+               write(OUT) id%SUP_PROC
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("IPTR_WORKING")
+            IF(associated(id%IPTR_WORKING)) THEN
+               write(OUT) size(id%IPTR_WORKING,1)
+               write(OUT) id%IPTR_WORKING
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("WORKING")
+            IF(associated(id%WORKING)) THEN
+               write(OUT) size(id%WORKING,1)
+               write(OUT) id%WORKING
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("root")
+         CASE("NBGRP")
+           write(OUT) id%NBGRP
+        CASE("LRGROUPS")
+           IF(associated(id%LRGROUPS)) THEN
+              write(OUT) size(id%LRGROUPS,1)
+              write(OUT) id%LRGROUPS
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("SCHED_SBTR")
+           IF(associated(id%SCHED_SBTR)) THEN
+              write(OUT) size(id%SCHED_SBTR,1)
+              write(OUT) id%SCHED_SBTR
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("LPOOL_AFTER_L0_OMP")
+           write(OUT) id%LPOOL_AFTER_L0_OMP
+        CASE("LPOOL_BEFORE_L0_OMP")
+           write(OUT) id%LPOOL_BEFORE_L0_OMP
+        CASE("L_PHYS_L0_OMP")
+           write(OUT) id%L_PHYS_L0_OMP
+        CASE("L_VIRT_L0_OMP")        
+           write(OUT) id%L_VIRT_L0_OMP
+        CASE("LL0_OMP_MAPPING")
+           write(OUT) id%LL0_OMP_MAPPING
+        CASE("THREAD_LA")
+           write(OUT) id%THREAD_LA
+        CASE("IPOOL_AFTER_L0_OMP")
+           IF(associated(id%IPOOL_AFTER_L0_OMP)) THEN
+              write(OUT) size(id%IPOOL_AFTER_L0_OMP,1)
+              write(OUT) id%IPOOL_AFTER_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("IPOOL_BEFORE_L0_OMP")
+           IF(associated(id%IPOOL_BEFORE_L0_OMP)) THEN
+              write(OUT) size(id%IPOOL_BEFORE_L0_OMP,1)
+              write(OUT) id%IPOOL_BEFORE_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("PHYS_L0_OMP")
+           IF(associated(id%PHYS_L0_OMP)) THEN
+              write(OUT) size(id%PHYS_L0_OMP,1)
+              write(OUT) id%PHYS_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("VIRT_L0_OMP")
+           IF(associated(id%VIRT_L0_OMP)) THEN
+              write(OUT) size(id%VIRT_L0_OMP,1)
+              write(OUT) id%VIRT_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("PERM_L0_OMP")
+           IF(associated(id%PERM_L0_OMP)) THEN
+              write(OUT) size(id%PERM_L0_OMP,1)
+              write(OUT) id%PERM_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("PTR_LEAFS_L0_OMP")
+           IF(associated(id%PTR_LEAFS_L0_OMP)) THEN
+              write(OUT) size(id%PTR_LEAFS_L0_OMP,1)
+              write(OUT) id%PTR_LEAFS_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("L0_OMP_MAPPING")
+          IF(associated(id%L0_OMP_MAPPING)) THEN
+              write(OUT) size(id%L0_OMP_MAPPING,1)
+              write(OUT) id%L0_OMP_MAPPING
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("IF_RESTARTING")
+           write(OUT) id%IF_RESTARTING
+      CASE("SINGULAR_VALUES")
+         IF(associated(id%SINGULAR_VALUES)) THEN
+            write(OUT) size(id%SINGULAR_VALUES,1)
+            write(OUT) id%SINGULAR_VALUES
+         ELSE
+            write(OUT) -999,-998
+            write(OUT) -999
+         ENDIF 
+      CASE("NB_SINGULAR_VALUES")
+        write(OUT) id%NB_SINGULAR_VALUES
+        CASE("pad0","pad1","pad2","pad3","pad4","pad5","pad8","pad11",
+     &          "pad111", "pad12","pad13","pad14")
+        CASE DEFAULT
+           id%INFOG(1)=-92
+           write(*,*) "IN SMUMPS_STOP UNKNOWN VARIABLE IN STRUCTURE: "
+     &          // trim(adjustl(VARIABLES(i1)))
+           error=.true.
+           goto 100
+        END SELECT
+      ENDDO
+ 100  continue
+      CLOSE(OUT)
+      if(error) goto 101
+      OUTROOT=OUT+1000
+      OUTFILEROOT=trim(adjustl(OUTFILE)) // trim(adjustl("ROOT")) 
+     &     // trim(adjustl(STRING_ID))
+      open(UNIT=OUTROOT,FILE=OUTFILEROOT,STATUS='replace',
+     &     form='unformatted',iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN SMUMPS_STOP CANNOT OPEN FILE: "
+     &        //trim(adjustl(OUTFILEROOT))
+         goto 100
+      endif
+      DO i2=1,NBVARIABLES_ROOT
+         SELECT CASE(VARIABLES_ROOT(i2))
+      CASE("MBLOCK")
+         write(OUTROOT) id%root%MBLOCK
+      CASE("NBLOCK")
+         write(OUTROOT) id%root%NBLOCK
+      CASE("NPROW")
+         write(OUTROOT) id%root%NPROW
+      CASE("NPCOL")
+         write(OUTROOT) id%root%NPCOL
+      CASE("MYROW")
+         write(OUTROOT) id%root%MYROW
+      CASE("MYCOL")
+         write(OUTROOT) id%root%MYCOL
+      CASE("SCHUR_MLOC")
+         write(OUTROOT) id%root%SCHUR_MLOC
+      CASE("SCHUR_NLOC")
+         write(OUTROOT) id%root%SCHUR_NLOC
+      CASE("SCHUR_LLD")
+         write(OUTROOT) id%root%SCHUR_LLD
+      CASE("RHS_NLOC")
+         write(OUTROOT) id%root%RHS_NLOC
+      CASE("ROOT_SIZE")
+         write(OUTROOT) id%root%ROOT_SIZE
+      CASE("TOT_ROOT_SIZE")
+         write(OUTROOT) id%root%TOT_ROOT_SIZE
+      CASE("DESCRIPTOR")
+         write(OUTROOT) id%root%DESCRIPTOR
+      CASE("CNTXT_BLACS")
+         write(OUTROOT) id%root%CNTXT_BLACS
+      CASE("LPIV")
+         write(OUTROOT) id%root%LPIV
+      CASE("RG2L_ROW")
+         IF(associated(id%root%RG2L_ROW)) THEN
+            write(OUTROOT) size(id%root%RG2L_ROW,1)
+            write(OUTROOT) id%root%RG2L_ROW
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("RG2L_COL")
+         IF(associated(id%root%RG2L_COL)) THEN
+            write(OUTROOT) size(id%root%RG2L_COL,1)
+            write(OUTROOT) id%root%RG2L_COL
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("IPIV")
+         IF(associated(id%root%IPIV)) THEN
+            write(OUTROOT) size(id%root%IPIV,1)
+            write(OUTROOT) id%root%IPIV
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("RHS_CNTR_MASTER_ROOT")
+         IF(associated(id%root%RHS_CNTR_MASTER_ROOT)) THEN
+            write(OUTROOT) size(id%root%RHS_CNTR_MASTER_ROOT,1)
+            write(OUTROOT) id%root%RHS_CNTR_MASTER_ROOT
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("SCHUR_POINTER")
+         IF(associated(id%root%SCHUR_POINTER)) THEN
+            write(OUTROOT) size(id%root%SCHUR_POINTER,1)
+            write(OUTROOT) id%root%SCHUR_POINTER
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("QR_TAU")
+         IF(associated(id%root%QR_TAU)) THEN
+            write(OUTROOT) size(id%root%QR_TAU,1)
+            write(OUTROOT) id%root%QR_TAU
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("RHS_ROOT")
+         IF(associated(id%root%RHS_ROOT)) THEN
+            write(OUTROOT) size(id%root%RHS_ROOT,1)
+     &           ,size(id%root%RHS_ROOT,2)
+            write(OUTROOT) id%root%RHS_ROOT
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF
+      CASE("QR_RCOND")
+         write(OUTROOT) id%root%QR_RCOND
+      CASE("yes")
+         write(OUTROOT) id%root%yes
+      CASE("gridinit_done")
+         write(OUTROOT) id%root%gridinit_done
+      CASE("SVD_U")
+         IF(associated(id%root%SVD_U)) THEN
+            write(OUTROOT) size(id%root%SVD_U,1)
+     &           ,size(id%root%SVD_U,2)
+            write(OUTROOT) id%root%SVD_U
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF   
+      CASE("SVD_VT")
+         IF(associated(id%root%SVD_VT)) THEN
+            write(OUTROOT) size(id%root%SVD_VT,1)
+     &           ,size(id%root%SVD_VT,2)
+            write(OUTROOT) id%root%SVD_VT
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF  
+      CASE("SINGULAR_VALUES")
+         IF(associated(id%root%SINGULAR_VALUES)) THEN
+            write(OUTROOT) size(id%root%SINGULAR_VALUES,1)
+            write(OUTROOT) id%root%SINGULAR_VALUES
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF 
+      CASE("NB_SINGULAR_VALUES")
+         write(OUTROOT) id%root%NB_SINGULAR_VALUES
+      CASE("rootpad0","rootpad1","rootpad2","rootpad",
+     &        "rootpad3")
+      CASE DEFAULT
+         id%INFOG(1)=-92
+         write(*,*) "IN SMUMPS_STOP UNKNOWN VARIABLE"
+     &        // "IN ROOT: " // trim(adjustl(VARIABLES_ROOT(i2)))
+         goto 101
+      END SELECT  
+      ENDDO
+ 101  continue
+      CLOSE(OUTROOT)
+      END SUBROUTINE SMUMPS_STOP
+      SUBROUTINE SMUMPS_RESTART(id,INFILE)
+      USE SMUMPS_STRUC_DEF
+      IMPLICIT NONE
+      INCLUDE 'mpif.h'
+      INTEGER::IN,err,NBVARIABLES,i1,NBVARIABLES_ROOT,dummy
+      INTEGER:: i2,size_array1,size_array2,INROOT
+      CHARACTER(len=100),allocatable,DIMENSION(:)::VARIABLES
+      CHARACTER(len=100),allocatable,DIMENSION(:)::VARIABLES_ROOT
+      CHARACTER(len=*), intent(in):: INFILE
+      CHARACTER(len=100):: INFILEMAIN,INFILEROOT
+      CHARACTER(len=3) :: STRING_ID
+      LOGICAL :: error
+      INTEGER MASTER
+      PARAMETER( MASTER = 0 )
+      TYPE (SMUMPS_STRUC) :: id
+      error=.false.
+      write (STRING_ID, '(i3)') id%MYID
+      NBVARIABLES=171
+      allocate(VARIABLES(NBVARIABLES))
+      VARIABLES(171)="NB_SINGULAR_VALUES"
+      VARIABLES(170)="SINGULAR_VALUES"
+      VARIABLES(169)="IF_RESTARTING"
+      VARIABLES(168)="L0_OMP_MAPPING"
+      VARIABLES(167)="PTR_LEAFS_L0_OMP"
+      VARIABLES(166)="PERM_L0_OMP"
+      VARIABLES(165)="VIRT_L0_OMP"
+      VARIABLES(164)="PHYS_L0_OMP"
+      VARIABLES(163)="IPOOL_AFTER_L0_OMP"
+      VARIABLES(162)="IPOOL_BEFORE_L0_OMP"
+      VARIABLES(161)="THREAD_LA"
+      VARIABLES(160)="LL0_OMP_MAPPING"
+      VARIABLES(159)="L_VIRT_L0_OMP"
+      VARIABLES(158)="L_PHYS_L0_OMP"
+      VARIABLES(157)="LPOOL_BEFORE_L0_OMP"
+      VARIABLES(156)="LPOOL_AFTER_L0_OMP"
+      VARIABLES(155)="NBGRP"
+      VARIABLES(154)="LRGROUPS"
+      VARIABLES(153)="root"
+      VARIABLES(152)="WORKING"
+      VARIABLES(151)="IPTR_WORKING"
+      VARIABLES(150)="pad14"
+      VARIABLES(149)="SUP_PROC"
+      VARIABLES(148)="PIVNUL_LIST"
+      VARIABLES(147)="OOC_FILE_NAME_LENGTH"
+      VARIABLES(146)="OOC_FILE_NAMES"
+      VARIABLES(145)="OOC_NB_FILE_TYPE"
+      VARIABLES(144)="OOC_NB_FILES"
+      VARIABLES(143)="OOC_TOTAL_NB_NODES"
+      VARIABLES(142)="OOC_VADDR"
+      VARIABLES(141)="OOC_SIZE_OF_BLOCK"
+      VARIABLES(140)="pad13"
+      VARIABLES(139)="OOC_INODE_SEQUENCE"
+      VARIABLES(138)="OOC_MAX_NB_NODES_FOR_ZONE"
+      VARIABLES(137)="INSTANCE_NUMBER"
+      VARIABLES(136)="pad12"
+      VARIABLES(135)="CB_SON_SIZE"
+      VARIABLES(134)="DKEEP"
+      VARIABLES(133)="LWK_USER"
+      VARIABLES(132)="NBSA_LOCAL"
+      VARIABLES(131)="WK_USER"
+      VARIABLES(130)="CROIX_MANU"
+      VARIABLES(129)="SCHED_SBTR"
+      VARIABLES(128)="SCHED_GRP"
+      VARIABLES(127)="SCHED_DEP"
+      VARIABLES(126)="SBTR_ID"
+      VARIABLES(125)="DEPTH_FIRST_SEQ"
+      VARIABLES(124)="DEPTH_FIRST"
+      VARIABLES(123)="MY_NB_LEAF"
+      VARIABLES(122)="MY_FIRST_LEAF"
+      VARIABLES(121)="MY_ROOT_SBTR"
+      VARIABLES(120)="COST_TRAV"
+      VARIABLES(119)="MEM_SUBTREE"
+      VARIABLES(118)="RHSCOMP"
+      VARIABLES(117)="POSINRHSCOMP_COL"
+      VARIABLES(116)="POSINRHSCOMP_ROW"
+      VARIABLES(115)="POSINRHSCOMP_COL_ALLOC"
+      VARIABLES(114)="MEM_DIST"
+      VARIABLES(113)="I_AM_CAND"
+      VARIABLES(112)="TAB_POS_IN_PERE"
+      VARIABLES(111)="FUTURE_NIV2"
+      VARIABLES(110)="ISTEP_TO_INIV2"
+      VARIABLES(109)="CANDIDATES"
+      VARIABLES(108)="ELTPROC"
+      VARIABLES(107)="pad11"
+      VARIABLES(106)="NA_ELT"
+      VARIABLES(105)="LELTVAR"
+      VARIABLES(104)="NELT_loc"
+      VARIABLES(103)="DBLARR"
+      VARIABLES(102)="INTARR"
+      VARIABLES(101)="PROCNODE"
+      VARIABLES(100)="S"
+      VARIABLES(99)="PTRFAC"
+      VARIABLES(98)="PTLUST_S"
+      VARIABLES(97)="PROCNODE_STEPS"
+      VARIABLES(96)="NA"
+      VARIABLES(95)="FRTELT"
+      VARIABLES(94)="FRTPTR"
+      VARIABLES(93)="PTRAR"
+      VARIABLES(92)="FILS"
+      VARIABLES(91)="DAD_STEPS"
+      VARIABLES(90)="FRERE_STEPS"
+      VARIABLES(89)="Step2node"
+      VARIABLES(88)="ND_STEPS"
+      VARIABLES(87)="NE_STEPS"
+      VARIABLES(86)="STEP"
+      VARIABLES(85)="NBSA"
+      VARIABLES(84)="LNA"
+      VARIABLES(83)="KEEP"
+      VARIABLES(82)="Deficiency"
+      VARIABLES(81)="MAXIS1"
+      VARIABLES(80)="IS1"
+      VARIABLES(79)="IS"
+      VARIABLES(78)="BUFR"
+      VARIABLES(77)="POIDS"
+      VARIABLES(76)="LBUFR_BYTES"
+      VARIABLES(75)="LBUFR"
+      VARIABLES(74)="ASS_IRECV"
+      VARIABLES(73)="NSLAVES"
+      VARIABLES(72)="NPROCS"
+      VARIABLES(71)="MYID"
+      VARIABLES(70)="COMM_LOAD"
+      VARIABLES(69)="MYID_NODES"
+      VARIABLES(68)="COMM_NODES"
+      VARIABLES(67)="INST_Number"
+      VARIABLES(66)="MAX_SURF_MASTER"
+      VARIABLES(65)="KEEP8"
+      VARIABLES(64)="pad8"
+      VARIABLES(63)="WRITE_PROBLEM"
+      VARIABLES(62)="OOC_PREFIX"
+      VARIABLES(61)="OOC_TMPDIR"
+      VARIABLES(60)="VERSION_NUMBER"
+      VARIABLES(59)="MAPPING"
+      VARIABLES(58)="LISTVAR_SCHUR"
+      VARIABLES(57)="SCHUR_CINTERFACE"
+      VARIABLES(56)="SCHUR"
+      VARIABLES(55)="SIZE_SCHUR"
+      VARIABLES(54)="SCHUR_LLD"
+      VARIABLES(53)="SCHUR_NLOC"
+      VARIABLES(52)="SCHUR_MLOC"
+      VARIABLES(51)="NBLOCK"
+      VARIABLES(50)="MBLOCK"
+      VARIABLES(49)="NPCOL"
+      VARIABLES(48)="NPROW"
+      VARIABLES(47)="UNS_PERM"
+      VARIABLES(46)="SYM_PERM"
+      VARIABLES(45)="RINFOG"
+      VARIABLES(44)="RINFO"
+      VARIABLES(43)="CNTL"
+      VARIABLES(42)="COST_SUBTREES"
+      VARIABLES(41)="INFOG"
+      VARIABLES(40)="INFO"
+      VARIABLES(39)="ICNTL"
+      VARIABLES(38)="pad5"
+      VARIABLES(37)="LREDRHS"
+      VARIABLES(36)="LSOL_loc"
+      VARIABLES(35)="NZ_RHS"
+      VARIABLES(34)="NRHS"
+      VARIABLES(33)="LRHS"
+      VARIABLES(32)="ISOL_loc"
+      VARIABLES(31)="IRHS_PTR"
+      VARIABLES(30)="IRHS_SPARSE"
+      VARIABLES(29)="SOL_loc"
+      VARIABLES(28)="RHS_SPARSE"
+      VARIABLES(27)="REDRHS"
+      VARIABLES(26)="RHS"
+      VARIABLES(25)="PERM_IN"
+      VARIABLES(24)="pad4"
+      VARIABLES(23)="A_ELT"
+      VARIABLES(22)="ELTVAR"
+      VARIABLES(21)="ELTPTR"
+      VARIABLES(20)="pad3"
+      VARIABLES(19)="NELT"
+      VARIABLES(18)="pad2"
+      VARIABLES(17)="A_loc"
+      VARIABLES(16)="JCN_loc"
+      VARIABLES(15)="IRN_loc"
+      VARIABLES(14)="pad1"
+      VARIABLES(13)="NZ_loc"
+      VARIABLES(12)="pad0"
+      VARIABLES(11)="ROWSCA"
+      VARIABLES(10)="COLSCA"
+      VARIABLES(9)="JCN"
+      VARIABLES(8)="IRN"
+      VARIABLES(7)="A"
+      VARIABLES(6)="NZ"
+      VARIABLES(5)="N"
+      VARIABLES(4)="JOB"
+      VARIABLES(3)="PAR"
+      VARIABLES(2)="SYM"
+      VARIABLES(1)="COMM"
+      NBVARIABLES_ROOT=34
+      allocate(VARIABLES_ROOT(NBVARIABLES_ROOT))
+      VARIABLES_ROOT(34)="NB_SINGULAR_VALUES"
+      VARIABLES_ROOT(33)="SINGULAR_VALUES"
+      VARIABLES_ROOT(32)="SVD_VT"
+      VARIABLES_ROOT(31)="SVD_U"
+      VARIABLES_ROOT(30)="gridinit_done"
+      VARIABLES_ROOT(29)="yes"
+      VARIABLES_ROOT(28)="rootpad3"
+      VARIABLES_ROOT(27)="QR_RCOND"
+      VARIABLES_ROOT(26)="rootpad"
+      VARIABLES_ROOT(25)="RHS_ROOT"
+      VARIABLES_ROOT(24)="rootpad2"
+      VARIABLES_ROOT(23)="QR_TAU"
+      VARIABLES_ROOT(22)="SCHUR_POINTER"
+      VARIABLES_ROOT(21)="RHS_CNTR_MASTER_ROOT"
+      VARIABLES_ROOT(20)="rootpad1"
+      VARIABLES_ROOT(19)="IPIV"
+      VARIABLES_ROOT(18)="RG2L_COL"
+      VARIABLES_ROOT(17)="RG2L_ROW"
+      VARIABLES_ROOT(16)="rootpad0"
+      VARIABLES_ROOT(15)="LPIV"
+      VARIABLES_ROOT(14)="CNTXT_BLACS"
+      VARIABLES_ROOT(13)="DESCRIPTOR"
+      VARIABLES_ROOT(12)="TOT_ROOT_SIZE"
+      VARIABLES_ROOT(11)="ROOT_SIZE"
+      VARIABLES_ROOT(10)="RHS_NLOC"
+      VARIABLES_ROOT(9)="SCHUR_LLD"
+      VARIABLES_ROOT(8)="SCHUR_NLOC"
+      VARIABLES_ROOT(7)="SCHUR_MLOC"
+      VARIABLES_ROOT(6)="MYCOL"
+      VARIABLES_ROOT(5)="MYROW"
+      VARIABLES_ROOT(4)="NPCOL"
+      VARIABLES_ROOT(3)="NPROW"
+      VARIABLES_ROOT(2)="NBLOCK"
+      VARIABLES_ROOT(1)="MBLOCK"
+      IN=52+id%MYID
+      INFILEMAIN=trim(adjustl(INFILE)) // trim(adjustl(STRING_ID))
+      open(UNIT=IN,FILE=INFILEMAIN, STATUS='old',FORM='unformatted'
+     &     ,iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN SMUMPS_RESTART CANNOT OPEN FILE: "
+     &        //trim(adjustl(INFILEMAIN))
+         error=.true.
+         goto 101
+      endif
+      DO i1=4,NBVARIABLES
+         size_array1=0
+         size_array2=0
+         SELECT CASE(VARIABLES(i1))
+         CASE("JOB")
+            read(IN) id%JOB
+         CASE("N")
+            read(IN) id%N
+         CASE("ICNTL")
+            read(IN) id%ICNTL
+         CASE("INFO")
+            read(IN) id%INFO
+         CASE("INFOG")
+            read(IN) id%INFOG
+         CASE("COST_SUBTREES")
+            read(IN) id%COST_SUBTREES
+         CASE("CNTL")
+            read(IN) id%CNTL
+         CASE("RINFO")
+            read(IN) id%RINFO
+         CASE("RINFOG")
+            read(IN) id%RINFOG
+         CASE("KEEP8")
+            read(IN) id%KEEP8
+         CASE("KEEP")
+            read(IN) id%KEEP
+         CASE("DKEEP")
+            read(IN) id%DKEEP    
+         CASE("NZ")
+            read(IN) id%NZ
+         CASE("A")
+            nullify(id%A)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%A(size_array1))
+               read(IN) id%A
+            endif
+         CASE("IRN")
+            nullify(id%IRN)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRN(size_array1))
+               read(IN) id%IRN
+            endif
+         CASE("JCN")
+            nullify(id%JCN)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%JCN(size_array1))
+               read(IN) id%JCN
+            endif
+         CASE("COLSCA")
+            nullify(id%COLSCA)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%COLSCA(size_array1))
+               read(IN) id%COLSCA
+            endif
+         CASE("ROWSCA")
+            nullify(id%ROWSCA)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ROWSCA(size_array1))
+               read(IN) id%ROWSCA
+            endif
+         CASE("NZ_loc")
+            read(IN) id%NZ_loc
+         CASE("IRN_loc")
+            nullify(id%IRN_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRN_loc(size_array1))
+               read(IN) id%IRN_loc
+            endif
+         CASE("JCN_loc")
+            nullify(id%JCN_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%JCN_loc(size_array1))
+               read(IN) id%JCN_loc
+            endif
+         CASE("A_loc")
+            nullify(id%A_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%A_loc(size_array1))
+               read(IN) id%A_loc
+            endif
+         CASE("NELT")
+            read(IN) id%NELT
+         CASE("ELTPTR")
+            nullify(id%ELTPTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ELTPTR(size_array1))
+               read(IN) id%ELTPTR
+            endif
+         CASE("ELTVAR")
+            nullify(id%ELTVAR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ELTVAR(size_array1))
+               read(IN) id%ELTVAR
+            endif
+         CASE("A_ELT")
+            nullify(id%A_ELT)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%A_ELT(size_array1))
+               read(IN) id%A_ELT
+            endif
+         CASE("PERM_IN")
+            nullify(id%PERM_IN)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PERM_IN(size_array1))
+               read(IN) id%PERM_IN
+            endif
+         CASE("RHS")
+            nullify(id%RHS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%RHS(size_array1))
+               read(IN) id%RHS
+            endif
+         CASE("REDRHS")
+            nullify(id%REDRHS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%REDRHS(size_array1))
+               read(IN) id%REDRHS
+            endif
+         CASE("RHS_SPARSE")
+            nullify(id%RHS_SPARSE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%RHS_SPARSE(size_array1))
+               read(IN) id%RHS_SPARSE
+            endif
+         CASE("SOL_loc")
+            nullify(id%SOL_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SOL_loc(size_array1))
+               read(IN) id%SOL_loc
+            endif
+         CASE("IRHS_SPARSE")
+            nullify(id%IRHS_SPARSE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRHS_SPARSE(size_array1))
+               read(IN) id%IRHS_SPARSE
+            endif
+         CASE("IRHS_PTR")
+            nullify(id%IRHS_PTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRHS_PTR(size_array1))
+               read(IN) id%IRHS_PTR
+            endif
+         CASE("ISOL_loc")
+            nullify(id%ISOL_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ISOL_loc(size_array1))
+               read(IN) id%ISOL_loc
+            endif
+         CASE("LRHS")
+            read(IN) id%LRHS
+         CASE("NRHS")
+            read(IN) id%NRHS
+         CASE("NZ_RHS")
+            read(IN) id%NZ_RHS
+         CASE("LSOL_loc")
+            read(IN) id%LSOL_loc
+         CASE("LREDRHS")
+            read(IN) id%LREDRHS
+         CASE("SYM_PERM")
+            nullify(id%SYM_PERM)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SYM_PERM(size_array1))
+               read(IN) id%SYM_PERM
+            endif
+         CASE("UNS_PERM")
+            nullify(id%UNS_PERM)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%UNS_PERM(size_array1))
+               read(IN) id%UNS_PERM
+            endif
+         CASE("NPROW")
+            read(IN) id%NPROW
+         CASE("NPCOL")
+            read(IN) id%NPCOL
+         CASE("MBLOCK")
+            read(IN) id%MBLOCK
+         CASE("NBLOCK")
+            read(IN) id%NBLOCK
+         CASE("SCHUR_MLOC")
+            read(IN) id%SCHUR_MLOC
+         CASE("SCHUR_NLOC")
+            read(IN) id%SCHUR_NLOC
+         CASE("SCHUR_LLD")
+            read(IN) id%SCHUR_LLD
+         CASE("SIZE_SCHUR")
+            read(IN) id%SIZE_SCHUR
+         CASE("SCHUR")
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHUR(size_array1))
+               read(IN) id%SCHUR
+            endif
+         CASE("SCHUR_CINTERFACE")
+            nullify(id%SCHUR_CINTERFACE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHUR_CINTERFACE(size_array1))
+               read(IN) id%SCHUR_CINTERFACE
+            endif
+         CASE("LISTVAR_SCHUR")
+            nullify(id%LISTVAR_SCHUR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%LISTVAR_SCHUR(size_array1))
+               read(IN) id%LISTVAR_SCHUR
+            endif
+         CASE("MAPPING")
+            nullify(id%MAPPING)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MAPPING(size_array1))
+               read(IN) id%MAPPING
+            endif
+         CASE("VERSION_NUMBER")
+            read(IN) id%VERSION_NUMBER
+         CASE("OOC_TMPDIR")
+            read(IN) id%OOC_TMPDIR
+         CASE("OOC_PREFIX")
+            read(IN) id%OOC_PREFIX
+         CASE("WRITE_PROBLEM")
+            read(IN) id%WRITE_PROBLEM
+         CASE("MAX_SURF_MASTER")
+            read(IN) id%MAX_SURF_MASTER
+         CASE("INST_Number")
+            read(IN) id%INST_Number
+         CASE("COMM_NODES")
+            read(IN) id%COMM_NODES
+         CASE("MYID_NODES")
+            read(IN) id%MYID_NODES
+         CASE("COMM_LOAD")
+            read(IN) id%COMM_LOAD
+         CASE("MYID")
+            read(IN) id%MYID
+         CASE("NPROCS")
+            read(IN) id%NPROCS
+         CASE("NSLAVES")
+            read(IN) id%NSLAVES
+         CASE("ASS_IRECV")
+            read(IN) id%ASS_IRECV
+         CASE("LBUFR")
+            read(IN) id%LBUFR
+         CASE("LBUFR_BYTES")
+            read(IN) id%LBUFR_BYTES
+         CASE("POIDS")
+            nullify(id%POIDS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%POIDS(size_array1))
+               read(IN) id%POIDS
+            endif
+         CASE("BUFR")
+            nullify(id%BUFR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%BUFR(size_array1))
+               read(IN) id%BUFR
+            endif
+         CASE("IS")
+            nullify(id%IS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IS(size_array1))
+               read(IN) id%IS
+            endif
+         CASE("IS1")
+            nullify(id%IS1)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IS1(size_array1))
+               read(IN) id%IS1
+            endif
+         CASE("MAXIS1")
+            read(IN) id%MAXIS1
+         CASE("Deficiency")
+            read(IN) id%Deficiency
+         CASE("LNA")
+            read(IN) id%LNA
+         CASE("NBSA")
+            read(IN) id%NBSA
+         CASE("STEP")
+            nullify(id%STEP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%STEP(size_array1))
+               read(IN) id%STEP
+            endif
+         CASE("NE_STEPS")
+            nullify(id%NE_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%NE_STEPS(size_array1))
+               read(IN) id%NE_STEPS
+            endif
+         CASE("ND_STEPS")
+            nullify(id%ND_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ND_STEPS(size_array1))
+               read(IN) id%ND_STEPS
+            endif
+         CASE("Step2node")
+            nullify(id%Step2node)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%Step2node(size_array1))
+               read(IN) id%Step2node
+            endif
+         CASE("FRERE_STEPS")
+            nullify(id%FRERE_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FRERE_STEPS(size_array1))
+               read(IN) id%FRERE_STEPS
+            endif
+         CASE("DAD_STEPS")
+            nullify(id%DAD_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DAD_STEPS(size_array1))
+               read(IN) id%DAD_STEPS
+            endif
+         CASE("FILS")
+            nullify(id%FILS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FILS(size_array1))
+               read(IN) id%FILS
+            endif
+         CASE("PTRAR")
+            nullify(id%PTRAR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PTRAR(size_array1))
+               read(IN) id%PTRAR
+            endif
+         CASE("FRTPTR")
+            nullify(id%FRTPTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FRTPTR(size_array1))
+               read(IN) id%FRTPTR
+            endif
+         CASE("FRTELT")
+            nullify(id%FRTELT)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FRTELT(size_array1))
+               read(IN) id%FRTELT
+            endif
+         CASE("NA")
+            nullify(id%NA)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%NA(size_array1))
+               read(IN) id%NA
+            endif
+         CASE("PROCNODE_STEPS")
+            nullify(id%PROCNODE_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PROCNODE_STEPS(size_array1))
+               read(IN) id%PROCNODE_STEPS
+            endif
+         CASE("PTLUST_S")
+            nullify(id%PTLUST_S)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PTLUST_S(size_array1))
+               read(IN) id%PTLUST_S
+            endif
+         CASE("PTRFAC")
+            nullify(id%PTRFAC)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PTRFAC(size_array1))
+               read(IN) id%PTRFAC
+            endif
+         CASE("S")
+            nullify(id%S)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%S(size_array1))
+               read(IN) id%S
+            endif
+         CASE("PROCNODE")
+            nullify(id%PROCNODE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PROCNODE(size_array1))
+               read(IN) id%PROCNODE
+            endif
+         CASE("INTARR")
+            nullify(id%INTARR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%INTARR(size_array1))
+               read(IN) id%INTARR
+            endif
+         CASE("DBLARR")
+            nullify(id%DBLARR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DBLARR(size_array1))
+               read(IN) id%DBLARR
+            endif
+         CASE("NELT_loc")
+            read(IN) id%NELT_loc
+         CASE("LELTVAR")
+            read(IN) id%LELTVAR
+         CASE("NA_ELT")
+            read(IN) id%NA_ELT
+         CASE("ELTPROC")
+            nullify(id%ELTPROC)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ELTPROC(size_array1))
+               read(IN) id%ELTPROC
+            endif
+         CASE("CANDIDATES")
+            nullify(id%CANDIDATES)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%CANDIDATES(size_array1,size_array2))
+               read(IN) id%CANDIDATES
+            endif
+         CASE("ISTEP_TO_INIV2")
+            nullify(id%ISTEP_TO_INIV2)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ISTEP_TO_INIV2(size_array1))
+               read(IN) id%ISTEP_TO_INIV2
+            endif
+         CASE("FUTURE_NIV2")
+            nullify(id%FUTURE_NIV2)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FUTURE_NIV2(size_array1))
+               read(IN) id%FUTURE_NIV2
+            endif
+         CASE("TAB_POS_IN_PERE")
+            nullify(id%TAB_POS_IN_PERE)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%TAB_POS_IN_PERE(size_array1,size_array2))
+               read(IN) id%TAB_POS_IN_PERE
+            endif
+         CASE("I_AM_CAND")
+            nullify(id%I_AM_CAND)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%I_AM_CAND(size_array1))
+               read(IN) id%I_AM_CAND
+            endif
+         CASE("MEM_DIST")
+            nullify(id%MEM_DIST)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MEM_DIST(0:size_array1-1))
+               read(IN) id%MEM_DIST
+            endif
+         CASE("POSINRHSCOMP_ROW")
+            nullify(id%POSINRHSCOMP_ROW)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%POSINRHSCOMP_ROW(size_array1))
+               read(IN) id%POSINRHSCOMP_ROW
+            endif
+         CASE("POSINRHSCOMP_COL_ALLOC")
+            read(IN) id%POSINRHSCOMP_COL_ALLOC
+         CASE("POSINRHSCOMP_COL")
+            nullify(id%POSINRHSCOMP_COL)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               if(id%POSINRHSCOMP_COL_ALLOC) then
+                  allocate(id%POSINRHSCOMP_COL(size_array1))
+                  read(IN) id%POSINRHSCOMP_COL
+               else
+                  read(IN) dummy
+                  id%POSINRHSCOMP_COL=>id%POSINRHSCOMP_ROW
+               endif
+            endif
+         CASE("RHSCOMP")
+            nullify(id%RHSCOMP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%RHSCOMP(size_array1))
+               read(IN) id%RHSCOMP
+            endif
+         CASE("MEM_SUBTREE")
+            nullify(id%MEM_SUBTREE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MEM_SUBTREE(size_array1))
+               read(IN) id%MEM_SUBTREE
+            endif
+         CASE("COST_TRAV")
+            nullify(id%COST_TRAV)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%COST_TRAV(size_array1))
+               read(IN) id%COST_TRAV
+            endif
+         CASE("MY_ROOT_SBTR")
+            nullify(id%MY_ROOT_SBTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MY_ROOT_SBTR(size_array1))
+               read(IN) id%MY_ROOT_SBTR
+            endif
+         CASE("MY_FIRST_LEAF")
+            nullify(id%MY_FIRST_LEAF)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MY_FIRST_LEAF(size_array1))
+               read(IN) id%MY_FIRST_LEAF
+            endif
+         CASE("MY_NB_LEAF")
+            nullify(id%MY_NB_LEAF)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MY_NB_LEAF(size_array1))
+               read(IN) id%MY_NB_LEAF
+            endif
+         CASE("DEPTH_FIRST")
+            nullify(id%DEPTH_FIRST)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DEPTH_FIRST(size_array1))
+               read(IN) id%DEPTH_FIRST
+            endif
+         CASE("DEPTH_FIRST_SEQ")
+            nullify(id%DEPTH_FIRST_SEQ)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DEPTH_FIRST_SEQ(size_array1))
+               read(IN) id%DEPTH_FIRST_SEQ
+            endif
+         CASE("SBTR_ID")
+            nullify(id%SBTR_ID)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SBTR_ID(size_array1))
+               read(IN) id%SBTR_ID
+            endif
+         CASE("SCHED_DEP")
+            nullify(id%SCHED_DEP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHED_DEP(size_array1))
+               read(IN) id%SCHED_DEP
+            endif
+         CASE("SCHED_GRP")
+            nullify(id%SCHED_GRP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHED_GRP(size_array1))
+               read(IN) id%SCHED_GRP
+            endif
+         CASE("CROIX_MANU")
+            nullify(id%CROIX_MANU)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%CROIX_MANU(size_array1))
+               read(IN) id%CROIX_MANU
+            endif
+         CASE("WK_USER")
+            nullify(id%WK_USER)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%WK_USER(size_array1))
+               read(IN) id%WK_USER
+            endif
+         CASE("NBSA_LOCAL")
+            read(IN) id%NBSA_LOCAL
+         CASE("LWK_USER")
+            read(IN) id%LWK_USER
+         CASE("CB_SON_SIZE")
+            nullify(id%CB_SON_SIZE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%CB_SON_SIZE(size_array1))
+               read(IN) id%CB_SON_SIZE
+            endif
+         CASE("INSTANCE_NUMBER")
+            read(IN) id%INSTANCE_NUMBER
+         CASE("OOC_MAX_NB_NODES_FOR_ZONE")
+            read(IN) id%OOC_MAX_NB_NODES_FOR_ZONE
+         CASE("OOC_INODE_SEQUENCE")
+            nullify(id%OOC_INODE_SEQUENCE)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_INODE_SEQUENCE(size_array1,size_array2))
+               read(IN) id%OOC_INODE_SEQUENCE
+            endif
+         CASE("OOC_SIZE_OF_BLOCK")
+            nullify(id%OOC_SIZE_OF_BLOCK)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_SIZE_OF_BLOCK(size_array1,size_array2))
+               read(IN) id%OOC_SIZE_OF_BLOCK
+            endif
+         CASE("OOC_VADDR")
+            nullify(id%OOC_VADDR)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_VADDR(size_array1,size_array2))
+               read(IN) id%OOC_VADDR
+            endif
+         CASE("OOC_TOTAL_NB_NODES")
+            nullify(id%OOC_TOTAL_NB_NODES)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_TOTAL_NB_NODES(size_array1))
+               read(IN) id%OOC_TOTAL_NB_NODES
+            endif
+         CASE("OOC_NB_FILES")
+            nullify(id%OOC_NB_FILES)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_NB_FILES(size_array1))
+               read(IN) id%OOC_NB_FILES
+            endif
+         CASE("OOC_NB_FILE_TYPE")
+            read(IN) id%OOC_NB_FILE_TYPE
+         CASE("OOC_FILE_NAMES")
+            nullify(id%OOC_FILE_NAMES)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_FILE_NAMES(size_array1,size_array2))
+               read(IN) id%OOC_FILE_NAMES
+            endif
+         CASE("OOC_FILE_NAME_LENGTH")
+            nullify(id%OOC_FILE_NAME_LENGTH)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_FILE_NAME_LENGTH(size_array1))
+               read(IN) id%OOC_FILE_NAME_LENGTH
+            endif
+         CASE("PIVNUL_LIST")
+            nullify(id%PIVNUL_LIST)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PIVNUL_LIST(size_array1))
+               read(IN) id%PIVNUL_LIST
+            endif
+         CASE("SUP_PROC")
+            nullify(id%SUP_PROC)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SUP_PROC(size_array1,size_array2))
+               read(IN) id%SUP_PROC
+            endif
+         CASE("IPTR_WORKING")
+            nullify(id%IPTR_WORKING)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IPTR_WORKING(size_array1))
+               read(IN) id%IPTR_WORKING
+            endif
+         CASE("WORKING")
+            nullify(id%WORKING)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%WORKING(size_array1))
+               read(IN) id%WORKING
+            endif
+         CASE("root")
+        CASE("NBGRP")
+           read(IN) id%NBGRP
+        CASE("LRGROUPS")
+           nullify(id%LRGROUPS)
+           read(IN) size_array1
+           if(size_array1.EQ.-999) then
+              read(IN) dummy
+           else
+              allocate(id%LRGROUPS(size_array1))
+              read(IN) id%LRGROUPS
+           endif
+         CASE("SCHED_SBTR")
+            nullify(id%SCHED_SBTR)
+            read(IN) size_array1
+            IF(size_array1.EQ.-999) THEN
+               read(IN) dummy
+            ELSE
+               allocate(id%SCHED_SBTR(size_array1))
+               read(IN) id%SCHED_SBTR
+            ENDIF 
+        CASE("LPOOL_AFTER_L0_OMP")
+           read(IN) id%LPOOL_AFTER_L0_OMP
+        CASE("LPOOL_BEFORE_L0_OMP")
+           read(IN) id%LPOOL_BEFORE_L0_OMP
+        CASE("L_PHYS_L0_OMP")
+           read(IN) id%L_PHYS_L0_OMP
+        CASE("L_VIRT_L0_OMP")  
+           read(IN) id%L_VIRT_L0_OMP
+        CASE("LL0_OMP_MAPPING")
+           read(IN) id%LL0_OMP_MAPPING
+        CASE("THREAD_LA")
+           read(IN) id%THREAD_LA
+        CASE("IPOOL_AFTER_L0_OMP")
+           nullify(id%IPOOL_AFTER_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%IPOOL_AFTER_L0_OMP(size_array1))
+              read(IN) id%IPOOL_AFTER_L0_OMP
+           ENDIF 
+        CASE("IPOOL_BEFORE_L0_OMP")
+           nullify(id%IPOOL_BEFORE_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%IPOOL_BEFORE_L0_OMP(size_array1))
+              read(IN) id%IPOOL_BEFORE_L0_OMP
+           ENDIF 
+        CASE("PHYS_L0_OMP")
+           nullify(id%PHYS_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%PHYS_L0_OMP(size_array1))
+              read(IN) id%PHYS_L0_OMP
+           ENDIF 
+        CASE("VIRT_L0_OMP")
+           nullify(id%VIRT_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%VIRT_L0_OMP(size_array1))
+              read(IN) id%VIRT_L0_OMP
+           ENDIF
+        CASE("PERM_L0_OMP")
+           nullify(id%PERM_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%PERM_L0_OMP(size_array1))
+              read(IN) id%PERM_L0_OMP
+           ENDIF
+        CASE("PTR_LEAFS_L0_OMP")
+           nullify(id%PTR_LEAFS_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%PTR_LEAFS_L0_OMP(size_array1))
+              read(IN) id%PTR_LEAFS_L0_OMP
+           ENDIF
+        CASE("L0_OMP_MAPPING")
+           nullify(id%L0_OMP_MAPPING)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%L0_OMP_MAPPING(size_array1))
+              read(IN) id%L0_OMP_MAPPING
+           ENDIF 
+        CASE("IF_RESTARTING")
+           read(IN) id%IF_RESTARTING 
+        CASE("SINGULAR_VALUES")
+         read(IN) size_array1
+         if(size_array1.EQ.-999) then
+            read(IN) dummy
+         else
+            allocate(id%SINGULAR_VALUES(size_array1))
+            read(IN) id%SINGULAR_VALUES
+         endif  
+      CASE("NB_SINGULAR_VALUES")
+        write(IN) id%NB_SINGULAR_VALUES
+        CASE("pad0","pad1","pad2","pad3","pad4","pad5","pad8","pad11",
+     &          "pad111", "pad12","pad13","pad14")
+        CASE DEFAULT
+           id%INFOG(1)=-92
+           write(*,*) "IN SMUMPS_RESTART UNKNOWN VARIABLE IN "
+     &       // "STRUCTURE: "//  trim(adjustl(VARIABLES(i1)))
+           goto 101
+        END SELECT
+      ENDDO
+ 101  continue
+      close(IN)
+      if(error) goto 102
+      INROOT=1000+IN
+      INFILEROOT=trim(adjustl(INFILE)) // trim(adjustl("ROOT")) 
+     &     // trim(adjustl(STRING_ID)) 
+      open(UNIT=INROOT,FILE=INFILEROOT, STATUS='old',FORM='unformatted'
+     &     ,iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN SMUMPS_RESTART CANNOT OPEN FILE: "
+     &        //trim(adjustl(INFILEROOT))
+         goto 102
+      endif
+      DO i2=1,NBVARIABLES_ROOT
+         SELECT CASE(VARIABLES_ROOT(i2))
+      CASE("MBLOCK")
+         read(INROOT) id%root%MBLOCK
+      CASE("NBLOCK")
+         read(INROOT) id%root%NBLOCK
+      CASE("NPROW")
+         read(INROOT) id%root%NPROW
+      CASE("NPCOL")
+         read(INROOT) id%root%NPCOL
+      CASE("MYROW")
+         read(INROOT) id%root%MYROW
+      CASE("MYCOL")
+         read(INROOT) id%root%MYCOL
+      CASE("SCHUR_MLOC")
+         read(INROOT) id%root%SCHUR_MLOC
+      CASE("SCHUR_NLOC")
+         read(INROOT) id%root%SCHUR_NLOC
+      CASE("SCHUR_LLD")
+         read(INROOT) id%root%SCHUR_LLD
+      CASE("RHS_NLOC")
+         read(INROOT) id%root%RHS_NLOC
+      CASE("ROOT_SIZE")
+         read(INROOT) id%root%ROOT_SIZE
+      CASE("TOT_ROOT_SIZE")
+         read(INROOT) id%root%TOT_ROOT_SIZE
+      CASE("DESCRIPTOR")
+         read(INROOT) id%root%DESCRIPTOR
+      CASE("CNTXT_BLACS")
+         read(INROOT) id%root%CNTXT_BLACS
+      CASE("LPIV")
+         read(INROOT) id%root%LPIV
+      CASE("RG2L_ROW")
+         nullify(id%root%RG2L_ROW)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RG2L_ROW(size_array1))
+            read(INROOT) id%root%RG2L_ROW
+         endif
+      CASE("RG2L_COL")
+         nullify(id%root%RG2L_COL)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RG2L_COL(size_array1))
+            read(INROOT) id%root%RG2L_COL
+         endif
+      CASE("IPIV")
+         nullify(id%root%IPIV)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%IPIV(size_array1))
+            read(INROOT) id%root%IPIV
+         endif
+      CASE("RHS_CNTR_MASTER_ROOT")
+         nullify(id%root%RHS_CNTR_MASTER_ROOT)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RHS_CNTR_MASTER_ROOT(size_array1))
+            read(INROOT) id%root%RHS_CNTR_MASTER_ROOT
+         endif
+      CASE("SCHUR_POINTER")
+         nullify(id%root%SCHUR_POINTER)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SCHUR_POINTER(size_array1))
+            read(INROOT) id%root%SCHUR_POINTER
+         endif
+      CASE("QR_TAU")
+         nullify(id%root%QR_TAU)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%QR_TAU(size_array1))
+            read(INROOT) id%root%QR_TAU
+         endif
+      CASE("RHS_ROOT")
+         nullify(id%root%RHS_ROOT)
+         read(INROOT) size_array1,size_array2
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RHS_ROOT(size_array1,size_array2))
+            read(INROOT) id%root%RHS_ROOT
+         endif
+      CASE("QR_RCOND")
+         read(INROOT) id%root%QR_RCOND
+      CASE("yes")
+         read(INROOT) id%root%yes
+      CASE("gridinit_done")
+         read(INROOT) id%root%gridinit_done
+      CASE("SVD_U")
+         read(INROOT) size_array1,size_array2
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SVD_U(size_array1,size_array2))
+            read(INROOT) id%root%SVD_U
+         endif
+      CASE("SVD_VT")
+         read(INROOT) size_array1,size_array2
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SVD_VT(size_array1,size_array2))
+            read(INROOT) id%root%SVD_VT
+         endif
+      CASE("SINGULAR_VALUES")
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SINGULAR_VALUES(size_array1))
+            read(INROOT) id%root%SINGULAR_VALUES
+         endif  
+      CASE("NB_SINGULAR_VALUES")
+        write(INROOT) id%root%NB_SINGULAR_VALUES
+         CASE("rootpad0","rootpad1","rootpad2","rootpad",
+     &        "rootpad3")
+      CASE DEFAULT
+         id%INFOG(1)=-92
+         write(*,*) "IN SMUMPS_RESTART UNKNOWN VARIABLE "
+     &        // "IN ROOT: "// trim(adjustl(VARIABLES_ROOT(i2)))
+         goto 102
+      END SELECT  
+      ENDDO
+      if(id%root%gridinit_done) then
+         id%root%CNTXT_BLACS = id%COMM_NODES
+         CALL blacs_gridinit( id%root%CNTXT_BLACS, 'R',
+     &        id%root%NPROW, id%root%NPCOL )
+         id%root%gridinit_done = .TRUE.
+      endif
+ 102  continue
+      close(INROOT)
+      END SUBROUTINE SMUMPS_RESTART
diff -ruN MUMPS_5.1.2/src/tools_common_mod.F mumps-5.1.2-aster7/src/tools_common_mod.F
--- MUMPS_5.1.2/src/tools_common_mod.F	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/src/tools_common_mod.F	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,66 @@
+C
+C  This file is part of MUMPS 5.0.2, released
+C  on Fri Jul 15 09:12:54 UTC 2016
+C
+C
+C  Copyright 1991-2016 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria,
+C  University of Bordeaux.
+C
+C  This version of MUMPS is provided to you free of charge. It is
+C  released under the CeCILL-C license:
+C  http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
+C
+      MODULE TOOLS_COMMON
+      INTERFACE MUMPS_REALLOC
+      SUBROUTINE MUMPS_IREALLOC(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,
+     &     STRING, MEMCNT, ERRCODE)
+      INTEGER, POINTER    :: ARRAY(:)
+      INTEGER             :: MINSIZE, LP
+      INTEGER             :: INFO(:)
+      LOGICAL, OPTIONAL   :: FORCE
+      LOGICAL, OPTIONAL   :: COPY
+      CHARACTER, OPTIONAL :: STRING*(*)
+      INTEGER, OPTIONAL   :: ERRCODE, MEMCNT
+      END SUBROUTINE MUMPS_IREALLOC
+      SUBROUTINE MUMPS_DREALLOC(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,
+     &     STRING, MEMCNT, ERRCODE)
+      REAL(kind(1.D0)), POINTER    :: ARRAY(:)
+      INTEGER             :: MINSIZE, LP
+      INTEGER             :: INFO(:)
+      LOGICAL, OPTIONAL   :: FORCE
+      LOGICAL, OPTIONAL   :: COPY
+      CHARACTER, OPTIONAL :: STRING*(*)
+      INTEGER, OPTIONAL   :: ERRCODE, MEMCNT
+      END SUBROUTINE MUMPS_DREALLOC
+      SUBROUTINE MUMPS_SREALLOC(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,
+     &     STRING, MEMCNT, ERRCODE)
+      REAL(kind(1.E0)), POINTER    :: ARRAY(:)
+      INTEGER             :: MINSIZE, LP
+      INTEGER             :: INFO(:)
+      LOGICAL, OPTIONAL   :: FORCE
+      LOGICAL, OPTIONAL   :: COPY
+      CHARACTER, OPTIONAL :: STRING*(*)
+      INTEGER, OPTIONAL   :: ERRCODE, MEMCNT
+      END SUBROUTINE MUMPS_SREALLOC
+      SUBROUTINE MUMPS_ZREALLOC(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,
+     &     STRING, MEMCNT, ERRCODE)
+      COMPLEX(kind((1.D0,1.D0))), POINTER    :: ARRAY(:)
+      INTEGER             :: MINSIZE, LP
+      INTEGER             :: INFO(:)
+      LOGICAL, OPTIONAL   :: FORCE
+      LOGICAL, OPTIONAL   :: COPY
+      CHARACTER, OPTIONAL :: STRING*(*)
+      INTEGER, OPTIONAL   :: ERRCODE, MEMCNT
+      END SUBROUTINE MUMPS_ZREALLOC
+      SUBROUTINE MUMPS_CREALLOC(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,
+     &     STRING, MEMCNT, ERRCODE)
+      COMPLEX(kind((1.E0,1.E0))), POINTER    :: ARRAY(:)
+      INTEGER             :: MINSIZE, LP
+      INTEGER             :: INFO(:)
+      LOGICAL, OPTIONAL   :: FORCE
+      LOGICAL, OPTIONAL   :: COPY
+      CHARACTER, OPTIONAL :: STRING*(*)
+      INTEGER, OPTIONAL   :: ERRCODE, MEMCNT
+      END SUBROUTINE MUMPS_CREALLOC
+      END INTERFACE
+      END MODULE
diff -ruN MUMPS_5.1.2/src/zmumps_restart.F mumps-5.1.2-aster7/src/zmumps_restart.F
--- MUMPS_5.1.2/src/zmumps_restart.F	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/src/zmumps_restart.F	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,2648 @@
+C
+C  This file is part of MUMPS 5.0.2, released
+C  on Fri Jul 15 09:12:54 UTC 2016
+C
+C
+C  Copyright 1991-2016 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria,
+C  University of Bordeaux.
+C
+C  This version of MUMPS is provided to you free of charge. It is
+C  released under the CeCILL-C license:
+C  http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
+C
+      SUBROUTINE ZMUMPS_STOP(id,OUTFILE)
+      USE ZMUMPS_STRUC_DEF
+      IMPLICIT NONE
+      INCLUDE 'mpif.h'
+      CHARACTER(len=*), intent(in) :: OUTFILE
+      INTEGER::i1,i2,NBVARIABLES,NBVARIABLES_ROOT
+      INTEGER::OUT,err,OUTROOT
+      CHARACTER(len=100), allocatable, dimension(:)::VARIABLES
+      CHARACTER(len=100), allocatable, dimension(:)::VARIABLES_ROOT
+      CHARACTER(len=100):: OUTFILEMAIN,OUTFILEROOT
+      CHARACTER(len=3) :: STRING_ID
+      LOGICAL :: error
+      INTEGER MASTER
+      PARAMETER( MASTER = 0 )
+      TYPE (ZMUMPS_STRUC) :: id
+      id%IF_RESTARTING=.TRUE.
+      NBVARIABLES=171
+      allocate(VARIABLES(NBVARIABLES))
+      VARIABLES(171)="NB_SINGULAR_VALUES"
+      VARIABLES(170)="SINGULAR_VALUES"
+      VARIABLES(169)="IF_RESTARTING"
+      VARIABLES(168)="L0_OMP_MAPPING"
+      VARIABLES(167)="PTR_LEAFS_L0_OMP"
+      VARIABLES(166)="PERM_L0_OMP"
+      VARIABLES(165)="VIRT_L0_OMP"
+      VARIABLES(164)="PHYS_L0_OMP"
+      VARIABLES(163)="IPOOL_AFTER_L0_OMP"
+      VARIABLES(162)="IPOOL_BEFORE_L0_OMP"
+      VARIABLES(161)="THREAD_LA"
+      VARIABLES(160)="LL0_OMP_MAPPING"
+      VARIABLES(159)="L_VIRT_L0_OMP"
+      VARIABLES(158)="L_PHYS_L0_OMP"
+      VARIABLES(157)="LPOOL_BEFORE_L0_OMP"
+      VARIABLES(156)="LPOOL_AFTER_L0_OMP"
+      VARIABLES(155)="NBGRP"
+      VARIABLES(154)="LRGROUPS"
+      VARIABLES(153)="root"
+      VARIABLES(152)="WORKING"
+      VARIABLES(151)="IPTR_WORKING"
+      VARIABLES(150)="pad14"
+      VARIABLES(149)="SUP_PROC"
+      VARIABLES(148)="PIVNUL_LIST"
+      VARIABLES(147)="OOC_FILE_NAME_LENGTH"
+      VARIABLES(146)="OOC_FILE_NAMES"
+      VARIABLES(145)="OOC_NB_FILE_TYPE"
+      VARIABLES(144)="OOC_NB_FILES"
+      VARIABLES(143)="OOC_TOTAL_NB_NODES"
+      VARIABLES(142)="OOC_VADDR"
+      VARIABLES(141)="OOC_SIZE_OF_BLOCK"
+      VARIABLES(140)="pad13"
+      VARIABLES(139)="OOC_INODE_SEQUENCE"
+      VARIABLES(138)="OOC_MAX_NB_NODES_FOR_ZONE"
+      VARIABLES(137)="INSTANCE_NUMBER"
+      VARIABLES(136)="pad12"
+      VARIABLES(135)="CB_SON_SIZE"
+      VARIABLES(134)="DKEEP"
+      VARIABLES(133)="LWK_USER"
+      VARIABLES(132)="NBSA_LOCAL"
+      VARIABLES(131)="WK_USER"
+      VARIABLES(130)="CROIX_MANU"
+      VARIABLES(129)="SCHED_SBTR"
+      VARIABLES(128)="SCHED_GRP"
+      VARIABLES(127)="SCHED_DEP"
+      VARIABLES(126)="SBTR_ID"
+      VARIABLES(125)="DEPTH_FIRST_SEQ"
+      VARIABLES(124)="DEPTH_FIRST"
+      VARIABLES(123)="MY_NB_LEAF"
+      VARIABLES(122)="MY_FIRST_LEAF"
+      VARIABLES(121)="MY_ROOT_SBTR"
+      VARIABLES(120)="COST_TRAV"
+      VARIABLES(119)="MEM_SUBTREE"
+      VARIABLES(118)="RHSCOMP"
+      VARIABLES(117)="POSINRHSCOMP_COL"
+      VARIABLES(116)="POSINRHSCOMP_ROW"
+      VARIABLES(115)="POSINRHSCOMP_COL_ALLOC"
+      VARIABLES(114)="MEM_DIST"
+      VARIABLES(113)="I_AM_CAND"
+      VARIABLES(112)="TAB_POS_IN_PERE"
+      VARIABLES(111)="FUTURE_NIV2"
+      VARIABLES(110)="ISTEP_TO_INIV2"
+      VARIABLES(109)="CANDIDATES"
+      VARIABLES(108)="ELTPROC"
+      VARIABLES(107)="pad11"
+      VARIABLES(106)="NA_ELT"
+      VARIABLES(105)="LELTVAR"
+      VARIABLES(104)="NELT_loc"
+      VARIABLES(103)="DBLARR"
+      VARIABLES(102)="INTARR"
+      VARIABLES(101)="PROCNODE"
+      VARIABLES(100)="S"
+      VARIABLES(99)="PTRFAC"
+      VARIABLES(98)="PTLUST_S"
+      VARIABLES(97)="PROCNODE_STEPS"
+      VARIABLES(96)="NA"
+      VARIABLES(95)="FRTELT"
+      VARIABLES(94)="FRTPTR"
+      VARIABLES(93)="PTRAR"
+      VARIABLES(92)="FILS"
+      VARIABLES(91)="DAD_STEPS"
+      VARIABLES(90)="FRERE_STEPS"
+      VARIABLES(89)="Step2node"
+      VARIABLES(88)="ND_STEPS"
+      VARIABLES(87)="NE_STEPS"
+      VARIABLES(86)="STEP"
+      VARIABLES(85)="NBSA"
+      VARIABLES(84)="LNA"
+      VARIABLES(83)="KEEP"
+      VARIABLES(82)="Deficiency"
+      VARIABLES(81)="MAXIS1"
+      VARIABLES(80)="IS1"
+      VARIABLES(79)="IS"
+      VARIABLES(78)="BUFR"
+      VARIABLES(77)="POIDS"
+      VARIABLES(76)="LBUFR_BYTES"
+      VARIABLES(75)="LBUFR"
+      VARIABLES(74)="ASS_IRECV"
+      VARIABLES(73)="NSLAVES"
+      VARIABLES(72)="NPROCS"
+      VARIABLES(71)="MYID"
+      VARIABLES(70)="COMM_LOAD"
+      VARIABLES(69)="MYID_NODES"
+      VARIABLES(68)="COMM_NODES"
+      VARIABLES(67)="INST_Number"
+      VARIABLES(66)="MAX_SURF_MASTER"
+      VARIABLES(65)="KEEP8"
+      VARIABLES(64)="pad8"
+      VARIABLES(63)="WRITE_PROBLEM"
+      VARIABLES(62)="OOC_PREFIX"
+      VARIABLES(61)="OOC_TMPDIR"
+      VARIABLES(60)="VERSION_NUMBER"
+      VARIABLES(59)="MAPPING"
+      VARIABLES(58)="LISTVAR_SCHUR"
+      VARIABLES(57)="SCHUR_CINTERFACE"
+      VARIABLES(56)="SCHUR"
+      VARIABLES(55)="SIZE_SCHUR"
+      VARIABLES(54)="SCHUR_LLD"
+      VARIABLES(53)="SCHUR_NLOC"
+      VARIABLES(52)="SCHUR_MLOC"
+      VARIABLES(51)="NBLOCK"
+      VARIABLES(50)="MBLOCK"
+      VARIABLES(49)="NPCOL"
+      VARIABLES(48)="NPROW"
+      VARIABLES(47)="UNS_PERM"
+      VARIABLES(46)="SYM_PERM"
+      VARIABLES(45)="RINFOG"
+      VARIABLES(44)="RINFO"
+      VARIABLES(43)="CNTL"
+      VARIABLES(42)="COST_SUBTREES"
+      VARIABLES(41)="INFOG"
+      VARIABLES(40)="INFO"
+      VARIABLES(39)="ICNTL"
+      VARIABLES(38)="pad5"
+      VARIABLES(37)="LREDRHS"
+      VARIABLES(36)="LSOL_loc"
+      VARIABLES(35)="NZ_RHS"
+      VARIABLES(34)="NRHS"
+      VARIABLES(33)="LRHS"
+      VARIABLES(32)="ISOL_loc"
+      VARIABLES(31)="IRHS_PTR"
+      VARIABLES(30)="IRHS_SPARSE"
+      VARIABLES(29)="SOL_loc"
+      VARIABLES(28)="RHS_SPARSE"
+      VARIABLES(27)="REDRHS"
+      VARIABLES(26)="RHS"
+      VARIABLES(25)="PERM_IN"
+      VARIABLES(24)="pad4"
+      VARIABLES(23)="A_ELT"
+      VARIABLES(22)="ELTVAR"
+      VARIABLES(21)="ELTPTR"
+      VARIABLES(20)="pad3"
+      VARIABLES(19)="NELT"
+      VARIABLES(18)="pad2"
+      VARIABLES(17)="A_loc"
+      VARIABLES(16)="JCN_loc"
+      VARIABLES(15)="IRN_loc"
+      VARIABLES(14)="pad1"
+      VARIABLES(13)="NZ_loc"
+      VARIABLES(12)="pad0"
+      VARIABLES(11)="ROWSCA"
+      VARIABLES(10)="COLSCA"
+      VARIABLES(9)="JCN"
+      VARIABLES(8)="IRN"
+      VARIABLES(7)="A"
+      VARIABLES(6)="NZ"
+      VARIABLES(5)="N"
+      VARIABLES(4)="JOB"
+      VARIABLES(3)="PAR"
+      VARIABLES(2)="SYM"
+      VARIABLES(1)="COMM"
+      NBVARIABLES_ROOT=34
+      allocate(VARIABLES_ROOT(NBVARIABLES_ROOT))
+      VARIABLES_ROOT(34)="NB_SINGULAR_VALUES"
+      VARIABLES_ROOT(33)="SINGULAR_VALUES"
+      VARIABLES_ROOT(32)="SVD_VT"
+      VARIABLES_ROOT(31)="SVD_U"
+      VARIABLES_ROOT(30)="gridinit_done"
+      VARIABLES_ROOT(29)="yes"
+      VARIABLES_ROOT(28)="rootpad3"
+      VARIABLES_ROOT(27)="QR_RCOND"
+      VARIABLES_ROOT(26)="rootpad"
+      VARIABLES_ROOT(25)="RHS_ROOT"
+      VARIABLES_ROOT(24)="rootpad2"
+      VARIABLES_ROOT(23)="QR_TAU"
+      VARIABLES_ROOT(22)="SCHUR_POINTER"
+      VARIABLES_ROOT(21)="RHS_CNTR_MASTER_ROOT"
+      VARIABLES_ROOT(20)="rootpad1"
+      VARIABLES_ROOT(19)="IPIV"
+      VARIABLES_ROOT(18)="RG2L_COL"
+      VARIABLES_ROOT(17)="RG2L_ROW"
+      VARIABLES_ROOT(16)="rootpad0"
+      VARIABLES_ROOT(15)="LPIV"
+      VARIABLES_ROOT(14)="CNTXT_BLACS"
+      VARIABLES_ROOT(13)="DESCRIPTOR"
+      VARIABLES_ROOT(12)="TOT_ROOT_SIZE"
+      VARIABLES_ROOT(11)="ROOT_SIZE"
+      VARIABLES_ROOT(10)="RHS_NLOC"
+      VARIABLES_ROOT(9)="SCHUR_LLD"
+      VARIABLES_ROOT(8)="SCHUR_NLOC"
+      VARIABLES_ROOT(7)="SCHUR_MLOC"
+      VARIABLES_ROOT(6)="MYCOL"
+      VARIABLES_ROOT(5)="MYROW"
+      VARIABLES_ROOT(4)="NPCOL"
+      VARIABLES_ROOT(3)="NPROW"
+      VARIABLES_ROOT(2)="NBLOCK"
+      VARIABLES_ROOT(1)="MBLOCK"
+      if(((id%ICNTL(3).GT.0).AND.(id%MYID .EQ. MASTER))) then
+         write(*,*) "DUMPING MUMPS STRUCTURE IN FILE:",OUTFILE
+      endif
+      error=.false.
+      write (STRING_ID, '(i3)') id%MYID
+      OUT=42+id%MYID
+      OUTFILEMAIN=trim(adjustl(OUTFILE)) // trim(adjustl(STRING_ID))
+      open(UNIT=OUT,FILE=OUTFILEMAIN,STATUS='replace',
+     &     form='unformatted',iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN ZMUMPS_STOP CANNOT OPEN FILE: "
+     &        //trim(adjustl(OUTFILEMAIN))
+         error=.true.
+         goto 100
+      endif      
+      DO i1=1,NBVARIABLES 
+         SELECT CASE(trim(adjustl(VARIABLES(i1))))
+         CASE("COMM") 
+         CASE("SYM")
+         CASE("PAR")
+         CASE("JOB")
+            write(OUT) id%JOB
+         CASE("N")
+            write(OUT) id%N
+         CASE("ICNTL")
+            write(OUT) id%ICNTL
+         CASE("INFO")
+            write(OUT) id%INFO
+         CASE("INFOG")
+            write(OUT) id%INFOG
+         CASE("COST_SUBTREES")
+            write(OUT) id%COST_SUBTREES
+         CASE("CNTL")
+            write(OUT) id%CNTL
+         CASE("RINFO")
+            write(OUT) id%RINFO
+         CASE("RINFOG")
+            write(OUT) id%RINFOG
+         CASE("KEEP8")
+            write(OUT) id%KEEP8
+         CASE("KEEP")
+            write(OUT) id%KEEP
+         CASE("DKEEP")
+            write(OUT) id%DKEEP    
+         CASE("NZ")
+            write(OUT) id%NZ
+         CASE("A")
+            IF(associated(id%A)) THEN
+               write(OUT) size(id%A,1)
+               write(OUT) id%A
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IRN")
+            IF(associated(id%IRN)) THEN
+               write(OUT) size(id%IRN,1)
+               write(OUT) id%IRN
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("JCN")
+            IF(associated(id%JCN)) THEN
+               write(OUT) size(id%JCN,1)
+               write(OUT) id%JCN
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("COLSCA")
+            IF(associated(id%COLSCA)) THEN
+               write(OUT) size(id%COLSCA,1)
+               write(OUT) id%COLSCA
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF 
+         CASE("ROWSCA")
+            IF(associated(id%ROWSCA)) THEN
+               write(OUT) size(id%ROWSCA,1)
+               write(OUT) id%ROWSCA
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NZ_loc")
+            write(OUT) id%NZ_loc
+         CASE("IRN_loc")
+            IF(associated(id%IRN_loc)) THEN
+               write(OUT) size(id%IRN_loc,1)
+               write(OUT) id%IRN_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("JCN_loc")
+            IF(associated(id%JCN_loc)) THEN
+               write(OUT) size(id%JCN_loc,1)
+               write(OUT) id%JCN_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("A_loc")
+            IF(associated(id%A_loc)) THEN
+               write(OUT) size(id%A_loc,1)
+               write(OUT) id%A_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NELT")
+            write(OUT) id%NELT
+         CASE("ELTPTR")
+            IF(associated(id%ELTPTR)) THEN
+               write(OUT) size(id%ELTPTR,1)
+               write(OUT) id%ELTPTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("ELTVAR")
+            IF(associated(id%ELTVAR)) THEN
+               write(OUT) size(id%ELTVAR,1)
+               write(OUT) id%ELTVAR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("A_ELT")
+            IF(associated(id%A_ELT)) THEN
+               write(OUT) size(id%A_ELT,1)
+               write(OUT) id%A_ELT
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PERM_IN")
+            IF(associated(id%PERM_IN)) THEN
+               write(OUT) size(id%PERM_IN,1)
+               write(OUT) id%PERM_IN
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("RHS")
+            IF(associated(id%RHS)) THEN
+               write(OUT) size(id%RHS,1)
+               write(OUT) id%RHS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("REDRHS")
+            IF(associated(id%REDRHS)) THEN
+               write(OUT) size(id%REDRHS,1)
+               write(OUT) id%REDRHS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("RHS_SPARSE")
+            IF(associated(id%RHS_SPARSE)) THEN
+               write(OUT) size(id%RHS_SPARSE,1)
+               write(OUT) id%RHS_SPARSE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SOL_loc")
+            IF(associated(id%SOL_loc)) THEN
+               write(OUT) size(id%SOL_loc,1)
+               write(OUT) id%SOL_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IRHS_SPARSE")
+            IF(associated(id%IRHS_SPARSE)) THEN
+               write(OUT) size(id%IRHS_SPARSE,1)
+               write(OUT) id%IRHS_SPARSE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IRHS_PTR")
+            IF(associated(id%IRHS_PTR)) THEN
+               write(OUT) size(id%IRHS_PTR,1)
+               write(OUT) id%IRHS_PTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("ISOL_loc")
+            IF(associated(id%ISOL_loc)) THEN
+               write(OUT) size(id%ISOL_loc,1)
+               write(OUT) id%ISOL_loc
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("LRHS")
+            write(OUT) id%LRHS
+         CASE("NRHS")
+            write(OUT) id%NRHS
+         CASE("NZ_RHS")
+            write(OUT) id%NZ_RHS
+         CASE("LSOL_loc")
+            write(OUT) id%LSOL_loc
+         CASE("LREDRHS")
+            write(OUT) id%LREDRHS
+         CASE("SYM_PERM")
+            IF(associated(id%SYM_PERM)) THEN
+               write(OUT) size(id%SYM_PERM,1)
+               write(OUT) id%SYM_PERM
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("UNS_PERM")
+            IF(associated(id%UNS_PERM)) THEN
+               write(OUT) size(id%UNS_PERM,1)
+               write(OUT) id%UNS_PERM
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NPROW")
+            write(OUT) id%NPROW
+         CASE("NPCOL")
+            write(OUT) id%NPCOL
+         CASE("MBLOCK")
+            write(OUT) id%MBLOCK
+         CASE("NBLOCK")
+            write(OUT) id%NBLOCK
+         CASE("SCHUR_MLOC")
+            write(OUT) id%SCHUR_MLOC
+         CASE("SCHUR_NLOC")
+            write(OUT) id%SCHUR_NLOC
+         CASE("SCHUR_LLD")
+            write(OUT) id%SCHUR_LLD
+         CASE("SIZE_SCHUR")
+            write(OUT) id%SIZE_SCHUR
+         CASE("SCHUR")
+            IF(associated(id%SCHUR)) THEN
+               write(OUT) size(id%SCHUR,1)
+               write(OUT) id%SCHUR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SCHUR_CINTERFACE")
+            IF(associated(id%SCHUR_CINTERFACE)) THEN
+               write(OUT) size(id%SCHUR_CINTERFACE,1)
+               write(OUT) id%SCHUR_CINTERFACE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("LISTVAR_SCHUR")
+            IF(associated(id%LISTVAR_SCHUR)) THEN
+               write(OUT) size(id%LISTVAR_SCHUR,1)
+               write(OUT) id%LISTVAR_SCHUR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MAPPING")
+            IF(associated(id%MAPPING)) THEN
+               write(OUT) size(id%MAPPING,1)
+               write(OUT) id%MAPPING
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("VERSION_NUMBER")
+            write(OUT) id%VERSION_NUMBER
+         CASE("OOC_TMPDIR")
+            write(OUT) id%OOC_TMPDIR
+         CASE("OOC_PREFIX")
+            write(OUT) id%OOC_PREFIX
+         CASE("WRITE_PROBLEM")
+            write(OUT) id%WRITE_PROBLEM
+         CASE("MAX_SURF_MASTER")
+            write(OUT) id%MAX_SURF_MASTER
+         CASE("INST_Number")
+            write(OUT) id%INST_Number
+         CASE("COMM_NODES")
+            write(OUT) id%COMM_NODES
+         CASE("MYID_NODES")
+            write(OUT) id%MYID_NODES
+         CASE("COMM_LOAD")
+            write(OUT) id%COMM_LOAD
+         CASE("MYID")
+            write(OUT) id%MYID
+         CASE("NPROCS")
+            write(OUT) id%NPROCS
+         CASE("NSLAVES")
+            write(OUT) id%NSLAVES
+         CASE("ASS_IRECV")
+            write(OUT) id%ASS_IRECV
+         CASE("LBUFR")
+            write(OUT) id%LBUFR
+         CASE("LBUFR_BYTES")
+            write(OUT) id%LBUFR_BYTES
+         CASE("POIDS")
+            IF(associated(id%POIDS)) THEN 
+               write(OUT) size(id%POIDS,1)
+               write(OUT) id%POIDS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("BUFR")
+            IF(associated(id%BUFR)) THEN 
+               write(OUT) size(id%BUFR,1)
+               write(OUT) id%BUFR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IS")
+            IF(associated(id%IS)) THEN 
+               write(OUT) size(id%IS,1)
+               write(OUT) id%IS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("IS1")
+            IF(associated(id%IS1)) THEN 
+               write(OUT) size(id%IS1,1)
+               write(OUT) id%IS1
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MAXIS1")
+            write(OUT) id%MAXIS1
+         CASE("Deficiency")
+            write(OUT) id%Deficiency
+         CASE("LNA")
+            write(OUT) id%LNA
+         CASE("NBSA")
+            write(OUT) id%NBSA
+         CASE("STEP")
+            IF(associated(id%STEP)) THEN
+               write(OUT) size(id%STEP,1)
+               write(OUT) id%STEP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NE_STEPS")
+            IF(associated(id%NE_STEPS)) THEN
+               write(OUT) size(id%NE_STEPS,1)
+               write(OUT) id%NE_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("ND_STEPS")
+            IF(associated(id%ND_STEPS)) THEN
+               write(OUT) size(id%ND_STEPS,1)
+               write(OUT) id%ND_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("Step2node")
+            IF(associated(id%Step2node)) THEN
+               write(OUT) size(id%Step2node,1)
+               write(OUT) id%Step2node
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FRERE_STEPS")
+            IF(associated(id%FRERE_STEPS)) THEN
+               write(OUT) size(id%FRERE_STEPS,1)
+               write(OUT) id%FRERE_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DAD_STEPS")
+            IF(associated(id%DAD_STEPS)) THEN
+               write(OUT) size(id%DAD_STEPS,1)
+               write(OUT) id%DAD_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FILS")
+            IF(associated(id%FILS)) THEN
+               write(OUT) size(id%FILS,1)
+               write(OUT) id%FILS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PTRAR")
+            IF(associated(id%PTRAR)) THEN
+               write(OUT) size(id%PTRAR,1)
+               write(OUT) id%PTRAR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FRTPTR")
+            IF(associated(id%FRTPTR)) THEN
+               write(OUT) size(id%FRTPTR,1)
+               write(OUT) id%FRTPTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FRTELT")
+            IF(associated(id%FRTELT)) THEN
+               write(OUT) size(id%FRTELT,1)
+               write(OUT) id%FRTELT
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NA")
+            IF(associated(id%NA)) THEN
+               write(OUT) size(id%NA,1)
+               write(OUT) id%NA
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PROCNODE_STEPS")
+            IF(associated(id%PROCNODE_STEPS)) THEN
+               write(OUT) size(id%PROCNODE_STEPS,1)
+               write(OUT) id%PROCNODE_STEPS
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PTLUST_S")
+            IF(associated(id%PTLUST_S)) THEN
+               write(OUT) size(id%PTLUST_S,1)
+               write(OUT) id%PTLUST_S
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PTRFAC")
+            IF(associated(id%PTRFAC)) THEN
+               write(OUT) size(id%PTRFAC,1)
+               write(OUT) id%PTRFAC
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("S")
+            IF(associated(id%S)) THEN
+               write(OUT) id%KEEP8(23)
+               write(OUT) id%S
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PROCNODE")
+            IF(associated(id%PROCNODE)) THEN
+               write(OUT) size(id%PROCNODE,1)
+               write(OUT) id%PROCNODE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("INTARR")
+            IF(associated(id%INTARR)) THEN
+               write(OUT) size(id%INTARR,1)
+               write(OUT) id%INTARR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DBLARR")
+            IF(associated(id%DBLARR)) THEN
+               write(OUT) size(id%DBLARR,1)
+               write(OUT) id%DBLARR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NELT_loc")
+            write(OUT) id%NELT_loc
+         CASE("LELTVAR")
+            write(OUT) id%LELTVAR
+         CASE("NA_ELT")
+            write(OUT) id%NA_ELT
+         CASE("ELTPROC")
+            IF(associated(id%ELTPROC)) THEN
+               write(OUT) size(id%ELTPROC,1)
+               write(OUT) id%ELTPROC
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("CANDIDATES")
+            IF(associated(id%CANDIDATES)) THEN
+               write(OUT) size(id%CANDIDATES,1)
+     &              ,size(id%CANDIDATES,2)
+               write(OUT) id%CANDIDATES
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("ISTEP_TO_INIV2")
+            IF(associated(id%ISTEP_TO_INIV2)) THEN
+               write(OUT) size(id%ISTEP_TO_INIV2,1)
+               write(OUT) id%ISTEP_TO_INIV2
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("FUTURE_NIV2")
+            IF(associated(id%FUTURE_NIV2)) THEN
+               write(OUT) size(id%FUTURE_NIV2,1)
+               write(OUT) id%FUTURE_NIV2
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("TAB_POS_IN_PERE")
+            IF(associated(id%TAB_POS_IN_PERE)) THEN
+               write(OUT) size(id%TAB_POS_IN_PERE,1)
+     &              ,size(id%TAB_POS_IN_PERE,2)
+               write(OUT) id%TAB_POS_IN_PERE
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("I_AM_CAND")
+            IF(associated(id%I_AM_CAND)) THEN
+               write(OUT) size(id%I_AM_CAND,1)
+               write(OUT) id%I_AM_CAND
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MEM_DIST")
+            IF(associated(id%MEM_DIST)) THEN
+               write(OUT) size(id%MEM_DIST,1)
+               write(OUT) id%MEM_DIST
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("POSINRHSCOMP_ROW")
+            IF(associated(id%POSINRHSCOMP_ROW)) THEN 
+               write(OUT) size(id%POSINRHSCOMP_ROW,1)
+               write(OUT) id%POSINRHSCOMP_ROW
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("POSINRHSCOMP_COL_ALLOC")
+            write(OUT) id%POSINRHSCOMP_COL_ALLOC
+         CASE("POSINRHSCOMP_COL")
+            IF(associated(id%POSINRHSCOMP_COL)) THEN
+               IF(id%POSINRHSCOMP_COL_ALLOC) THEN
+                  write(OUT) size(id%POSINRHSCOMP_COL,1)
+                  write(OUT) id%POSINRHSCOMP_COL
+               ELSE
+                  write(OUT) size(id%POSINRHSCOMP_COL,1)
+                  write(OUT) -999
+               ENDIF
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("RHSCOMP")
+            IF(associated(id%RHSCOMP)) THEN
+               write(OUT) size(id%RHSCOMP,1)
+               write(OUT) id%RHSCOMP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MEM_SUBTREE")
+            IF(associated(id%MEM_SUBTREE)) THEN
+               write(OUT) size(id%MEM_SUBTREE,1)
+               write(OUT) id%MEM_SUBTREE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("COST_TRAV")
+            IF(associated(id%COST_TRAV)) THEN
+               write(OUT) size(id%COST_TRAV,1)
+               write(OUT) id%COST_TRAV
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MY_ROOT_SBTR")
+            IF(associated(id%MY_ROOT_SBTR)) THEN
+               write(OUT) size(id%MY_ROOT_SBTR,1)
+               write(OUT) id%MY_ROOT_SBTR
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MY_FIRST_LEAF")
+            IF(associated(id%MY_FIRST_LEAF)) THEN
+               write(OUT) size(id%MY_FIRST_LEAF,1)
+               write(OUT) id%MY_FIRST_LEAF
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("MY_NB_LEAF")
+            IF(associated(id%MY_NB_LEAF)) THEN
+               write(OUT) size(id%MY_NB_LEAF,1)
+               write(OUT) id%MY_NB_LEAF
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DEPTH_FIRST")
+            IF(associated(id%DEPTH_FIRST)) THEN
+               write(OUT) size(id%DEPTH_FIRST,1)
+               write(OUT) id%DEPTH_FIRST
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("DEPTH_FIRST_SEQ")
+            IF(associated(id%DEPTH_FIRST_SEQ)) THEN
+               write(OUT) size(id%DEPTH_FIRST_SEQ,1)
+               write(OUT) id%DEPTH_FIRST_SEQ
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SBTR_ID")
+            IF(associated(id%SBTR_ID)) THEN
+               write(OUT) size(id%SBTR_ID,1)
+               write(OUT) id%SBTR_ID
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SCHED_DEP")
+            IF(associated(id%SCHED_DEP)) THEN
+               write(OUT) size(id%SCHED_DEP,1)
+               write(OUT) id%SCHED_DEP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SCHED_GRP")
+            IF(associated(id%SCHED_GRP)) THEN
+               write(OUT) size(id%SCHED_GRP,1)
+               write(OUT) id%SCHED_GRP
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("CROIX_MANU")
+            IF(associated(id%CROIX_MANU)) THEN
+               write(OUT) size(id%CROIX_MANU,1)
+               write(OUT) id%CROIX_MANU
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("WK_USER")
+            IF(associated(id%WK_USER)) THEN
+               write(OUT) id%KEEP8(24)
+               write(OUT) id%WK_USER
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("NBSA_LOCAL")
+            write(OUT) id%NBSA_LOCAL
+         CASE("LWK_USER")
+            write(OUT) id%LWK_USER
+         CASE("CB_SON_SIZE")
+            IF(associated(id%CB_SON_SIZE)) THEN
+               write(OUT) size(id%CB_SON_SIZE,1)
+               write(OUT) id%CB_SON_SIZE
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("INSTANCE_NUMBER")
+            write(OUT) id%INSTANCE_NUMBER
+         CASE("OOC_MAX_NB_NODES_FOR_ZONE")
+            write(OUT) id%OOC_MAX_NB_NODES_FOR_ZONE
+         CASE("OOC_INODE_SEQUENCE")
+            IF(associated(id%OOC_INODE_SEQUENCE)) THEN
+               write(OUT) size(id%OOC_INODE_SEQUENCE,1)
+     &              ,size(id%OOC_INODE_SEQUENCE,2)
+               write(OUT) id%OOC_INODE_SEQUENCE
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_SIZE_OF_BLOCK")
+            IF(associated(id%OOC_SIZE_OF_BLOCK)) THEN
+               write(OUT) size(id%OOC_SIZE_OF_BLOCK,1)
+     &              ,size(id%OOC_SIZE_OF_BLOCK,2)  
+               write(OUT) id%OOC_SIZE_OF_BLOCK
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_VADDR")
+            IF(associated(id%OOC_VADDR)) THEN
+               write(OUT) size(id%OOC_VADDR,1),size(id%OOC_VADDR,2)
+               write(OUT) id%OOC_VADDR
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_TOTAL_NB_NODES")
+            IF(associated(id%OOC_TOTAL_NB_NODES)) THEN
+               write(OUT) size(id%OOC_TOTAL_NB_NODES,1)
+               write(OUT) id%OOC_TOTAL_NB_NODES
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_NB_FILES")
+            IF(associated(id%OOC_NB_FILES)) THEN
+               write(OUT) size(id%OOC_NB_FILES,1)
+               write(OUT) id%OOC_NB_FILES
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_NB_FILE_TYPE")
+            write(OUT) id%OOC_NB_FILE_TYPE
+         CASE("OOC_FILE_NAMES")
+            IF(associated(id%OOC_FILE_NAMES)) THEN
+               write(OUT) size(id%OOC_FILE_NAMES,1)
+     &              ,size(id%OOC_FILE_NAMES,2)
+               write(OUT) id%OOC_FILE_NAMES
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("OOC_FILE_NAME_LENGTH")
+            IF(associated(id%OOC_FILE_NAME_LENGTH)) THEN
+               write(OUT) size(id%OOC_FILE_NAME_LENGTH,1)
+               write(OUT) id%OOC_FILE_NAME_LENGTH
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("PIVNUL_LIST")
+            IF(associated(id%PIVNUL_LIST)) THEN
+               write(OUT) size(id%PIVNUL_LIST,1)
+               write(OUT) id%PIVNUL_LIST
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("SUP_PROC")
+            IF(associated(id%SUP_PROC)) THEN
+               write(OUT) size(id%SUP_PROC,1),size(id%SUP_PROC,2)
+               write(OUT) id%SUP_PROC
+            ELSE
+               write(OUT) -999,-998
+               write(OUT) -999
+            ENDIF
+         CASE("IPTR_WORKING")
+            IF(associated(id%IPTR_WORKING)) THEN
+               write(OUT) size(id%IPTR_WORKING,1)
+               write(OUT) id%IPTR_WORKING
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("WORKING")
+            IF(associated(id%WORKING)) THEN
+               write(OUT) size(id%WORKING,1)
+               write(OUT) id%WORKING
+            ELSE
+               write(OUT) -999
+               write(OUT) -999
+            ENDIF
+         CASE("root")
+         CASE("NBGRP")
+           write(OUT) id%NBGRP
+        CASE("LRGROUPS")
+           IF(associated(id%LRGROUPS)) THEN
+              write(OUT) size(id%LRGROUPS,1)
+              write(OUT) id%LRGROUPS
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("SCHED_SBTR")
+           IF(associated(id%SCHED_SBTR)) THEN
+              write(OUT) size(id%SCHED_SBTR,1)
+              write(OUT) id%SCHED_SBTR
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("LPOOL_AFTER_L0_OMP")
+           write(OUT) id%LPOOL_AFTER_L0_OMP
+        CASE("LPOOL_BEFORE_L0_OMP")
+           write(OUT) id%LPOOL_BEFORE_L0_OMP
+        CASE("L_PHYS_L0_OMP")
+           write(OUT) id%L_PHYS_L0_OMP
+        CASE("L_VIRT_L0_OMP")        
+           write(OUT) id%L_VIRT_L0_OMP
+        CASE("LL0_OMP_MAPPING")
+           write(OUT) id%LL0_OMP_MAPPING
+        CASE("THREAD_LA")
+           write(OUT) id%THREAD_LA
+        CASE("IPOOL_AFTER_L0_OMP")
+           IF(associated(id%IPOOL_AFTER_L0_OMP)) THEN
+              write(OUT) size(id%IPOOL_AFTER_L0_OMP,1)
+              write(OUT) id%IPOOL_AFTER_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("IPOOL_BEFORE_L0_OMP")
+           IF(associated(id%IPOOL_BEFORE_L0_OMP)) THEN
+              write(OUT) size(id%IPOOL_BEFORE_L0_OMP,1)
+              write(OUT) id%IPOOL_BEFORE_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("PHYS_L0_OMP")
+           IF(associated(id%PHYS_L0_OMP)) THEN
+              write(OUT) size(id%PHYS_L0_OMP,1)
+              write(OUT) id%PHYS_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("VIRT_L0_OMP")
+           IF(associated(id%VIRT_L0_OMP)) THEN
+              write(OUT) size(id%VIRT_L0_OMP,1)
+              write(OUT) id%VIRT_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("PERM_L0_OMP")
+           IF(associated(id%PERM_L0_OMP)) THEN
+              write(OUT) size(id%PERM_L0_OMP,1)
+              write(OUT) id%PERM_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("PTR_LEAFS_L0_OMP")
+           IF(associated(id%PTR_LEAFS_L0_OMP)) THEN
+              write(OUT) size(id%PTR_LEAFS_L0_OMP,1)
+              write(OUT) id%PTR_LEAFS_L0_OMP
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("L0_OMP_MAPPING")
+          IF(associated(id%L0_OMP_MAPPING)) THEN
+              write(OUT) size(id%L0_OMP_MAPPING,1)
+              write(OUT) id%L0_OMP_MAPPING
+           ELSE
+              write(OUT) -999
+              write(OUT) -999
+           ENDIF
+        CASE("IF_RESTARTING")
+           write(OUT) id%IF_RESTARTING
+      CASE("SINGULAR_VALUES")
+         IF(associated(id%SINGULAR_VALUES)) THEN
+            write(OUT) size(id%SINGULAR_VALUES,1)
+            write(OUT) id%SINGULAR_VALUES
+         ELSE
+            write(OUT) -999,-998
+            write(OUT) -999
+         ENDIF 
+      CASE("NB_SINGULAR_VALUES")
+        write(OUT) id%NB_SINGULAR_VALUES
+        CASE("pad0","pad1","pad2","pad3","pad4","pad5","pad8","pad11",
+     &          "pad111", "pad12","pad13","pad14")
+        CASE DEFAULT
+           id%INFOG(1)=-92
+           write(*,*) "IN ZMUMPS_STOP UNKNOWN VARIABLE IN STRUCTURE: "
+     &          // trim(adjustl(VARIABLES(i1)))
+           error=.true.
+           goto 100
+        END SELECT
+      ENDDO
+ 100  continue
+      CLOSE(OUT)
+      if(error) goto 101
+      OUTROOT=OUT+1000
+      OUTFILEROOT=trim(adjustl(OUTFILE)) // trim(adjustl("ROOT")) 
+     &     // trim(adjustl(STRING_ID))
+      open(UNIT=OUTROOT,FILE=OUTFILEROOT,STATUS='replace',
+     &     form='unformatted',iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN ZMUMPS_STOP CANNOT OPEN FILE: "
+     &        //trim(adjustl(OUTFILEROOT))
+         goto 100
+      endif
+      DO i2=1,NBVARIABLES_ROOT
+         SELECT CASE(VARIABLES_ROOT(i2))
+      CASE("MBLOCK")
+         write(OUTROOT) id%root%MBLOCK
+      CASE("NBLOCK")
+         write(OUTROOT) id%root%NBLOCK
+      CASE("NPROW")
+         write(OUTROOT) id%root%NPROW
+      CASE("NPCOL")
+         write(OUTROOT) id%root%NPCOL
+      CASE("MYROW")
+         write(OUTROOT) id%root%MYROW
+      CASE("MYCOL")
+         write(OUTROOT) id%root%MYCOL
+      CASE("SCHUR_MLOC")
+         write(OUTROOT) id%root%SCHUR_MLOC
+      CASE("SCHUR_NLOC")
+         write(OUTROOT) id%root%SCHUR_NLOC
+      CASE("SCHUR_LLD")
+         write(OUTROOT) id%root%SCHUR_LLD
+      CASE("RHS_NLOC")
+         write(OUTROOT) id%root%RHS_NLOC
+      CASE("ROOT_SIZE")
+         write(OUTROOT) id%root%ROOT_SIZE
+      CASE("TOT_ROOT_SIZE")
+         write(OUTROOT) id%root%TOT_ROOT_SIZE
+      CASE("DESCRIPTOR")
+         write(OUTROOT) id%root%DESCRIPTOR
+      CASE("CNTXT_BLACS")
+         write(OUTROOT) id%root%CNTXT_BLACS
+      CASE("LPIV")
+         write(OUTROOT) id%root%LPIV
+      CASE("RG2L_ROW")
+         IF(associated(id%root%RG2L_ROW)) THEN
+            write(OUTROOT) size(id%root%RG2L_ROW,1)
+            write(OUTROOT) id%root%RG2L_ROW
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("RG2L_COL")
+         IF(associated(id%root%RG2L_COL)) THEN
+            write(OUTROOT) size(id%root%RG2L_COL,1)
+            write(OUTROOT) id%root%RG2L_COL
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("IPIV")
+         IF(associated(id%root%IPIV)) THEN
+            write(OUTROOT) size(id%root%IPIV,1)
+            write(OUTROOT) id%root%IPIV
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("RHS_CNTR_MASTER_ROOT")
+         IF(associated(id%root%RHS_CNTR_MASTER_ROOT)) THEN
+            write(OUTROOT) size(id%root%RHS_CNTR_MASTER_ROOT,1)
+            write(OUTROOT) id%root%RHS_CNTR_MASTER_ROOT
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("SCHUR_POINTER")
+         IF(associated(id%root%SCHUR_POINTER)) THEN
+            write(OUTROOT) size(id%root%SCHUR_POINTER,1)
+            write(OUTROOT) id%root%SCHUR_POINTER
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("QR_TAU")
+         IF(associated(id%root%QR_TAU)) THEN
+            write(OUTROOT) size(id%root%QR_TAU,1)
+            write(OUTROOT) id%root%QR_TAU
+         ELSE
+            write(OUTROOT) -999
+            write(OUTROOT) -999
+         ENDIF
+      CASE("RHS_ROOT")
+         IF(associated(id%root%RHS_ROOT)) THEN
+            write(OUTROOT) size(id%root%RHS_ROOT,1)
+     &           ,size(id%root%RHS_ROOT,2)
+            write(OUTROOT) id%root%RHS_ROOT
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF
+      CASE("QR_RCOND")
+         write(OUTROOT) id%root%QR_RCOND
+      CASE("yes")
+         write(OUTROOT) id%root%yes
+      CASE("gridinit_done")
+         write(OUTROOT) id%root%gridinit_done
+      CASE("SVD_U")
+         IF(associated(id%root%SVD_U)) THEN
+            write(OUTROOT) size(id%root%SVD_U,1)
+     &           ,size(id%root%SVD_U,2)
+            write(OUTROOT) id%root%SVD_U
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF   
+      CASE("SVD_VT")
+         IF(associated(id%root%SVD_VT)) THEN
+            write(OUTROOT) size(id%root%SVD_VT,1)
+     &           ,size(id%root%SVD_VT,2)
+            write(OUTROOT) id%root%SVD_VT
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF  
+      CASE("SINGULAR_VALUES")
+         IF(associated(id%root%SINGULAR_VALUES)) THEN
+            write(OUTROOT) size(id%root%SINGULAR_VALUES,1)
+            write(OUTROOT) id%root%SINGULAR_VALUES
+         ELSE
+            write(OUTROOT) -999,-998
+            write(OUTROOT) -999
+         ENDIF 
+      CASE("NB_SINGULAR_VALUES")
+         write(OUTROOT) id%root%NB_SINGULAR_VALUES
+      CASE("rootpad0","rootpad1","rootpad2","rootpad",
+     &        "rootpad3")
+      CASE DEFAULT
+         id%INFOG(1)=-92
+         write(*,*) "IN ZMUMPS_STOP UNKNOWN VARIABLE"
+     &        // "IN ROOT: " // trim(adjustl(VARIABLES_ROOT(i2)))
+         goto 101
+      END SELECT  
+      ENDDO
+ 101  continue
+      CLOSE(OUTROOT)
+      END SUBROUTINE ZMUMPS_STOP
+      SUBROUTINE ZMUMPS_RESTART(id,INFILE)
+      USE ZMUMPS_STRUC_DEF
+      IMPLICIT NONE
+      INCLUDE 'mpif.h'
+      INTEGER::IN,err,NBVARIABLES,i1,NBVARIABLES_ROOT,dummy
+      INTEGER:: i2,size_array1,size_array2,INROOT
+      CHARACTER(len=100),allocatable,DIMENSION(:)::VARIABLES
+      CHARACTER(len=100),allocatable,DIMENSION(:)::VARIABLES_ROOT
+      CHARACTER(len=*), intent(in):: INFILE
+      CHARACTER(len=100):: INFILEMAIN,INFILEROOT
+      CHARACTER(len=3) :: STRING_ID
+      LOGICAL :: error
+      INTEGER MASTER
+      PARAMETER( MASTER = 0 )
+      TYPE (ZMUMPS_STRUC) :: id
+      error=.false.
+      write (STRING_ID, '(i3)') id%MYID
+      NBVARIABLES=171
+      allocate(VARIABLES(NBVARIABLES))
+      VARIABLES(171)="NB_SINGULAR_VALUES"
+      VARIABLES(170)="SINGULAR_VALUES"
+      VARIABLES(169)="IF_RESTARTING"
+      VARIABLES(168)="L0_OMP_MAPPING"
+      VARIABLES(167)="PTR_LEAFS_L0_OMP"
+      VARIABLES(166)="PERM_L0_OMP"
+      VARIABLES(165)="VIRT_L0_OMP"
+      VARIABLES(164)="PHYS_L0_OMP"
+      VARIABLES(163)="IPOOL_AFTER_L0_OMP"
+      VARIABLES(162)="IPOOL_BEFORE_L0_OMP"
+      VARIABLES(161)="THREAD_LA"
+      VARIABLES(160)="LL0_OMP_MAPPING"
+      VARIABLES(159)="L_VIRT_L0_OMP"
+      VARIABLES(158)="L_PHYS_L0_OMP"
+      VARIABLES(157)="LPOOL_BEFORE_L0_OMP"
+      VARIABLES(156)="LPOOL_AFTER_L0_OMP"
+      VARIABLES(155)="NBGRP"
+      VARIABLES(154)="LRGROUPS"
+      VARIABLES(153)="root"
+      VARIABLES(152)="WORKING"
+      VARIABLES(151)="IPTR_WORKING"
+      VARIABLES(150)="pad14"
+      VARIABLES(149)="SUP_PROC"
+      VARIABLES(148)="PIVNUL_LIST"
+      VARIABLES(147)="OOC_FILE_NAME_LENGTH"
+      VARIABLES(146)="OOC_FILE_NAMES"
+      VARIABLES(145)="OOC_NB_FILE_TYPE"
+      VARIABLES(144)="OOC_NB_FILES"
+      VARIABLES(143)="OOC_TOTAL_NB_NODES"
+      VARIABLES(142)="OOC_VADDR"
+      VARIABLES(141)="OOC_SIZE_OF_BLOCK"
+      VARIABLES(140)="pad13"
+      VARIABLES(139)="OOC_INODE_SEQUENCE"
+      VARIABLES(138)="OOC_MAX_NB_NODES_FOR_ZONE"
+      VARIABLES(137)="INSTANCE_NUMBER"
+      VARIABLES(136)="pad12"
+      VARIABLES(135)="CB_SON_SIZE"
+      VARIABLES(134)="DKEEP"
+      VARIABLES(133)="LWK_USER"
+      VARIABLES(132)="NBSA_LOCAL"
+      VARIABLES(131)="WK_USER"
+      VARIABLES(130)="CROIX_MANU"
+      VARIABLES(129)="SCHED_SBTR"
+      VARIABLES(128)="SCHED_GRP"
+      VARIABLES(127)="SCHED_DEP"
+      VARIABLES(126)="SBTR_ID"
+      VARIABLES(125)="DEPTH_FIRST_SEQ"
+      VARIABLES(124)="DEPTH_FIRST"
+      VARIABLES(123)="MY_NB_LEAF"
+      VARIABLES(122)="MY_FIRST_LEAF"
+      VARIABLES(121)="MY_ROOT_SBTR"
+      VARIABLES(120)="COST_TRAV"
+      VARIABLES(119)="MEM_SUBTREE"
+      VARIABLES(118)="RHSCOMP"
+      VARIABLES(117)="POSINRHSCOMP_COL"
+      VARIABLES(116)="POSINRHSCOMP_ROW"
+      VARIABLES(115)="POSINRHSCOMP_COL_ALLOC"
+      VARIABLES(114)="MEM_DIST"
+      VARIABLES(113)="I_AM_CAND"
+      VARIABLES(112)="TAB_POS_IN_PERE"
+      VARIABLES(111)="FUTURE_NIV2"
+      VARIABLES(110)="ISTEP_TO_INIV2"
+      VARIABLES(109)="CANDIDATES"
+      VARIABLES(108)="ELTPROC"
+      VARIABLES(107)="pad11"
+      VARIABLES(106)="NA_ELT"
+      VARIABLES(105)="LELTVAR"
+      VARIABLES(104)="NELT_loc"
+      VARIABLES(103)="DBLARR"
+      VARIABLES(102)="INTARR"
+      VARIABLES(101)="PROCNODE"
+      VARIABLES(100)="S"
+      VARIABLES(99)="PTRFAC"
+      VARIABLES(98)="PTLUST_S"
+      VARIABLES(97)="PROCNODE_STEPS"
+      VARIABLES(96)="NA"
+      VARIABLES(95)="FRTELT"
+      VARIABLES(94)="FRTPTR"
+      VARIABLES(93)="PTRAR"
+      VARIABLES(92)="FILS"
+      VARIABLES(91)="DAD_STEPS"
+      VARIABLES(90)="FRERE_STEPS"
+      VARIABLES(89)="Step2node"
+      VARIABLES(88)="ND_STEPS"
+      VARIABLES(87)="NE_STEPS"
+      VARIABLES(86)="STEP"
+      VARIABLES(85)="NBSA"
+      VARIABLES(84)="LNA"
+      VARIABLES(83)="KEEP"
+      VARIABLES(82)="Deficiency"
+      VARIABLES(81)="MAXIS1"
+      VARIABLES(80)="IS1"
+      VARIABLES(79)="IS"
+      VARIABLES(78)="BUFR"
+      VARIABLES(77)="POIDS"
+      VARIABLES(76)="LBUFR_BYTES"
+      VARIABLES(75)="LBUFR"
+      VARIABLES(74)="ASS_IRECV"
+      VARIABLES(73)="NSLAVES"
+      VARIABLES(72)="NPROCS"
+      VARIABLES(71)="MYID"
+      VARIABLES(70)="COMM_LOAD"
+      VARIABLES(69)="MYID_NODES"
+      VARIABLES(68)="COMM_NODES"
+      VARIABLES(67)="INST_Number"
+      VARIABLES(66)="MAX_SURF_MASTER"
+      VARIABLES(65)="KEEP8"
+      VARIABLES(64)="pad8"
+      VARIABLES(63)="WRITE_PROBLEM"
+      VARIABLES(62)="OOC_PREFIX"
+      VARIABLES(61)="OOC_TMPDIR"
+      VARIABLES(60)="VERSION_NUMBER"
+      VARIABLES(59)="MAPPING"
+      VARIABLES(58)="LISTVAR_SCHUR"
+      VARIABLES(57)="SCHUR_CINTERFACE"
+      VARIABLES(56)="SCHUR"
+      VARIABLES(55)="SIZE_SCHUR"
+      VARIABLES(54)="SCHUR_LLD"
+      VARIABLES(53)="SCHUR_NLOC"
+      VARIABLES(52)="SCHUR_MLOC"
+      VARIABLES(51)="NBLOCK"
+      VARIABLES(50)="MBLOCK"
+      VARIABLES(49)="NPCOL"
+      VARIABLES(48)="NPROW"
+      VARIABLES(47)="UNS_PERM"
+      VARIABLES(46)="SYM_PERM"
+      VARIABLES(45)="RINFOG"
+      VARIABLES(44)="RINFO"
+      VARIABLES(43)="CNTL"
+      VARIABLES(42)="COST_SUBTREES"
+      VARIABLES(41)="INFOG"
+      VARIABLES(40)="INFO"
+      VARIABLES(39)="ICNTL"
+      VARIABLES(38)="pad5"
+      VARIABLES(37)="LREDRHS"
+      VARIABLES(36)="LSOL_loc"
+      VARIABLES(35)="NZ_RHS"
+      VARIABLES(34)="NRHS"
+      VARIABLES(33)="LRHS"
+      VARIABLES(32)="ISOL_loc"
+      VARIABLES(31)="IRHS_PTR"
+      VARIABLES(30)="IRHS_SPARSE"
+      VARIABLES(29)="SOL_loc"
+      VARIABLES(28)="RHS_SPARSE"
+      VARIABLES(27)="REDRHS"
+      VARIABLES(26)="RHS"
+      VARIABLES(25)="PERM_IN"
+      VARIABLES(24)="pad4"
+      VARIABLES(23)="A_ELT"
+      VARIABLES(22)="ELTVAR"
+      VARIABLES(21)="ELTPTR"
+      VARIABLES(20)="pad3"
+      VARIABLES(19)="NELT"
+      VARIABLES(18)="pad2"
+      VARIABLES(17)="A_loc"
+      VARIABLES(16)="JCN_loc"
+      VARIABLES(15)="IRN_loc"
+      VARIABLES(14)="pad1"
+      VARIABLES(13)="NZ_loc"
+      VARIABLES(12)="pad0"
+      VARIABLES(11)="ROWSCA"
+      VARIABLES(10)="COLSCA"
+      VARIABLES(9)="JCN"
+      VARIABLES(8)="IRN"
+      VARIABLES(7)="A"
+      VARIABLES(6)="NZ"
+      VARIABLES(5)="N"
+      VARIABLES(4)="JOB"
+      VARIABLES(3)="PAR"
+      VARIABLES(2)="SYM"
+      VARIABLES(1)="COMM"
+      NBVARIABLES_ROOT=34
+      allocate(VARIABLES_ROOT(NBVARIABLES_ROOT))
+      VARIABLES_ROOT(34)="NB_SINGULAR_VALUES"
+      VARIABLES_ROOT(33)="SINGULAR_VALUES"
+      VARIABLES_ROOT(32)="SVD_VT"
+      VARIABLES_ROOT(31)="SVD_U"
+      VARIABLES_ROOT(30)="gridinit_done"
+      VARIABLES_ROOT(29)="yes"
+      VARIABLES_ROOT(28)="rootpad3"
+      VARIABLES_ROOT(27)="QR_RCOND"
+      VARIABLES_ROOT(26)="rootpad"
+      VARIABLES_ROOT(25)="RHS_ROOT"
+      VARIABLES_ROOT(24)="rootpad2"
+      VARIABLES_ROOT(23)="QR_TAU"
+      VARIABLES_ROOT(22)="SCHUR_POINTER"
+      VARIABLES_ROOT(21)="RHS_CNTR_MASTER_ROOT"
+      VARIABLES_ROOT(20)="rootpad1"
+      VARIABLES_ROOT(19)="IPIV"
+      VARIABLES_ROOT(18)="RG2L_COL"
+      VARIABLES_ROOT(17)="RG2L_ROW"
+      VARIABLES_ROOT(16)="rootpad0"
+      VARIABLES_ROOT(15)="LPIV"
+      VARIABLES_ROOT(14)="CNTXT_BLACS"
+      VARIABLES_ROOT(13)="DESCRIPTOR"
+      VARIABLES_ROOT(12)="TOT_ROOT_SIZE"
+      VARIABLES_ROOT(11)="ROOT_SIZE"
+      VARIABLES_ROOT(10)="RHS_NLOC"
+      VARIABLES_ROOT(9)="SCHUR_LLD"
+      VARIABLES_ROOT(8)="SCHUR_NLOC"
+      VARIABLES_ROOT(7)="SCHUR_MLOC"
+      VARIABLES_ROOT(6)="MYCOL"
+      VARIABLES_ROOT(5)="MYROW"
+      VARIABLES_ROOT(4)="NPCOL"
+      VARIABLES_ROOT(3)="NPROW"
+      VARIABLES_ROOT(2)="NBLOCK"
+      VARIABLES_ROOT(1)="MBLOCK"
+      IN=52+id%MYID
+      INFILEMAIN=trim(adjustl(INFILE)) // trim(adjustl(STRING_ID))
+      open(UNIT=IN,FILE=INFILEMAIN, STATUS='old',FORM='unformatted'
+     &     ,iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN ZMUMPS_RESTART CANNOT OPEN FILE: "
+     &        //trim(adjustl(INFILEMAIN))
+         error=.true.
+         goto 101
+      endif
+      DO i1=4,NBVARIABLES
+         size_array1=0
+         size_array2=0
+         SELECT CASE(VARIABLES(i1))
+         CASE("JOB")
+            read(IN) id%JOB
+         CASE("N")
+            read(IN) id%N
+         CASE("ICNTL")
+            read(IN) id%ICNTL
+         CASE("INFO")
+            read(IN) id%INFO
+         CASE("INFOG")
+            read(IN) id%INFOG
+         CASE("COST_SUBTREES")
+            read(IN) id%COST_SUBTREES
+         CASE("CNTL")
+            read(IN) id%CNTL
+         CASE("RINFO")
+            read(IN) id%RINFO
+         CASE("RINFOG")
+            read(IN) id%RINFOG
+         CASE("KEEP8")
+            read(IN) id%KEEP8
+         CASE("KEEP")
+            read(IN) id%KEEP
+         CASE("DKEEP")
+            read(IN) id%DKEEP    
+         CASE("NZ")
+            read(IN) id%NZ
+         CASE("A")
+            nullify(id%A)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%A(size_array1))
+               read(IN) id%A
+            endif
+         CASE("IRN")
+            nullify(id%IRN)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRN(size_array1))
+               read(IN) id%IRN
+            endif
+         CASE("JCN")
+            nullify(id%JCN)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%JCN(size_array1))
+               read(IN) id%JCN
+            endif
+         CASE("COLSCA")
+            nullify(id%COLSCA)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%COLSCA(size_array1))
+               read(IN) id%COLSCA
+            endif
+         CASE("ROWSCA")
+            nullify(id%ROWSCA)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ROWSCA(size_array1))
+               read(IN) id%ROWSCA
+            endif
+         CASE("NZ_loc")
+            read(IN) id%NZ_loc
+         CASE("IRN_loc")
+            nullify(id%IRN_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRN_loc(size_array1))
+               read(IN) id%IRN_loc
+            endif
+         CASE("JCN_loc")
+            nullify(id%JCN_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%JCN_loc(size_array1))
+               read(IN) id%JCN_loc
+            endif
+         CASE("A_loc")
+            nullify(id%A_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%A_loc(size_array1))
+               read(IN) id%A_loc
+            endif
+         CASE("NELT")
+            read(IN) id%NELT
+         CASE("ELTPTR")
+            nullify(id%ELTPTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ELTPTR(size_array1))
+               read(IN) id%ELTPTR
+            endif
+         CASE("ELTVAR")
+            nullify(id%ELTVAR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ELTVAR(size_array1))
+               read(IN) id%ELTVAR
+            endif
+         CASE("A_ELT")
+            nullify(id%A_ELT)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%A_ELT(size_array1))
+               read(IN) id%A_ELT
+            endif
+         CASE("PERM_IN")
+            nullify(id%PERM_IN)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PERM_IN(size_array1))
+               read(IN) id%PERM_IN
+            endif
+         CASE("RHS")
+            nullify(id%RHS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%RHS(size_array1))
+               read(IN) id%RHS
+            endif
+         CASE("REDRHS")
+            nullify(id%REDRHS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%REDRHS(size_array1))
+               read(IN) id%REDRHS
+            endif
+         CASE("RHS_SPARSE")
+            nullify(id%RHS_SPARSE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%RHS_SPARSE(size_array1))
+               read(IN) id%RHS_SPARSE
+            endif
+         CASE("SOL_loc")
+            nullify(id%SOL_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SOL_loc(size_array1))
+               read(IN) id%SOL_loc
+            endif
+         CASE("IRHS_SPARSE")
+            nullify(id%IRHS_SPARSE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRHS_SPARSE(size_array1))
+               read(IN) id%IRHS_SPARSE
+            endif
+         CASE("IRHS_PTR")
+            nullify(id%IRHS_PTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IRHS_PTR(size_array1))
+               read(IN) id%IRHS_PTR
+            endif
+         CASE("ISOL_loc")
+            nullify(id%ISOL_loc)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ISOL_loc(size_array1))
+               read(IN) id%ISOL_loc
+            endif
+         CASE("LRHS")
+            read(IN) id%LRHS
+         CASE("NRHS")
+            read(IN) id%NRHS
+         CASE("NZ_RHS")
+            read(IN) id%NZ_RHS
+         CASE("LSOL_loc")
+            read(IN) id%LSOL_loc
+         CASE("LREDRHS")
+            read(IN) id%LREDRHS
+         CASE("SYM_PERM")
+            nullify(id%SYM_PERM)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SYM_PERM(size_array1))
+               read(IN) id%SYM_PERM
+            endif
+         CASE("UNS_PERM")
+            nullify(id%UNS_PERM)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%UNS_PERM(size_array1))
+               read(IN) id%UNS_PERM
+            endif
+         CASE("NPROW")
+            read(IN) id%NPROW
+         CASE("NPCOL")
+            read(IN) id%NPCOL
+         CASE("MBLOCK")
+            read(IN) id%MBLOCK
+         CASE("NBLOCK")
+            read(IN) id%NBLOCK
+         CASE("SCHUR_MLOC")
+            read(IN) id%SCHUR_MLOC
+         CASE("SCHUR_NLOC")
+            read(IN) id%SCHUR_NLOC
+         CASE("SCHUR_LLD")
+            read(IN) id%SCHUR_LLD
+         CASE("SIZE_SCHUR")
+            read(IN) id%SIZE_SCHUR
+         CASE("SCHUR")
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHUR(size_array1))
+               read(IN) id%SCHUR
+            endif
+         CASE("SCHUR_CINTERFACE")
+            nullify(id%SCHUR_CINTERFACE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHUR_CINTERFACE(size_array1))
+               read(IN) id%SCHUR_CINTERFACE
+            endif
+         CASE("LISTVAR_SCHUR")
+            nullify(id%LISTVAR_SCHUR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%LISTVAR_SCHUR(size_array1))
+               read(IN) id%LISTVAR_SCHUR
+            endif
+         CASE("MAPPING")
+            nullify(id%MAPPING)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MAPPING(size_array1))
+               read(IN) id%MAPPING
+            endif
+         CASE("VERSION_NUMBER")
+            read(IN) id%VERSION_NUMBER
+         CASE("OOC_TMPDIR")
+            read(IN) id%OOC_TMPDIR
+         CASE("OOC_PREFIX")
+            read(IN) id%OOC_PREFIX
+         CASE("WRITE_PROBLEM")
+            read(IN) id%WRITE_PROBLEM
+         CASE("MAX_SURF_MASTER")
+            read(IN) id%MAX_SURF_MASTER
+         CASE("INST_Number")
+            read(IN) id%INST_Number
+         CASE("COMM_NODES")
+            read(IN) id%COMM_NODES
+         CASE("MYID_NODES")
+            read(IN) id%MYID_NODES
+         CASE("COMM_LOAD")
+            read(IN) id%COMM_LOAD
+         CASE("MYID")
+            read(IN) id%MYID
+         CASE("NPROCS")
+            read(IN) id%NPROCS
+         CASE("NSLAVES")
+            read(IN) id%NSLAVES
+         CASE("ASS_IRECV")
+            read(IN) id%ASS_IRECV
+         CASE("LBUFR")
+            read(IN) id%LBUFR
+         CASE("LBUFR_BYTES")
+            read(IN) id%LBUFR_BYTES
+         CASE("POIDS")
+            nullify(id%POIDS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%POIDS(size_array1))
+               read(IN) id%POIDS
+            endif
+         CASE("BUFR")
+            nullify(id%BUFR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%BUFR(size_array1))
+               read(IN) id%BUFR
+            endif
+         CASE("IS")
+            nullify(id%IS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IS(size_array1))
+               read(IN) id%IS
+            endif
+         CASE("IS1")
+            nullify(id%IS1)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IS1(size_array1))
+               read(IN) id%IS1
+            endif
+         CASE("MAXIS1")
+            read(IN) id%MAXIS1
+         CASE("Deficiency")
+            read(IN) id%Deficiency
+         CASE("LNA")
+            read(IN) id%LNA
+         CASE("NBSA")
+            read(IN) id%NBSA
+         CASE("STEP")
+            nullify(id%STEP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%STEP(size_array1))
+               read(IN) id%STEP
+            endif
+         CASE("NE_STEPS")
+            nullify(id%NE_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%NE_STEPS(size_array1))
+               read(IN) id%NE_STEPS
+            endif
+         CASE("ND_STEPS")
+            nullify(id%ND_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ND_STEPS(size_array1))
+               read(IN) id%ND_STEPS
+            endif
+         CASE("Step2node")
+            nullify(id%Step2node)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%Step2node(size_array1))
+               read(IN) id%Step2node
+            endif
+         CASE("FRERE_STEPS")
+            nullify(id%FRERE_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FRERE_STEPS(size_array1))
+               read(IN) id%FRERE_STEPS
+            endif
+         CASE("DAD_STEPS")
+            nullify(id%DAD_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DAD_STEPS(size_array1))
+               read(IN) id%DAD_STEPS
+            endif
+         CASE("FILS")
+            nullify(id%FILS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FILS(size_array1))
+               read(IN) id%FILS
+            endif
+         CASE("PTRAR")
+            nullify(id%PTRAR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PTRAR(size_array1))
+               read(IN) id%PTRAR
+            endif
+         CASE("FRTPTR")
+            nullify(id%FRTPTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FRTPTR(size_array1))
+               read(IN) id%FRTPTR
+            endif
+         CASE("FRTELT")
+            nullify(id%FRTELT)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FRTELT(size_array1))
+               read(IN) id%FRTELT
+            endif
+         CASE("NA")
+            nullify(id%NA)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%NA(size_array1))
+               read(IN) id%NA
+            endif
+         CASE("PROCNODE_STEPS")
+            nullify(id%PROCNODE_STEPS)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PROCNODE_STEPS(size_array1))
+               read(IN) id%PROCNODE_STEPS
+            endif
+         CASE("PTLUST_S")
+            nullify(id%PTLUST_S)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PTLUST_S(size_array1))
+               read(IN) id%PTLUST_S
+            endif
+         CASE("PTRFAC")
+            nullify(id%PTRFAC)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PTRFAC(size_array1))
+               read(IN) id%PTRFAC
+            endif
+         CASE("S")
+            nullify(id%S)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%S(size_array1))
+               read(IN) id%S
+            endif
+         CASE("PROCNODE")
+            nullify(id%PROCNODE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PROCNODE(size_array1))
+               read(IN) id%PROCNODE
+            endif
+         CASE("INTARR")
+            nullify(id%INTARR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%INTARR(size_array1))
+               read(IN) id%INTARR
+            endif
+         CASE("DBLARR")
+            nullify(id%DBLARR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DBLARR(size_array1))
+               read(IN) id%DBLARR
+            endif
+         CASE("NELT_loc")
+            read(IN) id%NELT_loc
+         CASE("LELTVAR")
+            read(IN) id%LELTVAR
+         CASE("NA_ELT")
+            read(IN) id%NA_ELT
+         CASE("ELTPROC")
+            nullify(id%ELTPROC)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ELTPROC(size_array1))
+               read(IN) id%ELTPROC
+            endif
+         CASE("CANDIDATES")
+            nullify(id%CANDIDATES)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%CANDIDATES(size_array1,size_array2))
+               read(IN) id%CANDIDATES
+            endif
+         CASE("ISTEP_TO_INIV2")
+            nullify(id%ISTEP_TO_INIV2)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%ISTEP_TO_INIV2(size_array1))
+               read(IN) id%ISTEP_TO_INIV2
+            endif
+         CASE("FUTURE_NIV2")
+            nullify(id%FUTURE_NIV2)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%FUTURE_NIV2(size_array1))
+               read(IN) id%FUTURE_NIV2
+            endif
+         CASE("TAB_POS_IN_PERE")
+            nullify(id%TAB_POS_IN_PERE)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%TAB_POS_IN_PERE(size_array1,size_array2))
+               read(IN) id%TAB_POS_IN_PERE
+            endif
+         CASE("I_AM_CAND")
+            nullify(id%I_AM_CAND)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%I_AM_CAND(size_array1))
+               read(IN) id%I_AM_CAND
+            endif
+         CASE("MEM_DIST")
+            nullify(id%MEM_DIST)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MEM_DIST(0:size_array1-1))
+               read(IN) id%MEM_DIST
+            endif
+         CASE("POSINRHSCOMP_ROW")
+            nullify(id%POSINRHSCOMP_ROW)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%POSINRHSCOMP_ROW(size_array1))
+               read(IN) id%POSINRHSCOMP_ROW
+            endif
+         CASE("POSINRHSCOMP_COL_ALLOC")
+            read(IN) id%POSINRHSCOMP_COL_ALLOC
+         CASE("POSINRHSCOMP_COL")
+            nullify(id%POSINRHSCOMP_COL)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               if(id%POSINRHSCOMP_COL_ALLOC) then
+                  allocate(id%POSINRHSCOMP_COL(size_array1))
+                  read(IN) id%POSINRHSCOMP_COL
+               else
+                  read(IN) dummy
+                  id%POSINRHSCOMP_COL=>id%POSINRHSCOMP_ROW
+               endif
+            endif
+         CASE("RHSCOMP")
+            nullify(id%RHSCOMP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%RHSCOMP(size_array1))
+               read(IN) id%RHSCOMP
+            endif
+         CASE("MEM_SUBTREE")
+            nullify(id%MEM_SUBTREE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MEM_SUBTREE(size_array1))
+               read(IN) id%MEM_SUBTREE
+            endif
+         CASE("COST_TRAV")
+            nullify(id%COST_TRAV)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%COST_TRAV(size_array1))
+               read(IN) id%COST_TRAV
+            endif
+         CASE("MY_ROOT_SBTR")
+            nullify(id%MY_ROOT_SBTR)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MY_ROOT_SBTR(size_array1))
+               read(IN) id%MY_ROOT_SBTR
+            endif
+         CASE("MY_FIRST_LEAF")
+            nullify(id%MY_FIRST_LEAF)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MY_FIRST_LEAF(size_array1))
+               read(IN) id%MY_FIRST_LEAF
+            endif
+         CASE("MY_NB_LEAF")
+            nullify(id%MY_NB_LEAF)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%MY_NB_LEAF(size_array1))
+               read(IN) id%MY_NB_LEAF
+            endif
+         CASE("DEPTH_FIRST")
+            nullify(id%DEPTH_FIRST)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DEPTH_FIRST(size_array1))
+               read(IN) id%DEPTH_FIRST
+            endif
+         CASE("DEPTH_FIRST_SEQ")
+            nullify(id%DEPTH_FIRST_SEQ)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%DEPTH_FIRST_SEQ(size_array1))
+               read(IN) id%DEPTH_FIRST_SEQ
+            endif
+         CASE("SBTR_ID")
+            nullify(id%SBTR_ID)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SBTR_ID(size_array1))
+               read(IN) id%SBTR_ID
+            endif
+         CASE("SCHED_DEP")
+            nullify(id%SCHED_DEP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHED_DEP(size_array1))
+               read(IN) id%SCHED_DEP
+            endif
+         CASE("SCHED_GRP")
+            nullify(id%SCHED_GRP)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SCHED_GRP(size_array1))
+               read(IN) id%SCHED_GRP
+            endif
+         CASE("CROIX_MANU")
+            nullify(id%CROIX_MANU)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%CROIX_MANU(size_array1))
+               read(IN) id%CROIX_MANU
+            endif
+         CASE("WK_USER")
+            nullify(id%WK_USER)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%WK_USER(size_array1))
+               read(IN) id%WK_USER
+            endif
+         CASE("NBSA_LOCAL")
+            read(IN) id%NBSA_LOCAL
+         CASE("LWK_USER")
+            read(IN) id%LWK_USER
+         CASE("CB_SON_SIZE")
+            nullify(id%CB_SON_SIZE)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%CB_SON_SIZE(size_array1))
+               read(IN) id%CB_SON_SIZE
+            endif
+         CASE("INSTANCE_NUMBER")
+            read(IN) id%INSTANCE_NUMBER
+         CASE("OOC_MAX_NB_NODES_FOR_ZONE")
+            read(IN) id%OOC_MAX_NB_NODES_FOR_ZONE
+         CASE("OOC_INODE_SEQUENCE")
+            nullify(id%OOC_INODE_SEQUENCE)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_INODE_SEQUENCE(size_array1,size_array2))
+               read(IN) id%OOC_INODE_SEQUENCE
+            endif
+         CASE("OOC_SIZE_OF_BLOCK")
+            nullify(id%OOC_SIZE_OF_BLOCK)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_SIZE_OF_BLOCK(size_array1,size_array2))
+               read(IN) id%OOC_SIZE_OF_BLOCK
+            endif
+         CASE("OOC_VADDR")
+            nullify(id%OOC_VADDR)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_VADDR(size_array1,size_array2))
+               read(IN) id%OOC_VADDR
+            endif
+         CASE("OOC_TOTAL_NB_NODES")
+            nullify(id%OOC_TOTAL_NB_NODES)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_TOTAL_NB_NODES(size_array1))
+               read(IN) id%OOC_TOTAL_NB_NODES
+            endif
+         CASE("OOC_NB_FILES")
+            nullify(id%OOC_NB_FILES)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_NB_FILES(size_array1))
+               read(IN) id%OOC_NB_FILES
+            endif
+         CASE("OOC_NB_FILE_TYPE")
+            read(IN) id%OOC_NB_FILE_TYPE
+         CASE("OOC_FILE_NAMES")
+            nullify(id%OOC_FILE_NAMES)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_FILE_NAMES(size_array1,size_array2))
+               read(IN) id%OOC_FILE_NAMES
+            endif
+         CASE("OOC_FILE_NAME_LENGTH")
+            nullify(id%OOC_FILE_NAME_LENGTH)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%OOC_FILE_NAME_LENGTH(size_array1))
+               read(IN) id%OOC_FILE_NAME_LENGTH
+            endif
+         CASE("PIVNUL_LIST")
+            nullify(id%PIVNUL_LIST)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%PIVNUL_LIST(size_array1))
+               read(IN) id%PIVNUL_LIST
+            endif
+         CASE("SUP_PROC")
+            nullify(id%SUP_PROC)
+            read(IN) size_array1,size_array2
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%SUP_PROC(size_array1,size_array2))
+               read(IN) id%SUP_PROC
+            endif
+         CASE("IPTR_WORKING")
+            nullify(id%IPTR_WORKING)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%IPTR_WORKING(size_array1))
+               read(IN) id%IPTR_WORKING
+            endif
+         CASE("WORKING")
+            nullify(id%WORKING)
+            read(IN) size_array1
+            if(size_array1.EQ.-999) then
+               read(IN) dummy
+            else
+               allocate(id%WORKING(size_array1))
+               read(IN) id%WORKING
+            endif
+         CASE("root")
+        CASE("NBGRP")
+           read(IN) id%NBGRP
+        CASE("LRGROUPS")
+           nullify(id%LRGROUPS)
+           read(IN) size_array1
+           if(size_array1.EQ.-999) then
+              read(IN) dummy
+           else
+              allocate(id%LRGROUPS(size_array1))
+              read(IN) id%LRGROUPS
+           endif
+         CASE("SCHED_SBTR")
+            nullify(id%SCHED_SBTR)
+            read(IN) size_array1
+            IF(size_array1.EQ.-999) THEN
+               read(IN) dummy
+            ELSE
+               allocate(id%SCHED_SBTR(size_array1))
+               read(IN) id%SCHED_SBTR
+            ENDIF 
+        CASE("LPOOL_AFTER_L0_OMP")
+           read(IN) id%LPOOL_AFTER_L0_OMP
+        CASE("LPOOL_BEFORE_L0_OMP")
+           read(IN) id%LPOOL_BEFORE_L0_OMP
+        CASE("L_PHYS_L0_OMP")
+           read(IN) id%L_PHYS_L0_OMP
+        CASE("L_VIRT_L0_OMP")  
+           read(IN) id%L_VIRT_L0_OMP
+        CASE("LL0_OMP_MAPPING")
+           read(IN) id%LL0_OMP_MAPPING
+        CASE("THREAD_LA")
+           read(IN) id%THREAD_LA
+        CASE("IPOOL_AFTER_L0_OMP")
+           nullify(id%IPOOL_AFTER_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%IPOOL_AFTER_L0_OMP(size_array1))
+              read(IN) id%IPOOL_AFTER_L0_OMP
+           ENDIF 
+        CASE("IPOOL_BEFORE_L0_OMP")
+           nullify(id%IPOOL_BEFORE_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%IPOOL_BEFORE_L0_OMP(size_array1))
+              read(IN) id%IPOOL_BEFORE_L0_OMP
+           ENDIF 
+        CASE("PHYS_L0_OMP")
+           nullify(id%PHYS_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%PHYS_L0_OMP(size_array1))
+              read(IN) id%PHYS_L0_OMP
+           ENDIF 
+        CASE("VIRT_L0_OMP")
+           nullify(id%VIRT_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%VIRT_L0_OMP(size_array1))
+              read(IN) id%VIRT_L0_OMP
+           ENDIF
+        CASE("PERM_L0_OMP")
+           nullify(id%PERM_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%PERM_L0_OMP(size_array1))
+              read(IN) id%PERM_L0_OMP
+           ENDIF
+        CASE("PTR_LEAFS_L0_OMP")
+           nullify(id%PTR_LEAFS_L0_OMP)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%PTR_LEAFS_L0_OMP(size_array1))
+              read(IN) id%PTR_LEAFS_L0_OMP
+           ENDIF
+        CASE("L0_OMP_MAPPING")
+           nullify(id%L0_OMP_MAPPING)
+           read(IN) size_array1
+           IF(size_array1.EQ.-999) THEN
+              read(IN) dummy
+           ELSE
+              allocate(id%L0_OMP_MAPPING(size_array1))
+              read(IN) id%L0_OMP_MAPPING
+           ENDIF 
+        CASE("IF_RESTARTING")
+           read(IN) id%IF_RESTARTING 
+        CASE("SINGULAR_VALUES")
+         read(IN) size_array1
+         if(size_array1.EQ.-999) then
+            read(IN) dummy
+         else
+            allocate(id%SINGULAR_VALUES(size_array1))
+            read(IN) id%SINGULAR_VALUES
+         endif  
+      CASE("NB_SINGULAR_VALUES")
+        write(IN) id%NB_SINGULAR_VALUES
+        CASE("pad0","pad1","pad2","pad3","pad4","pad5","pad8","pad11",
+     &          "pad111", "pad12","pad13","pad14")
+        CASE DEFAULT
+           id%INFOG(1)=-92
+           write(*,*) "IN ZMUMPS_RESTART UNKNOWN VARIABLE IN "
+     &       // "STRUCTURE: "//  trim(adjustl(VARIABLES(i1)))
+           goto 101
+        END SELECT
+      ENDDO
+ 101  continue
+      close(IN)
+      if(error) goto 102
+      INROOT=1000+IN
+      INFILEROOT=trim(adjustl(INFILE)) // trim(adjustl("ROOT")) 
+     &     // trim(adjustl(STRING_ID)) 
+      open(UNIT=INROOT,FILE=INFILEROOT, STATUS='old',FORM='unformatted'
+     &     ,iostat=err)
+      if(err.ne.0) THEN
+         id%INFOG(1)=-91
+         write(*,*) "IN ZMUMPS_RESTART CANNOT OPEN FILE: "
+     &        //trim(adjustl(INFILEROOT))
+         goto 102
+      endif
+      DO i2=1,NBVARIABLES_ROOT
+         SELECT CASE(VARIABLES_ROOT(i2))
+      CASE("MBLOCK")
+         read(INROOT) id%root%MBLOCK
+      CASE("NBLOCK")
+         read(INROOT) id%root%NBLOCK
+      CASE("NPROW")
+         read(INROOT) id%root%NPROW
+      CASE("NPCOL")
+         read(INROOT) id%root%NPCOL
+      CASE("MYROW")
+         read(INROOT) id%root%MYROW
+      CASE("MYCOL")
+         read(INROOT) id%root%MYCOL
+      CASE("SCHUR_MLOC")
+         read(INROOT) id%root%SCHUR_MLOC
+      CASE("SCHUR_NLOC")
+         read(INROOT) id%root%SCHUR_NLOC
+      CASE("SCHUR_LLD")
+         read(INROOT) id%root%SCHUR_LLD
+      CASE("RHS_NLOC")
+         read(INROOT) id%root%RHS_NLOC
+      CASE("ROOT_SIZE")
+         read(INROOT) id%root%ROOT_SIZE
+      CASE("TOT_ROOT_SIZE")
+         read(INROOT) id%root%TOT_ROOT_SIZE
+      CASE("DESCRIPTOR")
+         read(INROOT) id%root%DESCRIPTOR
+      CASE("CNTXT_BLACS")
+         read(INROOT) id%root%CNTXT_BLACS
+      CASE("LPIV")
+         read(INROOT) id%root%LPIV
+      CASE("RG2L_ROW")
+         nullify(id%root%RG2L_ROW)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RG2L_ROW(size_array1))
+            read(INROOT) id%root%RG2L_ROW
+         endif
+      CASE("RG2L_COL")
+         nullify(id%root%RG2L_COL)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RG2L_COL(size_array1))
+            read(INROOT) id%root%RG2L_COL
+         endif
+      CASE("IPIV")
+         nullify(id%root%IPIV)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%IPIV(size_array1))
+            read(INROOT) id%root%IPIV
+         endif
+      CASE("RHS_CNTR_MASTER_ROOT")
+         nullify(id%root%RHS_CNTR_MASTER_ROOT)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RHS_CNTR_MASTER_ROOT(size_array1))
+            read(INROOT) id%root%RHS_CNTR_MASTER_ROOT
+         endif
+      CASE("SCHUR_POINTER")
+         nullify(id%root%SCHUR_POINTER)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SCHUR_POINTER(size_array1))
+            read(INROOT) id%root%SCHUR_POINTER
+         endif
+      CASE("QR_TAU")
+         nullify(id%root%QR_TAU)
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%QR_TAU(size_array1))
+            read(INROOT) id%root%QR_TAU
+         endif
+      CASE("RHS_ROOT")
+         nullify(id%root%RHS_ROOT)
+         read(INROOT) size_array1,size_array2
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%RHS_ROOT(size_array1,size_array2))
+            read(INROOT) id%root%RHS_ROOT
+         endif
+      CASE("QR_RCOND")
+         read(INROOT) id%root%QR_RCOND
+      CASE("yes")
+         read(INROOT) id%root%yes
+      CASE("gridinit_done")
+         read(INROOT) id%root%gridinit_done
+      CASE("SVD_U")
+         read(INROOT) size_array1,size_array2
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SVD_U(size_array1,size_array2))
+            read(INROOT) id%root%SVD_U
+         endif
+      CASE("SVD_VT")
+         read(INROOT) size_array1,size_array2
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SVD_VT(size_array1,size_array2))
+            read(INROOT) id%root%SVD_VT
+         endif
+      CASE("SINGULAR_VALUES")
+         read(INROOT) size_array1
+         if(size_array1.EQ.-999) then
+            read(INROOT) dummy
+         else
+            allocate(id%root%SINGULAR_VALUES(size_array1))
+            read(INROOT) id%root%SINGULAR_VALUES
+         endif  
+      CASE("NB_SINGULAR_VALUES")
+        write(INROOT) id%root%NB_SINGULAR_VALUES
+         CASE("rootpad0","rootpad1","rootpad2","rootpad",
+     &        "rootpad3")
+      CASE DEFAULT
+         id%INFOG(1)=-92
+         write(*,*) "IN ZMUMPS_RESTART UNKNOWN VARIABLE "
+     &        // "IN ROOT: "// trim(adjustl(VARIABLES_ROOT(i2)))
+         goto 102
+      END SELECT  
+      ENDDO
+      if(id%root%gridinit_done) then
+         id%root%CNTXT_BLACS = id%COMM_NODES
+         CALL blacs_gridinit( id%root%CNTXT_BLACS, 'R',
+     &        id%root%NPROW, id%root%NPCOL )
+         id%root%gridinit_done = .TRUE.
+      endif
+ 102  continue
+      close(INROOT)
+      END SUBROUTINE ZMUMPS_RESTART
diff -ruN MUMPS_5.1.2/waf mumps-5.1.2-aster7/waf
--- MUMPS_5.1.2/waf	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/waf	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,172 @@
+#!/usr/bin/env python3
+# encoding: latin-1
+# Thomas Nagy, 2005-2018
+#
+"""
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+
+3. The name of the author may not be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+"""
+
+import os, sys, inspect
+
+VERSION="2.0.20"
+REVISION="df7687050314fa98c5daa534cb234b8c"
+GIT="cef110adc2fb3789107b6ed8dee15397dc7e4030"
+INSTALL=''
+C1='#8'
+C2='#.'
+C3='#,'
+cwd = os.getcwd()
+join = os.path.join
+
+
+WAF='waf'
+def b(x):
+	return x
+if sys.hexversion>0x300000f:
+	WAF='waf3'
+	def b(x):
+		return x.encode()
+
+def err(m):
+	print(('\033[91mError: %s\033[0m' % m))
+	sys.exit(1)
+
+def unpack_wafdir(dir, src):
+	f = open(src,'rb')
+	c = 'corrupt archive (%d)'
+	while 1:
+		line = f.readline()
+		if not line: err('run waf-light from a folder containing waflib')
+		if line == b('#==>\n'):
+			txt = f.readline()
+			if not txt: err(c % 1)
+			if f.readline() != b('#<==\n'): err(c % 2)
+			break
+	if not txt: err(c % 3)
+	txt = txt[1:-1].replace(b(C1), b('\n')).replace(b(C2), b('\r')).replace(b(C3), b('\x00'))
+
+	import shutil, tarfile
+	try: shutil.rmtree(dir)
+	except OSError: pass
+	try:
+		for x in ('Tools', 'extras'):
+			os.makedirs(join(dir, 'waflib', x))
+	except OSError:
+		err("Cannot unpack waf lib into %s\nMove waf in a writable directory" % dir)
+
+	os.chdir(dir)
+	tmp = 't.bz2'
+	t = open(tmp,'wb')
+	try: t.write(txt)
+	finally: t.close()
+
+	try:
+		t = tarfile.open(tmp)
+	except:
+		try:
+			os.system('bunzip2 t.bz2')
+			t = tarfile.open('t')
+			tmp = 't'
+		except:
+			os.chdir(cwd)
+			try: shutil.rmtree(dir)
+			except OSError: pass
+			err("Waf cannot be unpacked, check that bzip2 support is present")
+
+	try:
+		for x in t: t.extract(x)
+	finally:
+		t.close()
+
+	for x in ('Tools', 'extras'):
+		os.chmod(join('waflib',x), 493)
+
+	if sys.hexversion<0x300000f:
+		sys.path = [join(dir, 'waflib')] + sys.path
+		import fixpy2
+		fixpy2.fixdir(dir)
+
+	os.remove(tmp)
+	os.chdir(cwd)
+
+	try: dir = unicode(dir, 'mbcs')
+	except: pass
+	try:
+		from ctypes import windll
+		windll.kernel32.SetFileAttributesW(dir, 2)
+	except:
+		pass
+
+def test(dir):
+	try:
+		os.stat(join(dir, 'waflib'))
+		return os.path.abspath(dir)
+	except OSError:
+		pass
+
+def find_lib():
+	src = os.path.abspath(inspect.getfile(inspect.getmodule(err)))
+	base, name = os.path.split(src)
+
+	#devs use $WAFDIR
+	w=test(os.environ.get('WAFDIR', ''))
+	if w: return w
+
+	#waf-light
+	if name.endswith('waf-light'):
+		w = test(base)
+		if w: return w
+		for dir in sys.path:
+			if test(dir):
+				return dir
+		err('waf-light requires waflib -> export WAFDIR=/folder')
+
+	dirname = '%s-%s-%s' % (WAF, VERSION, REVISION)
+	for i in (INSTALL,'/usr','/usr/local','/opt'):
+		w = test(i + '/lib/' + dirname)
+		if w: return w
+
+	#waf-local
+	dir = join(base, (sys.platform != 'win32' and '.' or '') + dirname)
+	w = test(dir)
+	if w: return w
+
+	#unpack
+	unpack_wafdir(dir, src)
+	return dir
+
+wafdir = find_lib()
+sys.path.insert(0, wafdir)
+
+if __name__ == '__main__':
+
+	from waflib import Scripting
+	Scripting.waf_entry_point(cwd, VERSION, wafdir)
+
+#==>
+#BZh91AY&SYtDmh#,0E0mb(w#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,/}Wvw7t][5jmmdWvWZYY5iM{jr\v#,e	4b].#,}=v'w_}E]uh16g:]g];nwkz#,#,#,;#,P/c@#,G#,Gl]@6oytiGGl&nh)mv(Q[#.$UJQ@{"{1$#,	j6m-{iak.Zj4GlbRU;s}.Zzw}kWY^WZ=4}Ds7wxU%[EIP)mQzWh{malj"r0#,PT	!;=Q#wtzkwm{v:BoWfCU=8d_1W}gFynQM=g`TZ^omm'#.^3fUm^{9c+Mn_\y^|{z>A:vR1oloJKsbsL=v7s/I&Wg}Uo,m-07po!vnow{#,`**Z5@3n#8(9U0.i])]ow}P#,T{}|}k5Uv="Sku5;N|pb4l|!cunYB;cM{[mOF^n/ww>_^\wYY#w8cv[=\'u.B7e]rh0U&rw]Q:T]C^{w#.fy%kZnm{S7B^7smKiOBJj#.;k^]o(kvq]=y{#}o{Rpzo*u3r5/a9Rmzm>}a#4wZ\,PP+I#8^jozbz>WUG;9Y[$C}[gH{{zl]_]<k>t4#,@4#,@2L@#,4!2=O(4#,mA=O#8mA)B 	OA4)5MGz#,#,#,#,#,#,$"M#,CLdjJ~14S#54z#,#,#,#,#,I#."i?P5=O=Fh@#,#,#,#,#,#,#,#,$A#,@i&A0A44S#.IzLC@#,4#,#,#,j"#,#@	iS#.#,#,#,#,#,#,/J]jej#8QDH0#,L#8#,EIB<>r?&~z6nC*Wuq3R[T\#uLiz.\|nOKwN1/3*mN-(.3f2o,\d|j])!WF#,)0($*H#8H4*&	 #,dx^)%y83 o <$4JA"OTT"*@&H<Pd$jfIb2*R(M4	PTFB3IdQ%b6HZX46IZ-DPYiM-1-!BLA31IFd#.&a&4	"	32L$Mi&Ii-6Si2fX#8)kLMB#.2(6BH) ED6"JFiQjRCA 2XhdFIR&B#K,$#)f,2Y)dMlb#.HC%JiIFQ!FJTi@%d"XZAcY!&3Jf0lK+FL)66-%%D$F)LL2)e#8e$Y5RDKJl!E,(YQ6l")FleSLI#.dH4Fd1eb	il li1I*IeAFL6B(,YY)2&iQ0YB`L1	&jfZQR"fCR44#8,QLlb*YL#Djd2#8C)#.6YR06FHM(F2E*I1$YI&H)2M$Dh`!4F""	M(&if$#.QTD#8DlS#(5%EDhjE1LDY6De0H40LCDi0L53FR$biE$DEh5),f)4,jealSb2D#HJmablmcmI5hZBMlQjf2	RF33LeXKQ!h5acR#8e2eI5i*l2U40MfDVVDSk%h$R)4*Z2TEY-FbJ54DZ1cZZ6EQH&&2&cFX$XDV[YbLD#)iHVURJ%jdEK"e63m	)X6fj,Q2I4E#"A1S0!*#8-dh2Xd`lH@")))(`b#8-dLI#Mb!#.1$dbbacDI3QES"YeXM3#,dhbJP$&(Q4d)SlDS#.jHXF%#82Z(ibM6e,fRSfVaa,jIj6hPJMclKQHFD&fA%D&*SLT%3QX6lfhe4%[YFR$ (#T6(%15$$E1V36-#.&HM#.,Fj#86,eXd6JYIS"5bjEA#,0, 4m%Qh4d(Dl-EQ`6#)[e],k&&eRC2RJmbE%E)4+4TiQ 5&1&#lI A#8)*QRVKfESI5DQEM+db(AL&"4ZYhV6m)F5 Q(BQLRLdfFcfc	[IbRT6[(HE3lF1mIhbkEb#cj#i(T9eF9%Flkedi+bRehfd M[m%"eBbJ###,#.MiCmbhZK&d-4(#La*MI#8e$FadDk?+Ep#.FCl%dMO?Wt%3ei#.M4ov'234iN2y&q	4<mHhUPUUoP#8E#.*>Z?%LgxF"X[s*d[l-L%StrLZva8cafz(UnRpZ!IIJZbMtO/'&'y!1r=]zksY~3>g5r	6kEowxN#.;ddCBZ c@gQ]@L)o4$RQzTqZ$=nft\c,/rA#:fuuBe8B@gPCCm:\kc	r#CG#8>(08=VoW(TT^c,Dn]R$V9.(PR+t#.Fm$E5m"O>>S+ln]"~C(gpTp:#8t+[ieAbzkoopr2#8)|2rxousFkWy:W.d.9dt	M!9F(H:T43lee#8hbM?F4#.)+29cUHT[b#.P6hIA@Vxs@W|#tE]P}+/~?pG^^!<)rurGSDMY8	waX9=;PW}|H)>~s=[&u#.nHNB+PRh^I9'Va#8kCBLBZT)b#=/kbbd]T'}Y5"c(WR/v'uyE}VztWl3v^p#,>P(LSIvU*yS:A@V5xj7k?kK`DdMMyC#.#.[J>mzk!@cgL'!GTu)TARh^&=E~r[wc7vu)b^u3Pi-n>%=wp`Otc&K@WL\quPF+karD v#8X0VBJ",5m)HN-N4]=tx:S(E%ZSZVStHSE#8lQMZH"JuJ*-5kJSucg_s	#8-DGGJ*rB#8KvQQ>g#.taz#V.!x{D9z01v9o?&6T3#8317ejM'Io3~veJ*j"piMk?ow.T=,sP3VHjY{JCOq#8Iu8Da8[AcRGR	7CVM~tlj<jJtJU;xWS8&.S8W[+]|r_4ws'>p#.bZ07Cg~V!dxa;<RfBf^ZGp0%$Ku@(l;&zvG177KO#8LgVm 7V[#.uoz;$:h}|FxH"0:E5B^9-vC~,0QzH)#,7cmQ+b<R:IxK5%/~R:,8`=jR;'xo^W#[m=@..5vch8{:Cls=Zu	$(0t%BdN?	I8QeD9zC|WMpV_b{C-9VraCm#.ml}z&<e|or3jvb}9#.^#.,Mo'k4%D*cl/B#8>7+]n2/)!6B)z_BRQ(	+W_{u>VZ[yQTR>>|6<nC_P_VQ>l|(oU5F,(A$KxO6S!k&0^Z#.3'H?{~{\myQ>U'W5v6"}X_#<%t#x~Alg8p&*W~56`sq43qLU,#-9YVg>[Elh=CSbHkryMe4n&;L.]=skCjJW*)jD2ii5]gB=Kdti_TFf5/\cHES#8(-f@bR{!<o.v$3|GAVGl_&>4QIB^#.K4lT^tE)\:'?<*;F5>i2s89:h]& :Fc~0B`e_SGn|]F*4dT/U#zy#Gm@['*#.@UU7U];{9Z+#8-C8}z*U91RYLC5|,"30NRYG;Ah0$7!&k(.EU{Ur0;0*zG/bdV;ypNSKb!B9+JP	Jma}z\:fWAexYk|3J);]Mp|G^|'={`tJ\lt=|WoZ.~oDeyTYObcWz~Y:~YeayzRWSk>(F0p=`4U6i1DE{G<u7)!xdPE%7Sb!$7}vTn;%.QvkRTq@WJxG/>J+j?(PO(!c"cpt8=sJj+J#r~UQSG6SBu)	%tC6:N=JH28ycm<G/.0#8aFJg~MGgcI#Z=7o4uGHl:tC	7yp[0{MyZ1(`fn^>=#.h5g:fTXZ#.*	Te; BH| GDb?	V|#e4d!~wt!cd8l:28R#8?=#8co.+BB>HRm~vcH//80m3vOj0a=QhU6 DYgO#.E~#8i~?Olg}iI[8<y}}gc~p'5Vu0u~5O~i)zjsvvW\Qmk}!<#.f0C-#8F,V!1R+hMg5#.2	jzVM00YUFuhEm@0f8,m\j@-vxd 4 03sZk<{F&IqSYD"Z;bP&-aZK!#.ar|tNR{{/u!PJ:uXhqGU&TTM~vPj'5"7iS1Z$z@DfjJF&UvR7R*QZb%#,m*f.$\"7uWp DhV\Cb:S! .#.c%6'8QHX*B*_+YZ$[ugI0#>R#,y#,'.C~	PF	*:T6kauuBC5<3of}jWS4Ri;n)Qk;FqM<Zrniw&SUuqkA%#rCufb4JZBcsQhD@]$e_}3Y+zbqqYaur8J%3/"r37!F:I|Xv_'mMuZ3Qx'	8<%dhIcTMu8Y<1$y-4Lj#>00nZgL6&m;1t_7(d{a^#.6u}1M#,`Ff=2pSqKA"u(L'6HWVOnAg"s!^\R\}	r0B"pc#87^ ]m"/>`/z&IeDnw-:q|Mv.E&AAQN&|XY~>7gKo`GeRUB{V\sm72s;bH<W(s2[_$~'JB#I#,t~u~}bD%!jvA%<[y0B#.ufM-d+~_g;dtH&O<HC)C+|x|N~IWO#LlBT`)9T#,d*pX#8HQXZ_r	D;cJn!|_PjFO.:-h 71h}i`ey>;yx`u^o#.XNbwyTg_vsdKCF=jZe,yd-j5?@mn5{#~(4BC9Q4@CK9JZbasJ(tj^Dqn+tPY?MDs\,qP#.%DtZ(g#,CbCF]X9h%=o[J]]kM\U-T4>|	7xBs%Sm@iJZN]-`@(AM'(C(d2I(tE#.A ?BDP9.tl #, B	z!Dz;%#,%"A/@^)y W8l_];Q#8<G$Z_'sfb>=^}n&P){GQv;#.9+mx>:$k[R")#,&@E(UmR+x>fC`s^iQE39p5C~v:b<@2GWc;#8M\1DY>7"#,n!H#8eDx/PB":}oN{eX=g6D#iD2a!paNY>EHi}4@f1H#.c;}I#,%;@cma.w=p}h3>tAH!NQ#,?	G08Mu6mOsq`V &by#,b0IR$0KOe~1\1s}><<m@7M79DxZ7#g/TGo(nr,Fq=$Y5~%0 38ak!g42&_[s^@*,UCx~nHxQ{bjE~hA?r@- n>;w,b I[=TIcb3&GtGs@_N~gM|u^r\31*+q{NQW04B<[|!0.,p,#."#,4!<=|EyyKx%df`!29=Ke-$rM)7G#,db%hQnS4d}uV#8%t	*NX:$_g3=AZLD{>^Uf_J2>n`fgbb|jR]GIwQ`,d>)<bOzb5#.gHH[#.euTe#OTV4OEJ)#8#.mU"'oWN#,W&68@!B#,X3HA%%U?3#8HG{iErf]l2}r4#.~?( xU(wFAm#8 8(G$@xv='M0m#.B}?VDNwS]1MLYh81 Mvczlr7@h%,kY^"5sitt!yp7-HI%`=<s=wrR"5C60Sw<GDO<`zh1M2tvGY-^)8VwU~@xoJXq+FRMbAmpLze- PSv;	<JZZ`STD1vLyE!LimGIh5"#n{D#PX&1|O&&S S08FBew8YhR!Sy`A+3xlG#82:}"0Jf=19AClDsbg)	~-^N?cF80%&	(TN?5*G*?E^}~xfM_ dPc1D|P{9hVov522. qh#8Z,f+bIsN.iB(]vNv9;C;_&{2RU:Bc},zDAjr}t}jm $(A 1#Ag8x4`VKJ#8)9 [tX5'@(6-F#8sE<_dlv5[[hM)#.Ppp;j2BuK4v!L9lhr39z)mBP%pfAl%s"WWa7g_28hl[w|#.cz`;Kftn5<VQ+3GGdJv3T5/c)ed]>~Hc_C.P{SbcL+#,%mimP:O#.m}J/c<LO0z	n#8lb&*U~ef0:2) ,O^hvo1>\/<yg/$5!,)V2#8Il#8LcjhgwfLZ"HV#,)9LNt!#Cw6cs.64WppH={NOXAw{[S5b#.wz/JKCp9!0.7c2pn8,?7+C[,0rS"px#8x!1f8yn0`B>?>}1UH@oR|>}"[OZPF#8M:An`{"obEOU,E3}	9@c*cPDW8@S:tZ[#.J(BwCq.Anq-I0=b#88L!bcBJX11tX#8Bl6.|<E|mnhk5zbm,Qa)wi.RjB.c+cNF1chrvzb(8bE,v%1ImR4`~e=W~[>"_EGGr1/ysn(<?*xO	w	!J`@m9D%dClP#8\(SR_;m;#8A)#.SO4	[iydpgKdcl"64n9.5LzpO][Z Wz8J`jTh9s}b1HY;TqY$sgcbd2$:^8:4P^v1h7f8 |c 'Jf\hGv	so01k32[KqW1j?Hp@lTJU"P`IdpNd!aovAV!E=b-L@!F|ZAe#8=QNJsaDg#.j4C[64./?&f2DyRjb3S=#8tP G:a#.$:632Q2D!7P[CR!ZDQ;"8k1'*#8[F,q;H5LD`!M).7N#:%k-p`*(5"SZh~\h6Fh(i\#Hfxp\5Vd:Q$jE*u?E/&r<GByP128w)#.-VDcqK.#8i#.GKLMd5AD2lr#U~G0,$	'n,5Gf)2Rc7#,9?^E!2>oC(rwnXm6	E~Mwwx^ULR[e(9B#s,|-&G!!`1{<(}UB'NuPD e0OsvAw-c&Bj4=L1)5PA`h0ps.k6,@MZ'DiR/\Lo;rN_Up;b^>y[&13UreZHQBUQCZfnTn&~_NNp#88tQ.TD$/,_`l #,L!=:>8OmUH}QKy7HvV3~HC;rK.T!Jja)DrURC112:Ul!T"7-^bo#.t#8"(,XLxhRJ3xC>'PLAnAn.E0\|YU\Bxk>LHK5tj(14[Fi0#qB`PF:l<W/i&N$`Ko	^bvqTvz,p}qD'	Wi!AIex@PL^~Kh\F@O?qq(#8x~b_oKok/5?#e~?}u,xL&CYn>Q!:}V,\I#|e<,8~lwi|JOW,I1m,`HwN~,vx eyXgY#.l(j+\0>T=6	:	g|sk[8 K	K%X~=c=a*9Q'c,#.B`;ZmId& 3eK8MlUQXF RKVu;a}?vyMfG/<2SQvi+,A#8UBA`[R02`HfwSU{U1W_<OOMkz1dYh'_Sw (GT>P5HHaEJE#.`!2-CG8^gm#.mbqa#8'j*UW?_@s:]E^1=:%TWw_fi\_JS8]ZK`J]Ks`Hh*X7D|+q8<yP|QR,.|#9u4xbsll#.#8{TI]w\4ACRTAU\oOq06/[E@,~2Dyd~ODOzkO$M8;QH%#.4(#,bHP=LP|$8	{uO@G~?Oo#3ZfLeo?UK=='t~ nOlm9Wd{d\A'	0u+9X.q+!t/rQOggMvSMli|#MkA#.-6=#tFp*gM|?_FoZR<Il<1{CfsVp`3C;G(q=sfvOF>O!#8BcnDR.uL~<~6S=}:>O	GO9?;h}2/:z=^lShq*F/I#8](]6*:;}^#~O?(rkrv^<:OIP?ML[rbBcB&.P=LTDc?	R|]>p=F}iv(/UJHo2A1BA0tzPUE	q7SO41#oe?t#,w'/YUOC8!Hx]P#.PUV	#,Z#.Ck._=^~r	?G#8aQ4"C[W4gcS&(~6Bo=#8fl)/a#t*0"!bj=xg~Ot@WFI_##8ii)mt_7t?Y{{x{<wa}f`+5DHcj!wx-&86EiZ:?_wF~ch;v2b/i}:z9u}G}?{#.:COg @2Hdt,1iw?>VSb,}l~qdy.Pw:O.q^qu(u/}0^#.}?vN=wF0Vk:v}8%nPduoB>.r9gKujn#8bX<yYJvoI0BZ#%{8et?z<nU{/>r4&cR%pU6[Ad5y~URV)CT,4wzOnr>3+-^pw;Du37&#??{1f.'N+I#.;5a6a_UwV&_gNh/a*_N[Y>VkHelF2@c\,~*@d8t!#?/w#8(THT~.{S+J]9:N1wZn=#.1gF{5m_5K!AGf>o}x*>}#8;3_c(|_j[n3^7|#9Ap/$g+gtm=vY(&ahLQw#.#O^VojjhJP6}Z.S}U_m-aN~?wY?@tr:c#.Z?_BODg-'{=<xG}ze=jk;~[wa~8vW_	H6^1w}v7~Bu63<#.V/OrM!=}?xS?Usp8|[_k=);0v]/>a%A 2W#,9U:9>;srGX)63iG*"y=wbr4(Dvyo?O_|w.NY%G;i(@'Y7')*t<slCu#5x+ m9"@=lP/.nBB]jIA-?@+V3=c\oNVua01HfS8b#"]t*!n/XKE2):[#,G6iga9&{~&#.!J&N=kkhr`Av7w-r6%(Ejcw#.u}/\za^~<Y65MRo#8eT[)KJAxKFI?1jVM%!vmFc*}B=#.gI2I!%'qJ%>U;l/22JOd+|DqC.A#,x{2Yrw{+7VpXuNhnz}Pb)ZQ4c,G~`Yuui[.v>,q]#{PjS-h&L6fy|\>0q*a#.	0OgI=:[9w]Wo[?mU@jI;vPd"v:6W[=x'x|T=003AKl^>'.K6c=T?T>{%'|GxX01cay1Wxg?H#hu`CL7a+,DpaSqQFAHMJ*T& #D49p(?v0mGp!aa[M`cXLH5dM#.#.$RpEf8c7N'\6]SzoMzi.Nu}ZfbgZM38/o=wj?zL=a5A]cXw!xH%UH	.?qyDhdbi7x2EA*26Bv&NF%%$-(9:>	#My<4o)]&:qHdh>ee;U>}7-+%[//8O>XE0;_9w#.x;?.wwe[*k+=owT8XQSADzDT~aZuz}~2^W$fP1ixKth<}\;q^"N5#rsXZmkF6`hkO]O+?\^9da|Q}o?Q\p?/y14fQmZ$V"*ZCXC9f!]yy)MDE:Q`b65TQ&Q\hIn(-p#.zhau%mTclQ!l[PQt&w<YHrHsh,MhjoVdDnT!IlBR3ZCYKk$-B#8%25Xou),R4bq=j#cdxB34UQ9ADaWZeF8iVR")]KjcZAI$9%!9ULv ^taMH^@gzOmKdR:h^{!;WFa5X{Zhti	\ib#.^):1S`{wtEab")N2Oe9{saSiY3a?C#w:9SAr2L /xC%lnm#6Ip:#8$eUVGEhM@=,- $#<(~9r}"gi>>!#8H;O'~J%_1(@JA)}C"W{I6	~N6h&9FE(yusS(dqV!1[#,rDTU!A.TVPyl*^}+k,=LlzOJD&~c3Alp7s*[H)#0z0!yk*0)dakOr05ApE30BhbdFTX"{$L/;Fc "9ALm=BAC~hjB'jfR"%8*1H#DsV+6:muD:dc*I@fM,1#,Z8rF.2X6jne5KY?c#.k/4P+8rK(NZ%:E;H#.3 0,"\y(Po]r|\_:B:et E!KLHe1~>fSsc?iPyK+yn+)'z>	O-^I@>XL$m1bJ N0_+[_h+#.,Y%"	$nQZco`FEA	HhON3[QO\EM4.hnE{/FK#.mNs06iqQB|"mDCz|}zE33O!l*y/PdVpV/G&Eh27tv>=oR?7Npm4>	4Hy#CY}]mNLR7x268Ce*j#.+qB$#.ud8t3*&)jJ'~3H#8o-.I K5t#.=h#8|t7aW,ma#8o#.PxrL;Y$QAL3I-Xc5f;^j!V4bV5{2	op+v`j0tEmkFar7k2i2!H&7?a}3M9~`M\}vN2"6$9;boLXh~umm	;KpL$C5@%,c%92(xS-$!ST}0c&	$*N#,.gfho/K$F	a23:aR(#(;?wC~c#.5 6n|#8#/hs6&Xtg}Tkv!,Ef8Mp@4n+6@dj#1[5zXSq2!Cn[4#88n#.33xKwe15T$3}x5.u9SZeTu%+U9w\o\Fha@#xLRx-pJD~RJ#.n47B:IJ;5;v#8dw#8F/dBk8xpwEV}#,LBae+Vn8d2FP;5KM1dXe'91#8FoNq	E!&WnVc&[6 ImdAU6'b36#8>Fd=XDsU ^JRdv!B}P.KZsGr0GaFJ)SU#.%\dIF1D`zdL)\uOOjuzbqY\rg*IH!R1DJm-/uFS,-e4LHT>8olQC?M'DW]xfl4|I,rB|xE-,Sv~:Ki!>CgnqX#.Mq7D>yK/'-81M5<{kzuBOrrYXd^N8m{Xae8g#.]LWY#++\sk^Xg?2!t)T:jb~,uPyfi#._]*]D]wi=5:oN8iNZUJ	#,\#8:R`{U:;U| R<}j#,)zWmPfx]wS:QwqTvr_kXjDd?Q=`ryapxDT4#.Ppm8#\#82:G|@Oy\+ r{?.	DErs[	}>i~N:z6k/#,-y.|Z_1^bL8#,zpr`@.3s3}ix&XyN#	tF^#8eYJ#8f['(d6lax_{-1{b*#86#,B<-QBwf*j=JK+M{$="=,y}o/`)>pw?sY7<+U?\AvhJ?7">Y"dp{(&K1&=M-*.r9L@;7UL7`&bxeyg)IV\.Bm0JR[F3k h(=cuQb%6m+r35Vf:%!#82mP|Q>-GmEIO.R([/:#b5Ys(o_IkP|^9$]ABQ/iP d]k/h~=p>H&AzjPYQX[wA]BL3>5'mFPi]c(igQ[r#Z~?Zx"}--qw%EQ#))@A(i5@Xt83]"Sn=$=~l.&!u'Y@'#.3b8sM?-,$YVX^ajBBP\yu_MWA	[8aS9lVN/h#0f8#.{S}EB>_;<i"A#./qz(i#.eBo_8HN%P".hwUO;dRd|10=F0o(rgse#.67xc&:[~v2TOjanf08"@B&3\Gg'/vMZYK^G4cGD`"*>m #8V?#8^\Q(:]=e5+0	#8Fe8@yiv9|LPS?q/!}rg05VK(aC{8%`tsrGjK0WS2}]`A+%io)X	V>1"y	'l<Zj&'&3?f<#8_+ktC8./eB~mQ:|f"5o]$|+#qi|`!$6BG}h0#,fv]c+j/Ks>'nmf'DN#.ZwwnLc'jZJ-gCh*g-KmF+,hYo8xQ1nk]Kt7jmce k;Z/Fwgo672a')KY>{;t[:[>(pyG&J:`;'fDQ}(a%K[i<*%xrKU9B7s[>[t8:6FJ'OQ(=YE]*4iXAul#8=|DeSgN'}_%%w+eXl;<v7b.SdSIxzW7tBI/C|0J*09TFR(~%HIj/,e>>^fm2&]xyKHeLbxoc}6"\rr[%Ze%5<)D0"a#r_)fu][_"7Q0t>.#.klq,=;DXkAN+5YDRA_`ISC@B}13x2cKFa1>e{Vi9x6-/:)_Y.nq.00ayU"G]w&a2sgBJ\ub4r[J(7Z3'&erpxbN[Dj`HepiNcn5yuV.rG#.0oGGlN4HYs#.pzIY6QgphnJ\/]+&EUi8q_M7O'+o9UX8#>k7G[m,@cCV^Rtv/CkJ3(4HOih:;Rzw{Mg\Y\[|s#83ni5-]9.m`.ql/U"{pNrS#,9R#,9B#.2VG_M>aco+ib.W;Nf.b-Sn:}$U#8[G6	(.o(urOu5KEr#8(v!S'Yisd~Xu@~Qj?Suh-KJ5qnAB\e'(e]`98p9DR4u>0~p`g&QnIx/H`Fd5k]%u U^56K#8u+;z\}{|v[U(e1#8>Pc=GNowu4hv`VA\'sXo&zD0&VTCfQ*WD	8_sOtG^]g~sN$pQWX\M^E$w@:#,K%X#.#,b(o+H^'`|`iBm%th'UV7USDx`n{9_:+<qt]H!_-9K'6v:_+yOyT{xpfwC5/< H>xK3k7zT84VaDKfFZ\UxwM0H'\92SN3`3)QDC$b7Eo<YRe|0b(#mMv#bOraZ	lJ{yF6Hb8Q%<,kp|JB'0k5/jxF6:E$CAl0[J5}XKMYav0G\81hYV/tv6ak.ANhv^KM<je#8B9nC|,x`l[cn#.EeFhWA][6ZwY](4it,gY*s?1N0)Z#.#E7	H^v#,(gs&I8u;B.]>X8~ ={^1vS)i},3P+psLq@W$CX/CT.Ijp#.`*#8(+9*_V]IoirWuXl6l Av8JcERJ8#8lI.uLvknuV99dnzexMc#8\XzkuhIC1K2#iy{8SLys59$4,,\_d.`J;v}kppvk'g}F#-3]kmQ%#vgstwR:b7U!S	0W:TXDE#80mF?73@~Oh'4#8F0; 4<]L<TZz^HH\I7Q1QWUaqfG0m4}*#,{=}/g-Rg|Z.o@41rKM.gs9c-mMM&X^;^KEm"&N;Dvazi#.P6azoa#8d2"@5D\,5L7A'WF#D8TxdypvA  iFIrrG:\]k|uw"9m8~~4Lj#,}.UU8z*F\y TC&dkX-K `wb4y]A9^rzp?_D4j4luF62m)RXhcmQ,v)-#.`]Bls:\"W=R+V)kGsNUZma3`_Ge.a^C{BG_#.MV/6x}dG5)^hwNy*|NZY66>3k`QlU&#.M'/<}}]`2+rD<(pcE`c'7Z|IT^8/Ws=m3echcZU{H9|Xc19u:(xQiF"BUU(;F|59J+rgmC"P+u[}{XKGI&T%{Ol<eqL, i<.E&9iSe0kPLKBF+yw]Zpgr[Sd*N{WjHL<`V;C#."(duhql0}9Bn4_U-(:,9>Nmbwom7;}~8CwSBFu(2WE#.VNQkJ.5ng4m}IxzmTR<mxx<$.i'a(^Edmg4y[q=Q]Fm|6^66(dD|lzj8DI[:[H~B	NO`[#q#8Z<OXOT\&W^gvz3C|9o^2En5W:	y_s*r=qI#loBmUubTtpNA;o$|H"<*|r\r6#.[tHLNS5Joro(WLo#b2$D*2ICuM7h1^1\mO'!V^[	39?%	 I#.PF(ASPdI\@k)$b|t>z5J5JH_xWNGO<tG:+1Y7)kC[rHDQ+g^u8qiL9p-x3#.*xgr6z#8NO{FpK1YtJ'Z9*vBGRpuA\,`x_j&E{oD["#8OSdUtK9d2-R2V76X#,>'g`:79u\<kLR#80waj~z#.sW*v@7U_vilS>	4!;MdHKJ?C<{@O(Wxv4Z-l6t{9F#+T=!=JsMdGu_G#8@ZX#8Eq5"wJ(3~<r&f'2UrFh	]@oPJ16t\2AH:xq-4I,9Bb%(XbRh@#,tBW517_|{I3]|9ss(@>Z69U*=rmg#VdCSL~bYg%FZk	uhsO'a$}+)ZiTC_.Ap$` y$B(nf8lE@=wO;) k	 }Bo/Wa6Z~#1]aY9O6hj`6I\e /zQY}~?WHH([h!p.Eb	A%Y5`2lm9|g<*c@6:])@:irYG_;w_lC%w/F!RQy_@s-j-Qq.fOB=cH5# 6%6.5 ]'.:m"_{Piyer,'~MQPj]KXct#>4r@ *25RG\tntw~rV- \JXDp/zs	=vGr#8;;@82y-/-B!h |Z//;{	D#8dPT!'~?'2t: Dq| \Uz8##cKFa4-')!u$A5#.z@#.^8(	 qf;s8lIIMStQCM}I^L=^P{A,26_iww~oAA1\?4sJ5dpM]<NRO#8boz!TA$w^T#88wKvoFdW5gK'=x#	A#}33kS(q$jbyz~B0a|1}1Iz2XA$_mF8SRis3l"={s-EU3) KbL|$]U2w15=2rl:6a.j.XNQD8,!CwYShv[.H"e\ANn+^Q<}6i90CiQo,]@1]tr^{y=wz{CD)ZN!*P="8Bgtcq&~vDk#8-3FP?/_3}#.L<^GVCTU]B#8NIhs,f~`[_~qJ#80wbAP%WgykZaD\4#,5Q%=S +%#8qQ1xHuA~\o_2+4IXxJe6V:iebQ0#,CCT%.iqrLy<.:3s8yC_~p1KDy:Ff,InG"R^~!-[0?n#./Y/@KM<a:,7r4c5ABRAon(?zH@1vv#8speBrm@l&%:dKljd+B\@p[Q`-BwglH.57.mjm)BAek:90>+Z)'fl1#.`TdP3,nlxlcnol1H{,9m6	#.#.Pu.-?Mzyc]h#.#8^/9As6VB*@!&`(EqR$9>5mx3-?2Nr^:9(.DK1{D(IWmPbEO,MFrO'W?0m7c+25;BB+piFu[I j0'=}!@'IFw0r~w)UJ\;(M-c3P[CpDZ8RAEAD,1G)#8.)iVe:I5*p	A}#8AWg2sy}R\e~%A3bIx%(K"{{zj2YI]yC :61h)g(~]#c{		=k{bhe=LHyN0wX#8]HRgv.$2(#]o9$b9g1u!v<z["S>{yOgdF"[&Mn*ImRt0ot+X+0bYoP~K7864p[H	7/T@[Z;hhhP;w9XB8oDJ4#8~d|:\t-4A5[11S>]#.Bcjr< opRr!1rH"0$"ePo_-zl(paICRi"4N<GNrjqiX}*(5sY#wmJPdR# l%!f{,^$cDqSSAU2fggG)w58{`ZR984FV`T>AT=5/UAQh=>.>L}|	OOa~_0z>9ET?d>Es ?8^H{}|s& tRf#,z5*>#,-#|Mr/zyxp]uE}MG=pqa."#}vM?_s$BSM#8`b\1N'qNLg^)!{Q*]#8mr@~eny(<?	z0%&2|{f'94)<fpknA8^dG*#,J\DJNNQ28r3uLs'~^?7u0D;I@4aUUhcuz#	{Hix7>Hmx#09 lNp'GC`#,RDh9 sC@Ac'Ct5bJsG#.)<LL!8G^tt!st]BG7K$)O1yFJ#.Bn}"#8_l=$*v#RqdQ	EU!#,=0s;4?_f(68#8D?olkGT_$g|7pT/[Ff#.;Qr}-Q&Oh<{g:g!&#au	8M?J#I)[O46#.'9^&R#8B	C.['^WW"OY|'qXC#g}Zn,fGV##8wVNhVc#$zjS[E!)Ig,;mt;qsSi#83ud!3^@>x3=(-i}9!fo{'QB&l@8	@=92hW*D$0M#.ywd>.t-pq6N`P3KhC[rr((NJ),bZbfNz>%53*DquCxt}wA!h!C,MlnhmlInO!9( p'"AQ,'A`PyWABo!3gMQF<>h?x`,DA	hsaI. $8s$"l>1Hi<D/JM*y{zVF,O&#,3;K#8J8wC1\whrC i%Fx0@P	$ !a5z-fz%FDefl]#,R'5/z:>Wr0<-F''m)/#.-x<L'uGl|Iv+&kQ*6A<tRm(y(M>/smdD- %l7)e4RBTjUvw*u=("$^8dM}:aG pB.@#,Pbx4J	#8Qd4^JumxIt	!5fgM/,|DIm#LWo(~	-*7S=~]d~R,7..4@B"\Kl(YbPI#8l6#,A4[#,3_B@a#(*Q <5	S6S+$#8WR1_wV"ZPBdqrx+/ $.bNXLpR<ymRFoY2xx#AF:2#m<uI,At71Pj/@{|9AgwT`}~	6b>9f=BBy>!#8x4m~`KPC@u"GzNS]Dm#8HpR'#fYlZ}5Zf0{a8G?Cbeeaa/`+exw-,OW^]))o+ywc'KBe	 %Tv7CIAjMYwmC4Q_S#.76\v\et|#.j`((p|]69`9BNlgNr#r8d}#.McE4OkJUPR". Kp8^z:(q91_lD 1f,&#.!+AA0,Pq2CRFw^,@m+O#85rcw]=I9zzb}}[l{af=v]ApU E9.#.EnA<o<c#c]6#|p^E]nY|w#.us]V^9_|&X'+H'	::Xid$4#,O,A]}}#8$XpmBB_>EtT9$Ge}>z	P3w!Igl4.TLU]CZrD\38VBSQIa]Vyb0D5O2(#8~+9sY#,<9c(P%	dlDV i^&Mu`SSfX{E*A>*u5u~&\Oy?vjZRG4m[efv	#.`nqi8t<'	:dr#8;#.%;lfGgFh9lu0d]*4/\2]6F%@SBjGn5QT2r7>gB<NB(^	t#.1c#,?*a8/3LSS(HO|($,ZwY(Ud#,8;Np?'lQ]~BL#,lAHG1%\8-)1Myl=h#8 oDH?mD ??O<o`O$JS!IQV-0#,L>$oO'~5|Ll^j>bzyZAt|&?sX>J=wM!OCxH*:])v71$68=R /lg$@QSh`7]gg]q~V #,r&AQ*P`P8k3~G	`bk6}b\C;)#.0Vio\q=u (^5QP?+"H@8FKuQ-	#,#,#,0bP#,#,#,o=g/_5`X:mnf|"+}m7M#,32a#,%`@!$o q#]?/l.65$tbZxof|gD+:!vnz&#,'Xs:AEBf~goquI2.cT|~z	-$?4#,*6MP.>>=1Kx"#,}PM4b'eLC?SttNaPeh:Ug}gnX0@x]#,"#8:08#,ndx+a#,[&)t6/xwfLA:>\}7f,k}7#.	~	 i`d#8#8'jIW'0KG4d%wgzs)4Ocz|j2i:f?CISMKR((>uvUZT4DZIA dD}{;E8w?%4#`1}^m` UX_FW;<%):Gb(/%;XCc`y?:",(]4LlS?l#,|'3)4+oI_"sG?1)#;;:{Xn:YOeD;#8nrzwCx}5k!sy=C;W^?Z%	C|nhw41?Gq|X55L\(_I?FJ/88#,P ==-#.xi {&<B#,d#8{plx;^@R&~-!-((A;4aQ @PnR=[6'@_V7mpx?Oq}w#Vi?Yfd}qql x"|a	I'ENbhs+@@ygJSt^U~vo+8!m?]rSZBY[hk Fl(YEAh8dg[8\f@vs]Rf\o0(Wc0'+9"#Em#.jYm!G~yv`7#,7o TG94.4@"#,x 59Q#, HksN8~,%97~.j<Lf~y#.#,Ts7mIna}BhRyG#./	*(f'=|>~*knA,S?19g#.t7gqSm9Q6HdB"Q?s#._a	r|g>yPGJHm|l3Ex=C#,9p]_?"h?m9F@3k:JsvS8<>>,|ei#.Ztc[2(8"gm++&VucV/8S*&[z>0o[!yKG.]R~Ewk9~3(;tiwZ-5K^zlhuA_%Sw6u)oL;^6	t#Lgem_;)oJ"l&|8&D.]2):Sr[l^2]A4UFAW*P$G*<\V<(*921bWT:oUaF?wz|cU(ig.si)8d\/B:WQ{&Veozjbx$MLtA7IK)K vZ4"u+7M~6XdEe.ih%tcn:)D]mgEc^|%G 07aY\zgmy1;!_K(MqYkSVASy#8x:6! Q.=q)$L9pj{')KzYy$EG;ymPC8VSjU,qV	MSxl#mACxmOmTZD'vQRcXbNTO?a{6v8~zsCLH%NyDgr]FR_rv"6UN_DOURl?;vJ"lC5a2!%=H6de%[i(NjY|-]63N:',8vz3^(|!Jnnyf=xe\%s9Qk3yk')k-&1Evhb.W`eQEP/m tFG#8Fn*db6D78nd(z_Ju;2U\	P#8TR&I~B/!+\.;lNZ.y/3n?7MZiK]VF=EyDY>$Er|Icku=n#u{EubnKQ7mjuM %J~^ATK%#85e|x9kT75/|6#!G%X_76e*#.Vqzn,X#2vB!&pV$3^A#,p+k&FSR;q/CVANm6G\HKacGm5,B8_c~:FC\;+{JJEGqc2'v1N#.)X-OAX}t;'5hd!^ zr;8m%NGm.~8g!#8g_WK?`#(CXbasD:y]{)wwo_pu.zQ:)/KyNi6\r#.>P'gD1o9*8p0Vo?8t/]|$U=tx[qUahw8g:'X2j#8bXq2O'Gu.iAs!=c=seHK*_cO2Cj/!DGr(V#.,P3,a5d-%h1eX-{Cw:Q^J1T6sP,f;rj&S3^#,B\ "DdnF'm10{#8o#,Q%M0FeBY[{R1#8z`|tZ&Q@p?^4Qn2!<fHO5Mi;89 @^t=^l-NIf{T-:Ni-N|S19*@u7O<	h}zg@#8fT? %[{~m9/V?!VkRg]$ETSt-^9(QEa#,BGJ,>/2jdXJ`U#8S=Ra	~py5OO?;ch>%-zD,{sgRH1/s+4H^9D]*DR!Aa	&njq=y?#.UDes@?qz<}<05??X=|&Iav|${znZux]%>H#dRz:IWG$	A_ptAV#t#.0W7tGIpn~`dSdpCg*Z?n1LHMPenQA8yr@X\&%wwj xpQvBz%P`B,$0WtFHgBNhiRE<jFfkw]e.-oiM~Z(|tqnm#,^QYN@'f'2^>	dRkkSaYVTib$97r<zT;3L,f#ge;gE?{t$>tc1"04e[{:O_-93c<}w,Jw>8Fx1$A7T4JToZ9l}4x#,~n#..oJk=mp=(5tOy-/tC,lzOQB@!}WGZiTzPf\>Cp$DHS</FJ;#8#8.Cz1CtX~Ka'~GK1i8bO=:{w#8A@J=+E&Q6L!4g!.*;8DFmR?~{Q.{F#,hK|NgHLW(%FV^r=R1L0\=d]SET!T(K>>AybSNDT8Bcyzs.GK8S1#.dSB>(	t'>(8F 5}#8\.S<EhmF&i+"m MX:~*,6!	7Vp_0(6?#.=H4Ks;KtLZ#.)MG3wuKB,t;y-C:vDi[4ysC7[pZ+Uft)j"V+nJWD/s$5v]QX8.ot5>X&8:A]Q\aKLP\i`jUzTiu1hC-!{va2f;g(lRJoz(DwYfd"0#,E{p _=*}dD/zuS=!tqesYc}r|}G4Af%QbhBR&mP\2}-p%"+G;L	!XwwN;L<MuFH5F#.]]v#8t#.kd%Zh0W  m+PSI8<N#.GvcL=py-QumS [Em\_\sIC	"v{iZ%8^Jr)ry|$)#86z};Ij(FBzO7 A8y#,:JI< #,pI@0A9{n[smHGa|@h"*EPA[>uuk#,gC$ga:,Lu	C'7R [)e!$8#.f#.?@w^6 i0]Kb~_6	3o{T$5UlT!LP54L8w|}P^;2JNN6akj{A/:Q[StP<.JC)DgZ_Kf>F<0gVK#8fJVQ#8$TE@e6Hmut#.pOx6*O`Vvnj!s(PiPk37oP7w#8n[]f@A2GOI0zSy{RI'lX#.!ic"=ROq7(<c'S!vn]J9C"~3Xaz~Wr>$o#8*hc"[KV*o|j#.tsrA>z:GE?>smG-7~G(} iW(rKPTlefKm!U|2~i pckoAcY6PHo?i[~yl	6 8v	xZLZ~2/a-ur]h{g(a'9J`0!#.VD#,^8TWtSpsSxI>M6:<	!Z-pvwD0XDN;yzdGG[Fkd,5)n9^Qs>p0 Fa)l'XfoBR#._j1)m~xl4(&~H!#8o/}	a^!v#+6_Y6%#.t6.#,-]W{0QmclR5;F<zgNH2nqcS2z?	-}eY|3<%NXmYu	Ap*A.Qmc`;sMwd'D,mJ+n5#xlE%!&EuR0;H#WS0fGxEpG`'/'8BZH0Txj#,"#5EBb-4oxq8x@odDH>w[h3)!d1qor.rxQ7(#,4YB#,\>O0}Zt ;_0 +?O+8N<Z^j#B3	8l|r-MR4KEs#,I>jW960},Y4z]~\~1;De7'{Y],ez#8?H0Go@Vd@}b(^*woKkP}?N6`45$d-=*~z	lZ6#,	77K&*#.4M^<96H0F&C(,nbd4Lo:CxBy#,0'C'.bW9}H&=AIB8BW'#.	T@%1 >3G>:S<f>z9Dy}BLhWDtE!ra<_>~x"_qdtk[Jxb_8JN0gu5\DB|?OsZXP_;Q80b#,(8$^,ym#\@J5+9GHG\>_w~!vvg=|DzO&	wh(7a-l`?#7$1II=o/a]#.0&(Ia%NCxwNd'<8Jp#L&.~]#,?tIHm5E80iogbG9=]l_*=> <'<;$ws8]37~;l-#.M~&/LR%oa5!4!'yQfYB[*XvH0;Cj@_W!#81>1l(g@	1#.caj$|?Eg~7IPl}&?AAu#.X>Qob$31HI1zhbnLa$ROHyT*H>@|>U{Yl7zkxC7b)c107@^s7>n1K4=O/"aiHJx<	_/.hcd#U!@0y|6dg]N<kxB+x%$HkUz,r\tbo^a]LUU]v}^\dsbJ\?2T=^J4Tlrnoe[GUkbzW8AqEyhA _~<ya(~`V.*GlhP/0V_P\p	h'U9L;osrWz\[`S0ju+4ILFmT#.KOKYZX6?AW#j6h0hTZZ#8i!D#,1;N:7D{L>ppND%g:>?O7i_%:(>K/I1ix70B=X>P8	Cs"gKIcNJZo-hUe#d)Of8qSv<Nh;==z|=Frfz2#?suXG)jN%&p5y%`!pa2@8`#8s@vA_m-8!I_,0'iaCTz$HWfz,e3D6FOZ*r#.Vi-7r6YD4Yy$IXLy-zYu.W@zk,CC[RyuheC{u~+vcU\P|$_>M\cO-&RsHBxO%@~r#8WQb1G=(QQ;: u-?AF>M@$$0G>qKmH|5jd&["v]5B#8MLqg&<uYpp*mRD	(81Z,2.O#81 *mwgf|l#0PDu<r<Nc#TRv5"]I0TZ;};G<x`@>ED]~A`mIF |_~z|}@%}S=/U()JEMm!<@;#,4Ei#,hE\6}ouz~Fc;; MM-	]Q(-# oa1C7p\#,k?TJk`#/37I@AbP@~_W7=XW/s(Df|?W_D8yWNHli||?Ig_gYa%r"v{'N"BH#p=;a=g#,z'9#v(x'}J>Tsd{#,}D\%Hz{'C!,MyV;@V_=CWhFhq8_<C`p18u'9nnd%C z09=~1#,<u@'P'IP|)MDc\DM$	#8iN>8d(5U|P6#,@ PC|=IJ<'zC}Qga30pR,.oH{1`a(>ZpCnz%*fb0/XxC;<;XY>5zgw;'4`N/d"T|SGA0!"Hc:&v[r8alTgSz*HZ1M8yvhsx/in8:Drz]|jkR]I'X/fsiZ%j\forx4X!|9kE}_XP0G=#,W>Hz;;o%:D&=^EU93K~']3k_~K$G$*(+KA8bL6W.Ihwz_Gwm0&; d4"z*%$Pja/a?U?LWISvQ&H=~`8~~BPA1Gg"t73y+KW#,T&|z?(gZ?aB0PpZ[*9afgC>524k\3^[1.?bTaZi&5qVq8p,]809/9hElh=%2#8;bDN/?o#,T;@MSx=C#.h{}S:,PJ%: #,bKbRmOh~19>=aCB:Me$'?0cK*D:V#8mjQahfCThYP#84Je(%m|5JFCeBb`as#.iTcrg8pih|Y_f#,-mxGH' hg?pC&L#,8.\:I	$=\9	Szuyv+w^MmpY|	@57f&G?QP{+HuCS>8>#,t%4y xl#8hLQPe	D:6R!	9RP/dG>\<n3U[Z2#8Qp`},Jy{=Ta?$qD~~_cG#n4>hU0H^-b=$$?=>#.fg#.-`h3*Z1BNR~.,<8$0<8</D>OJjs'O0(O_Ryr	G$q7{=!Q##zP>^?)z8{?_h2g#,79ZfGc@d1E6hn0Le!{~*N)?#M\%O}'S<LYM`f((9)Uh<xpO/eA$'jyE	9#893a"3V8!AKW$$PpWz6Am@*#8bo~4zG4dC;#.a Y	v8uD#,?9		?6tD^GwS<O) <r PE!8#,	VT9XES#,0tF!]eEa1XoAnm7o*|Cx82A@T%#8 M=Xo$yERpdQ%Jsih6#	<#	#812NM7rh`!]3Q'u2Y8M.+ft~r#0bz6c}6wE*0@` ;N0`7pZ%Tu:bj>#8a#8j@=DfZ]O!Bd+(=XO@,H`5?#.mHR{/A?-0]wVna y;6.F8iFsv?J6=#.RZ(L&ftGINhu`$~\"Bqs}H|$\H,R{vvyg@?Z~o|`,?}!_@):?xv|=LkOCQyka !D?~P} UX6vC{8}c8C~k[16mS	#K:ZYXq@#.3#.z$GdS:0>A9C@AJ'73mlwAgJR-#eW#,rDp_Luy	#.#,zD	axM$?>S$nKNY#w^bg\dTq/="zt	#phgB'i#.e!z2PPL&l~O6`"aXV$?cf1qY|L;'<3p.M_G:9P^Q1S;k#,N6f))je Kwu<#(&&yY;g5vO(tO`#,lri!S|O;Nap'wNt?>E"!PR='lx$Kn=@E(5]&N9Xs?wia5ZFp1J$FX&Og ,Yk}^c]iRjeBw)?wD~~`N,\#8k@Z9HoL,}'/k:xq>r#,|`#,%#.{b@OQ<'#.yOEAY	@O)EyLO>=Rq28s>O?3TcA>MK#&1a4i"AAD{%Aq#,H],0D	,I?|~{@s\|+*&%#.Hm	@r|hM2O" @#\QU,TFRW/X6?<	:&abAf-E.E7%t(a#8a0j?#/p$W'N#.`L#."&37igpT5xQA1PDB[&4q5?mZ.Sc3@Y#8I]D#8UZ\`@ED<2 {BT?f	CW?>@76TbQ#8wKLGI::oN}NZ{zd3sUBdffCsB|Qh %7wyd%E9-U9u@bE9Bl~a5HF']>];i!`AD	!P;#8t4( D#8.A9&t[l5E|~[	i+W\A,\	i=;51KT$<NN@>;~cFnI.=68#,eR$#8:xz'#.WF?uM6m#,<5:ovz\5SHW&k&l.g:#8s(.DZGs6w);6)h#,AcA1mg"_Oa@u@Ul(?wB<9@'>)?#8?~Yt!'# I~#8CpFdQP3;yEtx~*E8d_yr@ZNF#,P(.2W/hkHaE!c,:Pe8nj$8ov0Uopo);K;v ,MYQ:gwsU	C:'7$S-5k(~wEM`uL:k*2c.l#./L:zWi)iCPhg#,b5{]~pKlus--A0GInq6:z:V fxJQJ((Btc6&ekRl6w<%#,v;$	kNbK/O[0Evdg	P~Wqws$cr]st7h*9UOZ`  FIT'<%d"8funbJaTxwrEr~A;Tl(+#,4[$DD8.e:EEl'-kv=R&bLGr}]kj]2Y;Oz",fl!K'x|?Mi?my:#83PuZvKo%\@q>*LSEyaFy%2#8$HjQn"?Y	1Ht3n9FzSq<#.aQ ((j~J}_;;Kv;#]r1pa54kP=2Ex$m rwMeoF&t}|L"v0$#8lNM.z|Xf10H/TJMmpYHIpkX(T}>F"09f<+vniyAjS0H;0BDy	w=z%f3NWADb2-+}0)^yxU={5e[	e`E$7tLs]VHsGD\#,u`Z$t]L0K4`A#!B~u?K<(Oa}PORg4j?>\{y!]?AsQPqDD4;zN##8Ls;_lI2?v}-#,ql0_	rx}a ?vjr\hApbPbuV7OalgC#nm	o@dqsPl0Cf?<j(BF<bvs<bIML'PCEuC'/=#,KgIp.dv^yf'|C 9=u2H#,s9eB,ef4nV&yhi=<.;wfv#V7	JY|Q~UlaeL$D(y9q/jH;,:hO2VPA<2u;+#.p}3ez&6Ce35S$u_p&0f0j`,Mb Dj`8p|N=fwcvqq3X#8v9,#8Bv d\;#n^<Gz#8@	~Brk'bW[0qGwwYAq*$#315'aD+Lm-	"!ZeYTaqAQ%xh?w!*/X^V6<i`f#Xb$;Wv<y5@9 =7gP6#XBsO{;#.Un<pylJ(%9h9,`vkmU$qCx,BAv<2H#.8C";-AO$=Z43T~KyB5e@8>I0#.I,aCm_/#,Ln65&T%.K#81`~8C`sbfS;#Qe8^jk>E#,sxeYe`nM<6y^r)g[b$Ov(y7&xyxwOi_n-JSu;'iW#.!:4BFq9-r[sxdp&pGi3:46:Xj=d#8'dJzIMcwfbC#8!C, cDd6kR#s`'<8CpI+6;G%H`<= AqJHi(f3e#8Q*Q|5nh#.)I*$rUmkW<Ac8p3BE{R&D.3f#)08CH\{2"<~[0m64|"pM8V9G1*&	oCMMv#*!fw$,8&M^LL	AIi0,5iACy[94(,?OJyyl]|dMc;"G`xFeR#8	:ys/U& B#8A:+nr.G=,X@39=Ny"wT(z<4z'&v7Hu4HfIx06vR_DsTU$(5BzgRv1Vjm"y<Cn%C*q<*Y`z"<'9ud9'G:nd9J<'{G5xB,'S-r5VFzyM:Wc:>#.fSlUe2ffX12%X^uqos@(|jX5O9+E^`eF:@"kT#{9Q>%:=\6&AdL!#.Ls;sZ30 pp2'GTXJ<d44NG`f4cKo;yv%1Ki]N"V2t+R5(3:IlK#;bXm_lEV`zzY43hZx1@h^bq+'o$$mO=xh-@=hI-d#8~tapP#D-EQ{iv,y0hBa3F[|ok:JB@G/z;Culh4ucc.\SElQGZS(/SC\	3'KU';Co$]	I"8Ni|h f1P}^rZ4MT=8q6:l"@hgWdTB7gY`vj]B!('O)8I`o/ f3arhF#.RC{"\#.a#.$?]2>M)w6	u-#8M9`cK+'\c<,iXzEqb\ad*t^j "kDSBq)({9F 6#,l.XmqIm#	2I!z(1zQ	lmO#x,!S5Q8y#,>v01#4>e)X%#.b<DHlCx2+q#,@=p>Jk18r!<Nyp,<|RKe|U^]Py\F=H#8>[By=w.t=*_=<z!L;."gYBJNVZ75%q8KY=7xjy3d$xh$k'BL	76UMKp	P@)FavL3?DBi'SA5)0L4Tmc}2LaNCtl9Bn|\*#8pU9;v"G)`pJX>WJoVri`t:w}/at!Lq	@(4fz~[[#,er4LH^.izl.,eHo<x=_aNZn4IK&ZMOiv&QjET'O	 9mK%IT#.CVD{w~nHD#,x;vQ>#04 79W46EEhdW*YLl;gco7_e	*(\b'PK#,0>#,8zK;vxnJ4X7t<bqO* &#,j\#.""iBd~>$Pp$yu[K0\RCS<N lC R#,bax#,bwLlk#8"jd6:CyZ)Mhy9&2`04m:sh?hw8=1Xw:*~`UC#.D$|N'ZQ:$]cO%30ys&zk7}W`Ft=[T/tU9wd#,r\R	#,:iC!(!~@pw}4#.("@<D`Sp;5'R&163em^)j02"d&&"!G)>LkRcMEi0`0nIxukswv57Vu#,	W#'-]Fmeg_< &5~G#.O#.:h|"*{2{0/'o+TRI%e#.%4s/w=;Zb_/Ha<t_G{ }n<>w9clIs\GxUii%9BH#.%D3B/8{}g5NY&^*b?f\F;Bb#.Iug[!)M<P{#!j@xcr4EdF#8@"`ic/p7N#nx|&,3OnxTH7sqmH;CT3#,d<rCx%\:J|=}z~2Cny)x"%g??+t^Kp[JL!."iP04CI_L&,2q=s7bv0,<Dsx@A(\A#i*0/G{>tmUAj{`BK!x&(]OycblxdLbUqMpry^#AM#vD.(!HOZ3XmE`IDVZUM5MmIZeDA3#,$"'^l<<"{hQ /#,BX|aj8! `C~s!F\MTs.7tiH	#H56kF!}h6mD|nhp7'v4J/[jyg#,. pN*7Z^L  M/\chboV<1naox_{9eJ<9t(&,#,CH[QCie\1%Q\\3aJE0j*Klm!"xYAsZABJ#,}(sA6;'IG9tK*QM&zw|b>X>JQ8 C z:F{<W|2c@<p><AAmd.'U}@g#,Y0a>5T<cC nt)*;F@#,_MbHu~+RNw~:0ne3P<NcLJlY .3dz=do<<;d,?]Tp:a~jo\Y}AwTiygP(#8 4M!~t+Nm`$4'd u6m?Mh4O&C[eni:O5~	Y"8^*z#:`]xG@<I A)}O{:xBK?)$	Pipo?Az|A#,qS4O4>}{H=!m	M3JKQ$c'v(a!J!3#8P NC>+g\lMtm<1X6<4 D0ROFb=CA}[]]J)h,3fG!b>8'0e$F'7@e<g,1, =@uR!G&0 JBZ	DN"	YA=P.%^wQ5C]bAY$#8>idO+;hC t2xD'%L#,xE!!3jW+]~(=6I"##,1GT;xD?ZH\#8,+=1+8Mh)|[;4)y}'j.dt.xK(\Q-s+8$%,	e?vV^NM,1V`Y{0j~eUgmpAG,=()\eKaA[g^MW@g_)}jvR\]6#^Vz3yr	{B*j\Bc\=M~'6zo>p&@u<LhH0OfN	nTBqhx4'?Rt9N<RqF}#8EJPMn0;B1ZYf%5`hy^F .fH;HF1}jp\F"70;#.Zb.:M!:Co,#,~ ,l:0'Iz8$#,t/AlKpAMpZdYK[?i`WX!!qBcg8h;69rJ&%:"Tb0vvx"g|#cMe$vAT_S=J0A`z#,z#.OC{vvb0U:{q#;8hkg0oGd2,C+qBa%8mXh4/_ |S}Pu?g;(DJt`IQytws3Nh?5@!H.#,7{?bQ<+wD6]T 6nbFlK5Y-FD4I"c2B  VKFBXa.&;L^$w^#=}<LpG?**3	26D/`}n?wCa^OFxY-Q&d5gd{I=Vg#,Ch8>=*G"W"6&JYff!N^e16B8xQOW26w '$.NTt9_ek=#,}mg# {6G#8OFmM9PIc5&bYi4	#)&0GeZ7@y#}Y6J0A#8<N7yo7vpd#.XZ;I0|(hm:az&66l.*ylxliK6Ff2L&vuc<Y243u;Mk9bh#.1xK6(|PIn	A@EhC#.{<9#.BpO#,T#8bM8fy#,..%E#8fuaL,ylbzoC<#82kM|e7Cfz3;~`#W/!n) "v\8^M(g3rt?Go	5E '#.6L|1u&S2paUX{oyf 0".!!hl5VA[H1 p	I!ypl8%=#87%O#8AH\W>4D5LH%ul7#,FqSS~NNP&hD	L``l.,Z'-<Y3H<lZk8 E$HQS"BaXh t=X9#8a*QjC^Ps1ziCI`r4K<	Pf@GI6I9;kt?Q4}W$1=F#/IdfchFYIW#.]T}i	 oa#,kv)Hsmx}]`9rlJc'Z!aUW?r@!20|O$s=KRpz6E~l=_z}K/0"h1e1VO#8@;e#8P1#`J"~UX]5EK]H:b$7%71"]b#,sXxF( /D$>^'pj"Tk[4(jm}	,UgBB6c"xZc!%xgH$vbsfc7\L	4]Z@x-vAM20pg[~$N2Y#4S0b3@D#.vE	wyn)=K>TL4B4cjC$Gf=i=]M.m4G}\Cz#hR4}9MhC[P#.'#8je!5ZZZM!(i#8QZh "Sn9Vg NJp02,8kB[AWUD-Bf#,C$	M?l#.<8BA..Z_#83y:M:'XXhnHn\x'	6n-vvG		SnsCk/!bn>Zd98Y(t(p%1#@"bB5*MYJ9-U#81K`;42_J@U&&jaV4h3Lr`YWxUsC2@bA1>!m.[R>]]!0"J-#.B^KBRp9p0I.9S&sMHRBHf5lUAuZ'6AvAzP{9tuBH9<!s"%XCd6A#,F#.(~}}1	4.hB_42Bzt1l;a#,C	703'z'Lek5Q,"+:Be2bnwNfIJFAm;,&z3#.ap|8lJ?2sZ99nKS fmle"}&"Kh{u9+z3T0T~`\v)>Q,DT k#.#"sli}{H.XD	Tbj!2I#T&$#.#8](656MJ)s4JA:ptTCLt-#dk6O#8g`;/'z) $:uf4z##dE{M<ts/^q2ZvjsUC)N{f\VV-k>Nh D@"zo>)A?	"_^F.xEBB5HdPd+#.(BF	v?_oGa{~/b0bA=R7:_#,T@{;7eX-\>lB	2Q1JdL2J)IeNZC*&(d#8+K-FLY%LfLL2FdQEMuIdP)I#T&EEA2EZb&Q)2S)24i42PE<8\<!wPidsc[&l!C_cVX	iQ2;7Ki,78e#,b3w>bxJ(1,;mCPjfGrN0XWkH+6Ef{5Iy~#.J\1lM\cFgN&)X(5XMbI4Og{:y%$aSf}2ro78^"$,]RkP[9Pung)?$v}Dz	>>d{_~31q*wU]5<IA_VGM%XRVYY$tVB$1YPS>Y~>Sp}@Q!<}r$xF_E~bG4 fC&i#.I-8~QEJLB.EMQf'3(mX_[.rPVZ9(j7#._rW` L|:mH,VPKsA;4k]mw3XA\?	R=;SHfj<{E	\/UdDcy<5fPetDNN5@O|<`x4BC>.#,3#,1T#,mJ+Q<B*DaZ%]JT5zzkb|hK~HX<Y;o<[q0K'&}#	cHij5d!lYi{{P62w#s^C}|9&v{soP,Hr;T~fJx7O6f.c=YVidhc#8Zf[x5TPf<d"563#.s1crj)CL[liFyjCKFq4hQSRJbkXXamLWVMCLGgK$)Ci{B@[i33prdI<>."XWS2KlXh+=z)3^sMPanadXOrf+%gQM&afh&32waO15bD?5#.p5;5|[*!i$L]?a+av.c;M q":Fx_/j# F(!KKK#,15c{h!T>n](8aA(O	%4HPWblX}s{2-7a{yiNozD"MG}<9Wxez-Y}^F{q\4(dtmse?3$'p'IRa,>5Nzc$&Nc=4gL$s)wH{3#.Y+'OaCfH'KMutcD$uXBcMQf:v(`f'YJWB&2 $#,pz(2`#8.&xHqDZIiTz&TUo&wVl!2(5566j<sL[3L,		rm14i&:=MLt 	2m9|zr&O(q`:mNK%5&G8NB\]pl/aEjtSi8kk5-m1fuDN!\('9=$o	Fe3RB#O<SS)*$Ye	my1ss4tt4&E 1J	%S"ML=Bv)>4:3pDk#\bBek/Y2	#.Q*/H%\@")?/pnMV)nepOVRQ9B&PXrOs5mif)!z33ule|[t<#.LqMe$<2UHYr1sYk5Fa[Y_LQwCqcm"3Q7.xMdpN\RX[md\r^rVpm5\[KbR#3uUauVfe2ts'htX<dcIIU8%5B.,ycY,spNK"j*:H"04KIOWctkW[#.:uN|Xvv,UraEJl7jFM8=7"aN+a$ R`hE8(jfE]0KM;,a\1f3x<kO,fN9Vg6j#,A`hH{ ^K,=MQp6#8$-[,8i6^p0qjnybXoT;p'f)|0Q}a:&R<Nv	dvl'u2)l< \82u#g6ejSL&XwaV;VS*Ff&V@#.e53Al2biA-Rr:VS%f[y$C"si$1g$m)&.#J&lfUVFhD[\ SPOJbx](NbDLlK306eq=Fy\mC D0i/WgvLs#.dx/qrmB\X9|scrDcC#C8-AoncF9K;J`V#:S1/_%cpxCjt3p&,!:0O#qA<\a=lg~4eui7NA*HMNi]s#.24I10b0[x'VD:jl<H&`kUDUT6^H[.UYuR1HH%(!u@(Uhu#.:ni`p(1PK"#.,G:zyYlo#auR"C%r9J2s991^hG!TuNg')P0#.N#.:{ev+#.!h2\f$#.D'[:38	4H6GP,vL3lp$l6Yoci04%_z3h#](etfC`v#t%SbB&%12*GE:%=:z?i(29O#.]CzU8UIH4	Y#,'<GJSc}97$L5:L&$-!bG`@RyB9'q t9|UI>#.>Z7>Zl9'Y3h(kFwe]vpa!^$ ;R0:<~A+Nh`sf};.sDMA);!9w;#.sOmd'R=hv=p!&L#@CG@/gP;]#,@Av^H1!Z"NElt]\xGCS8Q#,:~!d~#3#,i30 (1B< A "/'zTAP#.@;=r!;1w0J|,!?j3zSp]L?qEvx?_1gX5.8<ypuI"$Dd#,dD6x	eL{m-$M1(oP*(,HX"f^F=2q!gaLxB1kt_xiI),Z+hcQfRAH4<GR}psh>3wWx'#,=0s="B%m"`J$i2rDu'MpwOk[HdZd`A%#Pi~#8sE}9`BD;<W 4B#u(`1!`(d&9v#i,m`x&4e*b	P5j^3	mcw*X9#~-\{&j`_04y'ngh<wUbZ5{lLUitHd#oZ.Guf6(l]Tt(6jL.!^#d&Y	c{z{?=H=Oc#.Z"5	1`b+hl&Mi2DRqhAC!am[|m6J]wl63`o\*'*##	q]rgRrE0:/6(.""Cz#.H%ka!mIdfPf,u97W08f67FB]N'.Ne[V>PZ#8`LvI>#.`ArH85VM=\)kb9kfmwtbR`ZFPfvao7DqJ	.q=H|oLhH.46gC.d1K!SKQ#.2&H$7@t j*(;=<:^}<0@WH	 kpqlZ_+E'jJ>(?Ib -&)2k26  714+cf	?#844J1#8(B{ a)"/?#.{pfa\XSxz_^++W8@-i%r(kbz'#.gxy4TKvvnt0Vj1DI[#w0cb%#.LE"s"'$j#8tzP2M9?F#.7"p0eCDh:o63it6Bb~8#.JwOXIBU8DFf.I8t9YuNT4<lcks9.MRYTd%j+tf1nQ^t<&mC`{YRP@2`XNgTJhWXfDxp]kajQZ# LRd	{mrTuTq@$#.<`AGSCD<$tf;O8hX4fh)!_nif1q+V2S$nYGcD9!mh]	&DX3LhjAKAF!!g#NaN2$,f6dTu-t$HfYP.Q!F0X[kBTUH '`_kBlBn;0 y1A.#.I%M#,xD0\/GQh>\wDLl~O.$ra08N'8(/'`;4zu]#!I*jX*I4SUqN"&J8BFbiVS#8v#,Flcs]	afs4_]dA/?$	eH*Kw1wWq1KP#,#,\f"dKkMOK3VK7G+?^##8]4A`-Pc"@	Qg>z#pYl/'8.h3Rs<VkZ	.cB~$@$TI@#,}~gf}g[!>QZ*iXA?Q/RuaTbfImE%!pt)$0*HieJdilg]%7f6hKm'8*$JmBoivWL66F*U~#8uw6I(IJmKZiXeRMMmMYBfFR'{ixeLT#.5xcYm#mbJVTz~e\T+$3k`V_^#.]azn)$(tQ9Lp>WEi1.)c%4%fc1!@#V"U!R'3RiJL#,;(qN!$QE Y$N2 a<*HJd9h%pZ%iU3CJJCE9`hGT*s%#,(bU!g1DJ 	TIY&QDR*0&ZZJR4J5&ll4ehl&I,kMh**RMjRZFVm4,	)1lI$%K5fQdHX&IZk&M	D0(D 'ZVZY"4sP2#,SfDhU(	P$TO$u/viSIy!-SQ+h#,D@@toas7}qgTM1V{}A;IY%{6/Z9 Cnz (F+xwc]:k(&chdN(Rb]]5I1:Rl2a%FCy#.	3$i#.rqb_N=_#8o`'BOy|xohbygzDO^t	I}`}"b"CJqvlGKRZ)Xe,	B4u}CGV%sdGCu47;5JPT_r0~5NKO*C(Olk8mbh`Vswdj*S#8ps>b&e*cAZvt`d:;!#.lUU,ZH yw#,l[bF#.5w]W!YVn6)`)+AN]}7)%>.D<L(q!#,p\4{kw}cMMSY>$@lDD#,R#,pM5P`P9u#+  A0@M@nO$dbl#8irJto]OyLEBvP?n[4(YIycZb@mZ#.xjIZ)dX;N%8ah6cA1^XEXAZ(lL2!10#CuZ<qId!jLF;p9#,r7~=kXy7h#,$pv!igz@&yU%	*U0hOVOr`0HT%zl)O^3pg#8*#.`*NvoV@Nl{zC+]6ir>}*_G7<Gd /#<#T{# <ELc<YSAVD$KU#.-yo#8oufC5;1CBc&%!%eK}otc0+Xm	DB#O|3)X;4W93l#8Wx$sfCRSNwo	/C'UXM7NR*ZO"?k'#..0J&613M1"IdL!IIJPL1X#81(3u=Mn`pyr-1EA,'g}G@4&2qt5d&.sj#.&39)#8N~ D=\MoIj&JT6q @J"8#.k8J&&M1@eFB!soH}s )y/;#8h<3)V@#,`e+gZNC}8LRv5NecMtB;DtP;qEqYjn ddB1hkm0,01Zx>lbUt#5Gkq=<''#.1=Td:6;NB<hrf]J!KuU]CmFop#.E$&}_;WKu=<T	iix#h#edel%&d$HVBI67`UQTUT5bgl[R3l\O$e6G#Ky>z'WWwnb)U*w#[mp,gOcFZp<J#,&tGR++#,%5w+|#QB,&a#8C|C|:qDvy(f"iF2_@U&jU,/cr4zv,Nb5fK&dEZw}#.AmCd0"%:D1#,LccjMJxwn)	#K0"Fb #.&0nz~fu^O~y!#,{@q)#81#.x`L7("O_vdlmt3[<dK<B(ST34m(5j\M5+EhB SKE(R #.hMNH0RVh,)hTi43Q3rPmini75@!	M\a	d~l7IC3e 7u CYpX26"#8a&{#+@H7#8	a9'Wd=E& )}a5)d uteQ;UO5M"'5CM NnBCbnm5ri(H#8#8Ua]rhLjy6ab<#8cvoTh(E$4 cH"'KAP'q'./#,7AnT!7}8#,8pY4QS bD"$*?}x"nC&gC5gH#8	J%t/7e#M#.;xe<^#8.#.C~A@TT$<9vT7]keu~!x4Y&Qow/OJ@{=P"zTiPX$LA4b:4	#-HV.OMq\q51ffE]u-lZZe!~xPf2Rv 02!>	`{NBh73;J	%^F5>EU#.k+Nu|KRgp,qD#8#,b9-77YPPfm};YJiCg #$Ab1`N6;^#,1TXUJmfX~Ha&=#.fAbUS?v(`R2!s)Pm: `A(GXD )hNX"@^xpu6ltt`7l8`F%AFL+:Ik"X#s#x,s6b+jyQ!6dcd3mz'$-`(PA}#,j9iG147)]"F1mPPRo:!#.IKD%+mD!0!	-&[kc++hnZ@!0,o@mV8aZ,M(`NY%G]C[66E\J\/bLWK.MD5Q5L2&@QHf#.2FV(\i\_&Q@#.Xt0 8Z]m@hcB(ky|:4C &`@u^69'B;^v1boqBfV08`$g?lC?]j?;c6b<QGu#.,#@RiQ*)0^-mQEU`@- 8+HaPJPi;zCC4;s%H.#}qG9*#,<h$T`bCEhvA#.3i!WFeD:%B%0(	x	*$DOE}JG>H IO!#8xCd-#,nf8/yK%lR,rR=b#8%lz65{]#l`(2@,I3mEZii/o~mih#,UHBUXSD?kkLPT9)g8!IJ8\@%#.7-(tJxM|#,=Nq0#qOn=#.]	/PHq`>S{8C'~~FIFD-IGTmoF&*[	h\~:pik#8x\I29}@8mv;lp8fzP#0qs(") )MV6{-YORYH2J_9$%WsY|9_ !	WA8\&4)VeswgUgxnqcb&CF`4N.G|G1X[#,8;e5JC<7`touH%gd15ibw A8=10 lh@i>%zV!UVx$$'Oy.d_u#^F;fl Q<$iI+,E5!4pl sW36;HM`[#JtK91dn}9In&LPA&e8FQ9``j[1cF}TvLm #,\geO{&h8$vL+;okK&|<~0H|]MdA''#.tBb5e#jJ2YRlVF!M}]I2ZY#eEJVTS[YZJmfM[(646A@~1'?IuZD<]#,CSrAD@B@LMT6?JB]CO#	V09EEaD%zu,JCz&CPC0!H _>ApC'A,D>h]<f60qO?H)C	L#,r3taM~rz 0AL >v!mb>1s\$YNmv`%!ugW GwT!7$=6*a_#&&K:)3bd%#bC>yPOZ8>(#8xbwj2jrd$'1#,I8IZs5((i.jVY	f17Z$ei:B0`;?.{|~`&VMtU}}}#8h^0mFiA	5#8<mkH(7oH	#,62mo,LMrdL"c4&&'J`aOS;]HW(+^EO;/NaIDhP,q#,iHQ!mj4@bil 6"0-T	~albc{dhzpr20HFvA"A9l(0Mjqo'Ssa-6tt)T8F4d#l#8ooynbN[B; S^yIzRX&)N:L#462`%Dpa5#84MK#,LfuN AX%PXqsD`w<O>$)X&##DHI0 P4fD{O Ohh9|8z|6Ty@A2$P@]XL6z}356`p'`aU!#,HCX<6	F&`_phH^#.IUsLjF`}q<2P#8AaZL+6t#8R)yK:Mfg9	Umv"(a~w*f.P7M|"$D0BP:e#8:R#|-0"`[?{"8%Rrf5"^(I\+(*|"JaFbD,EKb'yw' #s|M/3BGDpcBI.#,1jq3{Pd-*Eqc$F9$fE! Q~OF%ltd	Cwh*TtuiM3fh3;#au&#VEx`KX`.%,J~F8ju#.a.j#.mr8pCY{LI0KewvsX6?K8JF Vd!GI"L8`IK iA'pt+y*(ov/~V#,g=ga|I}"H<#.;R%@{xG)O^rt9YnBZ#,/sA.gOO,AOPCn Bg_CrN`2"8a^`l&Wt3V)D@,JD8AH(hLL4wc\	d 233	A"^'5)XcHMH1>-~n9V7t\-2B2ft(Pti2j"-(#.ieXly4{H2^\4J[Z{#.Pi%$AF6mH$/#,5_hhW41`EP#. oM#8SB:v0~PzSw)OUKEE!3:#8Mn.rOa'$|k"j#,J^?X6Lz <#. {_D"#Y+bebV)) NdTa{_`j#,#,*];Swi>h}'CH/\a2XTq6yaR8~f*6VraakgcZ{mqG#"Ph^/'x_nik]i v$n{8P";Og3MB#	&Ms>tc3YK#	$	k#6t#8e6-h#8~E/A!~v7#szv:E@c<=)|0LqkDmVoi(ttzdHKH}t!_I$/{:xS`O~_^/dXp,.f{v7#8Y=Y	=@:syeSZ?/*>46Hx nvOC@fjS#8#,CBlo1#.<kqLUQ Gt"e'N d VkZhJ3rJ"S][QTRq/x#mTH/\Fw/)"(kbbRDm+Q"H0n 'bL#.#88H BA;{`JFiNZQD7zx#.}l8)$NKh2%0@:@	:A#,+>xf.8#\Lv!=G-qx::7'#.A$T4tZ r'N>xP]@z#.[&Ly_wx8aGEJ5fr&U2C11$ K@hVI0Q9H*=,0R4*16#.xxC>?R1fLVH$pc|Rl<3i>l )uLf!`wKrp&w%(5A[Tl3Wca+43@4jv#.YY)Ai$|#,3u,#> v^#.OWHvu#,} N,b3xUgJ)v`n|GtB?+0n~z^LC:bHGk#.nmsP8rI~X(RTkQlIp])D9M9("60d!a`5t=j\h6#, -@80r$0?KP UR.(ABN~/Ml]:p{9GR#.u*#8+?#.WMIO1R}1oTL6aKaB!{HSz#,|d.yP5,C&#.##,;Km&4X#v2onkJGJ#.;~gc^(iNK#,	Ip`JK-7%D#[5ht,d4qv4tC@I6UOfapma+`Z4}Pt2H;i!>$ak";t~?9($11#,x3DG88Ta)iF)g1r5)B#.4Fmlh&5Im1#. d#8\L#bZp	KxV(#8*Do/&=YX#,.z,zW1G<X~9s{}n}Tv#8&$$LwX2H0q/1~B}G; 1!$DB@3c<<sO#,tjoZ80T%/Y0d:bkHR5JTP;mF[#,ZW?j5D`~{S7;M(T&n958G{}uGfY!!g#8#8IP: SV\R40SC2% ?J; p_dM,M"uF68|3xbED6Z*!Pvgu?9#.ve00,ayH"@5d"{^rQ=+PXr~fqj*"a,$&='4u(uUEwdzzbvK4QH0B%1b,TX	1=P8Kw9w8`/#mZLK}f1T*]h3#8hanMqh5( #.I$CI) N-aE.-nVbhbd.~7YEELdZ"1	FC817e-yDh4,Q8I1114f		HJ#).5}	[q[HHKFe-:odRs F-F6LQ4Ylp(^FfH*'}fYkSuLMAZhS1RHifhLlyv&W$n4Y-`eTN87	$#8mF#.q*(2U]1S&b+"4V	V#.#DPh<OOVaRC^[nLL6UZ,F4-OA2m67#T]YfcSHIQj	#.kKix X6`%-dbR#%e78Jnd@L#i8[Vex(LCF[K"LI+,n`f8SJ1f;h1o8R7ce3 NqC67v:V#8`kckR"`il(A`=mEA8>d:Li,k<|1dhq>V%#.U76puh8`pf7bU6xbR`JQ/wA~s)L8KfFL}W{YI,ya}\5}:xcPx|XWLgF*0&TH`L0@Y&#8LJnoY!&sYlJU*PSF,aSqMmaRq#.i?l6kzt;C1+pVoMJ>y#.!M!9DT#.	D0p%R0e``0:B$aD	&V|;a&O<~|PND	Cs,8Eiqu#,TG/7EX=)4LvzdJ.xsQlMHzs4<5mr\zoWI\8!VxWd2MzzJ7f"Hr6oF6q8hPh,C#Cdqm$G/K0"HWU,so`r#..#.k$/9:"Hd.8=>ug^H9!^h546p}(j&X&:D!zwR;cPo{~pX#8KKpSh8}@|?}{	4-L>[rc	&:M#,H#8Pn`^F#8(rI:-R:@0tIwXNwndNv[E<2Y-sNR]).h(E@	X0 oMcl#5%bGP*1#,&##,aSZ@/}BLlc&p*CQQd)u6&J!`#.#.&O}qj 0AZ2-Hj(13M*-lh-AF4Rl2`U,QV@F^u#8{\:>.*oS[^zIZ "M/yv{]9E<S9]6uACU!!$DRuY=NW=[lzlYFwvu\rr*6bdd8(#!AM#,8~:G:\cMHGEB4&C%PL#HD<uUP$r&=uBbfy[`'dMy+1rJ<}lOvK8.OED.`*DTE7 C<`lyGg#.k6Ws$PcHJd4I42G8Q/kJ!Squ?J&5K5/s`*c[!'Jcew!LY/6s#g|!E]c;-DV2jCDM@x*EIULK#86}Nup;vqXRL)+jbIXaCl$E;`~Q%#8@]$MIlQ@.)X#84ku`#.@i4 .y^#YLFl %P+LHD#r0cJnSn|n~6%*"=TJ*DK*$)x"di2-4Ie!FN#8sZ8&.6ZA$aVL#.q4cji3*4Harb}[khf	($I!>t(#,x{=pz"Yr7ksR2qeq9> o1sn\< `	$pP*zMQ5UD'#.GpIg.?9x:Cm?=?Q?rak9a_o%]spFC)#8">Tw^c5#6:;7S6r^5[}tt*@"h!4K;'Dpw--Bd8"#.Vi C9@MmmK2UcBbFPmg%&:alm	T^v3@[F&$2i6+S|WU:sQ)k6#.8CyAE !0n"#J0KgOl}{`mEVcc5#.:?~3KJA4;c.ZiG]/!)F^n+6lM6WiM(l`%\]G:+Hoy*ieew,4c@%B`9Z5R-6edXsWvgKrE-\-FV)+R8B~:U^4*>0z`zQ!(~`@yB2e#,D&2& =*vm)A;#,>J@gqOSTF*O'Q|#,h#.#3W@!LDCH(!&dS'LTYNWe%FRj)jQ$L`P}		h#.vF]K))#8js"s:&VHkZsR#}&#8'"7ul4E&I#.J!:G-){P&PEAC(0qImA88A#/#.sx1O3{6HpF#,",L4&Ow>n8A#,PK%HH$!*I	[N*"V@ebba#8UZ$P<}dCA'l1Vc`Y#8CX{qz>xlCbNgPXq%*9#,qctsuO_		`31$q N`A( U`7i)_;E "NpB<3#8`v#,ZJ?COh 1Z(QF`)iNPh130w8%" ?Rn0Fi&*6%D%u#,Vk1Wv46SxMR[#tHF#,Z7lV[sVxT;u*i#,xd	xG W+@XiF`,)X ^BH*#BR!Cvr5x#,JN!HBO~%0PgZsQMhO%2,P#)P&`@Hj%"KH?M}zd@.(>#8xIA2AX.@a9JyOK$Arv<dN)O'})eb^=P4muBUZD[D MtgAli5G-fI$e!&SMj"md	$iuj<jf6Rb!ihC9w>CQ#8#8i{NGl#.	@?0P)Iws&b@aT@JvY?tt%Cy#,SFhK#.2`B>s[KI&o#,"?orr\H~BAD$T5H4#EH&I	#.>8W:.(+Tl8~aiEYYv]2`438G#,HhTw[ru+z#.y7{698}sLo#/zif3`bh#,Dp#,(ajYj$o!B>ajQ>,6bwqBpn0YG'.yYq-9nalU:a~Dy~*q'i#.:vmlVk'59	($"H9Mc9d4id<$I7bk=i4bcEAdy5#.;~\(tBdUe&fRviKl:s`kR8),O9@#.3]6xmX]>[i-MCvNC<yk#.gFa	Cc&eFFt6r'HH<J#TBlK=>r}q^i%I5$rP2!._g	TF/'#.`r@@hWI"0/KAzPLlX,0%=/X4#NbR!zN1O/nEa!tPZvivrcr<Y6Yu>LFI51jF/ebL#Pf-)gV\jW!=srcn-f)	&u<^>/>f36&drefn|e#8n{948+:0WJFiF]B,0bPJ#8`c"oF5R=qU@#SMio?~3]#89#|CH%y9N#8Lq{`DZFNhP!*	?I$v#8 %3A@6RJ{@?5_Cw#.d	iH? A#8$TJVi$6AA;2>z>8#.%Tp}#l=4<1}$		<;I3	z'C8[g#,< 99je:41#8);P+A'**3Eu"k@rA>lgyn~DWgIp=5"#=C:mta&@uoFV$#,cM+	.1k_.}L-Qa1om-CEV_~PlH@#hy:=;_^	BzGWI[o4k3>Vg\6Cq(/W9pMC=:xd;a2 1o_:Pl;RVwC|2!D}X	8Hx<pi!bba+cUobL$dlV#,H;		ES#,/]bU^wsq&8 hb5~5QH;9-tXLMy"%f%!!%qI(mIdCB:agg#.~%FA}_az/	9-	)cL^m(J-B!Jzg4~GBuwF4C9Zb/:<3("YR15AI"4dhRRl6$f!?2t#.x{w7s~)I&jPrcl4&L7)5,k7yRi:P84N/<1M<R6TEYy#.Y-q'T1,$#8_bf76T!uE'c'@szv^}J0Ki	IvO;?Iv*P"2COXjl8L_;!PvO FD	E%S)JM8 0g	bGIBP)}fw<jzW6w\yD[JQ6"3(jc"@H#,0Za$O}#8H%#,#WUDhem%$jC#,#,ce|CauD.!@:D\3FTZe'F\\1HM3ML+?iz,8tD3 NS/:kz)\Q2J5V@s1;nV_	p74:q2L5*&rf2tEEjI6B*-"@#jH-I&#8~Bpb,vf3Np#A$A,#86PjNUiJZcL-9V@Jpci6T0Lx7&j0#Uo`L:{R	JE`zd[t1cltji1mfEw{F1Nglc0mb)JVV,!Y$vS >)5im-c&]T'Db#)VG,5k0-XD#.WK1a#d3Lpxc$*qf6K%r#J0+:81`KVQM*-(	s|r6nm#,5B`kHgTNrH4&)bvFqV"L"["8oR(62dX!X-8`'}UfsA<1#.dN"Y&4rm1At9`:UDn,fzMAJ@!s(4[TCd|E=5WayQ]}nXP%!KoXETBb8Oer{|k1@l@m2"ijcwN#,#.(F:SDD4b#8sP#8$,IQAdT01Cp#.cw )JCtp141_[;xw#8~%o';%g7R@AP,11 #8D?H?;g}W#!Lzl~oU%Pr(#.Hd!7'	}TD@#*azDG->U,<GJYPRU)l@sQ%y&RReAVHRR',3014aY% gHQ6LlN1CZFP 0'[(Vszk[(N0g#,>#.}iKU"`<V[feK.i!f}#./=IEfUJQ@v=mS@2_q>[|HW"|dB9Oex(SP'gg|OZj'	~?r}$dhxC	dJ W^gu?8^X<t}>mB#,!D:Xt`D-7?G)>XqXVO1	L;%0R!_<kRCi<CrHh`>#8d!$ZppyT<~z:P5,xX!#zh$b>GI(QeTZ\*{iqF$5sUHa]k<ntcBABu*,:;_%WHi{~m7,bT&U~[\G7p"ir%L22PE&E#.+SAHh?ki7e-Y!.K<Hl)|R^J@X	CDQ#,=	MnO_fgNxfc /^'T?)ec</]LEQ!`,-Oq1(IBHL"3#,>#,ul#2A!#,h@TES%jMNlduI*:i54[m_=Pra* >>!4h<i@P74vxtw0jN6#,:~?	C$x^x<L2t(#H$~ym_3dRhhllQ%$4RP)QPPL(i6i$Wcl)#8R#8x0b*O*A78cx#,FF*"42Hic0#8#+#,m1ZD*Fn%(8@"#,!nayT,o|t SQ!j:z#CU	"FiYcB$h~m<xK~V<QJ#,(HCOPP;lM?D`KC 7&1\Xh%D)YwYcif#.u?4OBO;In#R/OU!YQ8&9v6;,TVccH#.3)$^^i|{YW;*$s{6Z#.6(}SUHEt/#8jax4gN?glr;H8g6q4#8d{B6!lkV#.kBv4~x#gKw8%bPS~54>O:O >0<<v,uSMILsj<4d)	:SJ-^|xXqMdUK7/m|m#,07s]g>u8~8]?4wO#:eG.?}NGj5j?(*fOIT/-B=7AKjbM,/%1	#.;hu+ TNqPMW`BD:Kd,F#8Xdu/(E	[X @ipE#%'`R#8bRY#,$w0iQE\s=)k1(-\K /4[Jt"E:qPnK8%KG=!q,4;#.=Y"7Obi+FAD7}9R 6Q(#5G,l=GP8VsW5+iXtLF@#.xzk}"r?`zxcc$e	<*>gx 79R`g:1LN.M7o/+6kSidh10N83b+2zFy he%m~)".^#8)vxG4i/I_l1r!u!!mi9@y"jn=P:mDR]:1rZ&|Fd:j\i)z^`qqdRg\`fdwq=OYzz^RxR<^8<Kht<(,KR|(u0yWjBN#{gsu,3\^^h]{_yrvuc_tf3z<|~gv"r%vd%m(!&Y\J&v^(mFm<92l7BZQ<;<xCC#(Q(ioY|V1fJetrF{h5ICf7IAwBI'C_^z#.MS7&#79@F4+ku]Tnh@i8yD#54$Ns&@Cigu`}!ntt<<w* t0?m/*a76tp$l=?bOP	a(	SX_~q#8z]L64w#e3S@>KPUN/tt]R#8hX!<W^*ijqadR,(?ZL~9RpY8.-;Mu)Ia![f:*F)hQB(J"jiQAELM=n#z +}i206n#8vGSvy1E~P|H$Qcg"kh|W|A|ToMZ-M]JkZ-8hQ:9>'}Vm_e<Eq(pUI29s83B8e+#.l{0>btDG a1t!bP+y Xgx	1(G	$K8vin=hYR9x#.?{s_z;F`os\WiIU_P`|57u%8`yofxs$#.#.)=]4 /SK#,}2ad7gQMW^S@lg#8" 1PBI7,hty;7~Gvk$G>x$O[&Q^(*#,Tj@be #.C[qW>bw#8&DOM#.FAz#,6(4UUNO$cDa<igHtYJno<14!#."x_M@#KB\Q4uDNq;j=:h2`1#,YFw {KTiYIKQ#,}M@E;;A#.+3#"!.5fAu}.j#.+`A`)"5;_M1|/&5~a)U0Bsb//9xNcs34?;*>76jZ	2hM\KIIXI@H6S Jc#,&6UN^.<lCF*j@[XiGh(QE#.XH `k#.@1Q4(TQ3`oo3q'4-A h-AQOceuY	)Q)U)#,")v1qfs5[-NU1K+tPd/i;k7Z1D(/SgMiq<5&DZHRUe!)T(|T0"DL*f6!]3MEI+ry8<#m[o\vQl(PCii#M.RC]!pbVp#815)Vsor3SFIkZn$aX:5lLlffhh8r"b@C[emi4FL16,[l2L-~[Z9	choF[I]7hNrduZ-T}mBR#s[#.+&J^h87	R vZ'`N7N8WaCNRdBL*ljq^TskBiJcjmUJahJhpM6o7LY]9fn]>t#.Rux1qkd54Eajn=]q,hkaxpJ^{BaM\z$*7{km&3#.NF4R+(eJV4U5yp(DVUqchZ9rb3j:wkq3NUm!4@;FZy2>EJ=a#L{AV#pkXcM ANxe)$\d#3$d6fn%Dh4pLA2puV,&rTdBF|S9X:)#.@jACYg!yte)6m1Y"#8;k$5F9@7g@	/DWzbQe,F,"aC|i<sD-g-h)UqQJ47ef?gVa!#,Ce^&)(v ~GgXQ]Vz< SU0{sR<ykmm9'&]7w=<vO{G xt#.8B[HQHyLAnNE"*D$L#R3Cy{8GqN}^}01Uchd11"j%IB3V)l%Z%#8)h3hSM&(e$$iED%$),J-$l(l%(I1h k>Jnb#,ubhuI0Nz9R=:79vx7{Jny@Y.#8k`>jG.#,U	>zM,^&%#.H)#.s>r(%T)Nzs)=^p16$E>#8`!p~$'<=ja5"qy':a4*@[`|<	B#8b5Ik>j+65(Rj4cV#>hB4`f#lxLLp0}4j'>3.o.=pI*b\Cjr]J82V)#h`=0&Vi F#&[D;,4f8TEo#.2SLc.FH4F(,I @+p`vs!V#8U(X"B!y6Yi>	&|-| +T.8F(HR:f`h~3b3R,=$4.R'}D[^0|@eh!U)F#8((4=!`$06fMUT#,ODCN|p.:S[#8<#,vn&d$F* baZL5&b}^ 8:	UDBdi7M1]k8}d }NJ`^Z"yvgV~>8sS%Uf|O+!NKY`8XGBLJBT897A(xHXK<Q(&Lqb#8'O@`&PgX#,/bx',:>gtQHh{Qmd:<DPj#,K!<g?I*U#8Ya?O3:zN!~H	#8#.#.OC(1Xr#8g/M;#nn_oJOg;#R5%#,E}Q/1/5TPtxa)=?Nq4\Y86o^,WM1t0v;#!%A1u>?|==.N1(pf%P Isssnd[wofR!IxH]vutD1<+;K"Y0Sb!#8ER:M#,T/UhX2	JfA4i#},PPXew9.OHw;=o.;!#8n9xh5FllqLvav=N:4#$dB<z5#.#8JDI9'$W#,Ds$ @='C#.1hHSZ`g#.YS@@^>[9>Ici%Csjl|xNAJI#8 CAt^>&N,D255[gMiP'd( <c0l}+6d 95qOkW#,Hg7.Yp)i"erL<.;b*qwk&S6cJ:-v.	K)3>=`&je@x|!p0aE5+aAH"h&Lb8#,#.06x*tZBB<bxM*RQQhusGn++22<x1W	4"sXvWd@a=Ux"mje3ZL0r[Ndv`;4b[OA9SZlGKFu#,AmL\ST u\(fBRV=Ngn&M	LG,8q)i#.&@V$lJoiw)fKnI;&vt[!mi8C#8}j#;;#8.LUD<jl$3*g[4`I,EdhFz<JyXa8\Xl[wO 9W4&='N:h5e.W*0LK<j@G@:B"Yr-Yb1OKvv&?grvrE]Mt@b(nH&l3ytg5Ie{Ctc,N5i!>Yp}vr#8{g7FS.$xr8p)P]v6*,E%T`w@t%o&!j$NTU#,t[;I+0MDCzsr1#.C](via1IE$[`xw4m'GAu3i#4~~9&0sNB1-yj?Wu[yX}D&C@!lyy,<utcf)>pLkgYie;e/AR/6XZLS&3m!$td,jm0}V:<u#,VKnj&IE`+d{HI[:lCs8!-euVR!i$48'3:t0o0NG	y{h#8,LMM4X&!U2\.U3v.uJb.wdO>LAF"=!eC8L(]Ko*%4ps&o%89-/N.])r71 q<D(#8haxg8#.&t5$bbf}G#.2HQB${*xPQ*5MdnZ2309,6cAQM#aP 74j.hM{4;0Ix8Vco5laT5`#3,UDE!$DP#DS*vB]%"#8#7e#aV0l@odAP07XZEW-rhg"Bb0uu40UF`uPPW&0J"89q`y3b<Sknh4@H*~w~FT"0"vDT(rOHJhwi G;#,";2CB.Vx@hZUBQ)i}LntPicZ0T1`aKw2[[<IhGumDxjfyvaM	48~0_| Pqdjk	hl3#,)<>04T#D;uYih\QQ'{Q8rAg24T,M1vdV}&2wvsV<z;Gss"'8+' }y6sk9lQK[\5o*g~*!>#.:awtXiZ=}H HZCp>\	D QO;3#,+4,p\	OY]-@TRdjzR[$2IEMN[J.Lpd!1qHU2C.w6G#H{PSE*k5$KLa*vmP`<;	{}>7gGZ@~E	8^NWFFoAM:Fd6#s#.fdD3B#.J1a^$P~@O(w6SbNsd4h21eWd/?q"p3B`8M%,0yIjFoefhftJi};.^vs0h<`E7/RQ}I7h&z(mZteYDIJ>Y3uv81T&!3B9j$6{p"V!!#8@7^#8H#,^pPCj#.9h#,#8AJJ`BH"yA/pMh#._Z#,#,'sgWmt=z#8{#.cRX)(9:GKVT?a#,(ANk-OSQ`X$P@7FnO6kdB;hnlnp4Q#$F 6ULb&FM48*r R14$4iB`LH76	uHaCZW:v8`x'|'qNYEYxkP53ikH	"!LC17GOP:NzP6=% @]t9$$~)rX\q2&QowhLJG-a89	Jp{WW1!p`Dy`nn8g%qpgO$K[7n,jRc[F^66yzxv!AocO{J>tPx{66MefjLe1JPZa&*[16ol#8){f#.@BSHl@=G#^>dl	K@qcp<@3A>J3Q9#8"#.6Ucxwa|+2LY5[#,7hmNCM;h;;&p57M'MHrKDMUAUJ,pw$HI4io#.q3yf8Ci u&mJD !JafCZ#,S]X&hZ9#e]c;_ZA4	iZL TkAh`kZRl-6>`n9Hd<3&5Hz"l#"D#8gyhpwJad}PR#,+,#,y"(=S>&sOgm%V<"OBQVhQ+#,(dCPA*x^WN93l^7pSD"38XmV#%G+#,{';w?@Ujx#, %)OM."H-u, <P0:UR/4D	#&3#TF4i2$"nWJV4qT!R$CQw5"jnkJd(#*q%;`q>$~}Ffo f|wyxx2(JJ#8>@N_tZ%K#8E0D,BLQbjYPL#8y,J"u'KH,\dllT#D=ANcdScXVXFV2S(X1=y-$BP3eD K@z?N~ZB'=N#.Jw#,~\p	q#.ERDzAx8z6	>|xIfPBDbPY?"<>bHar0CGO`Chs)\ ((_E8\5Sv6jYHBX88&SsA|mxjZs]Tv`MJ@D1q<NFD/82CL9\#84zs881&gvjZ:R\LZ.#8;@N#,]rxF?8}9/9lx'U0`{UI}3e)&az_ChJV$*_FaL_9P,P)	iBNu#8 DAu@x~3{:@%SmF5(j	)FB!:67)?Z2#,rD@%1gv}Q9h+J[OG[3"I*bc;(:\J0X<54ReBi+Rf#,2 (tYvm^]Di*A0A-#tkaN#8U" QQ"^\ESKe5&L&55-)2L#&3!p0aB!I#8tM2P6G,aM	>]nj7mT2@%CYW[FhL*&iI#.NhTrhEd<'?C#,|s;g>Yn76)uF[q!n|xxO-21&=H8_	b5i(L=r062Eq\K^sU7 (Ba043UwX{(#.r# P3>`.rp|Mp: "HN \Jaw& bsnd"SJju)L1_#8q#,2qT8c{:y!/ZFxy"{DqfkLZI-!q>	lPpBM#.d>><|t"9I[_@_X{]GG ]l~u>	E#.#.{d`( Z ^Dh}8|L 2~K"=!;'bUj[pC'Ypi+_iVo7#8^,Lw#."+iKc/Epw:B/}+`'1Grhw6L#.`Cs2u4hS%9AQg"E<x#.OQh!jiB4x6zK2l@`v$#,DbLP_'GA}#,<6"<gN	w HO"?"5~n@OD?#.`33@ f#,#,>c?k~>/g=?O?{OO?~OT~UOP<}Dy( p.lzE;zp'E?lF$y"yWs$"&f\l3#,0zf#.49AFqdTP<N6byzA08oR3J1C-_;<b	%*W):xdD'=COgJph#.`Q&#.\,	o2n7*jHF6548CeC*`6v!To{x2x@'gtne!uDtChE5k<|9f+DqUX:.6&VK	&kPjUNqkddrkMou'T:s9?6>,{FVCFE|Z/!H?,t!fwY=W0+<S3x"S#.v!hcyx[z32a_%dHbO3Tx$c`3pe<#.ax	)XzOvt+F<3PEATV*AB9wt!=\&	KNR" D=z#8*#,#8II#lCLxaT1Ap}	bfp>p6#.##,IF l#k_ssIkiA&5#8n-M&Ulk3X"d)<!P~!xleRu$Dji{kol}o`v{!{8#*JP9x-"#A==	K!~::nI!ZW,7Qn2Fx3;{ #9cv`Ny@li#,1OLx?g4,,lU4xgxUG>n?~zx37A`|kInbh#8M]7((Jd o:3mh`nE	#.#.!!A?!=!L5y{ZXK"hD}Z}l}.!>?#8^">{=bO;>YUe\+2Y@b&I0CBe"O1dQoJlvB%#?=NH&>43/8{OO#.'~xw~xTaB%-40JJXU#O''aH^G}+y!aw)gt<cR'=>`9	GK^9$~ONOh[kv`#.7P7B_;p=vbkP\xUL\e|!ttYX+XhTK^V99+!jEw#.AJ;e1	oQ#,jH)KU?s|b\Q$B	@+k!b{0?.p!qS
+#<==
diff -ruN MUMPS_5.1.2/waftools/ext_aster.py mumps-5.1.2-aster7/waftools/ext_aster.py
--- MUMPS_5.1.2/waftools/ext_aster.py	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/waftools/ext_aster.py	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,172 @@
+# coding=utf-8
+# --------------------------------------------------------------------
+# Copyright (C) 1991 - 2017 - EDF R&D - www.code-aster.org
+# This file is part of code_aster.
+#
+# code_aster is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# code_aster is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
+# --------------------------------------------------------------------
+
+import os.path as osp
+from waflib import Configure, Logs
+
+###############################################################################
+# Add OPTLIB_FLAGS support
+from waflib.Tools import fc, c, cxx, ccroot
+# original run_str command line is store as hcode
+for lang in ('c', 'cxx', 'fc'):
+    for feature in ('', 'program', 'shlib'):
+        ccroot.USELIB_VARS[lang + feature].add('OPTLIB_FLAGS')
+
+class fcprogram(fc.fcprogram):
+    """Link object files into a fortran program, add optional OPTLIB_FLAGS at the end"""
+    run_str = fc.fcprogram.hcode.decode() + ' ${OPTLIB_FLAGS}'
+
+class cprogram(c.cprogram):
+    """Link object files into a C program, add optional OPTLIB_FLAGS at the end"""
+    run_str = c.cprogram.hcode.decode() + ' ${OPTLIB_FLAGS}'
+
+class cxxprogram(cxx.cxxprogram):
+    """Link object files into a C program, add optional OPTLIB_FLAGS at the end"""
+    run_str = cxx.cxxprogram.hcode.decode() + ' ${OPTLIB_FLAGS}'
+
+###############################################################################
+def customize_configure_output():
+    """Customize the output of configure"""
+    from waflib.Context import Context
+    def start_msg40(self, *k, **kw):
+        """Force output on 40 columns. See :py:meth:`waflib.Context.Context.msg`"""
+        if kw.get('quiet', None):
+            return
+
+        msg = kw.get('msg', None) or k[0]
+        try:
+            if self.in_msg:
+                self.in_msg += 1
+                return
+        except AttributeError:
+            self.in_msg = 0
+        self.in_msg += 1
+
+        self.line_just = 40 # <--- here is the change
+        for x in (self.line_just * '-', msg):
+            self.to_log(x)
+        Logs.pprint('NORMAL', "%s :" % msg.ljust(self.line_just), sep='')
+    Context.start_msg = start_msg40
+
+customize_configure_output()
+###############################################################################
+from waflib.Task import Task, CRASHED, MISSING
+
+SRCWIDTH = 120
+def format_error(self):
+    """Write task details into a file. Print only the first line in console.
+    See :py:meth:`waflib.Task.Task.format_error`"""
+    text = Task.format_error(self)
+    if self.hasrun == CRASHED:
+        msg = getattr(self, 'last_cmd', '')
+        name = getattr(self.generator, 'name', '')
+        bldlog = osp.join(self.generator.bld.path.get_bld().abspath(), '%s.log' % name)
+        slog = ''
+        try:
+            open(bldlog, 'wb').write('task: %r\nlast command:\n%r\n' % (self, msg))
+        except (OSError, IOError) as exc:
+            slog = '\ncan not write the log file: %s' % str(exc)
+        text = text.splitlines()[0] \
+             + '\n    task details in: {0}{1}'.format(bldlog, slog)
+    return text
+
+#cprogram.format_error = format_error
+#cxxprogram.format_error = format_error
+#fcprogram.format_error = format_error
+
+###############################################################################
+# support for the "dynamic_source" attribute
+from waflib import Build, Utils, TaskGen
+
+@TaskGen.feature('c', 'cxx')
+@TaskGen.before('process_source', 'process_rule')
+def dynamic_post(self):
+    """
+    bld(dynamic_source='*.c', ...)
+        will search for source files to add to the attribute 'source'.
+
+    bld(dynamic_source='*.c', dynamic_incpaths='include', ...)
+        will search for 'include' in the parent of every new source and
+        add it in INCLUDES paths.
+    """
+    if not getattr(self, 'dynamic_source', None):
+        return
+    self.source = Utils.to_list(self.source)
+    get_srcs = self.path.get_bld().ant_glob
+    added = get_srcs(self.dynamic_source, remove=False, quiet=True)
+    self.source.extend(added)
+    for node in added:
+        node.sig = Utils.h_file(node.abspath())
+        if getattr(self, 'dynamic_incpaths', None):
+            incpath = node.parent.find_node(self.dynamic_incpaths)
+            if incpath:
+                incpath.sig = incpath.abspath()
+                self.env.append_value('INCLUDES', [incpath.abspath()])
+                incs = incpath.get_bld().ant_glob('**/*.h*', quiet=True)
+                for node in incs:
+                    node.sig = Utils.h_file(node.abspath())
+
+###############################################################################
+@Configure.conf
+def safe_remove(self, var, value):
+    """Remove 'value' from the variable, remove duplicates"""
+    self.env[var] = self.remove_duplicates(self.env[var])
+    while value in self.env[var]:
+        self.env[var].remove(value)
+
+@Configure.conf
+def remove_duplicates(self, list_in):
+    """Return the list by removing the duplicated elements
+    and by keeping the order"""
+    dset = set()
+    # relies on the fact that dset.add() always returns None.
+    return [ l for l in list_in if
+             l not in dset and not dset.add(l) ]
+
+# Force static libs
+CHECK = '_check'
+
+@Configure.conf
+def _force_stlib(self, *args, **kwargs):
+    """Always use 'stlib' keyword argument"""
+    kwargs = kwargs.copy()
+    stlib = kwargs.get('stlib') or kwargs.get('lib')
+    if stlib:
+        kwargs['stlib'] = stlib
+    try:
+        del kwargs['lib']
+    except KeyError:
+        pass
+    return getattr(self, CHECK)(*args, **kwargs)
+
+@Configure.conf
+def static_lib_pref(self):
+    """Change temporarly the 'check' method"""
+    if not self.options.embed_all:
+        return
+    if getattr(self, CHECK, None) is None:
+        setattr(self, CHECK, self.check)
+    self.check = self._force_stlib
+
+@Configure.conf
+def revert_lib_pref(self):
+    """Restore original method"""
+    if not self.options.embed_all:
+        return
+    self._force_stlib = getattr(self, CHECK)
diff -ruN MUMPS_5.1.2/waftools/mathematics.py mumps-5.1.2-aster7/waftools/mathematics.py
--- MUMPS_5.1.2/waftools/mathematics.py	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/waftools/mathematics.py	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,384 @@
+# coding=utf-8
+# --------------------------------------------------------------------
+# Copyright (C) 1991 - 2017 - EDF R&D - www.code-aster.org
+# This file is part of code_aster.
+#
+# code_aster is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# code_aster is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
+# --------------------------------------------------------------------
+
+import os
+import os.path as osp
+from itertools import product, takewhile
+from functools import partial
+from subprocess import Popen, PIPE
+from waflib import Options, Configure, Errors, Logs, Utils
+
+BLAS = ('openblas', 'blas')
+BLACS = ('blacs', )
+LAPACK = ('lapack', )
+SCALAPACK = ('scalapack', )
+OPTIONAL_DEPS = ('cblas', )
+
+def options(self):
+    group = self.add_option_group("Mathematics  libraries options")
+    group.add_option('--maths-libs', type='string',
+                    dest='maths_libs', default=None,
+                    help='Math librairies to link with like blas and lapack. '
+                         'Use None or "auto" to search them automatically.')
+    group.add_option('--embed-maths', dest='embed_math',
+                    default=False, action='store_true',
+                    help='Embed math libraries as static library')
+
+def configure(self):
+    # always check for libpthread, libm (never in static)
+    self.check_cc(uselib_store='MATH', lib='pthread')
+    self.check_cc(uselib_store='MATH', lib='m')
+    self.check_number_cores()
+    if self.options.maths_libs in (None, 'auto'):
+        # try MKL first, then automatic blas/lapack
+        if not self.detect_mkl():
+            self.detect_math_lib()
+    elif self.options.maths_libs:
+        self.check_opts_math_lib()
+    self.check_libm_after_files()
+    self.check_math_libs_call()
+
+###############################################################################
+@Configure.conf
+def check_opts_math_lib(self):
+    opts = self.options
+    embed = opts.embed_math or opts.embed_all
+    check_lib = lambda lib: self.check_cc(**{
+        'mandatory':True, 'uselib_store':'MATH', 'use':'MPI',
+        ('st' * embed + 'lib'):lib})
+
+    for lib in Utils.to_list(opts.maths_libs):
+        check_lib(lib)
+
+@Configure.conf
+def check_sizeof_blas_int(self):
+    """Check size of blas integers"""
+    self.set_define_from_env('BLAS_INT_SIZE',
+                             'Setting size of blas/lapack integers',
+                             'unexpected value for blas int: %(size)s',
+                             into=(4, 8), default=4)
+
+@Configure.conf
+def check_libm_after_files(self):
+    """Avoid warning #10315: specifying -lm before files may supercede the
+    Intel(R) math library and affect performance"""
+    self.start_msg('Setting libm after files')
+    flags = self.env.LINKFLAGS_CLIB
+    if '-lm' in flags:
+        while True:
+            try:
+                flags.remove('-lm')
+            except ValueError:
+                break
+        self.end_msg('yes ("-lm" removed from LINKFLAGS_CLIB)')
+        self.env.LINKFLAGS_CLIB = flags
+    else:
+        self.end_msg('nothing done')
+
+@Configure.conf
+def detect_mkl(self):
+    """Try to use MKL if ifort was detected"""
+    var = 'OPTLIB_FLAGS_MATH'
+    opts = self.options
+    embed = opts.embed_math or opts.embed_all
+    if 'ifort' not in self.env.FC_NAME.lower():
+        return
+    self.start_msg('Detecting MKL libraries')
+    suffix = '_lp64' if self.env.DEST_CPU.endswith('64') else ''
+    # first: out of the box (OPTLIB_FLAGS as provided)
+    totest = ['']
+    # http://software.intel.com/en-us/articles/intel-mkl-link-line-advisor/
+    if self.get_define('HAVE_MPI'):
+        totest.append('-mkl=parallel')
+        scalapack = ['-lmkl_scalapack' + suffix or '_core', '-lmkl_intel' + suffix]   # ia32: mkl_scalapack_core
+        blacs = ['-lmkl_intel_thread', '-lmkl_blacs_intelmpi' + suffix] + ['-lmkl_lapack95' + suffix]
+    else:
+        scalapack = []
+        blacs = []
+    interf = 'mkl_intel' + suffix
+    for typ in ('parallel', 'sequential'):
+        totest.append('-mkl=' + typ)
+        thread = 'mkl_sequential' if typ == 'sequential' else 'mkl_intel_thread'
+        core = 'mkl_core'
+        optional = []
+        if typ == 'parallel':
+            optional.append('iomp5')
+        libs = ['-l%s' % name for name in [interf, thread, core] + optional]
+        libs = ['-Wl,--start-group'] + scalapack + libs + blacs + ['-Wl,--end-group']
+        totest.append(libs)
+        libs = ['-mkl=' + typ ] +  libs
+        totest.append(libs)
+    Logs.debug("\ntest: %r" % totest)
+    while totest:
+        self.env.stash()
+        opts = totest.pop(0)
+        if opts:
+            self.env.append_value(var, opts)
+        try:
+            self.check_math_libs_call(color='YELLOW')
+        except:
+            self.env.revert()
+            continue
+        else:
+            self.end_msg(self.env[var])
+            self.define('_USE_MKL', 1)
+            return True
+    self.end_msg('no', color='YELLOW')
+    return False
+
+@Configure.conf
+def detect_math_lib(self):
+    opts = self.options
+    embed = opts.embed_math or (opts.embed_all and not self.get_define('HAVE_MPI'))
+    varlib = ('ST' if embed else '') + 'LIB_MATH'
+
+    # blas
+    blaslibs, lapacklibs = self.get_mathlib_from_numpy()
+    self.check_math_libs('blas', list(BLAS) + blaslibs, embed)
+    # lapack
+    opt_lapack = False
+    if 'openblas' in self.env.get_flat(varlib):
+        try:
+            self.check_math_libs_call(color='YELLOW')
+            opt_lapack = True
+        except:
+            pass
+    if not opt_lapack:
+        self.check_math_libs('lapack', list(LAPACK) + lapacklibs, embed)
+
+    def _scalapack():
+        """Check scalapack"""
+        libs = list(SCALAPACK)
+        libs = libs + [''.join(n) for n in product(libs, ['mpi', '-mpi', 'openmpi', '-openmpi'])]
+        return self.check_math_libs('scalapack', libs, embed)
+
+    def _blacs():
+        """Check blacs"""
+        libs = list(BLACS)
+        libs = libs + \
+               [''.join(n) for n in product(libs, ['mpi', '-mpi', 'openmpi', '-openmpi'])] \
+             + [''.join(n) for n in product(['mpi', 'mpi-', 'openmpi', 'openmpi-'], libs)] \
+        # check the 3 blacs libs together: Cinit, F77init, ''
+        ins = []
+        for i in libs:
+            ins.append([l.replace('blacs', 'blacs' + n) for l, n in \
+                        product([i], ['Cinit', 'F77init', ''])])
+        libs = ins + libs
+        return self.check_math_libs('blacs', libs, embed)
+
+    def _optional():
+        """Check optional dependencies"""
+        self.check_math_libs('optional', OPTIONAL_DEPS, embed, optional=True)
+
+    # parallel
+    if self.get_define('HAVE_MPI'):
+        self.env.stash()
+        try:
+            _blacs() and _scalapack()
+            _optional()
+            self.check_math_libs_call()
+        except:
+            self.env.revert()
+            _scalapack() and _blacs()
+            _optional()
+            self.check_math_libs_call()
+
+    self.start_msg('Detected math libraries')
+    self.end_msg(self.env[varlib])
+    if self.get_define('HAVE_MPI') and embed:
+        msg = "WARNING:\n"\
+              "    Static link with MPI libraries is not recommended.\n"\
+              "    Remove the option --embed-maths in case of link error.\n"\
+              "    See http://www.open-mpi.org/faq/?category=mpi-apps#static-mpi-apps"
+        Logs.warn(msg)
+    if 'openblas' in self.env[varlib]:
+        self.define('_USE_OPENBLAS', 1)
+
+@Configure.conf
+def check_math_libs(self, name, libs, embed, optional=False):
+    """Check for library 'name', stop on first found"""
+    check_maths = partial(self.check_cc, uselib_store='MATH', use='MATH MPI',
+                          mandatory=False)
+    if embed:
+        check_lib = lambda lib: check_maths(stlib=lib)
+    else:
+        check_lib = lambda lib: check_maths(lib=lib)
+    self.start_msg('Checking library %s' % name)
+    found = None
+    for lib in libs:
+        if check_lib(lib=lib):
+            self.end_msg('yes (%s)' % lib)
+            found = lib
+            break
+    else:
+        if not optional:
+            self.fatal('Missing the %s library' % name)
+        self.end_msg('not found', 'YELLOW')
+    return found
+
+@Configure.conf
+def check_number_cores(self):
+    """Check for the number of available cores."""
+    self.start_msg('Checking for number of cores')
+    try:
+        self.find_program('nproc')
+        try:
+            res = self.cmd_and_log(['nproc'])
+            nproc = int(res)
+        except Errors.WafError:
+            raise Errors.ConfigurationError
+    except Errors.ConfigurationError:
+        nproc = 1
+    else:
+        self.end_msg(nproc)
+    self.env['NPROC'] = nproc
+
+@Configure.conf
+def get_mathlib_from_numpy(self):
+    '''The idea is that numpy shall be linked to blas and lapack.
+    So we will try to get then using ldd if available'''
+    libblas = []
+    pathblas = []
+    liblapack = []
+    pathlapack = []
+
+    self.load('python')
+
+    self.check_python_module('numpy')
+    pymodule_path = self.get_python_variables(
+        ['lapack_lite.__file__'],
+        ['from numpy.linalg import lapack_lite'])[0]
+
+    self.find_program('ldd')
+    ldd_env = {'LD_LIBRARY_PATH': ':'.join(self.env.LIBPATH)}
+    cmd = self.env.LDD + [pymodule_path]
+    out = Popen(cmd, stdout=PIPE, env=ldd_env).communicate()[0].decode()
+
+    for line in out.split('\n'):
+        lib = _detect_libnames_in_ldd_line(line, LAPACK)
+        if lib:
+            liblapack.append(lib)
+            continue
+        lib = _detect_libnames_in_ldd_line(line, BLAS)
+        if lib:
+            libblas.append(lib)
+    return libblas, liblapack
+
+def _detect_libnames_in_ldd_line(line, libnames):
+    if not list(filter(line.__contains__, libnames)):
+        return None
+    lib = line.split()[0].split('.', 1)[0]
+    return lib[3:]
+
+@Configure.conf
+def check_math_libs_call(self, color='RED'):
+    """Compile and run a small blas/lapack program"""
+    self.start_msg('Checking for a program using blas/lapack')
+    try:
+        ret = self.check_fc(fragment=blas_lapack_fragment, use='MATH OPENMP MPI',
+                            mandatory=False, execute=True, define_ret=True)
+        values = list(map(float, ret and ret.split() or []))
+        ref = [10.0, 5.0]
+        if list(values) != ref:
+            raise Errors.ConfigurationError('invalid result: %r (expecting %r)' % (values, ref))
+    except Exception as exc:
+        # the message must be closed
+        self.end_msg('no', color=color)
+        raise Errors.ConfigurationError(str(exc))
+    else:
+        self.end_msg('yes')
+
+    if self.get_define('HAVE_MPI'):
+        self.start_msg('Checking for a program using blacs')
+        try:
+            ret = self.check_fc(fragment=blacs_fragment, use='MATH OPENMP MPI',
+                                mandatory=True)
+        except Exception as exc:
+            # the message must be closed
+            self.end_msg('no', color=color)
+            raise Errors.ConfigurationError(str(exc))
+        else:
+            self.end_msg('yes')
+
+    self.start_msg('Checking for a program using omp thread')
+    try:
+        ret = self.check_fc(fragment=omp_thread_fragment, use='MATH OPENMP MPI',
+                            mandatory=True, execute=True, define_ret=True)
+        nbThreads = int((ret and ret.split() or [])[-1])
+        refe = min(self.env['NPROC'], 2) if self.env.BUILD_OPENMP else 1
+        if nbThreads < refe:
+            raise ValueError("expected at least {0} thread(s)".format(nbThreads))
+    except Exception as exc:
+        # the message must be closed
+        self.end_msg('no', color=color)
+        raise Errors.ConfigurationError(str(exc))
+    else:
+        self.end_msg('yes (on {0} threads)'.format(nbThreads))
+
+# program testing a blas and a lapack call, output is 10.0 and 5.0
+blas_lapack_fragment = r"""
+subroutine test(res, res2)
+    implicit none
+    real(kind=8), intent(out) :: res, res2
+!
+    real(kind=8) :: ddot, dlapy2
+    real(kind=8) :: a1(2), a2(2)
+    integer  i
+!
+    do i = 1, 2
+        a1(i) = 1.d0 * i
+        a2(i) = 2.d0 * i
+    end do
+    res = ddot(2, a1, 1, a2,1)
+    res2 = dlapy2(3.d0, 4.d0)
+end subroutine test
+
+program main
+    real(kind=8) :: a, b
+    call test(a, b)
+    print *, a
+    print *, b
+end program main
+"""
+
+# program testing a blacs call, output is 0 and 1
+blacs_fragment = r"""
+program test_blacs
+    integer iam, nprocs
+    call blacs_pinfo (iam, nprocs)
+    print *,iam
+    print *,nprocs
+end program test_blacs
+"""
+
+# program testing openmp theads
+omp_thread_fragment = r"""
+program hello
+!$ use omp_lib
+    integer total, thid
+    total = 1
+    thid = 0
+!$omp parallel private(thid) shared(total)
+!$ total = omp_get_num_threads()
+!$ thid = omp_get_thread_num()
+    print *, "Thread ", thid, "of ", total, "childs"
+!$omp end parallel
+    print *, total
+end program hello
+"""
diff -ruN MUMPS_5.1.2/waftools/metis.py mumps-5.1.2-aster7/waftools/metis.py
--- MUMPS_5.1.2/waftools/metis.py	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/waftools/metis.py	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,122 @@
+# coding=utf-8
+# --------------------------------------------------------------------
+# Copyright (C) 1991 - 2017 - EDF R&D - www.code-aster.org
+# This file is part of code_aster.
+#
+# code_aster is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# code_aster is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
+# --------------------------------------------------------------------
+
+import os.path as osp
+import re
+from functools import partial
+from waflib import Options, Configure, Logs, Utils, Errors
+
+def options(self):
+    group = self.add_option_group('Metis library options')
+    group.add_option('--disable-metis', action='store_false', default=None,
+                    dest='enable_metis', help='Disable METIS support')
+    group.add_option('--enable-metis', action='store_true', default=None,
+                    dest='enable_metis', help='Force METIS support')
+    group.add_option('--metis-libs', type='string', dest='metis_libs',
+                    default=None,
+                    help='metis librairies to use when linking')
+    group.add_option('--embed-metis', dest='embed_metis',
+                    default=False, action='store_true',
+                    help='Embed METIS libraries as static library')
+
+def configure(self):
+    try:
+        self.check_metis()
+    except Errors.ConfigurationError:
+        self.define('_DISABLE_METIS', 1)
+        self.undefine('HAVE_METIS')
+        if self.options.enable_metis == True:
+            raise
+    else:
+        self.define('_HAVE_METIS', 1)
+        self.define('HAVE_METIS', 1)
+
+###############################################################################
+@Configure.conf
+def check_metis(self):
+    opts = self.options
+    if opts.enable_metis == False:
+        raise Errors.ConfigurationError('METIS disabled')
+    if opts.metis_libs is None:
+        opts.metis_libs = 'metis'
+    if opts.metis_libs:
+        self.check_metis_libs()
+    self.check_metis_headers()
+    self.check_metis_version()
+
+@Configure.conf
+def check_metis_libs(self):
+    opts = self.options
+    check_metis = partial(self.check_cc, uselib_store='METIS', mandatory=True)
+    if opts.embed_all or opts.embed_metis:
+        check = lambda lib: check_metis(stlib=lib)
+    else:
+        check = lambda lib: check_metis(lib=lib)
+    for lib in Utils.to_list(opts.metis_libs):
+        check(lib)
+
+@Configure.conf
+def check_metis_headers(self):
+    check = partial(self.check_cc, header_name='metis.h', uselib_store='METIS', use='METIS')
+    self.start_msg('Checking for header metis.h')
+    try:
+        if not check(mandatory=False):
+            if not check(includes=[osp.join(self.env.INCLUDEDIR, 'metis')], mandatory=False):
+                check(includes=[osp.join(self.env.OLDINCLUDEDIR, 'metis')], mandatory=True)
+    except:
+        self.end_msg('no', 'YELLOW')
+        raise
+    else:
+        self.end_msg('yes')
+
+@Configure.conf
+def check_metis_version(self):
+    fragment = r'''
+#include <stdio.h>
+#include <metis.h>
+int main(void){
+#ifdef METISTITLE
+/* metis 4 */
+    printf("METISTITLE: %s", METISTITLE);
+    return 0;
+#endif
+#if defined(METIS_VER_MAJOR) && defined(METIS_VER_MINOR) && defined(METIS_VER_SUBMINOR)
+    printf("METISVER: %d.%d.%d", METIS_VER_MAJOR, METIS_VER_MINOR, METIS_VER_SUBMINOR);
+    return 0;
+#endif
+/* unexpected */
+    return 1;
+}'''
+    self.start_msg('Checking metis version')
+    try:
+        ret = self.check_cc(fragment=fragment, use='METIS',
+                            mandatory=True, execute=True, define_ret=True)
+        mat4 = re.search('METISTITLE: *METIS *(?P<vers>[0-9]+\.[0-9]+\.\w+) ', ret)
+        mat5 = re.search('METISVER: *(?P<vers>[0-9]+\.[0-9]+\.\w+)', ret)
+        vers = (mat4 and mat4.group('vers')) or (mat5 and mat5.group('vers'))
+        major = int(vers.split('.')[0])
+        if major != 5:
+            self.end_msg('unsupported metis version: %s' % vers, 'RED')
+            raise Errors.ConfigurationError
+        self.env.METIS_ORDERING = 'metis'
+    except:
+        self.end_msg('can not get version', 'RED')
+        raise
+    else:
+        self.end_msg(vers)
diff -ruN MUMPS_5.1.2/waftools/parallel.py mumps-5.1.2-aster7/waftools/parallel.py
--- MUMPS_5.1.2/waftools/parallel.py	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/waftools/parallel.py	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,121 @@
+# coding=utf-8
+# --------------------------------------------------------------------
+# Copyright (C) 1991 - 2017 - EDF R&D - www.code-aster.org
+# This file is part of code_aster.
+#
+# code_aster is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# code_aster is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
+# --------------------------------------------------------------------
+
+import os
+import os.path as osp
+from functools import partial
+from waflib import Options, Configure, Errors, Logs, Utils
+
+
+def options(self):
+    self.load('compiler_c')
+    self.load('compiler_cxx')
+    self.load('compiler_fc')
+
+    group = self.get_option_group("Global options")
+    group.add_option('--enable-mpi', dest='parallel', action='store_true',
+                     help='Build a parallel version with mpi')
+    group.add_option('--enable-openmp', dest='openmp', action='store_true',
+                     help='Build a parallel version supporting OpenMP')
+    group.add_option('--disable-openmp', dest='openmp', action='store_false',
+                     help='Disable OpenMP')
+
+def configure(self):
+    opts = self.options
+    if opts.parallel:
+        # Configure.find_program uses first self.environ, then os.environ
+        self.environ.setdefault('CC', 'mpicc')
+        self.environ.setdefault('CXX', 'mpicxx')
+        self.environ.setdefault('FC', 'mpif90')
+    self.load_compilers()
+    self.check_compilers_version()
+    self.check_fortran_verbose_flag()
+    self.check_openmp()
+    self.check_fortran_clib()
+
+###############################################################################
+
+@Configure.conf
+def check_compilers_version(self):
+    self.start_msg('Checking for C compiler version')
+    self.end_msg(self.env.CC_NAME.lower() + ' ' + \
+                 '.'.join(Utils.to_list(self.env.CC_VERSION)))
+    # CXX_VERSION does not exist, c++ == c
+    self.start_msg('Checking for Fortran compiler version')
+    self.end_msg(self.env.FC_NAME.lower() + ' ' + \
+                 '.'.join(Utils.to_list(self.env.FC_VERSION)))
+
+@Configure.conf
+def load_compilers(self):
+    self.load('compiler_c')
+    self.load('compiler_cxx')
+    self.load('compiler_fc')
+    if self.options.parallel:
+        cc = self.env.CC[0]
+        cxx = self.env.CXX[0]
+        fc = self.env.FC[0]
+        check = partial(self.check_cfg, args='--showme:compile --showme:link -show',
+                        package='', uselib_store='MPI', mandatory=False)
+        # do not add flags given by cxx linker
+        if check(path=cc) and check(path=fc):
+            self.check_mpi()
+        if not self.get_define('HAVE_MPI'):
+            self.fatal("Unable to configure the parallel environment")
+        self.env.BUILD_PARALLEL = 1
+
+@Configure.conf
+def check_mpi(self):
+    self.check_cc(header_name='mpi.h', use='MPI', define_name='_USE_MPI')
+    if self.get_define('_USE_MPI'):
+        self.define('HAVE_MPI', 1)
+
+@Configure.conf
+def check_openmp(self):
+    opts = self.options
+    if opts.openmp is False:
+        self.msg('Checking for OpenMP flag', 'no', color='YELLOW')
+        return
+    try:
+        self.detect_openmp()
+    except (Errors.ConfigurationError, Errors.BuildError):
+        if opts.openmp is True:
+            raise
+        self.env.append_value('FCFLAGS_OPENMP', ['-fopenmp'])
+        self.env.append_value('FCLINKFLAGS_OPENMP', ['-fopenmp'])
+    if self.env.FCFLAGS_OPENMP:
+        self.env.BUILD_OPENMP = 1
+        self.define('_USE_OPENMP', 1)
+
+@Configure.conf
+def check_sizeof_mpi_int(self):
+    """Check size of MPI_Fint"""
+    if self.get_define('HAVE_MPI'):
+        fragment = '\n'.join([
+            '#include <stdio.h>',
+            '#include "mpi.h"',
+            'int main(void){',
+            '    MPI_Fint var;',
+            '    printf("%d", (int)sizeof(var));',
+            '    return 0;',
+            '}',
+            ''])
+        self.code_checker('MPI_INT_SIZE', self.check_cc, fragment,
+                          'Checking size of MPI_Fint integers',
+                          'unexpected value for sizeof(MPI_Fint): %(size)s',
+                          into=(4, 8), use='MPI')
diff -ruN MUMPS_5.1.2/waftools/parmetis.py mumps-5.1.2-aster7/waftools/parmetis.py
--- MUMPS_5.1.2/waftools/parmetis.py	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/waftools/parmetis.py	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,101 @@
+# coding=utf-8
+
+import os.path as osp
+import re
+from functools import partial
+from waflib import Options, Configure, Logs, Utils, Errors
+
+def options(self):
+    group = self.add_option_group('Parmetis library options')
+    group.add_option('--disable-parmetis', action='store_false', default=None,
+                    dest='enable_parmetis', help='Disable PARMETIS support')
+    group.add_option('--enable-parmetis', action='store_true', default=None,
+                    dest='enable_parmetis', help='Force PARMETIS support')
+    group.add_option('--parmetis-libs', type='string', dest='parmetis_libs',
+                    default=None,
+                    help='parmetis librairies to use when linking')
+    group.add_option('--embed-parmetis', dest='embed_parmetis',
+                    default=False, action='store_true',
+                    help='Embed PARMETIS libraries as static library')
+
+def configure(self):
+    try:
+        self.check_parmetis()
+    except Errors.ConfigurationError:
+        self.define('_DISABLE_PARMETIS', 1)
+        self.undefine('HAVE_PARMETIS')
+        if self.options.enable_parmetis == True:
+            raise
+    else:
+        self.define('_HAVE_PARMETIS', 1)
+        self.define('HAVE_PARMETIS', 1)
+
+###############################################################################
+@Configure.conf
+def check_parmetis(self):
+    opts = self.options
+    if opts.enable_parmetis == False:
+        raise Errors.ConfigurationError('PARMETIS disabled')
+    if opts.parmetis_libs is None:
+        opts.parmetis_libs = 'parmetis'
+    if opts.parmetis_libs:
+        self.check_parmetis_libs()
+    self.check_parmetis_headers()
+    self.check_parmetis_version()
+
+@Configure.conf
+def check_parmetis_libs(self):
+    opts = self.options
+    check_parmetis = partial(self.check_cc, uselib_store='PARMETIS', mandatory=True)
+    if opts.embed_all or opts.embed_parmetis:
+        check = lambda lib: check_parmetis(stlib=lib)
+    else:
+        check = lambda lib: check_parmetis(lib=lib)
+    for lib in Utils.to_list(opts.parmetis_libs):
+        check(lib)
+
+@Configure.conf
+def check_parmetis_headers(self):
+    check = partial(self.check_cc, header_name='parmetis.h', uselib_store='PARMETIS', use='PARMETIS')
+    self.start_msg('Checking for header parmetis.h')
+    try:
+        if not check(mandatory=False):
+            if not check(includes=[osp.join(self.env.INCLUDEDIR, 'parmetis')], mandatory=False):
+                check(includes=[osp.join(self.env.OLDINCLUDEDIR, 'parmetis')], mandatory=True)
+    except:
+        self.end_msg('no', 'YELLOW')
+        raise
+    else:
+        self.end_msg('yes')
+
+@Configure.conf
+def check_parmetis_version(self):
+    fragment = r'''
+#include <stdio.h>
+#include <parmetis.h>
+#include <metis.h>
+int main(void){
+#if defined(PARMETIS_MAJOR_VERSION) && defined(PARMETIS_MINOR_VERSION) && defined(PARMETIS_SUBMINOR_VERSION)
+    printf("PARMETISVER: %d.%d.%d", PARMETIS_MAJOR_VERSION, PARMETIS_MINOR_VERSION, PARMETIS_SUBMINOR_VERSION);
+    return 0;
+#endif
+/* unexpected */
+    return 1;
+}'''
+    self.start_msg('Checking parmetis version')
+    try:
+        ret = self.check_cc(fragment=fragment, use='PARMETIS',
+                            mandatory=True, execute=True, define_ret=True)
+        mat5 = re.search('PARMETISVER: *(?P<vers>[0-9]+\.[0-9]+\.\w+)', ret)
+        vers = (mat5 and mat5.group('vers'))
+        major = int(vers.split('.')[0])
+        if major not in (4,):
+            self.end_msg('unsupported metis version: %s' % vers, 'RED')
+            raise Errors.ConfigurationError
+        if major == 4:
+            self.env.PARMETIS_ORDERING = 'parmetis'
+    except:
+        self.end_msg('can not get version', 'RED')
+        raise
+    else:
+        self.end_msg(vers)
diff -ruN MUMPS_5.1.2/waftools/scotch.py mumps-5.1.2-aster7/waftools/scotch.py
--- MUMPS_5.1.2/waftools/scotch.py	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/waftools/scotch.py	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,128 @@
+# coding=utf-8
+# --------------------------------------------------------------------
+# Copyright (C) 1991 - 2017 - EDF R&D - www.code-aster.org
+# This file is part of code_aster.
+#
+# code_aster is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# code_aster is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
+# --------------------------------------------------------------------
+
+import os.path as osp
+from functools import partial
+from waflib import Options, Configure, Logs, Utils, Errors
+
+def options(self):
+    group = self.add_option_group("Scotch library options")
+    group.add_option('--disable-scotch', action='store_false', default=None,
+                   dest='enable_scotch', help='Disable SCOTCH support')
+    group.add_option('--enable-scotch', action='store_true', default=None,
+                   dest='enable_scotch', help='Force scotch support')
+    group.add_option('--scotch-libs', type='string',
+                   dest='scotch_libs', default=None,
+                   help='scotch librairies used when linking')
+    group.add_option('--embed-scotch', dest='embed_scotch',
+                    default=False, action='store_true',
+                    help='Embed SCOTCH libraries as static library')
+
+def configure(self):
+    try:
+        self.check_scotch()
+    except Errors.ConfigurationError:
+        self.define('_DISABLE_SCOTCH', 1)
+        self.undefine('HAVE_SCOTCH')
+        if self.options.enable_scotch == True:
+            raise
+    else:
+        self.define('HAVE_SCOTCH', 1)
+        self.undefine('_DISABLE_SCOTCH')
+
+###############################################################################
+
+@Configure.conf
+def check_scotch(self):
+    opts = self.options
+    if opts.enable_scotch == False:
+        raise Errors.ConfigurationError('SCOTCH disabled')
+
+    self.check_scotch_headers()
+    self.check_scotch_version()
+
+    if opts.scotch_libs is None:
+        if self.env.SCOTCH_VERSION and self.env.SCOTCH_VERSION[0] < 5:
+            opts.scotch_libs = 'scotch scotcherr scotcherrexit'
+        else:
+            # default or SCOTCH_VERSION >= 5
+            if self.env.HAVE_MPI:
+               opts.scotch_libs = 'esmumps ptscotch ptscotcherr ptscotcherrexit scotch scotcherr scotcherrexit'
+            else :
+               opts.scotch_libs = 'esmumps scotch scotcherr'
+
+    # code_aster v11.0.1: FICHE 016627
+    if 'scotchmetis' in opts.scotch_libs:
+        raise Errors.ConfigurationError('scotchmetis variant library is not compatible with code_aster')
+
+    if opts.scotch_libs:
+        self.check_scotch_libs()
+
+
+@Configure.conf
+def check_scotch_libs(self):
+    opts = self.options
+    check_scotch = partial(self.check_cc, mandatory=True, uselib_store='SCOTCH', use='MPI')
+    if opts.embed_all or opts.embed_scotch:
+        check_lib = lambda lib: check_scotch(stlib=lib)
+    else:
+        check_lib = lambda lib: check_scotch(lib=lib)
+    for lib in Utils.to_list(opts.scotch_libs):
+        check_lib(lib)
+
+@Configure.conf
+def check_scotch_headers(self):
+    self.start_msg('Checking for header scotch.h')
+    headers = 'stdio.h stdlib.h sys/types.h scotch.h'
+    try:
+        check = partial(self.check, header_name=headers,
+                        uselib_store='SCOTCH', uselib='SCOTCH MPI')
+
+        if not check(mandatory=False):
+            if not check(includes=[osp.join(self.env.INCLUDEDIR, 'scotch')], mandatory=False):
+                check(includes=[osp.join(self.env.OLDINCLUDEDIR, 'scotch')], mandatory=True)
+    except:
+        self.end_msg('no', 'YELLOW')
+        raise
+    else:
+        self.end_msg('yes')
+
+@Configure.conf
+def check_scotch_version(self):
+    # scotch.h may use int64_t without including <sys/types.h>
+    fragment = r'''
+#include <stdio.h>
+#include <sys/types.h>
+#include "scotch.h"
+
+int main(void){
+    printf("(%d, %d, %d)", (int)SCOTCH_VERSION, (int)SCOTCH_RELEASE,
+           (int)SCOTCH_PATCHLEVEL);
+    return 0;
+}'''
+    self.start_msg('Checking scotch version')
+    try:
+        ret = self.check_cc(fragment=fragment, use='SCOTCH', uselib_store='SCOTCH',
+                            mandatory=True, execute=True, define_ret=True)
+        self.env.append_value('SCOTCH_VERSION', eval(ret))
+    except:
+        self.end_msg('no', 'YELLOW')
+        raise
+    else:
+        self.end_msg( '.'.join([str(i) for i in eval(ret)]) )
diff -ruN MUMPS_5.1.2/wscript mumps-5.1.2-aster7/wscript
--- MUMPS_5.1.2/wscript	1970-01-01 01:00:00.000000000 +0100
+++ mumps-5.1.2-aster7/wscript	2020-10-23 11:16:48.000000000 +0200
@@ -0,0 +1,267 @@
+# coding=utf-8
+
+"""
+The waf scripts have been added by the Code_Aster team to configure the
+Makefile.inc of Mumps.
+
+See http://www.code-aster.org and https://code.google.com/p/waf for more informations.
+"""
+
+top = '.'
+out = 'build'
+
+import os
+import os.path as osp
+import sys
+import platform
+from itertools import chain
+from waflib import Configure, Utils, Logs
+
+def options(self):
+    ori_get_usage = self.parser.get_usage
+    def _usage():
+        return ori_get_usage() + os.linesep.join((
+        '',
+        'Environment variables:',
+        '  INCLUDES       : space separated list of directories extending the include'
+        ' path',
+        '  CC             : C compiler',
+        '  FC             : Fortran compiler',
+        '  INCLUDES       : extra include paths',
+        '  DEFINES        : extra preprocessor defines',
+        '  LINKFLAGS      : extra C linker options',
+        '  LIBPATH        : extra paths where to find libraries',
+        '  OPTLIB_FLAGS   : extra linker flags inserted after static libs '
+        '(for example when -Wl,start-group options are necessary)',
+        '  CFLAGS         : extra C compilation options',
+        '  FCFLAGS        : extra Fortran compilation options',
+        '  PREFIX         : default installation prefix to be used, '
+        'if no --prefix option is given.',
+        '',))
+    self.parser.get_usage = _usage
+
+    self.load('gnu_dirs')
+    self.load('python')
+
+    group = self.add_option_group('Global options')
+
+    self.load('parallel', tooldir='waftools')
+    self.load('mathematics', tooldir='waftools')
+    self.load('metis', tooldir='waftools')
+    self.load('parmetis', tooldir='waftools')
+    self.load('scotch', tooldir='waftools')
+
+    group.add_option('-E', '--embed-all', dest='embed_all',
+                    action='store_true', default=False,
+                    help='activate all embed-* options')
+    group.add_option('--install-tests', dest='install_tests',
+                    action='store_true', default=False,
+                    help='build and install the testcases files')
+
+def configure(self):
+    opts = self.options
+    self.env.install_tests = opts.install_tests
+    self.load('gnu_dirs')
+    self.add_os_flags('FLAGS')
+    self.add_os_flags('CFLAGS')
+    self.add_os_flags('FCFLAGS')
+    self.add_os_flags('LINKFLAGS')
+    self.add_os_flags('LIB')
+    self.add_os_flags('LIBPATH')
+    self.add_os_flags('STLIB')
+    self.add_os_flags('STLIBPATH')
+    self.add_os_flags('INCLUDES')
+    self.add_os_flags('DEFINES')
+    self.add_os_flags('OPTLIB_FLAGS')
+
+    # Add *LIBPATH paths to LD_LIBRARY_PATH
+    libpaths = list(chain(*[Utils.to_list(self.env[key]) for key in self.env.table
+                            if 'libpath' in key.lower()]))
+    ldpaths = [p for p in os.environ.get('LD_LIBRARY_PATH', '').split(os.pathsep)]
+    paths =  libpaths + ldpaths
+    os.environ['LD_LIBRARY_PATH'] = os.pathsep.join(p for p in paths if p)
+
+    self.load('ext_aster', tooldir='waftools')
+    self.load('parallel', tooldir='waftools')
+    self.load('mathematics', tooldir='waftools')
+    self.load('metis', tooldir='waftools')
+    if self.env.HAVE_MPI:
+       self.load('parmetis', tooldir='waftools')
+    self.load('scotch', tooldir='waftools')
+
+    self.check_linkflags()
+    self.check_cflags()
+    self.check_fcflags()
+
+    self.check_cc(uselib_store='SYS', lib='dl')
+    self.check_cc(uselib_store='SYS', lib='util')
+    self.check_cc(uselib_store='SYS', lib='pthread')
+    if not self.env.HAVE_MPI:
+        self.env.INCS = '$(INCSEQ)'
+        self.env.LIBS = '$(LIBSEQ)'
+        self.env.LIBSEQNEEDED = 'libseqneeded'
+    else:
+        self.env.INCS = '$(INCPAR)'
+        self.env.LIBS = '$(LIBPAR)'
+    self.env.append_value('ORDERINGS', 'pord')
+    if self.env.LIB_METIS:
+        self.env.append_unique('ORDERINGS', [self.env.METIS_ORDERING])
+        self.env.append_unique('DEFINES', [self.env.METIS_ORDERING])
+    if self.env.HAVE_MPI:
+        if self.env.LIB_PARMETIS:
+           self.env.append_unique('ORDERINGS', [self.env.PARMETIS_ORDERING])
+           self.env.append_unique('DEFINES', [self.env.PARMETIS_ORDERING])
+    if self.env.LIB_SCOTCH:
+        self.env.append_value('ORDERINGS', 'scotch')
+        if self.env.HAVE_MPI:
+           self.env.append_value('ORDERINGS', 'ptscotch')
+
+@Configure.conf
+def check_cflags(self):
+    self.start_msg('Getting C compiler flags')
+    if platform.machine() in 'x86_64' :
+       self.env.append_unique('CFLAGS', ['-fPIC', '-O'])
+    else:
+       self.env.append_unique('CFLAGS', ['-fPIC', '-O', '-DINTSIZE32'])
+    self.end_msg(self.env['CFLAGS'])
+
+@Configure.conf
+def check_fcflags(self):
+    self.check_fortran()
+    self.check_fortran_dummy_main()
+    if 'MAIN_' in self.env.FC_MAIN:
+        # for examples/c_example unittest
+        self.env.append_unique('CFLAGS', ['-DMAIN_COMP'])
+    self.check_fortran_mangling()
+    if self.env.FORTRAN_MANGLING:
+        underscore = self.env.FORTRAN_MANGLING[0] + self.env.FORTRAN_MANGLING[1]
+        if underscore:
+            self.env.append_value('DEFINES', 'Add' + underscore)
+        if self.env.FORTRAN_MANGLING[2] == 'upper':
+            self.env.append_value('DEFINES', 'UPPER')
+    self.start_msg('Getting Fortran compiler flags')
+    if platform.machine() in 'x86_64' :
+       self.env.append_unique('FCFLAGS', ['-fPIC', '-O', '-DPORD_INTSIZE64'])
+    else:
+       self.env.append_unique('FCFLAGS', ['-fPIC', '-O'])
+    self.end_msg(self.env['FCFLAGS'])
+
+@Configure.conf
+def check_linkflags(self):
+    opts = self.options
+    if sys.platform != 'darwin':
+        self.env.append_unique('LINKFLAGS', ['-Wl,--export-dynamic'])
+    else:
+        # '--export-dynamic' is '-export_dynamic' in OS X linker
+        # http://stackoverflow.com/questions/21279036/what-is-clangs-equivalent-to-rdynamic-gcc-flag
+        self.env.append_unique('LINKFLAGS', ['-Wl,-export_dynamic'])
+
+    if 'ifort' in self.env.FC_NAME.lower():
+        self.env.append_value('LINKFLAGS_fcprogram', ['-nofor_main'])
+        if opts.embed_all:
+            self.env.append_value('LINKFLAGS_fcprogram', ['-static-intel'])
+            if self.get_define('HAVE_MPI'):
+                self.env.append_value('LINKFLAGS_fcprogram', ['-static_mpi'])
+
+################################################################################
+def build(self):
+    self.load('ext_aster', tooldir='waftools')
+    if self.cmd == 'clean':
+        return clean(self)
+    mkn = self.path.make_node
+    makeinc = mkn('Makefile.inc')
+    self(
+        name   = 'create_makefile_inc',
+        rule   = build_makefile,
+        vars   = ['AR', 'ARFLAGS',
+                  'DEFINES', 'INCLUDES',
+                  'CC', 'CFLAGS', 'FC', 'FCFLAGS', 'FCFLAGS_OPENMP',
+                  'LINK_FC', 'LINKFLAGS', 'LINKFLAGS_OPENMP', 'LINKFLAGS_CLIB',
+                  'LIBPATH',
+                  'LIB_SCOTCH', 'LIB_METIS', 'LIB_PARMETIS', 'LIB_MATH', 'LIB_SYS',
+                  'STLIB_SCOTCH', 'STLIB_METIS', 'STLIB_PARMETIS', 'STLIB_MATH', 'STLIB_SYS',
+                  'OPTLIB_FLAGS', 'OPTLIB_FLAGS_MATH',
+                  # Makefile variables
+                  'INCS', 'LIBS', 'LIB_SCALAPACK',
+                  'LIBSEQNEEDED', 'ORDERINGS'],
+        source = 'Makefile.inc.in',
+        target = makeinc,
+        always = True,
+        update_outputs = True,  # because target is written in src
+    )
+    libs = [mkn('lib/lib%s.a' % i) for i in \
+            ('smumps', 'dmumps', 'cmumps', 'zmumps', 'mumps_common', 'pord')]
+    if not self.env.HAVE_MPI:
+        libs.append(mkn('libseq/libmpiseq.a'))
+    bins = []
+    datas = []
+    if self.env.install_tests:
+        bins = [mkn('examples/%ssimpletest' % i) for i in 'sdcz']
+        bins.append(mkn('examples/c_example'))
+        datas = [mkn(i) for i in ('examples/input_simpletest_cmplx',
+                                  'examples/input_simpletest_real',
+                                  'examples/README')]
+    self(
+        name   = 'make_mumps_libs',
+        rule   = call_make,
+        source = makeinc,
+        target = libs + bins + datas,
+        update_outputs = True,  # because targets are built in src
+        after  = 'create_makefile_inc',
+    )
+    self.install_files('${PREFIX}/lib', libs)
+    if self.env.install_tests:
+        self.install_files('${PREFIX}/share/examples', bins, chmod=Utils.O755)
+        self.install_files('${PREFIX}/share/examples', datas)
+    get_srcs = self.path.get_src().ant_glob
+    self.install_files('${PREFIX}/include', get_srcs('include/*.h'))
+    self.install_files('${PREFIX}/include_seq', get_srcs('libseq/mpi*.h'))
+
+def build_makefile(self):
+    """Change variables to be inserted in the Makefile.inc.in template,
+    change text and write Makefile.inc"""
+    content = self.inputs[0].read()
+    Logs.debug("changing '%s'..." % self.inputs[0])
+    for varn in self.vars:
+        fmt = None
+        prefix = None
+        if varn in ('DEFINES', 'ORDERINGS'):
+            fmt = self.env.DEFINES_ST
+        elif varn == 'INCLUDES':
+            fmt = self.env.CPPPATH_ST
+        elif varn == 'LIBPATH':
+            fmt = self.env.LIBPATH_ST
+        elif varn.startswith('LIB_'):
+            fmt = self.env.LIB_ST
+            prefix = self.env.SHLIB_MARKER
+        elif varn.startswith('STLIB_'):
+            fmt = self.env.LIB_ST
+            prefix = self.env.STLIB_MARKER
+        if fmt:
+            value = ' '.join([fmt % i for i in self.env[varn]])
+        else:
+            value = self.env.get_flat(varn)
+        if prefix and value.strip():
+            value = prefix + ' ' + value
+        #print("%s=%r" % (varn, value))
+        content = content.replace("?%s?" % varn, value)
+    #assert '?' not in content
+    Logs.debug("writing '%s'" % self.outputs[0])
+    self.outputs[0].write(content)
+    return 0
+
+def call_make(self):
+    """Call the standard Mumps build"""
+    from waflib.Options import options as opts
+    inc = self.inputs[0]
+    path = osp.dirname(inc.get_src().abspath())
+    cmd = "cd %s ; make all -j %s" % (path, opts.jobs)
+    ret = self.exec_command(cmd)
+    return ret
+
+def clean(self):
+    root = self.path.abspath()
+    inc = osp.join(root, 'Makefile.inc')
+    if osp.isfile(inc):
+        self.exec_command('make clean')
+        os.remove(inc)
