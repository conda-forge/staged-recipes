From f83df0c3e1ae71ca32dbf777a7a52b45b80095bb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Julian=20R=C3=BCth?= <julian.rueth@fsfe.org>
Date: Fri, 8 Jul 2022 18:32:03 +0300
Subject: [PATCH] Do not vendor external dependencies

and do not hardwire clang binary path; we'll just search for it when we
are running cppast. In principle this means that the clang version we
built against and the clang version we are running are incompatible but
we can make sure with pins that this does not happen. (There is also no
ABI/API compatibility problem here.)
---
 CMakeLists.txt                   |  14 +-
 external/external.cmake          | 235 -------------------
 external/tpl/CMakeLists.txt      |  66 ------
 external/tpl/process.cpp         |  55 -----
 external/tpl/process.hpp         | 169 --------------
 external/tpl/process_unix.cpp    | 376 -------------------------------
 external/tpl/process_win.cpp     | 350 ----------------------------
 src/CMakeLists.txt               |   3 +-
 src/libclang/libclang_parser.cpp |  31 +--
 test/CMakeLists.txt              |   8 +-
 tool/CMakeLists.txt              |   2 +-
 tool/main.cpp                    |   2 -
 12 files changed, 24 insertions(+), 1287 deletions(-)
 delete mode 100644 external/external.cmake
 delete mode 100644 external/tpl/CMakeLists.txt
 delete mode 100644 external/tpl/process.cpp
 delete mode 100644 external/tpl/process.hpp
 delete mode 100644 external/tpl/process_unix.cpp
 delete mode 100644 external/tpl/process_win.cpp

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 2b44f51..1dceac8 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -29,7 +29,19 @@ else()
     set(build_tool OFF)
 endif()
 
-include(external/external.cmake)
+find_package(type_safe REQUIRED)
+find_package(Threads REQUIRED)
+
+find_package(LLVM REQUIRED CONFIG)
+
+message(STATUS "Found LLVM ${LLVM_PACKAGE_VERSION}")
+message(STATUS "Using LLVMConfig.cmake in: ${LLVM_DIR}")
+
+include_directories(${LLVM_INCLUDE_DIRS})
+separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS})
+add_definitions(${LLVM_DEFINITIONS_LIST})
+
+llvm_map_components_to_libnames(llvm_libs support core irreader)
 
 if(build_test AND CPPAST_TEST_GCOV AND (CMAKE_CXX_COMPILER_ID STREQUAL "GNU"))
     list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")
diff --git a/external/external.cmake b/external/external.cmake
deleted file mode 100644
index c42f01e..0000000
--- a/external/external.cmake
+++ /dev/null
@@ -1,235 +0,0 @@
-# Copyright (C) 2017 Jonathan Müller <jonathanmueller.dev@gmail.com>
-# SPDX-License-Identifier: MIT
-# found in the top-level directory of this distribution.
-
-include(FetchContent)
-
-#
-# install type safe
-#
-find_package(type_safe QUIET)
-if(NOT type_safe_FOUND)
-    message(STATUS "Fetching type_safe")
-    FetchContent_Declare(type_safe GIT_REPOSITORY https://github.com/foonathan/type_safe GIT_TAG origin/main)
-    FetchContent_MakeAvailable(type_safe)
-endif()
-
-#
-# install the tiny-process-library
-#
-find_package(Threads REQUIRED QUIET)
-
-# create a target here instead of using the one provided
-add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/external/tpl)
-add_library(_cppast_tiny_process INTERFACE)
-target_include_directories(_cppast_tiny_process INTERFACE ${tiny_process_dir})
-target_link_libraries(_cppast_tiny_process INTERFACE tiny-process-library::tiny-process-library Threads::Threads)
-
-#
-# install cxxopts, if needed
-#
-if(build_tool)
-    set(CXXOPTS_BUILD_TESTS OFF CACHE BOOL "")
-
-    message(STATUS "Fetching cxxopts")
-    FetchContent_Declare(cxxopts URL https://github.com/jarro2783/cxxopts/archive/v2.2.1.zip)
-    FetchContent_MakeAvailable(cxxopts)
-endif()
-
-#
-# install libclang
-#
-
-function(name_without_extension FILENAME NAME)
-    set(known_extensions "\\.tar\\.xz" "\\.tar\\.gz" "\\.tar" "\\.zip")
-
-    set(name_we "${FILENAME}")
-
-    foreach(ext ${known_extensions})
-        string(REGEX REPLACE "(.*)${ext}" "\\1" name_we "${name_we}")
-    endforeach()
-    set(${NAME} "${name_we}" PARENT_SCOPE)
-endfunction()
-
-# downloads and extracts LLVM using the given URL, filename, and extension
-# sets: LLVM_DOWNLOAD_DIR
-function(_cppast_download_llvm url)
-    get_filename_component(file "${url}" NAME)
-    name_without_extension(${file} folder)
-
-    if(NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}/${folder})
-        message(STATUS "Downloading LLVM from ${url}")
-        file(DOWNLOAD ${url} ${CMAKE_CURRENT_BINARY_DIR}/${file}
-            STATUS status
-            LOG log)
-
-        list(GET status 0 status_code)
-        list(GET status 1 status_string)
-        if(NOT status_code EQUAL 0)
-            message(FATAL_ERROR "error downloading llvm: ${status_string}" "${log}")
-        endif()
-
-        execute_process(COMMAND ${CMAKE_COMMAND} -E tar xJf ${file}
-                        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
-    endif()
-
-    set(LLVM_DOWNLOAD_DIR ${CMAKE_CURRENT_BINARY_DIR}/${folder} PARENT_SCOPE)
-endfunction()
-
-# downloads and extracts LLVM using the given version and OS name
-# sets: LLVM_DOWNLOAD_DIR
-function(_cppast_download_llvm_from_llvm_releases version os)
-    _cppast_download_llvm("http://releases.llvm.org/${version}/clang+llvm-${version}-${os}.tar.xz")
-    set(LLVM_DOWNLOAD_DIR ${LLVM_DOWNLOAD_DIR} PARENT_SCOPE)
-endfunction()
-
-# determines the llvm version from a config binary
-macro(_cppast_llvm_version output_name llvm_binary)
-    execute_process(COMMAND ${llvm_binary} --version
-                    OUTPUT_VARIABLE ${output_name} OUTPUT_STRIP_TRAILING_WHITESPACE)
-
-    # ignore git tags in the version string, get the semver number only
-    string(REGEX REPLACE "([0-9]).([0-9]).([0-9])(.*)" "\\1.\\2.\\3" ${output_name} "${${output_name}}")
-endmacro()
-
-# finds the llvm-config binary
-# sets: LLVM_CONFIG_BINARY
-function(_cppast_find_llvm_config)
-    unset(LLVM_CONFIG_BINARY CACHE)
-    if(LLVM_DOWNLOAD_DIR)
-        find_program(LLVM_CONFIG_BINARY "llvm-config" "${LLVM_DOWNLOAD_DIR}/bin" NO_DEFAULT_PATH)
-    else()
-        find_program(llvm_config_binary_no_suffix llvm-config)
-        find_program(llvm_config_binary_suffix NAMES llvm-config-10 llvm-config-9 llvm-config-8 llvm-config-7 llvm-config-6.0 llvm-config-5.0 llvm-config-4.0)
-
-        if(NOT llvm_config_binary_no_suffix)
-            set(LLVM_CONFIG_BINARY ${llvm_config_binary_suffix} CACHE INTERNAL "")
-        elseif(NOT llvm_config_binary_suffix)
-            set(LLVM_CONFIG_BINARY ${llvm_config_binary_no_suffix} CACHE INTERNAL "")
-        else()
-            # pick latest version of the two
-            _cppast_llvm_version(suffix_version ${llvm_config_binary_suffix})
-            _cppast_llvm_version(no_suffix_version ${llvm_config_binary_no_suffix})
-            if(suffix_version VERSION_GREATER no_suffix_version)
-                set(LLVM_CONFIG_BINARY ${llvm_config_binary_suffix} CACHE INTERNAL "")
-            else()
-                set(LLVM_CONFIG_BINARY ${llvm_config_binary_no_suffix} CACHE INTERNAL "")
-            endif()
-        endif()
-    endif()
-
-    if(NOT LLVM_CONFIG_BINARY)
-        message(FATAL_ERROR "Unable to find llvm-config binary, please set option LLVM_CONFIG_BINARY yourself")
-    else()
-        message(STATUS "Found llvm-config at ${LLVM_CONFIG_BINARY}")
-    endif()
-endfunction()
-
-# find libclang using the config tool
-# sets: LLVM_VERSION, LIBCLANG_INCLUDE_DIR, LIBCLANG_SYSTEM_INCLUDE_DIR, LIBCLANG_LIBRARY and CLANG_BINARY
-function(_cppast_find_libclang config_tool min_version force)
-    if (NOT EXISTS "${LLVM_CONFIG_BINARY}")
-        message(FATAL_ERROR "LLVM config binary not found at ${LLVM_CONFIG_BINARY}")
-    endif()
-
-    _cppast_llvm_version(llvm_version ${config_tool})
-    if(llvm_version VERSION_LESS min_version)
-        message(FATAL_ERROR "Outdated LLVM version ${llvm_version}, minimal supported is ${min_version}")
-    else()
-        message(STATUS "Using LLVM version ${llvm_version}")
-        set(LLVM_VERSION ${llvm_version} CACHE INTERNAL "")
-    endif()
-
-    # get include directory
-    if(${force})
-        unset(LIBCLANG_INCLUDE_DIR CACHE)
-    endif()
-    if(NOT LIBCLANG_INCLUDE_DIR)
-        execute_process(COMMAND ${config_tool} --includedir
-                        OUTPUT_VARIABLE llvm_include_dir OUTPUT_STRIP_TRAILING_WHITESPACE)
-        find_path(LIBCLANG_INCLUDE_DIR "clang-c/Index.h" "${llvm_include_dir}" NO_DEFAULT_PATH)
-
-        if(NOT LIBCLANG_INCLUDE_DIR)
-            message(FATAL_ERROR "libclang header files not found")
-        else()
-            message(STATUS "Found libclang header files at ${LIBCLANG_INCLUDE_DIR}")
-        endif()
-    endif()
-
-    # find libclang library in llvm_library_dir
-    if(${force})
-        unset(LIBCLANG_LIBRARY CACHE)
-    endif()
-    if(NOT LIBCLANG_LIBRARY)
-        execute_process(COMMAND ${config_tool} --libdir
-                        OUTPUT_VARIABLE llvm_library_dir OUTPUT_STRIP_TRAILING_WHITESPACE)
-        find_library(LIBCLANG_LIBRARY NAMES clang libclang HINTS "${llvm_library_dir}" NO_DEFAULT_PATH)
-
-        if(NOT LIBCLANG_LIBRARY)
-            message(FATAL_ERROR "libclang library not found")
-        endif()
-        message(STATUS "Found libclang library at ${LIBCLANG_LIBRARY}")
-
-        get_filename_component(ext ${LIBCLANG_LIBRARY} EXT)
-        if(UNIX AND ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang" OR "${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU") AND "${ext}" STREQUAL ".a")
-            message(STATUS "libclang will be linked statically; linking might take a long time")
-
-            # glob all libraries and put them inside a group,
-            # as the correct order cannot be determined apparently
-            file(GLOB clang_libraries "${llvm_library_dir}/libclang*.a")
-            string(REPLACE ";" " " clang_libraries "${clang_libraries}")
-            set(clang_libraries "-Wl,--start-group ${clang_libraries} -Wl,--end-group")
-
-            file(GLOB llvm_libraries "${llvm_library_dir}/libLLVM*.a")
-            string(REPLACE ";" " " llvm_libraries "${llvm_libraries}")
-            set(llvm_libraries "-Wl,--start-group ${llvm_libraries} -Wl,--end-group")
-
-            set(LIBCLANG_LIBRARY "${clang_libraries} ${llvm_libraries}" CACHE INTERNAL "")
-        endif()
-    endif()
-
-    # find clang binary in llvm_binary_dir
-    # note: never override that binary
-    if(NOT CLANG_BINARY)
-        execute_process(COMMAND ${config_tool} --bindir
-                        OUTPUT_VARIABLE llvm_binary_dir OUTPUT_STRIP_TRAILING_WHITESPACE)
-        find_program(CLANG_BINARY "clang" "${llvm_binary_dir}" NO_DEFAULT_PATH)
-
-        if(NOT CLANG_BINARY)
-            message(FATAL_ERROR "clang binary not found")
-        else()
-            message(STATUS "Found clang binary at ${CLANG_BINARY}")
-        endif()
-    endif()
-endfunction()
-
-set(llvm_min_version 4.0.0)
-
-if(NOT DEFINED LLVM_PREFERRED_VERSION)
-    set(LLVM_PREFERRED_VERSION 4.0.0 CACHE STRING "the preferred LLVM version")
-endif()
-
-if(DEFINED LLVM_VERSION_EXPLICIT)
-    if(LLVM_VERSION_EXPLICIT VERSION_LESS llvm_min_version)
-        message(FATAL_ERROR "Outdated LLVM version ${LLVM_VERSION_EXPLICIT}, minimal supported is ${llvm_min_version}")
-    endif()
-    set(LLVM_VERSION ${LLVM_VERSION_EXPLICIT} CACHE INTERNAL "")
-    message(STATUS "Using manually specified LLVM version ${LLVM_VERSION}")
-elseif(NOT LLVM_CONFIG_BINARY)
-    if(DEFINED LLVM_DOWNLOAD_OS_NAME)
-        _cppast_download_llvm_from_llvm_releases(${LLVM_PREFERRED_VERSION} ${LLVM_DOWNLOAD_OS_NAME})
-    elseif(DEFINED LLVM_DOWNLOAD_URL)
-        _cppast_download_llvm(${LLVM_DOWNLOAD_URL})
-    endif()
-    _cppast_find_llvm_config()
-    _cppast_find_libclang(${LLVM_CONFIG_BINARY} ${llvm_min_version} 1) # override here
-else()
-    _cppast_find_libclang(${LLVM_CONFIG_BINARY} ${llvm_min_version} 0)
-endif()
-
-add_library(_cppast_libclang INTERFACE)
-target_link_libraries(_cppast_libclang INTERFACE ${LIBCLANG_LIBRARY})
-target_include_directories(_cppast_libclang INTERFACE ${LIBCLANG_INCLUDE_DIR})
-target_compile_definitions(_cppast_libclang INTERFACE
-                           CPPAST_CLANG_BINARY="${CLANG_BINARY}"
-                           CPPAST_CLANG_VERSION_STRING="${LLVM_VERSION}")
diff --git a/external/tpl/CMakeLists.txt b/external/tpl/CMakeLists.txt
deleted file mode 100644
index 8662ba3..0000000
--- a/external/tpl/CMakeLists.txt
+++ /dev/null
@@ -1,66 +0,0 @@
-cmake_minimum_required(VERSION 3.1)
-
-project(tiny-process-library)
-
-if(CMAKE_SOURCE_DIR STREQUAL "${CMAKE_CURRENT_SOURCE_DIR}")
-  option(BUILD_TESTING "set ON to build library tests" ON)
-else()
-  option(BUILD_TESTING "set ON to build library tests" OFF)
-endif()
-
-add_library(tiny-process-library process.cpp)
-add_library(tiny-process-library::tiny-process-library ALIAS tiny-process-library)
-
-if(MSVC)
-  target_compile_definitions(tiny-process-library PRIVATE /D_CRT_SECURE_NO_WARNINGS)
-else()
-  target_compile_options(tiny-process-library PRIVATE -std=c++11 -Wall -Wextra)
-endif()
-
-if(WIN32)
-  set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)
-  target_sources(tiny-process-library PRIVATE process_win.cpp)
-  #If compiled using MSYS2, use sh to run commands
-  if(MSYS)
-    target_compile_definitions(tiny-process-library PUBLIC MSYS_PROCESS_USE_SH)
-  endif()
-else()
-  target_sources(tiny-process-library PRIVATE process_unix.cpp)
-endif()
-
-find_package(Threads REQUIRED)
-
-target_link_libraries(tiny-process-library ${CMAKE_THREAD_LIBS_INIT})
-target_include_directories(tiny-process-library PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
-                                                       $<INSTALL_INTERFACE:include>)
-
-# if tiny-process-library is not a sub-project:
-if(CMAKE_SOURCE_DIR STREQUAL "${CMAKE_CURRENT_SOURCE_DIR}")
-  if(MSVC)
-    add_definitions(/D_CRT_SECURE_NO_WARNINGS)
-  else()
-    add_compile_options(-std=c++11 -Wall -Wextra)
-  endif()
-
-  add_executable(examples examples.cpp)
-  target_link_libraries(examples tiny-process-library)
-  
-  install(TARGETS tiny-process-library
-    EXPORT ${PROJECT_NAME}-config
-    ARCHIVE DESTINATION lib
-    LIBRARY DESTINATION lib
-    RUNTIME DESTINATION bin)
-
-  install(EXPORT ${PROJECT_NAME}-config
-    FILE ${PROJECT_NAME}-config.cmake
-    NAMESPACE ${PROJECT_NAME}::
-    DESTINATION lib/cmake/${PROJECT_NAME}
-  )
-
-  install(FILES process.hpp DESTINATION include)
-endif()
-
-if(BUILD_TESTING)
-  enable_testing()
-  add_subdirectory(tests)
-endif()
diff --git a/external/tpl/process.cpp b/external/tpl/process.cpp
deleted file mode 100644
index a68e518..0000000
--- a/external/tpl/process.cpp
+++ /dev/null
@@ -1,55 +0,0 @@
-#include "process.hpp"
-
-namespace TinyProcessLib {
-
-Process::Process(const std::vector<string_type> &arguments, const string_type &path,
-                 std::function<void(const char *bytes, size_t n)> read_stdout,
-                 std::function<void(const char *bytes, size_t n)> read_stderr,
-                 bool open_stdin, const Config &config) noexcept
-    : closed(true), read_stdout(std::move(read_stdout)), read_stderr(std::move(read_stderr)), open_stdin(open_stdin), config(config) {
-  open(arguments, path);
-  async_read();
-}
-
-Process::Process(const string_type &command, const string_type &path,
-                 std::function<void(const char *bytes, size_t n)> read_stdout,
-                 std::function<void(const char *bytes, size_t n)> read_stderr,
-                 bool open_stdin, const Config &config) noexcept
-    : closed(true), read_stdout(std::move(read_stdout)), read_stderr(std::move(read_stderr)), open_stdin(open_stdin), config(config) {
-  open(command, path);
-  async_read();
-}
-
-Process::Process(const std::vector<string_type> &arguments, const string_type &path,
-                 const environment_type &environment,
-                 std::function<void(const char *bytes, size_t n)> read_stdout,
-                 std::function<void(const char *bytes, size_t n)> read_stderr,
-                 bool open_stdin, const Config &config) noexcept
-    : closed(true), read_stdout(std::move(read_stdout)), read_stderr(std::move(read_stderr)), open_stdin(open_stdin), config(config) {
-  open(arguments, path, &environment);
-  async_read();
-}
-
-Process::Process(const string_type &command, const string_type &path,
-                 const environment_type &environment,
-                 std::function<void(const char *bytes, size_t n)> read_stdout,
-                 std::function<void(const char *bytes, size_t n)> read_stderr,
-                 bool open_stdin, const Config &config) noexcept
-    : closed(true), read_stdout(std::move(read_stdout)), read_stderr(std::move(read_stderr)), open_stdin(open_stdin), config(config) {
-  open(command, path, &environment);
-  async_read();
-}
-
-Process::~Process() noexcept {
-  close_fds();
-}
-
-Process::id_type Process::get_id() const noexcept {
-  return data.id;
-}
-
-bool Process::write(const std::string &str) {
-  return write(str.c_str(), str.size());
-}
-
-} // namespace TinyProcessLib
diff --git a/external/tpl/process.hpp b/external/tpl/process.hpp
deleted file mode 100644
index ad1ab3a..0000000
--- a/external/tpl/process.hpp
+++ /dev/null
@@ -1,169 +0,0 @@
-#ifndef TINY_PROCESS_LIBRARY_HPP_
-#define TINY_PROCESS_LIBRARY_HPP_
-#include <functional>
-#include <memory>
-#include <mutex>
-#include <string>
-#include <thread>
-#include <unordered_map>
-#include <vector>
-#ifndef _WIN32
-#include <sys/wait.h>
-#endif
-
-namespace TinyProcessLib {
-/// Additional parameters to Process constructors.
-struct Config {
-  /// Buffer size for reading stdout and stderr. Default is 131072 (128 kB).
-  std::size_t buffer_size = 131072;
-  /// Set to true to inherit file descriptors from parent process. Default is false.
-  /// On Windows: has no effect unless read_stdout==nullptr, read_stderr==nullptr and open_stdin==false.
-  bool inherit_file_descriptors = false;
-
-  /// On Windows only: controls how the process is started, mimics STARTUPINFO's wShowWindow.
-  /// See: https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa
-  /// and https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-showwindow
-  enum class ShowWindow {
-    hide = 0,
-    show_normal = 1,
-    show_minimized = 2,
-    maximize = 3,
-    show_maximized = 3,
-    show_no_activate = 4,
-    show = 5,
-    minimize = 6,
-    show_min_no_active = 7,
-    show_na = 8,
-    restore = 9,
-    show_default = 10,
-    force_minimize = 11
-  };
-  /// On Windows only: controls how the window is shown.
-  ShowWindow show_window{ShowWindow::show_default};
-};
-
-/// Platform independent class for creating processes.
-/// Note on Windows: it seems not possible to specify which pipes to redirect.
-/// Thus, at the moment, if read_stdout==nullptr, read_stderr==nullptr and open_stdin==false,
-/// the stdout, stderr and stdin are sent to the parent process instead.
-class Process {
-public:
-#ifdef _WIN32
-  typedef unsigned long id_type; // Process id type
-  typedef void *fd_type;         // File descriptor type
-#ifdef UNICODE
-  typedef std::wstring string_type;
-#else
-  typedef std::string string_type;
-#endif
-#else
-  typedef pid_t id_type;
-  typedef int fd_type;
-  typedef std::string string_type;
-#endif
-  typedef std::unordered_map<string_type, string_type> environment_type;
-
-private:
-  class Data {
-  public:
-    Data() noexcept;
-    id_type id;
-#ifdef _WIN32
-    void *handle{nullptr};
-#endif
-    int exit_status{-1};
-  };
-
-public:
-  /// Starts a process with the environment of the calling process.
-  Process(const std::vector<string_type> &arguments, const string_type &path = string_type(),
-          std::function<void(const char *bytes, size_t n)> read_stdout = nullptr,
-          std::function<void(const char *bytes, size_t n)> read_stderr = nullptr,
-          bool open_stdin = false,
-          const Config &config = {}) noexcept;
-  /// Starts a process with the environment of the calling process.
-  Process(const string_type &command, const string_type &path = string_type(),
-          std::function<void(const char *bytes, size_t n)> read_stdout = nullptr,
-          std::function<void(const char *bytes, size_t n)> read_stderr = nullptr,
-          bool open_stdin = false,
-          const Config &config = {}) noexcept;
-
-  /// Starts a process with specified environment.
-  Process(const std::vector<string_type> &arguments,
-          const string_type &path,
-          const environment_type &environment,
-          std::function<void(const char *bytes, size_t n)> read_stdout = nullptr,
-          std::function<void(const char *bytes, size_t n)> read_stderr = nullptr,
-          bool open_stdin = false,
-          const Config &config = {}) noexcept;
-  /// Starts a process with specified environment.
-  Process(const string_type &command,
-          const string_type &path,
-          const environment_type &environment,
-          std::function<void(const char *bytes, size_t n)> read_stdout = nullptr,
-          std::function<void(const char *bytes, size_t n)> read_stderr = nullptr,
-          bool open_stdin = false,
-          const Config &config = {}) noexcept; /// Starts a process with specified environment.
-#ifndef _WIN32
-  /// Starts a process with the environment of the calling process.
-  /// Supported on Unix-like systems only.
-  Process(const std::function<void()> &function,
-          std::function<void(const char *bytes, size_t n)> read_stdout = nullptr,
-          std::function<void(const char *bytes, size_t n)> read_stderr = nullptr,
-          bool open_stdin = false,
-          const Config &config = {}) noexcept;
-#endif
-  ~Process() noexcept;
-
-  /// Get the process id of the started process.
-  id_type get_id() const noexcept;
-  /// Wait until process is finished, and return exit status.
-  int get_exit_status() noexcept;
-  /// If process is finished, returns true and sets the exit status. Returns false otherwise.
-  bool try_get_exit_status(int &exit_status) noexcept;
-  /// Write to stdin.
-  bool write(const char *bytes, size_t n);
-  /// Write to stdin. Convenience function using write(const char *, size_t).
-  bool write(const std::string &str);
-  /// Close stdin. If the process takes parameters from stdin, use this to notify that all parameters have been sent.
-  void close_stdin() noexcept;
-
-  /// Kill the process. force=true is only supported on Unix-like systems.
-  void kill(bool force = false) noexcept;
-  /// Kill a given process id. Use kill(bool force) instead if possible. force=true is only supported on Unix-like systems.
-  static void kill(id_type id, bool force = false) noexcept;
-#ifndef _WIN32
-  /// Send the signal signum to the process.
-  void signal(int signum) noexcept;
-#endif
-
-private:
-  Data data;
-  bool closed;
-  std::mutex close_mutex;
-  std::function<void(const char *bytes, size_t n)> read_stdout;
-  std::function<void(const char *bytes, size_t n)> read_stderr;
-#ifndef _WIN32
-  std::thread stdout_stderr_thread;
-#else
-  std::thread stdout_thread, stderr_thread;
-#endif
-  bool open_stdin;
-  std::mutex stdin_mutex;
-
-  Config config;
-
-  std::unique_ptr<fd_type> stdout_fd, stderr_fd, stdin_fd;
-
-  id_type open(const std::vector<string_type> &arguments, const string_type &path, const environment_type *environment = nullptr) noexcept;
-  id_type open(const string_type &command, const string_type &path, const environment_type *environment = nullptr) noexcept;
-#ifndef _WIN32
-  id_type open(const std::function<void()> &function) noexcept;
-#endif
-  void async_read() noexcept;
-  void close_fds() noexcept;
-};
-
-} // namespace TinyProcessLib
-
-#endif // TINY_PROCESS_LIBRARY_HPP_
diff --git a/external/tpl/process_unix.cpp b/external/tpl/process_unix.cpp
deleted file mode 100644
index 01d6ca1..0000000
--- a/external/tpl/process_unix.cpp
+++ /dev/null
@@ -1,376 +0,0 @@
-#include "process.hpp"
-#include <algorithm>
-#include <bitset>
-#include <cstdlib>
-#include <fcntl.h>
-#include <poll.h>
-#include <set>
-#include <signal.h>
-#include <stdexcept>
-#include <unistd.h>
-
-namespace TinyProcessLib {
-
-Process::Data::Data() noexcept : id(-1) {}
-
-Process::Process(const std::function<void()> &function,
-                 std::function<void(const char *, size_t)> read_stdout,
-                 std::function<void(const char *, size_t)> read_stderr,
-                 bool open_stdin, const Config &config) noexcept
-    : closed(true), read_stdout(std::move(read_stdout)), read_stderr(std::move(read_stderr)), open_stdin(open_stdin), config(config) {
-  open(function);
-  async_read();
-}
-
-Process::id_type Process::open(const std::function<void()> &function) noexcept {
-  if(open_stdin)
-    stdin_fd = std::unique_ptr<fd_type>(new fd_type);
-  if(read_stdout)
-    stdout_fd = std::unique_ptr<fd_type>(new fd_type);
-  if(read_stderr)
-    stderr_fd = std::unique_ptr<fd_type>(new fd_type);
-
-  int stdin_p[2], stdout_p[2], stderr_p[2];
-
-  if(stdin_fd && pipe(stdin_p) != 0)
-    return -1;
-  if(stdout_fd && pipe(stdout_p) != 0) {
-    if(stdin_fd) {
-      close(stdin_p[0]);
-      close(stdin_p[1]);
-    }
-    return -1;
-  }
-  if(stderr_fd && pipe(stderr_p) != 0) {
-    if(stdin_fd) {
-      close(stdin_p[0]);
-      close(stdin_p[1]);
-    }
-    if(stdout_fd) {
-      close(stdout_p[0]);
-      close(stdout_p[1]);
-    }
-    return -1;
-  }
-
-  id_type pid = fork();
-
-  if(pid < 0) {
-    if(stdin_fd) {
-      close(stdin_p[0]);
-      close(stdin_p[1]);
-    }
-    if(stdout_fd) {
-      close(stdout_p[0]);
-      close(stdout_p[1]);
-    }
-    if(stderr_fd) {
-      close(stderr_p[0]);
-      close(stderr_p[1]);
-    }
-    return pid;
-  }
-  else if(pid == 0) {
-    if(stdin_fd)
-      dup2(stdin_p[0], 0);
-    if(stdout_fd)
-      dup2(stdout_p[1], 1);
-    if(stderr_fd)
-      dup2(stderr_p[1], 2);
-    if(stdin_fd) {
-      close(stdin_p[0]);
-      close(stdin_p[1]);
-    }
-    if(stdout_fd) {
-      close(stdout_p[0]);
-      close(stdout_p[1]);
-    }
-    if(stderr_fd) {
-      close(stderr_p[0]);
-      close(stderr_p[1]);
-    }
-
-    if(!config.inherit_file_descriptors) {
-      // Optimization on some systems: using 8 * 1024 (Debian's default _SC_OPEN_MAX) as fd_max limit
-      int fd_max = std::min(8192, static_cast<int>(sysconf(_SC_OPEN_MAX))); // Truncation is safe
-      if(fd_max < 0)
-        fd_max = 8192;
-      for(int fd = 3; fd < fd_max; fd++)
-        close(fd);
-    }
-
-    setpgid(0, 0);
-    //TODO: See here on how to emulate tty for colors: http://stackoverflow.com/questions/1401002/trick-an-application-into-thinking-its-stdin-is-interactive-not-a-pipe
-    //TODO: One solution is: echo "command;exit"|script -q /dev/null
-
-    if(function)
-      function();
-
-    _exit(EXIT_FAILURE);
-  }
-
-  if(stdin_fd)
-    close(stdin_p[0]);
-  if(stdout_fd)
-    close(stdout_p[1]);
-  if(stderr_fd)
-    close(stderr_p[1]);
-
-  if(stdin_fd)
-    *stdin_fd = stdin_p[1];
-  if(stdout_fd)
-    *stdout_fd = stdout_p[0];
-  if(stderr_fd)
-    *stderr_fd = stderr_p[0];
-
-  closed = false;
-  data.id = pid;
-  return pid;
-}
-
-Process::id_type Process::open(const std::vector<string_type> &arguments, const string_type &path, const environment_type *environment) noexcept {
-  return open([&arguments, &path, &environment] {
-    if(arguments.empty())
-      exit(127);
-
-    std::vector<const char *> argv_ptrs;
-    argv_ptrs.reserve(arguments.size() + 1);
-    for(auto &argument : arguments)
-      argv_ptrs.emplace_back(argument.c_str());
-    argv_ptrs.emplace_back(nullptr);
-
-    if(!path.empty()) {
-      if(chdir(path.c_str()) != 0)
-        exit(1);
-    }
-
-    if(!environment)
-      execv(arguments[0].c_str(), const_cast<char *const *>(argv_ptrs.data()));
-    else {
-      std::vector<std::string> env_strs;
-      std::vector<const char *> env_ptrs;
-      env_strs.reserve(environment->size());
-      env_ptrs.reserve(environment->size() + 1);
-      for(const auto &e : *environment) {
-        env_strs.emplace_back(e.first + '=' + e.second);
-        env_ptrs.emplace_back(env_strs.back().c_str());
-      }
-      env_ptrs.emplace_back(nullptr);
-
-      execve(arguments[0].c_str(), const_cast<char *const *>(argv_ptrs.data()), const_cast<char *const *>(env_ptrs.data()));
-    }
-  });
-}
-
-Process::id_type Process::open(const std::string &command, const std::string &path, const environment_type *environment) noexcept {
-  return open([&command, &path, &environment] {
-    auto command_c_str = command.c_str();
-    std::string cd_path_and_command;
-    if(!path.empty()) {
-      auto path_escaped = path;
-      size_t pos = 0;
-      // Based on https://www.reddit.com/r/cpp/comments/3vpjqg/a_new_platform_independent_process_library_for_c11/cxsxyb7
-      while((pos = path_escaped.find('\'', pos)) != std::string::npos) {
-        path_escaped.replace(pos, 1, "'\\''");
-        pos += 4;
-      }
-      cd_path_and_command = "cd '" + path_escaped + "' && " + command; // To avoid resolving symbolic links
-      command_c_str = cd_path_and_command.c_str();
-    }
-
-    if(!environment)
-      execl("/bin/sh", "/bin/sh", "-c", command_c_str, nullptr);
-    else {
-      std::vector<std::string> env_strs;
-      std::vector<const char *> env_ptrs;
-      env_strs.reserve(environment->size());
-      env_ptrs.reserve(environment->size() + 1);
-      for(const auto &e : *environment) {
-        env_strs.emplace_back(e.first + '=' + e.second);
-        env_ptrs.emplace_back(env_strs.back().c_str());
-      }
-      env_ptrs.emplace_back(nullptr);
-      execle("/bin/sh", "/bin/sh", "-c", command_c_str, nullptr, env_ptrs.data());
-    }
-  });
-}
-
-void Process::async_read() noexcept {
-  if(data.id <= 0 || (!stdout_fd && !stderr_fd))
-    return;
-
-  stdout_stderr_thread = std::thread([this] {
-    std::vector<pollfd> pollfds;
-    std::bitset<2> fd_is_stdout;
-    if(stdout_fd) {
-      fd_is_stdout.set(pollfds.size());
-      pollfds.emplace_back();
-      pollfds.back().fd = fcntl(*stdout_fd, F_SETFL, fcntl(*stdout_fd, F_GETFL) | O_NONBLOCK) == 0 ? *stdout_fd : -1;
-      pollfds.back().events = POLLIN;
-    }
-    if(stderr_fd) {
-      pollfds.emplace_back();
-      pollfds.back().fd = fcntl(*stderr_fd, F_SETFL, fcntl(*stderr_fd, F_GETFL) | O_NONBLOCK) == 0 ? *stderr_fd : -1;
-      pollfds.back().events = POLLIN;
-    }
-    auto buffer = std::unique_ptr<char[]>(new char[config.buffer_size]);
-    bool any_open = !pollfds.empty();
-    while(any_open && (poll(pollfds.data(), static_cast<nfds_t>(pollfds.size()), -1) > 0 || errno == EINTR)) {
-      any_open = false;
-      for(size_t i = 0; i < pollfds.size(); ++i) {
-        if(pollfds[i].fd >= 0) {
-          if(pollfds[i].revents & POLLIN) {
-            const ssize_t n = read(pollfds[i].fd, buffer.get(), config.buffer_size);
-            if(n > 0) {
-              if(fd_is_stdout[i])
-                read_stdout(buffer.get(), static_cast<size_t>(n));
-              else
-                read_stderr(buffer.get(), static_cast<size_t>(n));
-            }
-            else if(n < 0 && errno != EINTR && errno != EAGAIN && errno != EWOULDBLOCK) {
-              pollfds[i].fd = -1;
-              continue;
-            }
-          }
-          if(pollfds[i].revents & (POLLERR | POLLHUP | POLLNVAL)) {
-            pollfds[i].fd = -1;
-            continue;
-          }
-          any_open = true;
-        }
-      }
-    }
-  });
-}
-
-int Process::get_exit_status() noexcept {
-  if(data.id <= 0)
-    return -1;
-
-  int exit_status;
-  id_type pid;
-  do {
-    pid = waitpid(data.id, &exit_status, 0);
-  } while(pid < 0 && errno == EINTR);
-
-  if(pid < 0 && errno == ECHILD) {
-    // PID doesn't exist anymore, return previously sampled exit status (or -1)
-    return data.exit_status;
-  }
-  else {
-    // Store exit status for future calls
-    if(exit_status >= 256)
-      exit_status = exit_status >> 8;
-    data.exit_status = exit_status;
-  }
-
-  {
-    std::lock_guard<std::mutex> lock(close_mutex);
-    closed = true;
-  }
-  close_fds();
-
-  return exit_status;
-}
-
-bool Process::try_get_exit_status(int &exit_status) noexcept {
-  if(data.id <= 0)
-    return false;
-
-  const id_type pid = waitpid(data.id, &exit_status, WNOHANG);
-  if(pid < 0 && errno == ECHILD) {
-    // PID doesn't exist anymore, set previously sampled exit status (or -1)
-    exit_status = data.exit_status;
-    return true;
-  }
-  else if(pid <= 0) {
-    // Process still running (p==0) or error
-    return false;
-  }
-  else {
-    // store exit status for future calls
-    if(exit_status >= 256)
-      exit_status = exit_status >> 8;
-    data.exit_status = exit_status;
-  }
-
-  {
-    std::lock_guard<std::mutex> lock(close_mutex);
-    closed = true;
-  }
-  close_fds();
-
-  return true;
-}
-
-void Process::close_fds() noexcept {
-  if(stdout_stderr_thread.joinable())
-    stdout_stderr_thread.join();
-
-  if(stdin_fd)
-    close_stdin();
-  if(stdout_fd) {
-    if(data.id > 0)
-      close(*stdout_fd);
-    stdout_fd.reset();
-  }
-  if(stderr_fd) {
-    if(data.id > 0)
-      close(*stderr_fd);
-    stderr_fd.reset();
-  }
-}
-
-bool Process::write(const char *bytes, size_t n) {
-  if(!open_stdin)
-    throw std::invalid_argument("Can't write to an unopened stdin pipe. Please set open_stdin=true when constructing the process.");
-
-  std::lock_guard<std::mutex> lock(stdin_mutex);
-  if(stdin_fd) {
-    if(::write(*stdin_fd, bytes, n) >= 0) {
-      return true;
-    }
-    else {
-      return false;
-    }
-  }
-  return false;
-}
-
-void Process::close_stdin() noexcept {
-  std::lock_guard<std::mutex> lock(stdin_mutex);
-  if(stdin_fd) {
-    if(data.id > 0)
-      close(*stdin_fd);
-    stdin_fd.reset();
-  }
-}
-
-void Process::kill(bool force) noexcept {
-  std::lock_guard<std::mutex> lock(close_mutex);
-  if(data.id > 0 && !closed) {
-    if(force)
-      ::kill(-data.id, SIGTERM);
-    else
-      ::kill(-data.id, SIGINT);
-  }
-}
-
-void Process::kill(id_type id, bool force) noexcept {
-  if(id <= 0)
-    return;
-
-  if(force)
-    ::kill(-id, SIGTERM);
-  else
-    ::kill(-id, SIGINT);
-}
-
-void Process::signal(int signum) noexcept {
-  std::lock_guard<std::mutex> lock(close_mutex);
-  if(data.id > 0 && !closed) {
-    ::kill(-data.id, signum);
-  }
-}
-
-} // namespace TinyProcessLib
diff --git a/external/tpl/process_win.cpp b/external/tpl/process_win.cpp
deleted file mode 100644
index 305289a..0000000
--- a/external/tpl/process_win.cpp
+++ /dev/null
@@ -1,350 +0,0 @@
-#include "process.hpp"
-// clang-format off
-#include <windows.h>
-// clang-format on
-#include <tlhelp32.h>
-#include <cstring>
-#include <stdexcept>
-
-namespace TinyProcessLib {
-
-Process::Data::Data() noexcept : id(0) {}
-
-// Simple HANDLE wrapper to close it automatically from the destructor.
-class Handle {
-public:
-  Handle() noexcept : handle(INVALID_HANDLE_VALUE) {}
-  ~Handle() noexcept {
-    close();
-  }
-  void close() noexcept {
-    if(handle != INVALID_HANDLE_VALUE)
-      CloseHandle(handle);
-  }
-  HANDLE detach() noexcept {
-    HANDLE old_handle = handle;
-    handle = INVALID_HANDLE_VALUE;
-    return old_handle;
-  }
-  operator HANDLE() const noexcept { return handle; }
-  HANDLE *operator&() noexcept { return &handle; }
-
-private:
-  HANDLE handle;
-};
-
-//Based on the discussion thread: https://www.reddit.com/r/cpp/comments/3vpjqg/a_new_platform_independent_process_library_for_c11/cxq1wsj
-std::mutex create_process_mutex;
-
-Process::id_type Process::open(const std::vector<string_type> &arguments, const string_type &path, const environment_type *environment) noexcept {
-  string_type command;
-  for(auto &argument : arguments)
-#ifdef UNICODE
-    command += (command.empty() ? L"" : L" ") + argument;
-#else
-    command += (command.empty() ? "" : " ") + argument;
-#endif
-  return open(command, path, environment);
-}
-
-//Based on the example at https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499(v=vs.85).aspx.
-Process::id_type Process::open(const string_type &command, const string_type &path, const environment_type *environment) noexcept {
-  if(open_stdin)
-    stdin_fd = std::unique_ptr<fd_type>(new fd_type(nullptr));
-  if(read_stdout)
-    stdout_fd = std::unique_ptr<fd_type>(new fd_type(nullptr));
-  if(read_stderr)
-    stderr_fd = std::unique_ptr<fd_type>(new fd_type(nullptr));
-
-  Handle stdin_rd_p;
-  Handle stdin_wr_p;
-  Handle stdout_rd_p;
-  Handle stdout_wr_p;
-  Handle stderr_rd_p;
-  Handle stderr_wr_p;
-
-  SECURITY_ATTRIBUTES security_attributes;
-
-  security_attributes.nLength = sizeof(SECURITY_ATTRIBUTES);
-  security_attributes.bInheritHandle = TRUE;
-  security_attributes.lpSecurityDescriptor = nullptr;
-
-  std::lock_guard<std::mutex> lock(create_process_mutex);
-  if(stdin_fd) {
-    if(!CreatePipe(&stdin_rd_p, &stdin_wr_p, &security_attributes, 0) ||
-       !SetHandleInformation(stdin_wr_p, HANDLE_FLAG_INHERIT, 0))
-      return 0;
-  }
-  if(stdout_fd) {
-    if(!CreatePipe(&stdout_rd_p, &stdout_wr_p, &security_attributes, 0) ||
-       !SetHandleInformation(stdout_rd_p, HANDLE_FLAG_INHERIT, 0)) {
-      return 0;
-    }
-  }
-  if(stderr_fd) {
-    if(!CreatePipe(&stderr_rd_p, &stderr_wr_p, &security_attributes, 0) ||
-       !SetHandleInformation(stderr_rd_p, HANDLE_FLAG_INHERIT, 0)) {
-      return 0;
-    }
-  }
-
-  PROCESS_INFORMATION process_info;
-  STARTUPINFO startup_info;
-
-  ZeroMemory(&process_info, sizeof(PROCESS_INFORMATION));
-
-  ZeroMemory(&startup_info, sizeof(STARTUPINFO));
-  startup_info.cb = sizeof(STARTUPINFO);
-  startup_info.hStdInput = stdin_rd_p;
-  startup_info.hStdOutput = stdout_wr_p;
-  startup_info.hStdError = stderr_wr_p;
-  if(stdin_fd || stdout_fd || stderr_fd)
-    startup_info.dwFlags |= STARTF_USESTDHANDLES;
-
-  if(config.show_window != Config::ShowWindow::show_default) {
-    startup_info.dwFlags |= STARTF_USESHOWWINDOW;
-    startup_info.wShowWindow = static_cast<WORD>(config.show_window);
-  }
-
-  auto process_command = command;
-#ifdef MSYS_PROCESS_USE_SH
-  size_t pos = 0;
-  while((pos = process_command.find('\\', pos)) != string_type::npos) {
-    process_command.replace(pos, 1, "\\\\\\\\");
-    pos += 4;
-  }
-  pos = 0;
-  while((pos = process_command.find('\"', pos)) != string_type::npos) {
-    process_command.replace(pos, 1, "\\\"");
-    pos += 2;
-  }
-  process_command.insert(0, "sh -c \"");
-  process_command += "\"";
-#endif
-
-  string_type environment_str;
-  if(environment) {
-#ifdef UNICODE
-    for(const auto &e : *environment)
-      environment_str += e.first + L'=' + e.second + L'\0';
-    environment_str += L'\0';
-#else
-    for(const auto &e : *environment)
-      environment_str += e.first + '=' + e.second + '\0';
-    environment_str += '\0';
-#endif
-  }
-  BOOL bSuccess = CreateProcess(nullptr, process_command.empty() ? nullptr : &process_command[0], nullptr, nullptr,
-                                stdin_fd || stdout_fd || stderr_fd || config.inherit_file_descriptors, // Cannot be false when stdout, stderr or stdin is used
-                                stdin_fd || stdout_fd || stderr_fd ? CREATE_NO_WINDOW : 0,             // CREATE_NO_WINDOW cannot be used when stdout or stderr is redirected to parent process
-                                environment_str.empty() ? nullptr : &environment_str[0],
-                                path.empty() ? nullptr : path.c_str(),
-                                &startup_info, &process_info);
-
-  if(!bSuccess)
-    return 0;
-  else
-    CloseHandle(process_info.hThread);
-
-  if(stdin_fd)
-    *stdin_fd = stdin_wr_p.detach();
-  if(stdout_fd)
-    *stdout_fd = stdout_rd_p.detach();
-  if(stderr_fd)
-    *stderr_fd = stderr_rd_p.detach();
-
-  closed = false;
-  data.id = process_info.dwProcessId;
-  data.handle = process_info.hProcess;
-  return process_info.dwProcessId;
-}
-
-void Process::async_read() noexcept {
-  if(data.id == 0)
-    return;
-
-  if(stdout_fd) {
-    stdout_thread = std::thread([this]() {
-      DWORD n;
-      std::unique_ptr<char[]> buffer(new char[config.buffer_size]);
-      for(;;) {
-        BOOL bSuccess = ReadFile(*stdout_fd, static_cast<CHAR *>(buffer.get()), static_cast<DWORD>(config.buffer_size), &n, nullptr);
-        if(!bSuccess || n == 0)
-          break;
-        read_stdout(buffer.get(), static_cast<size_t>(n));
-      }
-    });
-  }
-  if(stderr_fd) {
-    stderr_thread = std::thread([this]() {
-      DWORD n;
-      std::unique_ptr<char[]> buffer(new char[config.buffer_size]);
-      for(;;) {
-        BOOL bSuccess = ReadFile(*stderr_fd, static_cast<CHAR *>(buffer.get()), static_cast<DWORD>(config.buffer_size), &n, nullptr);
-        if(!bSuccess || n == 0)
-          break;
-        read_stderr(buffer.get(), static_cast<size_t>(n));
-      }
-    });
-  }
-}
-
-int Process::get_exit_status() noexcept {
-  if(data.id == 0)
-    return -1;
-
-  if(!data.handle)
-    return data.exit_status;
-
-  WaitForSingleObject(data.handle, INFINITE);
-
-  DWORD exit_status;
-  if(!GetExitCodeProcess(data.handle, &exit_status))
-    data.exit_status = -1; // Store exit status for future calls
-  else
-    data.exit_status = static_cast<int>(exit_status); // Store exit status for future calls
-
-  {
-    std::lock_guard<std::mutex> lock(close_mutex);
-    CloseHandle(data.handle);
-    data.handle = nullptr;
-    closed = true;
-  }
-  close_fds();
-
-  return data.exit_status;
-}
-
-bool Process::try_get_exit_status(int &exit_status) noexcept {
-  if(data.id == 0)
-    return false;
-
-  if(!data.handle) {
-    exit_status = data.exit_status;
-    return true;
-  }
-
-  DWORD wait_status = WaitForSingleObject(data.handle, 0);
-  if(wait_status == WAIT_TIMEOUT)
-    return false;
-
-  DWORD exit_status_tmp;
-  if(!GetExitCodeProcess(data.handle, &exit_status_tmp))
-    exit_status = -1;
-  else
-    exit_status = static_cast<int>(exit_status_tmp);
-  data.exit_status = exit_status; // Store exit status for future calls
-
-  {
-    std::lock_guard<std::mutex> lock(close_mutex);
-    CloseHandle(data.handle);
-    data.handle = nullptr;
-    closed = true;
-  }
-  close_fds();
-
-  return true;
-}
-
-void Process::close_fds() noexcept {
-  if(stdout_thread.joinable())
-    stdout_thread.join();
-  if(stderr_thread.joinable())
-    stderr_thread.join();
-
-  if(stdin_fd)
-    close_stdin();
-  if(stdout_fd) {
-    if(*stdout_fd != nullptr)
-      CloseHandle(*stdout_fd);
-    stdout_fd.reset();
-  }
-  if(stderr_fd) {
-    if(*stderr_fd != nullptr)
-      CloseHandle(*stderr_fd);
-    stderr_fd.reset();
-  }
-}
-
-bool Process::write(const char *bytes, size_t n) {
-  if(!open_stdin)
-    throw std::invalid_argument("Can't write to an unopened stdin pipe. Please set open_stdin=true when constructing the process.");
-
-  std::lock_guard<std::mutex> lock(stdin_mutex);
-  if(stdin_fd) {
-    DWORD written;
-    BOOL bSuccess = WriteFile(*stdin_fd, bytes, static_cast<DWORD>(n), &written, nullptr);
-    if(!bSuccess || written == 0) {
-      return false;
-    }
-    else {
-      return true;
-    }
-  }
-  return false;
-}
-
-void Process::close_stdin() noexcept {
-  std::lock_guard<std::mutex> lock(stdin_mutex);
-  if(stdin_fd) {
-    if(*stdin_fd != nullptr)
-      CloseHandle(*stdin_fd);
-    stdin_fd.reset();
-  }
-}
-
-//Based on http://stackoverflow.com/a/1173396
-void Process::kill(bool /*force*/) noexcept {
-  std::lock_guard<std::mutex> lock(close_mutex);
-  if(data.id > 0 && !closed) {
-    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
-    if(snapshot) {
-      PROCESSENTRY32 process;
-      ZeroMemory(&process, sizeof(process));
-      process.dwSize = sizeof(process);
-      if(Process32First(snapshot, &process)) {
-        do {
-          if(process.th32ParentProcessID == data.id) {
-            HANDLE process_handle = OpenProcess(PROCESS_TERMINATE, FALSE, process.th32ProcessID);
-            if(process_handle) {
-              TerminateProcess(process_handle, 2);
-              CloseHandle(process_handle);
-            }
-          }
-        } while(Process32Next(snapshot, &process));
-      }
-      CloseHandle(snapshot);
-    }
-    TerminateProcess(data.handle, 2);
-  }
-}
-
-//Based on http://stackoverflow.com/a/1173396
-void Process::kill(id_type id, bool /*force*/) noexcept {
-  if(id == 0)
-    return;
-
-  HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
-  if(snapshot) {
-    PROCESSENTRY32 process;
-    ZeroMemory(&process, sizeof(process));
-    process.dwSize = sizeof(process);
-    if(Process32First(snapshot, &process)) {
-      do {
-        if(process.th32ParentProcessID == id) {
-          HANDLE process_handle = OpenProcess(PROCESS_TERMINATE, FALSE, process.th32ProcessID);
-          if(process_handle) {
-            TerminateProcess(process_handle, 2);
-            CloseHandle(process_handle);
-          }
-        }
-      } while(Process32Next(snapshot, &process));
-    }
-    CloseHandle(snapshot);
-  }
-  HANDLE process_handle = OpenProcess(PROCESS_TERMINATE, FALSE, id);
-  if(process_handle)
-    TerminateProcess(process_handle, 2);
-}
-
-} // namespace TinyProcessLib
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 2fa30b0..346f4c1 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -105,7 +105,8 @@ set(libclang_source
 add_library(cppast ${detail_header} ${header} ${source} ${libclang_source})
 target_compile_features(cppast PUBLIC cxx_std_11)
 target_include_directories(cppast PRIVATE ../include SYSTEM INTERFACE ../include)
-target_link_libraries(cppast PUBLIC type_safe _cppast_tiny_process _cppast_libclang)
+target_link_libraries(cppast PUBLIC type_safe tiny-process-library ${llvm_libs} clang)
+
 target_compile_definitions(cppast PUBLIC
                                 CPPAST_VERSION_MINOR="${cppast_VERSION_MINOR}"
                                 CPPAST_VERSION_MAJOR="${cppast_VERSION_MAJOR}"
diff --git a/src/libclang/libclang_parser.cpp b/src/libclang/libclang_parser.cpp
index b45290b..cdacc8a 100644
--- a/src/libclang/libclang_parser.cpp
+++ b/src/libclang/libclang_parser.cpp
@@ -83,7 +83,7 @@ libclang_compile_config::libclang_compile_config()
   remove_comments_in_macro_(false)
 {
     // set given clang binary
-    set_clang_binary(CPPAST_CLANG_BINARY);
+    set_clang_binary("clang++");
 
     // set macros to detect cppast
     define_macro("__cppast__", "libclang");
@@ -313,30 +313,13 @@ void add_default_include_dirs(libclang_compile_config& config)
 
 bool libclang_compile_config::set_clang_binary(std::string binary)
 {
-    if (is_valid_binary(binary))
-    {
-        clang_binary_ = binary;
-        add_default_include_dirs(*this);
-        return true;
-    }
-    else
-    {
-        // first search in current directory, then in PATH
-        static const char* paths[]
-            = {"./clang++",   "clang++",       "./clang++-4.0", "clang++-4.0", "./clang++-5.0",
-               "clang++-5.0", "./clang++-6.0", "clang++-6.0",   "./clang-7",   "clang-7",
-               "./clang-8",   "clang-8",       "./clang-9",     "clang-9",     "./clang-10",
-               "clang-10",    "./clang-11",    "clang-11"};
-        for (auto& p : paths)
-            if (is_valid_binary(p))
-            {
-                clang_binary_ = p;
-                add_default_include_dirs(*this);
-                return false;
-            }
-
+    if (!is_valid_binary(binary))
         throw std::invalid_argument("unable to find clang binary '" + binary + "'");
-    }
+
+
+    clang_binary_ = binary;
+    add_default_include_dirs(*this);
+    return true;
 }
 
 void libclang_compile_config::do_set_flags(cpp_standard standard, compile_flags flags)
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index 3b24dac..dc1d6d8 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -2,12 +2,6 @@
 # SPDX-License-Identifier: MIT
 # found in the top-level directory of this distribution.
 
-# Fetch catch.
-message(STATUS "Fetching catch")
-include(FetchContent)
-FetchContent_Declare(catch URL https://github.com/catchorg/Catch2/archive/v2.13.4.zip)
-FetchContent_MakeAvailable(catch)
-
 set(tests
         code_generator.cpp
         cpp_alias_template.cpp
@@ -43,7 +37,7 @@ endforeach()
 
 add_executable(cppast_test test.cpp test_parser.hpp ${tests})
 target_include_directories(cppast_test PRIVATE ${CMAKE_CURRENT_LIST_DIR}/../src ${CMAKE_CURRENT_BINARY_DIR})
-target_link_libraries(cppast_test PUBLIC cppast Catch2)
+target_link_libraries(cppast_test PUBLIC cppast)
 target_compile_definitions(cppast_test PUBLIC CPPAST_INTEGRATION_FILE="${CMAKE_CURRENT_SOURCE_DIR}/integration.cpp"
                                               CPPAST_COMPILE_COMMANDS="${CMAKE_BINARY_DIR}")
 
diff --git a/tool/CMakeLists.txt b/tool/CMakeLists.txt
index 5dfa27a..f228e83 100644
--- a/tool/CMakeLists.txt
+++ b/tool/CMakeLists.txt
@@ -3,5 +3,5 @@
 # found in the top-level directory of this distribution.
 
 add_executable(cppast_tool main.cpp)
-target_link_libraries(cppast_tool PUBLIC cppast cxxopts)
+target_link_libraries(cppast_tool PUBLIC cppast)
 set_target_properties(cppast_tool PROPERTIES CXX_STANDARD 11 OUTPUT_NAME cppast)
diff --git a/tool/main.cpp b/tool/main.cpp
index f0f3a1e..866a135 100644
--- a/tool/main.cpp
+++ b/tool/main.cpp
@@ -228,8 +228,6 @@ try
     {
         std::cout << "cppast version " << CPPAST_VERSION_STRING << "\n";
         std::cout << "Copyright (C) Jonathan Müller 2017-2019 <jonathanmueller.dev@gmail.com>\n";
-        std::cout << '\n';
-        std::cout << "Using libclang version " << CPPAST_CLANG_VERSION_STRING << '\n';
     }
     else if (!options.count("file") || options["file"].as<std::string>().empty())
     {
-- 
2.37.1

