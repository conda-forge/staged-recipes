From b020d13822452aba81ec521efc50e42015dce14c Mon Sep 17 00:00:00 2001
From: "H. Vetinari" <h.vetinari@gmx.com>
Date: Fri, 11 Mar 2022 19:04:01 +1100
Subject: [PATCH 2/2] point osi-symbols to correct lib

---
 mip/cbc.py | 140 ++++++++++++++++++++++++++---------------------------
 1 file changed, 70 insertions(+), 70 deletions(-)

diff --git a/mip/cbc.py b/mip/cbc.py
index 3b68f1e..5aa4402 100644
--- a/mip/cbc.py
+++ b/mip/cbc.py
@@ -565,11 +565,11 @@ INT_PARAM_CLIQUE_MERGING = 18
 INT_PARAM_MAX_NODES_NOT_IMPROV_FS = 19
 
 
-Osi_getNumCols = cbclib.Osi_getNumCols
-Osi_getColSolution = cbclib.Osi_getColSolution
-Osi_getIntegerTolerance = cbclib.Osi_getIntegerTolerance
-Osi_isInteger = cbclib.Osi_isInteger
-Osi_isProvenOptimal = cbclib.Osi_isProvenOptimal
+Osi_getNumCols = osilib.Osi_getNumCols
+Osi_getColSolution = osilib.Osi_getColSolution
+Osi_getIntegerTolerance = osilib.Osi_getIntegerTolerance
+Osi_isInteger = osilib.Osi_isInteger
+Osi_isProvenOptimal = osilib.Osi_isProvenOptimal
 Cbc_setIntParam = cbclib.Cbc_setIntParam
 Cbc_setDblParam = cbclib.Cbc_setDblParam
 Cbc_getSolverPtr = cbclib.Cbc_getSolverPtr
@@ -583,16 +583,16 @@ Cbc_computeFeatures = cbclib.Cbc_computeFeatures
 Cbc_nFeatures = cbclib.Cbc_nFeatures
 Cbc_featureName = cbclib.Cbc_featureName
 
-OsiCuts_new = cbclib.OsiCuts_new
-OsiCuts_addRowCut = cbclib.OsiCuts_addRowCut
-OsiCuts_addGlobalRowCut = cbclib.OsiCuts_addGlobalRowCut
-OsiCuts_sizeRowCuts = cbclib.OsiCuts_sizeRowCuts
-OsiCuts_nzRowCut = cbclib.OsiCuts_nzRowCut
-OsiCuts_idxRowCut = cbclib.OsiCuts_idxRowCut
-OsiCuts_coefRowCut = cbclib.OsiCuts_coefRowCut
-OsiCuts_rhsRowCut = cbclib.OsiCuts_rhsRowCut
-OsiCuts_senseRowCut = cbclib.OsiCuts_senseRowCut
-OsiCuts_delete = cbclib.OsiCuts_delete
+OsiCuts_new = osilib.OsiCuts_new
+OsiCuts_addRowCut = osilib.OsiCuts_addRowCut
+OsiCuts_addGlobalRowCut = osilib.OsiCuts_addGlobalRowCut
+OsiCuts_sizeRowCuts = osilib.OsiCuts_sizeRowCuts
+OsiCuts_nzRowCut = osilib.OsiCuts_nzRowCut
+OsiCuts_idxRowCut = osilib.OsiCuts_idxRowCut
+OsiCuts_coefRowCut = osilib.OsiCuts_coefRowCut
+OsiCuts_rhsRowCut = osilib.OsiCuts_rhsRowCut
+OsiCuts_senseRowCut = osilib.OsiCuts_senseRowCut
+OsiCuts_delete = osilib.OsiCuts_delete
 
 
 def cbc_set_parameter(model: Solver, param: str, value: str):
@@ -977,9 +977,9 @@ class SolverCbc(Solver):
         # get name indexes from an osi problem
         def cbc_get_osi_name_indexes(osi_solver) -> Dict[str, int]:
             nameIdx = {}
-            n = cbclib.Osi_getNumCols(osi_solver)
+            n = osilib.Osi_getNumCols(osi_solver)
             for i in range(n):
-                cbclib.Osi_getColName(osi_solver, i, self.__name_spacec, MAX_NAME_SIZE)
+                osilib.Osi_getColName(osi_solver, i, self.__name_spacec, MAX_NAME_SIZE)
                 cname = ffi.string(self.__name_spacec).decode("utf-8")
                 nameIdx[cname] = i
 
@@ -1704,7 +1704,7 @@ class SolverOsi(Solver):
             self.owns_solver = False
         else:
             self.owns_solver = True
-            self.osi = cbclib.Osi_newSolver()
+            self.osi = osilib.Osi_newSolver()
         self.__relaxed = False
 
         # name indexes, created if necessary
@@ -1717,11 +1717,11 @@ class SolverOsi(Solver):
         self.__pi = EmptyRowSol(model)
         self.__obj_val = None
 
-        if cbclib.Osi_isProvenOptimal(self.osi):
-            self.__x = cbclib.Osi_getColSolution(self.osi)
-            self.__rc = cbclib.Osi_getReducedCost(self.osi)
-            self.__pi = cbclib.Osi_getRowPrice(self.osi)
-            self.__obj_val = cbclib.Osi_getObjValue(self.osi)
+        if osilib.Osi_isProvenOptimal(self.osi):
+            self.__x = osilib.Osi_getColSolution(self.osi)
+            self.__rc = osilib.Osi_getReducedCost(self.osi)
+            self.__pi = osilib.Osi_getRowPrice(self.osi)
+            self.__obj_val = osilib.Osi_getObjValue(self.osi)
 
     def __clear_sol(self: "SolverOsi"):
         self.__x = EmptyVarSol(self.model)
@@ -1731,7 +1731,7 @@ class SolverOsi(Solver):
 
     def __del__(self):
         if self.owns_solver:
-            cbclib.Osi_deleteSolver(self.osi)
+            osilib.Osi_deleteSolver(self.osi)
 
     def add_var(
         self,
@@ -1755,7 +1755,7 @@ class SolverOsi(Solver):
         isInt = (
             CHAR_ONE if var_type.upper() == "B" or var_type.upper() == "I" else CHAR_ZERO
         )
-        cbclib.Osi_addCol(
+        osilib.Osi_addCol(
             self.osi,
             name.encode("utf-8"),
             lb,
@@ -1780,7 +1780,7 @@ class SolverOsi(Solver):
 
         namestr = name.encode("utf-8")
         mp = self.osi
-        cbclib.Osi_addRow(mp, namestr, numnz, cind, cval, sense, rhs)
+        osilib.Osi_addRow(mp, namestr, numnz, cind, cval, sense, rhs)
 
     def add_cut(self, lin_expr: LinExpr):
         if self.osi_cutsp != ffi.NULL:
@@ -1827,7 +1827,7 @@ class SolverOsi(Solver):
         raise NotImplementedError("Not available in OsiSolver")
 
     def get_objective(self) -> LinExpr:
-        obj = cbclib.Osi_getObjCoefficients(self.osi)
+        obj = osilib.Osi_getObjCoefficients(self.osi)
         if obj == ffi.NULL:
             raise ParameterNotAvailable("Error getting objective function coefficients")
         return (
@@ -1848,30 +1848,30 @@ class SolverOsi(Solver):
     def optimize(self) -> OptimizationStatus:
         if self.__relaxed or self.num_int() == 0:
             # linear optimization
-            if cbclib.Osi_isProvenOptimal(self.osi):
-                cbclib.Osi_resolve(self.osi)
+            if osilib.Osi_isProvenOptimal(self.osi):
+                osilib.Osi_resolve(self.osi)
             else:
-                cbclib.Osi_initialSolve(self.osi)
+                osilib.Osi_initialSolve(self.osi)
         else:
-            cbclib.Osi_branchAndBound(self.osi)
+            osilib.Osi_branchAndBound(self.osi)
 
-        if cbclib.Osi_isProvenOptimal(self.osi):
-            self.__x = cbclib.Osi_getColSolution(self.osi)
-            self.__rc = cbclib.Osi_getReducedCost(self.osi)
-            self.__pi = cbclib.Osi_getRowPrice(self.osi)
-            self.__obj_val = cbclib.Osi_getObjValue(self.osi)
+        if osilib.Osi_isProvenOptimal(self.osi):
+            self.__x = osilib.Osi_getColSolution(self.osi)
+            self.__rc = osilib.Osi_getReducedCost(self.osi)
+            self.__pi = osilib.Osi_getRowPrice(self.osi)
+            self.__obj_val = osilib.Osi_getObjValue(self.osi)
 
         return self.get_status()
 
     def get_status(self) -> OptimizationStatus:
-        if cbclib.Osi_isProvenOptimal(self.osi):
+        if osilib.Osi_isProvenOptimal(self.osi):
             return OptimizationStatus.OPTIMAL
 
-        if cbclib.Osi_isProvenPrimalInfeasible(
+        if osilib.Osi_isProvenPrimalInfeasible(
             self.osi
-        ) or cbclib.Osi_isProvenDualInfeasible(self.osi):
+        ) or osilib.Osi_isProvenDualInfeasible(self.osi):
             return OptimizationStatus.INFEASIBLE
-        elif cbclib.Osi_isAbandoned(self.osi):
+        elif osilib.Osi_isAbandoned(self.osi):
             return OptimizationStatus.ERROR
         return OptimizationStatus.LOADED
 
@@ -1887,13 +1887,13 @@ class SolverOsi(Solver):
         raise NotImplementedError("Not available in OsiSolver")
 
     def get_num_solutions(self) -> int:
-        if cbclib.Osi_isProvenOptimal(self.osi):
+        if osilib.Osi_isProvenOptimal(self.osi):
             return 1
 
         return 0
 
     def get_objective_sense(self) -> str:
-        objs = cbclib.Osi_getObjSense(self.osi)
+        objs = osilib.Osi_getObjSense(self.osi)
         if objs <= -0.5:
             return MAXIMIZE
 
@@ -1901,9 +1901,9 @@ class SolverOsi(Solver):
 
     def set_objective_sense(self, sense: str):
         if sense.strip().upper() == MAXIMIZE.strip().upper():
-            cbclib.Osi_setObjSense(self.osi, -1.0)
+            osilib.Osi_setObjSense(self.osi, -1.0)
         elif sense.strip().upper() == MINIMIZE.strip().upper():
-            cbclib.Osi_setObjSense(self.osi, 1.0)
+            osilib.Osi_setObjSense(self.osi, 1.0)
         else:
             raise ValueError(
                 "Unknown sense: {}, use {} or {}".format(sense, MAXIMIZE, MINIMIZE)
@@ -1915,16 +1915,16 @@ class SolverOsi(Solver):
     def set_objective(self, lin_expr: "LinExpr", sense: str = ""):
         # collecting variable coefficients
         for var, coeff in lin_expr.expr.items():
-            cbclib.Osi_setObjCoeff(self.osi, var.idx, coeff)
+            osilib.Osi_setObjCoeff(self.osi, var.idx, coeff)
 
         # objective function constant
         self._objconst = lin_expr.const
 
         # setting objective sense
         if sense == MAXIMIZE:
-            cbclib.Osi_setObjSense(self.osi, -1.0)
+            osilib.Osi_setObjSense(self.osi, -1.0)
         elif sense == MINIMIZE:
-            cbclib.Osi_setObjSense(self.osi, 1.0)
+            osilib.Osi_setObjSense(self.osi, 1.0)
 
     def set_objective_const(self, const: numbers.Real):
         raise NotImplementedError("Still not implemented in OsiSolver")
@@ -1971,16 +1971,16 @@ class SolverOsi(Solver):
         raise NotImplementedError("Not available in OsiSolver")
 
     def num_cols(self) -> int:
-        return cbclib.Osi_getNumCols(self.osi)
+        return osilib.Osi_getNumCols(self.osi)
 
     def num_rows(self) -> int:
-        return cbclib.Osi_getNumRows(self.osi)
+        return osilib.Osi_getNumRows(self.osi)
 
     def num_nz(self) -> int:
-        return cbclib.Osi_getNumElements(self.osi)
+        return osilib.Osi_getNumElements(self.osi)
 
     def num_int(self) -> int:
-        return cbclib.Osi_getNumIntegers(self.osi)
+        return osilib.Osi_getNumIntegers(self.osi)
 
     def get_emphasis(self) -> SearchEmphasis:
         raise NotImplementedError("Not available in OsiSolver")
@@ -2014,17 +2014,17 @@ class SolverOsi(Solver):
 
     # Constraint-related getters/setters
     def constr_get_expr(self, constr: Constr) -> LinExpr:
-        numnz = cbclib.Osi_getRowNz(self.osi, constr.idx)
+        numnz = osilib.Osi_getRowNz(self.osi, constr.idx)
 
-        ridx = cbclib.Osi_getRowIndices(self.osi, constr.idx)
+        ridx = osilib.Osi_getRowIndices(self.osi, constr.idx)
         if ridx == ffi.NULL:
             raise ParameterNotAvailable("Error getting row indices.")
-        rcoef = cbclib.Osi_getRowCoeffs(self.osi, constr.idx)
+        rcoef = osilib.Osi_getRowCoeffs(self.osi, constr.idx)
         if rcoef == ffi.NULL:
             raise ParameterNotAvailable("Error getting row coefficients.")
 
-        rhs = cbclib.Osi_getRowRHS(self.osi, constr.idx)
-        rsense = cbclib.Osi_getRowSense(self.osi, constr.idx).decode("utf-8").upper()
+        rhs = osilib.Osi_getRowRHS(self.osi, constr.idx)
+        rsense = osilib.Osi_getRowSense(self.osi, constr.idx).decode("utf-8").upper()
         sense = ""
         if rsense == "E":
             sense = EQUAL
@@ -2046,7 +2046,7 @@ class SolverOsi(Solver):
 
     def constr_get_name(self, idx: int) -> str:
         namep = self.__name_space
-        cbclib.Osi_getRowName(self.osi, idx, namep, MAX_NAME_SIZE)
+        osilib.Osi_getRowName(self.osi, idx, namep, MAX_NAME_SIZE)
         return ffi.string(namep).decode("utf-8")
 
     def remove_constrs(self, constrsList: List[int]):
@@ -2072,13 +2072,13 @@ class SolverOsi(Solver):
             OptimizationStatus.FEASIBLE,
         ]:
             return None
-        pac = cbclib.Osi_getRowActivity(self.osi)
+        pac = osilib.Osi_getRowActivity(self.osi)
         if pac == ffi.NULL:
             return None
-        rhs = cbclib.Osi_getRowRHS(self.osi, constr.idx)
+        rhs = osilib.Osi_getRowRHS(self.osi, constr.idx)
         activity = pac[constr.idx]
 
-        sense = cbclib.Osi_getRowSense(self.osi, constr.idx).decode("utf-8").upper()
+        sense = osilib.Osi_getRowSense(self.osi, constr.idx).decode("utf-8").upper()
 
         if sense in "<L":
             return rhs - activity
@@ -2100,30 +2100,30 @@ class SolverOsi(Solver):
         )
 
     def var_get_lb(self, var: "Var") -> numbers.Real:
-        x = cbclib.Osi_getColLower(self.osi)
+        x = osilib.Osi_getColLower(self.osi)
         return x[var.idx]
 
     def var_set_lb(self, var: "Var", value: numbers.Real):
-        cbclib.Osi_setColLower(self.osi, var.idx, value)
+        osilib.Osi_setColLower(self.osi, var.idx, value)
 
     def var_get_ub(self, var: "Var") -> numbers.Real:
-        x = cbclib.Osi_getColUpper(self.osi)
+        x = osilib.Osi_getColUpper(self.osi)
         return x[var.idx]
 
     def var_set_ub(self, var: "Var", value: numbers.Real):
-        cbclib.Osi_setColUpper(self.osi, var.idx, value)
+        osilib.Osi_setColUpper(self.osi, var.idx, value)
 
     def var_get_obj(self, var: "Var") -> numbers.Real:
-        obj = cbclib.Osi_getObjCoefficients(self.osi)
+        obj = osilib.Osi_getObjCoefficients(self.osi)
         if obj == ffi.NULL:
             raise ParameterNotAvailable("Error getting objective function coefficients")
         return obj[var.idx]
 
     def var_set_obj(self, var: "Var", value: numbers.Real):
-        cbclib.Osi_setObjCoef(self.osi, var.idx, value)
+        osilib.Osi_setObjCoef(self.osi, var.idx, value)
 
     def var_get_var_type(self, var: "Var") -> str:
-        isInt = cbclib.Osi_isInteger(self.osi, var.idx)
+        isInt = osilib.Osi_isInteger(self.osi, var.idx)
         if isInt:
             lb = self.var_get_lb(var)
             ub = self.var_get_ub(var)
@@ -2140,10 +2140,10 @@ class SolverOsi(Solver):
             return
         if cv == CONTINUOUS:
             if value in (INTEGER, BINARY):
-                cbclib.Osi_setInteger(self.osi, var.idx)
+                osilib.Osi_setInteger(self.osi, var.idx)
         else:
             if value == CONTINUOUS:
-                cbclib.Osi_setContinuous(self.osi, var.idx)
+                osilib.Osi_setContinuous(self.osi, var.idx)
         if value == BINARY:
             # checking bounds
             if var.lb != 0.0:
@@ -2181,7 +2181,7 @@ class SolverOsi(Solver):
 
     def var_get_name(self, idx: int) -> str:
         namep = self.__name_space
-        cbclib.Osi_getColName(self.osi, idx, namep, MAX_NAME_SIZE)
+        osilib.Osi_getColName(self.osi, idx, namep, MAX_NAME_SIZE)
         return ffi.string(namep).decode("utf-8")
 
     def remove_vars(self, varsList: List[int]):
